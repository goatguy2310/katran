
bpf/native/balancer.bpf:     file format elf64-x86-64


Disassembly of section xdp:

0000000000000000 <balancer_ingress>:

  return XDP_TX;
}

SEC(PROG_SEC_NAME)
int balancer_ingress(struct xdp_md* ctx) {
       0:	f3 0f 1e fa          	endbr64
       4:	55                   	push   %rbp
       5:	48 89 e5             	mov    %rsp,%rbp
       8:	41 57                	push   %r15
       a:	41 56                	push   %r14
       c:	41 55                	push   %r13
       e:	41 54                	push   %r12
      10:	53                   	push   %rbx
      11:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  void* data = (void*)(long)ctx->data;
      18:	4c 8b 37             	mov    (%rdi),%r14
  void* data_end = (void*)(long)ctx->data_end;
      1b:	4c 8b 67 08          	mov    0x8(%rdi),%r12
  struct ethhdr* eth = data;
  __u32 eth_proto;
  __u32 nh_off;
  nh_off = sizeof(struct ethhdr);

  if (data + nh_off > data_end) {
      1f:	49 8d 46 0e          	lea    0xe(%r14),%rax
      23:	bb 01 00 00 00       	mov    $0x1,%ebx
      28:	4c 39 e0             	cmp    %r12,%rax
      2b:	0f 87 6a 1c 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
      31:	49 89 fd             	mov    %rdi,%r13
    // bogus packet, len less than minimum ethernet frame size
    return XDP_DROP;
  }

  eth_proto = eth->h_proto;
      34:	41 0f b7 4e 0c       	movzwl 0xc(%r14),%ecx

  if (eth_proto == BE_ETH_P_IP) {
      39:	81 f9 86 dd 00 00    	cmp    $0xdd86,%ecx
      3f:	0f 84 41 01 00 00    	je     186 <balancer_ingress+0x186>
      45:	bb 02 00 00 00       	mov    $0x2,%ebx
      4a:	66 83 f9 08          	cmp    $0x8,%cx
      4e:	0f 85 47 1c 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
  struct packet_description pckt = {};
      54:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
      5b:	00 
      5c:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
      63:	00 
      64:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
      6b:	00 
      6c:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
      73:	00 
      74:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
      7b:	00 
      7c:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
      83:	00 
  struct vip_definition vip = {};
      84:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%rbp)
      8b:	00 00 00 
      8e:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
      95:	00 00 00 00 
      99:	48 c7 85 58 ff ff ff 	movq   $0x0,-0xa8(%rbp)
      a0:	00 00 00 00 
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
    }
  } else {
    iph = data + nh_off;
    if (iph + 1 > data_end) {
      a4:	4d 8d 7e 22          	lea    0x22(%r14),%r15
      a8:	4d 39 e7             	cmp    %r12,%r15
      ab:	0f 87 e5 1b 00 00    	ja     1c96 <balancer_ingress+0x1c96>
      return XDP_DROP;
    }
    // ihl contains len of ipv4 header in 32bit words
    if (iph->ihl != 5) {
      b1:	8a 00                	mov    (%rax),%al
      b3:	24 0f                	and    $0xf,%al
      b5:	3c 05                	cmp    $0x5,%al
      b7:	0f 85 d9 1b 00 00    	jne    1c96 <balancer_ingress+0x1c96>
      // if len of ipv4 hdr is not equal to 20bytes that means that header
      // contains ip options, and we dont support em
      return XDP_DROP;
    }
    pckt->tos = iph->tos;
      bd:	41 8a 46 0f          	mov    0xf(%r14),%al
      c1:	88 45 ad             	mov    %al,-0x53(%rbp)
    *protocol = iph->protocol;
      c4:	41 8a 4e 17          	mov    0x17(%r14),%cl
    pckt->flow.proto = *protocol;
      c8:	88 4d a4             	mov    %cl,-0x5c(%rbp)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;

    if (iph->frag_off & PCKT_FRAGMENTED) {
      cb:	41 0f b7 46 14       	movzwl 0x14(%r14),%eax
      d0:	a9 3f ff 00 00       	test   $0xff3f,%eax
      d5:	0f 85 bb 1b 00 00    	jne    1c96 <balancer_ingress+0x1c96>
      db:	41 0f b7 76 10       	movzwl 0x10(%r14),%esi
      // we drop fragmented packets.
      return XDP_DROP;
    }
    if (*protocol == IPPROTO_ICMP) {
      e0:	80 f9 01             	cmp    $0x1,%cl
      e3:	0f 85 64 03 00 00    	jne    44d <balancer_ingress+0x44d>
    __u64 off,
    struct packet_description* pckt) {
  struct icmphdr* icmp_hdr;
  struct iphdr* iph;
  icmp_hdr = data + off;
  if (icmp_hdr + 1 > data_end) {
      e9:	49 8d 5e 2a          	lea    0x2a(%r14),%rbx
      ed:	4c 39 e3             	cmp    %r12,%rbx
      f0:	0f 87 a0 1b 00 00    	ja     1c96 <balancer_ingress+0x1c96>
    return XDP_DROP;
  }
  if (icmp_hdr->type == ICMP_ECHO) {
      f6:	41 8a 0f             	mov    (%r15),%cl
      f9:	80 f9 03             	cmp    $0x3,%cl
      fc:	0f 84 46 07 00 00    	je     848 <balancer_ingress+0x848>
     102:	bb 02 00 00 00       	mov    $0x2,%ebx
     107:	80 f9 08             	cmp    $0x8,%cl
     10a:	0f 85 8b 1b 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
     110:	44 0f b7 c6          	movzwl %si,%r8d
  icmp_hdr->type = ICMP_ECHOREPLY;
     114:	41 c6 46 22 00       	movb   $0x0,0x22(%r14)
  icmp_hdr->checksum += 0x0008;
     119:	66 41 83 46 24 08    	addw   $0x8,0x24(%r14)
  iph->ttl = DEFAULT_TTL;
     11f:	41 c6 46 16 40       	movb   $0x40,0x16(%r14)
  iph->daddr = iph->saddr;
     124:	41 8b 4e 1a          	mov    0x1a(%r14),%ecx
  tmp_addr = iph->daddr;
     128:	41 8b 76 1e          	mov    0x1e(%r14),%esi
  iph->daddr = iph->saddr;
     12c:	41 89 4e 1e          	mov    %ecx,0x1e(%r14)
  iph->saddr = tmp_addr;
     130:	41 89 76 1a          	mov    %esi,0x1a(%r14)
    void* iph,
    __u64* csum) {
  __u16* next_iph_u16 = (__u16*)iph;
#pragma clang loop unroll(full)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    *csum += *next_iph_u16++;
     134:	41 0f b7 7e 0e       	movzwl 0xe(%r14),%edi
     139:	41 0f b7 5e 12       	movzwl 0x12(%r14),%ebx
     13e:	45 0f b7 4e 16       	movzwl 0x16(%r14),%r9d
     143:	0f b7 d6             	movzwl %si,%edx
     146:	48 c1 ee 10          	shr    $0x10,%rsi
     14a:	48 01 d6             	add    %rdx,%rsi
     14d:	0f b7 d1             	movzwl %cx,%edx
     150:	48 01 f2             	add    %rsi,%rdx
     153:	48 c1 e9 10          	shr    $0x10,%rcx
     157:	48 01 d1             	add    %rdx,%rcx
     15a:	48 01 f9             	add    %rdi,%rcx
     15d:	4c 01 c1             	add    %r8,%rcx
     160:	48 01 d9             	add    %rbx,%rcx
     163:	48 01 c1             	add    %rax,%rcx
     166:	4c 01 c9             	add    %r9,%rcx
    if (csum >> 16)
     169:	48 89 c8             	mov    %rcx,%rax
     16c:	48 c1 e8 10          	shr    $0x10,%rax
     170:	0f b7 d1             	movzwl %cx,%edx
     173:	48 01 c2             	add    %rax,%rdx
     176:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
     17d:	48 0f 42 d1          	cmovb  %rcx,%rdx
     181:	e9 01 02 00 00       	jmp    387 <balancer_ingress+0x387>
  struct packet_description pckt = {};
     186:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
     18d:	00 
     18e:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
     195:	00 
     196:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
     19d:	00 
     19e:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
     1a5:	00 
     1a6:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
     1ad:	00 
     1ae:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
     1b5:	00 
  struct vip_definition vip = {};
     1b6:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%rbp)
     1bd:	00 00 00 
     1c0:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
     1c7:	00 00 00 00 
     1cb:	48 c7 85 58 ff ff ff 	movq   $0x0,-0xa8(%rbp)
     1d2:	00 00 00 00 
    if (ip6h + 1 > data_end) {
     1d6:	4d 8d 7e 36          	lea    0x36(%r14),%r15
     1da:	4d 39 e7             	cmp    %r12,%r15
     1dd:	0f 87 b3 1a 00 00    	ja     1c96 <balancer_ingress+0x1c96>
    *protocol = ip6h->nexthdr;
     1e3:	41 8a 46 14          	mov    0x14(%r14),%al
    pckt->flow.proto = *protocol;
     1e7:	88 45 a4             	mov    %al,-0x5c(%rbp)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1ea:	41 8a 4e 0e          	mov    0xe(%r14),%cl
     1ee:	c0 e1 04             	shl    $0x4,%cl
     1f1:	88 4d ad             	mov    %cl,-0x53(%rbp)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1f4:	41 8a 56 0f          	mov    0xf(%r14),%dl
     1f8:	c0 ea 04             	shr    $0x4,%dl
     1fb:	08 ca                	or     %cl,%dl
     1fd:	88 55 ad             	mov    %dl,-0x53(%rbp)
    if (*protocol == IPPROTO_FRAGMENT) {
     200:	3c 2c                	cmp    $0x2c,%al
     202:	0f 84 8e 1a 00 00    	je     1c96 <balancer_ingress+0x1c96>
     208:	41 0f b7 7e 12       	movzwl 0x12(%r14),%edi
     20d:	3c 3a                	cmp    $0x3a,%al
     20f:	0f 85 9d 00 00 00    	jne    2b2 <balancer_ingress+0x2b2>
  if (icmp_hdr + 1 > data_end) {
     215:	49 8d 46 3e          	lea    0x3e(%r14),%rax
     219:	4c 39 e0             	cmp    %r12,%rax
     21c:	0f 87 74 1a 00 00    	ja     1c96 <balancer_ingress+0x1c96>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     222:	41 8a 07             	mov    (%r15),%al
     225:	3c 02                	cmp    $0x2,%al
     227:	0f 84 f6 02 00 00    	je     523 <balancer_ingress+0x523>
     22d:	3c 01                	cmp    $0x1,%al
     22f:	0f 84 30 03 00 00    	je     565 <balancer_ingress+0x565>
     235:	bb 02 00 00 00       	mov    $0x2,%ebx
     23a:	3c 80                	cmp    $0x80,%al
     23c:	0f 85 59 1a 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
     242:	41 c6 46 36 81       	movb   $0x81,0x36(%r14)
     247:	66 41 83 46 38 ff    	addw   $0xffff,0x38(%r14)
     24d:	41 c6 46 15 40       	movb   $0x40,0x15(%r14)
     252:	49 8b 46 16          	mov    0x16(%r14),%rax
     256:	49 8b 4e 1e          	mov    0x1e(%r14),%rcx
     25a:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
     25e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     262:	49 8b 46 26          	mov    0x26(%r14),%rax
     266:	49 8b 4e 2e          	mov    0x2e(%r14),%rcx
     26a:	49 89 46 16          	mov    %rax,0x16(%r14)
     26e:	49 89 4e 1e          	mov    %rcx,0x1e(%r14)
     272:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
     276:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
     27a:	49 89 46 26          	mov    %rax,0x26(%r14)
     27e:	49 89 4e 2e          	mov    %rcx,0x2e(%r14)
     282:	41 0f b7 46 0a       	movzwl 0xa(%r14),%eax
     287:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
     28b:	41 8b 46 06          	mov    0x6(%r14),%eax
     28f:	89 45 b8             	mov    %eax,-0x48(%rbp)
     292:	41 8b 06             	mov    (%r14),%eax
     295:	41 89 46 06          	mov    %eax,0x6(%r14)
     299:	41 0f b7 46 04       	movzwl 0x4(%r14),%eax
     29e:	66 41 89 46 0a       	mov    %ax,0xa(%r14)
     2a3:	8b 45 b8             	mov    -0x48(%rbp),%eax
     2a6:	41 89 06             	mov    %eax,(%r14)
     2a9:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
     2ad:	e9 4d 01 00 00       	jmp    3ff <balancer_ingress+0x3ff>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     2b2:	49 8b 4e 16          	mov    0x16(%r14),%rcx
     2b6:	49 8b 56 1e          	mov    0x1e(%r14),%rdx
     2ba:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
     2be:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2c2:	49 8b 4e 26          	mov    0x26(%r14),%rcx
     2c6:	49 8b 56 2e          	mov    0x2e(%r14),%rdx
     2ca:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
     2ce:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
    void* data,
    void* data_end,
    __u64 off,
    struct packet_description* pckt,
    __u8 protocol) {
  if (protocol == IPPROTO_ICMPV6) {
     2d2:	3c 01                	cmp    $0x1,%al
     2d4:	0f 85 34 01 00 00    	jne    40e <balancer_ingress+0x40e>
  if (icmp_hdr + 1 > data_end) {
     2da:	49 8d 5e 3e          	lea    0x3e(%r14),%rbx
     2de:	4c 39 e3             	cmp    %r12,%rbx
     2e1:	0f 87 af 19 00 00    	ja     1c96 <balancer_ingress+0x1c96>
  if (icmp_hdr->type == ICMP_ECHO) {
     2e7:	41 8a 07             	mov    (%r15),%al
     2ea:	3c 03                	cmp    $0x3,%al
     2ec:	0f 84 5f 04 00 00    	je     751 <balancer_ingress+0x751>
     2f2:	bb 02 00 00 00       	mov    $0x2,%ebx
     2f7:	3c 08                	cmp    $0x8,%al
     2f9:	0f 85 9c 19 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2ff:	49 8d 46 2a          	lea    0x2a(%r14),%rax
     303:	bb 01 00 00 00       	mov    $0x1,%ebx
       sizeof(struct icmphdr)) > data_end) {
     308:	4c 39 e0             	cmp    %r12,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     30b:	0f 87 8a 19 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
  icmp_hdr->type = ICMP_ECHOREPLY;
     311:	41 c6 46 22 00       	movb   $0x0,0x22(%r14)
  icmp_hdr->checksum += 0x0008;
     316:	66 41 83 46 24 08    	addw   $0x8,0x24(%r14)
  iph->ttl = DEFAULT_TTL;
     31c:	41 c6 46 16 40       	movb   $0x40,0x16(%r14)
  iph->daddr = iph->saddr;
     321:	41 8b 46 1a          	mov    0x1a(%r14),%eax
  tmp_addr = iph->daddr;
     325:	41 8b 4e 1e          	mov    0x1e(%r14),%ecx
  iph->daddr = iph->saddr;
     329:	41 89 46 1e          	mov    %eax,0x1e(%r14)
  iph->saddr = tmp_addr;
     32d:	41 89 4e 1a          	mov    %ecx,0x1a(%r14)
    *csum += *next_iph_u16++;
     331:	45 0f b7 4e 0e       	movzwl 0xe(%r14),%r9d
     336:	41 0f b7 76 10       	movzwl 0x10(%r14),%esi
     33b:	41 0f b7 7e 12       	movzwl 0x12(%r14),%edi
     340:	41 0f b7 5e 14       	movzwl 0x14(%r14),%ebx
     345:	45 0f b7 46 16       	movzwl 0x16(%r14),%r8d
     34a:	0f b7 d1             	movzwl %cx,%edx
     34d:	48 c1 e9 10          	shr    $0x10,%rcx
     351:	48 01 d1             	add    %rdx,%rcx
     354:	0f b7 d0             	movzwl %ax,%edx
     357:	48 01 ca             	add    %rcx,%rdx
     35a:	48 c1 e8 10          	shr    $0x10,%rax
     35e:	48 01 d0             	add    %rdx,%rax
     361:	4c 01 c8             	add    %r9,%rax
     364:	48 01 f0             	add    %rsi,%rax
     367:	48 01 f8             	add    %rdi,%rax
     36a:	48 01 d8             	add    %rbx,%rax
     36d:	4c 01 c0             	add    %r8,%rax
    if (csum >> 16)
     370:	48 89 c1             	mov    %rax,%rcx
     373:	48 c1 e9 10          	shr    $0x10,%rcx
     377:	0f b7 d0             	movzwl %ax,%edx
     37a:	48 01 ca             	add    %rcx,%rdx
     37d:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
     383:	48 0f 42 d0          	cmovb  %rax,%rdx
     387:	48 89 d0             	mov    %rdx,%rax
     38a:	48 c1 e8 10          	shr    $0x10,%rax
     38e:	0f b7 ca             	movzwl %dx,%ecx
     391:	48 01 c1             	add    %rax,%rcx
     394:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     39b:	48 0f 42 ca          	cmovb  %rdx,%rcx
     39f:	48 89 c8             	mov    %rcx,%rax
     3a2:	48 c1 e8 10          	shr    $0x10,%rax
     3a6:	0f b7 d1             	movzwl %cx,%edx
     3a9:	48 01 c2             	add    %rax,%rdx
     3ac:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
     3b3:	48 0f 42 d1          	cmovb  %rcx,%rdx
     3b7:	89 d0                	mov    %edx,%eax
     3b9:	c1 e8 10             	shr    $0x10,%eax
     3bc:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     3c3:	b9 00 00 01 00       	mov    $0x10000,%ecx
     3c8:	0f 43 c8             	cmovae %eax,%ecx
     3cb:	01 d1                	add    %edx,%ecx
     3cd:	f7 d1                	not    %ecx
     3cf:	66 41 89 4e 18       	mov    %cx,0x18(%r14)
     3d4:	41 0f b7 46 0a       	movzwl 0xa(%r14),%eax
     3d9:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
     3dd:	41 8b 46 06          	mov    0x6(%r14),%eax
     3e1:	89 45 c0             	mov    %eax,-0x40(%rbp)
     3e4:	41 8b 06             	mov    (%r14),%eax
     3e7:	41 89 46 06          	mov    %eax,0x6(%r14)
     3eb:	41 0f b7 46 04       	movzwl 0x4(%r14),%eax
     3f0:	66 41 89 46 0a       	mov    %ax,0xa(%r14)
     3f5:	8b 45 c0             	mov    -0x40(%rbp),%eax
     3f8:	41 89 06             	mov    %eax,(%r14)
     3fb:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
     3ff:	66 41 89 46 04       	mov    %ax,0x4(%r14)
     404:	bb 03 00 00 00       	mov    $0x3,%ebx
     409:	e9 8d 18 00 00       	jmp    1c9b <balancer_ingress+0x1c9b>
     40e:	31 c9                	xor    %ecx,%ecx
     410:	bb 02 00 00 00       	mov    $0x2,%ebx
  if (protocol == IPPROTO_TCP) {
     415:	3c 11                	cmp    $0x11,%al
     417:	0f 84 87 00 00 00    	je     4a4 <balancer_ingress+0x4a4>
     41d:	3c 06                	cmp    $0x6,%al
     41f:	0f 85 76 18 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
  tcp = data + off;
     425:	49 8d 46 66          	lea    0x66(%r14),%rax
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     429:	f6 c1 01             	test   $0x1,%cl
  tcp = data + off;
     42c:	49 0f 44 c7          	cmove  %r15,%rax
  if (tcp + 1 > data_end) {
     430:	48 8d 50 14          	lea    0x14(%rax),%rdx
     434:	4c 39 e2             	cmp    %r12,%rdx
     437:	0f 87 59 18 00 00    	ja     1c96 <balancer_ingress+0x1c96>
  if (tcp->syn) {
     43d:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     441:	74 79                	je     4bc <balancer_ingress+0x4bc>
    pckt->flags |= F_SYN_SET;
     443:	89 ca                	mov    %ecx,%edx
     445:	80 ca 02             	or     $0x2,%dl
     448:	88 55 ac             	mov    %dl,-0x54(%rbp)
     44b:	eb 6f                	jmp    4bc <balancer_ingress+0x4bc>
      return FURTHER_PROCESSING;
    } else {
      pckt->flow.src = iph->saddr;
     44d:	41 8b 46 1a          	mov    0x1a(%r14),%eax
     451:	89 45 80             	mov    %eax,-0x80(%rbp)
      pckt->flow.dst = iph->daddr;
     454:	41 8b 46 1e          	mov    0x1e(%r14),%eax
     458:	89 45 90             	mov    %eax,-0x70(%rbp)
  if (protocol == IPPROTO_ICMPV6) {
     45b:	80 f9 3a             	cmp    $0x3a,%cl
     45e:	75 7c                	jne    4dc <balancer_ingress+0x4dc>
  if (icmp_hdr + 1 > data_end) {
     460:	49 8d 46 2a          	lea    0x2a(%r14),%rax
     464:	4c 39 e0             	cmp    %r12,%rax
     467:	0f 87 29 18 00 00    	ja     1c96 <balancer_ingress+0x1c96>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     46d:	41 8a 07             	mov    (%r15),%al
     470:	3c 02                	cmp    $0x2,%al
     472:	0f 84 47 06 00 00    	je     abf <balancer_ingress+0xabf>
     478:	3c 01                	cmp    $0x1,%al
     47a:	0f 84 81 06 00 00    	je     b01 <balancer_ingress+0xb01>
     480:	bb 02 00 00 00       	mov    $0x2,%ebx
     485:	3c 80                	cmp    $0x80,%al
     487:	0f 85 0e 18 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     48d:	49 8d 46 3e          	lea    0x3e(%r14),%rax
     491:	bb 01 00 00 00       	mov    $0x1,%ebx
       sizeof(struct icmp6hdr)) > data_end) {
     496:	4c 39 e0             	cmp    %r12,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     499:	0f 86 a3 fd ff ff    	jbe    242 <balancer_ingress+0x242>
     49f:	e9 f7 17 00 00       	jmp    1c9b <balancer_ingress+0x1c9b>
  udp = data + off;
     4a4:	49 8d 46 66          	lea    0x66(%r14),%rax
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     4a8:	f6 c1 01             	test   $0x1,%cl
  udp = data + off;
     4ab:	49 0f 44 c7          	cmove  %r15,%rax
  if (udp + 1 > data_end) {
     4af:	48 8d 50 08          	lea    0x8(%rax),%rdx
     4b3:	4c 39 e2             	cmp    %r12,%rdx
     4b6:	0f 87 da 17 00 00    	ja     1c96 <balancer_ingress+0x1c96>
     4bc:	f6 c1 01             	test   $0x1,%cl
     4bf:	89 7d b4             	mov    %edi,-0x4c(%rbp)
     4c2:	0f 85 df 00 00 00    	jne    5a7 <balancer_ingress+0x5a7>
     4c8:	0f b7 10             	movzwl (%rax),%edx
     4cb:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
     4cf:	66 89 55 a0          	mov    %dx,-0x60(%rbp)
     4d3:	48 83 c0 02          	add    $0x2,%rax
     4d7:	e9 d7 00 00 00       	jmp    5b3 <balancer_ingress+0x5b3>
     4dc:	31 c0                	xor    %eax,%eax
     4de:	bb 02 00 00 00       	mov    $0x2,%ebx
     4e3:	80 f9 11             	cmp    $0x11,%cl
     4e6:	0f 84 25 03 00 00    	je     811 <balancer_ingress+0x811>
     4ec:	80 f9 06             	cmp    $0x6,%cl
     4ef:	0f 85 a6 17 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
  tcp = data + off;
     4f5:	49 8d 4e 3e          	lea    0x3e(%r14),%rcx
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     4f9:	a8 01                	test   $0x1,%al
  tcp = data + off;
     4fb:	49 0f 44 cf          	cmove  %r15,%rcx
  if (tcp + 1 > data_end) {
     4ff:	48 8d 51 14          	lea    0x14(%rcx),%rdx
     503:	4c 39 e2             	cmp    %r12,%rdx
     506:	0f 87 8a 17 00 00    	ja     1c96 <balancer_ingress+0x1c96>
  if (tcp->syn) {
     50c:	f6 41 0d 02          	testb  $0x2,0xd(%rcx)
     510:	0f 84 12 03 00 00    	je     828 <balancer_ingress+0x828>
    pckt->flags |= F_SYN_SET;
     516:	89 c2                	mov    %eax,%edx
     518:	80 ca 02             	or     $0x2,%dl
     51b:	88 55 ac             	mov    %dl,-0x54(%rbp)
     51e:	e9 05 03 00 00       	jmp    828 <balancer_ingress+0x828>
     523:	89 fb                	mov    %edi,%ebx
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     525:	c7 45 c0 0c 02 00 00 	movl   $0x20c,-0x40(%rbp)
        bpf_map_lookup_elem(&stats, &stats_key);
     52c:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     533:	88 ff ff 
     536:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     53a:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     541:	ff d0                	call   *%rax
    if (!icmp_ptb_v6_stats) {
     543:	48 85 c0             	test   %rax,%rax
     546:	0f 84 4a 17 00 00    	je     1c96 <balancer_ingress+0x1c96>
    icmp_ptb_v6_stats->v1 += 1;
     54c:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     550:	41 8b 4e 3a          	mov    0x3a(%r14),%ecx
     554:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     556:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     55c:	77 05                	ja     563 <balancer_ingress+0x563>
      icmp_ptb_v6_stats->v2 += 1;
     55e:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
     563:	89 df                	mov    %ebx,%edi
  if (ip6h + 1 > data_end) {
     565:	49 8d 46 66          	lea    0x66(%r14),%rax
     569:	4c 39 e0             	cmp    %r12,%rax
     56c:	0f 87 24 17 00 00    	ja     1c96 <balancer_ingress+0x1c96>
  pckt->flow.proto = ip6h->nexthdr;
     572:	41 8a 46 44          	mov    0x44(%r14),%al
     576:	88 45 a4             	mov    %al,-0x5c(%rbp)
  pckt->flags |= F_ICMP;
     579:	8a 4d ac             	mov    -0x54(%rbp),%cl
     57c:	80 c9 01             	or     $0x1,%cl
     57f:	88 4d ac             	mov    %cl,-0x54(%rbp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     582:	49 8b 56 56          	mov    0x56(%r14),%rdx
     586:	49 8b 76 5e          	mov    0x5e(%r14),%rsi
     58a:	48 89 55 80          	mov    %rdx,-0x80(%rbp)
     58e:	48 89 75 88          	mov    %rsi,-0x78(%rbp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     592:	49 8b 56 46          	mov    0x46(%r14),%rdx
     596:	49 8b 76 4e          	mov    0x4e(%r14),%rsi
     59a:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
     59e:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
     5a2:	e9 69 fe ff ff       	jmp    410 <balancer_ingress+0x410>
     5a7:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     5ab:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
     5af:	66 89 55 a0          	mov    %dx,-0x60(%rbp)
     5b3:	0f b7 00             	movzwl (%rax),%eax
     5b6:	66 89 41 02          	mov    %ax,0x2(%rcx)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     5ba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
     5be:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
     5c2:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
     5c9:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  vip.port = pckt.flow.port16[1];
     5d0:	0f b7 45 a2          	movzwl -0x5e(%rbp),%eax
     5d4:	66 89 85 68 ff ff ff 	mov    %ax,-0x98(%rbp)
  vip.proto = pckt.flow.proto;
     5db:	8a 45 a4             	mov    -0x5c(%rbp),%al
     5de:	88 85 6a ff ff ff    	mov    %al,-0x96(%rbp)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     5e4:	48 bf 00 60 27 43 81 	movabs $0xffff888143276000,%rdi
     5eb:	88 ff ff 
     5ee:	48 8d b5 58 ff ff ff 	lea    -0xa8(%rbp),%rsi
     5f5:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     5fc:	ff d0                	call   *%rax
  if (!vip_info) {
     5fe:	48 85 c0             	test   %rax,%rax
     601:	0f 84 ca 01 00 00    	je     7d1 <balancer_ingress+0x7d1>
  if (data_end - data > MAX_PCKT_SIZE) {
     607:	4c 89 e1             	mov    %r12,%rcx
     60a:	4c 29 f1             	sub    %r14,%rcx
     60d:	bb 01 00 00 00       	mov    $0x1,%ebx
     612:	48 81 f9 ea 05 00 00 	cmp    $0x5ea,%rcx
     619:	0f 8f 7c 16 00 00    	jg     1c9b <balancer_ingress+0x1c9b>
     61f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
     623:	c7 85 4c ff ff ff 00 	movl   $0x200,-0xb4(%rbp)
     62a:	02 00 00 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     62d:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     634:	88 ff ff 
     637:	48 8d b5 4c ff ff ff 	lea    -0xb4(%rbp),%rsi
     63e:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     645:	ff d0                	call   *%rax
  if (!data_stats) {
     647:	48 85 c0             	test   %rax,%rax
     64a:	0f 84 46 16 00 00    	je     1c96 <balancer_ingress+0x1c96>
     650:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  data_stats->v1 += 1;
     657:	48 83 00 01          	addq   $0x1,(%rax)
     65b:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     65f:	f6 03 01             	testb  $0x1,(%rbx)
     662:	74 06                	je     66a <balancer_ingress+0x66a>
    pckt.flow.port16[0] = 0;
     664:	66 c7 45 a0 00 00    	movw   $0x0,-0x60(%rbp)
  vip_num = vip_info->vip_num;
     66a:	8b 43 04             	mov    0x4(%rbx),%eax
     66d:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
     673:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
     679:	48 c7 c0 90 d5 09 9f 	mov    $0xffffffff9f09d590,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     680:	ff d0                	call   *%rax
     682:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     688:	48 bf 00 50 01 d4 81 	movabs $0xffff8881d4015000,%rdi
     68f:	88 ff ff 
     692:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
     699:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     6a0:	ff d0                	call   *%rax
     6a2:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  if (!lru_map) {
     6a9:	48 85 c0             	test   %rax,%rax
     6ac:	75 40                	jne    6ee <balancer_ingress+0x6ee>
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
     6ae:	c7 45 c0 03 02 00 00 	movl   $0x203,-0x40(%rbp)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     6b5:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     6bc:	88 ff ff 
     6bf:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     6c3:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     6ca:	ff d0                	call   *%rax
    if (!lru_stats) {
     6cc:	48 85 c0             	test   %rax,%rax
     6cf:	0f 84 c1 15 00 00    	je     1c96 <balancer_ingress+0x1c96>
    lru_stats->v1 += 1;
     6d5:	48 83 00 01          	addq   $0x1,(%rax)
     6d9:	48 b8 00 58 27 43 81 	movabs $0xffff888143275800,%rax
     6e0:	88 ff ff 
     6e3:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
     6ea:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  if ((vip_info->flags & F_QUIC_VIP)) {
     6ee:	f6 03 04             	testb  $0x4,(%rbx)
     6f1:	48 89 de             	mov    %rbx,%rsi
     6f4:	0f 84 8b 04 00 00    	je     b85 <balancer_ingress+0xb85>
    bool is_icmp = (pckt.flags & F_ICMP);
     6fa:	f6 45 ac 01          	testb  $0x1,-0x54(%rbp)
    if (is_icmp) {
     6fe:	0f 85 41 04 00 00    	jne    b45 <balancer_ingress+0xb45>
      __u32 quic_packets_stats_key = 0;
     704:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     70b:	48 bf 00 e0 b9 7e 81 	movabs $0xffff88817eb9e000,%rdi
     712:	88 ff ff 
     715:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
     719:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     720:	ff d0                	call   *%rax
      if (!quic_packets_stats) {
     722:	48 85 c0             	test   %rax,%rax
     725:	0f 84 6b 15 00 00    	je     1c96 <balancer_ingress+0x1c96>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     72b:	49 83 c6 66          	add    $0x66,%r14
  bool is_icmp = (pckt->flags & F_ICMP);
     72f:	f6 45 ac 01          	testb  $0x1,-0x54(%rbp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     733:	4d 0f 44 f7          	cmove  %r15,%r14
     737:	49 8d 7e 09          	lea    0x9(%r14),%rdi
     73b:	4c 39 e7             	cmp    %r12,%rdi
     73e:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
     742:	0f 86 a6 04 00 00    	jbe    bee <balancer_ingress+0xbee>
        quic_packets_stats->ch_routed += 1;
     748:	48 83 00 01          	addq   $0x1,(%rax)
     74c:	e9 34 04 00 00       	jmp    b85 <balancer_ingress+0xb85>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     751:	41 80 7e 37 04       	cmpb   $0x4,0x37(%r14)
     756:	75 3d                	jne    795 <balancer_ingress+0x795>
     758:	89 7d b4             	mov    %edi,-0x4c(%rbp)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     75b:	c7 45 c0 0d 02 00 00 	movl   $0x20d,-0x40(%rbp)
        bpf_map_lookup_elem(&stats, &stats_key);
     762:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     769:	88 ff ff 
     76c:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     770:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     777:	ff d0                	call   *%rax
    if (!icmp_ptb_v4_stats) {
     779:	48 85 c0             	test   %rax,%rax
     77c:	0f 84 14 15 00 00    	je     1c96 <balancer_ingress+0x1c96>
    icmp_ptb_v4_stats->v1 += 1;
     782:	48 83 00 01          	addq   $0x1,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     786:	41 80 7e 3c 04       	cmpb   $0x4,0x3c(%r14)
     78b:	77 05                	ja     792 <balancer_ingress+0x792>
      icmp_ptb_v4_stats->v2 += 1;
     78d:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
     792:	8b 7d b4             	mov    -0x4c(%rbp),%edi
  if (iph + 1 > data_end) {
     795:	49 8d 46 52          	lea    0x52(%r14),%rax
     799:	4c 39 e0             	cmp    %r12,%rax
     79c:	0f 87 f4 14 00 00    	ja     1c96 <balancer_ingress+0x1c96>
  if (iph->ihl != 5) {
     7a2:	8a 03                	mov    (%rbx),%al
     7a4:	24 0f                	and    $0xf,%al
     7a6:	3c 05                	cmp    $0x5,%al
     7a8:	0f 85 e8 14 00 00    	jne    1c96 <balancer_ingress+0x1c96>
  pckt->flow.proto = iph->protocol;
     7ae:	41 8a 46 47          	mov    0x47(%r14),%al
     7b2:	88 45 a4             	mov    %al,-0x5c(%rbp)
  pckt->flags |= F_ICMP;
     7b5:	8a 4d ac             	mov    -0x54(%rbp),%cl
     7b8:	80 c9 01             	or     $0x1,%cl
     7bb:	88 4d ac             	mov    %cl,-0x54(%rbp)
  pckt->flow.src = iph->daddr;
     7be:	41 8b 56 4e          	mov    0x4e(%r14),%edx
     7c2:	89 55 80             	mov    %edx,-0x80(%rbp)
  pckt->flow.dst = iph->saddr;
     7c5:	41 8b 56 4a          	mov    0x4a(%r14),%edx
     7c9:	89 55 90             	mov    %edx,-0x70(%rbp)
     7cc:	e9 3f fc ff ff       	jmp    410 <balancer_ingress+0x410>
    vip.port = 0;
     7d1:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%rbp)
     7d8:	00 00 
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     7da:	48 bf 00 60 27 43 81 	movabs $0xffff888143276000,%rdi
     7e1:	88 ff ff 
     7e4:	48 8d b5 58 ff ff ff 	lea    -0xa8(%rbp),%rsi
     7eb:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     7f2:	ff d0                	call   *%rax
    if (!vip_info) {
     7f4:	48 85 c0             	test   %rax,%rax
     7f7:	0f 84 9e 14 00 00    	je     1c9b <balancer_ingress+0x1c9b>
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     7fd:	f6 00 88             	testb  $0x88,(%rax)
     800:	0f 85 01 fe ff ff    	jne    607 <balancer_ingress+0x607>
      pckt.flow.port16[1] = 0;
     806:	66 c7 45 a2 00 00    	movw   $0x0,-0x5e(%rbp)
     80c:	e9 f6 fd ff ff       	jmp    607 <balancer_ingress+0x607>
  udp = data + off;
     811:	49 8d 4e 3e          	lea    0x3e(%r14),%rcx
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     815:	a8 01                	test   $0x1,%al
  udp = data + off;
     817:	49 0f 44 cf          	cmove  %r15,%rcx
  if (udp + 1 > data_end) {
     81b:	48 8d 51 08          	lea    0x8(%rcx),%rdx
     81f:	4c 39 e2             	cmp    %r12,%rdx
     822:	0f 87 6e 14 00 00    	ja     1c96 <balancer_ingress+0x1c96>
     828:	66 89 75 b4          	mov    %si,-0x4c(%rbp)
     82c:	a8 01                	test   $0x1,%al
     82e:	0f 85 95 00 00 00    	jne    8c9 <balancer_ingress+0x8c9>
     834:	0f b7 11             	movzwl (%rcx),%edx
     837:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     83b:	66 89 55 a0          	mov    %dx,-0x60(%rbp)
     83f:	48 83 c1 02          	add    $0x2,%rcx
     843:	e9 8d 00 00 00       	jmp    8d5 <balancer_ingress+0x8d5>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     848:	41 80 7e 23 04       	cmpb   $0x4,0x23(%r14)
     84d:	75 3f                	jne    88e <balancer_ingress+0x88e>
     84f:	66 89 75 b4          	mov    %si,-0x4c(%rbp)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     853:	c7 45 c0 0d 02 00 00 	movl   $0x20d,-0x40(%rbp)
        bpf_map_lookup_elem(&stats, &stats_key);
     85a:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     861:	88 ff ff 
     864:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     868:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     86f:	ff d0                	call   *%rax
    if (!icmp_ptb_v4_stats) {
     871:	48 85 c0             	test   %rax,%rax
     874:	0f 84 1c 14 00 00    	je     1c96 <balancer_ingress+0x1c96>
    icmp_ptb_v4_stats->v1 += 1;
     87a:	48 83 00 01          	addq   $0x1,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     87e:	41 80 7e 28 04       	cmpb   $0x4,0x28(%r14)
     883:	77 05                	ja     88a <balancer_ingress+0x88a>
      icmp_ptb_v4_stats->v2 += 1;
     885:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
     88a:	0f b7 75 b4          	movzwl -0x4c(%rbp),%esi
  if (iph + 1 > data_end) {
     88e:	49 8d 46 3e          	lea    0x3e(%r14),%rax
     892:	4c 39 e0             	cmp    %r12,%rax
     895:	0f 87 fb 13 00 00    	ja     1c96 <balancer_ingress+0x1c96>
  if (iph->ihl != 5) {
     89b:	8a 03                	mov    (%rbx),%al
     89d:	24 0f                	and    $0xf,%al
     89f:	3c 05                	cmp    $0x5,%al
     8a1:	0f 85 ef 13 00 00    	jne    1c96 <balancer_ingress+0x1c96>
  pckt->flow.proto = iph->protocol;
     8a7:	41 8a 4e 33          	mov    0x33(%r14),%cl
     8ab:	88 4d a4             	mov    %cl,-0x5c(%rbp)
  pckt->flags |= F_ICMP;
     8ae:	8a 45 ac             	mov    -0x54(%rbp),%al
     8b1:	0c 01                	or     $0x1,%al
     8b3:	88 45 ac             	mov    %al,-0x54(%rbp)
  pckt->flow.src = iph->daddr;
     8b6:	41 8b 56 3a          	mov    0x3a(%r14),%edx
     8ba:	89 55 80             	mov    %edx,-0x80(%rbp)
  pckt->flow.dst = iph->saddr;
     8bd:	41 8b 56 36          	mov    0x36(%r14),%edx
     8c1:	89 55 90             	mov    %edx,-0x70(%rbp)
     8c4:	e9 15 fc ff ff       	jmp    4de <balancer_ingress+0x4de>
     8c9:	0f b7 51 02          	movzwl 0x2(%rcx),%edx
     8cd:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     8d1:	66 89 55 a0          	mov    %dx,-0x60(%rbp)
     8d5:	0f b7 09             	movzwl (%rcx),%ecx
     8d8:	66 89 48 02          	mov    %cx,0x2(%rax)
    vip.vip = pckt.flow.dst;
     8dc:	8b 45 90             	mov    -0x70(%rbp),%eax
     8df:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%rbp)
  vip.port = pckt.flow.port16[1];
     8e5:	0f b7 45 a2          	movzwl -0x5e(%rbp),%eax
     8e9:	66 89 85 68 ff ff ff 	mov    %ax,-0x98(%rbp)
  vip.proto = pckt.flow.proto;
     8f0:	8a 45 a4             	mov    -0x5c(%rbp),%al
     8f3:	88 85 6a ff ff ff    	mov    %al,-0x96(%rbp)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     8f9:	48 bf 00 60 27 43 81 	movabs $0xffff888143276000,%rdi
     900:	88 ff ff 
     903:	48 8d b5 58 ff ff ff 	lea    -0xa8(%rbp),%rsi
     90a:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     911:	ff d0                	call   *%rax
  if (!vip_info) {
     913:	48 85 c0             	test   %rax,%rax
     916:	0f 84 63 01 00 00    	je     a7f <balancer_ingress+0xa7f>
  if (data_end - data > MAX_PCKT_SIZE) {
     91c:	4c 89 e1             	mov    %r12,%rcx
     91f:	4c 29 f1             	sub    %r14,%rcx
     922:	bb 01 00 00 00       	mov    $0x1,%ebx
     927:	48 81 f9 ea 05 00 00 	cmp    $0x5ea,%rcx
     92e:	0f 8f 67 13 00 00    	jg     1c9b <balancer_ingress+0x1c9b>
     934:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
     938:	c7 85 4c ff ff ff 00 	movl   $0x200,-0xb4(%rbp)
     93f:	02 00 00 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     942:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     949:	88 ff ff 
     94c:	48 8d b5 4c ff ff ff 	lea    -0xb4(%rbp),%rsi
     953:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     95a:	ff d0                	call   *%rax
  if (!data_stats) {
     95c:	48 85 c0             	test   %rax,%rax
     95f:	0f 84 31 13 00 00    	je     1c96 <balancer_ingress+0x1c96>
     965:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  data_stats->v1 += 1;
     96c:	48 83 00 01          	addq   $0x1,(%rax)
     970:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     974:	f6 03 01             	testb  $0x1,(%rbx)
     977:	74 06                	je     97f <balancer_ingress+0x97f>
    pckt.flow.port16[0] = 0;
     979:	66 c7 45 a0 00 00    	movw   $0x0,-0x60(%rbp)
  vip_num = vip_info->vip_num;
     97f:	8b 43 04             	mov    0x4(%rbx),%eax
     982:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
     988:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
     98e:	48 c7 c0 90 d5 09 9f 	mov    $0xffffffff9f09d590,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     995:	ff d0                	call   *%rax
     997:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     99d:	48 bf 00 50 01 d4 81 	movabs $0xffff8881d4015000,%rdi
     9a4:	88 ff ff 
     9a7:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
     9ae:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     9b5:	ff d0                	call   *%rax
     9b7:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  if (!lru_map) {
     9be:	48 85 c0             	test   %rax,%rax
     9c1:	75 40                	jne    a03 <balancer_ingress+0xa03>
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
     9c3:	c7 45 c0 03 02 00 00 	movl   $0x203,-0x40(%rbp)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     9ca:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     9d1:	88 ff ff 
     9d4:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     9d8:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     9df:	ff d0                	call   *%rax
    if (!lru_stats) {
     9e1:	48 85 c0             	test   %rax,%rax
     9e4:	0f 84 ac 12 00 00    	je     1c96 <balancer_ingress+0x1c96>
    lru_stats->v1 += 1;
     9ea:	48 83 00 01          	addq   $0x1,(%rax)
     9ee:	48 b8 00 58 27 43 81 	movabs $0xffff888143275800,%rax
     9f5:	88 ff ff 
     9f8:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
     9ff:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  if ((vip_info->flags & F_QUIC_VIP)) {
     a03:	f6 03 04             	testb  $0x4,(%rbx)
     a06:	48 89 d8             	mov    %rbx,%rax
     a09:	0f 84 ae 0c 00 00    	je     16bd <balancer_ingress+0x16bd>
    bool is_icmp = (pckt.flags & F_ICMP);
     a0f:	f6 45 ac 01          	testb  $0x1,-0x54(%rbp)
    if (is_icmp) {
     a13:	0f 85 45 02 00 00    	jne    c5e <balancer_ingress+0xc5e>
      __u32 quic_packets_stats_key = 0;
     a19:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     a20:	48 bf 00 e0 b9 7e 81 	movabs $0xffff88817eb9e000,%rdi
     a27:	88 ff ff 
     a2a:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
     a2e:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     a35:	ff d0                	call   *%rax
      if (!quic_packets_stats) {
     a37:	48 85 c0             	test   %rax,%rax
     a3a:	0f 84 56 12 00 00    	je     1c96 <balancer_ingress+0x1c96>
     a40:	48 89 c3             	mov    %rax,%rbx
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     a43:	49 83 c6 3e          	add    $0x3e,%r14
  bool is_icmp = (pckt->flags & F_ICMP);
     a47:	f6 45 ac 01          	testb  $0x1,-0x54(%rbp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     a4b:	4d 0f 44 f7          	cmove  %r15,%r14
     a4f:	49 8d 46 09          	lea    0x9(%r14),%rax
     a53:	4c 39 e0             	cmp    %r12,%rax
     a56:	0f 87 59 0c 00 00    	ja     16b5 <balancer_ingress+0x16b5>
     a5c:	49 83 c6 08          	add    $0x8,%r14
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     a60:	41 0f b6 0e          	movzbl (%r14),%ecx
     a64:	f6 c1 80             	test   $0x80,%cl
     a67:	0f 85 0b 09 00 00    	jne    1378 <balancer_ingress+0x1378>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     a6d:	49 83 c6 09          	add    $0x9,%r14
     a71:	4d 39 e6             	cmp    %r12,%r14
     a74:	0f 86 e9 09 00 00    	jbe    1463 <balancer_ingress+0x1463>
     a7a:	e9 36 0c 00 00       	jmp    16b5 <balancer_ingress+0x16b5>
    vip.port = 0;
     a7f:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%rbp)
     a86:	00 00 
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     a88:	48 bf 00 60 27 43 81 	movabs $0xffff888143276000,%rdi
     a8f:	88 ff ff 
     a92:	48 8d b5 58 ff ff ff 	lea    -0xa8(%rbp),%rsi
     a99:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     aa0:	ff d0                	call   *%rax
    if (!vip_info) {
     aa2:	48 85 c0             	test   %rax,%rax
     aa5:	0f 84 f0 11 00 00    	je     1c9b <balancer_ingress+0x1c9b>
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     aab:	f6 00 88             	testb  $0x88,(%rax)
     aae:	0f 85 68 fe ff ff    	jne    91c <balancer_ingress+0x91c>
      pckt.flow.port16[1] = 0;
     ab4:	66 c7 45 a2 00 00    	movw   $0x0,-0x5e(%rbp)
     aba:	e9 5d fe ff ff       	jmp    91c <balancer_ingress+0x91c>
     abf:	89 f3                	mov    %esi,%ebx
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     ac1:	c7 45 c0 0c 02 00 00 	movl   $0x20c,-0x40(%rbp)
        bpf_map_lookup_elem(&stats, &stats_key);
     ac8:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     acf:	88 ff ff 
     ad2:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     ad6:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     add:	ff d0                	call   *%rax
    if (!icmp_ptb_v6_stats) {
     adf:	48 85 c0             	test   %rax,%rax
     ae2:	0f 84 ae 11 00 00    	je     1c96 <balancer_ingress+0x1c96>
    icmp_ptb_v6_stats->v1 += 1;
     ae8:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     aec:	41 8b 4e 26          	mov    0x26(%r14),%ecx
     af0:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     af2:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     af8:	77 05                	ja     aff <balancer_ingress+0xaff>
      icmp_ptb_v6_stats->v2 += 1;
     afa:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
     aff:	89 de                	mov    %ebx,%esi
  if (ip6h + 1 > data_end) {
     b01:	49 8d 46 52          	lea    0x52(%r14),%rax
     b05:	4c 39 e0             	cmp    %r12,%rax
     b08:	0f 87 88 11 00 00    	ja     1c96 <balancer_ingress+0x1c96>
     b0e:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  pckt->flow.proto = ip6h->nexthdr;
     b12:	41 8a 4e 30          	mov    0x30(%r14),%cl
     b16:	88 4d a4             	mov    %cl,-0x5c(%rbp)
  pckt->flags |= F_ICMP;
     b19:	8a 45 ac             	mov    -0x54(%rbp),%al
     b1c:	0c 01                	or     $0x1,%al
     b1e:	88 45 ac             	mov    %al,-0x54(%rbp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     b21:	49 8b 5e 42          	mov    0x42(%r14),%rbx
     b25:	49 8b 7e 4a          	mov    0x4a(%r14),%rdi
     b29:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
     b2d:	48 89 5d 80          	mov    %rbx,-0x80(%rbp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     b31:	49 8b 5e 32          	mov    0x32(%r14),%rbx
     b35:	49 8b 7e 3a          	mov    0x3a(%r14),%rdi
     b39:	48 89 1a             	mov    %rbx,(%rdx)
     b3c:	48 89 7a 08          	mov    %rdi,0x8(%rdx)
     b40:	e9 99 f9 ff ff       	jmp    4de <balancer_ingress+0x4de>
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
     b45:	c7 45 c0 0b 02 00 00 	movl   $0x20b,-0x40(%rbp)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b4c:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     b53:	88 ff ff 
     b56:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     b5a:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     b61:	ff d0                	call   *%rax
      if (!data_stats) {
     b63:	48 85 c0             	test   %rax,%rax
     b66:	0f 84 2a 11 00 00    	je     1c96 <balancer_ingress+0x1c96>
      data_stats->v1 += 1;
     b6c:	48 83 00 01          	addq   $0x1,(%rax)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     b70:	41 8a 4e 37          	mov    0x37(%r14),%cl
     b74:	80 c1 fd             	add    $0xfd,%cl
     b77:	80 f9 01             	cmp    $0x1,%cl
     b7a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     b7e:	77 05                	ja     b85 <balancer_ingress+0xb85>
        data_stats->v2 += 1;
     b80:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  original_sport = pckt.flow.port16[0];
     b85:	44 0f b7 75 a0       	movzwl -0x60(%rbp),%r14d
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     b8a:	f6 45 ac 02          	testb  $0x2,-0x54(%rbp)
     b8e:	75 56                	jne    be6 <balancer_ingress+0xbe6>
        !(vip_info->flags & F_LRU_BYPASS)) {
     b90:	f6 06 02             	testb  $0x2,(%rsi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     b93:	75 51                	jne    be6 <balancer_ingress+0xbe6>
     b95:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
     b99:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     ba0:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
     ba7:	ff d0                	call   *%rax
  if (!dst_lru) {
     ba9:	48 85 c0             	test   %rax,%rax
     bac:	74 30                	je     bde <balancer_ingress+0xbde>
     bae:	48 89 c3             	mov    %rax,%rbx
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
     bb1:	80 7d a4 11          	cmpb   $0x11,-0x5c(%rbp)
     bb5:	0f 85 39 01 00 00    	jne    cf4 <balancer_ingress+0xcf4>
     bbb:	48 c7 c0 30 d6 09 9f 	mov    $0xffffffff9f09d630,%rax
    cur_time = bpf_ktime_get_ns();
     bc2:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
     bc4:	48 89 c1             	mov    %rax,%rcx
     bc7:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
     bcb:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
     bd2:	00 00 00 
     bd5:	48 39 d1             	cmp    %rdx,%rcx
     bd8:	0f 86 12 01 00 00    	jbe    cf0 <balancer_ingress+0xcf0>
     bde:	45 31 ff             	xor    %r15d,%r15d
     be1:	e9 36 01 00 00       	jmp    d1c <balancer_ingress+0xd1c>
     be6:	45 31 ff             	xor    %r15d,%r15d
     be9:	e9 32 01 00 00       	jmp    d20 <balancer_ingress+0xd20>
     bee:	49 83 c6 08          	add    $0x8,%r14
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     bf2:	41 0f b6 0e          	movzbl (%r14),%ecx
     bf6:	f6 c1 80             	test   $0x80,%cl
     bf9:	0f 85 a4 00 00 00    	jne    ca3 <balancer_ingress+0xca3>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     bff:	49 83 c6 09          	add    $0x9,%r14
     c03:	4d 39 e6             	cmp    %r12,%r14
     c06:	0f 87 3c fb ff ff    	ja     748 <balancer_ingress+0x748>
  if (!connId) {
     c0c:	48 85 ff             	test   %rdi,%rdi
     c0f:	0f 84 33 fb ff ff    	je     748 <balancer_ingress+0x748>
     c15:	48 89 c3             	mov    %rax,%rbx
  __u8 connIdVersion = (connId[0] >> 6);
     c18:	0f b6 0f             	movzbl (%rdi),%ecx
     c1b:	89 ca                	mov    %ecx,%edx
     c1d:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     c20:	80 fa 03             	cmp    $0x3,%dl
     c23:	0f 84 c0 07 00 00    	je     13e9 <balancer_ingress+0x13e9>
     c29:	80 fa 02             	cmp    $0x2,%dl
     c2c:	0f 84 dc 07 00 00    	je     140e <balancer_ingress+0x140e>
     c32:	80 fa 01             	cmp    $0x1,%dl
     c35:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
     c39:	48 89 d8             	mov    %rbx,%rax
     c3c:	0f 85 06 fb ff ff    	jne    748 <balancer_ingress+0x748>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     c42:	83 e1 3f             	and    $0x3f,%ecx
     c45:	48 c1 e1 0a          	shl    $0xa,%rcx
     c49:	0f b6 57 01          	movzbl 0x1(%rdi),%edx
     c4d:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
     c51:	8a 47 02             	mov    0x2(%rdi),%al
     c54:	c0 e8 06             	shr    $0x6,%al
     c57:	b2 01                	mov    $0x1,%dl
     c59:	e9 c8 07 00 00       	jmp    1426 <balancer_ingress+0x1426>
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
     c5e:	c7 45 c0 0b 02 00 00 	movl   $0x20b,-0x40(%rbp)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c65:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     c6c:	88 ff ff 
     c6f:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     c73:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     c7a:	ff d0                	call   *%rax
      if (!data_stats) {
     c7c:	48 85 c0             	test   %rax,%rax
     c7f:	0f 84 11 10 00 00    	je     1c96 <balancer_ingress+0x1c96>
      data_stats->v1 += 1;
     c85:	48 83 00 01          	addq   $0x1,(%rax)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     c89:	41 8a 4e 23          	mov    0x23(%r14),%cl
     c8d:	80 e1 fd             	and    $0xfd,%cl
     c90:	80 f9 01             	cmp    $0x1,%cl
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     c93:	0f 85 20 0a 00 00    	jne    16b9 <balancer_ingress+0x16b9>
        data_stats->v2 += 1;
     c99:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
     c9e:	e9 16 0a 00 00       	jmp    16b9 <balancer_ingress+0x16b9>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     ca3:	49 8d 56 0e          	lea    0xe(%r14),%rdx
     ca7:	4c 39 e2             	cmp    %r12,%rdx
     caa:	0f 87 98 fa ff ff    	ja     748 <balancer_ingress+0x748>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     cb0:	f6 c1 20             	test   $0x20,%cl
     cb3:	0f 85 0c 07 00 00    	jne    13c5 <balancer_ingress+0x13c5>
        quic_packets_stats->cid_initial += 1;
     cb9:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
     cbe:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
     cc4:	89 45 c0             	mov    %eax,-0x40(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     cc7:	48 bf 00 c0 75 c4 81 	movabs $0xffff8881c475c000,%rdi
     cce:	88 ff ff 
     cd1:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     cd5:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     cdc:	ff d0                	call   *%rax
  if (!per_vip_stats) {
     cde:	48 85 c0             	test   %rax,%rax
     ce1:	74 04                	je     ce7 <balancer_ingress+0xce7>
    per_vip_stats->v1 += 1;
     ce3:	48 83 00 01          	addq   $0x1,(%rax)
     ce7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
     ceb:	e9 95 fe ff ff       	jmp    b85 <balancer_ingress+0xb85>
    dst_lru->atime = cur_time;
     cf0:	48 89 43 08          	mov    %rax,0x8(%rbx)
  key = dst_lru->pos;
     cf4:	8b 03                	mov    (%rbx),%eax
     cf6:	45 31 ff             	xor    %r15d,%r15d
     cf9:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
     cff:	89 45 a8             	mov    %eax,-0x58(%rbp)
  *real = bpf_map_lookup_elem(&reals, &key);
     d02:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
     d06:	48 b9 00 60 7b 40 03 	movabs $0xffffc903407b6000,%rcx
     d0d:	c9 ff ff 
     d10:	48 8d 84 81 00 01 00 	lea    0x100(%rcx,%rax,4),%rax
     d17:	00 
     d18:	4c 0f 42 f8          	cmovb  %rax,%r15
     d1c:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     d20:	80 7d a4 11          	cmpb   $0x11,-0x5c(%rbp)
     d24:	0f 85 c9 00 00 00    	jne    df3 <balancer_ingress+0xdf3>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
     d2a:	f6 46 01 02          	testb  $0x2,0x1(%rsi)
     d2e:	0f 84 bf 00 00 00    	je     df3 <balancer_ingress+0xdf3>
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
     d34:	c7 45 c0 02 02 00 00 	movl   $0x202,-0x40(%rbp)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     d3b:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     d42:	88 ff ff 
     d45:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     d49:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     d50:	ff d0                	call   *%rax
  if (!conn_rate_stats) {
     d52:	48 85 c0             	test   %rax,%rax
     d55:	0f 84 98 00 00 00    	je     df3 <balancer_ingress+0xdf3>
     d5b:	48 89 c3             	mov    %rax,%rbx
     d5e:	48 c7 c0 30 d6 09 9f 	mov    $0xffffffff9f09d630,%rax
  *cur_time = bpf_ktime_get_ns();
     d65:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     d67:	48 89 c1             	mov    %rax,%rcx
     d6a:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
     d6e:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
     d75:	72 0d                	jb     d84 <balancer_ingress+0xd84>
    conn_rate_stats->v1 = 1;
     d77:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
     d7e:	48 89 43 08          	mov    %rax,0x8(%rbx)
     d82:	eb 12                	jmp    d96 <balancer_ingress+0xd96>
    conn_rate_stats->v1 += 1;
     d84:	48 8b 03             	mov    (%rbx),%rax
     d87:	48 83 c0 01          	add    $0x1,%rax
     d8b:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
     d8e:	48 3d 49 e8 01 00    	cmp    $0x1e849,%rax
     d94:	73 5d                	jae    df3 <balancer_ingress+0xdf3>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
     d96:	48 bf 00 58 9e 5a 81 	movabs $0xffff88815a9e5800,%rdi
     d9d:	88 ff ff 
     da0:	48 8d b5 58 ff ff ff 	lea    -0xa8(%rbp),%rsi
     da7:	48 c7 c3 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rbx
     dae:	ff d3                	call   *%rbx
    if (down_reals_map) {
     db0:	48 85 c0             	test   %rax,%rax
     db3:	74 3e                	je     df3 <balancer_ingress+0xdf3>
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
     db5:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
     db9:	48 89 c7             	mov    %rax,%rdi
     dbc:	ff d3                	call   *%rbx
      if (down_real) {
     dbe:	48 85 c0             	test   %rax,%rax
     dc1:	74 30                	je     df3 <balancer_ingress+0xdf3>
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
     dc3:	c7 45 c0 0f 02 00 00 	movl   $0x20f,-0x40(%rbp)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
     dca:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     dd1:	88 ff ff 
     dd4:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     dd8:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     ddf:	ff d0                	call   *%rax
        if (stats_data) {
     de1:	48 85 c0             	test   %rax,%rax
     de4:	0f 84 62 01 00 00    	je     f4c <balancer_ingress+0xf4c>
          stats_data->v1 += 1;
     dea:	48 83 00 01          	addq   $0x1,(%rax)
     dee:	e9 59 01 00 00       	jmp    f4c <balancer_ingress+0xf4c>
    if (!dst) {
     df3:	4d 85 ff             	test   %r15,%r15
     df6:	0f 84 50 01 00 00    	je     f4c <balancer_ingress+0xf4c>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
     dfc:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     e03:	88 ff ff 
     e06:	48 8d b5 54 ff ff ff 	lea    -0xac(%rbp),%rsi
     e0d:	49 c7 c4 30 c9 09 9f 	mov    $0xffffffff9f09c930,%r12
     e14:	41 ff d4             	call   *%r12
     e17:	bb 01 00 00 00       	mov    $0x1,%ebx
  if (!data_stats) {
     e1c:	48 85 c0             	test   %rax,%rax
     e1f:	0f 84 76 0e 00 00    	je     1c9b <balancer_ingress+0x1c9b>
     e25:	4c 89 7d d0          	mov    %r15,-0x30(%rbp)
     e29:	45 89 f7             	mov    %r14d,%r15d
     e2c:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
     e2f:	66 c1 c1 08          	rol    $0x8,%cx
  data_stats->v1 += 1;
     e33:	48 83 00 01          	addq   $0x1,(%rax)
     e37:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
  data_stats->v2 += pkt_bytes;
     e3a:	44 0f b7 f1          	movzwl %cx,%r14d
     e3e:	4c 01 70 08          	add    %r14,0x8(%rax)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
     e42:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
     e46:	48 bf 00 00 7d 40 03 	movabs $0xffffc903407d0000,%rdi
     e4d:	c9 ff ff 
     e50:	41 ff d4             	call   *%r12
  if (!data_stats) {
     e53:	48 85 c0             	test   %rax,%rax
     e56:	0f 84 3f 0e 00 00    	je     1c9b <balancer_ingress+0x1c9b>
  data_stats->v1 += 1;
     e5c:	48 83 00 01          	addq   $0x1,(%rax)
  data_stats->v2 += pkt_bytes;
     e60:	4c 01 70 08          	add    %r14,0x8(%rax)
     e64:	44 89 f8             	mov    %r15d,%eax
  pckt.flow.port16[0] = original_sport;
     e67:	66 89 45 a0          	mov    %ax,-0x60(%rbp)
     e6b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  if (dst->flags & F_IPV6) {
     e6f:	f6 40 10 01          	testb  $0x1,0x10(%rax)
     e73:	0f 85 7e 01 00 00    	jne    ff7 <balancer_ingress+0xff7>
  void* data;
  void* data_end;
  struct iphdr* iph;
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
     e79:	44 0f b7 65 82       	movzwl -0x7e(%rbp),%r12d
     e7e:	48 c7 c0 20 5c 23 a1 	mov    $0xffffffffa1235c20,%rax
  __u64 csum = 0;
  // ipip encap
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
     e85:	4c 89 ef             	mov    %r13,%rdi
     e88:	be ec ff ff ff       	mov    $0xffffffec,%esi
     e8d:	ff d0                	call   *%rax
     e8f:	85 c0                	test   %eax,%eax
     e91:	0f 85 04 0e 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
    return false;
  }
  data = (void*)(long)xdp->data;
     e97:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
     e9b:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  new_eth = data;
  iph = data + sizeof(struct ethhdr);
     e9f:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  old_eth = data + sizeof(struct iphdr);
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
     ea3:	48 39 ca             	cmp    %rcx,%rdx
     ea6:	0f 87 ef 0d 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
     eac:	48 8d 50 22          	lea    0x22(%rax),%rdx
     eb0:	48 39 ca             	cmp    %rcx,%rdx
     eb3:	0f 87 e2 0d 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
     eb9:	66 41 c1 c7 08       	rol    $0x8,%r15w
     ebe:	45 31 fc             	xor    %r15d,%r12d
     ec1:	41 c1 e4 10          	shl    $0x10,%r12d
     ec5:	41 8d 94 24 ac 10 00 	lea    0x10ac(%r12),%edx
     ecc:	00 
     ecd:	48 b9 00 d8 b9 7e 81 	movabs $0xffff88817eb9d800,%rcx
     ed4:	88 ff ff 
    return false;
  }
  memcpy(new_eth->h_dest, cval->mac, 6);
     ed7:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
     ede:	66 89 70 04          	mov    %si,0x4(%rax)
     ee2:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
     ee8:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
     eea:	8b 48 14             	mov    0x14(%rax),%ecx
     eed:	89 48 06             	mov    %ecx,0x6(%rax)
     ef0:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
     ef4:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
     ef8:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)

  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
     efe:	8a 5d ad             	mov    -0x53(%rbp),%bl
     f01:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
     f05:	8b 09                	mov    (%rcx),%ecx
    __u32 daddr,
    __u16 pkt_bytes,
    __u8 proto) {
  __u64 csum = 0;
  iph->version = 4;
  iph->ihl = 5;
     f07:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->frag_off = 0;
  iph->protocol = proto;
  iph->check = 0;
#ifdef COPY_INNER_PACKET_TOS
  iph->tos = tos;
     f0b:	88 58 0f             	mov    %bl,0xf(%rax)
     f0e:	8b 75 b4             	mov    -0x4c(%rbp),%esi
#else
  iph->tos = DEFAULT_TOS;
#endif
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
     f11:	83 c6 14             	add    $0x14,%esi
     f14:	66 c1 c6 08          	rol    $0x8,%si
     f18:	66 89 70 10          	mov    %si,0x10(%rax)
  iph->id = 0;
     f1c:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
     f23:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
     f26:	89 50 1a             	mov    %edx,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
     f29:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    *csum += *next_iph_u16++;
     f2f:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
     f33:	0f b7 f6             	movzwl %si,%esi
     f36:	0f b7 78 16          	movzwl 0x16(%rax),%edi
     f3a:	41 c1 ec 10          	shr    $0x10,%r12d
     f3e:	49 01 f4             	add    %rsi,%r12
     f41:	0f b7 f1             	movzwl %cx,%esi
     f44:	4c 01 e6             	add    %r12,%rsi
     f47:	e9 2e 0a 00 00       	jmp    197a <balancer_ingress+0x197a>
      if (pckt.flow.proto == IPPROTO_TCP) {
     f4c:	80 7d a4 06          	cmpb   $0x6,-0x5c(%rbp)
     f50:	75 37                	jne    f89 <balancer_ingress+0xf89>
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
     f52:	c7 45 c0 01 02 00 00 	movl   $0x201,-0x40(%rbp)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
     f59:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     f60:	88 ff ff 
     f63:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     f67:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     f6e:	ff d0                	call   *%rax
        if (!lru_stats) {
     f70:	48 85 c0             	test   %rax,%rax
     f73:	0f 84 1d 0d 00 00    	je     1c96 <balancer_ingress+0x1c96>
        if (pckt.flags & F_SYN_SET) {
     f79:	8b 4d ac             	mov    -0x54(%rbp),%ecx
     f7c:	c1 e1 02             	shl    $0x2,%ecx
     f7f:	f7 d1                	not    %ecx
     f81:	83 e1 08             	and    $0x8,%ecx
     f84:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
  struct real_pos_lru new_dst_lru = {};
     f89:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
     f90:	00 
     f91:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
     f98:	00 
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
     f99:	c7 45 b8 02 02 00 00 	movl   $0x202,-0x48(%rbp)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     fa0:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
     fa7:	88 ff ff 
     faa:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
     fae:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
     fb5:	ff d0                	call   *%rax
     fb7:	41 b7 01             	mov    $0x1,%r15b
  if (!conn_rate_stats) {
     fba:	48 85 c0             	test   %rax,%rax
     fbd:	0f 84 da 00 00 00    	je     109d <balancer_ingress+0x109d>
     fc3:	48 89 c3             	mov    %rax,%rbx
     fc6:	48 c7 c0 30 d6 09 9f 	mov    $0xffffffff9f09d630,%rax
  *cur_time = bpf_ktime_get_ns();
     fcd:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     fcf:	48 89 c1             	mov    %rax,%rcx
     fd2:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
     fd6:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
     fdd:	0f 82 c2 00 00 00    	jb     10a5 <balancer_ingress+0x10a5>
    conn_rate_stats->v1 = 1;
     fe3:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
     fea:	48 89 43 08          	mov    %rax,0x8(%rbx)
     fee:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
     ff2:	e9 c5 00 00 00       	jmp    10bc <balancer_ingress+0x10bc>
     ff7:	48 c7 c0 20 5c 23 a1 	mov    $0xffffffffa1235c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
     ffe:	4c 89 ef             	mov    %r13,%rdi
    1001:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1006:	ff d0                	call   *%rax
    1008:	85 c0                	test   %eax,%eax
    100a:	0f 85 8b 0c 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
  data = (void*)(long)xdp->data;
    1010:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1014:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1018:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    101c:	48 39 ca             	cmp    %rcx,%rdx
    101f:	0f 87 76 0c 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
    1025:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1029:	48 39 ca             	cmp    %rcx,%rdx
    102c:	0f 87 69 0c 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
    1032:	48 b9 00 d8 b9 7e 81 	movabs $0xffff88817eb9d800,%rcx
    1039:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    103c:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1043:	66 89 50 04          	mov    %dx,0x4(%rax)
    1047:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    104d:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    104f:	8b 48 28             	mov    0x28(%rax),%ecx
    1052:	89 48 06             	mov    %ecx,0x6(%rax)
    1055:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    1059:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    105d:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    1063:	0f b7 4d a0          	movzwl -0x60(%rbp),%ecx
  saddr[3] = src ^ port;
    1067:	33 4d 8c             	xor    -0x74(%rbp),%ecx
    106a:	8b 75 b4             	mov    -0x4c(%rbp),%esi
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    106d:	83 c6 28             	add    $0x28,%esi
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1070:	8a 5d ad             	mov    -0x53(%rbp),%bl
    __u32* saddr,
    __u32* daddr,
    __u16 payload_len,
    __u8 proto) {
  ip6h->version = 6;
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1073:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#ifdef COPY_INNER_PACKET_TOS
  ip6h->priority = (tc & 0xF0) >> 4;
    1079:	89 da                	mov    %ebx,%edx
    107b:	c0 ea 04             	shr    $0x4,%dl
    107e:	80 ca 60             	or     $0x60,%dl
    1081:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1084:	c0 e3 04             	shl    $0x4,%bl
    1087:	88 58 0f             	mov    %bl,0xf(%rax)
#else
  ip6h->priority = DEFAULT_TOS;
#endif
  ip6h->nexthdr = proto;
    108a:	66 c7 40 14 29 40    	movw   $0x4029,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    1090:	66 c1 c6 08          	rol    $0x8,%si
    1094:	66 89 70 12          	mov    %si,0x12(%rax)
    1098:	e9 9c 0a 00 00       	jmp    1b39 <balancer_ingress+0x1b39>
    109d:	31 c0                	xor    %eax,%eax
    109f:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    10a3:	eb 1a                	jmp    10bf <balancer_ingress+0x10bf>
    conn_rate_stats->v1 += 1;
    10a5:	48 8b 0b             	mov    (%rbx),%rcx
    10a8:	48 83 c1 01          	add    $0x1,%rcx
    10ac:	48 89 0b             	mov    %rcx,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    10af:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    10b6:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    10ba:	77 03                	ja     10bf <balancer_ingress+0x10bf>
    10bc:	45 31 ff             	xor    %r15d,%r15d
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    10bf:	f6 01 08             	testb  $0x8,(%rcx)
    10c2:	75 1e                	jne    10e2 <balancer_ingress+0x10e2>
    10c4:	45 89 f4             	mov    %r14d,%r12d
    10c7:	8b 7d 80             	mov    -0x80(%rbp),%edi

  a = b = c = JHASH_INITVAL + length + initval;

  while (length > 12) {
    a += *(u32*)(k);
    b += *(u32*)(k + 4);
    10ca:	8b 4d 84             	mov    -0x7c(%rbp),%ecx
    c += *(u32*)(k + 8);
    10cd:	8b 55 88             	mov    -0x78(%rbp),%edx
    case 6:
      b += (u32)k[5] << 8;
    case 5:
      b += k[4];
    case 4:
      a += (u32)k[3] << 24;
    10d0:	44 8a 5d 8f          	mov    -0x71(%rbp),%r11b
    case 3:
      a += (u32)k[2] << 16;
    10d4:	44 8a 55 8e          	mov    -0x72(%rbp),%r10b
    case 2:
      a += (u32)k[1] << 8;
    10d8:	44 8a 4d 8d          	mov    -0x73(%rbp),%r9b
    case 1:
      a += k[0];
    10dc:	44 8a 45 8c          	mov    -0x74(%rbp),%r8b
    10e0:	eb 2d                	jmp    110f <balancer_ingress+0x110f>
    10e2:	45 89 f4             	mov    %r14d,%r12d
      pckt->flow.port16[0] = pckt->flow.port16[1];
    10e5:	0f b7 4d a2          	movzwl -0x5e(%rbp),%ecx
    10e9:	66 89 4d a0          	mov    %cx,-0x60(%rbp)
      memset(pckt->flow.srcv6, 0, 16);
    10ed:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
    10f4:	00 
    10f5:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    10fc:	00 
    10fd:	45 31 c0             	xor    %r8d,%r8d
    1100:	45 31 c9             	xor    %r9d,%r9d
    1103:	45 31 d2             	xor    %r10d,%r10d
    1106:	45 31 db             	xor    %r11d,%r11d
    1109:	31 d2                	xor    %edx,%edx
    110b:	31 c9                	xor    %ecx,%ecx
    110d:	31 ff                	xor    %edi,%edi
    c += *(u32*)(k + 8);
    110f:	8d 9a ff c0 ad de    	lea    -0x21523f01(%rdx),%ebx
    __jhash_mix(a, b, c);
    1115:	29 d7                	sub    %edx,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    1117:	c1 c3 04             	rol    $0x4,%ebx
    __jhash_mix(a, b, c);
    111a:	31 fb                	xor    %edi,%ebx
    b += *(u32*)(k + 4);
    111c:	89 cf                	mov    %ecx,%edi
    111e:	81 c7 ff c0 ad de    	add    $0xdeadc0ff,%edi
    __jhash_mix(a, b, c);
    1124:	01 ca                	add    %ecx,%edx
    1126:	81 c2 fe 81 5b bd    	add    $0xbd5b81fe,%edx
    112c:	29 df                	sub    %ebx,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    112e:	89 de                	mov    %ebx,%esi
    1130:	c1 c6 06             	rol    $0x6,%esi
    __jhash_mix(a, b, c);
    1133:	31 fe                	xor    %edi,%esi
    1135:	01 d3                	add    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1137:	89 f1                	mov    %esi,%ecx
    1139:	c1 c1 08             	rol    $0x8,%ecx
    __jhash_mix(a, b, c);
    113c:	29 f2                	sub    %esi,%edx
    113e:	31 d1                	xor    %edx,%ecx
    1140:	01 de                	add    %ebx,%esi
    1142:	29 cb                	sub    %ecx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1144:	89 cf                	mov    %ecx,%edi
    1146:	c1 c7 10             	rol    $0x10,%edi
    __jhash_mix(a, b, c);
    1149:	31 df                	xor    %ebx,%edi
    114b:	01 f1                	add    %esi,%ecx
    114d:	29 fe                	sub    %edi,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    114f:	89 fa                	mov    %edi,%edx
    1151:	c1 c2 13             	rol    $0x13,%edx
    __jhash_mix(a, b, c);
    1154:	31 f2                	xor    %esi,%edx
    1156:	01 cf                	add    %ecx,%edi
    1158:	29 d1                	sub    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    115a:	41 89 d6             	mov    %edx,%r14d
    115d:	41 c1 c6 04          	rol    $0x4,%r14d
    __jhash_mix(a, b, c);
    1161:	01 fa                	add    %edi,%edx
      a += (u32)k[3] << 24;
    1163:	41 0f b6 db          	movzbl %r11b,%ebx
    1167:	c1 e3 18             	shl    $0x18,%ebx
      a += (u32)k[2] << 16;
    116a:	41 0f b6 f2          	movzbl %r10b,%esi
    116e:	c1 e6 10             	shl    $0x10,%esi
      a += (u32)k[3] << 24;
    1171:	09 de                	or     %ebx,%esi
      a += (u32)k[1] << 8;
    1173:	41 0f b6 d9          	movzbl %r9b,%ebx
    1177:	c1 e3 08             	shl    $0x8,%ebx
      a += (u32)k[2] << 16;
    117a:	09 f3                	or     %esi,%ebx
      a += k[0];
    117c:	41 0f b6 f0          	movzbl %r8b,%esi
      a += (u32)k[1] << 8;
    1180:	09 de                	or     %ebx,%esi
      a += k[0];
    1182:	01 fe                	add    %edi,%esi
    __jhash_mix(a, b, c);
    1184:	31 d1                	xor    %edx,%ecx
      __jhash_final(a, b, c);
    1186:	44 31 f1             	xor    %r14d,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1189:	89 d7                	mov    %edx,%edi
    118b:	c1 c7 0e             	rol    $0xe,%edi
      __jhash_final(a, b, c);
    118e:	29 f9                	sub    %edi,%ecx
    1190:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1192:	89 cf                	mov    %ecx,%edi
    1194:	c1 c7 0b             	rol    $0xb,%edi
      __jhash_final(a, b, c);
    1197:	29 fe                	sub    %edi,%esi
    1199:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    119b:	89 f7                	mov    %esi,%edi
    119d:	c1 c7 19             	rol    $0x19,%edi
      __jhash_final(a, b, c);
    11a0:	29 fa                	sub    %edi,%edx
    11a2:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    11a4:	89 d7                	mov    %edx,%edi
    11a6:	c1 c7 10             	rol    $0x10,%edi
      __jhash_final(a, b, c);
    11a9:	29 f9                	sub    %edi,%ecx
    11ab:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    11ad:	89 cf                	mov    %ecx,%edi
    11af:	c1 c7 04             	rol    $0x4,%edi
      __jhash_final(a, b, c);
    11b2:	29 fe                	sub    %edi,%esi
    11b4:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    11b6:	c1 c6 0e             	rol    $0xe,%esi
      __jhash_final(a, b, c);
    11b9:	29 f2                	sub    %esi,%edx
    11bb:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    11bd:	c1 c2 18             	rol    $0x18,%edx

  return c;
}

static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval) {
  a += initval;
    11c0:	29 d1                	sub    %edx,%ecx
    11c2:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  b += initval;
    11c7:	03 75 a0             	add    -0x60(%rbp),%esi
  a += initval;
    11ca:	81 c1 f7 c0 ad e0    	add    $0xe0adc0f7,%ecx
  c += initval;
  __jhash_final(a, b, c);
    11d0:	89 f2                	mov    %esi,%edx
    11d2:	81 f2 f7 c0 ad e0    	xor    $0xe0adc0f7,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    11d8:	89 f7                	mov    %esi,%edi
    11da:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    11dd:	29 fa                	sub    %edi,%edx
    11df:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    11e1:	89 d7                	mov    %edx,%edi
    11e3:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    11e6:	29 f9                	sub    %edi,%ecx
    11e8:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    11ea:	89 cf                	mov    %ecx,%edi
    11ec:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    11ef:	29 fe                	sub    %edi,%esi
    11f1:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    11f3:	89 f7                	mov    %esi,%edi
    11f5:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    11f8:	29 fa                	sub    %edi,%edx
    11fa:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    11fc:	89 d7                	mov    %edx,%edi
    11fe:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1201:	29 f9                	sub    %edi,%ecx
    1203:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1205:	c1 c1 0e             	rol    $0xe,%ecx
  __jhash_final(a, b, c);
    1208:	29 ce                	sub    %ecx,%esi
    120a:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    120c:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    120f:	29 f2                	sub    %esi,%edx
    1211:	b9 01 00 ff ff       	mov    $0xffff0001,%ecx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1216:	48 0f af ca          	imul   %rdx,%rcx
    121a:	48 c1 e9 30          	shr    $0x30,%rcx
    121e:	89 ce                	mov    %ecx,%esi
    1220:	c1 e6 10             	shl    $0x10,%esi
    1223:	09 ce                	or     %ecx,%esi
    1225:	29 f2                	sub    %esi,%edx
    1227:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    122b:	8b 71 04             	mov    0x4(%rcx),%esi
    122e:	89 f1                	mov    %esi,%ecx
    1230:	c1 e1 10             	shl    $0x10,%ecx
    1233:	01 f1                	add    %esi,%ecx
    1235:	01 d1                	add    %edx,%ecx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1237:	81 f9 ff 01 00 02    	cmp    $0x20001ff,%ecx
    if (!real_pos) {
    123d:	0f 87 53 0a 00 00    	ja     1c96 <balancer_ingress+0x1c96>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1243:	89 c9                	mov    %ecx,%ecx
    1245:	48 ba 00 10 73 30 03 	movabs $0xffffc90330731000,%rdx
    124c:	c9 ff ff 
    key = *real_pos;
    124f:	8b 9c 8a 00 01 00 00 	mov    0x100(%rdx,%rcx,4),%ebx
    1256:	48 85 db             	test   %rbx,%rbx
    if (key == 0) {
    1259:	0f 84 0f 0a 00 00    	je     1c6e <balancer_ingress+0x1c6e>
  pckt->real_index = key;
    125f:	89 5d a8             	mov    %ebx,-0x58(%rbp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1262:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  if (!(*real)) {
    1268:	0f 83 d7 09 00 00    	jae    1c45 <balancer_ingress+0x1c45>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    126e:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
    1275:	00 
    1276:	74 10                	je     1288 <balancer_ingress+0x1288>
    1278:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    127c:	8a 09                	mov    (%rcx),%cl
    127e:	80 e1 02             	and    $0x2,%cl
    1281:	d0 e9                	shr    %cl
    1283:	41 08 cf             	or     %cl,%r15b
    1286:	74 05                	je     128d <balancer_ingress+0x128d>
    1288:	41 89 d8             	mov    %ebx,%r8d
    128b:	eb 2b                	jmp    12b8 <balancer_ingress+0x12b8>
    if (pckt->flow.proto == IPPROTO_UDP) {
    128d:	80 7d a4 11          	cmpb   $0x11,-0x5c(%rbp)
    1291:	75 04                	jne    1297 <balancer_ingress+0x1297>
      new_dst_lru.atime = cur_time;
    1293:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    new_dst_lru.pos = key;
    1297:	89 5d c0             	mov    %ebx,-0x40(%rbp)
    129a:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
    129e:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
    12a2:	48 c7 c0 c0 c9 09 9f 	mov    $0xffffffff9f09c9c0,%rax
    12a9:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    12b0:	31 c9                	xor    %ecx,%ecx
    12b2:	ff d0                	call   *%rax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    12b4:	44 8b 45 a8          	mov    -0x58(%rbp),%r8d
    12b8:	48 b9 00 dc b9 7e 81 	movabs $0xffff88817eb9dc00,%rcx
    12bf:	88 ff ff 
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    12c2:	8b 81 00 01 00 00    	mov    0x100(%rcx),%eax
    12c8:	b2 01                	mov    $0x1,%dl
    12ca:	3b 85 58 ff ff ff    	cmp    -0xa8(%rbp),%eax
    12d0:	75 2b                	jne    12fd <balancer_ingress+0x12fd>
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    12d2:	8b 81 04 01 00 00    	mov    0x104(%rcx),%eax
    12d8:	3b 85 5c ff ff ff    	cmp    -0xa4(%rbp),%eax
    12de:	75 1d                	jne    12fd <balancer_ingress+0x12fd>
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    12e0:	8b 81 08 01 00 00    	mov    0x108(%rcx),%eax
    12e6:	3b 85 60 ff ff ff    	cmp    -0xa0(%rbp),%eax
    12ec:	75 0f                	jne    12fd <balancer_ingress+0x12fd>
    12ee:	8b 81 0c 01 00 00    	mov    0x10c(%rcx),%eax
    12f4:	3b 85 64 ff ff ff    	cmp    -0x9c(%rbp),%eax
    12fa:	0f 95 c2             	setne  %dl
  bool port_match = lru_miss_stat_vip->port == vip->port;
    12fd:	0f b7 b9 10 01 00 00 	movzwl 0x110(%rcx),%edi
    1304:	0f b7 b5 68 ff ff ff 	movzwl -0x98(%rbp),%esi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    130b:	8a 85 6a ff ff ff    	mov    -0x96(%rbp),%al
    1311:	88 81 12 01 00 00    	mov    %al,0x112(%rcx)
  bool vip_match = address_match && port_match && proto_match;
    1317:	84 d2                	test   %dl,%dl
    1319:	75 30                	jne    134b <balancer_ingress+0x134b>
    131b:	66 39 f7             	cmp    %si,%di
    131e:	75 2b                	jne    134b <balancer_ingress+0x134b>
    1320:	84 c0                	test   %al,%al
    1322:	74 27                	je     134b <balancer_ingress+0x134b>
    __u32 lru_stats_key = pckt->real_index;
    1324:	44 89 45 c0          	mov    %r8d,-0x40(%rbp)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1328:	48 bf 00 a0 7d 40 03 	movabs $0xffffc903407da000,%rdi
    132f:	c9 ff ff 
    1332:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    1336:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    133d:	ff d0                	call   *%rax
    if (!lru_miss_stat) {
    133f:	48 85 c0             	test   %rax,%rax
    1342:	0f 84 4e 09 00 00    	je     1c96 <balancer_ingress+0x1c96>
    *lru_miss_stat += 1;
    1348:	83 00 01             	addl   $0x1,(%rax)
    134b:	48 8d 04 9b          	lea    (%rbx,%rbx,4),%rax
    134f:	48 b9 00 60 7b 40 03 	movabs $0xffffc903407b6000,%rcx
    1356:	c9 ff ff 
    1359:	4c 8d 3c 81          	lea    (%rcx,%rax,4),%r15
    135d:	49 81 c7 00 01 00 00 	add    $0x100,%r15
    1364:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
      data_stats->v2 += 1;
    136b:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    1370:	45 89 e6             	mov    %r12d,%r14d
    1373:	e9 84 fa ff ff       	jmp    dfc <balancer_ingress+0xdfc>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1378:	49 8d 46 0e          	lea    0xe(%r14),%rax
    137c:	4c 39 e0             	cmp    %r12,%rax
    137f:	0f 87 30 03 00 00    	ja     16b5 <balancer_ingress+0x16b5>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1385:	f6 c1 20             	test   $0x20,%cl
    1388:	0f 85 c3 00 00 00    	jne    1451 <balancer_ingress+0x1451>
        quic_packets_stats->cid_initial += 1;
    138e:	48 83 43 08 01       	addq   $0x1,0x8(%rbx)
    1393:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
    1399:	89 45 c0             	mov    %eax,-0x40(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    139c:	48 bf 00 c0 75 c4 81 	movabs $0xffff8881c475c000,%rdi
    13a3:	88 ff ff 
    13a6:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    13aa:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    13b1:	ff d0                	call   *%rax
  if (!per_vip_stats) {
    13b3:	48 85 c0             	test   %rax,%rax
    13b6:	0f 84 fd 02 00 00    	je     16b9 <balancer_ingress+0x16b9>
    per_vip_stats->v1 += 1;
    13bc:	48 83 00 01          	addq   $0x1,(%rax)
    13c0:	e9 f4 02 00 00       	jmp    16b9 <balancer_ingress+0x16b9>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    13c5:	41 80 7e 05 08       	cmpb   $0x8,0x5(%r14)
    13ca:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    13ce:	0f 82 74 f3 ff ff    	jb     748 <balancer_ingress+0x748>
    13d4:	49 83 c6 06          	add    $0x6,%r14
    13d8:	4c 89 f7             	mov    %r14,%rdi
  if (!connId) {
    13db:	48 85 ff             	test   %rdi,%rdi
    13de:	0f 85 31 f8 ff ff    	jne    c15 <balancer_ingress+0xc15>
    13e4:	e9 5f f3 ff ff       	jmp    748 <balancer_ingress+0x748>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    13e9:	0f b6 4f 01          	movzbl 0x1(%rdi),%ecx
    13ed:	48 c1 e1 18          	shl    $0x18,%rcx
    13f1:	0f b6 57 02          	movzbl 0x2(%rdi),%edx
    13f5:	48 c1 e2 10          	shl    $0x10,%rdx
    13f9:	48 09 ca             	or     %rcx,%rdx
    13fc:	0f b6 4f 03          	movzbl 0x3(%rdi),%ecx
    1400:	48 c1 e1 08          	shl    $0x8,%rcx
    1404:	48 09 d1             	or     %rdx,%rcx
    1407:	8a 47 04             	mov    0x4(%rdi),%al
    140a:	b2 03                	mov    $0x3,%dl
    140c:	eb 18                	jmp    1426 <balancer_ingress+0x1426>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    140e:	0f b6 57 01          	movzbl 0x1(%rdi),%edx
    1412:	48 c1 e2 10          	shl    $0x10,%rdx
    1416:	0f b6 4f 02          	movzbl 0x2(%rdi),%ecx
    141a:	48 c1 e1 08          	shl    $0x8,%rcx
    141e:	48 09 d1             	or     %rdx,%rcx
    1421:	8a 47 03             	mov    0x3(%rdi),%al
    1424:	b2 02                	mov    $0x2,%dl
    1426:	0f b6 f8             	movzbl %al,%edi
    1429:	48 09 cf             	or     %rcx,%rdi
      if (qpr.server_id > 0) {
    142c:	85 ff                	test   %edi,%edi
    142e:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    1432:	48 89 d8             	mov    %rbx,%rax
    1435:	0f 8e 0d f3 ff ff    	jle    748 <balancer_ingress+0x748>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    143b:	80 fa 01             	cmp    $0x1,%dl
    143e:	74 6b                	je     14ab <balancer_ingress+0x14ab>
    1440:	80 fa 03             	cmp    $0x3,%dl
    1443:	74 6d                	je     14b2 <balancer_ingress+0x14b2>
    1445:	80 fa 02             	cmp    $0x2,%dl
    1448:	75 6f                	jne    14b9 <balancer_ingress+0x14b9>
    144a:	b9 40 00 00 00       	mov    $0x40,%ecx
    144f:	eb 6d                	jmp    14be <balancer_ingress+0x14be>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1451:	41 80 7e 05 08       	cmpb   $0x8,0x5(%r14)
    1456:	0f 82 59 02 00 00    	jb     16b5 <balancer_ingress+0x16b5>
    145c:	49 83 c6 06          	add    $0x6,%r14
    1460:	4c 89 f0             	mov    %r14,%rax
  if (!connId) {
    1463:	48 85 c0             	test   %rax,%rax
    1466:	0f 84 49 02 00 00    	je     16b5 <balancer_ingress+0x16b5>
  __u8 connIdVersion = (connId[0] >> 6);
    146c:	0f b6 08             	movzbl (%rax),%ecx
    146f:	89 ca                	mov    %ecx,%edx
    1471:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    1474:	80 fa 03             	cmp    $0x3,%dl
    1477:	0f 84 e1 00 00 00    	je     155e <balancer_ingress+0x155e>
    147d:	80 fa 02             	cmp    $0x2,%dl
    1480:	0f 84 fd 00 00 00    	je     1583 <balancer_ingress+0x1583>
    1486:	80 fa 01             	cmp    $0x1,%dl
    1489:	0f 85 26 02 00 00    	jne    16b5 <balancer_ingress+0x16b5>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    148f:	83 e1 3f             	and    $0x3f,%ecx
    1492:	48 c1 e1 0a          	shl    $0xa,%rcx
    1496:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    149a:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
    149e:	8a 40 02             	mov    0x2(%rax),%al
    14a1:	c0 e8 06             	shr    $0x6,%al
    14a4:	b2 01                	mov    $0x1,%dl
    14a6:	e9 f0 00 00 00       	jmp    159b <balancer_ingress+0x159b>
    14ab:	b9 38 00 00 00       	mov    $0x38,%ecx
    14b0:	eb 0c                	jmp    14be <balancer_ingress+0x14be>
    14b2:	b9 48 00 00 00       	mov    $0x48,%ecx
    14b7:	eb 05                	jmp    14be <balancer_ingress+0x14be>
    14b9:	b9 30 00 00 00       	mov    $0x30,%ecx
    14be:	48 83 04 0b 01       	addq   $0x1,(%rbx,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    14c3:	81 ff fd ff ff 00    	cmp    $0xfffffd,%edi
        if (real_pos) {
    14c9:	77 7a                	ja     1545 <balancer_ingress+0x1545>
    14cb:	48 b9 00 40 7e 40 03 	movabs $0xffffc903407e4000,%rcx
    14d2:	c9 ff ff 
          key = *real_pos;
    14d5:	8b 8c b9 00 01 00 00 	mov    0x100(%rcx,%rdi,4),%ecx
    14dc:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    14df:	74 64                	je     1545 <balancer_ingress+0x1545>
            pckt.real_index = key;
    14e1:	89 4d a8             	mov    %ecx,-0x58(%rbp)
    14e4:	31 d2                	xor    %edx,%edx
            dst = bpf_map_lookup_elem(&reals, &key);
    14e6:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    14ec:	48 8d 04 89          	lea    (%rcx,%rcx,4),%rax
    14f0:	48 b9 00 60 7b 40 03 	movabs $0xffffc903407b6000,%rcx
    14f7:	c9 ff ff 
    14fa:	48 8d 84 81 00 01 00 	lea    0x100(%rcx,%rax,4),%rax
    1501:	00 
    1502:	48 0f 42 d0          	cmovb  %rax,%rdx
            if (!dst) {
    1506:	48 85 d2             	test   %rdx,%rdx
    1509:	0f 84 79 08 00 00    	je     1d88 <balancer_ingress+0x1d88>
    150f:	49 89 d7             	mov    %rdx,%r15
    1512:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
    1516:	49 c7 c6 30 c9 09 9f 	mov    $0xffffffff9f09c930,%r14
    151d:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1524:	41 ff d6             	call   *%r14
  if (dst_lru) {
    1527:	48 85 c0             	test   %rax,%rax
    152a:	0f 84 8f 00 00 00    	je     15bf <balancer_ingress+0x15bf>
    if (dst_lru->pos == pckt->real_index) {
    1530:	8b 4d a8             	mov    -0x58(%rbp),%ecx
    1533:	39 08                	cmp    %ecx,(%rax)
    1535:	0f 85 57 08 00 00    	jne    1d92 <balancer_ingress+0x1d92>
              quic_packets_stats->dst_match_in_lru += 1;
    153b:	48 83 43 50 01       	addq   $0x1,0x50(%rbx)
    1540:	e9 c7 08 00 00       	jmp    1e0c <balancer_ingress+0x1e0c>
    1545:	48 83 43 10 01       	addq   $0x1,0x10(%rbx)
    154a:	48 63 c7             	movslq %edi,%rax
    154d:	48 89 43 18          	mov    %rax,0x18(%rbx)
    1551:	48 83 03 01          	addq   $0x1,(%rbx)
    1555:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
    1559:	e9 27 f6 ff ff       	jmp    b85 <balancer_ingress+0xb85>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    155e:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    1562:	48 c1 e1 18          	shl    $0x18,%rcx
    1566:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    156a:	48 c1 e2 10          	shl    $0x10,%rdx
    156e:	48 09 ca             	or     %rcx,%rdx
    1571:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    1575:	48 c1 e1 08          	shl    $0x8,%rcx
    1579:	48 09 d1             	or     %rdx,%rcx
    157c:	8a 40 04             	mov    0x4(%rax),%al
    157f:	b2 03                	mov    $0x3,%dl
    1581:	eb 18                	jmp    159b <balancer_ingress+0x159b>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1583:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    1587:	48 c1 e2 10          	shl    $0x10,%rdx
    158b:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    158f:	48 c1 e1 08          	shl    $0x8,%rcx
    1593:	48 09 d1             	or     %rdx,%rcx
    1596:	8a 40 03             	mov    0x3(%rax),%al
    1599:	b2 02                	mov    $0x2,%dl
    159b:	0f b6 c0             	movzbl %al,%eax
    159e:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    15a1:	85 c0                	test   %eax,%eax
    15a3:	0f 8e 0c 01 00 00    	jle    16b5 <balancer_ingress+0x16b5>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    15a9:	80 fa 01             	cmp    $0x1,%dl
    15ac:	74 62                	je     1610 <balancer_ingress+0x1610>
    15ae:	80 fa 03             	cmp    $0x3,%dl
    15b1:	74 64                	je     1617 <balancer_ingress+0x1617>
    15b3:	80 fa 02             	cmp    $0x2,%dl
    15b6:	75 66                	jne    161e <balancer_ingress+0x161e>
    15b8:	b9 40 00 00 00       	mov    $0x40,%ecx
    15bd:	eb 64                	jmp    1623 <balancer_ingress+0x1623>
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    15bf:	c7 45 c0 02 02 00 00 	movl   $0x202,-0x40(%rbp)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    15c6:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
    15cd:	88 ff ff 
    15d0:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    15d4:	41 ff d6             	call   *%r14
  if (!conn_rate_stats) {
    15d7:	48 85 c0             	test   %rax,%rax
    15da:	0f 84 27 08 00 00    	je     1e07 <balancer_ingress+0x1e07>
    15e0:	49 89 c6             	mov    %rax,%r14
    15e3:	48 c7 c0 30 d6 09 9f 	mov    $0xffffffff9f09d630,%rax
  *cur_time = bpf_ktime_get_ns();
    15ea:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    15ec:	48 89 c1             	mov    %rax,%rcx
    15ef:	49 2b 4e 08          	sub    0x8(%r14),%rcx
    15f3:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    15fa:	0f 82 c5 07 00 00    	jb     1dc5 <balancer_ingress+0x1dc5>
    conn_rate_stats->v1 = 1;
    1600:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    conn_rate_stats->v2 = *cur_time;
    1607:	49 89 46 08          	mov    %rax,0x8(%r14)
    160b:	e9 c7 07 00 00       	jmp    1dd7 <balancer_ingress+0x1dd7>
    1610:	b9 38 00 00 00       	mov    $0x38,%ecx
    1615:	eb 0c                	jmp    1623 <balancer_ingress+0x1623>
    1617:	b9 48 00 00 00       	mov    $0x48,%ecx
    161c:	eb 05                	jmp    1623 <balancer_ingress+0x1623>
    161e:	b9 30 00 00 00       	mov    $0x30,%ecx
    1623:	48 83 04 0b 01       	addq   $0x1,(%rbx,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1628:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    162d:	77 7b                	ja     16aa <balancer_ingress+0x16aa>
    162f:	48 b9 00 40 7e 40 03 	movabs $0xffffc903407e4000,%rcx
    1636:	c9 ff ff 
          key = *real_pos;
    1639:	8b 8c 81 00 01 00 00 	mov    0x100(%rcx,%rax,4),%ecx
    1640:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    1643:	74 65                	je     16aa <balancer_ingress+0x16aa>
            pckt.real_index = key;
    1645:	89 4d a8             	mov    %ecx,-0x58(%rbp)
    1648:	31 d2                	xor    %edx,%edx
            dst = bpf_map_lookup_elem(&reals, &key);
    164a:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    1650:	48 8d 04 89          	lea    (%rcx,%rcx,4),%rax
    1654:	48 b9 00 60 7b 40 03 	movabs $0xffffc903407b6000,%rcx
    165b:	c9 ff ff 
    165e:	48 8d 84 81 00 01 00 	lea    0x100(%rcx,%rax,4),%rax
    1665:	00 
    1666:	48 0f 42 d0          	cmovb  %rax,%rdx
    166a:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
            if (!dst) {
    166e:	48 85 d2             	test   %rdx,%rdx
    1671:	0f 84 11 07 00 00    	je     1d88 <balancer_ingress+0x1d88>
    1677:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
    167b:	49 c7 c6 30 c9 09 9f 	mov    $0xffffffff9f09c930,%r14
    1682:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1689:	41 ff d6             	call   *%r14
  if (dst_lru) {
    168c:	48 85 c0             	test   %rax,%rax
    168f:	0f 84 86 07 00 00    	je     1e1b <balancer_ingress+0x1e1b>
    if (dst_lru->pos == pckt->real_index) {
    1695:	8b 4d a8             	mov    -0x58(%rbp),%ecx
    1698:	39 08                	cmp    %ecx,(%rax)
    169a:	0f 85 c5 07 00 00    	jne    1e65 <balancer_ingress+0x1e65>
              quic_packets_stats->dst_match_in_lru += 1;
    16a0:	48 83 43 50 01       	addq   $0x1,0x50(%rbx)
    16a5:	e9 35 08 00 00       	jmp    1edf <balancer_ingress+0x1edf>
    16aa:	48 83 43 10 01       	addq   $0x1,0x10(%rbx)
    16af:	48 98                	cltq
    16b1:	48 89 43 18          	mov    %rax,0x18(%rbx)
    16b5:	48 83 03 01          	addq   $0x1,(%rbx)
    16b9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  original_sport = pckt.flow.port16[0];
    16bd:	0f b7 4d a0          	movzwl -0x60(%rbp),%ecx
    16c1:	89 8d 7c ff ff ff    	mov    %ecx,-0x84(%rbp)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    16c7:	f6 45 ac 02          	testb  $0x2,-0x54(%rbp)
    16cb:	75 4a                	jne    1717 <balancer_ingress+0x1717>
        !(vip_info->flags & F_LRU_BYPASS)) {
    16cd:	f6 00 02             	testb  $0x2,(%rax)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    16d0:	75 45                	jne    1717 <balancer_ingress+0x1717>
    16d2:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
    16d6:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    16dd:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    16e4:	ff d0                	call   *%rax
  if (!dst_lru) {
    16e6:	48 85 c0             	test   %rax,%rax
    16e9:	74 28                	je     1713 <balancer_ingress+0x1713>
    16eb:	48 89 c3             	mov    %rax,%rbx
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    16ee:	80 7d a4 11          	cmpb   $0x11,-0x5c(%rbp)
    16f2:	75 2b                	jne    171f <balancer_ingress+0x171f>
    16f4:	48 c7 c0 30 d6 09 9f 	mov    $0xffffffff9f09d630,%rax
    cur_time = bpf_ktime_get_ns();
    16fb:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    16fd:	48 89 c1             	mov    %rax,%rcx
    1700:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1704:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    170b:	00 00 00 
    170e:	48 39 d1             	cmp    %rdx,%rcx
    1711:	76 08                	jbe    171b <balancer_ingress+0x171b>
    1713:	31 db                	xor    %ebx,%ebx
    1715:	eb 2f                	jmp    1746 <balancer_ingress+0x1746>
    1717:	31 db                	xor    %ebx,%ebx
    1719:	eb 2f                	jmp    174a <balancer_ingress+0x174a>
    dst_lru->atime = cur_time;
    171b:	48 89 43 08          	mov    %rax,0x8(%rbx)
  key = dst_lru->pos;
    171f:	8b 03                	mov    (%rbx),%eax
    1721:	31 db                	xor    %ebx,%ebx
    1723:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    1729:	89 45 a8             	mov    %eax,-0x58(%rbp)
  *real = bpf_map_lookup_elem(&reals, &key);
    172c:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
    1730:	48 b9 00 60 7b 40 03 	movabs $0xffffc903407b6000,%rcx
    1737:	c9 ff ff 
    173a:	48 8d 84 81 00 01 00 	lea    0x100(%rcx,%rax,4),%rax
    1741:	00 
    1742:	48 0f 42 d8          	cmovb  %rax,%rbx
    1746:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    174a:	80 7d a4 11          	cmpb   $0x11,-0x5c(%rbp)
    174e:	0f 85 cb 00 00 00    	jne    181f <balancer_ingress+0x181f>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1754:	f6 40 01 02          	testb  $0x2,0x1(%rax)
    1758:	0f 84 c1 00 00 00    	je     181f <balancer_ingress+0x181f>
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    175e:	c7 45 c0 02 02 00 00 	movl   $0x202,-0x40(%rbp)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1765:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
    176c:	88 ff ff 
    176f:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    1773:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    177a:	ff d0                	call   *%rax
  if (!conn_rate_stats) {
    177c:	48 85 c0             	test   %rax,%rax
    177f:	0f 84 9a 00 00 00    	je     181f <balancer_ingress+0x181f>
    1785:	49 89 c6             	mov    %rax,%r14
    1788:	48 c7 c0 30 d6 09 9f 	mov    $0xffffffff9f09d630,%rax
  *cur_time = bpf_ktime_get_ns();
    178f:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1791:	48 89 c1             	mov    %rax,%rcx
    1794:	49 2b 4e 08          	sub    0x8(%r14),%rcx
    1798:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    179f:	72 0d                	jb     17ae <balancer_ingress+0x17ae>
    conn_rate_stats->v1 = 1;
    17a1:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    conn_rate_stats->v2 = *cur_time;
    17a8:	49 89 46 08          	mov    %rax,0x8(%r14)
    17ac:	eb 12                	jmp    17c0 <balancer_ingress+0x17c0>
    conn_rate_stats->v1 += 1;
    17ae:	49 8b 06             	mov    (%r14),%rax
    17b1:	48 83 c0 01          	add    $0x1,%rax
    17b5:	49 89 06             	mov    %rax,(%r14)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    17b8:	48 3d 49 e8 01 00    	cmp    $0x1e849,%rax
    17be:	73 5f                	jae    181f <balancer_ingress+0x181f>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    17c0:	48 bf 00 58 9e 5a 81 	movabs $0xffff88815a9e5800,%rdi
    17c7:	88 ff ff 
    17ca:	48 8d b5 58 ff ff ff 	lea    -0xa8(%rbp),%rsi
    17d1:	49 c7 c6 30 c9 09 9f 	mov    $0xffffffff9f09c930,%r14
    17d8:	41 ff d6             	call   *%r14
    if (down_reals_map) {
    17db:	48 85 c0             	test   %rax,%rax
    17de:	74 3f                	je     181f <balancer_ingress+0x181f>
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    17e0:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
    17e4:	48 89 c7             	mov    %rax,%rdi
    17e7:	41 ff d6             	call   *%r14
      if (down_real) {
    17ea:	48 85 c0             	test   %rax,%rax
    17ed:	74 30                	je     181f <balancer_ingress+0x181f>
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
    17ef:	c7 45 c0 0f 02 00 00 	movl   $0x20f,-0x40(%rbp)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    17f6:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
    17fd:	88 ff ff 
    1800:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    1804:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    180b:	ff d0                	call   *%rax
        if (stats_data) {
    180d:	48 85 c0             	test   %rax,%rax
    1810:	0f 84 e1 01 00 00    	je     19f7 <balancer_ingress+0x19f7>
          stats_data->v1 += 1;
    1816:	48 83 00 01          	addq   $0x1,(%rax)
    181a:	e9 d8 01 00 00       	jmp    19f7 <balancer_ingress+0x19f7>
    if (!dst) {
    181f:	48 85 db             	test   %rbx,%rbx
    1822:	0f 84 cf 01 00 00    	je     19f7 <balancer_ingress+0x19f7>
    1828:	48 89 5d d0          	mov    %rbx,-0x30(%rbp)
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    182c:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
    1833:	88 ff ff 
    1836:	48 8d b5 54 ff ff ff 	lea    -0xac(%rbp),%rsi
    183d:	49 c7 c6 30 c9 09 9f 	mov    $0xffffffff9f09c930,%r14
    1844:	41 ff d6             	call   *%r14
    1847:	bb 01 00 00 00       	mov    $0x1,%ebx
  if (!data_stats) {
    184c:	48 85 c0             	test   %rax,%rax
    184f:	0f 84 46 04 00 00    	je     1c9b <balancer_ingress+0x1c9b>
    1855:	0f b7 4d b4          	movzwl -0x4c(%rbp),%ecx
    1859:	41 89 cc             	mov    %ecx,%r12d
    185c:	66 41 c1 c4 08       	rol    $0x8,%r12w
  data_stats->v1 += 1;
    1861:	48 83 00 01          	addq   $0x1,(%rax)
  data_stats->v2 += pkt_bytes;
    1865:	45 0f b7 fc          	movzwl %r12w,%r15d
    1869:	4c 01 78 08          	add    %r15,0x8(%rax)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    186d:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
    1871:	48 bf 00 00 7d 40 03 	movabs $0xffffc903407d0000,%rdi
    1878:	c9 ff ff 
    187b:	41 ff d6             	call   *%r14
  if (!data_stats) {
    187e:	48 85 c0             	test   %rax,%rax
    1881:	0f 84 14 04 00 00    	je     1c9b <balancer_ingress+0x1c9b>
  data_stats->v1 += 1;
    1887:	48 83 00 01          	addq   $0x1,(%rax)
  data_stats->v2 += pkt_bytes;
    188b:	4c 01 78 08          	add    %r15,0x8(%rax)
    188f:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  pckt.flow.port16[0] = original_sport;
    1895:	66 89 45 a0          	mov    %ax,-0x60(%rbp)
    1899:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  if (dst->flags & F_IPV6) {
    189d:	f6 40 10 01          	testb  $0x1,0x10(%rax)
    18a1:	0f 85 f7 01 00 00    	jne    1a9e <balancer_ingress+0x1a9e>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    18a7:	44 0f b7 75 82       	movzwl -0x7e(%rbp),%r14d
    18ac:	48 c7 c0 20 5c 23 a1 	mov    $0xffffffffa1235c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    18b3:	4c 89 ef             	mov    %r13,%rdi
    18b6:	be ec ff ff ff       	mov    $0xffffffec,%esi
    18bb:	ff d0                	call   *%rax
    18bd:	85 c0                	test   %eax,%eax
    18bf:	0f 85 d6 03 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
  data = (void*)(long)xdp->data;
    18c5:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    18c9:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  iph = data + sizeof(struct ethhdr);
    18cd:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    18d1:	48 39 ca             	cmp    %rcx,%rdx
    18d4:	0f 87 c1 03 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
    18da:	48 8d 50 22          	lea    0x22(%rax),%rdx
    18de:	48 39 ca             	cmp    %rcx,%rdx
    18e1:	0f 87 b4 03 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
    18e7:	8b 8d 7c ff ff ff    	mov    -0x84(%rbp),%ecx
    18ed:	66 c1 c1 08          	rol    $0x8,%cx
    18f1:	41 31 ce             	xor    %ecx,%r14d
    18f4:	41 c1 e6 10          	shl    $0x10,%r14d
    18f8:	41 8d 96 ac 10 00 00 	lea    0x10ac(%r14),%edx
    18ff:	48 b9 00 d8 b9 7e 81 	movabs $0xffff88817eb9d800,%rcx
    1906:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1909:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    1910:	66 89 70 04          	mov    %si,0x4(%rax)
    1914:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    191a:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    191c:	8b 48 14             	mov    0x14(%rax),%ecx
    191f:	89 48 06             	mov    %ecx,0x6(%rax)
    1922:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    1926:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    192a:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1930:	8a 5d ad             	mov    -0x53(%rbp),%bl
    1933:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    1937:	8b 09                	mov    (%rcx),%ecx
  iph->ihl = 5;
    1939:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->tos = tos;
    193d:	88 58 0f             	mov    %bl,0xf(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1940:	41 83 c4 14          	add    $0x14,%r12d
    1944:	66 41 c1 c4 08       	rol    $0x8,%r12w
    1949:	66 44 89 60 10       	mov    %r12w,0x10(%rax)
  iph->id = 0;
    194e:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    1955:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    1958:	89 50 1a             	mov    %edx,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    195b:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    1961:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    1965:	41 0f b7 f4          	movzwl %r12w,%esi
    1969:	0f b7 78 16          	movzwl 0x16(%rax),%edi
    196d:	41 c1 ee 10          	shr    $0x10,%r14d
    1971:	49 01 f6             	add    %rsi,%r14
    1974:	0f b7 f1             	movzwl %cx,%esi
    1977:	4c 01 f6             	add    %r14,%rsi
    197a:	48 c1 e9 10          	shr    $0x10,%rcx
    197e:	48 01 f1             	add    %rsi,%rcx
    1981:	48 01 d1             	add    %rdx,%rcx
    1984:	48 01 f9             	add    %rdi,%rcx
    1987:	48 81 c1 ac 10 00 00 	add    $0x10ac,%rcx
    198e:	48 89 ca             	mov    %rcx,%rdx
    1991:	48 c1 ea 10          	shr    $0x10,%rdx
    1995:	0f b7 f1             	movzwl %cx,%esi
    1998:	48 01 d6             	add    %rdx,%rsi
    199b:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
    19a2:	48 0f 42 f1          	cmovb  %rcx,%rsi
    19a6:	48 89 f1             	mov    %rsi,%rcx
    19a9:	48 c1 e9 10          	shr    $0x10,%rcx
    19ad:	0f b7 d6             	movzwl %si,%edx
    19b0:	48 01 ca             	add    %rcx,%rdx
    19b3:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    19ba:	48 0f 42 d6          	cmovb  %rsi,%rdx
    19be:	48 89 d1             	mov    %rdx,%rcx
    19c1:	48 c1 e9 10          	shr    $0x10,%rcx
    19c5:	0f b7 f2             	movzwl %dx,%esi
    19c8:	48 01 ce             	add    %rcx,%rsi
    19cb:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
    19d2:	48 0f 42 f2          	cmovb  %rdx,%rsi
    19d6:	89 f1                	mov    %esi,%ecx
    19d8:	c1 e9 10             	shr    $0x10,%ecx
    19db:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    19e2:	ba 00 00 01 00       	mov    $0x10000,%edx
    19e7:	0f 43 d1             	cmovae %ecx,%edx
    19ea:	01 f2                	add    %esi,%edx
    19ec:	f7 d2                	not    %edx
    19ee:	66 89 50 18          	mov    %dx,0x18(%rax)
    19f2:	e9 0d ea ff ff       	jmp    404 <balancer_ingress+0x404>
      if (pckt.flow.proto == IPPROTO_TCP) {
    19f7:	80 7d a4 06          	cmpb   $0x6,-0x5c(%rbp)
    19fb:	75 37                	jne    1a34 <balancer_ingress+0x1a34>
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
    19fd:	c7 45 c0 01 02 00 00 	movl   $0x201,-0x40(%rbp)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1a04:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
    1a0b:	88 ff ff 
    1a0e:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    1a12:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    1a19:	ff d0                	call   *%rax
        if (!lru_stats) {
    1a1b:	48 85 c0             	test   %rax,%rax
    1a1e:	0f 84 72 02 00 00    	je     1c96 <balancer_ingress+0x1c96>
        if (pckt.flags & F_SYN_SET) {
    1a24:	8b 4d ac             	mov    -0x54(%rbp),%ecx
    1a27:	c1 e1 02             	shl    $0x2,%ecx
    1a2a:	f7 d1                	not    %ecx
    1a2c:	83 e1 08             	and    $0x8,%ecx
    1a2f:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
  struct real_pos_lru new_dst_lru = {};
    1a34:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    1a3b:	00 
    1a3c:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    1a43:	00 
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1a44:	c7 45 b8 02 02 00 00 	movl   $0x202,-0x48(%rbp)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1a4b:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
    1a52:	88 ff ff 
    1a55:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
    1a59:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    1a60:	ff d0                	call   *%rax
    1a62:	41 b7 01             	mov    $0x1,%r15b
  if (!conn_rate_stats) {
    1a65:	48 85 c0             	test   %rax,%rax
    1a68:	0f 84 f5 00 00 00    	je     1b63 <balancer_ingress+0x1b63>
    1a6e:	48 89 c3             	mov    %rax,%rbx
    1a71:	48 c7 c0 30 d6 09 9f 	mov    $0xffffffff9f09d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1a78:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1a7a:	48 89 c1             	mov    %rax,%rcx
    1a7d:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1a81:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1a88:	0f 82 d9 00 00 00    	jb     1b67 <balancer_ingress+0x1b67>
    conn_rate_stats->v1 = 1;
    1a8e:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1a95:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1a99:	e9 dc 00 00 00       	jmp    1b7a <balancer_ingress+0x1b7a>
    1a9e:	48 c7 c0 20 5c 23 a1 	mov    $0xffffffffa1235c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1aa5:	4c 89 ef             	mov    %r13,%rdi
    1aa8:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1aad:	ff d0                	call   *%rax
    1aaf:	85 c0                	test   %eax,%eax
    1ab1:	0f 85 e4 01 00 00    	jne    1c9b <balancer_ingress+0x1c9b>
  data = (void*)(long)xdp->data;
    1ab7:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1abb:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1abf:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1ac3:	48 39 ca             	cmp    %rcx,%rdx
    1ac6:	0f 87 cf 01 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
    1acc:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1ad0:	48 39 ca             	cmp    %rcx,%rdx
    1ad3:	0f 87 c2 01 00 00    	ja     1c9b <balancer_ingress+0x1c9b>
    1ad9:	48 b9 00 d8 b9 7e 81 	movabs $0xffff88817eb9d800,%rcx
    1ae0:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1ae3:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1aea:	66 89 50 04          	mov    %dx,0x4(%rax)
    1aee:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1af4:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1af6:	8b 48 28             	mov    0x28(%rax),%ecx
    1af9:	89 48 06             	mov    %ecx,0x6(%rax)
    1afc:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    1b00:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    1b04:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    1b0a:	0f b7 4d a0          	movzwl -0x60(%rbp),%ecx
  saddr[3] = src ^ port;
    1b0e:	33 4d 80             	xor    -0x80(%rbp),%ecx
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1b11:	8a 5d ad             	mov    -0x53(%rbp),%bl
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1b14:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    1b1a:	89 da                	mov    %ebx,%edx
    1b1c:	c0 ea 04             	shr    $0x4,%dl
    1b1f:	80 ca 60             	or     $0x60,%dl
    1b22:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1b25:	c0 e3 04             	shl    $0x4,%bl
    1b28:	88 58 0f             	mov    %bl,0xf(%rax)
  ip6h->nexthdr = proto;
    1b2b:	66 c7 40 14 04 40    	movw   $0x4004,0x14(%rax)
    1b31:	0f b7 55 b4          	movzwl -0x4c(%rbp),%edx
  ip6h->payload_len = bpf_htons(payload_len);
    1b35:	66 89 50 12          	mov    %dx,0x12(%rax)
    1b39:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    1b40:	00 
    1b41:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    1b48:	89 48 22             	mov    %ecx,0x22(%rax)
    1b4b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    1b4f:	48 8b 0a             	mov    (%rdx),%rcx
    1b52:	48 8b 52 08          	mov    0x8(%rdx),%rdx
    1b56:	48 89 48 26          	mov    %rcx,0x26(%rax)
    1b5a:	48 89 50 2e          	mov    %rdx,0x2e(%rax)
    1b5e:	e9 a1 e8 ff ff       	jmp    404 <balancer_ingress+0x404>
    1b63:	31 c0                	xor    %eax,%eax
    1b65:	eb 16                	jmp    1b7d <balancer_ingress+0x1b7d>
    conn_rate_stats->v1 += 1;
    1b67:	48 8b 0b             	mov    (%rbx),%rcx
    1b6a:	48 83 c1 01          	add    $0x1,%rcx
    1b6e:	48 89 0b             	mov    %rcx,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1b71:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    1b78:	77 03                	ja     1b7d <balancer_ingress+0x1b7d>
    1b7a:	45 31 ff             	xor    %r15d,%r15d
    1b7d:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1b81:	f6 01 08             	testb  $0x8,(%rcx)
    1b84:	75 05                	jne    1b8b <balancer_ingress+0x1b8b>
    1b86:	8b 55 80             	mov    -0x80(%rbp),%edx
    1b89:	eb 1a                	jmp    1ba5 <balancer_ingress+0x1ba5>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1b8b:	0f b7 4d a2          	movzwl -0x5e(%rbp),%ecx
    1b8f:	66 89 4d a0          	mov    %cx,-0x60(%rbp)
      memset(pckt->flow.srcv6, 0, 16);
    1b93:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
    1b9a:	00 
    1b9b:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    1ba2:	00 
    1ba3:	31 d2                	xor    %edx,%edx
    1ba5:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  b += initval;
    1baa:	03 75 a0             	add    -0x60(%rbp),%esi
  a += initval;
    1bad:	81 c2 f7 c0 ad e0    	add    $0xe0adc0f7,%edx
  __jhash_final(a, b, c);
    1bb3:	89 f1                	mov    %esi,%ecx
    1bb5:	81 f1 f7 c0 ad e0    	xor    $0xe0adc0f7,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1bbb:	89 f7                	mov    %esi,%edi
    1bbd:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    1bc0:	29 f9                	sub    %edi,%ecx
    1bc2:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1bc4:	89 cf                	mov    %ecx,%edi
    1bc6:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    1bc9:	29 fa                	sub    %edi,%edx
    1bcb:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1bcd:	89 d7                	mov    %edx,%edi
    1bcf:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    1bd2:	29 fe                	sub    %edi,%esi
    1bd4:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1bd6:	89 f7                	mov    %esi,%edi
    1bd8:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    1bdb:	29 f9                	sub    %edi,%ecx
    1bdd:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1bdf:	89 cf                	mov    %ecx,%edi
    1be1:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1be4:	29 fa                	sub    %edi,%edx
    1be6:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1be8:	c1 c2 0e             	rol    $0xe,%edx
  __jhash_final(a, b, c);
    1beb:	29 d6                	sub    %edx,%esi
    1bed:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1bef:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    1bf2:	29 f1                	sub    %esi,%ecx
    1bf4:	ba 01 00 ff ff       	mov    $0xffff0001,%edx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1bf9:	48 0f af d1          	imul   %rcx,%rdx
    1bfd:	48 c1 ea 30          	shr    $0x30,%rdx
    1c01:	89 d6                	mov    %edx,%esi
    1c03:	c1 e6 10             	shl    $0x10,%esi
    1c06:	09 d6                	or     %edx,%esi
    1c08:	29 f1                	sub    %esi,%ecx
    1c0a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1c0e:	8b 72 04             	mov    0x4(%rdx),%esi
    1c11:	89 f2                	mov    %esi,%edx
    1c13:	c1 e2 10             	shl    $0x10,%edx
    1c16:	01 f2                	add    %esi,%edx
    1c18:	01 ca                	add    %ecx,%edx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1c1a:	81 fa ff 01 00 02    	cmp    $0x20001ff,%edx
    if (!real_pos) {
    1c20:	77 74                	ja     1c96 <balancer_ingress+0x1c96>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1c22:	89 d1                	mov    %edx,%ecx
    1c24:	48 ba 00 10 73 30 03 	movabs $0xffffc90330731000,%rdx
    1c2b:	c9 ff ff 
    key = *real_pos;
    1c2e:	8b 9c 8a 00 01 00 00 	mov    0x100(%rdx,%rcx,4),%ebx
    1c35:	48 85 db             	test   %rbx,%rbx
    if (key == 0) {
    1c38:	74 34                	je     1c6e <balancer_ingress+0x1c6e>
  pckt->real_index = key;
    1c3a:	89 5d a8             	mov    %ebx,-0x58(%rbp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1c3d:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  if (!(*real)) {
    1c43:	72 6a                	jb     1caf <balancer_ingress+0x1caf>
    1c45:	c7 45 b8 09 02 00 00 	movl   $0x209,-0x48(%rbp)
    1c4c:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
    1c53:	88 ff ff 
    1c56:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
    1c5a:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    1c61:	ff d0                	call   *%rax
    1c63:	48 85 c0             	test   %rax,%rax
    1c66:	74 2e                	je     1c96 <balancer_ingress+0x1c96>
    1c68:	48 83 00 01          	addq   $0x1,(%rax)
    1c6c:	eb 28                	jmp    1c96 <balancer_ingress+0x1c96>
    1c6e:	c7 45 b8 09 02 00 00 	movl   $0x209,-0x48(%rbp)
    1c75:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
    1c7c:	88 ff ff 
    1c7f:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
    1c83:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    1c8a:	ff d0                	call   *%rax
    1c8c:	48 85 c0             	test   %rax,%rax
    1c8f:	74 05                	je     1c96 <balancer_ingress+0x1c96>
    1c91:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    1c96:	bb 01 00 00 00       	mov    $0x1,%ebx
    return process_packet(ctx, nh_off, true);
  } else {
    // pass to tcp/ip stack
    return XDP_PASS;
  }
}
    1c9b:	89 d8                	mov    %ebx,%eax
    1c9d:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
    1ca4:	5b                   	pop    %rbx
    1ca5:	41 5c                	pop    %r12
    1ca7:	41 5d                	pop    %r13
    1ca9:	41 5e                	pop    %r14
    1cab:	41 5f                	pop    %r15
    1cad:	5d                   	pop    %rbp
    1cae:	c3                   	ret
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1caf:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
    1cb6:	00 
    1cb7:	74 10                	je     1cc9 <balancer_ingress+0x1cc9>
    1cb9:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    1cbd:	8a 09                	mov    (%rcx),%cl
    1cbf:	80 e1 02             	and    $0x2,%cl
    1cc2:	d0 e9                	shr    %cl
    1cc4:	41 08 cf             	or     %cl,%r15b
    1cc7:	74 05                	je     1cce <balancer_ingress+0x1cce>
    1cc9:	41 89 d8             	mov    %ebx,%r8d
    1ccc:	eb 2b                	jmp    1cf9 <balancer_ingress+0x1cf9>
    if (pckt->flow.proto == IPPROTO_UDP) {
    1cce:	80 7d a4 11          	cmpb   $0x11,-0x5c(%rbp)
    1cd2:	75 04                	jne    1cd8 <balancer_ingress+0x1cd8>
      new_dst_lru.atime = cur_time;
    1cd4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    new_dst_lru.pos = key;
    1cd8:	89 5d c0             	mov    %ebx,-0x40(%rbp)
    1cdb:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
    1cdf:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
    1ce3:	48 c7 c0 c0 c9 09 9f 	mov    $0xffffffff9f09c9c0,%rax
    1cea:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1cf1:	31 c9                	xor    %ecx,%ecx
    1cf3:	ff d0                	call   *%rax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    1cf5:	44 8b 45 a8          	mov    -0x58(%rbp),%r8d
    1cf9:	48 bf 00 dc b9 7e 81 	movabs $0xffff88817eb9dc00,%rdi
    1d00:	88 ff ff 
    1d03:	8b 87 00 01 00 00    	mov    0x100(%rdi),%eax
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1d09:	0f b7 97 10 01 00 00 	movzwl 0x110(%rdi),%edx
    1d10:	0f b7 b5 68 ff ff ff 	movzwl -0x98(%rbp),%esi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1d17:	8a 8d 6a ff ff ff    	mov    -0x96(%rbp),%cl
    1d1d:	88 8f 12 01 00 00    	mov    %cl,0x112(%rdi)
    1d23:	3b 85 58 ff ff ff    	cmp    -0xa8(%rbp),%eax
  bool vip_match = address_match && port_match && proto_match;
    1d29:	75 30                	jne    1d5b <balancer_ingress+0x1d5b>
    1d2b:	66 39 f2             	cmp    %si,%dx
    1d2e:	75 2b                	jne    1d5b <balancer_ingress+0x1d5b>
    1d30:	84 c9                	test   %cl,%cl
    1d32:	74 27                	je     1d5b <balancer_ingress+0x1d5b>
    __u32 lru_stats_key = pckt->real_index;
    1d34:	44 89 45 c0          	mov    %r8d,-0x40(%rbp)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1d38:	48 bf 00 a0 7d 40 03 	movabs $0xffffc903407da000,%rdi
    1d3f:	c9 ff ff 
    1d42:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    1d46:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    1d4d:	ff d0                	call   *%rax
    if (!lru_miss_stat) {
    1d4f:	48 85 c0             	test   %rax,%rax
    1d52:	0f 84 3e ff ff ff    	je     1c96 <balancer_ingress+0x1c96>
    *lru_miss_stat += 1;
    1d58:	83 00 01             	addl   $0x1,(%rax)
    1d5b:	48 8d 04 9b          	lea    (%rbx,%rbx,4),%rax
    1d5f:	48 b9 00 60 7b 40 03 	movabs $0xffffc903407b6000,%rcx
    1d66:	c9 ff ff 
    1d69:	48 8d 04 81          	lea    (%rcx,%rax,4),%rax
    1d6d:	48 05 00 01 00 00    	add    $0x100,%rax
    1d73:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    1d77:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
      data_stats->v2 += 1;
    1d7e:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    1d83:	e9 a4 fa ff ff       	jmp    182c <balancer_ingress+0x182c>
    1d88:	48 83 43 28 01       	addq   $0x1,0x28(%rbx)
    1d8d:	e9 04 ff ff ff       	jmp    1c96 <balancer_ingress+0x1c96>
      dst_lru->pos = pckt->real_index;
    1d92:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1d94:	48 83 43 58 01       	addq   $0x1,0x58(%rbx)
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    1d99:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
    1d9f:	89 45 c0             	mov    %eax,-0x40(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1da2:	48 bf 00 c0 75 c4 81 	movabs $0xffff8881c475c000,%rdi
    1da9:	88 ff ff 
    1dac:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    1db0:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    1db7:	ff d0                	call   *%rax
  if (!per_vip_stats) {
    1db9:	48 85 c0             	test   %rax,%rax
    1dbc:	74 4e                	je     1e0c <balancer_ingress+0x1e0c>
    per_vip_stats->v2 += 1;
    1dbe:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    1dc3:	eb 47                	jmp    1e0c <balancer_ingress+0x1e0c>
    conn_rate_stats->v1 += 1;
    1dc5:	49 8b 06             	mov    (%r14),%rax
    1dc8:	48 83 c0 01          	add    $0x1,%rax
    1dcc:	49 89 06             	mov    %rax,(%r14)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1dcf:	48 3d 49 e8 01 00    	cmp    $0x1e849,%rax
    1dd5:	73 30                	jae    1e07 <balancer_ingress+0x1e07>
  struct real_pos_lru new_dst_lru = {};
    1dd7:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    1dde:	00 
    1ddf:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    1de6:	00 
  new_dst_lru.pos = pckt->real_index;
    1de7:	8b 45 a8             	mov    -0x58(%rbp),%eax
    1dea:	89 45 c0             	mov    %eax,-0x40(%rbp)
    1ded:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
    1df1:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
    1df5:	48 c7 c0 c0 c9 09 9f 	mov    $0xffffffff9f09c9c0,%rax
    1dfc:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1e03:	31 c9                	xor    %ecx,%ecx
    1e05:	ff d0                	call   *%rax
              quic_packets_stats->dst_not_found_in_lru += 1;
    1e07:	48 83 43 60 01       	addq   $0x1,0x60(%rbx)
            quic_packets_stats->cid_routed += 1;
    1e0c:	48 83 43 20 01       	addq   $0x1,0x20(%rbx)
  original_sport = pckt.flow.port16[0];
    1e11:	44 0f b7 75 a0       	movzwl -0x60(%rbp),%r14d
    1e16:	e9 e1 ef ff ff       	jmp    dfc <balancer_ingress+0xdfc>
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1e1b:	c7 45 c0 02 02 00 00 	movl   $0x202,-0x40(%rbp)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1e22:	48 bf 00 c0 71 77 81 	movabs $0xffff88817771c000,%rdi
    1e29:	88 ff ff 
    1e2c:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    1e30:	41 ff d6             	call   *%r14
  if (!conn_rate_stats) {
    1e33:	48 85 c0             	test   %rax,%rax
    1e36:	0f 84 9e 00 00 00    	je     1eda <balancer_ingress+0x1eda>
    1e3c:	49 89 c6             	mov    %rax,%r14
    1e3f:	48 c7 c0 30 d6 09 9f 	mov    $0xffffffff9f09d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1e46:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1e48:	48 89 c1             	mov    %rax,%rcx
    1e4b:	49 2b 4e 08          	sub    0x8(%r14),%rcx
    1e4f:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1e56:	72 40                	jb     1e98 <balancer_ingress+0x1e98>
    conn_rate_stats->v1 = 1;
    1e58:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    conn_rate_stats->v2 = *cur_time;
    1e5f:	49 89 46 08          	mov    %rax,0x8(%r14)
    1e63:	eb 45                	jmp    1eaa <balancer_ingress+0x1eaa>
      dst_lru->pos = pckt->real_index;
    1e65:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1e67:	48 83 43 58 01       	addq   $0x1,0x58(%rbx)
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    1e6c:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
    1e72:	89 45 c0             	mov    %eax,-0x40(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1e75:	48 bf 00 c0 75 c4 81 	movabs $0xffff8881c475c000,%rdi
    1e7c:	88 ff ff 
    1e7f:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    1e83:	48 c7 c0 30 c9 09 9f 	mov    $0xffffffff9f09c930,%rax
    1e8a:	ff d0                	call   *%rax
  if (!per_vip_stats) {
    1e8c:	48 85 c0             	test   %rax,%rax
    1e8f:	74 4e                	je     1edf <balancer_ingress+0x1edf>
    per_vip_stats->v2 += 1;
    1e91:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    1e96:	eb 47                	jmp    1edf <balancer_ingress+0x1edf>
    conn_rate_stats->v1 += 1;
    1e98:	49 8b 06             	mov    (%r14),%rax
    1e9b:	48 83 c0 01          	add    $0x1,%rax
    1e9f:	49 89 06             	mov    %rax,(%r14)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1ea2:	48 3d 49 e8 01 00    	cmp    $0x1e849,%rax
    1ea8:	73 30                	jae    1eda <balancer_ingress+0x1eda>
  struct real_pos_lru new_dst_lru = {};
    1eaa:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    1eb1:	00 
    1eb2:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    1eb9:	00 
  new_dst_lru.pos = pckt->real_index;
    1eba:	8b 45 a8             	mov    -0x58(%rbp),%eax
    1ebd:	89 45 c0             	mov    %eax,-0x40(%rbp)
    1ec0:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
    1ec4:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
    1ec8:	48 c7 c0 c0 c9 09 9f 	mov    $0xffffffff9f09c9c0,%rax
    1ecf:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1ed6:	31 c9                	xor    %ecx,%ecx
    1ed8:	ff d0                	call   *%rax
              quic_packets_stats->dst_not_found_in_lru += 1;
    1eda:	48 83 43 60 01       	addq   $0x1,0x60(%rbx)
            quic_packets_stats->cid_routed += 1;
    1edf:	48 83 43 20 01       	addq   $0x1,0x20(%rbx)
  original_sport = pckt.flow.port16[0];
    1ee4:	0f b7 45 a0          	movzwl -0x60(%rbp),%eax
    1ee8:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
    1eee:	e9 39 f9 ff ff       	jmp    182c <balancer_ingress+0x182c>

Disassembly of section license:

0000000000001ef3 <_license>:
    1ef3:	47 50                	rex.RXB push %r8
    1ef5:	4c                   	rex.WR
	...

Disassembly of section .debug_loclists:

0000000000000000 <.debug_loclists>:
int balancer_ingress(struct xdp_md* ctx) {
       0:	19 2c 00             	sbb    %ebp,(%rax,%rax,1)
       3:	00 05 00 08 00 52    	add    %al,0x52000800(%rip)        # 52000809 <_license+0x51ffe916>
       9:	01 00                	add    %eax,(%rax)
       b:	00 48 05             	add    %cl,0x5(%rax)
       e:	00 00                	add    %al,(%rax)
      10:	65 05 00 00 88 05    	gs add $0x5880000,%eax
      16:	00 00                	add    %al,(%rax)
  void* data = (void*)(long)ctx->data;
      18:	c7 05 00 00 ea 05 00 	movl   $0x5f20000,0x5ea0000(%rip)        # 5ea0022 <_license+0x5e9e12f>
      1f:	00 f2 05 
  if (data + nh_off > data_end) {
      22:	00 00                	add    %al,(%rax)
      24:	22 06                	and    (%rsi),%al
      26:	00 00                	add    %al,(%rax)
      28:	7d 06                	jge    30 <balancer_ingress+0x30>
      2a:	00 00                	add    %al,(%rax)
      2c:	e5 06                	in     $0x6,%eax
      2e:	00 00                	add    %al,(%rax)
      30:	4d 07                	rex.WRB (bad)
      32:	00 00                	add    %al,(%rax)
  eth_proto = eth->h_proto;
      34:	77 07                	ja     3d <balancer_ingress+0x3d>
      36:	00 00                	add    %al,(%rax)
      38:	d2 07                	rolb   %cl,(%rdi)
  if (eth_proto == BE_ETH_P_IP) {
      3a:	00 00                	add    %al,(%rax)
      3c:	84 08                	test   %cl,(%rax)
      3e:	00 00                	add    %al,(%rax)
      40:	ed                   	in     (%dx),%eax
      41:	08 00                	or     %al,(%rax)
      43:	00 18                	add    %bl,(%rax)
      45:	09 00                	or     %eax,(%rax)
      47:	00 2d 09 00 00 3e    	add    %ch,0x3e000009(%rip)        # 3e000056 <_license+0x3dffe163>
      4d:	09 00                	or     %eax,(%rax)
      4f:	00 4d 09             	add    %cl,0x9(%rbp)
      52:	00 00                	add    %al,(%rax)
  struct packet_description pckt = {};
      54:	5c                   	pop    %rsp
      55:	09 00                	or     %eax,(%rax)
      57:	00 6d 09             	add    %ch,0x9(%rbp)
      5a:	00 00                	add    %al,(%rax)
      5c:	7e 09                	jle    67 <balancer_ingress+0x67>
      5e:	00 00                	add    %al,(%rax)
      60:	8d 09                	lea    (%rcx),%ecx
      62:	00 00                	add    %al,(%rax)
      64:	9c                   	pushf
      65:	09 00                	or     %eax,(%rax)
      67:	00 b8 09 00 00 cd    	add    %bh,-0x32fffff7(%rax)
      6d:	09 00                	or     %eax,(%rax)
      6f:	00 dc                	add    %bl,%ah
      71:	09 00                	or     %eax,(%rax)
      73:	00 ec                	add    %ch,%ah
      75:	09 00                	or     %eax,(%rax)
      77:	00 35 0a 00 00 6e    	add    %dh,0x6e00000a(%rip)        # 6e000087 <_license+0x6dffe194>
      7d:	0a 00                	or     (%rax),%al
      7f:	00 7d 0a             	add    %bh,0xa(%rbp)
      82:	00 00                	add    %al,(%rax)
  struct vip_definition vip = {};
      84:	87 0a                	xchg   %ecx,(%rdx)
      86:	00 00                	add    %al,(%rax)
      88:	d5                   	(bad)
      89:	0a 00                	or     (%rax),%al
      8b:	00 2e                	add    %ch,(%rsi)
      8d:	0b 00                	or     (%rax),%eax
      8f:	00 87 0b 00 00 b9    	add    %al,-0x46fffff5(%rdi)
      95:	0b 00                	or     (%rax),%eax
      97:	00 1c 0c             	add    %bl,(%rsp,%rcx,1)
      9a:	00 00                	add    %al,(%rax)
      9c:	c5 0c 00             	(bad)
      9f:	00 1e                	add    %bl,(%rsi)
      a1:	0d 00 00 49 0d       	or     $0xd490000,%eax
    if (iph + 1 > data_end) {
      a6:	00 00                	add    %al,(%rax)
      a8:	5e                   	pop    %rsi
      a9:	0d 00 00 6f 0d       	or     $0xd6f0000,%eax
      ae:	00 00                	add    %al,(%rax)
      b0:	7e 0d                	jle    bf <balancer_ingress+0xbf>
    if (iph->ihl != 5) {
      b2:	00 00                	add    %al,(%rax)
      b4:	8d 0d 00 00 9e 0d    	lea    0xd9e0000(%rip),%ecx        # d9e00ba <_license+0xd9de1c7>
      ba:	00 00                	add    %al,(%rax)
      bc:	af                   	scas   %es:(%rdi),%eax
    pckt->tos = iph->tos;
      bd:	0d 00 00 c2 0d       	or     $0xdc20000,%eax
      c2:	00 00                	add    %al,(%rax)
    *protocol = iph->protocol;
      c4:	d1 0d 00 00 e0 0d    	rorl   0xde00000(%rip)        # de000ca <_license+0xddfe1d7>
    pckt->flow.proto = *protocol;
      ca:	00 00                	add    %al,(%rax)
    if (iph->frag_off & PCKT_FRAGMENTED) {
      cc:	f5                   	cmc
      cd:	0d 00 00 04 0e       	or     $0xe040000,%eax
      d2:	00 00                	add    %al,(%rax)
      d4:	5f                   	pop    %rdi
      d5:	0e                   	(bad)
      d6:	00 00                	add    %al,(%rax)
      d8:	75 0e                	jne    e8 <balancer_ingress+0xe8>
      da:	00 00                	add    %al,(%rax)
      dc:	84 0e                	test   %cl,(%rsi)
      de:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
      e0:	93                   	xchg   %eax,%ebx
      e1:	0e                   	(bad)
      e2:	00 00                	add    %al,(%rax)
      e4:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
      e5:	0e                   	(bad)
      e6:	00 00                	add    %al,(%rax)
      e8:	bb 0e 00 00 c3       	mov    $0xc300000e,%ebx
  if (icmp_hdr + 1 > data_end) {
      ed:	0e                   	(bad)
      ee:	00 00                	add    %al,(%rax)
      f0:	d2 0e                	rorb   %cl,(%rsi)
      f2:	00 00                	add    %al,(%rax)
      f4:	e1 0e                	loope  104 <balancer_ingress+0x104>
  if (icmp_hdr->type == ICMP_ECHO) {
      f6:	00 00                	add    %al,(%rax)
      f8:	fd                   	std
      f9:	0e                   	(bad)
      fa:	00 00                	add    %al,(%rax)
      fc:	12 0f                	adc    (%rdi),%cl
      fe:	00 00                	add    %al,(%rax)
     100:	21 0f                	and    %ecx,(%rdi)
     102:	00 00                	add    %al,(%rax)
     104:	31 0f                	xor    %ecx,(%rdi)
     106:	00 00                	add    %al,(%rax)
     108:	43 0f 00 00          	rex.XB sldt (%r8)
     10c:	4d 0f 00 00          	rex.WRB sldt (%r8)
     110:	a8 0f                	test   $0xf,%al
     112:	00 00                	add    %al,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
     114:	f3 0f 00 00          	repz sldt (%rax)
     118:	fd                   	std
  icmp_hdr->checksum += 0x0008;
     119:	0f 00 00             	sldt   (%rax)
     11c:	05 10 00 00 0d       	add    $0xd000010,%eax
  iph->ttl = DEFAULT_TTL;
     121:	10 00                	adc    %al,(%rax)
     123:	00 83 10 00 00 a0    	add    %al,-0x5ffffff0(%rbx)
  tmp_addr = iph->daddr;
     129:	10 00                	adc    %al,(%rax)
     12b:	00 af 10 00 00 be    	add    %ch,-0x41fffff0(%rdi)
  iph->saddr = tmp_addr;
     131:	10 00                	adc    %al,(%rax)
     133:	00 d1                	add    %dl,%cl
     135:	10 00                	adc    %al,(%rax)
     137:	00 e6                	add    %ah,%dh
     139:	10 00                	adc    %al,(%rax)
     13b:	00 f5                	add    %dh,%ch
     13d:	10 00                	adc    %al,(%rax)
     13f:	00 04 11             	add    %al,(%rcx,%rdx,1)
     142:	00 00                	add    %al,(%rax)
     144:	13 11                	adc    (%rcx),%edx
     146:	00 00                	add    %al,(%rax)
     148:	2f                   	(bad)
     149:	11 00                	adc    %eax,(%rax)
     14b:	00 44 11 00          	add    %al,0x0(%rcx,%rdx,1)
     14f:	00 53 11             	add    %dl,0x11(%rbx)
     152:	00 00                	add    %al,(%rax)
     154:	5b                   	pop    %rbx
     155:	11 00                	adc    %eax,(%rax)
     157:	00 63 11             	add    %ah,0x11(%rbx)
     15a:	00 00                	add    %al,(%rax)
     15c:	76 11                	jbe    16f <balancer_ingress+0x16f>
     15e:	00 00                	add    %al,(%rax)
     160:	86 11                	xchg   %dl,(%rcx)
     162:	00 00                	add    %al,(%rax)
     164:	8e 11                	mov    (%rcx),%ss
     166:	00 00                	add    %al,(%rax)
     168:	96                   	xchg   %eax,%esi
    if (csum >> 16)
     169:	11 00                	adc    %eax,(%rax)
     16b:	00 a0 11 00 00 aa    	add    %ah,-0x55ffffef(%rax)
     171:	11 00                	adc    %eax,(%rax)
     173:	00 ba 11 00 00 d3    	add    %bh,-0x2cffffef(%rdx)
     179:	12 00                	adc    (%rax),%al
     17b:	00 1d 13 00 00 2d    	add    %bl,0x2d000013(%rip)        # 2d000194 <_license+0x2cffe2a1>
     181:	13 00                	adc    (%rax),%eax
     183:	00 a4 13 00 00 2f 14 	add    %ah,0x142f0000(%rbx,%rdx,1)
  struct packet_description pckt = {};
     18a:	00 00                	add    %al,(%rax)
     18c:	76 14                	jbe    1a2 <balancer_ingress+0x1a2>
     18e:	00 00                	add    %al,(%rax)
     190:	8f                   	(bad)
     191:	14 00                	adc    $0x0,%al
     193:	00 2f                	add    %ch,(%rdi)
     195:	15 00 00 42 15       	adc    $0x15420000,%eax
     19a:	00 00                	add    %al,(%rax)
     19c:	52                   	push   %rdx
     19d:	15 00 00 5a 15       	adc    $0x155a0000,%eax
     1a2:	00 00                	add    %al,(%rax)
     1a4:	a2 15 00 00 b2 15 00 	movabs %al,0xf2000015b2000015
     1ab:	00 f2 
     1ad:	15 00 00 fa 15       	adc    $0x15fa0000,%eax
     1b2:	00 00                	add    %al,(%rax)
     1b4:	17                   	(bad)
     1b5:	16                   	(bad)
  struct vip_definition vip = {};
     1b6:	00 00                	add    %al,(%rax)
     1b8:	38 16                	cmp    %dl,(%rsi)
     1ba:	00 00                	add    %al,(%rax)
     1bc:	54                   	push   %rsp
     1bd:	17                   	(bad)
     1be:	00 00                	add    %al,(%rax)
     1c0:	67 17                	addr32 (bad)
     1c2:	00 00                	add    %al,(%rax)
     1c4:	77 17                	ja     1dd <balancer_ingress+0x1dd>
     1c6:	00 00                	add    %al,(%rax)
     1c8:	7f 17                	jg     1e1 <balancer_ingress+0x1e1>
     1ca:	00 00                	add    %al,(%rax)
     1cc:	90                   	nop
     1cd:	17                   	(bad)
     1ce:	00 00                	add    %al,(%rax)
     1d0:	a0 17 00 00 a8 17 00 	movabs 0xbb000017a8000017,%al
     1d7:	00 bb 
    if (ip6h + 1 > data_end) {
     1d9:	17                   	(bad)
     1da:	00 00                	add    %al,(%rax)
     1dc:	cb                   	lret
     1dd:	17                   	(bad)
     1de:	00 00                	add    %al,(%rax)
     1e0:	d3 17                	rcll   %cl,(%rdi)
     1e2:	00 00                	add    %al,(%rax)
    *protocol = ip6h->nexthdr;
     1e4:	e4 17                	in     $0x17,%al
     1e6:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
     1e8:	f4                   	hlt
     1e9:	17                   	(bad)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1ea:	00 00                	add    %al,(%rax)
     1ec:	c2 18 00             	ret    $0x18
     1ef:	00 27                	add    %ah,(%rdi)
     1f1:	19 00                	sbb    %eax,(%rax)
     1f3:	00 37                	add    %dh,(%rdi)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1f5:	19 00                	sbb    %eax,(%rax)
     1f7:	00 b7 19 00 00 30    	add    %dh,0x30000019(%rdi)
     1fd:	1a 00                	sbb    (%rax),%al
     1ff:	00 92 1a 00 00 ab    	add    %dl,-0x54ffffe6(%rdx)
    if (*protocol == IPPROTO_FRAGMENT) {
     205:	1a 00                	sbb    (%rax),%al
     207:	00 66 1b             	add    %ah,0x1b(%rsi)
     20a:	00 00                	add    %al,(%rax)
     20c:	79 1b                	jns    229 <balancer_ingress+0x229>
     20e:	00 00                	add    %al,(%rax)
     210:	89 1b                	mov    %ebx,(%rbx)
     212:	00 00                	add    %al,(%rax)
     214:	91                   	xchg   %eax,%ecx
  if (icmp_hdr + 1 > data_end) {
     215:	1b 00                	sbb    (%rax),%eax
     217:	00 d0                	add    %dl,%al
     219:	1b 00                	sbb    (%rax),%eax
     21b:	00 e0                	add    %ah,%al
     21d:	1b 00                	sbb    (%rax),%eax
     21f:	00 12                	add    %dl,(%rdx)
     221:	1c 00                	sbb    $0x0,%al
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     223:	00 1a                	add    %bl,(%rdx)
     225:	1c 00                	sbb    $0x0,%al
     227:	00 37                	add    %dh,(%rdi)
     229:	1c 00                	sbb    $0x0,%al
     22b:	00 58 1c             	add    %bl,0x1c(%rax)
     22e:	00 00                	add    %al,(%rax)
     230:	5c                   	pop    %rsp
     231:	1d 00 00 72 1d       	sbb    $0x1d720000,%eax
     236:	00 00                	add    %al,(%rax)
     238:	88 1d 00 00 b6 1d    	mov    %bl,0x1db60000(%rip)        # 1db6023e <_license+0x1db5e34b>
     23e:	00 00                	add    %al,(%rax)
     240:	c6                   	(bad)
     241:	1d 00 00 d9 1d       	sbb    $0x1dd90000,%eax
     246:	00 00                	add    %al,(%rax)
     248:	e9 1d 00 00 f1       	jmp    fffffffff100026a <server_id_map+0x36fcb081c26a>
     24d:	1d 00 00 f9 1d       	sbb    $0x1df90000,%eax
     252:	00 00                	add    %al,(%rax)
     254:	03 1e                	add    (%rsi),%ebx
     256:	00 00                	add    %al,(%rax)
     258:	16                   	(bad)
     259:	1e                   	(bad)
     25a:	00 00                	add    %al,(%rax)
     25c:	26 1e                	es (bad)
     25e:	00 00                	add    %al,(%rax)
     260:	2e 1e                	cs (bad)
     262:	00 00                	add    %al,(%rax)
     264:	43 1e                	rex.XB (bad)
     266:	00 00                	add    %al,(%rax)
     268:	5d                   	pop    %rbp
     269:	1e                   	(bad)
     26a:	00 00                	add    %al,(%rax)
     26c:	6e                   	outsb  %ds:(%rsi),(%dx)
     26d:	1e                   	(bad)
     26e:	00 00                	add    %al,(%rax)
     270:	84 1e                	test   %bl,(%rsi)
     272:	00 00                	add    %al,(%rax)
     274:	93                   	xchg   %eax,%ebx
     275:	1e                   	(bad)
     276:	00 00                	add    %al,(%rax)
     278:	a9 1e 00 00 bf       	test   $0xbf00001e,%eax
     27d:	1e                   	(bad)
     27e:	00 00                	add    %al,(%rax)
     280:	ed                   	in     (%dx),%eax
     281:	1e                   	(bad)
     282:	00 00                	add    %al,(%rax)
     284:	03 1f                	add    (%rdi),%ebx
     286:	00 00                	add    %al,(%rax)
     288:	16                   	(bad)
     289:	1f                   	(bad)
     28a:	00 00                	add    %al,(%rax)
     28c:	26 1f                	es (bad)
     28e:	00 00                	add    %al,(%rax)
     290:	2e 1f                	cs (bad)
     292:	00 00                	add    %al,(%rax)
     294:	3e 1f                	ds (bad)
     296:	00 00                	add    %al,(%rax)
     298:	46 1f                	rex.RX (bad)
     29a:	00 00                	add    %al,(%rax)
     29c:	4e 1f                	rex.WRX (bad)
     29e:	00 00                	add    %al,(%rax)
     2a0:	56                   	push   %rsi
     2a1:	1f                   	(bad)
     2a2:	00 00                	add    %al,(%rax)
     2a4:	5f                   	pop    %rdi
     2a5:	1f                   	(bad)
     2a6:	00 00                	add    %al,(%rax)
     2a8:	77 1f                	ja     2c9 <balancer_ingress+0x2c9>
     2aa:	00 00                	add    %al,(%rax)
     2ac:	8a 1f                	mov    (%rdi),%bl
     2ae:	00 00                	add    %al,(%rax)
     2b0:	9a                   	(bad)
     2b1:	1f                   	(bad)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     2b2:	00 00                	add    %al,(%rax)
     2b4:	a9 1f 00 00 b9       	test   $0xb900001f,%eax
     2b9:	1f                   	(bad)
     2ba:	00 00                	add    %al,(%rax)
     2bc:	c1 1f 00             	rcrl   $0x0,(%rdi)
     2bf:	00 c9                	add    %cl,%cl
     2c1:	1f                   	(bad)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2c2:	00 00                	add    %al,(%rax)
     2c4:	dc 1f                	fcompl (%rdi)
     2c6:	00 00                	add    %al,(%rax)
     2c8:	ec                   	in     (%dx),%al
     2c9:	1f                   	(bad)
     2ca:	00 00                	add    %al,(%rax)
     2cc:	f4                   	hlt
     2cd:	1f                   	(bad)
     2ce:	00 00                	add    %al,(%rax)
     2d0:	04 20                	add    $0x20,%al
  if (protocol == IPPROTO_ICMPV6) {
     2d2:	00 00                	add    %al,(%rax)
     2d4:	14 20                	adc    $0x20,%al
     2d6:	00 00                	add    %al,(%rax)
     2d8:	2c 20                	sub    $0x20,%al
  if (icmp_hdr + 1 > data_end) {
     2da:	00 00                	add    %al,(%rax)
     2dc:	41 20 00             	and    %al,(%r8)
     2df:	00 4a 20             	add    %cl,0x20(%rdx)
     2e2:	00 00                	add    %al,(%rax)
     2e4:	52                   	push   %rdx
     2e5:	20 00                	and    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
     2e7:	00 5a 20             	add    %bl,0x20(%rdx)
     2ea:	00 00                	add    %al,(%rax)
     2ec:	62                   	(bad)
     2ed:	20 00                	and    %al,(%rax)
     2ef:	00 6c 20 00          	add    %ch,0x0(%rax,%riz,1)
     2f3:	00 81 20 00 00 b8    	add    %al,-0x47ffffe0(%rcx)
     2f9:	20 00                	and    %al,(%rax)
     2fb:	00 fd                	add    %bh,%ch
     2fd:	20 00                	and    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2ff:	00 10                	add    %dl,(%rax)
     301:	21 00                	and    %eax,(%rax)
     303:	00 20                	add    %ah,(%rax)
     305:	21 00                	and    %eax,(%rax)
     307:	00 28                	add    %ch,(%rax)
       sizeof(struct icmphdr)) > data_end) {
     309:	21 00                	and    %eax,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     30b:	00 3d 21 00 00 91    	add    %bh,-0x6effffdf(%rip)        # ffffffff91000332 <server_id_map+0x36fc5081c332>
  icmp_hdr->type = ICMP_ECHOREPLY;
     311:	21 00                	and    %eax,(%rax)
     313:	00 a2 21 00 00 bc    	add    %ah,-0x43ffffdf(%rdx)
  icmp_hdr->checksum += 0x0008;
     319:	21 00                	and    %eax,(%rax)
     31b:	00 e4                	add    %ah,%ah
  iph->ttl = DEFAULT_TTL;
     31d:	21 00                	and    %eax,(%rax)
     31f:	00 f5                	add    %dh,%ch
  iph->daddr = iph->saddr;
     321:	21 00                	and    %eax,(%rax)
     323:	00 0d 22 00 00 2a    	add    %cl,0x2a000022(%rip)        # 2a00034b <_license+0x29ffe458>
     329:	22 00                	and    (%rax),%al
     32b:	00 3a                	add    %bh,(%rdx)
  iph->saddr = tmp_addr;
     32d:	22 00                	and    (%rax),%al
     32f:	00 50 22             	add    %dl,0x22(%rax)
    *csum += *next_iph_u16++;
     332:	00 00                	add    %al,(%rax)
     334:	58                   	pop    %rax
     335:	22 00                	and    (%rax),%al
     337:	00 60 22             	add    %ah,0x22(%rax)
     33a:	00 00                	add    %al,(%rax)
     33c:	68 22 00 00 70       	push   $0x70000022
     341:	22 00                	and    (%rax),%al
     343:	00 7a 22             	add    %bh,0x22(%rdx)
     346:	00 00                	add    %al,(%rax)
     348:	84 22                	test   %ah,(%rdx)
     34a:	00 00                	add    %al,(%rax)
     34c:	ac                   	lods   %ds:(%rsi),%al
     34d:	22 00                	and    (%rax),%al
     34f:	00 b4 22 00 00 bc 22 	add    %dh,0x22bc0000(%rdx,%riz,1)
     356:	00 00                	add    %al,(%rax)
     358:	c4 22 00 00          	(bad)
     35c:	fa                   	cli
     35d:	22 00                	and    (%rax),%al
     35f:	00 17                	add    %dl,(%rdi)
     361:	23 00                	and    (%rax),%eax
     363:	00 22                	add    %ah,(%rdx)
     365:	23 00                	and    (%rax),%eax
     367:	00 2b                	add    %ch,(%rbx)
     369:	23 00                	and    (%rax),%eax
     36b:	00 36                	add    %dh,(%rsi)
     36d:	23 00                	and    (%rax),%eax
     36f:	00 5e 23             	add    %bl,0x23(%rsi)
    if (csum >> 16)
     372:	00 00                	add    %al,(%rax)
     374:	6b 23 00             	imul   $0x0,(%rbx),%esp
     377:	00 73 23             	add    %dh,0x23(%rbx)
     37a:	00 00                	add    %al,(%rax)
     37c:	7b 23                	jnp    3a1 <balancer_ingress+0x3a1>
     37e:	00 00                	add    %al,(%rax)
     380:	9d                   	popf
     381:	23 00                	and    (%rax),%eax
     383:	00 a5 23 00 00 b4    	add    %ah,-0x4bffffdd(%rbp)
     389:	23 00                	and    (%rax),%eax
     38b:	00 bc 23 00 00 c5 23 	add    %bh,0x23c50000(%rbx,%riz,1)
     392:	00 00                	add    %al,(%rax)
     394:	ce                   	(bad)
     395:	23 00                	and    (%rax),%eax
     397:	00 de                	add    %bl,%dh
     399:	23 00                	and    (%rax),%eax
     39b:	00 ee                	add    %ch,%dh
     39d:	23 00                	and    (%rax),%eax
     39f:	00 f6                	add    %dh,%dh
     3a1:	23 00                	and    (%rax),%eax
     3a3:	00 06                	add    %al,(%rsi)
     3a5:	24 00                	and    $0x0,%al
     3a7:	00 0e                	add    %cl,(%rsi)
     3a9:	24 00                	and    $0x0,%al
     3ab:	00 16                	add    %dl,(%rsi)
     3ad:	24 00                	and    $0x0,%al
     3af:	00 4d 24             	add    %cl,0x24(%rbp)
     3b2:	00 00                	add    %al,(%rax)
     3b4:	5c                   	pop    %rsp
     3b5:	24 00                	and    $0x0,%al
     3b7:	00 6b 24             	add    %ch,0x24(%rbx)
     3ba:	00 00                	add    %al,(%rax)
     3bc:	73 24                	jae    3e2 <balancer_ingress+0x3e2>
     3be:	00 00                	add    %al,(%rax)
     3c0:	89 24 00             	mov    %esp,(%rax,%rax,1)
     3c3:	00 98 24 00 00 a1    	add    %bl,-0x5effffdc(%rax)
     3c9:	24 00                	and    $0x0,%al
     3cb:	00 b1 24 00 00 b9    	add    %dh,-0x46ffffdc(%rcx)
     3d1:	24 00                	and    $0x0,%al
     3d3:	00 e2                	add    %ah,%dl
     3d5:	24 00                	and    $0x0,%al
     3d7:	00 15 25 00 00 2b    	add    %dl,0x2b000025(%rip)        # 2b000402 <_license+0x2affe50f>
     3dd:	25 00 00 3e 25       	and    $0x253e0000,%eax
     3e2:	00 00                	add    %al,(%rax)
     3e4:	80 25 00 00 8f 25 00 	andb   $0x0,0x258f0000(%rip)        # 258f03eb <_license+0x258ee4f8>
     3eb:	00 9e 25 00 00 b9    	add    %bl,-0x46ffffdb(%rsi)
     3f1:	25 00 00 c9 25       	and    $0x25c90000,%eax
     3f6:	00 00                	add    %al,(%rax)
     3f8:	df 25 00 00 ee 25    	fbld   0x25ee0000(%rip)        # 25ee03fe <_license+0x25ede50b>
     3fe:	00 00                	add    %al,(%rax)
     400:	f7 25 00 00 0f 26    	mull   0x260f0000(%rip)        # 260f0406 <_license+0x260ee513>
     406:	00 00                	add    %al,(%rax)
     408:	17                   	(bad)
     409:	26 00 00             	es add %al,(%rax)
     40c:	36 26 00 00          	ss es add %al,(%rax)
     410:	60                   	(bad)
     411:	26 00 00             	es add %al,(%rax)
     414:	76 26                	jbe    43c <balancer_ingress+0x43c>
  if (protocol == IPPROTO_TCP) {
     416:	00 00                	add    %al,(%rax)
     418:	89 26                	mov    %esp,(%rsi)
     41a:	00 00                	add    %al,(%rax)
     41c:	9e                   	sahf
     41d:	26 00 00             	es add %al,(%rax)
     420:	b8 26 00 00 c9       	mov    $0xc9000026,%eax
  tcp = data + off;
     425:	26 00 00             	es add %al,(%rax)
     428:	df 26                	fbld   (%rsi)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     42a:	00 00                	add    %al,(%rax)
  tcp = data + off;
     42c:	ee                   	out    %al,(%dx)
     42d:	26 00 00             	es add %al,(%rax)
  if (tcp + 1 > data_end) {
     430:	f6 26                	mulb   (%rsi)
     432:	00 00                	add    %al,(%rax)
     434:	fe                   	(bad)
     435:	26 00 00             	es add %al,(%rax)
     438:	07                   	(bad)
     439:	27                   	(bad)
     43a:	00 00                	add    %al,(%rax)
     43c:	1f                   	(bad)
  if (tcp->syn) {
     43d:	27                   	(bad)
     43e:	00 00                	add    %al,(%rax)
     440:	32 27                	xor    (%rdi),%ah
     442:	00 00                	add    %al,(%rax)
    pckt->flags |= F_SYN_SET;
     444:	42 27                	rex.X (bad)
     446:	00 00                	add    %al,(%rax)
     448:	51                   	push   %rcx
     449:	27                   	(bad)
     44a:	00 00                	add    %al,(%rax)
     44c:	61                   	(bad)
      pckt->flow.src = iph->saddr;
     44d:	27                   	(bad)
     44e:	00 00                	add    %al,(%rax)
     450:	69 27 00 00 71 27    	imul   $0x27710000,(%rdi),%esp
      pckt->flow.dst = iph->daddr;
     456:	00 00                	add    %al,(%rax)
     458:	84 27                	test   %ah,(%rdi)
     45a:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
     45c:	94                   	xchg   %eax,%esp
     45d:	27                   	(bad)
     45e:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
     460:	9c                   	pushf
     461:	27                   	(bad)
     462:	00 00                	add    %al,(%rax)
     464:	ac                   	lods   %ds:(%rsi),%al
     465:	27                   	(bad)
     466:	00 00                	add    %al,(%rax)
     468:	bb 27 00 00 cb       	mov    $0xcb000027,%ebx
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     46d:	27                   	(bad)
     46e:	00 00                	add    %al,(%rax)
     470:	e3 27                	jrcxz  499 <balancer_ingress+0x499>
     472:	00 00                	add    %al,(%rax)
     474:	fc                   	cld
     475:	27                   	(bad)
     476:	00 00                	add    %al,(%rax)
     478:	11 28                	adc    %ebp,(%rax)
     47a:	00 00                	add    %al,(%rax)
     47c:	1a 28                	sbb    (%rax),%ch
     47e:	00 00                	add    %al,(%rax)
     480:	22 28                	and    (%rax),%ch
     482:	00 00                	add    %al,(%rax)
     484:	2a 28                	sub    (%rax),%ch
     486:	00 00                	add    %al,(%rax)
     488:	32 28                	xor    (%rax),%ch
     48a:	00 00                	add    %al,(%rax)
     48c:	3a 28                	cmp    (%rax),%ch
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     48e:	00 00                	add    %al,(%rax)
     490:	44 28 00             	sub    %r8b,(%rax)
     493:	00 59 28             	add    %bl,0x28(%rcx)
       sizeof(struct icmp6hdr)) > data_end) {
     496:	00 00                	add    %al,(%rax)
     498:	61                   	(bad)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     499:	28 00                	sub    %al,(%rax)
     49b:	00 98 28 00 00 dd    	add    %bl,-0x22ffffd8(%rax)
     4a1:	28 00                	sub    %al,(%rax)
     4a3:	00 f0                	add    %dh,%al
  udp = data + off;
     4a5:	28 00                	sub    %al,(%rax)
     4a7:	00 00                	add    %al,(%rax)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     4a9:	29 00                	sub    %eax,(%rax)
  udp = data + off;
     4ab:	00 08                	add    %cl,(%rax)
     4ad:	29 00                	sub    %eax,(%rax)
  if (udp + 1 > data_end) {
     4af:	00 27                	add    %ah,(%rdi)
     4b1:	29 00                	sub    %eax,(%rax)
     4b3:	00 6d 29             	add    %ch,0x29(%rbp)
     4b6:	00 00                	add    %al,(%rax)
     4b8:	86 29                	xchg   %ch,(%rcx)
     4ba:	00 00                	add    %al,(%rax)
     4bc:	a9 29 00 00 e8       	test   $0xe8000029,%eax
     4c1:	29 00                	sub    %eax,(%rax)
     4c3:	00 01                	add    %al,(%rcx)
     4c5:	2a 00                	sub    (%rax),%al
     4c7:	00 21                	add    %ah,(%rcx)
     4c9:	2a 00                	sub    (%rax),%al
     4cb:	00 3e                	add    %bh,(%rsi)
     4cd:	2a 00                	sub    (%rax),%al
     4cf:	00 4e 2a             	add    %cl,0x2a(%rsi)
     4d2:	00 00                	add    %al,(%rax)
     4d4:	64 2a 00             	sub    %fs:(%rax),%al
     4d7:	00 6c 2a 00          	add    %ch,0x0(%rdx,%rbp,1)
     4db:	00 74 2a 00          	add    %dh,0x0(%rdx,%rbp,1)
     4df:	00 7c 2a 00          	add    %bh,0x0(%rdx,%rbp,1)
     4e3:	00 84 2a 00 00 8e 2a 	add    %al,0x2a8e0000(%rdx,%rbp,1)
     4ea:	00 00                	add    %al,(%rax)
     4ec:	97                   	xchg   %eax,%edi
     4ed:	2a 00                	sub    (%rax),%al
     4ef:	00 bf 2a 00 00 c7    	add    %bh,-0x38ffffd6(%rdi)
  tcp = data + off;
     4f5:	2a 00                	sub    (%rax),%al
     4f7:	00 cf                	add    %cl,%bh
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     4f9:	2a 00                	sub    (%rax),%al
  tcp = data + off;
     4fb:	00 da                	add    %bl,%dl
     4fd:	2a 00                	sub    (%rax),%al
  if (tcp + 1 > data_end) {
     4ff:	00 e3                	add    %ah,%bl
     501:	2a 00                	sub    (%rax),%al
     503:	00 eb                	add    %ch,%bl
     505:	2a 00                	sub    (%rax),%al
     507:	00 f3                	add    %dh,%bl
     509:	2a 00                	sub    (%rax),%al
     50b:	00 fb                	add    %bh,%bl
  if (tcp->syn) {
     50d:	2a 00                	sub    (%rax),%al
     50f:	00 1d 2b 00 00 25    	add    %bl,0x2500002b(%rip)        # 25000540 <_license+0x24ffe64d>
     515:	2b 00                	sub    (%rax),%eax
    pckt->flags |= F_SYN_SET;
     517:	00 42 2b             	add    %al,0x2b(%rdx)
     51a:	00 00                	add    %al,(%rax)
     51c:	4b 2b 00             	rex.WXB sub (%r8),%rax
     51f:	00 54 2b 00          	add    %dl,0x0(%rbx,%rbp,1)
     523:	00 5f 2b             	add    %bl,0x2b(%rdi)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     526:	00 00                	add    %al,(%rax)
     528:	6f                   	outsl  %ds:(%rsi),(%dx)
     529:	2b 00                	sub    (%rax),%eax
     52b:	00 7f 2b             	add    %bh,0x2b(%rdi)
        bpf_map_lookup_elem(&stats, &stats_key);
     52e:	00 00                	add    %al,(%rax)
     530:	87 2b                	xchg   %ebp,(%rbx)
     532:	00 00                	add    %al,(%rax)
     534:	97                   	xchg   %eax,%edi
     535:	2b 00                	sub    (%rax),%eax
     537:	00 9f 2b 00 00 a7    	add    %bl,-0x58ffffd5(%rdi)
     53d:	2b 00                	sub    (%rax),%eax
     53f:	00 c2                	add    %al,%dl
     541:	2b 00                	sub    (%rax),%eax
    if (!icmp_ptb_v6_stats) {
     543:	00 d2                	add    %dl,%dl
     545:	2b 00                	sub    (%rax),%eax
     547:	00 e8                	add    %ch,%al
     549:	2b 00                	sub    (%rax),%eax
     54b:	00 f8                	add    %bh,%al
    icmp_ptb_v6_stats->v1 += 1;
     54d:	2b 00                	sub    (%rax),%eax
     54f:	00 00                	add    %al,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     551:	2c 00                	sub    $0x0,%al
     553:	00 04 04             	add    %al,(%rsp,%rax,1)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     556:	45 01 55 04          	add    %r10d,0x4(%r13)
     55a:	45                   	rex.RB
     55b:	9b                   	fwait
     55c:	39 01                	cmp    %eax,(%rcx)
      icmp_ptb_v6_stats->v2 += 1;
     55e:	5d                   	pop    %rbp
     55f:	04 9b                	add    $0x9b,%al
     561:	39 af 39 04 a3 01    	cmp    %ebp,0x1a30439(%rdi)
  if (ip6h + 1 > data_end) {
     567:	55                   	push   %rbp
     568:	9f                   	lahf
     569:	04 af                	add    $0xaf,%al
     56b:	39 f3                	cmp    %esi,%ebx
     56d:	3d 01 5d 00 04       	cmp    $0x4005d01,%eax
  pckt->flow.proto = ip6h->nexthdr;
     572:	1b 84 08 01 5e 04 8e 	sbb    -0x71fba1ff(%rax,%rcx,1),%eax
  pckt->flags |= F_ICMP;
     579:	08 af 0e 01 5e 04    	or     %ch,0x45e010e(%rdi)
     57f:	d1 0e                	rorl   (%rsi)
     581:	c7                   	(bad)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     582:	14 01                	adc    $0x1,%al
     584:	5e                   	pop    %rsi
     585:	04 ff                	add    $0xff,%al
     587:	14 85                	adc    $0x85,%al
     589:	17                   	(bad)
     58a:	01 5e 04             	add    %ebx,0x4(%rsi)
     58d:	de 18                	ficomps (%rax)
     58f:	a3 19 01 5e 00 04 1f 	movabs %eax,0x8841f04005e0119
     596:	84 08 
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     598:	01 5c 04 8e          	add    %ebx,-0x72(%rsp,%rax,1)
     59c:	08 fc                	or     %bh,%ah
     59e:	1b 01                	sbb    (%rcx),%eax
     5a0:	5c                   	pop    %rsp
     5a1:	04 cc                	add    $0xcc,%al
     5a3:	1e                   	(bad)
     5a4:	f7 1f                	negl   (%rdi)
     5a6:	01 5c 04 9d          	add    %ebx,-0x63(%rsp,%rax,1)
     5aa:	21 c7                	and    %eax,%edi
     5ac:	21 01                	and    %eax,(%rcx)
     5ae:	5c                   	pop    %rsp
     5af:	04 e2                	add    $0xe2,%al
     5b1:	21 e5                	and    %esp,%ebp
     5b3:	21 01                	and    %eax,(%rcx)
     5b5:	5c                   	pop    %rsp
     5b6:	04 f8                	add    $0xf8,%al
     5b8:	26 dc 30             	es fdivl (%rax)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     5bb:	01 5c 04 f7          	add    %ebx,-0x9(%rsp,%rax,1)
     5bf:	33 9e 35 01 5c 04    	xor    0x45c0135(%rsi),%ebx
     5c5:	e3 36                	jrcxz  5fd <balancer_ingress+0x5fd>
     5c7:	c5 38 01             	(bad)
     5ca:	5c                   	pop    %rsp
     5cb:	04 af                	add    $0xaf,%al
     5cd:	39 f3                	cmp    %esi,%ebx
     5cf:	3d 01 5c 00 04       	cmp    $0x4005c01,%eax
  vip.port = pckt.flow.port16[1];
     5d4:	1f                   	(bad)
     5d5:	84 08                	test   %cl,(%rax)
     5d7:	01 5e 04             	add    %ebx,0x4(%rsi)
     5da:	8e 08                	mov    (%rax),%cs
  vip.proto = pckt.flow.proto;
     5dc:	af                   	scas   %es:(%rdi),%eax
     5dd:	0e                   	(bad)
     5de:	01 5e 04             	add    %ebx,0x4(%rsi)
     5e1:	d1 0e                	rorl   (%rsi)
     5e3:	c7                   	(bad)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     5e4:	14 01                	adc    $0x1,%al
     5e6:	5e                   	pop    %rsi
     5e7:	04 ff                	add    $0xff,%al
     5e9:	14 85                	adc    $0x85,%al
     5eb:	17                   	(bad)
     5ec:	01 5e 04             	add    %ebx,0x4(%rsi)
     5ef:	de 18                	ficomps (%rax)
     5f1:	a3 19 01 5e 00 04 1f 	movabs %eax,0x3df31f04005e0119
     5f8:	f3 3d 
     5fa:	02 3e                	add    (%rsi),%bh
     5fc:	9f                   	lahf
     5fd:	00 04 39             	add    %al,(%rcx,%rdi,1)
  if (!vip_info) {
     600:	c8 01 12 72          	enter  $0x1201,$0x72
     604:	00 10                	add    %dl,(%rax)
     606:	ff                   	(bad)
  if (data_end - data > MAX_PCKT_SIZE) {
     607:	ff 03                	incl   (%rbx)
     609:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
     60f:	a8 b0                	test   $0xb0,%al
     611:	80 80 00 9f 04 86 03 	addb   $0x3,-0x79fb6100(%rax)
     618:	ee                   	out    %al,(%dx)
     619:	03 12                	add    (%rdx),%edx
     61b:	72 00                	jb     61d <balancer_ingress+0x61d>
     61d:	10 ff                	adc    %bh,%bh
     61f:	ff 03                	incl   (%rbx)
     621:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
     627:	a8 b0                	test   $0xb0,%al
     629:	80 80 00 9f 00 04 54 	addb   $0x54,0x4009f00(%rax)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     630:	86 03                	xchg   %al,(%rbx)
     632:	01 5d 04             	add    %ebx,0x4(%rbp)
     635:	cd 08                	int    $0x8
     637:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     638:	09 01                	or     %eax,(%rcx)
     63a:	5d                   	pop    %rbp
     63b:	04 de                	add    $0xde,%al
     63d:	09 a3 0a 01 5d 04    	or     %esp,0x45d010a(%rbx)
     643:	91                   	xchg   %eax,%ecx
     644:	10 c5                	adc    %al,%ch
     646:	16                   	(bad)
  if (!data_stats) {
     647:	01 5d 04             	add    %ebx,0x4(%rbp)
     64a:	de 18                	ficomps (%rax)
     64c:	a3 19 01 5d 04 f8 26 	movabs %eax,0x27c526f8045d0119
     653:	c5 27 
     655:	01 5d 04             	add    %ebx,0x4(%rbp)
  data_stats->v1 += 1;
     658:	d1 28                	shrl   (%rax)
     65a:	ab                   	stos   %eax,%es:(%rdi)
     65b:	29 01                	sub    %eax,(%rcx)
     65d:	5d                   	pop    %rbp
     65e:	04 de                	add    $0xde,%al
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     660:	2a b8 2b 01 5d 04    	sub    0x45d012b(%rax),%bh
    pckt.flow.port16[0] = 0;
     666:	a3 2c fa 32 01 5d 04 	movabs %eax,0x33f7045d0132fa2c
     66d:	f7 33 
     66f:	b9 36 01 5d 04       	mov    $0x45d0136,%ecx
  vip_num = vip_info->vip_num;
     674:	e7 36                	out    %eax,$0x36
     676:	c5 38 01             	(bad)
     679:	5d                   	pop    %rbp
     67a:	04 af                	add    $0xaf,%al
     67c:	39 88 3b 01 5d 04    	cmp    %ecx,0x45d013b(%rax)
  __u32 cpu_num = bpf_get_smp_processor_id();
     682:	9b                   	fwait
     683:	3c f3                	cmp    $0xf3,%al
     685:	3d 01 5d 00 04       	cmp    $0x4005d01,%eax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     68a:	54                   	push   %rsp
     68b:	86 03                	xchg   %al,(%rbx)
     68d:	02 3e                	add    (%rsi),%bh
     68f:	9f                   	lahf
     690:	04 cd                	add    $0xcd,%al
     692:	08 a4 09 02 3e 9f 04 	or     %ah,0x49f3e02(%rcx,%rcx,1)
     699:	de 09                	fimuls (%rcx)
     69b:	a3 0a 02 3e 9f 04 91 	movabs %eax,0xc51091049f3e020a
     6a2:	10 c5 
     6a4:	16                   	(bad)
     6a5:	02 3e                	add    (%rsi),%bh
     6a7:	9f                   	lahf
     6a8:	04 de                	add    $0xde,%al
  if (!lru_map) {
     6aa:	18 a3 19 02 3e 9f    	sbb    %ah,-0x60c1fde7(%rbx)
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
     6b0:	04 f8                	add    $0xf8,%al
     6b2:	26 c5 27 02          	(bad)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     6b6:	3e 9f                	ds lahf
     6b8:	04 d1                	add    $0xd1,%al
     6ba:	28 ab 29 02 3e 9f    	sub    %ch,-0x60c1fdd7(%rbx)
     6c0:	04 de                	add    $0xde,%al
     6c2:	2a b8 2b 02 3e 9f    	sub    -0x60c1fdd5(%rax),%bh
     6c8:	04 a3                	add    $0xa3,%al
     6ca:	2c fa                	sub    $0xfa,%al
    if (!lru_stats) {
     6cc:	32 02                	xor    (%rdx),%al
     6ce:	3e 9f                	ds lahf
     6d0:	04 f7                	add    $0xf7,%al
     6d2:	33 b9 36 02 3e 9f    	xor    -0x60c1fdca(%rcx),%edi
    lru_stats->v1 += 1;
     6d8:	04 e7                	add    $0xe7,%al
     6da:	36 c5 38 02          	(bad)
     6de:	3e 9f                	ds lahf
     6e0:	04 af                	add    $0xaf,%al
     6e2:	39 88 3b 02 3e 9f    	cmp    %ecx,-0x60c1fdc5(%rax)
     6e8:	04 9b                	add    $0x9b,%al
     6ea:	3c f3                	cmp    $0xf3,%al
     6ec:	3d 02 3e 9f 00       	cmp    $0x9f3e02,%eax
  if ((vip_info->flags & F_QUIC_VIP)) {
     6f1:	04 54                	add    $0x54,%al
     6f3:	86 03                	xchg   %al,(%rbx)
     6f5:	02 30                	add    (%rax),%dh
     6f7:	9f                   	lahf
     6f8:	04 cd                	add    $0xcd,%al
    bool is_icmp = (pckt.flags & F_ICMP);
     6fa:	08 a4 09 02 30 9f 04 	or     %ah,0x49f3002(%rcx,%rcx,1)
    if (is_icmp) {
     701:	de 09                	fimuls (%rcx)
     703:	a3 0a 02 30 9f 04 91 	movabs %eax,0xc51091049f30020a
     70a:	10 c5 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     70c:	16                   	(bad)
     70d:	02 30                	add    (%rax),%dh
     70f:	9f                   	lahf
     710:	04 de                	add    $0xde,%al
     712:	18 a3 19 02 30 9f    	sbb    %ah,-0x60cffde7(%rbx)
     718:	04 f8                	add    $0xf8,%al
     71a:	26 c5 27 02          	(bad)
     71e:	30 9f 04 d1 28 ab    	xor    %bl,-0x54d72efc(%rdi)
      if (!quic_packets_stats) {
     724:	29 02                	sub    %eax,(%rdx)
     726:	30 9f 04 de 2a b8    	xor    %bl,-0x47d521fc(%rdi)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     72c:	2b 02                	sub    (%rdx),%eax
     72e:	30 9f 04 a3 2c fa    	xor    %bl,-0x5d35cfc(%rdi)
     734:	32 02                	xor    (%rdx),%al
     736:	30 9f 04 f7 33 b9    	xor    %bl,-0x46cc08fc(%rdi)
     73c:	36 02 30             	ss add (%rax),%dh
     73f:	9f                   	lahf
     740:	04 e7                	add    $0xe7,%al
     742:	36 c5 38 02          	(bad)
     746:	30 9f 04 af 39 88    	xor    %bl,-0x77c650fc(%rdi)
        quic_packets_stats->ch_routed += 1;
     74c:	3b 02                	cmp    (%rdx),%eax
     74e:	30 9f 04 9b 3c f3    	xor    %bl,-0xcc364fc(%rdi)
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     754:	3d 02 30 9f 00       	cmp    $0x9f3002,%eax
     759:	04 54                	add    $0x54,%al
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     75b:	86 03                	xchg   %al,(%rbx)
     75d:	01 5e 04             	add    %ebx,0x4(%rsi)
     760:	cd 08                	int    $0x8
        bpf_map_lookup_elem(&stats, &stats_key);
     762:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     763:	09 01                	or     %eax,(%rcx)
     765:	5e                   	pop    %rsi
     766:	04 de                	add    $0xde,%al
     768:	09 a3 0a 01 5e 04    	or     %esp,0x45e010a(%rbx)
     76e:	91                   	xchg   %eax,%ecx
     76f:	10 c7                	adc    %al,%bh
     771:	14 01                	adc    $0x1,%al
     773:	5e                   	pop    %rsi
     774:	04 ff                	add    $0xff,%al
     776:	14 c5                	adc    $0xc5,%al
     778:	16                   	(bad)
    if (!icmp_ptb_v4_stats) {
     779:	01 5e 04             	add    %ebx,0x4(%rsi)
     77c:	de 18                	ficomps (%rax)
     77e:	a3 19 01 5e 00 04 54 	movabs %eax,0x3865404005e0119
     785:	86 03 
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     787:	01 5c 04 cd          	add    %ebx,-0x33(%rsp,%rax,1)
     78b:	08 a4 09 01 5c 04 de 	or     %ah,-0x21fba3ff(%rcx,%rcx,1)
     792:	09 a3 0a 01 5c 04    	or     %esp,0x45c010a(%rbx)
  if (iph + 1 > data_end) {
     798:	91                   	xchg   %eax,%ecx
     799:	10 c5                	adc    %al,%ch
     79b:	16                   	(bad)
     79c:	01 5c 04 de          	add    %ebx,-0x22(%rsp,%rax,1)
     7a0:	18 a3 19 01 5c 04    	sbb    %ah,0x45c0119(%rbx)
  if (iph->ihl != 5) {
     7a6:	f8                   	clc
     7a7:	26 c5 27 01          	(bad)
     7ab:	5c                   	pop    %rsp
     7ac:	04 d1                	add    $0xd1,%al
  pckt->flow.proto = iph->protocol;
     7ae:	28 ab 29 01 5c 04    	sub    %ch,0x45c0129(%rbx)
     7b4:	de 2a                	fisubrs (%rdx)
  pckt->flags |= F_ICMP;
     7b6:	b8 2b 01 5c 04       	mov    $0x45c012b,%eax
     7bb:	a3 2c dc 30 01 5c 04 	movabs %eax,0x33f7045c0130dc2c
     7c2:	f7 33 
  pckt->flow.src = iph->daddr;
     7c4:	9e                   	sahf
  pckt->flow.dst = iph->saddr;
     7c5:	35 01 5c 04 e7       	xor    $0xe7045c01,%eax
     7ca:	36 c5 38 01          	(bad)
     7ce:	5c                   	pop    %rsp
     7cf:	04 af                	add    $0xaf,%al
    vip.port = 0;
     7d1:	39 88 3b 01 5c 04    	cmp    %ecx,0x45c013b(%rax)
     7d7:	9b                   	fwait
     7d8:	3c f3                	cmp    $0xf3,%al
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     7da:	3d 01 5c 00 04       	cmp    $0x4005c01,%eax
     7df:	54                   	push   %rsp
     7e0:	86 03                	xchg   %al,(%rbx)
     7e2:	02 30                	add    (%rax),%dh
     7e4:	9f                   	lahf
     7e5:	04 cd                	add    $0xcd,%al
     7e7:	08 a4 09 02 30 9f 04 	or     %ah,0x49f3002(%rcx,%rcx,1)
     7ee:	de 09                	fimuls (%rcx)
     7f0:	a3 0a 02 30 9f 04 91 	movabs %eax,0xc51091049f30020a
     7f7:	10 c5 
    if (!vip_info) {
     7f9:	16                   	(bad)
     7fa:	02 30                	add    (%rax),%dh
     7fc:	9f                   	lahf
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     7fd:	04 de                	add    $0xde,%al
     7ff:	18 a3 19 02 30 9f    	sbb    %ah,-0x60cffde7(%rbx)
     805:	04 f8                	add    $0xf8,%al
      pckt.flow.port16[1] = 0;
     807:	26 c5 27 02          	(bad)
     80b:	30 9f 04 d1 28 ab    	xor    %bl,-0x54d72efc(%rdi)
  udp = data + off;
     811:	29 02                	sub    %eax,(%rdx)
     813:	30 9f 04 de 2a b8    	xor    %bl,-0x47d521fc(%rdi)
     819:	2b 02                	sub    (%rdx),%eax
  if (udp + 1 > data_end) {
     81b:	30 9f 04 a3 2c ea    	xor    %bl,-0x15d35cfc(%rdi)
     821:	2c 02                	sub    $0x2,%al
     823:	30 9f 04 ea 2c ee    	xor    %bl,-0x11d315fc(%rdi)
     829:	2c 01                	sub    $0x1,%al
     82b:	51                   	push   %rcx
     82c:	04 ee                	add    $0xee,%al
     82e:	2c f7                	sub    $0xf7,%al
     830:	2c 02                	sub    $0x2,%al
     832:	76 50                	jbe    884 <balancer_ingress+0x884>
     834:	04 f7                	add    $0xf7,%al
     836:	2c 8c                	sub    $0x8c,%al
     838:	2d 01 51 04 8c       	sub    $0x8c045101,%eax
     83d:	2d aa 2d 02 76       	sub    $0x76022daa,%eax
     842:	50                   	push   %rax
     843:	04 aa                	add    $0xaa,%al
     845:	2d 9f 30 02 30       	sub    $0x3002309f,%eax
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     84a:	9f                   	lahf
     84b:	04 9f                	add    $0x9f,%al
     84d:	30 ac 30 01 53 04 99 	xor    %ch,-0x66fbacff(%rax,%rsi,1)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     854:	31 9d 31 02 76 50    	xor    %ebx,0x50760231(%rbp)
        bpf_map_lookup_elem(&stats, &stats_key);
     85a:	04 9d                	add    $0x9d,%al
     85c:	31 b3 31 01 50 04    	xor    %esi,0x4500131(%rbx)
     862:	b3 31                	mov    $0x31,%bl
     864:	b7 32                	mov    $0x32,%bh
     866:	02 76 50             	add    0x50(%rsi),%dh
     869:	04 b7                	add    $0xb7,%al
     86b:	32 b9 32 01 52 04    	xor    0x4520132(%rcx),%bh
    if (!icmp_ptb_v4_stats) {
     871:	b9 32 fa 32 02       	mov    $0x232fa32,%ecx
     876:	76 50                	jbe    8c8 <balancer_ingress+0x8c8>
     878:	04 9e                	add    $0x9e,%al
    icmp_ptb_v4_stats->v1 += 1;
     87a:	35 a5 35 01 50       	xor    $0x500135a5,%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     87f:	04 a5                	add    $0xa5,%al
     881:	35 b9 36 02 76       	xor    $0x760236b9,%eax
      icmp_ptb_v4_stats->v2 += 1;
     886:	50                   	push   %rax
     887:	04 9b                	add    $0x9b,%al
     889:	3c f3                	cmp    $0xf3,%al
     88b:	3d 02 76 50 00       	cmp    $0x507602,%eax
  if (iph + 1 > data_end) {
     890:	04 a4                	add    $0xa4,%al
     892:	01 86 03 02 30 9f    	add    %eax,-0x60cffdfd(%rsi)
     898:	04 cd                	add    $0xcd,%al
     89a:	08 a4 09 02 30 9f 04 	or     %ah,0x49f3002(%rcx,%rcx,1)
  if (iph->ihl != 5) {
     8a1:	de 09                	fimuls (%rcx)
     8a3:	a3 0a 02 30 9f 04 91 	movabs %eax,0xc51091049f30020a
     8aa:	10 c5 
  pckt->flow.proto = iph->protocol;
     8ac:	16                   	(bad)
     8ad:	02 30                	add    (%rax),%dh
  pckt->flags |= F_ICMP;
     8af:	9f                   	lahf
     8b0:	04 de                	add    $0xde,%al
     8b2:	18 a3 19 02 30 9f    	sbb    %ah,-0x60cffde7(%rbx)
  pckt->flow.src = iph->daddr;
     8b8:	04 f8                	add    $0xf8,%al
     8ba:	26 c5 27 02          	(bad)
  pckt->flow.dst = iph->saddr;
     8be:	30 9f 04 d1 28 ab    	xor    %bl,-0x54d72efc(%rdi)
     8c4:	29 02                	sub    %eax,(%rdx)
     8c6:	30 9f 04 de 2a b8    	xor    %bl,-0x47d521fc(%rdi)
     8cc:	2b 02                	sub    (%rdx),%eax
     8ce:	30 9f 04 a3 2c fa    	xor    %bl,-0x5d35cfc(%rdi)
     8d4:	32 02                	xor    (%rdx),%al
     8d6:	30 9f 04 f7 33 b9    	xor    %bl,-0x46cc08fc(%rdi)
    vip.vip = pckt.flow.dst;
     8dc:	36 02 30             	ss add (%rax),%dh
     8df:	9f                   	lahf
     8e0:	04 e7                	add    $0xe7,%al
     8e2:	36 c5 38 02          	(bad)
  vip.port = pckt.flow.port16[1];
     8e6:	30 9f 04 af 39 88    	xor    %bl,-0x77c650fc(%rdi)
     8ec:	3b 02                	cmp    (%rdx),%eax
     8ee:	30 9f 04 9b 3c f3    	xor    %bl,-0xcc364fc(%rdi)
  vip.proto = pckt.flow.proto;
     8f4:	3d 02 30 9f 00       	cmp    $0x9f3002,%eax
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     8f9:	04 a4                	add    $0xa4,%al
     8fb:	01 86 03 02 30 9f    	add    %eax,-0x60cffdfd(%rsi)
     901:	04 cd                	add    $0xcd,%al
     903:	08 db                	or     %bl,%bl
     905:	08 02                	or     %al,(%rdx)
     907:	30 9f 04 db 08 a4    	xor    %bl,-0x5bf724fc(%rdi)
     90d:	09 03                	or     %eax,(%rbx)
     90f:	10 22                	adc    %ah,(%rdx)
     911:	9f                   	lahf
     912:	04 c8                	add    $0xc8,%al
  if (!vip_info) {
     914:	10 c9                	adc    %cl,%cl
     916:	11 02                	adc    %eax,(%rdx)
     918:	30 9f 04 bf 15 c5    	xor    %bl,-0x3aea40fc(%rdi)
  if (data_end - data > MAX_PCKT_SIZE) {
     91e:	16                   	(bad)
     91f:	03 10                	add    (%rax),%edx
     921:	22 9f 00 04 a4 01    	and    0x1a40400(%rdi),%bl
     927:	e9 01 04 76 80       	jmp    ffffffff80760d2d <server_id_map+0x36fc3ff7cd2d>
     92c:	7f 9f                	jg     8cd <balancer_ingress+0x8cd>
     92e:	04 cd                	add    $0xcd,%al
     930:	08 e0                	or     %ah,%al
     932:	08 04 76             	or     %al,(%rsi,%rsi,2)
     935:	80 7f 9f 00          	cmpb   $0x0,-0x61(%rdi)
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
     939:	04 a4                	add    $0xa4,%al
     93b:	01 e9                	add    %ebp,%ecx
     93d:	01 02                	add    %eax,(%rdx)
     93f:	3e 9f                	ds lahf
     941:	04 cd                	add    $0xcd,%al
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     943:	08 e0                	or     %ah,%al
     945:	08 02                	or     %al,(%rdx)
     947:	3e 9f                	ds lahf
     949:	00 04 a4             	add    %al,(%rsp,%riz,4)
     94c:	01 e9                	add    %ebp,%ecx
     94e:	01 01                	add    %eax,(%rcx)
     950:	5e                   	pop    %rsi
     951:	04 cd                	add    $0xcd,%al
     953:	08 e0                	or     %ah,%al
     955:	08 01                	or     %al,(%rcx)
     957:	5e                   	pop    %rsi
     958:	00 04 a4             	add    %al,(%rsp,%riz,4)
     95b:	01 e9                	add    %ebp,%ecx
  if (!data_stats) {
     95d:	01 01                	add    %eax,(%rcx)
     95f:	5c                   	pop    %rsp
     960:	04 cd                	add    $0xcd,%al
     962:	08 e0                	or     %ah,%al
     964:	08 01                	or     %al,(%rcx)
     966:	5c                   	pop    %rsp
     967:	00 04 a4             	add    %al,(%rsp,%riz,4)
     96a:	01 e9                	add    %ebp,%ecx
  data_stats->v1 += 1;
     96c:	01 02                	add    %eax,(%rdx)
     96e:	30 9f 04 cd 08 e0    	xor    %bl,-0x1ff732fc(%rdi)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     974:	08 02                	or     %al,(%rdx)
     976:	30 9f 00 04 a4 01    	xor    %bl,0x1a40400(%rdi)
    pckt.flow.port16[0] = 0;
     97c:	b1 01                	mov    $0x1,%cl
     97e:	03 7e 0e             	add    0xe(%rsi),%edi
  vip_num = vip_info->vip_num;
     981:	9f                   	lahf
     982:	04 b1                	add    $0xb1,%al
     984:	01 b3 01 01 50 00    	add    %esi,0x500101(%rbx)
     98a:	04 e9                	add    $0xe9,%al
     98c:	01 86 03 01 5e 04    	add    %eax,0x45e0103(%rsi)
     992:	c8 10 c9 11          	enter  $0xc910,$0x11
  __u32 cpu_num = bpf_get_smp_processor_id();
     996:	01 5e 00             	add    %ebx,0x0(%rsi)
     999:	04 e9                	add    $0xe9,%al
     99b:	01 86 03 01 5c 04    	add    %eax,0x45c0103(%rsi)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     9a1:	c8 10 c9 11          	enter  $0xc910,$0x11
     9a5:	01 5c 00 04          	add    %ebx,0x4(%rax,%rax,1)
     9a9:	e9 01 86 03 03       	jmp    3038faf <_license+0x30370bc>
     9ae:	10 22                	adc    %ah,(%rdx)
     9b0:	9f                   	lahf
     9b1:	04 c8                	add    $0xc8,%al
     9b3:	10 8e 11 03 10 22    	adc    %cl,0x22100311(%rsi)
     9b9:	9f                   	lahf
     9ba:	04 8e                	add    $0x8e,%al
     9bc:	11 c9                	adc    %ecx,%ecx
  if (!lru_map) {
     9be:	11 03                	adc    %eax,(%rbx)
     9c0:	10 2a                	adc    %ch,(%rdx)
     9c2:	9f                   	lahf
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
     9c3:	00 04 e9             	add    %al,(%rcx,%rbp,8)
     9c6:	01 86 03 04 76 80    	add    %eax,-0x7f89fbfd(%rsi)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     9cc:	7f 9f                	jg     96d <balancer_ingress+0x96d>
     9ce:	04 c8                	add    $0xc8,%al
     9d0:	10 c9                	adc    %cl,%cl
     9d2:	11 04 76             	adc    %eax,(%rsi,%rsi,2)
     9d5:	80 7f 9f 00          	cmpb   $0x0,-0x61(%rdi)
     9d9:	04 e9                	add    $0xe9,%al
     9db:	01 86 03 01 5f 04    	add    %eax,0x45f0103(%rsi)
    if (!lru_stats) {
     9e1:	c8 10 c9 11          	enter  $0xc910,$0x11
     9e5:	01 5f 00             	add    %ebx,0x0(%rdi)
     9e8:	04 94                	add    $0x94,%al
    lru_stats->v1 += 1;
     9ea:	02 ac 02 02 30 9f 04 	add    0x49f3002(%rdx,%rax,1),%ch
     9f1:	ac                   	lods   %ds:(%rsi),%al
     9f2:	02 ca                	add    %dl,%cl
     9f4:	02 01                	add    (%rcx),%al
     9f6:	54                   	push   %rsp
     9f7:	00 04 b4             	add    %al,(%rsp,%rsi,4)
     9fa:	02 b9 02 03 11 00    	add    0x110302(%rcx),%bh
     a00:	9f                   	lahf
     a01:	04 b9                	add    $0xb9,%al
  if ((vip_info->flags & F_QUIC_VIP)) {
     a03:	02 be 02 03 11 02    	add    0x2110302(%rsi),%bh
     a09:	9f                   	lahf
     a0a:	04 be                	add    $0xbe,%al
     a0c:	02 c3                	add    %bl,%al
     a0e:	02 03                	add    (%rbx),%al
    bool is_icmp = (pckt.flags & F_ICMP);
     a10:	11 04 9f             	adc    %eax,(%rdi,%rbx,4)
    if (is_icmp) {
     a13:	04 c3                	add    $0xc3,%al
     a15:	02 c6                	add    %dh,%al
     a17:	02 03                	add    (%rbx),%al
      __u32 quic_packets_stats_key = 0;
     a19:	11 06                	adc    %eax,(%rsi)
     a1b:	9f                   	lahf
     a1c:	04 c6                	add    $0xc6,%al
     a1e:	02 ca                	add    %dl,%cl
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     a20:	02 03                	add    (%rbx),%al
     a22:	11 07                	adc    %eax,(%rdi)
     a24:	9f                   	lahf
     a25:	04 ca                	add    $0xca,%al
     a27:	02 d0                	add    %al,%dl
     a29:	02 03                	add    (%rbx),%al
     a2b:	11 08                	adc    %ecx,(%rax)
     a2d:	9f                   	lahf
     a2e:	04 d0                	add    $0xd0,%al
     a30:	02 f6                	add    %dh,%dh
     a32:	02 03                	add    (%rbx),%al
     a34:	11 09                	adc    %ecx,(%rcx)
     a36:	9f                   	lahf
      if (!quic_packets_stats) {
     a37:	04 f6                	add    $0xf6,%al
     a39:	02 86 03 03 11 0a    	add    0xa110303(%rsi),%al
     a3f:	9f                   	lahf
     a40:	00 04 b9             	add    %al,(%rcx,%rdi,4)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     a43:	02 be 02 03 7e 12    	add    0x127e0302(%rsi),%bh
  bool is_icmp = (pckt->flags & F_ICMP);
     a49:	9f                   	lahf
     a4a:	04 be                	add    $0xbe,%al
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     a4c:	02 c3                	add    %bl,%al
     a4e:	02 03                	add    (%rbx),%al
     a50:	7e 16                	jle    a68 <balancer_ingress+0xa68>
     a52:	9f                   	lahf
     a53:	04 c3                	add    $0xc3,%al
     a55:	02 c6                	add    %dh,%al
     a57:	02 03                	add    (%rbx),%al
     a59:	7e 1c                	jle    a77 <balancer_ingress+0xa77>
     a5b:	9f                   	lahf
     a5c:	04 c6                	add    $0xc6,%al
     a5e:	02 ca                	add    %dl,%cl
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     a60:	02 03                	add    (%rbx),%al
     a62:	7e 1e                	jle    a82 <balancer_ingress+0xa82>
     a64:	9f                   	lahf
     a65:	04 ca                	add    $0xca,%al
     a67:	02 d0                	add    %al,%dl
     a69:	02 03                	add    (%rbx),%al
     a6b:	7e 20                	jle    a8d <balancer_ingress+0xa8d>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     a6d:	9f                   	lahf
     a6e:	04 d0                	add    $0xd0,%al
     a70:	02 86 03 05 7e 20    	add    0x207e0503(%rsi),%al
     a76:	23 02                	and    (%rdx),%eax
     a78:	9f                   	lahf
     a79:	00 04 e9             	add    %al,(%rcx,%rbp,8)
     a7c:	02 81 03 01 52 04    	add    0x4520103(%rcx),%al
    vip.port = 0;
     a82:	81 03 86 03 01 51    	addl   $0x51010386,(%rbx)
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     a88:	00 04 f6             	add    %al,(%rsi,%rsi,8)
     a8b:	02 86 03 03 11 00    	add    0x110303(%rsi),%al
     a91:	9f                   	lahf
     a92:	00 04 86             	add    %al,(%rsi,%rax,4)
     a95:	03 c2                	add    %edx,%eax
     a97:	04 01                	add    $0x1,%al
     a99:	5d                   	pop    %rbp
     a9a:	04 b2                	add    $0xb2,%al
     a9c:	05 87 07 01 5d       	add    $0x5d010787,%eax
     aa1:	04 90                	add    $0x90,%al
    if (!vip_info) {
     aa3:	08 cd                	or     %cl,%ch
     aa5:	08 01                	or     %al,(%rcx)
     aa7:	5d                   	pop    %rbp
     aa8:	04 a4                	add    $0xa4,%al
     aaa:	09 dc                	or     %ebx,%esp
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     aac:	09 01                	or     %eax,(%rcx)
     aae:	5d                   	pop    %rbp
     aaf:	04 a3                	add    $0xa3,%al
     ab1:	0a 91 10 01 5d 04    	or     0x45d0110(%rcx),%dl
      pckt.flow.port16[1] = 0;
     ab7:	c5 16 de             	(bad)
     aba:	18 01                	sbb    %al,(%rcx)
     abc:	5d                   	pop    %rbp
     abd:	04 a3                	add    $0xa3,%al
     abf:	19 f8                	sbb    %edi,%eax
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     ac1:	26 01 5d 04          	es add %ebx,0x4(%rbp)
     ac5:	c5 27 ca             	(bad)
        bpf_map_lookup_elem(&stats, &stats_key);
     ac8:	28 01                	sub    %al,(%rcx)
     aca:	5d                   	pop    %rbp
     acb:	04 be                	add    $0xbe,%al
     acd:	29 de                	sub    %ebx,%esi
     acf:	2a 01                	sub    (%rcx),%al
     ad1:	5d                   	pop    %rbp
     ad2:	04 bf                	add    $0xbf,%al
     ad4:	2b 90 2c 01 5d 04    	sub    0x45d012c(%rax),%edx
     ada:	92                   	xchg   %eax,%edx
     adb:	3b 9b 3c 01 5d 00    	cmp    0x5d013c(%rbx),%ebx
    if (!icmp_ptb_v6_stats) {
     ae1:	04 86                	add    $0x86,%al
     ae3:	03 c2                	add    %edx,%eax
     ae5:	04 02                	add    $0x2,%al
     ae7:	3e 9f                	ds lahf
    icmp_ptb_v6_stats->v1 += 1;
     ae9:	04 b2                	add    $0xb2,%al
     aeb:	05 87 07 02 3e       	add    $0x3e020787,%eax
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     af0:	9f                   	lahf
     af1:	04 90                	add    $0x90,%al
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     af3:	08 cd                	or     %cl,%ch
     af5:	08 02                	or     %al,(%rdx)
     af7:	3e 9f                	ds lahf
     af9:	04 a4                	add    $0xa4,%al
      icmp_ptb_v6_stats->v2 += 1;
     afb:	09 dc                	or     %ebx,%esp
     afd:	09 02                	or     %eax,(%rdx)
     aff:	3e 9f                	ds lahf
  if (ip6h + 1 > data_end) {
     b01:	04 a3                	add    $0xa3,%al
     b03:	0a 91 10 02 3e 9f    	or     -0x60c1fdf0(%rcx),%dl
     b09:	04 c5                	add    $0xc5,%al
     b0b:	16                   	(bad)
     b0c:	de 18                	ficomps (%rax)
     b0e:	02 3e                	add    (%rsi),%bh
     b10:	9f                   	lahf
     b11:	04 a3                	add    $0xa3,%al
  pckt->flow.proto = ip6h->nexthdr;
     b13:	19 f8                	sbb    %edi,%eax
     b15:	26 02 3e             	es add (%rsi),%bh
     b18:	9f                   	lahf
  pckt->flags |= F_ICMP;
     b19:	04 c5                	add    $0xc5,%al
     b1b:	27                   	(bad)
     b1c:	ca 28 02             	lret   $0x228
     b1f:	3e 9f                	ds lahf
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     b21:	04 be                	add    $0xbe,%al
     b23:	29 de                	sub    %ebx,%esi
     b25:	2a 02                	sub    (%rdx),%al
     b27:	3e 9f                	ds lahf
     b29:	04 bf                	add    $0xbf,%al
     b2b:	2b 90 2c 02 3e 9f    	sub    -0x60c1fdd4(%rax),%edx
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     b31:	04 92                	add    $0x92,%al
     b33:	3b 9b 3c 02 3e 9f    	cmp    -0x60c1fdc4(%rbx),%ebx
     b39:	00 04 86             	add    %al,(%rsi,%rax,4)
     b3c:	03 c2                	add    %edx,%eax
     b3e:	04 02                	add    $0x2,%al
     b40:	31 9f 04 b2 05 87    	xor    %ebx,-0x78fa4dfc(%rdi)
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
     b46:	07                   	(bad)
     b47:	02 31                	add    (%rcx),%dh
     b49:	9f                   	lahf
     b4a:	04 90                	add    $0x90,%al
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b4c:	08 cd                	or     %cl,%ch
     b4e:	08 02                	or     %al,(%rdx)
     b50:	31 9f 04 a4 09 dc    	xor    %ebx,-0x23f65bfc(%rdi)
     b56:	09 02                	or     %eax,(%rdx)
     b58:	31 9f 04 a3 0a 91    	xor    %ebx,-0x6ef55cfc(%rdi)
     b5e:	10 02                	adc    %al,(%rdx)
     b60:	31 9f 04 c5 16 de    	xor    %ebx,-0x21e93afc(%rdi)
      if (!data_stats) {
     b66:	18 02                	sbb    %al,(%rdx)
     b68:	31 9f 04 a3 19 f8    	xor    %ebx,-0x7e65cfc(%rdi)
      data_stats->v1 += 1;
     b6e:	26 02 31             	es add (%rcx),%dh
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     b71:	9f                   	lahf
     b72:	04 c5                	add    $0xc5,%al
     b74:	27                   	(bad)
     b75:	ca 28 02             	lret   $0x228
     b78:	31 9f 04 be 29 de    	xor    %ebx,-0x21d641fc(%rdi)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     b7e:	2a 02                	sub    (%rdx),%al
        data_stats->v2 += 1;
     b80:	31 9f 04 bf 2b 90    	xor    %ebx,-0x6fd440fc(%rdi)
  original_sport = pckt.flow.port16[0];
     b86:	2c 02                	sub    $0x2,%al
     b88:	31 9f 04 92 3b 9b    	xor    %ebx,-0x64c46dfc(%rdi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     b8e:	3c 02                	cmp    $0x2,%al
        !(vip_info->flags & F_LRU_BYPASS)) {
     b90:	31 9f 00 04 86 03    	xor    %ebx,0x3860400(%rdi)
     b96:	c2 04 01             	ret    $0x104
     b99:	5e                   	pop    %rsi
     b9a:	04 b2                	add    $0xb2,%al
     b9c:	05 87 07 01 5e       	add    $0x5e010787,%eax
     ba1:	04 90                	add    $0x90,%al
     ba3:	08 cd                	or     %cl,%ch
     ba5:	08 01                	or     %al,(%rcx)
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
     ba7:	5e                   	pop    %rsi
     ba8:	04 a4                	add    $0xa4,%al
  if (!dst_lru) {
     baa:	09 dc                	or     %ebx,%esp
     bac:	09 01                	or     %eax,(%rcx)
     bae:	5e                   	pop    %rsi
     baf:	04 a3                	add    $0xa3,%al
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
     bb1:	0a af 0e 01 5e 04    	or     0x45e010e(%rdi),%ch
     bb7:	d1 0e                	rorl   (%rsi)
     bb9:	91                   	xchg   %eax,%ecx
     bba:	10 01                	adc    %al,(%rcx)
     bbc:	5e                   	pop    %rsi
     bbd:	04 c5                	add    $0xc5,%al
     bbf:	16                   	(bad)
     bc0:	85 17                	test   %edx,(%rdi)
    cur_time = bpf_ktime_get_ns();
     bc2:	01 5e 00             	add    %ebx,0x0(%rsi)
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
     bc5:	04 86                	add    $0x86,%al
     bc7:	03 c2                	add    %edx,%eax
     bc9:	04 01                	add    $0x1,%al
     bcb:	5c                   	pop    %rsp
     bcc:	04 b2                	add    $0xb2,%al
     bce:	05 87 07 01 5c       	add    $0x5c010787,%eax
     bd3:	04 90                	add    $0x90,%al
     bd5:	08 cd                	or     %cl,%ch
     bd7:	08 01                	or     %al,(%rcx)
     bd9:	5c                   	pop    %rsp
     bda:	04 a4                	add    $0xa4,%al
     bdc:	09 dc                	or     %ebx,%esp
     bde:	09 01                	or     %eax,(%rcx)
     be0:	5c                   	pop    %rsp
     be1:	04 a3                	add    $0xa3,%al
     be3:	0a 91 10 01 5c 04    	or     0x45c0110(%rcx),%dl
     be9:	c5 16 de             	(bad)
     bec:	18 01                	sbb    %al,(%rcx)
     bee:	5c                   	pop    %rsp
     bef:	04 a3                	add    $0xa3,%al
     bf1:	19 fc                	sbb    %edi,%esp
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     bf3:	1b 01                	sbb    (%rcx),%eax
     bf5:	5c                   	pop    %rsp
     bf6:	04 cc                	add    $0xcc,%al
     bf8:	1e                   	(bad)
     bf9:	f7 1f                	negl   (%rdi)
     bfb:	01 5c 04 9d          	add    %ebx,-0x63(%rsp,%rax,1)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     bff:	21 c7                	and    %eax,%edi
     c01:	21 01                	and    %eax,(%rcx)
     c03:	5c                   	pop    %rsp
     c04:	04 e2                	add    $0xe2,%al
     c06:	21 e5                	and    %esp,%ebp
     c08:	21 01                	and    %eax,(%rcx)
     c0a:	5c                   	pop    %rsp
     c0b:	04 c5                	add    $0xc5,%al
  if (!connId) {
     c0d:	27                   	(bad)
     c0e:	ca 28 01             	lret   $0x128
     c11:	5c                   	pop    %rsp
     c12:	04 be                	add    $0xbe,%al
     c14:	29 de                	sub    %ebx,%esi
     c16:	2a 01                	sub    (%rcx),%al
  __u8 connIdVersion = (connId[0] >> 6);
     c18:	5c                   	pop    %rsp
     c19:	04 bf                	add    $0xbf,%al
     c1b:	2b 90 2c 01 5c 04    	sub    0x45c012c(%rax),%edx
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     c21:	92                   	xchg   %eax,%edx
     c22:	3b 9b 3c 01 5c 00    	cmp    0x5c013c(%rbx),%ebx
     c28:	04 86                	add    $0x86,%al
     c2a:	03 c2                	add    %edx,%eax
     c2c:	04 02                	add    $0x2,%al
     c2e:	30 9f 04 b2 05 87    	xor    %bl,-0x78fa4dfc(%rdi)
     c34:	07                   	(bad)
     c35:	02 30                	add    (%rax),%dh
     c37:	9f                   	lahf
     c38:	04 90                	add    $0x90,%al
     c3a:	08 cd                	or     %cl,%ch
     c3c:	08 02                	or     %al,(%rdx)
     c3e:	30 9f 04 a4 09 dc    	xor    %bl,-0x23f65bfc(%rdi)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     c44:	09 02                	or     %eax,(%rdx)
     c46:	30 9f 04 a3 0a 91    	xor    %bl,-0x6ef55cfc(%rdi)
     c4c:	10 02                	adc    %al,(%rdx)
     c4e:	30 9f 04 c5 16 de    	xor    %bl,-0x21e93afc(%rdi)
     c54:	18 02                	sbb    %al,(%rdx)
     c56:	30 9f 04 a3 19 f3    	xor    %bl,-0xce65cfc(%rdi)
     c5c:	1b 02                	sbb    (%rdx),%eax
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
     c5e:	30 9f 04 f3 1b fc    	xor    %bl,-0x3e40cfc(%rdi)
     c64:	1b 01                	sbb    (%rcx),%eax
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c66:	5f                   	pop    %rdi
     c67:	04 eb                	add    $0xeb,%al
     c69:	1c ef                	sbb    $0xef,%al
     c6b:	1c 02                	sbb    $0x2,%al
     c6d:	76 50                	jbe    cbf <balancer_ingress+0xcbf>
     c6f:	04 ef                	add    $0xef,%al
     c71:	1c 85                	sbb    $0x85,%al
     c73:	1d 01 50 04 85       	sbb    $0x85045001,%eax
     c78:	1d 85 1e 02 76       	sbb    $0x76021e85,%eax
      if (!data_stats) {
     c7d:	50                   	push   %rax
     c7e:	04 85                	add    $0x85,%al
     c80:	1e                   	(bad)
     c81:	87 1e                	xchg   %ebx,(%rsi)
     c83:	01 52 04             	add    %edx,0x4(%rdx)
      data_stats->v1 += 1;
     c86:	87 1e                	xchg   %ebx,(%rsi)
     c88:	cc                   	int3
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     c89:	1e                   	(bad)
     c8a:	02 76 50             	add    0x50(%rsi),%dh
     c8d:	04 f7                	add    $0xf7,%al
     c8f:	1f                   	(bad)
     c90:	fe                   	(bad)
     c91:	1f                   	(bad)
     c92:	01 50 04             	add    %edx,0x4(%rax)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     c95:	fe                   	(bad)
     c96:	1f                   	(bad)
     c97:	9d                   	popf
     c98:	21 02                	and    %eax,(%rdx)
        data_stats->v2 += 1;
     c9a:	76 50                	jbe    cec <balancer_ingress+0xcec>
     c9c:	04 c5                	add    $0xc5,%al
     c9e:	27                   	(bad)
     c9f:	ca 28 02             	lret   $0x228
     ca2:	30 9f 04 be 29 86    	xor    %bl,-0x79d641fc(%rdi)
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     ca8:	2a 02                	sub    (%rdx),%al
     caa:	30 9f 04 86 2a 92    	xor    %bl,-0x6dd579fc(%rdi)
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     cb0:	2a 01                	sub    (%rcx),%al
     cb2:	51                   	push   %rcx
     cb3:	04 92                	add    $0x92,%al
     cb5:	2a c5                	sub    %ch,%al
     cb7:	2a 01                	sub    (%rcx),%al
        quic_packets_stats->cid_initial += 1;
     cb9:	5f                   	pop    %rdi
     cba:	04 c5                	add    $0xc5,%al
     cbc:	2a de                	sub    %dh,%bl
     cbe:	2a 02                	sub    (%rdx),%al
     cc0:	30 9f 04 bf 2b 90    	xor    %bl,-0x6fd440fc(%rdi)
     cc6:	2c 01                	sub    $0x1,%al
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     cc8:	5f                   	pop    %rdi
     cc9:	04 92                	add    $0x92,%al
     ccb:	3b 9b 3c 01 5f 00    	cmp    0x5f013c(%rbx),%ebx
     cd1:	04 d6                	add    $0xd6,%al
     cd3:	03 c2                	add    %edx,%eax
     cd5:	04 02                	add    $0x2,%al
     cd7:	30 9f 04 b2 05 87    	xor    %bl,-0x78fa4dfc(%rdi)
     cdd:	07                   	(bad)
  if (!per_vip_stats) {
     cde:	02 30                	add    (%rax),%dh
     ce0:	9f                   	lahf
     ce1:	04 90                	add    $0x90,%al
    per_vip_stats->v1 += 1;
     ce3:	08 cd                	or     %cl,%ch
     ce5:	08 02                	or     %al,(%rdx)
     ce7:	30 9f 04 a4 09 dc    	xor    %bl,-0x23f65bfc(%rdi)
     ced:	09 02                	or     %eax,(%rdx)
     cef:	30 9f 04 a3 0a 91    	xor    %bl,-0x6ef55cfc(%rdi)
  key = dst_lru->pos;
     cf5:	10 02                	adc    %al,(%rdx)
     cf7:	30 9f 04 c5 16 de    	xor    %bl,-0x21e93afc(%rdi)
     cfd:	18 02                	sbb    %al,(%rdx)
  pckt->real_index = key;
     cff:	30 9f 04 a3 19 f8    	xor    %bl,-0x7e65cfc(%rdi)
  *real = bpf_map_lookup_elem(&reals, &key);
     d05:	26 02 30             	es add (%rax),%dh
     d08:	9f                   	lahf
     d09:	04 c5                	add    $0xc5,%al
     d0b:	27                   	(bad)
     d0c:	ca 28 02             	lret   $0x228
     d0f:	30 9f 04 be 29 de    	xor    %bl,-0x21d641fc(%rdi)
     d15:	2a 02                	sub    (%rdx),%al
     d17:	30 9f 04 bf 2b 90    	xor    %bl,-0x6fd440fc(%rdi)
     d1d:	2c 02                	sub    $0x2,%al
     d1f:	30 9f 04 92 3b 9b    	xor    %bl,-0x64c46dfc(%rdi)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     d25:	3c 02                	cmp    $0x2,%al
     d27:	30 9f 00 04 d6 03    	xor    %bl,0x3d60400(%rdi)
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
     d2d:	c2 04 02             	ret    $0x204
     d30:	30 9f 04 b2 05 d2    	xor    %bl,-0x2dfa4dfc(%rdi)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
     d36:	05 02 30 9f 04       	add    $0x49f3002,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     d3b:	d2 05 87 07 03 10    	rolb   %cl,0x10030787(%rip)        # 100314c8 <_license+0x1002f5d5>
     d41:	36 9f                	ss lahf
     d43:	04 a3                	add    $0xa3,%al
     d45:	0a a7 0b 02 30 9f    	or     -0x60cffdf5(%rdi),%ah
     d4b:	04 d1                	add    $0xd1,%al
     d4d:	0e                   	(bad)
     d4e:	d1 0f                	rorl   (%rdi)
     d50:	03 10                	add    (%rax),%edx
  if (!conn_rate_stats) {
     d52:	36 9f                	ss lahf
     d54:	00 04 d6             	add    %al,(%rsi,%rdx,8)
     d57:	03 95 04 04 76 80    	add    -0x7f89fbfc(%rbp),%edx
     d5d:	7f 9f                	jg     cfe <balancer_ingress+0xcfe>
     d5f:	04 b2                	add    $0xb2,%al
     d61:	05 da 05 04 76       	add    $0x760405da,%eax
  *cur_time = bpf_ktime_get_ns();
     d66:	80 7f 9f 00          	cmpb   $0x0,-0x61(%rdi)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     d6a:	04 d6                	add    $0xd6,%al
     d6c:	03 95 04 02 3e 9f    	add    -0x60c1fdfc(%rbp),%edx
     d72:	04 b2                	add    $0xb2,%al
     d74:	05 da 05 02 3e       	add    $0x3e0205da,%eax
    conn_rate_stats->v1 = 1;
     d79:	9f                   	lahf
     d7a:	00 04 d6             	add    %al,(%rsi,%rdx,8)
     d7d:	03 95 04 01 5e 04    	add    0x45e0104(%rbp),%edx
    conn_rate_stats->v2 = *cur_time;
     d83:	b2 05                	mov    $0x5,%dl
    conn_rate_stats->v1 += 1;
     d85:	da 05 01 5e 00 04    	fiaddl 0x4005e01(%rip)        # 4006b8c <_license+0x4004c99>
     d8b:	d6                   	(bad)
     d8c:	03 95 04 01 5c 04    	add    0x45c0104(%rbp),%edx
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
     d92:	b2 05                	mov    $0x5,%dl
     d94:	da 05 01 5c 00 04    	fiaddl 0x4005c01(%rip)        # 400699b <_license+0x4004aa8>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
     d9a:	d6                   	(bad)
     d9b:	03 95 04 02 31 9f    	add    -0x60cefdfc(%rbp),%edx
     da1:	04 b2                	add    $0xb2,%al
     da3:	05 da 05 02 31       	add    $0x310205da,%eax
     da8:	9f                   	lahf
     da9:	00 04 d6             	add    %al,(%rsi,%rdx,8)
     dac:	03 e3                	add    %ebx,%esp
     dae:	03 03                	add    (%rbx),%eax
    if (down_reals_map) {
     db0:	7e 0e                	jle    dc0 <balancer_ingress+0xdc0>
     db2:	9f                   	lahf
     db3:	04 e3                	add    $0xe3,%al
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
     db5:	03 e7                	add    %edi,%esp
     db7:	03 01                	add    (%rcx),%eax
     db9:	50                   	push   %rax
     dba:	00 04 e3             	add    %al,(%rbx,%riz,8)
     dbd:	03 95 04 03 10 28    	add    0x28100304(%rbp),%edx
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
     dc3:	9f                   	lahf
     dc4:	04 b2                	add    $0xb2,%al
     dc6:	05 da 05 03 10       	add    $0x100305da,%eax
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
     dcb:	28 9f 00 04 95 04    	sub    %bl,0x4950400(%rdi)
     dd1:	c2 04 01             	ret    $0x104
     dd4:	5e                   	pop    %rsi
     dd5:	04 a3                	add    $0xa3,%al
     dd7:	0a a7 0b 01 5e 00    	or     0x5e010b(%rdi),%ah
     ddd:	04 95                	add    $0x95,%al
     ddf:	04 c2                	add    $0xc2,%al
        if (stats_data) {
     de1:	04 01                	add    $0x1,%al
     de3:	5c                   	pop    %rsp
     de4:	04 a3                	add    $0xa3,%al
     de6:	0a a7 0b 01 5c 00    	or     0x5c010b(%rdi),%ah
          stats_data->v1 += 1;
     dec:	04 95                	add    $0x95,%al
     dee:	04 c2                	add    $0xc2,%al
     df0:	04 04                	add    $0x4,%al
     df2:	76 80                	jbe    d74 <balancer_ingress+0xd74>
    if (!dst) {
     df4:	7f 9f                	jg     d95 <balancer_ingress+0xd95>
     df6:	04 a3                	add    $0xa3,%al
     df8:	0a a7 0b 04 76 80    	or     -0x7f89fbf5(%rdi),%ah
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
     dfe:	7f 9f                	jg     d9f <balancer_ingress+0xd9f>
     e00:	00 04 95 04 c2 04 01 	add    %al,0x104c204(,%rdx,4)
     e07:	5f                   	pop    %rdi
     e08:	04 a3                	add    $0xa3,%al
     e0a:	0a a7 0b 01 5f 00    	or     0x5f010b(%rdi),%ah
     e10:	04 d2                	add    $0xd2,%al
     e12:	05 87 07 03 11       	add    $0x11030787,%eax
     e17:	7f 9f                	jg     db8 <balancer_ingress+0xdb8>
     e19:	04 90                	add    $0x90,%al
     e1b:	08 cd                	or     %cl,%ch
  if (!data_stats) {
     e1d:	08 03                	or     %al,(%rbx)
     e1f:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     e22:	04 a4                	add    $0xa4,%al
     e24:	09 dc                	or     %ebx,%esp
     e26:	09 03                	or     %eax,(%rbx)
     e28:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     e2b:	04 a7                	add    $0xa7,%al
     e2d:	0b 91 10 03 11 7f    	or     0x7f110310(%rcx),%edx
  data_stats->v1 += 1;
     e33:	9f                   	lahf
     e34:	04 c5                	add    $0xc5,%al
     e36:	16                   	(bad)
     e37:	de 18                	ficomps (%rax)
     e39:	03 11                	add    (%rcx),%edx
  data_stats->v2 += pkt_bytes;
     e3b:	7f 9f                	jg     ddc <balancer_ingress+0xddc>
     e3d:	04 a3                	add    $0xa3,%al
     e3f:	19 f8                	sbb    %edi,%eax
     e41:	26 03 11             	es add (%rcx),%edx
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
     e44:	7f 9f                	jg     de5 <balancer_ingress+0xde5>
     e46:	04 c5                	add    $0xc5,%al
     e48:	27                   	(bad)
     e49:	ca 28 03             	lret   $0x328
     e4c:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     e4f:	04 be                	add    $0xbe,%al
     e51:	29 de                	sub    %ebx,%esi
  if (!data_stats) {
     e53:	2a 03                	sub    (%rbx),%al
     e55:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     e58:	04 bf                	add    $0xbf,%al
     e5a:	2b 90 2c 03 11 7f    	sub    0x7f11032c(%rax),%edx
  data_stats->v2 += pkt_bytes;
     e60:	9f                   	lahf
     e61:	04 92                	add    $0x92,%al
     e63:	3b 9b 3c 03 11 7f    	cmp    0x7f11033c(%rbx),%ebx
  pckt.flow.port16[0] = original_sport;
     e69:	9f                   	lahf
     e6a:	00 04 d2             	add    %al,(%rdx,%rdx,8)
     e6d:	05 ea 05 01 50       	add    $0x500105ea,%eax
  if (dst->flags & F_IPV6) {
     e72:	04 90                	add    $0x90,%al
     e74:	08 a9 08 01 50 04    	or     %ch,0x4500108(%rcx)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
     e7a:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     e7b:	09 a8 09 01 50 00    	or     %ebp,0x500109(%rax)
     e81:	04 d2                	add    $0xd2,%al
     e83:	05 87 07 01 5e       	add    $0x5e010787,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
     e88:	04 d1                	add    $0xd1,%al
     e8a:	0e                   	(bad)
     e8b:	d1 0f                	rorl   (%rdi)
     e8d:	01 5e 00             	add    %ebx,0x0(%rsi)
     e90:	04 d2                	add    $0xd2,%al
     e92:	05 87 07 01 5c       	add    $0x5c010787,%eax
  data = (void*)(long)xdp->data;
     e97:	04 d1                	add    $0xd1,%al
     e99:	0e                   	(bad)
     e9a:	d1 0f                	rorl   (%rdi)
  data_end = (void*)(long)xdp->data_end;
     e9c:	01 5c 00 04          	add    %ebx,0x4(%rax,%rax,1)
  iph = data + sizeof(struct ethhdr);
     ea0:	d2 05 87 07 03 10    	rolb   %cl,0x10030787(%rip)        # 1003162d <_license+0x1002f73a>
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
     ea6:	36 9f                	ss lahf
     ea8:	04 d1                	add    $0xd1,%al
     eaa:	0e                   	(bad)
     eab:	d1 0f                	rorl   (%rdi)
     ead:	03 10                	add    (%rax),%edx
     eaf:	36 9f                	ss lahf
     eb1:	00 04 d2             	add    %al,(%rdx,%rdx,8)
     eb4:	05 87 07 04 76       	add    $0x76040787,%eax
     eb9:	80 7f 9f 04          	cmpb   $0x4,-0x61(%rdi)
     ebd:	d1 0e                	rorl   (%rsi)
     ebf:	d1 0f                	rorl   (%rdi)
     ec1:	04 76                	add    $0x76,%al
     ec3:	80 7f 9f 00          	cmpb   $0x0,-0x61(%rdi)
     ec7:	04 d2                	add    $0xd2,%al
     ec9:	05 ea 05 01 50       	add    $0x500105ea,%eax
     ece:	00 04 da             	add    %al,(%rdx,%rbx,8)
     ed1:	05 87 07 01 5e       	add    $0x5e010787,%eax
     ed6:	04 d1                	add    $0xd1,%al
  memcpy(new_eth->h_dest, cval->mac, 6);
     ed8:	0e                   	(bad)
     ed9:	d1 0f                	rorl   (%rdi)
     edb:	01 5e 00             	add    %ebx,0x0(%rsi)
     ede:	04 da                	add    $0xda,%al
     ee0:	05 87 07 01 5c       	add    $0x5c010787,%eax
     ee5:	04 d1                	add    $0xd1,%al
     ee7:	0e                   	(bad)
     ee8:	d1 0f                	rorl   (%rdi)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
     eea:	01 5c 00 04          	add    %ebx,0x4(%rax,%rax,1)
     eee:	da 05 87 07 03 10    	fiaddl 0x10030787(%rip)        # 1003167b <_license+0x1002f788>
     ef4:	36 9f                	ss lahf
     ef6:	04 d1                	add    $0xd1,%al
  new_eth->h_proto = BE_ETH_P_IP;
     ef8:	0e                   	(bad)
     ef9:	95                   	xchg   %eax,%ebp
     efa:	0f 03 10             	lsl    (%rax),%edx
     efd:	36 9f                	ss lahf
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
     eff:	04 95                	add    $0x95,%al
     f01:	0f d1 0f             	psrlw  (%rdi),%mm1
     f04:	03 10                	add    (%rax),%edx
     f06:	3e 9f                	ds lahf
  iph->ihl = 5;
     f08:	00 04 da             	add    %al,(%rdx,%rbx,8)
  iph->tos = tos;
     f0b:	05 87 07 04 76       	add    $0x76040787,%eax
     f10:	80 7f 9f 04          	cmpb   $0x4,-0x61(%rdi)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
     f14:	d1 0e                	rorl   (%rsi)
     f16:	d1 0f                	rorl   (%rdi)
     f18:	04 76                	add    $0x76,%al
     f1a:	80 7f 9f 00          	cmpb   $0x0,-0x61(%rdi)
  iph->id = 0;
     f1e:	04 da                	add    $0xda,%al
     f20:	05 87 07 01 5f       	add    $0x5f010787,%eax
  iph->daddr = daddr;
     f25:	04 d1                	add    $0xd1,%al
  iph->saddr = saddr;
     f27:	0e                   	(bad)
     f28:	d1 0f                	rorl   (%rdi)
  iph->ttl = DEFAULT_TTL;
     f2a:	01 5f 00             	add    %ebx,0x0(%rdi)
     f2d:	04 ff                	add    $0xff,%al
    *csum += *next_iph_u16++;
     f2f:	05 a9 06 02 30       	add    $0x300206a9,%eax
     f34:	9f                   	lahf
     f35:	04 a9                	add    $0xa9,%al
     f37:	06                   	(bad)
     f38:	d1 06                	roll   (%rsi)
     f3a:	01 52 00             	add    %edx,0x0(%rdx)
     f3d:	04 ff                	add    $0xff,%al
     f3f:	05 91 06 02 30       	add    $0x30020691,%eax
     f44:	9f                   	lahf
     f45:	04 91                	add    $0x91,%al
     f47:	06                   	(bad)
     f48:	87 07                	xchg   %eax,(%rdi)
     f4a:	03 10                	add    (%rax),%edx
      if (pckt.flow.proto == IPPROTO_TCP) {
     f4c:	22 9f 00 04 91 06    	and    0x6910400(%rdi),%bl
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
     f52:	87 07                	xchg   %eax,(%rdi)
     f54:	03 7e 22             	add    0x22(%rsi),%edi
     f57:	9f                   	lahf
     f58:	00 04 b1             	add    %al,(%rcx,%rsi,4)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
     f5b:	06                   	(bad)
     f5c:	b6 06                	mov    $0x6,%dh
     f5e:	03 11                	add    (%rcx),%edx
     f60:	00 9f 04 b6 06 bb    	add    %bl,-0x44f949fc(%rdi)
     f66:	06                   	(bad)
     f67:	03 11                	add    (%rcx),%edx
     f69:	01 9f 04 bb 06 c0    	add    %ebx,-0x3ff944fc(%rdi)
     f6f:	06                   	(bad)
        if (!lru_stats) {
     f70:	03 11                	add    (%rcx),%edx
     f72:	02 9f 04 c0 06 c5    	add    -0x3af93ffc(%rdi),%bl
     f78:	06                   	(bad)
        if (pckt.flags & F_SYN_SET) {
     f79:	03 11                	add    (%rcx),%edx
     f7b:	03 9f 04 c5 06 ca    	add    -0x35f93afc(%rdi),%ebx
     f81:	06                   	(bad)
     f82:	03 11                	add    (%rcx),%edx
     f84:	04 9f                	add    $0x9f,%al
     f86:	04 ca                	add    $0xca,%al
     f88:	06                   	(bad)
  struct real_pos_lru new_dst_lru = {};
     f89:	cd 06                	int    $0x6
     f8b:	03 11                	add    (%rcx),%edx
     f8d:	06                   	(bad)
     f8e:	9f                   	lahf
     f8f:	04 cd                	add    $0xcd,%al
     f91:	06                   	(bad)
     f92:	d1 06                	roll   (%rsi)
     f94:	03 11                	add    (%rcx),%edx
     f96:	07                   	(bad)
     f97:	9f                   	lahf
     f98:	04 d1                	add    $0xd1,%al
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
     f9a:	06                   	(bad)
     f9b:	d7                   	xlat   %ds:(%rbx)
     f9c:	06                   	(bad)
     f9d:	03 11                	add    (%rcx),%edx
     f9f:	08 9f 04 d7 06 fd    	or     %bl,-0x2f928fc(%rdi)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     fa5:	06                   	(bad)
     fa6:	03 11                	add    (%rcx),%edx
     fa8:	09 9f 04 fd 06 87    	or     %ebx,-0x78f902fc(%rdi)
     fae:	07                   	(bad)
     faf:	03 11                	add    (%rcx),%edx
     fb1:	0a 9f 00 04 b1 06    	or     0x6b10400(%rdi),%bl
     fb7:	bb 06 03 7e 10       	mov    $0x107e0306,%ebx
  if (!conn_rate_stats) {
     fbc:	9f                   	lahf
     fbd:	04 bb                	add    $0xbb,%al
     fbf:	06                   	(bad)
     fc0:	c0 06 03             	rolb   $0x3,(%rsi)
     fc3:	7e 12                	jle    fd7 <balancer_ingress+0xfd7>
     fc5:	9f                   	lahf
     fc6:	04 c0                	add    $0xc0,%al
     fc8:	06                   	(bad)
     fc9:	c5 06 03             	(bad)
     fcc:	7e 14                	jle    fe2 <balancer_ingress+0xfe2>
  *cur_time = bpf_ktime_get_ns();
     fce:	9f                   	lahf
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     fcf:	04 c5                	add    $0xc5,%al
     fd1:	06                   	(bad)
     fd2:	ca 06 03             	lret   $0x306
     fd5:	7e 18                	jle    fef <balancer_ingress+0xfef>
     fd7:	9f                   	lahf
     fd8:	04 ca                	add    $0xca,%al
     fda:	06                   	(bad)
     fdb:	cd 06                	int    $0x6
     fdd:	03 7e 1c             	add    0x1c(%rsi),%edi
     fe0:	9f                   	lahf
     fe1:	04 cd                	add    $0xcd,%al
    conn_rate_stats->v1 = 1;
     fe3:	06                   	(bad)
     fe4:	d1 06                	roll   (%rsi)
     fe6:	03 7e 1e             	add    0x1e(%rsi),%edi
     fe9:	9f                   	lahf
    conn_rate_stats->v2 = *cur_time;
     fea:	04 d1                	add    $0xd1,%al
     fec:	06                   	(bad)
     fed:	d7                   	xlat   %ds:(%rbx)
     fee:	06                   	(bad)
     fef:	03 7e 20             	add    0x20(%rsi),%edi
     ff2:	9f                   	lahf
     ff3:	04 d7                	add    $0xd7,%al
     ff5:	06                   	(bad)
     ff6:	87 07                	xchg   %eax,(%rdi)
     ff8:	05 7e 20 23 02       	add    $0x223207e,%eax
     ffd:	9f                   	lahf
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
     ffe:	00 04 fd 06 87 07 03 	add    %al,0x3078706(,%rdi,8)
    1005:	11 00                	adc    %eax,(%rax)
    1007:	9f                   	lahf
    1008:	00 04 a3             	add    %al,(%rbx,%riz,4)
    100b:	1d b0 1d 01 51       	sbb    $0x51011db0,%eax
  data = (void*)(long)xdp->data;
    1010:	00 04 b0             	add    %al,(%rax,%rsi,4)
    1013:	08 cd                	or     %cl,%ch
  data_end = (void*)(long)xdp->data_end;
    1015:	08 01                	or     %al,(%rcx)
    1017:	50                   	push   %rax
  ip6h = data + sizeof(struct ethhdr);
    1018:	00 04 db             	add    %al,(%rbx,%rbx,8)
    101b:	08 a4 09 03 11 7f 9f 	or     %ah,-0x6080eefd(%rcx,%rcx,1)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1022:	04 de                	add    $0xde,%al
    1024:	09 a3 0a 03 11 7f    	or     %esp,0x7f11030a(%rbx)
    102a:	9f                   	lahf
    102b:	04 91                	add    $0x91,%al
    102d:	10 c8                	adc    %cl,%al
    102f:	10 03                	adc    %al,(%rbx)
    1031:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    1034:	04 c9                	add    $0xc9,%al
    1036:	11 c5                	adc    %eax,%ebp
    1038:	16                   	(bad)
    1039:	03 11                	add    (%rcx),%edx
    103b:	7f 9f                	jg     fdc <balancer_ingress+0xfdc>
  memcpy(new_eth->h_dest, cval->mac, 6);
    103d:	04 de                	add    $0xde,%al
    103f:	18 a3 19 03 11 7f    	sbb    %ah,0x7f110319(%rbx)
    1045:	9f                   	lahf
    1046:	04 f8                	add    $0xf8,%al
    1048:	26 c5 27 03          	(bad)
    104c:	11 7f 9f             	adc    %edi,-0x61(%rdi)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    104f:	04 d1                	add    $0xd1,%al
    1051:	28 ab 29 03 11 7f    	sub    %ch,0x7f110329(%rbx)
    1057:	9f                   	lahf
    1058:	04 de                	add    $0xde,%al
    105a:	2a b8 2b 03 11 7f    	sub    0x7f11032b(%rax),%bh
  new_eth->h_proto = BE_ETH_P_IPV6;
    1060:	9f                   	lahf
    1061:	04 a3                	add    $0xa3,%al
    1063:	2c fa                	sub    $0xfa,%al
    1065:	32 03                	xor    (%rbx),%al
  saddr[3] = src ^ port;
    1067:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    106a:	04 f7                	add    $0xf7,%al
    106c:	33 b9 36 03 11 7f    	xor    0x7f110336(%rcx),%edi
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1072:	9f                   	lahf
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1073:	04 e7                	add    $0xe7,%al
    1075:	36 c5 38 03          	(bad)
  ip6h->priority = (tc & 0xF0) >> 4;
    1079:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    107c:	04 af                	add    $0xaf,%al
    107e:	39 88 3b 03 11 7f    	cmp    %ecx,0x7f11033b(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1084:	9f                   	lahf
    1085:	04 9b                	add    $0x9b,%al
    1087:	3c f3                	cmp    $0xf3,%al
    1089:	3d 03 11 7f 9f       	cmp    $0x9f7f1103,%eax
  ip6h->nexthdr = proto;
    108e:	00 04 db             	add    %al,(%rbx,%rbx,8)
  ip6h->payload_len = bpf_htons(payload_len);
    1091:	08 a4 09 01 52 04 de 	or     %ah,-0x21fbadff(%rcx,%rcx,1)
    1098:	09 f9                	or     %edi,%ecx
    109a:	09 01                	or     %eax,(%rcx)
    109c:	52                   	push   %rdx
    109d:	04 91                	add    $0x91,%al
    109f:	10 95 10 01 52 04    	adc    %dl,0x4520110(%rbp)
    conn_rate_stats->v1 += 1;
    10a5:	bf 15 df 15 01       	mov    $0x115df15,%edi
    10aa:	52                   	push   %rdx
    10ab:	00 04 db             	add    %al,(%rbx,%rbx,8)
    10ae:	08 a4 09 01 5e 04 bf 	or     %ah,-0x40fba1ff(%rcx,%rcx,1)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    10b5:	15 c5 16 01 5e       	adc    $0x5e0116c5,%eax
    10ba:	00 04 db             	add    %al,(%rbx,%rbx,8)
    10bd:	08 a4 09 01 5c 04 bf 	or     %ah,-0x40fba3ff(%rcx,%rcx,1)
    10c4:	15 c5 16 01 5c       	adc    $0x5c0116c5,%eax
    10c9:	00 04 db             	add    %al,(%rbx,%rbx,8)
    b += *(u32*)(k + 4);
    10cc:	08 a4 09 03 10 22 9f 	or     %ah,-0x60ddeffd(%rcx,%rcx,1)
      a += (u32)k[3] << 24;
    10d3:	04 bf                	add    $0xbf,%al
      a += (u32)k[2] << 16;
    10d5:	15 c5 16 03 10       	adc    $0x100316c5,%eax
      a += (u32)k[1] << 8;
    10da:	22 9f 00 04 db 08    	and    0x8db0400(%rdi),%bl
      a += k[0];
    10e0:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    10e1:	09 04 76             	or     %eax,(%rsi,%rsi,2)
    10e4:	80 7f 9f 04          	cmpb   $0x4,-0x61(%rdi)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    10e8:	bf 15 c5 16 04       	mov    $0x416c515,%edi
      memset(pckt->flow.srcv6, 0, 16);
    10ed:	76 80                	jbe    106f <balancer_ingress+0x106f>
    10ef:	7f 9f                	jg     1090 <balancer_ingress+0x1090>
    10f1:	00 04 db             	add    %al,(%rbx,%rbx,8)
    10f4:	08 a4 09 01 52 04 bf 	or     %ah,-0x40fbadff(%rcx,%rcx,1)
    10fb:	15 df 15 01 52       	adc    $0x520115df,%eax
    1100:	00 04 e0             	add    %al,(%rax,%riz,8)
    1103:	08 a4 09 01 5e 04 bf 	or     %ah,-0x40fba1ff(%rcx,%rcx,1)
    110a:	15 c5 16 01 5e       	adc    $0x5e0116c5,%eax
    c += *(u32*)(k + 8);
    110f:	00 04 e0             	add    %al,(%rax,%riz,8)
    1112:	08 a4 09 01 5c 04 bf 	or     %ah,-0x40fba3ff(%rcx,%rcx,1)
  return (word << shift) | (word >> ((-shift) & 31));
    1119:	15 c5 16 01 5c       	adc    $0x5c0116c5,%eax
    b += *(u32*)(k + 4);
    111e:	00 04 e0             	add    %al,(%rax,%riz,8)
    1121:	08 a4 09 03 10 22 9f 	or     %ah,-0x60ddeffd(%rcx,%rcx,1)
    __jhash_mix(a, b, c);
    1128:	04 bf                	add    $0xbf,%al
    112a:	15 81 16 03 10       	adc    $0x10031681,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    112f:	22 9f 04 81 16 c5    	and    -0x3ae97efc(%rdi),%bl
    __jhash_mix(a, b, c);
    1135:	16                   	(bad)
    1136:	03 10                	add    (%rax),%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1138:	2a 9f 00 04 e0 08    	sub    0x8e00400(%rdi),%bl
    __jhash_mix(a, b, c);
    113e:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    113f:	09 04 76             	or     %eax,(%rsi,%rsi,2)
    1142:	80 7f 9f 04          	cmpb   $0x4,-0x61(%rdi)
  return (word << shift) | (word >> ((-shift) & 31));
    1146:	bf 15 c5 16 04       	mov    $0x416c515,%edi
    __jhash_mix(a, b, c);
    114b:	76 80                	jbe    10cd <balancer_ingress+0x10cd>
    114d:	7f 9f                	jg     10ee <balancer_ingress+0x10ee>
  return (word << shift) | (word >> ((-shift) & 31));
    114f:	00 04 e0             	add    %al,(%rax,%riz,8)
    1152:	08 a4 09 01 5f 04 bf 	or     %ah,-0x40fba0ff(%rcx,%rcx,1)
    __jhash_mix(a, b, c);
    1159:	15 c5 16 01 5f       	adc    $0x5f0116c5,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    115e:	00 04 af             	add    %al,(%rdi,%rbp,4)
    __jhash_mix(a, b, c);
    1161:	09 bc 09 01 50 00 04 	or     %edi,0x4005001(%rcx,%rcx,1)
      a += (u32)k[3] << 24;
    1168:	ff 09                	decl   (%rcx)
      a += (u32)k[2] << 16;
    116a:	a3 0a 01 52 00 04 a3 	movabs %eax,0xac0aa3040052010a
    1171:	0a ac 
      a += (u32)k[1] << 8;
    1173:	0a 04 10             	or     (%rax,%rdx,1),%al
    1176:	8c 04 9f             	mov    %es,(%rdi,%rbx,4)
    1179:	04 ac                	add    $0xac,%al
      a += (u32)k[2] << 16;
    117b:	0a e3                	or     %bl,%ah
      a += k[0];
    117d:	0a 02                	or     (%rdx),%al
    117f:	76 40                	jbe    11c1 <balancer_ingress+0x11c1>
      a += (u32)k[1] << 8;
    1181:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    __jhash_mix(a, b, c);
    1184:	0a c3                	or     %bl,%al
      __jhash_final(a, b, c);
    1186:	0a 02                	or     (%rdx),%al
    1188:	30 9f 04 c3 0a cc    	xor    %bl,-0x33f53cfc(%rdi)
    118e:	0a 01                	or     (%rcx),%al
    1190:	50                   	push   %rax
    1191:	00 04 c3             	add    %al,(%rbx,%rax,8)
  return (word << shift) | (word >> ((-shift) & 31));
    1194:	0a e3                	or     %bl,%ah
    1196:	0a 01                	or     (%rcx),%al
      __jhash_final(a, b, c);
    1198:	50                   	push   %rax
    1199:	00 04 d6             	add    %al,(%rsi,%rdx,8)
  return (word << shift) | (word >> ((-shift) & 31));
    119c:	0a e3                	or     %bl,%ah
    119e:	0a 01                	or     (%rcx),%al
      __jhash_final(a, b, c);
    11a0:	52                   	push   %rdx
    11a1:	00 04 e5 0a a7 0b 03 	add    %al,0x30ba70a(,%riz,8)
  return (word << shift) | (word >> ((-shift) & 31));
    11a8:	10 3e                	adc    %bh,(%rsi)
      __jhash_final(a, b, c);
    11aa:	9f                   	lahf
    11ab:	00 04 e5 0a a7 0b 03 	add    %al,0x30ba70a(,%riz,8)
    11b2:	7e 3e                	jle    11f2 <balancer_ingress+0x11f2>
    11b4:	9f                   	lahf
    11b5:	00 04 e4             	add    %al,(%rsp,%riz,8)
  return (word << shift) | (word >> ((-shift) & 31));
    11b8:	0b fe                	or     %esi,%edi
      __jhash_final(a, b, c);
    11ba:	0b 02                	or     (%rdx),%eax
    11bc:	30 9f 04 fe 0b 87    	xor    %bl,-0x78f401fc(%rdi)
  a += initval;
    11c2:	0c 01                	or     $0x1,%al
    11c4:	50                   	push   %rax
    11c5:	00 04 fe             	add    %al,(%rsi,%rdi,8)
  b += initval;
    11c8:	0b a3 0c 01 50 04    	or     0x450010c(%rbx),%esp
  a += initval;
    11ce:	a3 0c df 0c 02 76 50 	movabs %eax,0xdf045076020cdf0c
    11d5:	04 df 
  __jhash_final(a, b, c);
    11d7:	0c c8                	or     $0xc8,%al
  return (word << shift) | (word >> ((-shift) & 31));
    11d9:	0e                   	(bad)
    11da:	01 53 04             	add    %edx,0x4(%rbx)
  __jhash_final(a, b, c);
    11dd:	c8 0e d1 0e          	enter  $0xd10e,$0xe
  return (word << shift) | (word >> ((-shift) & 31));
    11e1:	01 54 04 d1          	add    %edx,-0x2f(%rsp,%rax,1)
    11e5:	0f f2 0f             	pslld  (%rdi),%mm1
  __jhash_final(a, b, c);
    11e8:	01 50 04             	add    %edx,0x4(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    11eb:	f4                   	hlt
    11ec:	0f 91 10             	setno  (%rax)
  __jhash_final(a, b, c);
    11ef:	01 50 04             	add    %edx,0x4(%rax)
    11f2:	c5 16 85             	(bad)
  return (word << shift) | (word >> ((-shift) & 31));
    11f5:	17                   	(bad)
    11f6:	01 53 04             	add    %edx,0x4(%rbx)
  __jhash_final(a, b, c);
    11f9:	85 17                	test   %edx,(%rdi)
    11fb:	99                   	cltd
  return (word << shift) | (word >> ((-shift) & 31));
    11fc:	17                   	(bad)
    11fd:	01 54 04 99          	add    %edx,-0x67(%rsp,%rax,1)
  __jhash_final(a, b, c);
    1201:	17                   	(bad)
    1202:	e6 17                	out    %al,$0x17
    1204:	02 76 50             	add    0x50(%rsi),%dh
  return (word << shift) | (word >> ((-shift) & 31));
    1207:	04 e6                	add    $0xe6,%al
  __jhash_final(a, b, c);
    1209:	17                   	(bad)
    120a:	ee                   	out    %al,(%dx)
    120b:	17                   	(bad)
  return (word << shift) | (word >> ((-shift) & 31));
    120c:	01 54 04 ee          	add    %edx,-0x12(%rsp,%rax,1)
  __jhash_final(a, b, c);
    1210:	17                   	(bad)
    1211:	98                   	cwtl
    1212:	18 01                	sbb    %al,(%rcx)
    1214:	53                   	push   %rbx
    1215:	04 a9                	add    $0xa9,%al
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1217:	18 b9 18 01 54 04    	sbb    %bh,0x4540118(%rcx)
    121d:	c2 18 de             	ret    $0xde18
    1220:	18 01                	sbb    %al,(%rcx)
    1222:	54                   	push   %rsp
    1223:	04 a3                	add    $0xa3,%al
    1225:	19 f0                	sbb    %esi,%eax
    1227:	19 01                	sbb    %eax,(%rcx)
    1229:	53                   	push   %rbx
    122a:	04 f0                	add    $0xf0,%al
    key = RING_SIZE * (vip_info->vip_num) + hash;
    122c:	19 a0 1a 02 76 50    	sbb    %esp,0x5076021a(%rax)
    1232:	04 a0                	add    $0xa0,%al
    1234:	1a c9                	sbb    %cl,%cl
    1236:	1a 01                	sbb    (%rcx),%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1238:	54                   	push   %rsp
    1239:	04 c9                	add    $0xc9,%al
    123b:	1a a9 1c 02 76 50    	sbb    0x5076021c(%rcx),%ch
    if (!real_pos) {
    1241:	04 cc                	add    $0xcc,%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1243:	1e                   	(bad)
    1244:	f2 1f                	repnz (bad)
    1246:	02 76 50             	add    0x50(%rsi),%dh
    1249:	04 f2                	add    $0xf2,%al
    124b:	1f                   	(bad)
    124c:	f7 1f                	negl   (%rdi)
    124e:	01 52 04             	add    %edx,0x4(%rdx)
    key = *real_pos;
    1251:	9d                   	popf
    1252:	21 a3 21 02 76 50    	and    %esp,0x50760221(%rbx)
    1258:	04 a3                	add    $0xa3,%al
    if (key == 0) {
    125a:	21 a5 21 01 52 04    	and    %esp,0x4520121(%rbp)
  pckt->real_index = key;
    1260:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    1261:	21 ba 21 02 76 50    	and    %edi,0x50760221(%rdx)
  *real = bpf_map_lookup_elem(&reals, &key);
    1267:	04 ba                	add    $0xba,%al
  if (!(*real)) {
    1269:	21 cd                	and    %ecx,%ebp
    126b:	21 01                	and    %eax,(%rcx)
    126d:	52                   	push   %rdx
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    126e:	04 cd                	add    $0xcd,%al
    1270:	21 e2                	and    %esp,%edx
    1272:	21 02                	and    %eax,(%rdx)
    1274:	76 50                	jbe    12c6 <balancer_ingress+0x12c6>
    1276:	04 e2                	add    $0xe2,%al
    1278:	21 e9                	and    %ebp,%ecx
    127a:	21 01                	and    %eax,(%rcx)
    127c:	52                   	push   %rdx
    127d:	04 e9                	add    $0xe9,%al
    127f:	21 ab 24 02 76 50    	and    %ebp,0x50760224(%rbx)
    1285:	04 ab                	add    $0xab,%al
    1287:	24 b0                	and    $0xb0,%al
    1289:	24 01                	and    $0x1,%al
    128b:	52                   	push   %rdx
    128c:	04 b0                	add    $0xb0,%al
    if (pckt->flow.proto == IPPROTO_UDP) {
    128e:	24 fc                	and    $0xfc,%al
    1290:	24 02                	and    $0x2,%al
    1292:	76 50                	jbe    12e4 <balancer_ingress+0x12e4>
      new_dst_lru.atime = cur_time;
    1294:	04 fc                	add    $0xfc,%al
    1296:	24 fe                	and    $0xfe,%al
    new_dst_lru.pos = key;
    1298:	24 01                	and    $0x1,%al
    129a:	52                   	push   %rdx
    129b:	04 fe                	add    $0xfe,%al
    129d:	24 f8                	and    $0xf8,%al
    129f:	26 02 76 50          	es add 0x50(%rsi),%dh
    12a3:	04 c5                	add    $0xc5,%al
    12a5:	27                   	(bad)
    12a6:	e9 27 01 53 04       	jmp    45313d2 <_license+0x452f4df>
    12ab:	e9 27 b2 28 01       	jmp    128c4d7 <_license+0x128a5e4>
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    12b0:	54                   	push   %rsp
    12b1:	04 bb                	add    $0xbb,%al
    12b3:	28 ca                	sub    %cl,%dl
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    12b5:	28 01                	sub    %al,(%rcx)
    12b7:	54                   	push   %rsp
    12b8:	04 be                	add    $0xbe,%al
    12ba:	29 96 2a 01 54 04    	sub    %edx,0x454012a(%rsi)
    12c0:	96                   	xchg   %eax,%esi
    12c1:	2a c5                	sub    %ch,%al
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    12c3:	2a 02                	sub    (%rdx),%al
    12c5:	76 50                	jbe    1317 <balancer_ingress+0x1317>
    12c7:	04 c5                	add    $0xc5,%al
    12c9:	2a d9                	sub    %cl,%bl
    12cb:	2a 01                	sub    (%rcx),%al
    12cd:	54                   	push   %rsp
    12ce:	04 bf                	add    $0xbf,%al
    12d0:	2b 90 2c 02 76 50    	sub    0x5076022c(%rax),%edx
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    12d6:	04 92                	add    $0x92,%al
    12d8:	3b 9b 3c 02 76 50    	cmp    0x5076023c(%rbx),%ebx
    12de:	00 04 9f             	add    %al,(%rdi,%rbx,4)
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    12e1:	0c ad                	or     $0xad,%al
    12e3:	0c 04                	or     $0x4,%al
    12e5:	10 80 04 9f 04 ad    	adc    %al,-0x52fb60fc(%rax)
    12eb:	0c d1                	or     $0xd1,%al
    12ed:	0e                   	(bad)
    12ee:	03 76 cc             	add    -0x34(%rsi),%esi
    12f1:	7e 04                	jle    12f7 <balancer_ingress+0x12f7>
    12f3:	c5 16 de             	(bad)
    12f6:	18 03                	sbb    %al,(%rbx)
    12f8:	76 cc                	jbe    12c6 <balancer_ingress+0x12c6>
    12fa:	7e 04                	jle    1300 <balancer_ingress+0x1300>
    12fc:	a3 19 f8 26 03 76 cc 	movabs %eax,0x47ecc760326f819
    1303:	7e 04 
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1305:	c5 27 ca             	(bad)
    1308:	28 03                	sub    %al,(%rbx)
    130a:	76 cc                	jbe    12d8 <balancer_ingress+0x12d8>
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    130c:	7e 04                	jle    1312 <balancer_ingress+0x1312>
    130e:	be 29 de 2a 03       	mov    $0x32ade29,%esi
    1313:	76 cc                	jbe    12e1 <balancer_ingress+0x12e1>
    1315:	7e 04                	jle    131b <balancer_ingress+0x131b>
  bool vip_match = address_match && port_match && proto_match;
    1317:	bf 2b 90 2c 03       	mov    $0x32c902b,%edi
    131c:	76 cc                	jbe    12ea <balancer_ingress+0x12ea>
    131e:	7e 04                	jle    1324 <balancer_ingress+0x1324>
    1320:	92                   	xchg   %eax,%edx
    1321:	3b 9b 3c 03 76 cc    	cmp    -0x3389fcc4(%rbx),%ebx
    __u32 lru_stats_key = pckt->real_index;
    1327:	7e 00                	jle    1329 <balancer_ingress+0x1329>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1329:	04 ad                	add    $0xad,%al
    132b:	0c c7                	or     $0xc7,%al
    132d:	0c 02                	or     $0x2,%al
    132f:	30 9f 04 c7 0c d0    	xor    %bl,-0x2ff338fc(%rdi)
    1335:	0c 01                	or     $0x1,%al
    1337:	50                   	push   %rax
    1338:	00 04 c7             	add    %al,(%rdi,%rax,8)
    133b:	0c d7                	or     $0xd7,%al
    133d:	0c 01                	or     $0x1,%al
    if (!lru_miss_stat) {
    133f:	50                   	push   %rax
    1340:	04 d7                	add    $0xd7,%al
    1342:	0c e4                	or     $0xe4,%al
    1344:	0c 03                	or     $0x3,%al
    1346:	76 c0                	jbe    1308 <balancer_ingress+0x1308>
    *lru_miss_stat += 1;
    1348:	7e 04                	jle    134e <balancer_ingress+0x134e>
    134a:	e4 0c                	in     $0xc,%al
    134c:	ed                   	in     (%dx),%eax
    134d:	0c 01                	or     $0x1,%al
    134f:	50                   	push   %rax
    1350:	04 ed                	add    $0xed,%al
    1352:	0c d1                	or     $0xd1,%al
    1354:	0e                   	(bad)
    1355:	03 76 c0             	add    -0x40(%rsi),%esi
    1358:	7e 04                	jle    135e <balancer_ingress+0x135e>
    135a:	c5 16 de             	(bad)
    135d:	18 03                	sbb    %al,(%rbx)
    135f:	76 c0                	jbe    1321 <balancer_ingress+0x1321>
    1361:	7e 04                	jle    1367 <balancer_ingress+0x1367>
    1363:	a3 19 97 1c 03 76 c0 	movabs %eax,0x47ec076031c9719
    136a:	7e 04 
      data_stats->v2 += 1;
    136c:	97                   	xchg   %eax,%edi
    136d:	1c e7                	sbb    $0xe7,%al
    136f:	1c 01                	sbb    $0x1,%al
    1371:	50                   	push   %rax
    1372:	04 cc                	add    $0xcc,%al
    1374:	1e                   	(bad)
    1375:	f7 1f                	negl   (%rdi)
    1377:	03 76 c0             	add    -0x40(%rsi),%esi
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    137a:	7e 04                	jle    1380 <balancer_ingress+0x1380>
    137c:	9d                   	popf
    137d:	21 eb                	and    %ebp,%ebx
    137f:	26 03 76 c0          	es add -0x40(%rsi),%esi
    1383:	7e 04                	jle    1389 <balancer_ingress+0x1389>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1385:	eb 26                	jmp    13ad <balancer_ingress+0x13ad>
    1387:	f8                   	clc
    1388:	26 01 50 04          	es add %edx,0x4(%rax)
    138c:	c5 27 ca             	(bad)
        quic_packets_stats->cid_initial += 1;
    138f:	28 03                	sub    %al,(%rbx)
    1391:	76 c0                	jbe    1353 <balancer_ingress+0x1353>
    1393:	7e 04                	jle    1399 <balancer_ingress+0x1399>
    1395:	be 29 de 2a 03       	mov    $0x32ade29,%esi
    139a:	76 c0                	jbe    135c <balancer_ingress+0x135c>
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    139c:	7e 04                	jle    13a2 <balancer_ingress+0x13a2>
    139e:	bf 2b 90 2c 03       	mov    $0x32c902b,%edi
    13a3:	76 c0                	jbe    1365 <balancer_ingress+0x1365>
    13a5:	7e 04                	jle    13ab <balancer_ingress+0x13ab>
    13a7:	92                   	xchg   %eax,%edx
    13a8:	3b 9b 3c 03 76 c0    	cmp    -0x3f89fcc4(%rbx),%ebx
    13ae:	7e 00                	jle    13b0 <balancer_ingress+0x13b0>
    13b0:	04 ed                	add    $0xed,%al
    13b2:	0c f3                	or     $0xf3,%al
  if (!per_vip_stats) {
    13b4:	0c 01                	or     $0x1,%al
    13b6:	50                   	push   %rax
    13b7:	04 f3                	add    $0xf3,%al
    13b9:	0c d1                	or     $0xd1,%al
    13bb:	0e                   	(bad)
    per_vip_stats->v1 += 1;
    13bc:	03 76 fc             	add    -0x4(%rsi),%esi
    13bf:	7e 04                	jle    13c5 <balancer_ingress+0x13c5>
    13c1:	c5 16 de             	(bad)
    13c4:	18 03                	sbb    %al,(%rbx)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    13c6:	76 fc                	jbe    13c4 <balancer_ingress+0x13c4>
    13c8:	7e 04                	jle    13ce <balancer_ingress+0x13ce>
    13ca:	a3 19 c4 19 03 76 fc 	movabs %eax,0x47efc760319c419
    13d1:	7e 04 
    13d3:	c4                   	(bad)
    13d4:	19 dc                	sbb    %ebx,%esp
    13d6:	19 01                	sbb    %eax,(%rcx)
    13d8:	50                   	push   %rax
    13d9:	04 dc                	add    $0xdc,%al
  if (!connId) {
    13db:	19 fc                	sbb    %edi,%esp
    13dd:	1b 03                	sbb    (%rbx),%eax
    13df:	76 fc                	jbe    13dd <balancer_ingress+0x13dd>
    13e1:	7e 04                	jle    13e7 <balancer_ingress+0x13e7>
    13e3:	fc                   	cld
    13e4:	1b cc                	sbb    %esp,%ecx
    13e6:	1e                   	(bad)
    13e7:	03 76 d4             	add    -0x2c(%rsi),%esi
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    13ea:	7e 04                	jle    13f0 <balancer_ingress+0x13f0>
    13ec:	cc                   	int3
    13ed:	1e                   	(bad)
    13ee:	f7 1f                	negl   (%rdi)
    13f0:	03 76 fc             	add    -0x4(%rsi),%esi
    13f3:	7e 04                	jle    13f9 <balancer_ingress+0x13f9>
    13f5:	f7 1f                	negl   (%rdi)
    13f7:	9d                   	popf
    13f8:	21 03                	and    %eax,(%rbx)
    13fa:	76 d4                	jbe    13d0 <balancer_ingress+0x13d0>
    13fc:	7e 04                	jle    1402 <balancer_ingress+0x1402>
    13fe:	9d                   	popf
    13ff:	21 f8                	and    %edi,%eax
    1401:	26 03 76 fc          	es add -0x4(%rsi),%esi
    1405:	7e 04                	jle    140b <balancer_ingress+0x140b>
    1407:	c5 27 ca             	(bad)
    140a:	28 03                	sub    %al,(%rbx)
    140c:	76 fc                	jbe    140a <balancer_ingress+0x140a>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    140e:	7e 04                	jle    1414 <balancer_ingress+0x1414>
    1410:	be 29 de 2a 03       	mov    $0x32ade29,%esi
    1415:	76 fc                	jbe    1413 <balancer_ingress+0x1413>
    1417:	7e 04                	jle    141d <balancer_ingress+0x141d>
    1419:	bf 2b 90 2c 03       	mov    $0x32c902b,%edi
    141e:	76 fc                	jbe    141c <balancer_ingress+0x141c>
    1420:	7e 04                	jle    1426 <balancer_ingress+0x1426>
    1422:	92                   	xchg   %eax,%edx
    1423:	3b 9f 3b 03 76 fc    	cmp    -0x389fcc5(%rdi),%ebx
    1429:	7e 04                	jle    142f <balancer_ingress+0x142f>
    142b:	9f                   	lahf
      if (qpr.server_id > 0) {
    142c:	3b b7 3b 01 50 04    	cmp    0x450013b(%rdi),%esi
    1432:	c5 3b 8c             	(bad)
    1435:	3c 03                	cmp    $0x3,%al
    1437:	76 fc                	jbe    1435 <balancer_ingress+0x1435>
    1439:	7e 00                	jle    143b <balancer_ingress+0x143b>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    143b:	04 82                	add    $0x82,%al
    143d:	0d 88 0d 01 50       	or     $0x50010d88,%eax
    1442:	04 88                	add    $0x88,%al
    1444:	0d d1 0e 03 76       	or     $0x76030ed1,%eax
    1449:	d0 7e 04             	sarb   0x4(%rsi)
    144c:	c5 16 de             	(bad)
    144f:	18 03                	sbb    %al,(%rbx)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1451:	76 d0                	jbe    1423 <balancer_ingress+0x1423>
    1453:	7e 04                	jle    1459 <balancer_ingress+0x1459>
    1455:	a3 19 f8 26 03 76 d0 	movabs %eax,0x47ed0760326f819
    145c:	7e 04 
    145e:	c5 27 ca             	(bad)
    1461:	28 03                	sub    %al,(%rbx)
  if (!connId) {
    1463:	76 d0                	jbe    1435 <balancer_ingress+0x1435>
    1465:	7e 04                	jle    146b <balancer_ingress+0x146b>
    1467:	be 29 de 2a 03       	mov    $0x32ade29,%esi
  __u8 connIdVersion = (connId[0] >> 6);
    146c:	76 d0                	jbe    143e <balancer_ingress+0x143e>
    146e:	7e 04                	jle    1474 <balancer_ingress+0x1474>
    1470:	bf 2b 90 2c 03       	mov    $0x32c902b,%edi
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    1475:	76 d0                	jbe    1447 <balancer_ingress+0x1447>
    1477:	7e 04                	jle    147d <balancer_ingress+0x147d>
    1479:	92                   	xchg   %eax,%edx
    147a:	3b 9b 3c 03 76 d0    	cmp    -0x2f89fcc4(%rbx),%ebx
    1480:	7e 00                	jle    1482 <balancer_ingress+0x1482>
    1482:	04 88                	add    $0x88,%al
    1484:	0d a2 0d 02 30       	or     $0x30020da2,%eax
    1489:	9f                   	lahf
    148a:	04 a2                	add    $0xa2,%al
    148c:	0d a9 0d 01 50       	or     $0x50010da9,%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    1491:	04 a9                	add    $0xa9,%al
    1493:	0d ae 0d 03 76       	or     $0x76030dae,%eax
    1498:	f0 7e 00             	lock jle 149b <balancer_ingress+0x149b>
    149b:	04 a2                	add    $0xa2,%al
    149d:	0d a9 0d 01 50       	or     $0x50010da9,%eax
    14a2:	04 a9                	add    $0xa9,%al
    14a4:	0d ae 0d 03 76       	or     $0x76030dae,%eax
    14a9:	f0 7e 04             	lock jle 14b0 <balancer_ingress+0x14b0>
    14ac:	ae                   	scas   %es:(%rdi),%al
    14ad:	0d ca 0d 01 50       	or     $0x50010dca,%eax
    14b2:	04 ca                	add    $0xca,%al
    14b4:	0d cf 0d 03 76       	or     $0x76030dcf,%eax
    14b9:	f0 7e 04             	lock jle 14c0 <balancer_ingress+0x14c0>
    14bc:	ee                   	out    %al,(%dx)
    14bd:	0d d1 0e 03 76       	or     $0x76030ed1,%eax
    14c2:	f0 7e 04             	lock jle 14c9 <balancer_ingress+0x14c9>
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    14c5:	c5 16 a7             	(bad)
    14c8:	17                   	(bad)
        if (real_pos) {
    14c9:	03 76 f0             	add    -0x10(%rsi),%esi
    14cc:	7e 04                	jle    14d2 <balancer_ingress+0x14d2>
    14ce:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    14cf:	17                   	(bad)
    14d0:	a9 17 01 55 04       	test   $0x4550117,%eax
          key = *real_pos;
    14d5:	a9 17 de 18 03       	test   $0x318de17,%eax
    14da:	76 f0                	jbe    14cc <balancer_ingress+0x14cc>
    14dc:	7e 04                	jle    14e2 <balancer_ingress+0x14e2>
    14de:	a3 19 b0 25 03 76 f0 	movabs %eax,0x47ef0760325b019
    14e5:	7e 04 
            dst = bpf_map_lookup_elem(&reals, &key);
    14e7:	b0 25                	mov    $0x25,%al
    14e9:	b4 25                	mov    $0x25,%ah
    14eb:	01 55 04             	add    %edx,0x4(%rbp)
    14ee:	b4 25                	mov    $0x25,%ah
    14f0:	f8                   	clc
    14f1:	26 03 76 f0          	es add -0x10(%rsi),%esi
    14f5:	7e 04                	jle    14fb <balancer_ingress+0x14fb>
    14f7:	c5 27 ca             	(bad)
    14fa:	28 03                	sub    %al,(%rbx)
    14fc:	76 f0                	jbe    14ee <balancer_ingress+0x14ee>
    14fe:	7e 04                	jle    1504 <balancer_ingress+0x1504>
    1500:	be 29 a4 2a 03       	mov    $0x32aa429,%esi
    1505:	76 f0                	jbe    14f7 <balancer_ingress+0x14f7>
            if (!dst) {
    1507:	7e 04                	jle    150d <balancer_ingress+0x150d>
    1509:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    150a:	2a a7 2a 01 55 04    	sub    0x455012a(%rdi),%ah
    1510:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    1511:	2a de                	sub    %dh,%bl
    1513:	2a 03                	sub    (%rbx),%al
    1515:	76 f0                	jbe    1507 <balancer_ingress+0x1507>
    1517:	7e 04                	jle    151d <balancer_ingress+0x151d>
    1519:	bf 2b 90 2c 03       	mov    $0x32c902b,%edi
    151e:	76 f0                	jbe    1510 <balancer_ingress+0x1510>
    1520:	7e 04                	jle    1526 <balancer_ingress+0x1526>
    1522:	92                   	xchg   %eax,%edx
    1523:	3b 83 3c 03 76 f0    	cmp    -0xf89fcc4(%rbx),%eax
  if (dst_lru) {
    1529:	7e 04                	jle    152f <balancer_ingress+0x152f>
    152b:	83 3c 87 3c          	cmpl   $0x3c,(%rdi,%rax,4)
    152f:	01 55 04             	add    %edx,0x4(%rbp)
    if (dst_lru->pos == pckt->real_index) {
    1532:	87 3c 9b             	xchg   %edi,(%rbx,%rbx,4)
    1535:	3c 03                	cmp    $0x3,%al
    1537:	76 f0                	jbe    1529 <balancer_ingress+0x1529>
    1539:	7e 00                	jle    153b <balancer_ingress+0x153b>
              quic_packets_stats->dst_match_in_lru += 1;
    153b:	04 ae                	add    $0xae,%al
    153d:	0d b5 0d 04 10       	or     $0x10040db5,%eax
    1542:	83 04 9f 04          	addl   $0x4,(%rdi,%rbx,4)
    1546:	b5 0d                	mov    $0xd,%ch
    1548:	ee                   	out    %al,(%dx)
    1549:	0d 02 76 40 00       	or     $0x407602,%eax
    154e:	04 b5                	add    $0xb5,%al
    1550:	0d cc 0d 02 30       	or     $0x30020dcc,%eax
    1555:	9f                   	lahf
    1556:	04 cc                	add    $0xcc,%al
    1558:	0d d5 0d 01 50       	or     $0x50010dd5,%eax
    155d:	00 04 cc             	add    %al,(%rsp,%rcx,8)
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1560:	0d e3 0d 01 50       	or     $0x50010de3,%eax
    1565:	00 04 84             	add    %al,(%rsp,%rax,4)
    1568:	0e                   	(bad)
    1569:	8b 0e                	mov    (%rsi),%ecx
    156b:	02 30                	add    (%rax),%dh
    156d:	9f                   	lahf
    156e:	04 8b                	add    $0x8b,%al
    1570:	0e                   	(bad)
    1571:	d1 0e                	rorl   (%rsi)
    1573:	03 76 b8             	add    -0x48(%rsi),%esi
    1576:	7f 04                	jg     157c <balancer_ingress+0x157c>
    1578:	ee                   	out    %al,(%dx)
    1579:	17                   	(bad)
    157a:	de 18                	ficomps (%rax)
    157c:	03 76 b8             	add    -0x48(%rsi),%esi
    157f:	7f 04                	jg     1585 <balancer_ingress+0x1585>
    1581:	a3 19 e7 19 03 76 b8 	movabs %eax,0x47fb8760319e719
    1588:	7f 04 
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    158a:	c5 27 ca             	(bad)
    158d:	28 03                	sub    %al,(%rbx)
    158f:	76 b8                	jbe    1549 <balancer_ingress+0x1549>
    1591:	7f 04                	jg     1597 <balancer_ingress+0x1597>
    1593:	be 29 de 2a 03       	mov    $0x32ade29,%esi
    1598:	76 b8                	jbe    1552 <balancer_ingress+0x1552>
    159a:	7f 04                	jg     15a0 <balancer_ingress+0x15a0>
    159c:	bf 2b 90 2c 03       	mov    $0x32c902b,%edi
      if (qpr.server_id > 0) {
    15a1:	76 b8                	jbe    155b <balancer_ingress+0x155b>
    15a3:	7f 04                	jg     15a9 <balancer_ingress+0x15a9>
    15a5:	92                   	xchg   %eax,%edx
    15a6:	3b 9b 3c 03 76 b8    	cmp    -0x4789fcc4(%rbx),%ebx
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    15ac:	7f 00                	jg     15ae <balancer_ingress+0x15ae>
    15ae:	04 8b                	add    $0x8b,%al
    15b0:	0e                   	(bad)
    15b1:	a2 0e 02 30 9f 04 a2 	movabs %al,0xab0ea2049f30020e
    15b8:	0e ab 
    15ba:	0e                   	(bad)
    15bb:	01 50 00             	add    %edx,0x0(%rax)
    15be:	04 a2                	add    $0xa2,%al
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    15c0:	0e                   	(bad)
    15c1:	d1 0e                	rorl   (%rsi)
    15c3:	01 50 04             	add    %edx,0x4(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    15c6:	ee                   	out    %al,(%dx)
    15c7:	17                   	(bad)
    15c8:	98                   	cwtl
    15c9:	18 01                	sbb    %al,(%rcx)
    15cb:	50                   	push   %rax
    15cc:	04 98                	add    $0x98,%al
    15ce:	18 de                	sbb    %bl,%dh
    15d0:	18 01                	sbb    %al,(%rcx)
    15d2:	53                   	push   %rbx
    15d3:	04 a3                	add    $0xa3,%al
    15d5:	19 c4                	sbb    %eax,%esp
  if (!conn_rate_stats) {
    15d7:	19 01                	sbb    %eax,(%rcx)
    15d9:	50                   	push   %rax
    15da:	04 c5                	add    $0xc5,%al
    15dc:	27                   	(bad)
    15dd:	e9 27 01 50 04       	jmp    4501709 <_license+0x44ff816>
    15e2:	e9 27 ca 28 01       	jmp    128e00e <_license+0x128c11b>
    15e7:	53                   	push   %rbx
    15e8:	04 be                	add    $0xbe,%al
  *cur_time = bpf_ktime_get_ns();
    15ea:	29 de                	sub    %ebx,%esi
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    15ec:	2a 01                	sub    (%rcx),%al
    15ee:	53                   	push   %rbx
    15ef:	04 bf                	add    $0xbf,%al
    15f1:	2b 90 2c 01 53 04    	sub    0x453012c(%rax),%edx
    15f7:	92                   	xchg   %eax,%edx
    15f8:	3b 9b 3c 01 53 00    	cmp    0x53013c(%rbx),%ebx
    15fe:	04 ab                	add    $0xab,%al
    conn_rate_stats->v1 = 1;
    1600:	0e                   	(bad)
    1601:	af                   	scas   %es:(%rdi),%eax
    1602:	0e                   	(bad)
    1603:	01 5e 00             	add    %ebx,0x0(%rsi)
    1606:	04 ab                	add    $0xab,%al
    conn_rate_stats->v2 = *cur_time;
    1608:	0e                   	(bad)
    1609:	c8 0e 01 5c          	enter  $0x10e,$0x5c
    160d:	04 ee                	add    $0xee,%al
    160f:	17                   	(bad)
    1610:	de 18                	ficomps (%rax)
    1612:	01 5c 04 a3          	add    %ebx,-0x5d(%rsp,%rax,1)
    1616:	19 b9 19 01 5c 04    	sbb    %edi,0x45c0119(%rcx)
    161c:	c5 27 bb             	(bad)
    161f:	28 01                	sub    %al,(%rcx)
    1621:	5c                   	pop    %rsp
    1622:	00 04 ab             	add    %al,(%rbx,%rbp,4)
    1625:	0e                   	(bad)
    1626:	c8 0e 02 31          	enter  $0x20e,$0x31
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    162a:	9f                   	lahf
    162b:	04 ee                	add    $0xee,%al
        if (real_pos) {
    162d:	17                   	(bad)
    162e:	de 18                	ficomps (%rax)
    1630:	02 31                	add    (%rcx),%dh
    1632:	9f                   	lahf
    1633:	04 a3                	add    $0xa3,%al
    1635:	19 b9 19 02 31 9f    	sbb    %edi,-0x60cefde7(%rcx)
          key = *real_pos;
    163b:	04 c5                	add    $0xc5,%al
    163d:	27                   	(bad)
    163e:	bb 28 02 31 9f       	mov    $0x9f310228,%ebx
          if (key == 0) {
    1643:	00 04 ab             	add    %al,(%rbx,%rbp,4)
            pckt.real_index = key;
    1646:	0e                   	(bad)
    1647:	c8 0e 12 30          	enter  $0x120e,$0x30
            dst = bpf_map_lookup_elem(&reals, &key);
    164b:	20 9f 93 04 30 20    	and    %bl,0x20300493(%rdi)
    1651:	9f                   	lahf
    1652:	93                   	xchg   %eax,%ebx
    1653:	01 30                	add    %esi,(%rax)
    1655:	9f                   	lahf
    1656:	93                   	xchg   %eax,%ebx
    1657:	01 30                	add    %esi,(%rax)
    1659:	9f                   	lahf
    165a:	93                   	xchg   %eax,%ebx
    165b:	02 04 ee             	add    (%rsi,%rbp,8),%al
    165e:	17                   	(bad)
    165f:	a0 18 12 30 20 9f 93 	movabs 0x3004939f20301218,%al
    1666:	04 30 
    1668:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
            if (!dst) {
    166e:	93                   	xchg   %eax,%ebx
    166f:	01 30                	add    %esi,(%rax)
    1671:	9f                   	lahf
    1672:	93                   	xchg   %eax,%ebx
    1673:	02 04 a0             	add    (%rax,%riz,4),%al
    1676:	18 c5                	sbb    %al,%ch
    1678:	18 10                	sbb    %dl,(%rax)
    167a:	30 20                	xor    %ah,(%rax)
    167c:	9f                   	lahf
    167d:	93                   	xchg   %eax,%ebx
    167e:	04 51                	add    $0x51,%al
    1680:	93                   	xchg   %eax,%ebx
    1681:	01 30                	add    %esi,(%rax)
    1683:	9f                   	lahf
    1684:	93                   	xchg   %eax,%ebx
    1685:	01 30                	add    %esi,(%rax)
    1687:	9f                   	lahf
    1688:	93                   	xchg   %eax,%ebx
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1689:	02 04 c5 18 cd 18 0d 	add    0xd18cd18(,%rax,8),%al
  if (dst_lru) {
    1690:	93                   	xchg   %eax,%ebx
    1691:	04 51                	add    $0x51,%al
    1693:	93                   	xchg   %eax,%ebx
    1694:	01 30                	add    %esi,(%rax)
    if (dst_lru->pos == pckt->real_index) {
    1696:	9f                   	lahf
    1697:	93                   	xchg   %eax,%ebx
    1698:	01 30                	add    %esi,(%rax)
    169a:	9f                   	lahf
    169b:	93                   	xchg   %eax,%ebx
    169c:	02 04 cd 18 de 18 0a 	add    0xa18de18(,%rcx,8),%al
              quic_packets_stats->dst_match_in_lru += 1;
    16a3:	93                   	xchg   %eax,%ebx
    16a4:	05 30 9f 93 01       	add    $0x1939f30,%eax
    16a9:	30 9f 93 02 04 a3    	xor    %bl,-0x5cfbfd6d(%rdi)
    16af:	19 b9 19 12 30 20    	sbb    %edi,0x20301219(%rcx)
    16b5:	9f                   	lahf
    16b6:	93                   	xchg   %eax,%ebx
    16b7:	04 30                	add    $0x30,%al
    16b9:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
  original_sport = pckt.flow.port16[0];
    16bf:	93                   	xchg   %eax,%ebx
    16c0:	01 30                	add    %esi,(%rax)
    16c2:	9f                   	lahf
    16c3:	93                   	xchg   %eax,%ebx
    16c4:	02 04 c5 27 e9 27 12 	add    0x1227e927(,%rax,8),%al
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    16cb:	30 20                	xor    %ah,(%rax)
        !(vip_info->flags & F_LRU_BYPASS)) {
    16cd:	9f                   	lahf
    16ce:	93                   	xchg   %eax,%ebx
    16cf:	04 30                	add    $0x30,%al
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    16d1:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    16d7:	93                   	xchg   %eax,%ebx
    16d8:	01 30                	add    %esi,(%rax)
    16da:	9f                   	lahf
    16db:	93                   	xchg   %eax,%ebx
    16dc:	02 04 e9             	add    (%rcx,%rbp,8),%al
    16df:	27                   	(bad)
    16e0:	f5                   	cmc
    16e1:	27                   	(bad)
    16e2:	10 30                	adc    %dh,(%rax)
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    16e4:	20 9f 93 04 51 93    	and    %bl,-0x6caefb6d(%rdi)
  if (!dst_lru) {
    16ea:	01 30                	add    %esi,(%rax)
    16ec:	9f                   	lahf
    16ed:	93                   	xchg   %eax,%ebx
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    16ee:	01 30                	add    %esi,(%rax)
    16f0:	9f                   	lahf
    16f1:	93                   	xchg   %eax,%ebx
    16f2:	02 04 f5 27 8a 28 0f 	add    0xf288a27(,%rsi,8),%al
    16f9:	30 20                	xor    %ah,(%rax)
    cur_time = bpf_ktime_get_ns();
    16fb:	9f                   	lahf
    16fc:	93                   	xchg   %eax,%ebx
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    16fd:	04 93                	add    $0x93,%al
    16ff:	01 30                	add    %esi,(%rax)
    1701:	9f                   	lahf
    1702:	93                   	xchg   %eax,%ebx
    1703:	01 30                	add    %esi,(%rax)
    1705:	9f                   	lahf
    1706:	93                   	xchg   %eax,%ebx
    1707:	02 04 8a             	add    (%rdx,%rcx,4),%al
    170a:	28 8e 28 0a 93 05    	sub    %cl,0x5930a28(%rsi)
    1710:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    1716:	93                   	xchg   %eax,%ebx
    1717:	02 04 8e             	add    (%rsi,%rcx,4),%al
    171a:	28 92 28 10 30 20    	sub    %dl,0x20301028(%rdx)
  key = dst_lru->pos;
    1720:	9f                   	lahf
    1721:	93                   	xchg   %eax,%ebx
    1722:	04 51                	add    $0x51,%al
    1724:	93                   	xchg   %eax,%ebx
    1725:	01 30                	add    %esi,(%rax)
    1727:	9f                   	lahf
    1728:	93                   	xchg   %eax,%ebx
  pckt->real_index = key;
    1729:	01 30                	add    %esi,(%rax)
    172b:	9f                   	lahf
  *real = bpf_map_lookup_elem(&reals, &key);
    172c:	93                   	xchg   %eax,%ebx
    172d:	02 04 92             	add    (%rdx,%rdx,4),%al
    1730:	28 a4 28 0f 30 20 9f 	sub    %ah,-0x60dfcff1(%rax,%rbp,1)
    1737:	93                   	xchg   %eax,%ebx
    1738:	04 93                	add    $0x93,%al
    173a:	01 30                	add    %esi,(%rax)
    173c:	9f                   	lahf
    173d:	93                   	xchg   %eax,%ebx
    173e:	01 30                	add    %esi,(%rax)
    1740:	9f                   	lahf
    1741:	93                   	xchg   %eax,%ebx
    1742:	02 04 a4             	add    (%rsp,%riz,4),%al
    1745:	28 ac 28 0a 93 05 30 	sub    %ch,0x3005930a(%rax,%rbp,1)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    174c:	9f                   	lahf
    174d:	93                   	xchg   %eax,%ebx
    174e:	01 30                	add    %esi,(%rax)
    1750:	9f                   	lahf
    1751:	93                   	xchg   %eax,%ebx
    1752:	02 04 ac             	add    (%rsp,%rbp,4),%al
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1755:	28 bb 28 06 93 06    	sub    %bh,0x6930628(%rbx)
    175b:	30 9f 93 02 00 04    	xor    %bl,0x4000293(%rdi)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1761:	d8 0e                	fmuls  (%rsi)
    1763:	e2 0e                	loop   1773 <balancer_ingress+0x1773>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1765:	04 10                	add    $0x10,%al
    1767:	8d 04 9f             	lea    (%rdi,%rbx,4),%eax
    176a:	04 e2                	add    $0xe2,%al
    176c:	0e                   	(bad)
    176d:	92                   	xchg   %eax,%edx
    176e:	0f 02 76 40          	lar    0x40(%rsi),%esi
    1772:	00 04 e2             	add    %al,(%rdx,%riz,8)
    1775:	0e                   	(bad)
    1776:	f9                   	stc
    1777:	0e                   	(bad)
    1778:	02 30                	add    (%rax),%dh
    177a:	9f                   	lahf
    177b:	04 f9                	add    $0xf9,%al
  if (!conn_rate_stats) {
    177d:	0e                   	(bad)
    177e:	82                   	(bad)
    177f:	0f 01 50 00          	lgdt   0x0(%rax)
    1783:	04 f9                	add    $0xf9,%al
    1785:	0e                   	(bad)
    1786:	92                   	xchg   %eax,%edx
    1787:	0f 01 50 00          	lgdt   0x0(%rax)
    178b:	04 95                	add    $0x95,%al
    178d:	0f a2                	cpuid
  *cur_time = bpf_ktime_get_ns();
    178f:	0f 03 7e 3e          	lsl    0x3e(%rsi),%edi
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1793:	9f                   	lahf
    1794:	04 a2                	add    $0xa2,%al
    1796:	0f d1 0f             	psrlw  (%rdi),%mm1
    1799:	01 53 00             	add    %edx,0x0(%rbx)
    179c:	04 da                	add    $0xda,%al
    179e:	0f f4 0f             	pmuludq (%rdi),%mm1
    conn_rate_stats->v1 = 1;
    17a1:	02 30                	add    (%rax),%dh
    17a3:	9f                   	lahf
    17a4:	04 f4                	add    $0xf4,%al
    17a6:	0f fd 0f             	paddw  (%rdi),%mm1
    conn_rate_stats->v2 = *cur_time;
    17a9:	01 50 00             	add    %edx,0x0(%rax)
    17ac:	04 9b                	add    $0x9b,%al
    conn_rate_stats->v1 += 1;
    17ae:	10 a8 10 01 52 00    	adc    %ch,0x520110(%rax)
    17b4:	04 cf                	add    $0xcf,%al
    17b6:	10 da                	adc    %bl,%dl
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    17b8:	10 04 10             	adc    %al,(%rax,%rdx,1)
    17bb:	8d 04 9f             	lea    (%rdi,%rbx,4),%eax
    17be:	04 da                	add    $0xda,%al
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    17c0:	10 8a 11 02 76 40    	adc    %cl,0x40760211(%rdx)
    17c6:	00 04 da             	add    %al,(%rdx,%rbx,8)
    17c9:	10 f1                	adc    %dh,%cl
    17cb:	10 02                	adc    %al,(%rdx)
    17cd:	30 9f 04 f1 10 fa    	xor    %bl,-0x5ef0efc(%rdi)
    17d3:	10 01                	adc    %al,(%rcx)
    17d5:	50                   	push   %rax
    17d6:	00 04 f1             	add    %al,(%rcx,%rsi,8)
    17d9:	10 8a 11 01 50 00    	adc    %cl,0x500111(%rdx)
    if (down_reals_map) {
    17df:	04 8e                	add    $0x8e,%al
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    17e1:	11 9b 11 03 7e 2a    	adc    %ebx,0x2a7e0311(%rbx)
    17e7:	9f                   	lahf
    17e8:	04 9b                	add    $0x9b,%al
      if (down_real) {
    17ea:	11 c9                	adc    %ecx,%ecx
    17ec:	11 01                	adc    %eax,(%rcx)
    17ee:	53                   	push   %rbx
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
    17ef:	00 04 f9             	add    %al,(%rcx,%rdi,8)
    17f2:	11 93 12 02 30 9f    	adc    %edx,-0x60cffdee(%rbx)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    17f8:	04 93                	add    $0x93,%al
    17fa:	12 9c 12 01 50 00 04 	adc    0x4005001(%rdx,%rdx,1),%bl
    1801:	93                   	xchg   %eax,%ebx
    1802:	12 b8 12 01 50 04    	adc    0x4500112(%rax),%bh
    1808:	b8 12 f4 12 02       	mov    $0x212f412,%eax
        if (stats_data) {
    180d:	76 50                	jbe    185f <balancer_ingress+0x185f>
    180f:	04 f4                	add    $0xf4,%al
    1811:	12 c3                	adc    %bl,%al
    1813:	14 01                	adc    $0x1,%al
    1815:	53                   	push   %rbx
          stats_data->v1 += 1;
    1816:	04 dc                	add    $0xdc,%al
    1818:	14 ff                	adc    $0xff,%al
    181a:	14 02                	adc    $0x2,%al
    181c:	76 50                	jbe    186e <balancer_ingress+0x186e>
    181e:	04 ff                	add    $0xff,%al
    if (!dst) {
    1820:	14 a0                	adc    $0xa0,%al
    1822:	15 01 50 04 a2       	adc    $0xa2045001,%eax
    1827:	15 bf 15 01 50       	adc    $0x500115bf,%eax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    182c:	04 de                	add    $0xde,%al
    182e:	18 a3 19 01 53 04    	sbb    %ah,0x4530119(%rbx)
    1834:	f8                   	clc
    1835:	26 c5 27 02          	(bad)
    1839:	76 50                	jbe    188b <balancer_ingress+0x188b>
    183b:	04 d1                	add    $0xd1,%al
    183d:	28 ab 29 02 76 50    	sub    %ch,0x50760229(%rbx)
    1843:	04 de                	add    $0xde,%al
    1845:	2a b8 2b 02 76 50    	sub    0x5076022b(%rax),%bh
    184b:	04 a3                	add    $0xa3,%al
  if (!data_stats) {
    184d:	2c ee                	sub    $0xee,%al
    184f:	2c 02                	sub    $0x2,%al
    1851:	76 50                	jbe    18a3 <balancer_ingress+0x18a3>
    1853:	04 aa                	add    $0xaa,%al
    1855:	2d bd 2d 02 76       	sub    $0x76022dbd,%eax
    185a:	50                   	push   %rax
    185b:	04 bd                	add    $0xbd,%al
    185d:	2d dd 2d 01 50       	sub    $0x50012ddd,%eax
  data_stats->v1 += 1;
    1862:	04 dd                	add    $0xdd,%al
    1864:	2d 97 2e 02 76       	sub    $0x76022e97,%eax
  data_stats->v2 += pkt_bytes;
    1869:	50                   	push   %rax
    186a:	04 97                	add    $0x97,%al
    186c:	2e 9b                	cs fwait
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    186e:	2e 01 50 04          	cs add %edx,0x4(%rax)
    1872:	9b                   	fwait
    1873:	2e ca 2e 02          	cs lret $0x22e
    1877:	76 50                	jbe    18c9 <balancer_ingress+0x18c9>
    1879:	04 ca                	add    $0xca,%al
    187b:	2e fa                	cs cli
    187d:	2e 01 50 04          	cs add %edx,0x4(%rax)
  if (!data_stats) {
    1881:	fa                   	cli
    1882:	2e ac                	lods   %ds:(%rsi),%al
    1884:	30 02                	xor    %al,(%rdx)
    1886:	76 50                	jbe    18d8 <balancer_ingress+0x18d8>
  data_stats->v1 += 1;
    1888:	04 f7                	add    $0xf7,%al
    188a:	33 9e 35 02 76 50    	xor    0x50760235(%rsi),%ebx
  data_stats->v2 += pkt_bytes;
    1890:	04 e7                	add    $0xe7,%al
    1892:	36 81 37 02 76 50 04 	ss xorl $0x4507602,(%rdi)
    1899:	81 37 8f 37 01 52    	xorl   $0x5201378f,(%rdi)
  if (dst->flags & F_IPV6) {
    189f:	04 8f                	add    $0x8f,%al
    18a1:	37                   	(bad)
    18a2:	8e 38                	mov    (%rax),%?
    18a4:	02 76 50             	add    0x50(%rsi),%dh
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    18a7:	04 8e                	add    $0x8e,%al
    18a9:	38 93 38 01 51 04    	cmp    %dl,0x4510138(%rbx)
    18af:	93                   	xchg   %eax,%ebx
    18b0:	38 c5                	cmp    %al,%ch
    18b2:	38 02                	cmp    %al,(%rdx)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    18b4:	76 50                	jbe    1906 <balancer_ingress+0x1906>
    18b6:	04 af                	add    $0xaf,%al
    18b8:	39 bd 39 02 76 50    	cmp    %edi,0x50760239(%rbp)
    18be:	04 bd                	add    $0xbd,%al
    18c0:	39 bf 39 01 52 04    	cmp    %edi,0x4520139(%rdi)
  data = (void*)(long)xdp->data;
    18c6:	bf 39 f7 3a 02       	mov    $0x23af739,%edi
  data_end = (void*)(long)xdp->data_end;
    18cb:	76 50                	jbe    191d <balancer_ingress+0x191d>
  iph = data + sizeof(struct ethhdr);
    18cd:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    18d0:	12 c2                	adc    %dl,%al
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    18d2:	12 04 10             	adc    (%rax,%rdx,1),%al
    18d5:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    18d9:	c2 12 ff             	ret    $0xff12
    18dc:	14 03                	adc    $0x3,%al
    18de:	76 cc                	jbe    18ac <balancer_ingress+0x18ac>
    18e0:	7e 04                	jle    18e6 <balancer_ingress+0x18e6>
    18e2:	de 18                	ficomps (%rax)
    18e4:	a3 19 03 76 cc 7e 04 	movabs %eax,0x26f8047ecc760319
    18eb:	f8 26 
    18ed:	c5 27 03             	(bad)
    18f0:	76 cc                	jbe    18be <balancer_ingress+0x18be>
    18f2:	7e 04                	jle    18f8 <balancer_ingress+0x18f8>
    18f4:	d1 28                	shrl   (%rax)
    18f6:	ab                   	stos   %eax,%es:(%rdi)
    18f7:	29 03                	sub    %eax,(%rbx)
    18f9:	76 cc                	jbe    18c7 <balancer_ingress+0x18c7>
    18fb:	7e 04                	jle    1901 <balancer_ingress+0x1901>
    18fd:	de 2a                	fisubrs (%rdx)
    18ff:	b8 2b 03 76 cc       	mov    $0xcc76032b,%eax
    1904:	7e 04                	jle    190a <balancer_ingress+0x190a>
    1906:	a3 2c fa 32 03 76 cc 	movabs %eax,0x47ecc760332fa2c
    190d:	7e 04 
  memcpy(new_eth->h_dest, cval->mac, 6);
    190f:	f7 33                	divl   (%rbx)
    1911:	b9 36 03 76 cc       	mov    $0xcc760336,%ecx
    1916:	7e 04                	jle    191c <balancer_ingress+0x191c>
    1918:	e7 36                	out    %eax,$0x36
    191a:	c5 38 03             	(bad)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    191d:	76 cc                	jbe    18eb <balancer_ingress+0x18eb>
    191f:	7e 04                	jle    1925 <balancer_ingress+0x1925>
    1921:	af                   	scas   %es:(%rdi),%eax
    1922:	39 88 3b 03 76 cc    	cmp    %ecx,-0x3389fcc5(%rax)
    1928:	7e 04                	jle    192e <balancer_ingress+0x192e>
  new_eth->h_proto = BE_ETH_P_IP;
    192a:	9b                   	fwait
    192b:	3c f3                	cmp    $0xf3,%al
    192d:	3d 03 76 cc 7e       	cmp    $0x7ecc7603,%eax
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1932:	00 04 c2             	add    %al,(%rdx,%rax,8)
    1935:	12 dc                	adc    %ah,%bl
    1937:	12 02                	adc    (%rdx),%al
  iph->ihl = 5;
    1939:	30 9f 04 dc 12 e5    	xor    %bl,-0x1aed23fc(%rdi)
  iph->tos = tos;
    193f:	12 01                	adc    (%rcx),%al
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1941:	50                   	push   %rax
    1942:	00 04 dc             	add    %al,(%rsp,%rbx,8)
    1945:	12 ec                	adc    %ah,%ch
    1947:	12 01                	adc    (%rcx),%al
    1949:	50                   	push   %rax
    194a:	04 ec                	add    $0xec,%al
    194c:	12 f9                	adc    %cl,%bh
  iph->id = 0;
    194e:	12 03                	adc    (%rbx),%al
    1950:	76 c0                	jbe    1912 <balancer_ingress+0x1912>
    1952:	7e 04                	jle    1958 <balancer_ingress+0x1958>
    1954:	f9                   	stc
  iph->daddr = daddr;
    1955:	12 82 13 01 50 04    	adc    0x4500113(%rdx),%al
  iph->ttl = DEFAULT_TTL;
    195b:	82                   	(bad)
    195c:	13 ff                	adc    %edi,%edi
    195e:	14 03                	adc    $0x3,%al
    1960:	76 c0                	jbe    1922 <balancer_ingress+0x1922>
    1962:	7e 04                	jle    1968 <balancer_ingress+0x1968>
    1964:	de 18                	ficomps (%rax)
    1966:	a3 19 03 76 c0 7e 04 	movabs %eax,0x26f8047ec0760319
    196d:	f8 26 
    196f:	c5 27 03             	(bad)
    1972:	76 c0                	jbe    1934 <balancer_ingress+0x1934>
    1974:	7e 04                	jle    197a <balancer_ingress+0x197a>
    1976:	d1 28                	shrl   (%rax)
    1978:	ab                   	stos   %eax,%es:(%rdi)
    1979:	29 03                	sub    %eax,(%rbx)
    197b:	76 c0                	jbe    193d <balancer_ingress+0x193d>
    197d:	7e 04                	jle    1983 <balancer_ingress+0x1983>
    197f:	de 2a                	fisubrs (%rdx)
    1981:	b8 2b 03 76 c0       	mov    $0xc076032b,%eax
    1986:	7e 04                	jle    198c <balancer_ingress+0x198c>
    1988:	a3 2c c7 30 03 76 c0 	movabs %eax,0x47ec0760330c72c
    198f:	7e 04 
    1991:	c7                   	(bad)
    1992:	30 95 31 01 50 04    	xor    %dl,0x4500131(%rbp)
    1998:	f7 33                	divl   (%rbx)
    199a:	9e                   	sahf
    199b:	35 03 76 c0 7e       	xor    $0x7ec07603,%eax
    19a0:	04 e7                	add    $0xe7,%al
    19a2:	36 c5 38 03          	(bad)
    19a6:	76 c0                	jbe    1968 <balancer_ingress+0x1968>
    19a8:	7e 04                	jle    19ae <balancer_ingress+0x19ae>
    19aa:	af                   	scas   %es:(%rdi),%eax
    19ab:	39 fe                	cmp    %edi,%esi
    19ad:	3a 03                	cmp    (%rbx),%al
    19af:	76 c0                	jbe    1971 <balancer_ingress+0x1971>
    19b1:	7e 04                	jle    19b7 <balancer_ingress+0x19b7>
    19b3:	fe                   	(bad)
    19b4:	3a 88 3b 01 50 04    	cmp    0x450013b(%rax),%cl
    19ba:	9b                   	fwait
    19bb:	3c f3                	cmp    $0xf3,%al
    19bd:	3d 03 76 c0 7e       	cmp    $0x7ec07603,%eax
    19c2:	00 04 82             	add    %al,(%rdx,%rax,4)
    19c5:	13 88 13 01 50 04    	adc    0x4500113(%rax),%ecx
    19cb:	88 13                	mov    %dl,(%rbx)
    19cd:	ff 14 03             	call   *(%rbx,%rax,1)
    19d0:	76 fc                	jbe    19ce <balancer_ingress+0x19ce>
    19d2:	7e 04                	jle    19d8 <balancer_ingress+0x19d8>
    19d4:	de 18                	ficomps (%rax)
    19d6:	a3 19 03 76 fc 7e 04 	movabs %eax,0x26f8047efc760319
    19dd:	f8 26 
    19df:	99                   	cltd
    19e0:	27                   	(bad)
    19e1:	03 76 fc             	add    -0x4(%rsi),%esi
    19e4:	7e 04                	jle    19ea <balancer_ingress+0x19ea>
    19e6:	99                   	cltd
    19e7:	27                   	(bad)
    19e8:	b1 27                	mov    $0x27,%cl
    19ea:	01 50 04             	add    %edx,0x4(%rax)
    19ed:	b1 27                	mov    $0x27,%cl
    19ef:	c5 27 03             	(bad)
    19f2:	76 fc                	jbe    19f0 <balancer_ingress+0x19f0>
    19f4:	7e 04                	jle    19fa <balancer_ingress+0x19fa>
    19f6:	d1 28                	shrl   (%rax)
      if (pckt.flow.proto == IPPROTO_TCP) {
    19f8:	ab                   	stos   %eax,%es:(%rdi)
    19f9:	29 03                	sub    %eax,(%rbx)
    19fb:	76 fc                	jbe    19f9 <balancer_ingress+0x19f9>
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
    19fd:	7e 04                	jle    1a03 <balancer_ingress+0x1a03>
    19ff:	de 2a                	fisubrs (%rdx)
    1a01:	b8 2b 03 76 fc       	mov    $0xfc76032b,%eax
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1a06:	7e 04                	jle    1a0c <balancer_ingress+0x1a0c>
    1a08:	a3 2c c7 2d 03 76 fc 	movabs %eax,0x47efc76032dc72c
    1a0f:	7e 04 
    1a11:	ac                   	lods   %ds:(%rsi),%al
    1a12:	30 fa                	xor    %bh,%dl
    1a14:	32 03                	xor    (%rbx),%al
    1a16:	76 d4                	jbe    19ec <balancer_ingress+0x19ec>
    1a18:	7e 04                	jle    1a1e <balancer_ingress+0x1a1e>
    1a1a:	9e                   	sahf
        if (!lru_stats) {
    1a1b:	35 b9 36 03 76       	xor    $0x760336b9,%eax
    1a20:	d4                   	(bad)
    1a21:	7e 04                	jle    1a27 <balancer_ingress+0x1a27>
    1a23:	9b                   	fwait
        if (pckt.flags & F_SYN_SET) {
    1a24:	3c f2                	cmp    $0xf2,%al
    1a26:	3c 03                	cmp    $0x3,%al
    1a28:	76 fc                	jbe    1a26 <balancer_ingress+0x1a26>
    1a2a:	7e 04                	jle    1a30 <balancer_ingress+0x1a30>
    1a2c:	f2 3c 8a             	repnz cmp $0x8a,%al
    1a2f:	3d 01 50 04 98       	cmp    $0x98045001,%eax
  struct real_pos_lru new_dst_lru = {};
    1a34:	3d df 3d 03 76       	cmp    $0x76033ddf,%eax
    1a39:	fc                   	cld
    1a3a:	7e 00                	jle    1a3c <balancer_ingress+0x1a3c>
    1a3c:	04 97                	add    $0x97,%al
    1a3e:	13 9d 13 01 50 04    	adc    0x4500113(%rbp),%ebx
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1a44:	9d                   	popf
    1a45:	13 ff                	adc    %edi,%edi
    1a47:	14 03                	adc    $0x3,%al
    1a49:	76 d0                	jbe    1a1b <balancer_ingress+0x1a1b>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1a4b:	7e 04                	jle    1a51 <balancer_ingress+0x1a51>
    1a4d:	de 18                	ficomps (%rax)
    1a4f:	a3 19 03 76 d0 7e 04 	movabs %eax,0x26f8047ed0760319
    1a56:	f8 26 
    1a58:	c5 27 03             	(bad)
    1a5b:	76 d0                	jbe    1a2d <balancer_ingress+0x1a2d>
    1a5d:	7e 04                	jle    1a63 <balancer_ingress+0x1a63>
    1a5f:	d1 28                	shrl   (%rax)
    1a61:	ab                   	stos   %eax,%es:(%rdi)
    1a62:	29 03                	sub    %eax,(%rbx)
    1a64:	76 d0                	jbe    1a36 <balancer_ingress+0x1a36>
  if (!conn_rate_stats) {
    1a66:	7e 04                	jle    1a6c <balancer_ingress+0x1a6c>
    1a68:	de 2a                	fisubrs (%rdx)
    1a6a:	b8 2b 03 76 d0       	mov    $0xd076032b,%eax
    1a6f:	7e 04                	jle    1a75 <balancer_ingress+0x1a75>
    1a71:	a3 2c fa 32 03 76 d0 	movabs %eax,0x47ed0760332fa2c
    1a78:	7e 04 
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1a7a:	f7 33                	divl   (%rbx)
    1a7c:	b9 36 03 76 d0       	mov    $0xd0760336,%ecx
    1a81:	7e 04                	jle    1a87 <balancer_ingress+0x1a87>
    1a83:	e7 36                	out    %eax,$0x36
    1a85:	c5 38 03             	(bad)
    1a88:	76 d0                	jbe    1a5a <balancer_ingress+0x1a5a>
    1a8a:	7e 04                	jle    1a90 <balancer_ingress+0x1a90>
    1a8c:	af                   	scas   %es:(%rdi),%eax
    1a8d:	39 88 3b 03 76 d0    	cmp    %ecx,-0x2f89fcc5(%rax)
    conn_rate_stats->v1 = 1;
    1a93:	7e 04                	jle    1a99 <balancer_ingress+0x1a99>
    conn_rate_stats->v2 = *cur_time;
    1a95:	9b                   	fwait
    1a96:	3c f3                	cmp    $0xf3,%al
    1a98:	3d 03 76 d0 7e       	cmp    $0x7ed07603,%eax
    1a9d:	00 04 9d 13 b7 13 02 	add    %al,0x213b713(,%rbx,4)
    1aa4:	30 9f 04 b7 13 be    	xor    %bl,-0x41ec48fc(%rdi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1aaa:	13 01                	adc    (%rcx),%eax
    1aac:	50                   	push   %rax
    1aad:	04 be                	add    $0xbe,%al
    1aaf:	13 c3                	adc    %ebx,%eax
    1ab1:	13 03                	adc    (%rbx),%eax
    1ab3:	76 f0                	jbe    1aa5 <balancer_ingress+0x1aa5>
    1ab5:	7e 00                	jle    1ab7 <balancer_ingress+0x1ab7>
  data = (void*)(long)xdp->data;
    1ab7:	04 b7                	add    $0xb7,%al
    1ab9:	13 be 13 01 50 04    	adc    0x4500113(%rsi),%edi
  ip6h = data + sizeof(struct ethhdr);
    1abf:	be 13 c3 13 03       	mov    $0x313c313,%esi
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1ac4:	76 f0                	jbe    1ab6 <balancer_ingress+0x1ab6>
    1ac6:	7e 04                	jle    1acc <balancer_ingress+0x1acc>
    1ac8:	c3                   	ret
    1ac9:	13 df                	adc    %edi,%ebx
    1acb:	13 01                	adc    (%rcx),%eax
    1acd:	50                   	push   %rax
    1ace:	04 df                	add    $0xdf,%al
    1ad0:	13 e4                	adc    %esp,%esp
    1ad2:	13 03                	adc    (%rbx),%eax
    1ad4:	76 f0                	jbe    1ac6 <balancer_ingress+0x1ac6>
    1ad6:	7e 04                	jle    1adc <balancer_ingress+0x1adc>
    1ad8:	83 14 ff 14          	adcl   $0x14,(%rdi,%rdi,8)
    1adc:	03 76 f0             	add    -0x10(%rsi),%esi
    1adf:	7e 04                	jle    1ae5 <balancer_ingress+0x1ae5>
    1ae1:	de 18                	ficomps (%rax)
  memcpy(new_eth->h_dest, cval->mac, 6);
    1ae3:	a3 19 03 76 f0 7e 04 	movabs %eax,0x26f8047ef0760319
    1aea:	f8 26 
    1aec:	c5 27 03             	(bad)
    1aef:	76 f0                	jbe    1ae1 <balancer_ingress+0x1ae1>
    1af1:	7e 04                	jle    1af7 <balancer_ingress+0x1af7>
    1af3:	d1 28                	shrl   (%rax)
    1af5:	ab                   	stos   %eax,%es:(%rdi)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1af6:	29 03                	sub    %eax,(%rbx)
    1af8:	76 f0                	jbe    1aea <balancer_ingress+0x1aea>
    1afa:	7e 04                	jle    1b00 <balancer_ingress+0x1b00>
    1afc:	de 2a                	fisubrs (%rdx)
    1afe:	b8 2b 03 76 f0       	mov    $0xf076032b,%eax
    1b03:	7e 04                	jle    1b09 <balancer_ingress+0x1b09>
  new_eth->h_proto = BE_ETH_P_IPV6;
    1b05:	a3 2c 89 2d 03 76 f0 	movabs %eax,0x47ef076032d892c
    1b0c:	7e 04 
  saddr[3] = src ^ port;
    1b0e:	89 2d 8c 2d 01 55    	mov    %ebp,0x55012d8c(%rip)        # 550148a0 <_license+0x550129ad>
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1b14:	04 8c                	add    $0x8c,%al
    1b16:	2d e4 2d 03 76       	sub    $0x76032de4,%eax
  ip6h->priority = (tc & 0xF0) >> 4;
    1b1b:	f0 7e 04             	lock jle 1b22 <balancer_ingress+0x1b22>
    1b1e:	e4 2d                	in     $0x2d,%al
    1b20:	e6 2d                	out    %al,$0x2d
    1b22:	01 55 04             	add    %edx,0x4(%rbp)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1b25:	e6 2d                	out    %al,$0x2d
    1b27:	fa                   	cli
    1b28:	32 03                	xor    (%rbx),%al
    1b2a:	76 f0                	jbe    1b1c <balancer_ingress+0x1b1c>
  ip6h->nexthdr = proto;
    1b2c:	7e 04                	jle    1b32 <balancer_ingress+0x1b32>
    1b2e:	f7 33                	divl   (%rbx)
    1b30:	b9 36 03 76 f0       	mov    $0xf0760336,%ecx
  ip6h->payload_len = bpf_htons(payload_len);
    1b35:	7e 04                	jle    1b3b <balancer_ingress+0x1b3b>
    1b37:	e7 36                	out    %eax,$0x36
    1b39:	c5 38 03             	(bad)
    1b3c:	76 f0                	jbe    1b2e <balancer_ingress+0x1b2e>
    1b3e:	7e 04                	jle    1b44 <balancer_ingress+0x1b44>
    1b40:	af                   	scas   %es:(%rdi),%eax
    1b41:	39 f1                	cmp    %esi,%ecx
    1b43:	39 03                	cmp    %eax,(%rbx)
    1b45:	76 f0                	jbe    1b37 <balancer_ingress+0x1b37>
    1b47:	7e 04                	jle    1b4d <balancer_ingress+0x1b4d>
    1b49:	f1                   	int1
    1b4a:	39 f5                	cmp    %esi,%ebp
    1b4c:	39 01                	cmp    %eax,(%rcx)
    1b4e:	55                   	push   %rbp
    1b4f:	04 f5                	add    $0xf5,%al
    1b51:	39 88 3b 03 76 f0    	cmp    %ecx,-0xf89fcc5(%rax)
    1b57:	7e 04                	jle    1b5d <balancer_ingress+0x1b5d>
    1b59:	9b                   	fwait
    1b5a:	3c d6                	cmp    $0xd6,%al
    1b5c:	3d 03 76 f0 7e       	cmp    $0x7ef07603,%eax
    1b61:	04 d6                	add    $0xd6,%al
    1b63:	3d da 3d 01 55       	cmp    $0x55013dda,%eax
    conn_rate_stats->v1 += 1;
    1b68:	04 da                	add    $0xda,%al
    1b6a:	3d f3 3d 03 76       	cmp    $0x76033df3,%eax
    1b6f:	f0 7e 00             	lock jle 1b72 <balancer_ingress+0x1b72>
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1b72:	04 c3                	add    $0xc3,%al
    1b74:	13 ca                	adc    %edx,%ecx
    1b76:	13 04 10             	adc    (%rax,%rdx,1),%eax
    1b79:	83 04 9f 04          	addl   $0x4,(%rdi,%rbx,4)
    1b7d:	ca 13 83             	lret   $0x8313
    1b80:	14 02                	adc    $0x2,%al
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1b82:	76 40                	jbe    1bc4 <balancer_ingress+0x1bc4>
    1b84:	00 04 ca             	add    %al,(%rdx,%rcx,8)
    1b87:	13 e1                	adc    %ecx,%esp
    1b89:	13 02                	adc    (%rdx),%eax
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1b8b:	30 9f 04 e1 13 ea    	xor    %bl,-0x15ec1efc(%rdi)
    1b91:	13 01                	adc    (%rcx),%eax
      memset(pckt->flow.srcv6, 0, 16);
    1b93:	50                   	push   %rax
    1b94:	00 04 e1             	add    %al,(%rcx,%riz,8)
    1b97:	13 f8                	adc    %eax,%edi
    1b99:	13 01                	adc    (%rcx),%eax
    1b9b:	50                   	push   %rax
    1b9c:	00 04 99             	add    %al,(%rcx,%rbx,4)
    1b9f:	14 a0                	adc    $0xa0,%al
    1ba1:	14 02                	adc    $0x2,%al
    1ba3:	30 9f 04 a0 14 ff    	xor    %bl,-0xeb5ffc(%rdi)
    1ba9:	14 03                	adc    $0x3,%al
  b += initval;
    1bab:	76 b8                	jbe    1b65 <balancer_ingress+0x1b65>
  a += initval;
    1bad:	7f 04                	jg     1bb3 <balancer_ingress+0x1bb3>
    1baf:	f8                   	clc
    1bb0:	26 c5 27 03          	(bad)
  __jhash_final(a, b, c);
    1bb4:	76 b8                	jbe    1b6e <balancer_ingress+0x1b6e>
    1bb6:	7f 04                	jg     1bbc <balancer_ingress+0x1bbc>
    1bb8:	d1 28                	shrl   (%rax)
    1bba:	ab                   	stos   %eax,%es:(%rdi)
  return (word << shift) | (word >> ((-shift) & 31));
    1bbb:	29 03                	sub    %eax,(%rbx)
    1bbd:	76 b8                	jbe    1b77 <balancer_ingress+0x1b77>
    1bbf:	7f 04                	jg     1bc5 <balancer_ingress+0x1bc5>
  __jhash_final(a, b, c);
    1bc1:	de 2a                	fisubrs (%rdx)
    1bc3:	b8 2b 03 76 b8       	mov    $0xb876032b,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1bc8:	7f 04                	jg     1bce <balancer_ingress+0x1bce>
  __jhash_final(a, b, c);
    1bca:	a3 2c b9 2d 03 76 b8 	movabs %eax,0x47fb876032db92c
    1bd1:	7f 04 
    1bd3:	9b                   	fwait
    1bd4:	3c f3                	cmp    $0xf3,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1bd6:	3d 03 76 b8 7f       	cmp    $0x7fb87603,%eax
  __jhash_final(a, b, c);
    1bdb:	00 04 a0             	add    %al,(%rax,%riz,4)
    1bde:	14 b7                	adc    $0xb7,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1be0:	14 02                	adc    $0x2,%al
    1be2:	30 9f 04 b7 14 c0    	xor    %bl,-0x3feb48fc(%rdi)
    1be8:	14 01                	adc    $0x1,%al
    1bea:	50                   	push   %rax
  __jhash_final(a, b, c);
    1beb:	00 04 b7             	add    %al,(%rdi,%rsi,4)
    1bee:	14 c3                	adc    $0xc3,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1bf0:	14 01                	adc    $0x1,%al
  __jhash_final(a, b, c);
    1bf2:	50                   	push   %rax
    1bf3:	04 c3                	add    $0xc3,%al
    1bf5:	14 ff                	adc    $0xff,%al
    1bf7:	14 01                	adc    $0x1,%al
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1bf9:	53                   	push   %rbx
    1bfa:	04 f8                	add    $0xf8,%al
    1bfc:	26 c5 27 01          	(bad)
    1c00:	53                   	push   %rbx
    1c01:	04 d1                	add    $0xd1,%al
    1c03:	28 ab 29 01 53 04    	sub    %ch,0x4530129(%rbx)
    1c09:	de 2a                	fisubrs (%rdx)
    1c0b:	b8 2b 01 53 04       	mov    $0x453012b,%eax
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1c10:	a3 2c b9 2d 01 53 04 	movabs %eax,0x3c9b0453012db92c
    1c17:	9b 3c 
    1c19:	f3 3d 01 53 00 04    	repz cmp $0x4005301,%eax
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1c1f:	c3                   	ret
    if (!real_pos) {
    1c20:	14 c7                	adc    $0xc7,%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1c22:	14 01                	adc    $0x1,%al
    1c24:	5e                   	pop    %rsi
    1c25:	00 04 c3             	add    %al,(%rbx,%rax,8)
    1c28:	14 ff                	adc    $0xff,%al
    1c2a:	14 01                	adc    $0x1,%al
    1c2c:	5c                   	pop    %rsp
    1c2d:	04 f8                	add    $0xf8,%al
    key = *real_pos;
    1c2f:	26 8e 27             	es mov (%rdi),%fs
    1c32:	01 5c 04 d1          	add    %ebx,-0x2f(%rsp,%rax,1)
    1c36:	28 ab 29 01 5c 04    	sub    %ch,0x45c0129(%rbx)
  pckt->real_index = key;
    1c3c:	de 2a                	fisubrs (%rdx)
  *real = bpf_map_lookup_elem(&reals, &key);
    1c3e:	a9 2b 01 5c 00       	test   $0x5c012b,%eax
  if (!(*real)) {
    1c43:	04 c3                	add    $0xc3,%al
    1c45:	14 ff                	adc    $0xff,%al
    1c47:	14 02                	adc    $0x2,%al
    1c49:	30 9f 04 f8 26 8e    	xor    %bl,-0x71d907fc(%rdi)
    1c4f:	27                   	(bad)
    1c50:	02 30                	add    (%rax),%dh
    1c52:	9f                   	lahf
    1c53:	04 d1                	add    $0xd1,%al
    1c55:	28 ab 29 02 30 9f    	sub    %ch,-0x60cffdd7(%rbx)
    1c5b:	04 de                	add    $0xde,%al
    1c5d:	2a a9 2b 02 30 9f    	sub    -0x60cffdd5(%rcx),%ch
    1c63:	00 04 c3             	add    %al,(%rbx,%rax,8)
    1c66:	14 ff                	adc    $0xff,%al
    1c68:	14 12                	adc    $0x12,%al
    1c6a:	30 20                	xor    %ah,(%rax)
    1c6c:	9f                   	lahf
    1c6d:	93                   	xchg   %eax,%ebx
    1c6e:	04 30                	add    $0x30,%al
    1c70:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    1c76:	93                   	xchg   %eax,%ebx
    1c77:	01 30                	add    %esi,(%rax)
    1c79:	9f                   	lahf
    1c7a:	93                   	xchg   %eax,%ebx
    1c7b:	02 04 f8             	add    (%rax,%rdi,8),%al
    1c7e:	26 8e 27             	es mov (%rdi),%fs
    1c81:	12 30                	adc    (%rax),%dh
    1c83:	20 9f 93 04 30 20    	and    %bl,0x20300493(%rdi)
    1c89:	9f                   	lahf
    1c8a:	93                   	xchg   %eax,%ebx
    1c8b:	01 30                	add    %esi,(%rax)
    1c8d:	9f                   	lahf
    1c8e:	93                   	xchg   %eax,%ebx
    1c8f:	01 30                	add    %esi,(%rax)
    1c91:	9f                   	lahf
    1c92:	93                   	xchg   %eax,%ebx
    1c93:	02 04 d1             	add    (%rcx,%rdx,8),%al
    1c96:	28 f4                	sub    %dh,%ah
    1c98:	28 12                	sub    %dl,(%rdx)
    1c9a:	30 20                	xor    %ah,(%rax)
}
    1c9c:	9f                   	lahf
    1c9d:	93                   	xchg   %eax,%ebx
    1c9e:	04 30                	add    $0x30,%al
    1ca0:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    1ca6:	93                   	xchg   %eax,%ebx
    1ca7:	01 30                	add    %esi,(%rax)
    1ca9:	9f                   	lahf
    1caa:	93                   	xchg   %eax,%ebx
    1cab:	02 04 f4             	add    (%rsp,%rsi,8),%al
    1cae:	28 92 29 10 30 20    	sub    %dl,0x20301029(%rdx)
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1cb4:	9f                   	lahf
    1cb5:	93                   	xchg   %eax,%ebx
    1cb6:	04 51                	add    $0x51,%al
    1cb8:	93                   	xchg   %eax,%ebx
    1cb9:	01 30                	add    %esi,(%rax)
    1cbb:	9f                   	lahf
    1cbc:	93                   	xchg   %eax,%ebx
    1cbd:	01 30                	add    %esi,(%rax)
    1cbf:	9f                   	lahf
    1cc0:	93                   	xchg   %eax,%ebx
    1cc1:	02 04 92             	add    (%rdx,%rdx,4),%al
    1cc4:	29 9a 29 0d 93 04    	sub    %ebx,0x4930d29(%rdx)
    1cca:	51                   	push   %rcx
    1ccb:	93                   	xchg   %eax,%ebx
    1ccc:	01 30                	add    %esi,(%rax)
    if (pckt->flow.proto == IPPROTO_UDP) {
    1cce:	9f                   	lahf
    1ccf:	93                   	xchg   %eax,%ebx
    1cd0:	01 30                	add    %esi,(%rax)
    1cd2:	9f                   	lahf
    1cd3:	93                   	xchg   %eax,%ebx
      new_dst_lru.atime = cur_time;
    1cd4:	02 04 9a             	add    (%rdx,%rbx,4),%al
    1cd7:	29 ab 29 0a 93 05    	sub    %ebp,0x5930a29(%rbx)
    new_dst_lru.pos = key;
    1cdd:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    1ce3:	93                   	xchg   %eax,%ebx
    1ce4:	02 04 de             	add    (%rsi,%rbx,8),%al
    1ce7:	2a ea                	sub    %dl,%ch
    1ce9:	2a 10                	sub    (%rax),%dl
    1ceb:	30 20                	xor    %ah,(%rax)
    1ced:	9f                   	lahf
    1cee:	93                   	xchg   %eax,%ebx
    1cef:	04 51                	add    $0x51,%al
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1cf1:	93                   	xchg   %eax,%ebx
    1cf2:	01 30                	add    %esi,(%rax)
    1cf4:	9f                   	lahf
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    1cf5:	93                   	xchg   %eax,%ebx
    1cf6:	01 30                	add    %esi,(%rax)
    1cf8:	9f                   	lahf
    1cf9:	93                   	xchg   %eax,%ebx
    1cfa:	02 04 ea             	add    (%rdx,%rbp,8),%al
    1cfd:	2a ff                	sub    %bh,%bh
    1cff:	2a 0f                	sub    (%rdi),%cl
    1d01:	30 20                	xor    %ah,(%rax)
    1d03:	9f                   	lahf
    1d04:	93                   	xchg   %eax,%ebx
    1d05:	04 93                	add    $0x93,%al
    1d07:	01 30                	add    %esi,(%rax)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1d09:	9f                   	lahf
    1d0a:	93                   	xchg   %eax,%ebx
    1d0b:	01 30                	add    %esi,(%rax)
    1d0d:	9f                   	lahf
    1d0e:	93                   	xchg   %eax,%ebx
    1d0f:	02 04 ff             	add    (%rdi,%rdi,8),%al
    1d12:	2a 83 2b 0a 93 05    	sub    0x5930a2b(%rbx),%al
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1d18:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    1d1e:	93                   	xchg   %eax,%ebx
    1d1f:	02 04 83             	add    (%rbx,%rax,4),%al
    1d22:	2b 87 2b 10 30 20    	sub    0x2030102b(%rdi),%eax
    1d28:	9f                   	lahf
  bool vip_match = address_match && port_match && proto_match;
    1d29:	93                   	xchg   %eax,%ebx
    1d2a:	04 51                	add    $0x51,%al
    1d2c:	93                   	xchg   %eax,%ebx
    1d2d:	01 30                	add    %esi,(%rax)
    1d2f:	9f                   	lahf
    1d30:	93                   	xchg   %eax,%ebx
    1d31:	01 30                	add    %esi,(%rax)
    1d33:	9f                   	lahf
    __u32 lru_stats_key = pckt->real_index;
    1d34:	93                   	xchg   %eax,%ebx
    1d35:	02 04 87             	add    (%rdi,%rax,4),%al
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1d38:	2b 99 2b 0f 30 20    	sub    0x20300f2b(%rcx),%ebx
    1d3e:	9f                   	lahf
    1d3f:	93                   	xchg   %eax,%ebx
    1d40:	04 93                	add    $0x93,%al
    1d42:	01 30                	add    %esi,(%rax)
    1d44:	9f                   	lahf
    1d45:	93                   	xchg   %eax,%ebx
    1d46:	01 30                	add    %esi,(%rax)
    1d48:	9f                   	lahf
    1d49:	93                   	xchg   %eax,%ebx
    1d4a:	02 04 99             	add    (%rcx,%rbx,4),%al
    1d4d:	2b a1 2b 0a 93 05    	sub    0x5930a2b(%rcx),%esp
    if (!lru_miss_stat) {
    1d53:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    *lru_miss_stat += 1;
    1d59:	93                   	xchg   %eax,%ebx
    1d5a:	02 04 a1             	add    (%rcx,%riz,4),%al
    1d5d:	2b a9 2b 06 93 06    	sub    0x693062b(%rcx),%ebp
    1d63:	30 9f 93 02 00 04    	xor    %bl,0x4000293(%rdi)
    1d69:	e0 14                	loopne 1d7f <balancer_ingress+0x1d7f>
    1d6b:	f1                   	int1
    1d6c:	14 01                	adc    $0x1,%al
    1d6e:	5e                   	pop    %rsi
    1d6f:	04 f8                	add    $0xf8,%al
    1d71:	26 8e 27             	es mov (%rdi),%fs
    1d74:	01 5e 04             	add    %ebx,0x4(%rsi)
    1d77:	d1 28                	shrl   (%rax)
    1d79:	e0 28                	loopne 1da3 <balancer_ingress+0x1da3>
    1d7b:	01 5e 00             	add    %ebx,0x0(%rsi)
      data_stats->v2 += 1;
    1d7e:	04 e0                	add    $0xe0,%al
    1d80:	14 f1                	adc    $0xf1,%al
    1d82:	14 01                	adc    $0x1,%al
    1d84:	5e                   	pop    %rsi
    1d85:	04 f8                	add    $0xf8,%al
    1d87:	26 8e 27             	es mov (%rdi),%fs
    1d8a:	01 5e 04             	add    %ebx,0x4(%rsi)
    1d8d:	d1 28                	shrl   (%rax)
    1d8f:	e0 28                	loopne 1db9 <balancer_ingress+0x1db9>
    1d91:	01 5e 00             	add    %ebx,0x0(%rsi)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1d94:	04 e0                	add    $0xe0,%al
    1d96:	14 ff                	adc    $0xff,%al
    1d98:	14 02                	adc    $0x2,%al
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    1d9a:	30 9f 04 f8 26 8e    	xor    %bl,-0x71d907fc(%rdi)
    1da0:	27                   	(bad)
    1da1:	02 30                	add    (%rax),%dh
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1da3:	9f                   	lahf
    1da4:	04 d1                	add    $0xd1,%al
    1da6:	28 d6                	sub    %dl,%dh
    1da8:	28 02                	sub    %al,(%rdx)
    1daa:	30 9f 04 e3 28 a1    	xor    %bl,-0x5ed71cfc(%rdi)
    1db0:	29 01                	sub    %eax,(%rcx)
    1db2:	50                   	push   %rax
    1db3:	04 de                	add    $0xde,%al
    1db5:	2a ff                	sub    %bh,%bh
    1db7:	2a 01                	sub    (%rcx),%al
  if (!per_vip_stats) {
    1db9:	50                   	push   %rax
    1dba:	04 83                	add    $0x83,%al
    1dbc:	2b 99 2b 01 50 00    	sub    0x50012b(%rcx),%ebx
    per_vip_stats->v2 += 1;
    1dc2:	04 88                	add    $0x88,%al
    1dc4:	15 a2 15 02 30       	adc    $0x300215a2,%eax
    conn_rate_stats->v1 += 1;
    1dc9:	9f                   	lahf
    1dca:	04 a2                	add    $0xa2,%al
    1dcc:	15 ab 15 01 50       	adc    $0x500115ab,%eax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1dd1:	00 04 bf             	add    %al,(%rdi,%rdi,4)
    1dd4:	15 c8 15 04 10       	adc    $0x100415c8,%eax
  struct real_pos_lru new_dst_lru = {};
    1dd9:	8c 04 9f             	mov    %es,(%rdi,%rbx,4)
    1ddc:	04 c8                	add    $0xc8,%al
    1dde:	15 ff 15 02 76       	adc    $0x760215ff,%eax
    1de3:	40 00 04 c8          	rex add %al,(%rax,%rcx,8)
  new_dst_lru.pos = pckt->real_index;
    1de7:	15 df 15 02 30       	adc    $0x300215df,%eax
    1dec:	9f                   	lahf
    1ded:	04 df                	add    $0xdf,%al
    1def:	15 e8 15 01 50       	adc    $0x500115e8,%eax
    1df4:	00 04 df             	add    %al,(%rdi,%rbx,8)
    1df7:	15 ff 15 01 50       	adc    $0x500115ff,%eax
    1dfc:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    1dff:	15 ff 15 01 52       	adc    $0x520115ff,%eax
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1e04:	00 04 81             	add    %al,(%rcx,%rax,4)
              quic_packets_stats->dst_not_found_in_lru += 1;
    1e07:	16                   	(bad)
    1e08:	c5 16 03             	(bad)
    1e0b:	7e 2a                	jle    1e37 <balancer_ingress+0x1e37>
            quic_packets_stats->cid_routed += 1;
    1e0d:	9f                   	lahf
    1e0e:	00 04 c5 16 cc 16 04 	add    %al,0x416cc16(,%rax,8)
  original_sport = pckt.flow.port16[0];
    1e15:	10 8b 04 9f 04 cc    	adc    %cl,-0x33fb60fc(%rbx)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1e1b:	16                   	(bad)
    1e1c:	85 17                	test   %edx,(%rdi)
    1e1e:	02 76 40             	add    0x40(%rsi),%dh
    1e21:	00 04 cc             	add    %al,(%rsp,%rcx,8)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1e24:	16                   	(bad)
    1e25:	e3 16                	jrcxz  1e3d <balancer_ingress+0x1e3d>
    1e27:	02 30                	add    (%rax),%dh
    1e29:	9f                   	lahf
    1e2a:	04 e3                	add    $0xe3,%al
    1e2c:	16                   	(bad)
    1e2d:	ec                   	in     (%dx),%al
    1e2e:	16                   	(bad)
    1e2f:	01 50 00             	add    %edx,0x0(%rax)
    1e32:	04 e3                	add    $0xe3,%al
  if (!conn_rate_stats) {
    1e34:	16                   	(bad)
    1e35:	85 17                	test   %edx,(%rdi)
    1e37:	01 50 00             	add    %edx,0x0(%rax)
    1e3a:	04 95                	add    $0x95,%al
    1e3c:	17                   	(bad)
    1e3d:	de 17                	ficoms (%rdi)
    1e3f:	04 76                	add    $0x76,%al
    1e41:	80 7f 9f 04          	cmpb   $0x4,-0x61(%rdi)
    1e45:	f0 19 9c 1a 04 76 80 	lock sbb %ebx,0x7f807604(%rdx,%rbx,1)
    1e4c:	7f 
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1e4d:	9f                   	lahf
    1e4e:	00 04 a7             	add    %al,(%rdi,%riz,4)
    1e51:	17                   	(bad)
    1e52:	a9 17 01 55 04       	test   $0x4550117,%eax
    1e57:	a9 17 de 17 03       	test   $0x317de17,%eax
    conn_rate_stats->v1 = 1;
    1e5c:	76 f0                	jbe    1e4e <balancer_ingress+0x1e4e>
    1e5e:	7e 04                	jle    1e64 <balancer_ingress+0x1e64>
    conn_rate_stats->v2 = *cur_time;
    1e60:	f0 19 9c 1a 03 76 f0 	lock sbb %ebx,0x7ef07603(%rdx,%rbx,1)
    1e67:	7e 
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1e68:	00 04 95 17 de 17 02 	add    %al,0x217de17(,%rdx,4)
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    1e6f:	30 9f 04 f0 19 9c    	xor    %bl,-0x63e60ffc(%rdi)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1e75:	1a 02                	sbb    (%rdx),%al
    1e77:	30 9f 00 04 a9 17    	xor    %bl,0x17a90400(%rdi)
    1e7d:	bb 17 01 50 04       	mov    $0x4500117,%ebx
    1e82:	bb 17 de 17 01       	mov    $0x117de17,%ebx
    1e87:	53                   	push   %rbx
    1e88:	04 f0                	add    $0xf0,%al
    1e8a:	19 9c 1a 01 53 00 04 	sbb    %ebx,0x4005301(%rdx,%rbx,1)
    per_vip_stats->v2 += 1;
    1e91:	c4                   	(bad)
    1e92:	17                   	(bad)
    1e93:	de 17                	ficoms (%rdi)
    1e95:	01 50 04             	add    %edx,0x4(%rax)
    conn_rate_stats->v1 += 1;
    1e98:	f0 19 f4             	lock sbb %esi,%esp
    1e9b:	19 01                	sbb    %eax,(%rcx)
    1e9d:	50                   	push   %rax
    1e9e:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    1ea1:	17                   	(bad)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1ea2:	83 18 01             	sbbl   $0x1,(%rax)
    1ea5:	5e                   	pop    %rsi
    1ea6:	04 a3                	add    $0xa3,%al
    1ea8:	19 b9 19 01 5e 04    	sbb    %edi,0x45e0119(%rcx)
  struct real_pos_lru new_dst_lru = {};
    1eae:	c5 27 d8             	(bad)
    1eb1:	27                   	(bad)
    1eb2:	01 5e 00             	add    %ebx,0x0(%rsi)
    1eb5:	04 f2                	add    $0xf2,%al
    1eb7:	17                   	(bad)
    1eb8:	83 18 01             	sbbl   $0x1,(%rax)
  new_dst_lru.pos = pckt->real_index;
    1ebb:	5e                   	pop    %rsi
    1ebc:	04 a3                	add    $0xa3,%al
    1ebe:	19 b9 19 01 5e 04    	sbb    %edi,0x45e0119(%rcx)
    1ec4:	c5 27 d8             	(bad)
    1ec7:	27                   	(bad)
    1ec8:	01 5e 00             	add    %ebx,0x0(%rsi)
    1ecb:	04 f2                	add    $0xf2,%al
    1ecd:	17                   	(bad)
    1ece:	8c 18                	mov    %ds,(%rax)
    1ed0:	02 30                	add    (%rax),%dh
    1ed2:	9f                   	lahf
    1ed3:	04 8c                	add    $0x8c,%al
    1ed5:	18 de                	sbb    %bl,%dh
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1ed7:	18 01                	sbb    %al,(%rcx)
    1ed9:	55                   	push   %rbp
              quic_packets_stats->dst_not_found_in_lru += 1;
    1eda:	04 a3                	add    $0xa3,%al
    1edc:	19 b9 19 02 30 9f    	sbb    %edi,-0x60cffde7(%rcx)
            quic_packets_stats->cid_routed += 1;
    1ee2:	04 c5                	add    $0xc5,%al
  original_sport = pckt.flow.port16[0];
    1ee4:	27                   	(bad)
    1ee5:	ca 27 02             	lret   $0x227
    1ee8:	30 9f 04 db 27 e9    	xor    %bl,-0x16d824fc(%rdi)
    1eee:	27                   	(bad)
    1eef:	01 5e 04             	add    %ebx,0x4(%rsi)
    1ef2:	e9 27 a9 28 01       	jmp    128c81e <_license+0x128a92b>
    1ef7:	55                   	push   %rbp
    1ef8:	00 04 a0             	add    %al,(%rax,%riz,4)
    1efb:	18 cd                	sbb    %cl,%ch
    1efd:	18 01                	sbb    %al,(%rcx)
    1eff:	51                   	push   %rcx
    1f00:	04 e9                	add    $0xe9,%al
    1f02:	27                   	(bad)
    1f03:	f5                   	cmc
    1f04:	27                   	(bad)
    1f05:	01 51 04             	add    %edx,0x4(%rcx)
    1f08:	8e 28                	mov    (%rax),%gs
    1f0a:	92                   	xchg   %eax,%edx
    1f0b:	28 01                	sub    %al,(%rcx)
    1f0d:	51                   	push   %rcx
    1f0e:	00 04 de             	add    %al,(%rsi,%rbx,8)
    1f11:	18 e5                	sbb    %ah,%ch
    1f13:	18 04 10             	sbb    %al,(%rax,%rdx,1)
    1f16:	8b 04 9f             	mov    (%rdi,%rbx,4),%eax
    1f19:	04 e5                	add    $0xe5,%al
    1f1b:	18 a3 19 02 76 40    	sbb    %ah,0x40760219(%rbx)
    1f21:	00 04 e5 18 fc 18 02 	add    %al,0x218fc18(,%riz,8)
    1f28:	30 9f 04 fc 18 85    	xor    %bl,-0x7ae703fc(%rdi)
    1f2e:	19 01                	sbb    %eax,(%rcx)
    1f30:	50                   	push   %rax
    1f31:	00 04 fc             	add    %al,(%rsp,%rdi,8)
    1f34:	18 a3 19 01 50 00    	sbb    %ah,0x500119(%rbx)
    1f3a:	04 c7                	add    $0xc7,%al
    1f3c:	19 de                	sbb    %ebx,%esi
    1f3e:	19 02                	sbb    %eax,(%rdx)
    1f40:	30 9f 04 de 19 e3    	xor    %bl,-0x1ce621fc(%rdi)
    1f46:	19 01                	sbb    %eax,(%rcx)
    1f48:	50                   	push   %rax
    1f49:	00 04 de             	add    %al,(%rsi,%rbx,8)
    1f4c:	19 e7                	sbb    %esp,%edi
    1f4e:	19 01                	sbb    %eax,(%rcx)
    1f50:	50                   	push   %rax
    1f51:	00 04 f6             	add    %al,(%rsi,%rsi,8)
    1f54:	19 86 1a 01 50 00    	sbb    %eax,0x50011a(%rsi)
    1f5a:	04 f6                	add    $0xf6,%al
    1f5c:	19 86 1a 01 50 00    	sbb    %eax,0x50011a(%rsi)
    1f62:	04 82                	add    $0x82,%al
    1f64:	1a 9c 1a 02 30 9f 00 	sbb    0x9f3002(%rdx,%rbx,1),%bl
    1f6b:	04 a0                	add    $0xa0,%al
    1f6d:	1a aa 1a 02 76 50    	sbb    0x5076021a(%rdx),%ch
    1f73:	04 aa                	add    $0xaa,%al
    1f75:	1a c9                	sbb    %cl,%cl
    1f77:	1a 01                	sbb    (%rcx),%al
    1f79:	54                   	push   %rsp
    1f7a:	04 c9                	add    $0xc9,%al
    1f7c:	1a f3                	sbb    %bl,%dh
    1f7e:	1b 02                	sbb    (%rdx),%eax
    1f80:	76 50                	jbe    1fd2 <_license+0xdf>
    1f82:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    1f85:	1a bb 1a 04 10 82    	sbb    -0x7deffbe6(%rbx),%bh
    1f8b:	04 9f                	add    $0x9f,%al
    1f8d:	04 bb                	add    $0xbb,%al
    1f8f:	1a 96 1b 02 76 40    	sbb    0x4076021b(%rsi),%dl
    1f95:	00 04 bb             	add    %al,(%rbx,%rdi,4)
    1f98:	1a d2                	sbb    %dl,%dl
    1f9a:	1a 02                	sbb    (%rdx),%al
    1f9c:	30 9f 04 d2 1a db    	xor    %bl,-0x24e52dfc(%rdi)
    1fa2:	1a 01                	sbb    (%rcx),%al
    1fa4:	50                   	push   %rax
    1fa5:	00 04 d2             	add    %al,(%rdx,%rdx,8)
    1fa8:	1a e5                	sbb    %ch,%ah
    1faa:	1a 01                	sbb    (%rcx),%al
    1fac:	50                   	push   %rax
    1fad:	04 e5                	add    $0xe5,%al
    1faf:	1a 96 1b 01 53 00    	sbb    0x53011b(%rsi),%dl
    1fb5:	04 96                	add    $0x96,%al
    1fb7:	1b b0 1b 02 30 9f    	sbb    -0x60cffde5(%rax),%esi
    1fbd:	04 b0                	add    $0xb0,%al
    1fbf:	1b b5 1b 01 50 00    	sbb    0x50011b(%rbp),%esi
    1fc5:	04 b0                	add    $0xb0,%al
    1fc7:	1b be 1b 01 50 00    	sbb    0x50011b(%rsi),%edi
    1fcd:	04 be                	add    $0xbe,%al
    1fcf:	1b df                	sbb    %edi,%ebx
    1fd1:	1b 01                	sbb    (%rcx),%eax
    1fd3:	50                   	push   %rax
    1fd4:	00 04 c3             	add    %al,(%rbx,%rax,8)
    1fd7:	1b ca                	sbb    %edx,%ecx
    1fd9:	1b 04 10             	sbb    (%rax,%rdx,1),%eax
    1fdc:	8f 04 9f             	pop    (%rdi,%rbx,4)
    1fdf:	04 ca                	add    $0xca,%al
    1fe1:	1b f3                	sbb    %ebx,%esi
    1fe3:	1b 02                	sbb    (%rdx),%eax
    1fe5:	76 40                	jbe    2027 <_license+0x134>
    1fe7:	00 04 ca             	add    %al,(%rdx,%rcx,8)
    1fea:	1b e1                	sbb    %ecx,%esp
    1fec:	1b 02                	sbb    (%rdx),%eax
    1fee:	30 9f 04 e1 1b ea    	xor    %bl,-0x15e41efc(%rdi)
    1ff4:	1b 01                	sbb    (%rcx),%eax
    1ff6:	50                   	push   %rax
    1ff7:	00 04 e1             	add    %al,(%rcx,%riz,8)
    1ffa:	1b f3                	sbb    %ebx,%esi
    1ffc:	1b 01                	sbb    (%rcx),%eax
    1ffe:	50                   	push   %rax
    1fff:	00 04 fc             	add    %al,(%rsp,%rdi,8)
    2002:	1b 97 1c 02 30 9f    	sbb    -0x60cffde4(%rdi),%edx
    2008:	04 97                	add    $0x97,%al
    200a:	1c a5                	sbb    $0xa5,%al
    200c:	1c 01                	sbb    $0x1,%al
    200e:	50                   	push   %rax
    200f:	00 04 c2             	add    %al,(%rdx,%rax,8)
    2012:	1c d3                	sbb    $0xd3,%al
    2014:	1c 02                	sbb    $0x2,%al
    2016:	30 9f 04 d3 1c dc    	xor    %bl,-0x23e32cfc(%rdi)
    201c:	1c 01                	sbb    $0x1,%al
    201e:	50                   	push   %rax
    201f:	00 04 f9             	add    %al,(%rcx,%rdi,8)
    2022:	1c 85                	sbb    $0x85,%al
    2024:	1e                   	(bad)
    2025:	02 76 50             	add    0x50(%rsi),%dh
    2028:	04 85                	add    $0x85,%al
    202a:	1e                   	(bad)
    202b:	87 1e                	xchg   %ebx,(%rsi)
    202d:	01 52 04             	add    %edx,0x4(%rdx)
    2030:	87 1e                	xchg   %ebx,(%rsi)
    2032:	cc                   	int3
    2033:	1e                   	(bad)
    2034:	02 76 50             	add    0x50(%rsi),%dh
    2037:	00 04 c5 1d be 1e 0e 	add    %al,0xe1ebe1d(,%rax,8)
    203e:	7c 00                	jl     2040 <_license+0x14d>
    2040:	10 ff                	adc    %bh,%bh
    2042:	ff                   	(bad)
    2043:	ff                   	(bad)
    2044:	ff 0f                	decl   (%rdi)
    2046:	1a 10                	sbb    (%rax),%dl
    2048:	ac                   	lods   %ds:(%rsi),%al
    2049:	21 21                	and    %esp,(%rcx)
    204b:	9f                   	lahf
    204c:	00 04 fe             	add    %al,(%rsi,%rdi,8)
    204f:	1c cc                	sbb    $0xcc,%al
    2051:	1e                   	(bad)
    2052:	02 30                	add    (%rax),%dh
    2054:	9f                   	lahf
    2055:	00 04 9b             	add    %al,(%rbx,%rbx,4)
    2058:	1d cc 1e 01 50       	sbb    $0x50011ecc,%eax
    205d:	00 04 9f             	add    %al,(%rdi,%rbx,4)
    2060:	1d d7 1d 01 52       	sbb    $0x52011dd7,%eax
    2065:	00 04 9f             	add    %al,(%rdi,%rbx,4)
    2068:	1d cc 1e 01 50       	sbb    $0x50011ecc,%eax
    206d:	00 04 a3             	add    %al,(%rbx,%riz,4)
    2070:	1d cc 1e 03 70       	sbb    $0x70031ecc,%eax
    2075:	14 9f                	adc    $0x9f,%al
    2077:	00 04 87             	add    %al,(%rdi,%rax,4)
    207a:	1e                   	(bad)
    207b:	be 1e 0e 7c 00       	mov    $0x7c0e1e,%esi
    2080:	10 ff                	adc    %bh,%bh
    2082:	ff                   	(bad)
    2083:	ff                   	(bad)
    2084:	ff 0f                	decl   (%rdi)
    2086:	1a 10                	sbb    (%rax),%dl
    2088:	ac                   	lods   %ds:(%rsi),%al
    2089:	21 21                	and    %esp,(%rcx)
    208b:	9f                   	lahf
    208c:	00 04 af             	add    %al,(%rdi,%rbp,4)
    208f:	1e                   	(bad)
    2090:	b3 1e                	mov    $0x1e,%bl
    2092:	03 11                	add    (%rcx),%edx
    2094:	00 9f 04 b3 1e b6    	add    %bl,-0x49e14cfc(%rdi)
    209a:	1e                   	(bad)
    209b:	03 11                	add    (%rcx),%edx
    209d:	01 9f 04 b6 1e ba    	add    %ebx,-0x45e149fc(%rdi)
    20a3:	1e                   	(bad)
    20a4:	03 11                	add    (%rcx),%edx
    20a6:	04 9f                	add    $0x9f,%al
    20a8:	04 ba                	add    $0xba,%al
    20aa:	1e                   	(bad)
    20ab:	be 1e 03 11 07       	mov    $0x711031e,%esi
    20b0:	9f                   	lahf
    20b1:	04 be                	add    $0xbe,%al
    20b3:	1e                   	(bad)
    20b4:	c4                   	(bad)
    20b5:	1e                   	(bad)
    20b6:	03 11                	add    (%rcx),%edx
    20b8:	08 9f 04 c4 1e cc    	or     %bl,-0x33e13bfc(%rdi)
    20be:	1e                   	(bad)
    20bf:	03 11                	add    (%rcx),%edx
    20c1:	09 9f 00 04 af 1e    	or     %ebx,0x1eaf0400(%rdi)
    20c7:	b3 1e                	mov    $0x1e,%bl
    20c9:	05 70 0e 23 02       	add    $0x2230e70,%eax
    20ce:	9f                   	lahf
    20cf:	04 b3                	add    $0xb3,%al
    20d1:	1e                   	(bad)
    20d2:	b6 1e                	mov    $0x1e,%dh
    20d4:	05 70 0e 23 04       	add    $0x4230e70,%eax
    20d9:	9f                   	lahf
    20da:	04 b6                	add    $0xb6,%al
    20dc:	1e                   	(bad)
    20dd:	ba 1e 05 70 0e       	mov    $0xe70051e,%edx
    20e2:	23 0a                	and    (%rdx),%ecx
    20e4:	9f                   	lahf
    20e5:	04 ba                	add    $0xba,%al
    20e7:	1e                   	(bad)
    20e8:	be 1e 05 70 0e       	mov    $0xe70051e,%esi
    20ed:	23 10                	and    (%rax),%edx
    20ef:	9f                   	lahf
    20f0:	04 be                	add    $0xbe,%al
    20f2:	1e                   	(bad)
    20f3:	c4                   	(bad)
    20f4:	1e                   	(bad)
    20f5:	05 70 0e 23 12       	add    $0x12230e70,%eax
    20fa:	9f                   	lahf
    20fb:	04 c4                	add    $0xc4,%al
    20fd:	1e                   	(bad)
    20fe:	cc                   	int3
    20ff:	1e                   	(bad)
    2100:	07                   	(bad)
    2101:	70 0e                	jo     2111 <_license+0x21e>
    2103:	23 12                	and    (%rdx),%edx
    2105:	23 02                	and    (%rdx),%eax
    2107:	9f                   	lahf
    2108:	00 04 d2             	add    %al,(%rdx,%rdx,8)
    210b:	1e                   	(bad)
    210c:	d9 1e                	fstps  (%rsi)
    210e:	04 10                	add    $0x10,%al
    2110:	81 04 9f 04 d9 1e 89 	addl   $0x891ed904,(%rdi,%rbx,4)
    2117:	1f                   	(bad)
    2118:	02 76 40             	add    0x40(%rsi),%dh
    211b:	00 04 d9             	add    %al,(%rcx,%rbx,8)
    211e:	1e                   	(bad)
    211f:	f0 1e                	lock (bad)
    2121:	02 30                	add    (%rax),%dh
    2123:	9f                   	lahf
    2124:	04 f0                	add    $0xf0,%al
    2126:	1e                   	(bad)
    2127:	f9                   	stc
    2128:	1e                   	(bad)
    2129:	01 50 00             	add    %edx,0x0(%rax)
    212c:	04 f0                	add    $0xf0,%al
    212e:	1e                   	(bad)
    212f:	89 1f                	mov    %ebx,(%rdi)
    2131:	01 50 00             	add    %edx,0x0(%rax)
    2134:	04 89                	add    $0x89,%al
    2136:	1f                   	(bad)
    2137:	f7 1f                	negl   (%rdi)
    2139:	04 76                	add    $0x76,%al
    213b:	80 7f 9f 04          	cmpb   $0x4,-0x61(%rdi)
    213f:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2140:	21 b8 25 04 76 80    	and    %edi,-0x7f89fbdb(%rax)
    2146:	7f 9f                	jg     20e7 <_license+0x1f4>
    2148:	00 04 89             	add    %al,(%rcx,%rcx,4)
    214b:	1f                   	(bad)
    214c:	f2 1f                	repnz (bad)
    214e:	02 76 50             	add    0x50(%rsi),%dh
    2151:	04 f2                	add    $0xf2,%al
    2153:	1f                   	(bad)
    2154:	f7 1f                	negl   (%rdi)
    2156:	01 52 04             	add    %edx,0x4(%rdx)
    2159:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    215a:	21 ba 21 02 76 50    	and    %edi,0x50760221(%rdx)
    2160:	04 ba                	add    $0xba,%al
    2162:	21 cd                	and    %ecx,%ebp
    2164:	21 01                	and    %eax,(%rcx)
    2166:	52                   	push   %rdx
    2167:	04 cd                	add    $0xcd,%al
    2169:	21 e2                	and    %esp,%edx
    216b:	21 02                	and    %eax,(%rdx)
    216d:	76 50                	jbe    21bf <_license+0x2cc>
    216f:	04 e2                	add    $0xe2,%al
    2171:	21 e9                	and    %ebp,%ecx
    2173:	21 01                	and    %eax,(%rcx)
    2175:	52                   	push   %rdx
    2176:	04 e9                	add    $0xe9,%al
    2178:	21 ab 24 02 76 50    	and    %ebp,0x50760224(%rbx)
    217e:	04 ab                	add    $0xab,%al
    2180:	24 b0                	and    $0xb0,%al
    2182:	24 01                	and    $0x1,%al
    2184:	52                   	push   %rdx
    2185:	04 b0                	add    $0xb0,%al
    2187:	24 fc                	and    $0xfc,%al
    2189:	24 02                	and    $0x2,%al
    218b:	76 50                	jbe    21dd <_license+0x2ea>
    218d:	04 fc                	add    $0xfc,%al
    218f:	24 fe                	and    $0xfe,%al
    2191:	24 01                	and    $0x1,%al
    2193:	52                   	push   %rdx
    2194:	04 fe                	add    $0xfe,%al
    2196:	24 b8                	and    $0xb8,%al
    2198:	25 02 76 50 00       	and    $0x507602,%eax
    219d:	04 89                	add    $0x89,%al
    219f:	1f                   	(bad)
    21a0:	f7 1f                	negl   (%rdi)
    21a2:	02 31                	add    (%rcx),%dh
    21a4:	9f                   	lahf
    21a5:	04 a5                	add    $0xa5,%al
    21a7:	21 b8 25 02 31 9f    	and    %edi,-0x60cefddb(%rax)
    21ad:	00 04 89             	add    %al,(%rcx,%rcx,4)
    21b0:	1f                   	(bad)
    21b1:	f7 1f                	negl   (%rdi)
    21b3:	03 76 f0             	add    -0x10(%rsi),%esi
    21b6:	7e 04                	jle    21bc <_license+0x2c9>
    21b8:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    21b9:	21 b0 25 03 76 f0    	and    %esi,-0xf89fcdb(%rax)
    21bf:	7e 04                	jle    21c5 <_license+0x2d2>
    21c1:	b0 25                	mov    $0x25,%al
    21c3:	b4 25                	mov    $0x25,%ah
    21c5:	01 55 00             	add    %edx,0x0(%rbp)
    21c8:	04 99                	add    $0x99,%al
    21ca:	1f                   	(bad)
    21cb:	f7 1f                	negl   (%rdi)
    21cd:	02 30                	add    (%rax),%dh
    21cf:	9f                   	lahf
    21d0:	04 a5                	add    $0xa5,%al
    21d2:	21 bf 21 02 30 9f    	and    %edi,-0x60cffddf(%rdi)
    21d8:	04 bf                	add    $0xbf,%al
    21da:	21 86 25 11 7f 00    	and    %eax,0x7f1125(%rsi)
    21e0:	10 ff                	adc    %bh,%bh
    21e2:	01 1a                	add    %ebx,(%rdx)
    21e4:	a8 b5                	test   $0xb5,%al
    21e6:	80 80 00 a8 ba 80 80 	addb   $0x80,-0x7f455800(%rax)
    21ed:	00 9f 00 04 99 1f    	add    %bl,0x1f990400(%rdi)
    21f3:	f7 1f                	negl   (%rdi)
    21f5:	02 30                	add    (%rax),%dh
    21f7:	9f                   	lahf
    21f8:	04 a5                	add    $0xa5,%al
    21fa:	21 b8 25 02 30 9f    	and    %edi,-0x60cffddb(%rax)
    2200:	00 04 99             	add    %al,(%rcx,%rbx,4)
    2203:	1f                   	(bad)
    2204:	f7 1f                	negl   (%rdi)
    2206:	02 30                	add    (%rax),%dh
    2208:	9f                   	lahf
    2209:	04 a5                	add    $0xa5,%al
    220b:	21 93 25 02 30 9f    	and    %edx,-0x60cffddb(%rbx)
    2211:	04 93                	add    $0x93,%al
    2213:	25 97 25 01 50       	and    $0x50012597,%eax
    2218:	00 04 99             	add    %al,(%rcx,%rbx,4)
    221b:	1f                   	(bad)
    221c:	a0 1f 04 10 82 04 9f 	movabs 0xa0049f048210041f,%al
    2223:	04 a0 
    2225:	1f                   	(bad)
    2226:	f7 1f                	negl   (%rdi)
    2228:	03 76 b8             	add    -0x48(%rsi),%esi
    222b:	7f 04                	jg     2231 <_license+0x33e>
    222d:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    222e:	21 bc 21 03 76 b8 7f 	and    %edi,0x7fb87603(%rcx,%riz,1)
    2235:	00 04 a0             	add    %al,(%rax,%riz,4)
    2238:	1f                   	(bad)
    2239:	b7 1f                	mov    $0x1f,%bh
    223b:	02 30                	add    (%rax),%dh
    223d:	9f                   	lahf
    223e:	04 b7                	add    $0xb7,%al
    2240:	1f                   	(bad)
    2241:	c3                   	ret
    2242:	1f                   	(bad)
    2243:	01 50 00             	add    %edx,0x0(%rax)
    2246:	04 b7                	add    $0xb7,%al
    2248:	1f                   	(bad)
    2249:	cd 1f                	int    $0x1f
    224b:	01 50 04             	add    %edx,0x4(%rax)
    224e:	cd 1f                	int    $0x1f
    2250:	f7 1f                	negl   (%rdi)
    2252:	01 53 04             	add    %edx,0x4(%rbx)
    2255:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2256:	21 bc 21 01 53 00 04 	and    %edi,0x4005301(%rcx,%riz,1)
    225d:	94                   	xchg   %eax,%esp
    225e:	20 9d 21 01 50 00    	and    %bl,0x500121(%rbp)
    2264:	04 98                	add    $0x98,%al
    2266:	20 bc 20 01 52 00 04 	and    %bh,0x4005201(%rax,%riz,1)
    226d:	98                   	cwtl
    226e:	20 9d 21 01 50 00    	and    %bl,0x500121(%rbp)
    2274:	04 9c                	add    $0x9c,%al
    2276:	20 a9 20 01 51 00    	and    %ch,0x510120(%rcx)
    227c:	04 9c                	add    $0x9c,%al
    227e:	20 9d 21 03 70 28    	and    %bl,0x28700321(%rbp)
    2284:	9f                   	lahf
    2285:	00 04 e7             	add    %al,(%rdi,%riz,8)
    2288:	20 9d 21 03 10 29    	and    %bl,0x29100321(%rbp)
    228e:	9f                   	lahf
    228f:	00 04 e7             	add    %al,(%rdi,%riz,8)
    2292:	20 ea                	and    %ch,%dl
    2294:	20 0c 31             	and    %cl,(%rcx,%rsi,1)
    2297:	9f                   	lahf
    2298:	93                   	xchg   %eax,%ebx
    2299:	04 30                	add    $0x30,%al
    229b:	9f                   	lahf
    229c:	93                   	xchg   %eax,%ebx
    229d:	04 30                	add    $0x30,%al
    229f:	9f                   	lahf
    22a0:	93                   	xchg   %eax,%ebx
    22a1:	04 04                	add    $0x4,%al
    22a3:	ea                   	(bad)
    22a4:	20 9d 21 0f 31 9f    	and    %bl,-0x60cef0df(%rbp)
    22aa:	93                   	xchg   %eax,%ebx
    22ab:	04 30                	add    $0x30,%al
    22ad:	9f                   	lahf
    22ae:	93                   	xchg   %eax,%ebx
    22af:	04 30                	add    $0x30,%al
    22b1:	9f                   	lahf
    22b2:	93                   	xchg   %eax,%ebx
    22b3:	04 52                	add    $0x52,%al
    22b5:	93                   	xchg   %eax,%ebx
    22b6:	04 00                	add    $0x0,%al
    22b8:	04 f0                	add    $0xf0,%al
    22ba:	20 94 21 01 54 00 04 	and    %dl,0x4005401(%rcx,%riz,1)
    22c1:	f0 20 94 21 01 54 00 	lock and %dl,0x4005401(%rcx,%riz,1)
    22c8:	04 
    22c9:	f3 20 87 21 01 53 00 	repz and %al,0x530121(%rdi)
    22d0:	04 95                	add    $0x95,%al
    22d2:	22 9a 22 01 53 04    	and    0x4530122(%rdx),%bl
    22d8:	9c                   	pushf
    22d9:	22 ac 22 0c 10 ff 81 	and    -0x7e00eff4(%rdx,%riz,1),%ch
    22e0:	b7 f5                	mov    $0xf5,%bh
    22e2:	fd                   	std
    22e3:	ff                   	(bad)
    22e4:	ff                   	(bad)
    22e5:	ff                   	(bad)
    22e6:	ff 01                	incl   (%rcx)
    22e8:	9f                   	lahf
    22e9:	04 ac                	add    $0xac,%al
    22eb:	22 b7 22 01 51 04    	and    0x4510122(%rdi),%dh
    22f1:	be 22 c0 22 01       	mov    $0x122c022,%esi
    22f6:	51                   	push   %rcx
    22f7:	04 c0                	add    $0xc0,%al
    22f9:	22 e1                	and    %cl,%ah
    22fb:	22 01                	and    (%rcx),%al
    22fd:	52                   	push   %rdx
    22fe:	04 90                	add    $0x90,%al
    2300:	23 c0                	and    %eax,%eax
    2302:	23 01                	and    (%rcx),%eax
    2304:	52                   	push   %rdx
    2305:	00 04 97             	add    %al,(%rdi,%rdx,4)
    2308:	22 9c 22 01 55 04 b7 	and    -0x48fbaaff(%rdx,%riz,1),%bl
    230f:	22 cb                	and    %bl,%cl
    2311:	22 01                	and    (%rcx),%al
    2313:	53                   	push   %rbx
    2314:	04 cb                	add    $0xcb,%al
    2316:	22 ea                	and    %dl,%ch
    2318:	22 01                	and    (%rcx),%al
    231a:	55                   	push   %rbp
    231b:	04 84                	add    $0x84,%al
    231d:	23 b9 23 01 54 00    	and    0x540123(%rcx),%edi
    2323:	04 9c                	add    $0x9c,%al
    2325:	22 c3                	and    %bl,%al
    2327:	24 04                	and    $0x4,%al
    2329:	76 80                	jbe    22ab <_license+0x3b8>
    232b:	7f 9f                	jg     22cc <_license+0x3d9>
    232d:	00 04 9c             	add    %al,(%rsp,%rbx,4)
    2330:	22 c3                	and    %bl,%al
    2332:	24 02                	and    $0x2,%al
    2334:	31 9f 00 04 9c 22    	xor    %ebx,0x229c0400(%rdi)
    233a:	c3                   	ret
    233b:	24 04                	and    $0x4,%al
    233d:	10 80 04 9f 00 04    	adc    %al,0x4009f04(%rax)
    2343:	9c                   	pushf
    2344:	22 a4 22 0c 10 ff 81 	and    -0x7e00eff4(%rdx,%riz,1),%ah
    234b:	b7 f5                	mov    $0xf5,%bh
    234d:	fd                   	std
    234e:	ff                   	(bad)
    234f:	ff                   	(bad)
    2350:	ff                   	(bad)
    2351:	ff 01                	incl   (%rcx)
    2353:	9f                   	lahf
    2354:	04 a4                	add    $0xa4,%al
    2356:	22 b5 22 01 55 04    	and    0x4550122(%rbp),%dh
    235c:	b5 22                	mov    $0x22,%ch
    235e:	d6                   	(bad)
    235f:	22 01                	and    (%rcx),%al
    2361:	54                   	push   %rsp
    2362:	04 d6                	add    $0xd6,%al
    2364:	22 c0                	and    %al,%al
    2366:	23 01                	and    (%rcx),%eax
    2368:	51                   	push   %rcx
    2369:	00 04 e3             	add    %al,(%rbx,%riz,8)
    236c:	22 c3                	and    %bl,%al
    236e:	24 06                	and    $0x6,%al
    2370:	76 80                	jbe    22f2 <_license+0x3ff>
    2372:	7f 23                	jg     2397 <_license+0x4a4>
    2374:	0c 9f                	or     $0x9f,%al
    2376:	00 04 d0             	add    %al,(%rax,%rdx,8)
    2379:	23 88 24 01 52 00    	and    0x520124(%rax),%ecx
    237f:	04 ca                	add    $0xca,%al
    2381:	23 8f 24 01 54 00    	and    0x540124(%rdi),%ecx
    2387:	04 c0                	add    $0xc0,%al
    2389:	23 ca                	and    %edx,%ecx
    238b:	23 02                	and    (%rdx),%eax
    238d:	30 9f 04 ca 23 d8    	xor    %bl,-0x27dc35fc(%rdi)
    2393:	23 0c 10             	and    (%rax,%rdx,1),%ecx
    2396:	f7 81 b7 85 fe ff ff 	testl  $0x1ffffff,-0x17a49(%rcx)
    239d:	ff ff 01 
    23a0:	9f                   	lahf
    23a1:	04 d8                	add    $0xd8,%al
    23a3:	23 a7 24 01 51 00    	and    0x510124(%rdi),%esp
    23a9:	04 a7                	add    $0xa7,%al
    23ab:	24 cf                	and    $0xcf,%al
    23ad:	24 01                	and    $0x1,%al
    23af:	51                   	push   %rcx
    23b0:	00 04 b7             	add    %al,(%rdi,%rsi,4)
    23b3:	24 c5                	and    $0xc5,%al
    23b5:	24 01                	and    $0x1,%al
    23b7:	52                   	push   %rdx
    23b8:	04 d6                	add    $0xd6,%al
    23ba:	24 b8                	and    $0xb8,%al
    23bc:	25 01 53 00 04       	and    $0x4005301,%eax
    23c1:	b7 24                	mov    $0x24,%bh
    23c3:	c5 24 01             	(bad)
    23c6:	52                   	push   %rdx
    23c7:	00 04 b7             	add    %al,(%rdi,%rsi,4)
    23ca:	24 bd                	and    $0xbd,%al
    23cc:	24 02                	and    $0x2,%al
    23ce:	30 9f 00 04 e2 24    	xor    %bl,0x24e20400(%rdi)
    23d4:	e8 24 02 30 9f       	call   ffffffff9f3025fd <server_id_map+0x36fc5eb1e5fd>
    23d9:	00 04 a4             	add    %al,(%rsp,%riz,4)
    23dc:	26 a8 26             	es test $0x26,%al
    23df:	01 58 04             	add    %ebx,0x4(%rax)
    23e2:	a8 26                	test   $0x26,%al
    23e4:	cb                   	lret
    23e5:	26 02 76 40          	es add 0x40(%rsi),%dh
    23e9:	00 04 a8             	add    %al,(%rax,%rbp,4)
    23ec:	26 bf 26 02 30 9f    	es mov $0x9f300226,%edi
    23f2:	04 bf                	add    $0xbf,%al
    23f4:	26 c8 26 01 50       	es enter $0x126,$0x50
    23f9:	00 04 bf             	add    %al,(%rdi,%rdi,4)
    23fc:	26 cb                	es lret
    23fe:	26 01 50 00          	es add %edx,0x0(%rax)
    2402:	04 9c                	add    $0x9c,%al
    2404:	27                   	(bad)
    2405:	b3 27                	mov    $0x27,%bl
    2407:	02 30                	add    (%rax),%dh
    2409:	9f                   	lahf
    240a:	04 b3                	add    $0xb3,%al
    240c:	27                   	(bad)
    240d:	bc 27 01 50 00       	mov    $0x500127,%esp
    2412:	04 b3                	add    $0xb3,%al
    2414:	27                   	(bad)
    2415:	c5 27 01             	(bad)
    2418:	50                   	push   %rax
    2419:	00 04 c5 27 d4 27 01 	add    %al,0x127d427(,%rax,8)
    2420:	5e                   	pop    %rsi
    2421:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    2424:	28 bb 28 03 55 93    	sub    %bh,-0x6caafcd8(%rbx)
    242a:	04 04                	add    $0x4,%al
    242c:	bb 28 ca 28 06       	mov    $0x628ca28,%ebx
    2431:	55                   	push   %rbp
    2432:	93                   	xchg   %eax,%ebx
    2433:	04 51                	add    $0x51,%al
    2435:	93                   	xchg   %eax,%ebx
    2436:	01 04 be             	add    %eax,(%rsi,%rdi,4)
    2439:	29 e6                	sub    %esp,%esi
    243b:	29 06                	sub    %eax,(%rsi)
    243d:	55                   	push   %rbp
    243e:	93                   	xchg   %eax,%ebx
    243f:	04 51                	add    $0x51,%al
    2441:	93                   	xchg   %eax,%ebx
    2442:	01 04 e6             	add    %eax,(%rsi,%riz,8)
    2445:	29 a4 2a 03 55 93 04 	sub    %esp,0x4935503(%rdx,%rbp,1)
    244c:	04 c5                	add    $0xc5,%al
    244e:	2a de                	sub    %dh,%bl
    2450:	2a 06                	sub    (%rsi),%al
    2452:	55                   	push   %rbp
    2453:	93                   	xchg   %eax,%ebx
    2454:	04 51                	add    $0x51,%al
    2456:	93                   	xchg   %eax,%ebx
    2457:	01 00                	add    %eax,(%rax)
    2459:	04 bb                	add    $0xbb,%al
    245b:	28 ca                	sub    %cl,%dl
    245d:	28 01                	sub    %al,(%rcx)
    245f:	53                   	push   %rbx
    2460:	04 be                	add    $0xbe,%al
    2462:	29 cb                	sub    %ecx,%ebx
    2464:	29 01                	sub    %eax,(%rcx)
    2466:	53                   	push   %rbx
    2467:	00 04 bb             	add    %al,(%rbx,%rdi,4)
    246a:	28 ca                	sub    %cl,%dl
    246c:	28 01                	sub    %al,(%rcx)
    246e:	51                   	push   %rcx
    246f:	04 be                	add    $0xbe,%al
    2471:	29 cb                	sub    %ecx,%ebx
    2473:	29 01                	sub    %eax,(%rcx)
    2475:	51                   	push   %rcx
    2476:	00 04 d1             	add    %al,(%rcx,%rdx,8)
    2479:	28 dc                	sub    %bl,%ah
    247b:	28 01                	sub    %al,(%rcx)
    247d:	5e                   	pop    %rsi
    247e:	00 04 f4             	add    %al,(%rsp,%rsi,8)
    2481:	28 9a 29 01 51 04    	sub    %bl,0x4510129(%rdx)
    2487:	de 2a                	fisubrs (%rdx)
    2489:	ea                   	(bad)
    248a:	2a 01                	sub    (%rcx),%al
    248c:	51                   	push   %rcx
    248d:	04 83                	add    $0x83,%al
    248f:	2b 87 2b 01 51 00    	sub    0x51012b(%rdi),%eax
    2495:	04 c3                	add    $0xc3,%al
    2497:	29 dc                	sub    %ebx,%esp
    2499:	29 01                	sub    %eax,(%rcx)
    249b:	55                   	push   %rbp
    249c:	04 dc                	add    $0xdc,%al
    249e:	29 fa                	sub    %edi,%edx
    24a0:	29 01                	sub    %eax,(%rcx)
    24a2:	52                   	push   %rdx
    24a3:	00 04 c3             	add    %al,(%rbx,%rax,8)
    24a6:	29 c9                	sub    %ecx,%ecx
    24a8:	29 02                	sub    %eax,(%rdx)
    24aa:	30 9f 00 04 e6 29    	xor    %bl,0x29e60400(%rdi)
    24b0:	86 2a                	xchg   %ch,(%rdx)
    24b2:	02 30                	add    (%rax),%dh
    24b4:	9f                   	lahf
    24b5:	04 86                	add    $0x86,%al
    24b7:	2a 8f 2a 01 51 00    	sub    0x51012a(%rdi),%cl
    24bd:	04 e6                	add    $0xe6,%al
    24bf:	29 fa                	sub    %edi,%edx
    24c1:	29 01                	sub    %eax,(%rcx)
    24c3:	52                   	push   %rdx
    24c4:	00 04 92             	add    %al,(%rdx,%rdx,4)
    24c7:	2a bb 2a 04 76 80    	sub    -0x7f89fbd6(%rbx),%bh
    24cd:	7f 9f                	jg     246e <_license+0x57b>
    24cf:	04 bf                	add    $0xbf,%al
    24d1:	2b 90 2c 04 76 80    	sub    -0x7f89fbd4(%rax),%edx
    24d7:	7f 9f                	jg     2478 <_license+0x585>
    24d9:	04 92                	add    $0x92,%al
    24db:	3b be 3b 04 76 80    	cmp    -0x7f89fbc5(%rsi),%edi
    24e1:	7f 9f                	jg     2482 <_license+0x58f>
    24e3:	04 c5                	add    $0xc5,%al
    24e5:	3b 87 3c 04 76 80    	cmp    -0x7f89fbc4(%rdi),%eax
    24eb:	7f 9f                	jg     248c <_license+0x599>
    24ed:	00 04 a4             	add    %al,(%rsp,%riz,4)
    24f0:	2a a7 2a 01 55 04    	sub    0x455012a(%rdi),%ah
    24f6:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    24f7:	2a bb 2a 03 76 f0    	sub    -0xf89fcd6(%rbx),%bh
    24fd:	7e 04                	jle    2503 <_license+0x610>
    24ff:	bf 2b 90 2c 03       	mov    $0x32c902b,%edi
    2504:	76 f0                	jbe    24f6 <_license+0x603>
    2506:	7e 04                	jle    250c <_license+0x619>
    2508:	92                   	xchg   %eax,%edx
    2509:	3b be 3b 03 76 f0    	cmp    -0xf89fcc5(%rsi),%edi
    250f:	7e 04                	jle    2515 <_license+0x622>
    2511:	c5 3b 83             	(bad)
    2514:	3c 03                	cmp    $0x3,%al
    2516:	76 f0                	jbe    2508 <_license+0x615>
    2518:	7e 04                	jle    251e <_license+0x62b>
    251a:	83 3c 87 3c          	cmpl   $0x3c,(%rdi,%rax,4)
    251e:	01 55 00             	add    %edx,0x0(%rbp)
    2521:	04 a7                	add    $0xa7,%al
    2523:	2a bb 2a 01 50 04    	sub    0x450012a(%rbx),%bh
    2529:	bf 2b d7 2b 01       	mov    $0x12bd72b,%edi
    252e:	50                   	push   %rax
    252f:	04 92                	add    $0x92,%al
    2531:	3b 9f 3b 01 50 00    	cmp    0x50013b(%rdi),%ebx
    2537:	04 bb                	add    $0xbb,%al
    2539:	2a c5                	sub    %ch,%al
    253b:	2a 03                	sub    (%rbx),%al
    253d:	11 01                	adc    %eax,(%rcx)
    253f:	9f                   	lahf
    2540:	04 94                	add    $0x94,%al
    2542:	3b c5                	cmp    %ebp,%eax
    2544:	3b 03                	cmp    (%rbx),%eax
    2546:	11 01                	adc    %eax,(%rcx)
    2548:	9f                   	lahf
    2549:	00 04 a1             	add    %al,(%rcx,%riz,4)
    254c:	2b a9 2b 03 50 93    	sub    -0x6caffcd5(%rcx),%ebp
    2552:	04 04                	add    $0x4,%al
    2554:	a9 2b b8 2b 06       	test   $0x62bb82b,%eax
    2559:	50                   	push   %rax
    255a:	93                   	xchg   %eax,%ebx
    255b:	04 51                	add    $0x51,%al
    255d:	93                   	xchg   %eax,%ebx
    255e:	01 04 a3             	add    %eax,(%rbx,%riz,4)
    2561:	2c ca                	sub    $0xca,%al
    2563:	2c 06                	sub    $0x6,%al
    2565:	50                   	push   %rax
    2566:	93                   	xchg   %eax,%ebx
    2567:	04 51                	add    $0x51,%al
    2569:	93                   	xchg   %eax,%ebx
    256a:	01 04 ca             	add    %eax,(%rdx,%rcx,8)
    256d:	2c d4                	sub    $0xd4,%al
    256f:	2c 03                	sub    $0x3,%al
    2571:	50                   	push   %rax
    2572:	93                   	xchg   %eax,%ebx
    2573:	04 04                	add    $0x4,%al
    2575:	aa                   	stos   %al,%es:(%rdi)
    2576:	2d b1 2d 06 50       	sub    $0x50062db1,%eax
    257b:	93                   	xchg   %eax,%ebx
    257c:	04 51                	add    $0x51,%al
    257e:	93                   	xchg   %eax,%ebx
    257f:	01 04 b1             	add    %eax,(%rcx,%rsi,4)
    2582:	2d b5 2d 05 93       	sub    $0x93052db5,%eax
    2587:	04 51                	add    $0x51,%al
    2589:	93                   	xchg   %eax,%ebx
    258a:	01 00                	add    %eax,(%rax)
    258c:	04 a9                	add    $0xa9,%al
    258e:	2b b8 2b 01 53 04    	sub    0x453012b(%rax),%edi
    2594:	a3 2c af 2c 01 53 00 	movabs %eax,0xa9040053012caf2c
    259b:	04 a9 
    259d:	2b b8 2b 01 51 04    	sub    0x451012b(%rax),%edi
    25a3:	a3 2c af 2c 01 51 00 	movabs %eax,0xbf040051012caf2c
    25aa:	04 bf 
    25ac:	2b c6                	sub    %esi,%eax
    25ae:	2b 04 10             	sub    (%rax,%rdx,1),%eax
    25b1:	82                   	(bad)
    25b2:	04 9f                	add    $0x9f,%al
    25b4:	04 c6                	add    $0xc6,%al
    25b6:	2b 90 2c 02 76 40    	sub    0x4076022c(%rax),%edx
    25bc:	04 c5                	add    $0xc5,%al
    25be:	3b d7                	cmp    %edi,%edx
    25c0:	3b 02                	cmp    (%rdx),%eax
    25c2:	76 40                	jbe    2604 <_license+0x711>
    25c4:	00 04 c6             	add    %al,(%rsi,%rax,8)
    25c7:	2b d7                	sub    %edi,%edx
    25c9:	2b 02                	sub    (%rdx),%eax
    25cb:	30 9f 04 d7 2b e0    	xor    %bl,-0x1fd428fc(%rdi)
    25d1:	2b 01                	sub    (%rcx),%eax
    25d3:	50                   	push   %rax
    25d4:	00 04 d7             	add    %al,(%rdi,%rdx,8)
    25d7:	2b ea                	sub    %edx,%ebp
    25d9:	2b 01                	sub    (%rcx),%eax
    25db:	50                   	push   %rax
    25dc:	04 ea                	add    $0xea,%al
    25de:	2b 90 2c 01 5e 04    	sub    0x45e012c(%rax),%edx
    25e4:	c5 3b d7             	(bad)
    25e7:	3b 01                	cmp    (%rcx),%eax
    25e9:	5e                   	pop    %rsi
    25ea:	00 04 a8             	add    %al,(%rax,%rbp,4)
    25ed:	2c c0                	sub    $0xc0,%al
    25ef:	2c 01                	sub    $0x1,%al
    25f1:	50                   	push   %rax
    25f2:	04 c0                	add    $0xc0,%al
    25f4:	2c de                	sub    $0xde,%al
    25f6:	2c 01                	sub    $0x1,%al
    25f8:	52                   	push   %rdx
    25f9:	00 04 a8             	add    %al,(%rax,%rbp,4)
    25fc:	2c ad                	sub    $0xad,%al
    25fe:	2c 02                	sub    $0x2,%al
    2600:	30 9f 00 04 ca 2c    	xor    %bl,0x2cca0400(%rdi)
    2606:	ea                   	(bad)
    2607:	2c 02                	sub    $0x2,%al
    2609:	30 9f 04 ea 2c ee    	xor    %bl,-0x11d315fc(%rdi)
    260f:	2c 01                	sub    $0x1,%al
    2611:	51                   	push   %rcx
    2612:	04 ee                	add    $0xee,%al
    2614:	2c f7                	sub    $0xf7,%al
    2616:	2c 02                	sub    $0x2,%al
    2618:	76 50                	jbe    266a <_license+0x777>
    261a:	00 04 ca             	add    %al,(%rdx,%rcx,8)
    261d:	2c de                	sub    $0xde,%al
    261f:	2c 01                	sub    $0x1,%al
    2621:	52                   	push   %rdx
    2622:	00 04 f7             	add    %al,(%rdi,%rsi,8)
    2625:	2c a0                	sub    $0xa0,%al
    2627:	2d 04 76 80 7f       	sub    $0x7f807604,%eax
    262c:	9f                   	lahf
    262d:	04 9b                	add    $0x9b,%al
    262f:	3c 91                	cmp    $0x91,%al
    2631:	3d 04 76 80 7f       	cmp    $0x7f807604,%eax
    2636:	9f                   	lahf
    2637:	04 98                	add    $0x98,%al
    2639:	3d da 3d 04 76       	cmp    $0x76043dda,%eax
    263e:	80 7f 9f 00          	cmpb   $0x0,-0x61(%rdi)
    2642:	04 89                	add    $0x89,%al
    2644:	2d 8c 2d 01 55       	sub    $0x55012d8c,%eax
    2649:	04 8c                	add    $0x8c,%al
    264b:	2d a0 2d 03 76       	sub    $0x76032da0,%eax
    2650:	f0 7e 04             	lock jle 2657 <_license+0x764>
    2653:	9b                   	fwait
    2654:	3c 91                	cmp    $0x91,%al
    2656:	3d 03 76 f0 7e       	cmp    $0x7ef07603,%eax
    265b:	04 98                	add    $0x98,%al
    265d:	3d d6 3d 03 76       	cmp    $0x76033dd6,%eax
    2662:	f0 7e 04             	lock jle 2669 <_license+0x776>
    2665:	d6                   	(bad)
    2666:	3d da 3d 01 55       	cmp    $0x55013dda,%eax
    266b:	00 04 8c             	add    %al,(%rsp,%rcx,4)
    266e:	2d a0 2d 01 50       	sub    $0x50012da0,%eax
    2673:	04 9b                	add    $0x9b,%al
    2675:	3c b3                	cmp    $0xb3,%al
    2677:	3c 01                	cmp    $0x1,%al
    2679:	50                   	push   %rax
    267a:	04 e5                	add    $0xe5,%al
    267c:	3c f2                	cmp    $0xf2,%al
    267e:	3c 01                	cmp    $0x1,%al
    2680:	50                   	push   %rax
    2681:	00 04 a0             	add    %al,(%rax,%riz,4)
    2684:	2d aa 2d 03 11       	sub    $0x11032daa,%eax
    2689:	01 9f 04 e7 3c 98    	add    %ebx,-0x67c318fc(%rdi)
    268f:	3d 03 11 01 9f       	cmp    $0x9f011103,%eax
    2694:	00 04 d2             	add    %al,(%rdx,%rdx,8)
    2697:	2d 97 2e 04 76       	sub    $0x76042e97,%eax
    269c:	80 7f 9f 04          	cmpb   $0x4,-0x61(%rdi)
    26a0:	9b                   	fwait
    26a1:	2e c6                	cs (bad)
    26a3:	2e 04 76             	cs add $0x76,%al
    26a6:	80 7f 9f 00          	cmpb   $0x0,-0x61(%rdi)
    26aa:	04 e4                	add    $0xe4,%al
    26ac:	2d e6 2d 01 55       	sub    $0x55012de6,%eax
    26b1:	04 e6                	add    $0xe6,%al
    26b3:	2d 97 2e 03 76       	sub    $0x76032e97,%eax
    26b8:	f0 7e 04             	lock jle 26bf <_license+0x7cc>
    26bb:	9b                   	fwait
    26bc:	2e c6                	cs (bad)
    26be:	2e 03 76 f0          	cs add -0x10(%rsi),%esi
    26c2:	7e 00                	jle    26c4 <_license+0x7d1>
    26c4:	04 d2                	add    $0xd2,%al
    26c6:	2d 97 2e 02 30       	sub    $0x30022e97,%eax
    26cb:	9f                   	lahf
    26cc:	04 9b                	add    $0x9b,%al
    26ce:	2e c6                	cs (bad)
    26d0:	2e 02 30             	cs add (%rax),%dh
    26d3:	9f                   	lahf
    26d4:	00 04 e6             	add    %al,(%rsi,%riz,8)
    26d7:	2d f4 2d 01 50       	sub    $0x50012df4,%eax
    26dc:	04 f4                	add    $0xf4,%al
    26de:	2d 93 2e 01 53       	sub    $0x53012e93,%eax
    26e3:	04 9b                	add    $0x9b,%al
    26e5:	2e a3 2e 01 53 00 04 	cs movabs %eax,0x932dfd040053012e
    26ec:	fd 2d 93 
    26ef:	2e 01 50 04          	cs add %edx,0x4(%rax)
    26f3:	9b                   	fwait
    26f4:	2e 9f                	cs lahf
    26f6:	2e 01 50 00          	cs add %edx,0x0(%rax)
    26fa:	04 a1                	add    $0xa1,%al
    26fc:	2e b0 2e             	cs mov $0x2e,%al
    26ff:	01 50 00             	add    %edx,0x0(%rax)
    2702:	04 a1                	add    $0xa1,%al
    2704:	2e b0 2e             	cs mov $0x2e,%al
    2707:	01 50 00             	add    %edx,0x0(%rax)
    270a:	04 ac                	add    $0xac,%al
    270c:	2e c6                	cs (bad)
    270e:	2e 02 30             	cs add (%rax),%dh
    2711:	9f                   	lahf
    2712:	00 04 ca             	add    %al,(%rdx,%rcx,8)
    2715:	2e d4                	cs (bad)
    2717:	2e 02 76 50          	cs add 0x50(%rsi),%dh
    271b:	04 d4                	add    $0xd4,%al
    271d:	2e fa                	cs cli
    271f:	2e 01 50 04          	cs add %edx,0x4(%rax)
    2723:	fa                   	cli
    2724:	2e 9f                	cs lahf
    2726:	30 02                	xor    %al,(%rdx)
    2728:	76 50                	jbe    277a <_license+0x887>
    272a:	00 04 de             	add    %al,(%rsi,%rbx,8)
    272d:	2e e5 2e             	cs in  $0x2e,%eax
    2730:	04 10                	add    $0x10,%al
    2732:	82                   	(bad)
    2733:	04 9f                	add    $0x9f,%al
    2735:	04 e5                	add    $0xe5,%al
    2737:	2e c0 2f 02          	cs shrb $0x2,(%rdi)
    273b:	76 40                	jbe    277d <_license+0x88a>
    273d:	00 04 e5 2e fc 2e 02 	add    %al,0x22efc2e(,%riz,8)
    2744:	30 9f 04 fc 2e 85    	xor    %bl,-0x7ad103fc(%rdi)
    274a:	2f                   	(bad)
    274b:	01 50 00             	add    %edx,0x0(%rax)
    274e:	04 fc                	add    $0xfc,%al
    2750:	2e 8f                	cs (bad)
    2752:	2f                   	(bad)
    2753:	01 50 04             	add    %edx,0x4(%rax)
    2756:	8f                   	(bad)
    2757:	2f                   	(bad)
    2758:	c0 2f 01             	shrb   $0x1,(%rdi)
    275b:	5e                   	pop    %rsi
    275c:	00 04 c0             	add    %al,(%rax,%rax,8)
    275f:	2f                   	(bad)
    2760:	db 2f                	fldt   (%rdi)
    2762:	02 30                	add    (%rax),%dh
    2764:	9f                   	lahf
    2765:	04 db                	add    $0xdb,%al
    2767:	2f                   	(bad)
    2768:	e0 2f                	loopne 2799 <_license+0x8a6>
    276a:	01 50 00             	add    %edx,0x0(%rax)
    276d:	04 db                	add    $0xdb,%al
    276f:	2f                   	(bad)
    2770:	ea                   	(bad)
    2771:	2f                   	(bad)
    2772:	01 50 00             	add    %edx,0x0(%rax)
    2775:	04 ea                	add    $0xea,%al
    2777:	2f                   	(bad)
    2778:	8b 30                	mov    (%rax),%esi
    277a:	01 50 00             	add    %edx,0x0(%rax)
    277d:	04 ef                	add    $0xef,%al
    277f:	2f                   	(bad)
    2780:	f6 2f                	imulb  (%rdi)
    2782:	04 10                	add    $0x10,%al
    2784:	8f 04 9f             	pop    (%rdi,%rbx,4)
    2787:	04 f6                	add    $0xf6,%al
    2789:	2f                   	(bad)
    278a:	9f                   	lahf
    278b:	30 02                	xor    %al,(%rdx)
    278d:	76 40                	jbe    27cf <_license+0x8dc>
    278f:	00 04 f6             	add    %al,(%rsi,%rsi,8)
    2792:	2f                   	(bad)
    2793:	8d 30                	lea    (%rax),%esi
    2795:	02 30                	add    (%rax),%dh
    2797:	9f                   	lahf
    2798:	04 8d                	add    $0x8d,%al
    279a:	30 96 30 01 50 00    	xor    %dl,0x500130(%rsi)
    27a0:	04 8d                	add    $0x8d,%al
    27a2:	30 9f 30 01 50 00    	xor    %bl,0x500130(%rdi)
    27a8:	04 ac                	add    $0xac,%al
    27aa:	30 c7                	xor    %al,%bh
    27ac:	30 02                	xor    %al,(%rdx)
    27ae:	30 9f 04 c7 30 d5    	xor    %bl,-0x2acf38fc(%rdi)
    27b4:	30 01                	xor    %al,(%rcx)
    27b6:	50                   	push   %rax
    27b7:	00 04 e5 30 c4 32 01 	add    %al,0x132c430(,%riz,8)
    27be:	5c                   	pop    %rsp
    27bf:	04 9e                	add    $0x9e,%al
    27c1:	35 b9 36 01 5c       	xor    $0x5c0136b9,%eax
    27c6:	00 04 ed 30 fe 30 02 	add    %al,0x230fe30(,%rbp,8)
    27cd:	30 9f 04 fe 30 87    	xor    %bl,-0x78cf01fc(%rdi)
    27d3:	31 01                	xor    %eax,(%rcx)
    27d5:	50                   	push   %rax
    27d6:	00 04 a7             	add    %al,(%rdi,%riz,4)
    27d9:	31 b7 32 02 76 50    	xor    %esi,0x50760232(%rdi)
    27df:	04 b7                	add    $0xb7,%al
    27e1:	32 b9 32 01 52 04    	xor    0x4520132(%rcx),%bh
    27e7:	b9 32 fa 32 02       	mov    $0x232fa32,%ecx
    27ec:	76 50                	jbe    283e <_license+0x94b>
    27ee:	00 04 a7             	add    %al,(%rdi,%riz,4)
    27f1:	31 c4                	xor    %eax,%esp
    27f3:	32 12                	xor    (%rdx),%dl
    27f5:	7c 00                	jl     27f7 <_license+0x904>
    27f7:	10 ff                	adc    %bh,%bh
    27f9:	ff 03                	incl   (%rbx)
    27fb:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
    2801:	a8 b0                	test   $0xb0,%al
    2803:	80 80 00 9f 00 04 f8 	addb   $0xf8,0x4009f00(%rax)
    280a:	31 f1                	xor    %esi,%ecx
    280c:	32 0e                	xor    (%rsi),%cl
    280e:	7e 00                	jle    2810 <_license+0x91d>
    2810:	10 ff                	adc    %bh,%bh
    2812:	ff                   	(bad)
    2813:	ff                   	(bad)
    2814:	ff 0f                	decl   (%rdi)
    2816:	1a 10                	sbb    (%rax),%dl
    2818:	ac                   	lods   %ds:(%rsi),%al
    2819:	21 21                	and    %esp,(%rcx)
    281b:	9f                   	lahf
    281c:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    281f:	31 fa                	xor    %edi,%edx
    2821:	32 02                	xor    (%rdx),%al
    2823:	30 9f 00 04 c9 31    	xor    %bl,0x31c90400(%rdi)
    2829:	fa                   	cli
    282a:	32 01                	xor    (%rcx),%al
    282c:	50                   	push   %rax
    282d:	00 04 cd 31 ed 31 01 	add    %al,0x131ed31(,%rcx,8)
    2834:	52                   	push   %rdx
    2835:	00 04 cd 31 fa 32 01 	add    %al,0x132fa31(,%rcx,8)
    283c:	50                   	push   %rax
    283d:	00 04 d1             	add    %al,(%rcx,%rdx,8)
    2840:	31 de                	xor    %ebx,%esi
    2842:	31 01                	xor    %eax,(%rcx)
    2844:	51                   	push   %rcx
    2845:	00 04 d1             	add    %al,(%rcx,%rdx,8)
    2848:	31 fa                	xor    %edi,%edx
    284a:	32 03                	xor    (%rbx),%al
    284c:	70 14                	jo     2862 <_license+0x96f>
    284e:	9f                   	lahf
    284f:	00 04 b9             	add    %al,(%rcx,%rdi,4)
    2852:	32 f1                	xor    %cl,%dh
    2854:	32 0e                	xor    (%rsi),%cl
    2856:	7e 00                	jle    2858 <_license+0x965>
    2858:	10 ff                	adc    %bh,%bh
    285a:	ff                   	(bad)
    285b:	ff                   	(bad)
    285c:	ff 0f                	decl   (%rdi)
    285e:	1a 10                	sbb    (%rax),%dl
    2860:	ac                   	lods   %ds:(%rsi),%al
    2861:	21 21                	and    %esp,(%rcx)
    2863:	9f                   	lahf
    2864:	00 04 b9             	add    %al,(%rcx,%rdi,4)
    2867:	32 c4                	xor    %ah,%al
    2869:	32 01                	xor    (%rcx),%al
    286b:	5c                   	pop    %rsp
    286c:	00 04 e1             	add    %al,(%rcx,%riz,8)
    286f:	32 e5                	xor    %ch,%ah
    2871:	32 03                	xor    (%rbx),%al
    2873:	11 00                	adc    %eax,(%rax)
    2875:	9f                   	lahf
    2876:	04 e5                	add    $0xe5,%al
    2878:	32 e9                	xor    %cl,%ch
    287a:	32 03                	xor    (%rbx),%al
    287c:	11 01                	adc    %eax,(%rcx)
    287e:	9f                   	lahf
    287f:	04 e9                	add    $0xe9,%al
    2881:	32 ed                	xor    %ch,%ch
    2883:	32 03                	xor    (%rbx),%al
    2885:	11 04 9f             	adc    %eax,(%rdi,%rbx,4)
    2888:	04 ed                	add    $0xed,%al
    288a:	32 f1                	xor    %cl,%dh
    288c:	32 03                	xor    (%rbx),%al
    288e:	11 07                	adc    %eax,(%rdi)
    2890:	9f                   	lahf
    2891:	04 f1                	add    $0xf1,%al
    2893:	32 f7                	xor    %bh,%dh
    2895:	32 03                	xor    (%rbx),%al
    2897:	11 08                	adc    %ecx,(%rax)
    2899:	9f                   	lahf
    289a:	04 f7                	add    $0xf7,%al
    289c:	32 fa                	xor    %dl,%bh
    289e:	32 03                	xor    (%rbx),%al
    28a0:	11 09                	adc    %ecx,(%rcx)
    28a2:	9f                   	lahf
    28a3:	00 04 e1             	add    %al,(%rcx,%riz,8)
    28a6:	32 e5                	xor    %ch,%ah
    28a8:	32 05 70 0e 23 02    	xor    0x2230e70(%rip),%al        # 223371e <_license+0x223182b>
    28ae:	9f                   	lahf
    28af:	04 e5                	add    $0xe5,%al
    28b1:	32 e9                	xor    %cl,%ch
    28b3:	32 05 70 0e 23 04    	xor    0x4230e70(%rip),%al        # 4233729 <_license+0x4231836>
    28b9:	9f                   	lahf
    28ba:	04 e9                	add    $0xe9,%al
    28bc:	32 ed                	xor    %ch,%ch
    28be:	32 05 70 0e 23 0a    	xor    0xa230e70(%rip),%al        # a233734 <_license+0xa231841>
    28c4:	9f                   	lahf
    28c5:	04 ed                	add    $0xed,%al
    28c7:	32 f1                	xor    %cl,%dh
    28c9:	32 05 70 0e 23 10    	xor    0x10230e70(%rip),%al        # 1023373f <_license+0x1023184c>
    28cf:	9f                   	lahf
    28d0:	04 f1                	add    $0xf1,%al
    28d2:	32 f7                	xor    %bh,%dh
    28d4:	32 05 70 0e 23 12    	xor    0x12230e70(%rip),%al        # 1223374a <_license+0x12231857>
    28da:	9f                   	lahf
    28db:	04 f7                	add    $0xf7,%al
    28dd:	32 fa                	xor    %dl,%bh
    28df:	32 07                	xor    (%rdi),%al
    28e1:	70 0e                	jo     28f1 <_license+0x9fe>
    28e3:	23 12                	and    (%rdx),%edx
    28e5:	23 02                	and    (%rdx),%eax
    28e7:	9f                   	lahf
    28e8:	00 04 fd 33 84 34 04 	add    %al,0x4348433(,%rdi,8)
    28ef:	10 81 04 9f 04 84    	adc    %al,-0x7bfb60fc(%rcx)
    28f5:	34 b4                	xor    $0xb4,%al
    28f7:	34 02                	xor    $0x2,%al
    28f9:	76 40                	jbe    293b <_license+0xa48>
    28fb:	00 04 84             	add    %al,(%rsp,%rax,4)
    28fe:	34 9b                	xor    $0x9b,%al
    2900:	34 02                	xor    $0x2,%al
    2902:	30 9f 04 9b 34 a4    	xor    %bl,-0x5bcb64fc(%rdi)
    2908:	34 01                	xor    $0x1,%al
    290a:	50                   	push   %rax
    290b:	00 04 9b             	add    %al,(%rbx,%rbx,4)
    290e:	34 b4                	xor    $0xb4,%al
    2910:	34 01                	xor    $0x1,%al
    2912:	50                   	push   %rax
    2913:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    2916:	34 9e                	xor    $0x9e,%al
    2918:	35 04 76 80 7f       	xor    $0x7f807604,%eax
    291d:	9f                   	lahf
    291e:	04 e7                	add    $0xe7,%al
    2920:	36 c5 38 04          	(bad)
    2924:	76 80                	jbe    28a6 <_license+0x9b3>
    2926:	7f 9f                	jg     28c7 <_license+0x9d4>
    2928:	04 af                	add    $0xaf,%al
    292a:	39 f9                	cmp    %edi,%ecx
    292c:	39 04 76             	cmp    %eax,(%rsi,%rsi,2)
    292f:	80 7f 9f 00          	cmpb   $0x0,-0x61(%rdi)
    2933:	04 b4                	add    $0xb4,%al
    2935:	34 9e                	xor    $0x9e,%al
    2937:	35 02 76 50 04       	xor    $0x4507602,%eax
    293c:	e7 36                	out    %eax,$0x36
    293e:	81 37 02 76 50 04    	xorl   $0x4507602,(%rdi)
    2944:	81 37 8f 37 01 52    	xorl   $0x5201378f,(%rdi)
    294a:	04 8f                	add    $0x8f,%al
    294c:	37                   	(bad)
    294d:	8e 38                	mov    (%rax),%?
    294f:	02 76 50             	add    0x50(%rsi),%dh
    2952:	04 8e                	add    $0x8e,%al
    2954:	38 93 38 01 51 04    	cmp    %dl,0x4510138(%rbx)
    295a:	93                   	xchg   %eax,%ebx
    295b:	38 c5                	cmp    %al,%ch
    295d:	38 02                	cmp    %al,(%rdx)
    295f:	76 50                	jbe    29b1 <_license+0xabe>
    2961:	04 af                	add    $0xaf,%al
    2963:	39 bd 39 02 76 50    	cmp    %edi,0x50760239(%rbp)
    2969:	04 bd                	add    $0xbd,%al
    296b:	39 bf 39 01 52 04    	cmp    %edi,0x4520139(%rdi)
    2971:	bf 39 f9 39 02       	mov    $0x239f939,%edi
    2976:	76 50                	jbe    29c8 <_license+0xad5>
    2978:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    297b:	34 9e                	xor    $0x9e,%al
    297d:	35 02 30 9f 04       	xor    $0x49f3002,%eax
    2982:	e7 36                	out    %eax,$0x36
    2984:	c5 38 02             	(bad)
    2987:	30 9f 04 af 39 f9    	xor    %bl,-0x6c650fc(%rdi)
    298d:	39 02                	cmp    %eax,(%rdx)
    298f:	30 9f 00 04 b4 34    	xor    %bl,0x34b40400(%rdi)
    2995:	9e                   	sahf
    2996:	35 03 76 f0 7e       	xor    $0x7ef07603,%eax
    299b:	04 e7                	add    $0xe7,%al
    299d:	36 c5 38 03          	(bad)
    29a1:	76 f0                	jbe    2993 <_license+0xaa0>
    29a3:	7e 04                	jle    29a9 <_license+0xab6>
    29a5:	af                   	scas   %es:(%rdi),%eax
    29a6:	39 f1                	cmp    %esi,%ecx
    29a8:	39 03                	cmp    %eax,(%rbx)
    29aa:	76 f0                	jbe    299c <_license+0xaa9>
    29ac:	7e 04                	jle    29b2 <_license+0xabf>
    29ae:	f1                   	int1
    29af:	39 f5                	cmp    %esi,%ebp
    29b1:	39 01                	cmp    %eax,(%rcx)
    29b3:	55                   	push   %rbp
    29b4:	00 04 c4             	add    %al,(%rsp,%rax,8)
    29b7:	34 9e                	xor    $0x9e,%al
    29b9:	35 02 30 9f 04       	xor    $0x49f3002,%eax
    29be:	e7 36                	out    %eax,$0x36
    29c0:	fd                   	std
    29c1:	36 02 30             	ss add (%rax),%dh
    29c4:	9f                   	lahf
    29c5:	04 fd                	add    $0xfd,%al
    29c7:	36 c5 38 11          	(bad)
    29cb:	7f 00                	jg     29cd <_license+0xada>
    29cd:	10 ff                	adc    %bh,%bh
    29cf:	01 1a                	add    %ebx,(%rdx)
    29d1:	a8 b5                	test   $0xb5,%al
    29d3:	80 80 00 a8 ba 80 80 	addb   $0x80,-0x7f455800(%rax)
    29da:	00 9f 04 af 39 c7    	add    %bl,-0x38c650fc(%rdi)
    29e0:	39 11                	cmp    %edx,(%rcx)
    29e2:	7f 00                	jg     29e4 <_license+0xaf1>
    29e4:	10 ff                	adc    %bh,%bh
    29e6:	01 1a                	add    %ebx,(%rdx)
    29e8:	a8 b5                	test   $0xb5,%al
    29ea:	80 80 00 a8 ba 80 80 	addb   $0x80,-0x7f455800(%rax)
    29f1:	00 9f 00 04 c4 34    	add    %bl,0x34c40400(%rdi)
    29f7:	9e                   	sahf
    29f8:	35 02 30 9f 04       	xor    $0x49f3002,%eax
    29fd:	e7 36                	out    %eax,$0x36
    29ff:	c5 38 02             	(bad)
    2a02:	30 9f 04 af 39 f9    	xor    %bl,-0x6c650fc(%rdi)
    2a08:	39 02                	cmp    %eax,(%rdx)
    2a0a:	30 9f 00 04 c4 34    	xor    %bl,0x34c40400(%rdi)
    2a10:	9e                   	sahf
    2a11:	35 02 30 9f 04       	xor    $0x49f3002,%eax
    2a16:	e7 36                	out    %eax,$0x36
    2a18:	c5 38 02             	(bad)
    2a1b:	30 9f 04 af 39 d4    	xor    %bl,-0x2bc650fc(%rdi)
    2a21:	39 02                	cmp    %eax,(%rdx)
    2a23:	30 9f 04 d4 39 d8    	xor    %bl,-0x27c62bfc(%rdi)
    2a29:	39 01                	cmp    %eax,(%rcx)
    2a2b:	50                   	push   %rax
    2a2c:	00 04 c4             	add    %al,(%rsp,%rax,8)
    2a2f:	34 cb                	xor    $0xcb,%al
    2a31:	34 04                	xor    $0x4,%al
    2a33:	10 82 04 9f 04 cb    	adc    %al,-0x34fb60fc(%rdx)
    2a39:	34 9e                	xor    $0x9e,%al
    2a3b:	35 03 76 b8 7f       	xor    $0x7fb87603,%eax
    2a40:	04 e7                	add    $0xe7,%al
    2a42:	36 fa                	ss cli
    2a44:	36 03 76 b8          	ss add -0x48(%rsi),%esi
    2a48:	7f 00                	jg     2a4a <_license+0xb57>
    2a4a:	04 cb                	add    $0xcb,%al
    2a4c:	34 e2                	xor    $0xe2,%al
    2a4e:	34 02                	xor    $0x2,%al
    2a50:	30 9f 04 e2 34 ee    	xor    %bl,-0x11cb1dfc(%rdi)
    2a56:	34 01                	xor    $0x1,%al
    2a58:	50                   	push   %rax
    2a59:	00 04 e2             	add    %al,(%rdx,%riz,8)
    2a5c:	34 f8                	xor    $0xf8,%al
    2a5e:	34 01                	xor    $0x1,%al
    2a60:	50                   	push   %rax
    2a61:	04 f8                	add    $0xf8,%al
    2a63:	34 9e                	xor    $0x9e,%al
    2a65:	35 01 53 04 e7       	xor    $0xe7045301,%eax
    2a6a:	36 fa                	ss cli
    2a6c:	36 01 53 00          	ss add %edx,0x0(%rbx)
    2a70:	04 bb                	add    $0xbb,%al
    2a72:	35 b9 36 01 50       	xor    $0x500136b9,%eax
    2a77:	00 04 bf             	add    %al,(%rdi,%rdi,4)
    2a7a:	35 e3 35 01 52       	xor    $0x520135e3,%eax
    2a7f:	00 04 bf             	add    %al,(%rdi,%rdi,4)
    2a82:	35 b9 36 01 50       	xor    $0x500136b9,%eax
    2a87:	00 04 c3             	add    %al,(%rbx,%rax,8)
    2a8a:	35 d0 35 01 51       	xor    $0x510135d0,%eax
    2a8f:	00 04 c3             	add    %al,(%rbx,%rax,8)
    2a92:	35 b9 36 03 70       	xor    $0x700336b9,%eax
    2a97:	28 9f 00 04 8e 36    	sub    %bl,0x368e0400(%rdi)
    2a9d:	b9 36 02 34 9f       	mov    $0x9f340236,%ecx
    2aa2:	00 04 8e             	add    %al,(%rsi,%rcx,4)
    2aa5:	36 91                	ss xchg %eax,%ecx
    2aa7:	36 0c 31             	ss or  $0x31,%al
    2aaa:	9f                   	lahf
    2aab:	93                   	xchg   %eax,%ebx
    2aac:	04 30                	add    $0x30,%al
    2aae:	9f                   	lahf
    2aaf:	93                   	xchg   %eax,%ebx
    2ab0:	04 30                	add    $0x30,%al
    2ab2:	9f                   	lahf
    2ab3:	93                   	xchg   %eax,%ebx
    2ab4:	04 04                	add    $0x4,%al
    2ab6:	91                   	xchg   %eax,%ecx
    2ab7:	36 b9 36 0f 31 9f    	ss mov $0x9f310f36,%ecx
    2abd:	93                   	xchg   %eax,%ebx
    2abe:	04 30                	add    $0x30,%al
    2ac0:	9f                   	lahf
    2ac1:	93                   	xchg   %eax,%ebx
    2ac2:	04 30                	add    $0x30,%al
    2ac4:	9f                   	lahf
    2ac5:	93                   	xchg   %eax,%ebx
    2ac6:	04 52                	add    $0x52,%al
    2ac8:	93                   	xchg   %eax,%ebx
    2ac9:	04 00                	add    $0x0,%al
    2acb:	04 91                	add    $0x91,%al
    2acd:	36 b9 36 01 5c 00    	ss mov $0x5c0136,%ecx
    2ad3:	04 94                	add    $0x94,%al
    2ad5:	36 a8 36             	ss test $0x36,%al
    2ad8:	01 53 00             	add    %edx,0x0(%rbx)
    2adb:	04 a5                	add    $0xa5,%al
    2add:	37                   	(bad)
    2ade:	a2 38 04 76 80 7f 9f 	movabs %al,0x4009f7f80760438
    2ae5:	00 04 
    2ae7:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2ae8:	37                   	(bad)
    2ae9:	a2 38 02 30 9f 00 04 	movabs %al,0x37a504009f300238
    2af0:	a5 37 
    2af2:	b3 37                	mov    $0x37,%bl
    2af4:	01 51 00             	add    %edx,0x0(%rcx)
    2af7:	04 b3                	add    $0xb3,%al
    2af9:	37                   	(bad)
    2afa:	eb 37                	jmp    2b33 <_license+0xc40>
    2afc:	01 51 00             	add    %edx,0x0(%rcx)
    2aff:	04 ad                	add    $0xad,%al
    2b01:	37                   	(bad)
    2b02:	f2 37                	repnz (bad)
    2b04:	01 54 00 04          	add    %edx,0x4(%rax,%rax,1)
    2b08:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2b09:	37                   	(bad)
    2b0a:	ad                   	lods   %ds:(%rsi),%eax
    2b0b:	37                   	(bad)
    2b0c:	02 30                	add    (%rax),%dh
    2b0e:	9f                   	lahf
    2b0f:	04 ad                	add    $0xad,%al
    2b11:	37                   	(bad)
    2b12:	bb 37 0c 10 f7       	mov    $0xf7100c37,%ebx
    2b17:	81 b7 85 fe ff ff ff 	xorl   $0x9f01ffff,-0x17b(%rdi)
    2b1e:	ff 01 9f 
    2b21:	04 bb                	add    $0xbb,%al
    2b23:	37                   	(bad)
    2b24:	8a 38                	mov    (%rax),%bh
    2b26:	01 52 00             	add    %edx,0x0(%rdx)
    2b29:	04 8a                	add    $0x8a,%al
    2b2b:	38 a4 38 01 52 00 04 	cmp    %ah,0x4005201(%rax,%rdi,1)
    2b32:	9a                   	(bad)
    2b33:	38 ae 38 01 51 04    	cmp    %ch,0x4510138(%rsi)
    2b39:	ae                   	scas   %es:(%rdi),%al
    2b3a:	38 b5 38 01 52 04    	cmp    %dh,0x4520138(%rbp)
    2b40:	b5 38                	mov    $0x38,%ch
    2b42:	c5 38 01             	(bad)
    2b45:	53                   	push   %rbx
    2b46:	04 af                	add    $0xaf,%al
    2b48:	39 f9                	cmp    %edi,%ecx
    2b4a:	39 01                	cmp    %eax,(%rcx)
    2b4c:	53                   	push   %rbx
    2b4d:	00 04 9a             	add    %al,(%rdx,%rbx,4)
    2b50:	38 a0 38 02 30 9f    	cmp    %ah,-0x60cffdc8(%rax)
    2b56:	00 04 bd 38 c3 38 02 	add    %al,0x238c338(,%rdi,4)
    2b5d:	30 9f 00 04 83 3a    	xor    %bl,0x3a830400(%rdi)
    2b63:	c2 3a 04             	ret    $0x43a
    2b66:	75 80                	jne    2ae8 <_license+0xbf5>
    2b68:	02 9f 00 04 b4 3a    	add    0x3ab40400(%rdi),%bl
    2b6e:	b8 3a 01 58 04       	mov    $0x458013a,%eax
    2b73:	b8 3a db 3a 02       	mov    $0x23adb3a,%eax
    2b78:	76 40                	jbe    2bba <_license+0xcc7>
    2b7a:	00 04 b8             	add    %al,(%rax,%rdi,4)
    2b7d:	3a cf                	cmp    %bh,%cl
    2b7f:	3a 02                	cmp    (%rdx),%al
    2b81:	30 9f 04 cf 3a d8    	xor    %bl,-0x27c530fc(%rdi)
    2b87:	3a 01                	cmp    (%rcx),%al
    2b89:	50                   	push   %rax
    2b8a:	00 04 cf             	add    %al,(%rdi,%rcx,8)
    2b8d:	3a db                	cmp    %bl,%bl
    2b8f:	3a 01                	cmp    (%rcx),%al
    2b91:	50                   	push   %rax
    2b92:	00 04 a2             	add    %al,(%rdx,%riz,4)
    2b95:	3b b9 3b 02 30 9f    	cmp    -0x60cffdc5(%rcx),%edi
    2b9b:	04 b9                	add    $0xb9,%al
    2b9d:	3b be 3b 01 50 00    	cmp    0x50013b(%rsi),%edi
    2ba3:	04 b9                	add    $0xb9,%al
    2ba5:	3b c5                	cmp    %ebp,%eax
    2ba7:	3b 01                	cmp    (%rcx),%eax
    2ba9:	50                   	push   %rax
    2baa:	00 04 96             	add    %al,(%rsi,%rdx,4)
    2bad:	3c 9b                	cmp    $0x9b,%al
    2baf:	3c 01                	cmp    $0x1,%al
    2bb1:	5e                   	pop    %rsi
    2bb2:	00 04 9b             	add    %al,(%rbx,%rbx,4)
    2bb5:	3c a2                	cmp    $0xa2,%al
    2bb7:	3c 04                	cmp    $0x4,%al
    2bb9:	10 82 04 9f 04 a2    	adc    %al,-0x5dfb60fc(%rdx)
    2bbf:	3c e5                	cmp    $0xe5,%al
    2bc1:	3c 02                	cmp    $0x2,%al
    2bc3:	76 40                	jbe    2c05 <_license+0xd12>
    2bc5:	04 98                	add    $0x98,%al
    2bc7:	3d aa 3d 02 76       	cmp    $0x76023daa,%eax
    2bcc:	40 00 04 a2          	rex add %al,(%rdx,%riz,4)
    2bd0:	3c b3                	cmp    $0xb3,%al
    2bd2:	3c 02                	cmp    $0x2,%al
    2bd4:	30 9f 04 b3 3c bc    	xor    %bl,-0x43c34cfc(%rdi)
    2bda:	3c 01                	cmp    $0x1,%al
    2bdc:	50                   	push   %rax
    2bdd:	00 04 b3             	add    %al,(%rbx,%rsi,4)
    2be0:	3c c6                	cmp    $0xc6,%al
    2be2:	3c 01                	cmp    $0x1,%al
    2be4:	50                   	push   %rax
    2be5:	04 c6                	add    $0xc6,%al
    2be7:	3c e5                	cmp    $0xe5,%al
    2be9:	3c 01                	cmp    $0x1,%al
    2beb:	5e                   	pop    %rsi
    2bec:	04 98                	add    $0x98,%al
    2bee:	3d aa 3d 01 5e       	cmp    $0x5e013daa,%eax
    2bf3:	00 04 f5 3c 8c 3d 02 	add    %al,0x23d8c3c(,%rsi,8)
    2bfa:	30 9f 04 8c 3d 91    	xor    %bl,-0x6ec273fc(%rdi)
    2c00:	3d 01 50 00 04       	cmp    $0x4005001,%eax
    2c05:	8c 3d 98 3d 01 50    	mov    %?,0x50013d98(%rip)        # 500169a3 <_license+0x50014ab0>
    2c0b:	00 04 e8             	add    %al,(%rax,%rbp,8)
    2c0e:	3d ee 3d 01 50       	cmp    $0x50013dee,%eax
    2c13:	04 ee                	add    $0xee,%al
    2c15:	3d f3 3d 03 76       	cmp    $0x76033df3,%eax
    2c1a:	fc                   	cld
    2c1b:	7e 00                	jle    2c1d <_license+0xd2a>

Disassembly of section .debug_abbrev:

0000000000000000 <.debug_abbrev>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	01 11                	add    %edx,(%rcx)
   2:	01 25 25 13 05 03    	add    %esp,0x3051325(%rip)        # 305132d <_license+0x304f43a>
   8:	25 72 17 10 17       	and    $0x17101772,%eax
   d:	1b 25 11 1b 12 06    	sbb    0x6121b11(%rip),%esp        # 6121b24 <_license+0x611fc31>
  13:	73 17                	jae    2c <balancer_ingress+0x2c>
  15:	74 17                	je     2e <balancer_ingress+0x2e>
  17:	8c 01                	mov    %es,(%rcx)
  void* data = (void*)(long)ctx->data;
  19:	17                   	(bad)
  1a:	00 00                	add    %al,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
  1c:	02 24 00             	add    (%rax,%rax,1),%ah
  if (data + nh_off > data_end) {
  1f:	03 26                	add    (%rsi),%esp
  21:	3e 0b 0b             	ds or  (%rbx),%ecx
  24:	0b 00                	or     (%rax),%eax
  26:	00 03                	add    %al,(%rbx)
  28:	34 00                	xor    $0x0,%al
  2a:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f1379 <_license+0x193ef486>
  30:	3a 0b                	cmp    (%rbx),%cl
  32:	3b 05 02 18 00 00    	cmp    0x1802(%rip),%eax        # 183a <balancer_ingress+0x183a>
  eth_proto = eth->h_proto;
  38:	04 01                	add    $0x1,%al
  if (eth_proto == BE_ETH_P_IP) {
  3a:	01 49 13             	add    %ecx,0x13(%rcx)
  3d:	00 00                	add    %al,(%rax)
  3f:	05 21 00 49 13       	add    $0x13490021,%eax
  44:	37                   	(bad)
  45:	0b 00                	or     (%rax),%eax
  47:	00 06                	add    %al,(%rsi)
  49:	24 00                	and    $0x0,%al
  4b:	03 25 3e 0b 0b 0b    	add    0xb0b0b3e(%rip),%esp        # b0b0b8f <_license+0xb0aec9c>
  51:	00 00                	add    %al,(%rax)
  53:	07                   	(bad)
  struct packet_description pckt = {};
  54:	24 00                	and    $0x0,%al
  56:	03 25 0b 0b 3e 0b    	add    0xb3e0b0b(%rip),%esp        # b3e0b67 <_license+0xb3dec74>
  5c:	00 00                	add    %al,(%rax)
  5e:	08 34 00             	or     %dh,(%rax,%rax,1)
  61:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f13b0 <_license+0x193ef4bd>
  67:	3a 0b                	cmp    (%rbx),%cl
  69:	3b 0b                	cmp    (%rbx),%ecx
  6b:	02 18                	add    (%rax),%bl
  6d:	00 00                	add    %al,(%rax)
  6f:	09 13                	or     %edx,(%rbx)
  71:	01 0b                	add    %ecx,(%rbx)
  73:	0b 3a                	or     (%rdx),%edi
  75:	0b 3b                	or     (%rbx),%edi
  77:	0b 00                	or     (%rax),%eax
  79:	00 0a                	add    %cl,(%rdx)
  7b:	0d 00 03 25 49       	or     $0x49250300,%eax
  80:	13 3a                	adc    (%rdx),%edi
  82:	0b 3b                	or     (%rbx),%edi
  struct vip_definition vip = {};
  84:	0b 38                	or     (%rax),%edi
  86:	0b 00                	or     (%rax),%eax
  88:	00 0b                	add    %cl,(%rbx)
  8a:	16                   	(bad)
  8b:	00 49 13             	add    %cl,0x13(%rcx)
  8e:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0bce <_license+0xb3aecdb>
  94:	00 00                	add    %al,(%rax)
  96:	0c 13                	or     $0x13,%al
  98:	01 03                	add    %eax,(%rbx)
  9a:	25 0b 0b 3a 0b       	and    $0xb3a0b0b,%eax
  9f:	3b 0b                	cmp    (%rbx),%ecx
  a1:	00 00                	add    %al,(%rax)
  a3:	0d 0d 00 49 13       	or     $0x1349000d,%eax
    if (iph + 1 > data_end) {
  a8:	3a 0b                	cmp    (%rbx),%cl
  aa:	3b 0b                	cmp    (%rbx),%ecx
  ac:	38 0b                	cmp    %cl,(%rbx)
  ae:	00 00                	add    %al,(%rax)
  b0:	0e                   	(bad)
    if (iph->ihl != 5) {
  b1:	17                   	(bad)
  b2:	01 0b                	add    %ecx,(%rbx)
  b4:	0b 3a                	or     (%rdx),%edi
  b6:	0b 3b                	or     (%rbx),%edi
  b8:	0b 00                	or     (%rax),%eax
  ba:	00 0f                	add    %cl,(%rdi)
  bc:	13 01                	adc    (%rcx),%eax
    pckt->tos = iph->tos;
  be:	0b 05 3a 0b 3b 0b    	or     0xb3b0b3a(%rip),%eax        # b3b0bfe <_license+0xb3aed0b>
    *protocol = iph->protocol;
  c4:	00 00                	add    %al,(%rax)
  c6:	10 0d 00 03 25 49    	adc    %cl,0x49250300(%rip)        # 492503cc <_license+0x4924e4d9>
    if (iph->frag_off & PCKT_FRAGMENTED) {
  cc:	13 3a                	adc    (%rdx),%edi
  ce:	0b 3b                	or     (%rbx),%edi
  d0:	0b 38                	or     (%rax),%edi
  d2:	05 00 00 11 21       	add    $0x21110000,%eax
  d7:	00 49 13             	add    %cl,0x13(%rcx)
  da:	37                   	(bad)
  db:	05 00 00 12 21       	add    $0x21120000,%eax
    if (*protocol == IPPROTO_ICMP) {
  e0:	00 49 13             	add    %cl,0x13(%rcx)
  e3:	00 00                	add    %al,(%rax)
  e5:	13 0f                	adc    (%rdi),%ecx
  e7:	00 49 13             	add    %cl,0x13(%rcx)
  if (icmp_hdr + 1 > data_end) {
  ea:	00 00                	add    %al,(%rax)
  ec:	14 13                	adc    $0x13,%al
  ee:	01 0b                	add    %ecx,(%rbx)
  f0:	06                   	(bad)
  f1:	3a 0b                	cmp    (%rbx),%cl
  f3:	3b 0b                	cmp    (%rbx),%ecx
  f5:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
  f7:	15 0d 00 03 25       	adc    $0x2503000d,%eax
  fc:	49 13 3a             	adc    (%r10),%rdi
  ff:	0b 3b                	or     (%rbx),%edi
 101:	0b 38                	or     (%rax),%edi
 103:	06                   	(bad)
 104:	00 00                	add    %al,(%rax)
 106:	16                   	(bad)
 107:	21 00                	and    %eax,(%rax)
 109:	49 13 37             	adc    (%r15),%rsi
 10c:	06                   	(bad)
 10d:	00 00                	add    %al,(%rax)
 10f:	17                   	(bad)
 110:	34 00                	xor    $0x0,%al
 112:	03 25 49 13 3a 0b    	add    0xb3a1349(%rip),%esp        # b3a1461 <_license+0xb39f56e>
  icmp_hdr->type = ICMP_ECHOREPLY;
 118:	3b 0b                	cmp    (%rbx),%ecx
  icmp_hdr->checksum += 0x0008;
 11a:	00 00                	add    %al,(%rax)
 11c:	18 15 01 49 13 27    	sbb    %dl,0x27134901(%rip)        # 27134a23 <_license+0x27132b30>
  iph->ttl = DEFAULT_TTL;
 122:	19 00                	sbb    %eax,(%rax)
  iph->daddr = iph->saddr;
 124:	00 19                	add    %bl,(%rcx)
 126:	05 00 49 13 00       	add    $0x134900,%eax
  tmp_addr = iph->daddr;
 12b:	00 1a                	add    %bl,(%rdx)
  iph->daddr = iph->saddr;
 12d:	0f 00 00             	sldt   (%rax)
  iph->saddr = tmp_addr;
 130:	00 1b                	add    %bl,(%rbx)
 132:	15 00 49 13 27       	adc    $0x27134900,%eax
 137:	19 00                	sbb    %eax,(%rax)
 139:	00 1c 04             	add    %bl,(%rsp,%rax,1)
 13c:	01 49 13             	add    %ecx,0x13(%rcx)
 13f:	03 25 0b 0b 3a 0b    	add    0xb3a0b0b(%rip),%esp        # b3a0c50 <_license+0xb39ed5d>
 145:	3b 05 00 00 1d 28    	cmp    0x281d0000(%rip),%eax        # 281d014b <_license+0x281ce258>
 14b:	00 03                	add    %al,(%rbx)
 14d:	25 1c 0f 00 00       	and    $0xf1c,%eax
 152:	1e                   	(bad)
 153:	04 01                	add    $0x1,%al
 155:	49 13 0b             	adc    (%r11),%rcx
 158:	0b 3a                	or     (%rdx),%edi
 15a:	0b 3b                	or     (%rbx),%edi
 15c:	0b 00                	or     (%rax),%eax
 15e:	00 1f                	add    %bl,(%rdi)
 160:	2e 01 03             	cs add %eax,(%rbx)
 163:	25 3a 0b 3b 05       	and    $0x53b0b3a,%eax
 168:	27                   	(bad)
    if (csum >> 16)
 169:	19 49 13             	sbb    %ecx,0x13(%rcx)
 16c:	20 21                	and    %ah,(%rcx)
 16e:	01 00                	add    %eax,(%rax)
 170:	00 20                	add    %ah,(%rax)
 172:	05 00 03 25 3a       	add    $0x3a250300,%eax
 177:	0b 3b                	or     (%rbx),%edi
 179:	05 49 13 00 00       	add    $0x1349,%eax
 17e:	21 34 00             	and    %esi,(%rax,%rax,1)
 181:	03 25 3a 0b 3b 05    	add    0x53b0b3a(%rip),%esp        # 53b0cc1 <_license+0x53aedce>
  struct packet_description pckt = {};
 187:	49 13 00             	adc    (%r8),%rax
 18a:	00 22                	add    %ah,(%rdx)
 18c:	0b 01                	or     (%rcx),%eax
 18e:	00 00                	add    %al,(%rax)
 190:	23 13                	and    (%rbx),%edx
 192:	01 03                	add    %eax,(%rbx)
 194:	25 0b 0b 3a 0b       	and    $0xb3a0b0b,%eax
 199:	3b 05 00 00 24 0d    	cmp    0xd240000(%rip),%eax        # d24019f <_license+0xd23e2ac>
 19f:	00 03                	add    %al,(%rbx)
 1a1:	25 49 13 3a 0b       	and    $0xb3a1349,%eax
 1a6:	3b 05 38 0b 00 00    	cmp    0xb38(%rip),%eax        # ce4 <balancer_ingress+0xce4>
 1ac:	25 13 00 03 25       	and    $0x25030013,%eax
 1b1:	3c 19                	cmp    $0x19,%al
 1b3:	00 00                	add    %al,(%rax)
 1b5:	26 26 00 49 13       	es es add %cl,0x13(%rcx)
  struct vip_definition vip = {};
 1ba:	00 00                	add    %al,(%rax)
 1bc:	27                   	(bad)
 1bd:	0d 00 03 25 49       	or     $0x49250300,%eax
 1c2:	13 3a                	adc    (%rdx),%edi
 1c4:	0b 3b                	or     (%rbx),%edi
 1c6:	0b 0b                	or     (%rbx),%ecx
 1c8:	0b 0d 0b 0c 0b 38    	or     0x380b0c0b(%rip),%ecx        # 380b0dd9 <_license+0x380aeee6>
 1ce:	0b 00                	or     (%rax),%eax
 1d0:	00 28                	add    %ch,(%rax)
 1d2:	2e 01 03             	cs add %eax,(%rbx)
 1d5:	25 3a 0b 3b 0b       	and    $0xb3b0b3a,%eax
    if (ip6h + 1 > data_end) {
 1da:	27                   	(bad)
 1db:	19 49 13             	sbb    %ecx,0x13(%rcx)
 1de:	20 21                	and    %ah,(%rcx)
 1e0:	01 00                	add    %eax,(%rax)
 1e2:	00 29                	add    %ch,(%rcx)
    *protocol = ip6h->nexthdr;
 1e4:	05 00 03 25 3a       	add    $0x3a250300,%eax
    pckt->flow.proto = *protocol;
 1e9:	0b 3b                	or     (%rbx),%edi
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1eb:	0b 49 13             	or     0x13(%rcx),%ecx
 1ee:	00 00                	add    %al,(%rax)
 1f0:	2a 34 00             	sub    (%rax,%rax,1),%dh
 1f3:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0d33 <_license+0xb3aee40>
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1f9:	49 13 00             	adc    (%r8),%rax
 1fc:	00 2b                	add    %ch,(%rbx)
 1fe:	2e 01 03             	cs add %eax,(%rbx)
    if (*protocol == IPPROTO_FRAGMENT) {
 201:	25 3a 0b 3b 0b       	and    $0xb3b0b3a,%eax
 206:	27                   	(bad)
 207:	19 20                	sbb    %esp,(%rax)
 209:	21 01                	and    %eax,(%rcx)
 20b:	00 00                	add    %al,(%rax)
 20d:	2c 2e                	sub    $0x2e,%al
 20f:	01 03                	add    %eax,(%rbx)
 211:	26 3a 0b             	es cmp (%rbx),%cl
 214:	3b 0b                	cmp    (%rbx),%ecx
  if (icmp_hdr + 1 > data_end) {
 216:	27                   	(bad)
 217:	19 49 13             	sbb    %ecx,0x13(%rcx)
 21a:	20 21                	and    %ah,(%rcx)
 21c:	01 00                	add    %eax,(%rax)
 21e:	00 2d 34 00 03 26    	add    %ch,0x26030034(%rip)        # 26030258 <_license+0x2602e365>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 224:	3a 0b                	cmp    (%rbx),%cl
 226:	3b 0b                	cmp    (%rbx),%ecx
 228:	49 13 00             	adc    (%r8),%rax
 22b:	00 2e                	add    %ch,(%rsi)
 22d:	13 01                	adc    (%rcx),%eax
 22f:	03 26                	add    (%rsi),%esp
 231:	0b 0b                	or     (%rbx),%ecx
 233:	3a 0b                	cmp    (%rbx),%cl
 235:	3b 0b                	cmp    (%rbx),%ecx
 237:	00 00                	add    %al,(%rax)
 239:	2f                   	(bad)
 23a:	0d 00 03 26 49       	or     $0x49260300,%eax
 23f:	13 3a                	adc    (%rdx),%edi
 241:	0b 3b                	or     (%rbx),%edi
 243:	0b 38                	or     (%rax),%edi
 245:	0b 00                	or     (%rax),%eax
 247:	00 30                	add    %dh,(%rax)
 249:	0d 00 03 26 49       	or     $0x49260300,%eax
 24e:	13 3a                	adc    (%rdx),%edi
 250:	0b 3b                	or     (%rbx),%edi
 252:	0b 0b                	or     (%rbx),%ecx
 254:	0b 0d 0b 0c 0b 38    	or     0x380b0c0b(%rip),%ecx        # 380b0e65 <_license+0x380aef72>
 25a:	0b 00                	or     (%rax),%eax
 25c:	00 31                	add    %dh,(%rcx)
 25e:	2e 01 03             	cs add %eax,(%rbx)
 261:	26 3a 0b             	es cmp (%rbx),%cl
 264:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491b91 <_license+0x1348fc9e>
 26a:	20 21                	and    %ah,(%rcx)
 26c:	01 00                	add    %eax,(%rax)
 26e:	00 32                	add    %dh,(%rdx)
 270:	34 00                	xor    $0x0,%al
 272:	03 26                	add    (%rsi),%esp
 274:	3a 0b                	cmp    (%rbx),%cl
 276:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 15c5 <balancer_ingress+0x15c5>
 27c:	33 2e                	xor    (%rsi),%ebp
 27e:	01 03                	add    %eax,(%rbx)
 280:	26 3a 0b             	es cmp (%rbx),%cl
 283:	3b 0b                	cmp    (%rbx),%ecx
 285:	27                   	(bad)
 286:	19 20                	sbb    %esp,(%rax)
 288:	21 01                	and    %eax,(%rcx)
 28a:	00 00                	add    %al,(%rax)
 28c:	34 05                	xor    $0x5,%al
 28e:	00 03                	add    %al,(%rbx)
 290:	26 3a 0b             	es cmp (%rbx),%cl
 293:	3b 0b                	cmp    (%rbx),%ecx
 295:	49 13 00             	adc    (%r8),%rax
 298:	00 35 2e 01 03 26    	add    %dh,0x2603012e(%rip)        # 260303cc <_license+0x2602e4d9>
 29e:	3a 0b                	cmp    (%rbx),%cl
 2a0:	3b 05 27 19 20 21    	cmp    0x21201927(%rip),%eax        # 21201bcd <_license+0x211ffcda>
 2a6:	01 00                	add    %eax,(%rax)
 2a8:	00 36                	add    %dh,(%rsi)
 2aa:	05 00 03 26 3a       	add    $0x3a260300,%eax
 2af:	0b 3b                	or     (%rbx),%edi
 2b1:	05 49 13 00 00       	add    $0x1349,%eax
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2b6:	37                   	(bad)
 2b7:	26 00 00             	es add %al,(%rax)
 2ba:	00 38                	add    %bh,(%rax)
 2bc:	2e 01 11             	cs add %edx,(%rcx)
 2bf:	1b 12                	sbb    (%rdx),%edx
 2c1:	06                   	(bad)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2c2:	40 18 7a 19          	sbb    %dil,0x19(%rdx)
 2c6:	03 26                	add    (%rsi),%esp
 2c8:	3a 0b                	cmp    (%rbx),%cl
 2ca:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491bf7 <_license+0x1348fd04>
 2d0:	3f                   	(bad)
 2d1:	19 00                	sbb    %eax,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 2d3:	00 39                	add    %bh,(%rcx)
 2d5:	05 00 02 22 03       	add    $0x3220200,%eax
  if (icmp_hdr + 1 > data_end) {
 2da:	26 3a 0b             	es cmp (%rbx),%cl
 2dd:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 162c <balancer_ingress+0x162c>
 2e3:	3a 34 00             	cmp    (%rax,%rax,1),%dh
 2e6:	02 22                	add    (%rdx),%ah
  if (icmp_hdr->type == ICMP_ECHO) {
 2e8:	03 25 3a 0b 3b 05    	add    0x53b0b3a(%rip),%esp        # 53b0e28 <_license+0x53aef35>
 2ee:	49 13 00             	adc    (%r8),%rax
 2f1:	00 3b                	add    %bh,(%rbx)
 2f3:	34 00                	xor    $0x0,%al
 2f5:	02 22                	add    (%rdx),%ah
 2f7:	03 26                	add    (%rsi),%esp
 2f9:	3a 0b                	cmp    (%rbx),%cl
 2fb:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 164a <balancer_ingress+0x164a>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 301:	3c 1d                	cmp    $0x1d,%al
 303:	01 31                	add    %esi,(%rcx)
 305:	13 55 23             	adc    0x23(%rbp),%edx
       sizeof(struct icmphdr)) > data_end) {
 308:	58                   	pop    %rax
 309:	0b 59 05             	or     0x5(%rcx),%ebx
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 30c:	57                   	push   %rdi
 30d:	0b 00                	or     (%rax),%eax
 30f:	00 3d 05 00 02 22    	add    %bh,0x22020005(%rip)        # 2202031a <_license+0x2201e427>
  icmp_hdr->type = ICMP_ECHOREPLY;
 315:	31 13                	xor    %edx,(%rbx)
  icmp_hdr->checksum += 0x0008;
 317:	00 00                	add    %al,(%rax)
 319:	3e 34 00             	ds xor $0x0,%al
  iph->ttl = DEFAULT_TTL;
 31c:	02 18                	add    (%rax),%bl
 31e:	31 13                	xor    %edx,(%rbx)
 320:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
 322:	3f                   	(bad)
 323:	34 00                	xor    $0x0,%al
  tmp_addr = iph->daddr;
 325:	02 22                	add    (%rdx),%ah
 327:	31 13                	xor    %edx,(%rbx)
  iph->daddr = iph->saddr;
 329:	00 00                	add    %al,(%rax)
 32b:	40 1d 01 31 13 11    	rex sbb $0x11133101,%eax
    *csum += *next_iph_u16++;
 331:	1b 12                	sbb    (%rdx),%edx
 333:	06                   	(bad)
 334:	58                   	pop    %rax
 335:	0b 59 05             	or     0x5(%rcx),%ebx
 338:	57                   	push   %rdi
 339:	0b 00                	or     (%rax),%eax
 33b:	00 41 05             	add    %al,0x5(%rcx)
 33e:	00 02                	add    %al,(%rdx)
 340:	18 31                	sbb    %dh,(%rcx)
 342:	13 00                	adc    (%rax),%eax
 344:	00 42 34             	add    %al,0x34(%rdx)
 347:	00 1c 0f             	add    %bl,(%rdi,%rcx,1)
 34a:	31 13                	xor    %edx,(%rbx)
 34c:	00 00                	add    %al,(%rax)
 34e:	43 1d 01 31 13 11    	rex.XB sbb $0x11133101,%eax
 354:	1b 12                	sbb    (%rdx),%edx
 356:	06                   	(bad)
 357:	58                   	pop    %rax
 358:	0b 59 0b             	or     0xb(%rcx),%ebx
 35b:	57                   	push   %rdi
 35c:	0b 00                	or     (%rax),%eax
 35e:	00 44 0b 01          	add    %al,0x1(%rbx,%rcx,1)
 362:	11 1b                	adc    %ebx,(%rbx)
 364:	12 06                	adc    (%rsi),%al
 366:	00 00                	add    %al,(%rax)
 368:	45 34 00             	rex.RB xor $0x0,%al
 36b:	1c 0d                	sbb    $0xd,%al
 36d:	31 13                	xor    %edx,(%rbx)
 36f:	00 00                	add    %al,(%rax)
    if (csum >> 16)
 371:	46 0b 01             	rex.RX or (%rcx),%r8d
 374:	55                   	push   %rbp
 375:	23 00                	and    (%rax),%eax
 377:	00 47 1d             	add    %al,0x1d(%rdi)
 37a:	01 31                	add    %esi,(%rcx)
 37c:	13 55 23             	adc    0x23(%rbp),%edx
 37f:	58                   	pop    %rax
 380:	0b 59 0b             	or     0xb(%rcx),%ebx
 383:	57                   	push   %rdi
 384:	0b 00                	or     (%rax),%eax
 386:	00 48 05             	add    %cl,0x5(%rax)
 389:	00 1c 0f             	add    %bl,(%rdi,%rcx,1)
 38c:	31 13                	xor    %edx,(%rbx)
 38e:	00 00                	add    %al,(%rax)
 390:	49 1d 00 31 13 11    	rex.WB sbb $0x11133100,%rax
 396:	1b 12                	sbb    (%rdx),%edx
 398:	06                   	(bad)
 399:	58                   	pop    %rax
 39a:	0b 59 0b             	or     0xb(%rcx),%ebx
 39d:	57                   	push   %rdi
 39e:	0b 00                	or     (%rax),%eax
 3a0:	00 4a 48             	add    %cl,0x48(%rdx)
 3a3:	00 83 01 18 7d 1b    	add    %al,0x1b7d1801(%rbx)
 3a9:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_info:

0000000000000000 <.debug_info>:
int balancer_ingress(struct xdp_md* ctx) {
       0:	f0 34 00             	lock xor $0x0,%al
       3:	00 05 00 01 08 00    	add    %al,0x80100(%rip)        # 80109 <_license+0x7e216>
       9:	00 00                	add    %al,(%rax)
       b:	00 01                	add    %al,(%rcx)
       d:	00 0c 00             	add    %cl,(%rax,%rax,1)
      10:	01 08                	add    %ecx,(%rax)
      12:	00 00                	add    %al,(%rax)
      14:	00 00                	add    %al,(%rax)
      16:	00 00                	add    %al,(%rax)
  void* data = (void*)(long)ctx->data;
      18:	00 02                	add    %al,(%rdx)
      1a:	12 f3                	adc    %bl,%dh
  void* data_end = (void*)(long)ctx->data_end;
      1c:	1e                   	(bad)
      1d:	00 00                	add    %al,(%rax)
  if (data + nh_off > data_end) {
      1f:	08 00                	or     %al,(%rax)
      21:	00 00                	add    %al,(%rax)
      23:	0c 00                	or     $0x0,%al
      25:	00 00                	add    %al,(%rax)
      27:	0c 00                	or     $0x0,%al
      29:	00 00                	add    %al,(%rax)
      2b:	02 5e 01             	add    0x1(%rsi),%bl
      2e:	07                   	(bad)
      2f:	02 02                	add    (%rdx),%al
      31:	5d                   	pop    %rbp
      32:	01 07                	add    %eax,(%rdi)
  eth_proto = eth->h_proto;
      34:	04 02                	add    $0x2,%al
      36:	5c                   	pop    %rsp
      37:	01 07                	add    %eax,(%rdi)
  if (eth_proto == BE_ETH_P_IP) {
      39:	01 02                	add    %eax,(%rdx)
      3b:	5b                   	pop    %rbx
      3c:	01 07                	add    %eax,(%rdi)
      3e:	01 03                	add    %eax,(%rbx)
      40:	03 4b 00             	add    0x0(%rbx),%ecx
      43:	00 00                	add    %al,(%rax)
      45:	00 4a 04             	add    %cl,0x4(%rdx)
      48:	02 a1 00 04 57 00    	add    0x570400(%rcx),%ah
      4e:	00 00                	add    %al,(%rax)
      50:	05 5b 00 00 00       	add    $0x5b,%eax
  struct packet_description pckt = {};
      55:	04 00                	add    $0x0,%al
      57:	06                   	(bad)
      58:	04 06                	add    $0x6,%al
      5a:	01 07                	add    %eax,(%rdi)
      5c:	05 08 07 08 06       	add    $0x6080708,%eax
      61:	6a 00                	push   $0x0
      63:	00 00                	add    %al,(%rax)
      65:	01 29                	add    %ebp,(%rcx)
      67:	02 a1 01 09 58 01    	add    0x1580901(%rcx),%ah
      6d:	23 0a                	and    (%rdx),%ecx
      6f:	07                   	(bad)
      70:	9c                   	pushf
      71:	00 00                	add    %al,(%rax)
      73:	00 01                	add    %al,(%rcx)
      75:	24 00                	and    $0x0,%al
      77:	0a 09                	or     (%rcx),%cl
      79:	ac                   	lods   %ds:(%rsi),%al
      7a:	00 00                	add    %al,(%rax)
      7c:	00 01                	add    %al,(%rcx)
      7e:	25 08 0a 0c b8       	and    $0xb80c0a08,%eax
      83:	00 00                	add    %al,(%rax)
  struct vip_definition vip = {};
      85:	00 01                	add    %al,(%rcx)
      87:	26 10 0a             	es adc %cl,(%rdx)
      8a:	14 0a                	adc    $0xa,%al
      8c:	01 00                	add    %eax,(%rax)
      8e:	00 01                	add    %al,(%rcx)
      90:	27                   	(bad)
      91:	18 0a                	sbb    %cl,(%rdx)
      93:	15 16 01 00 00       	adc    $0x116,%eax
      98:	01 28                	add    %ebp,(%rax)
      9a:	58                   	pop    %rax
      9b:	00 04 a8             	add    %al,(%rax,%rbp,4)
      9e:	00 00                	add    %al,(%rax)
      a0:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 101 <balancer_ingress+0x101>
    if (iph + 1 > data_end) {
      a6:	02 00                	add    (%rax),%al
      a8:	06                   	(bad)
      a9:	08 05 04 0b b4 00    	or     %al,0xb40b04(%rip)        # b40bb3 <_license+0xb3ecc0>
      af:	00 00                	add    %al,(%rax)
    if (iph->ihl != 5) {
      b1:	0b 02                	or     (%rdx),%eax
      b3:	1b 06                	sbb    (%rsi),%eax
      b5:	0a 07                	or     (%rdi),%al
      b7:	04 0c                	add    $0xc,%al
      b9:	13 08                	adc    (%rax),%ecx
      bb:	03 35 0d c5 00 00    	add    0xc50d(%rip),%esi        # c5ce <_license+0xa6db>
    pckt->tos = iph->tos;
      c1:	00 03                	add    %al,(%rbx)
      c3:	36 00 0e             	ss add %cl,(%rsi)
    *protocol = iph->protocol;
      c6:	08 03                	or     %al,(%rbx)
    pckt->flow.proto = *protocol;
      c8:	36 0a 0c e6          	ss or  (%rsi,%riz,8),%cl
    if (iph->frag_off & PCKT_FRAGMENTED) {
      cc:	00 00                	add    %al,(%rax)
      ce:	00 03                	add    %al,(%rbx)
      d0:	37                   	(bad)
      d1:	00 0a                	add    %cl,(%rdx)
      d3:	0f ac 00 00          	shrd   $0x0,%eax,(%rax)
      d7:	00 03                	add    %al,(%rbx)
      d9:	38 00                	cmp    %al,(%rax)
      db:	0a 10                	or     (%rax),%dl
      dd:	f2 00 00             	repnz add %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
      e0:	00 03                	add    %al,(%rbx)
      e2:	39 00                	cmp    %eax,(%rax)
      e4:	00 00                	add    %al,(%rax)
      e6:	0b ee                	or     %esi,%ebp
      e8:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
      ea:	00 0e                	add    %cl,(%rsi)
      ec:	02 1f                	add    (%rdi),%bl
      ee:	06                   	(bad)
      ef:	0d 07 08 04 fe       	or     $0xfe040807,%eax
      f4:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
      f6:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 157 <balancer_ingress+0x157>
      fc:	06                   	(bad)
      fd:	00 0b                	add    %cl,(%rbx)
      ff:	06                   	(bad)
     100:	01 00                	add    %eax,(%rax)
     102:	00 12                	add    %dl,(%rdx)
     104:	02 15 06 11 08 01    	add    0x1081106(%rip),%dl        # 1081210 <_license+0x107f31d>
     10a:	04 a8                	add    $0xa8,%al
     10c:	00 00                	add    %al,(%rax)
     10e:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 16f <balancer_ingress+0x16f>
  icmp_hdr->type = ICMP_ECHOREPLY;
     114:	10 00                	adc    %al,(%rax)
     116:	04 a8                	add    $0xa8,%al
     118:	00 00                	add    %al,(%rax)
  icmp_hdr->checksum += 0x0008;
     11a:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 17b <balancer_ingress+0x17b>
  iph->ttl = DEFAULT_TTL;
     120:	00 00                	add    %al,(%rax)
     122:	08 16                	or     %dl,(%rsi)
  iph->daddr = iph->saddr;
     124:	2d 01 00 00 04       	sub    $0x4000001,%eax
  tmp_addr = iph->daddr;
     129:	26 02 a1 02 0f 20 08 	es add 0x8200f02(%rcx),%ah
  iph->saddr = tmp_addr;
     130:	04 20                	add    $0x20,%al
     132:	0a 07                	or     (%rdi),%al
    *csum += *next_iph_u16++;
     134:	61                   	(bad)
     135:	01 00                	add    %eax,(%rax)
     137:	00 04 21             	add    %al,(%rcx,%riz,1)
     13a:	00 0a                	add    %cl,(%rdx)
     13c:	09 6d 01             	or     %ebp,0x1(%rbp)
     13f:	00 00                	add    %al,(%rax)
     141:	04 22                	add    $0x22,%al
     143:	04 0a                	add    $0xa,%al
     145:	0c c4                	or     $0xc4,%al
     147:	01 00                	add    %eax,(%rax)
     149:	00 04 23             	add    %al,(%rbx,%riz,1)
     14c:	18 0a                	sbb    %cl,(%rdx)
     14e:	14 dc                	adc    $0xdc,%al
     150:	01 00                	add    %eax,(%rax)
     152:	00 04 24             	add    %al,(%rsp)
     155:	20 10                	and    %dl,(%rax)
     157:	15 16 01 00 00       	adc    $0x116,%eax
     15c:	04 25                	add    $0x25,%al
     15e:	20 08                	and    %cl,(%rax)
     160:	00 04 a8             	add    %al,(%rax,%rbp,4)
     163:	00 00                	add    %al,(%rax)
     165:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 1c6 <balancer_ingress+0x1c6>
    if (csum >> 16)
     16b:	01 00                	add    %eax,(%rax)
     16d:	0c 1e                	or     $0x1e,%al
     16f:	14 03                	adc    $0x3,%al
     171:	3e 0d 7a 01 00 00    	ds or  $0x17a,%eax
     177:	03 3f                	add    (%rdi),%edi
     179:	00 0e                	add    %cl,(%rsi)
     17b:	10 03                	adc    %al,(%rbx)
     17d:	3f                   	(bad)
     17e:	0a 17                	or     (%rdi),%dl
     180:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     181:	01 00                	add    %eax,(%rax)
     183:	00 03                	add    %al,(%rbx)
     185:	40 00 0a             	rex add %cl,(%rdx)
  struct packet_description pckt = {};
     188:	19 ac 01 00 00 03 41 	sbb    %ebp,0x41030000(%rcx,%rax,1)
     18f:	00 00                	add    %al,(%rax)
     191:	0a 1a                	or     (%rdx),%bl
     193:	b8 01 00 00 03       	mov    $0x3000001,%eax
     198:	43 10 0a             	rex.XB adc %cl,(%r10)
     19b:	1d fe 00 00 00       	sbb    $0xfe,%eax
     1a0:	03 44 12 00          	add    0x0(%rdx,%rdx,1),%eax
     1a4:	0b ac 00 00 00 18 05 	or     0x5180000(%rax,%rax,1),%ebp
     1ab:	22 04 a4             	and    (%rsp,%riz,4),%al
     1ae:	01 00                	add    %eax,(%rax)
     1b0:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 211 <balancer_ingress+0x211>
  struct vip_definition vip = {};
     1b6:	04 00                	add    $0x0,%al
     1b8:	0b c0                	or     %eax,%eax
     1ba:	01 00                	add    %eax,(%rax)
     1bc:	00 1c 02             	add    %bl,(%rdx,%rax,1)
     1bf:	18 06                	sbb    %al,(%rsi)
     1c1:	1b 07                	sbb    (%rdi),%eax
     1c3:	02 0c 21             	add    (%rcx,%riz,1),%cl
     1c6:	08 03                	or     %al,(%rbx)
     1c8:	48 0a 1f             	rex.W or (%rdi),%bl
     1cb:	ac                   	lods   %ds:(%rsi),%al
     1cc:	00 00                	add    %al,(%rax)
     1ce:	00 03                	add    %al,(%rbx)
     1d0:	49 00 0a             	rex.WB add %cl,(%r10)
     1d3:	20 ac 00 00 00 03 4a 	and    %ch,0x4a030000(%rax,%rax,1)
    if (ip6h + 1 > data_end) {
     1da:	04 00                	add    $0x0,%al
     1dc:	04 a8                	add    $0xa8,%al
     1de:	00 00                	add    %al,(%rax)
     1e0:	00 11                	add    %dl,(%rcx)
     1e2:	5b                   	pop    %rbx
    *protocol = ip6h->nexthdr;
     1e3:	00 00                	add    %al,(%rax)
     1e5:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
     1e7:	02 00                	add    (%rax),%al
     1e9:	08 22                	or     %ah,(%rdx)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1eb:	f4                   	hlt
     1ec:	01 00                	add    %eax,(%rax)
     1ee:	00 04 2f             	add    %al,(%rdi,%rbp,1)
     1f1:	02 a1 03 0f 00 10    	add    0x10000f03(%rcx),%ah
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1f7:	04 29                	add    $0x29,%al
     1f9:	0a 07                	or     (%rdi),%al
     1fb:	28 02                	sub    %al,(%rdx)
     1fd:	00 00                	add    %al,(%rax)
     1ff:	04 2a                	add    $0x2a,%al
    if (*protocol == IPPROTO_FRAGMENT) {
     201:	00 0a                	add    %cl,(%rdx)
     203:	09 34 02             	or     %esi,(%rdx,%rax,1)
     206:	00 00                	add    %al,(%rax)
     208:	04 2b                	add    $0x2b,%al
     20a:	24 0a                	and    $0xa,%al
     20c:	0c ac                	or     $0xac,%al
     20e:	02 00                	add    (%rax),%al
     210:	00 04 2c             	add    %al,(%rsp,%rbp,1)
     213:	50                   	push   %rax
     214:	0a 14 c4             	or     (%rsp,%rax,8),%dl
  if (icmp_hdr + 1 > data_end) {
     217:	02 00                	add    (%rax),%al
     219:	00 04 2d 60 10 15 16 	add    %al,0x16151060(,%rbp,1)
     220:	01 00                	add    %eax,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     222:	00 04 2e             	add    %al,(%rsi,%rbp,1)
     225:	00 10                	add    %dl,(%rax)
     227:	00 04 a8             	add    %al,(%rax,%rbp,4)
     22a:	00 00                	add    %al,(%rax)
     22c:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 28d <balancer_ingress+0x28d>
     232:	09 00                	or     %eax,(%rax)
     234:	0c 29                	or     $0x29,%al
     236:	28 03                	sub    %al,(%rbx)
     238:	1a 0d 41 02 00 00    	sbb    0x241(%rip),%cl        # 47f <balancer_ingress+0x47f>
     23e:	03 1b                	add    (%rbx),%ebx
     240:	00 0e                	add    %cl,(%rsi)
     242:	10 03                	adc    %al,(%rbx)
     244:	1b 0a                	sbb    (%rdx),%ecx
     246:	23 a4 01 00 00 03 1c 	and    0x1c030000(%rcx,%rax,1),%esp
     24d:	00 0a                	add    %cl,(%rdx)
     24f:	24 ac                	and    $0xac,%al
     251:	01 00                	add    %eax,(%rax)
     253:	00 03                	add    %al,(%rbx)
     255:	1d 00 00 0d 60       	sbb    $0x600d0000,%eax
     25a:	02 00                	add    (%rax),%al
     25c:	00 03                	add    %al,(%rbx)
     25e:	1f                   	(bad)
     25f:	10 0e                	adc    %cl,(%rsi)
     261:	10 03                	adc    %al,(%rbx)
     263:	1f                   	(bad)
     264:	0a 25 a4 01 00 00    	or     0x1a4(%rip),%ah        # 40e <balancer_ingress+0x40e>
     26a:	03 20                	add    (%rax),%esp
     26c:	00 0a                	add    %cl,(%rdx)
     26e:	26 ac                	lods   %ds:(%rsi),%al
     270:	01 00                	add    %eax,(%rax)
     272:	00 03                	add    %al,(%rbx)
     274:	21 00                	and    %eax,(%rax)
     276:	00 0d 7f 02 00 00    	add    %cl,0x27f(%rip)        # 4fb <balancer_ingress+0x4fb>
     27c:	03 23                	add    (%rbx),%esp
     27e:	20 0e                	and    %cl,(%rsi)
     280:	04 03                	add    $0x3,%al
     282:	23 0a                	and    (%rdx),%ecx
     284:	27                   	(bad)
     285:	ac                   	lods   %ds:(%rsi),%al
     286:	00 00                	add    %al,(%rax)
     288:	00 03                	add    %al,(%rbx)
     28a:	24 00                	and    $0x0,%al
     28c:	0a 28                	or     (%rax),%ch
     28e:	a0 02 00 00 03 25 00 	movabs 0xa00002503000002,%al
     295:	00 0a 
     297:	1d fe 00 00 00       	sbb    $0xfe,%eax
     29c:	03 27                	add    (%rdi),%esp
     29e:	24 00                	and    $0x0,%al
     2a0:	04 b8                	add    $0xb8,%al
     2a2:	01 00                	add    %eax,(%rax)
     2a4:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 305 <balancer_ingress+0x305>
     2aa:	02 00                	add    (%rax),%al
     2ac:	0c 2c                	or     $0x2c,%al
     2ae:	10 03                	adc    %al,(%rbx)
     2b0:	4e 0a 2a             	rex.WRX or (%rdx),%r13b
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     2b3:	ac                   	lods   %ds:(%rsi),%al
     2b4:	00 00                	add    %al,(%rax)
     2b6:	00 03                	add    %al,(%rbx)
     2b8:	4f 00 0a             	rex.WRXB add %r9b,(%r10)
     2bb:	2b e6                	sub    %esi,%esp
     2bd:	00 00                	add    %al,(%rax)
     2bf:	00 03                	add    %al,(%rbx)
     2c1:	50                   	push   %rax
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2c2:	08 00                	or     %al,(%rax)
     2c4:	04 a8                	add    $0xa8,%al
     2c6:	00 00                	add    %al,(%rax)
     2c8:	00 11                	add    %dl,(%rcx)
     2ca:	5b                   	pop    %rbx
     2cb:	00 00                	add    %al,(%rax)
     2cd:	00 e8                	add    %ch,%al
     2cf:	03 00                	add    (%rax),%eax
     2d1:	08 2d dc 02 00 00    	or     %ch,0x2dc(%rip)        # 5b3 <balancer_ingress+0x5b3>
  if (protocol == IPPROTO_ICMPV6) {
     2d7:	04 40                	add    $0x40,%al
     2d9:	02 a1 04 0f 38 02    	add    0x2380f04(%rcx),%ah
  if (icmp_hdr + 1 > data_end) {
     2df:	04 32                	add    $0x32,%al
     2e1:	0a 07                	or     (%rdi),%al
     2e3:	44 03 00             	add    (%rax),%r8d
     2e6:	00 04 33             	add    %al,(%rbx,%rsi,1)
  if (icmp_hdr->type == ICMP_ECHO) {
     2e9:	00 0a                	add    %cl,(%rdx)
     2eb:	09 ac 00 00 00 04 34 	or     %ebp,0x34040000(%rax,%rax,1)
     2f2:	30 0a                	xor    %cl,(%rdx)
     2f4:	0c ac                	or     $0xac,%al
     2f6:	00 00                	add    %al,(%rax)
     2f8:	00 04 35 34 0a 14 50 	add    %al,0x50140a34(,%rsi,1)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2ff:	03 00                	add    (%rax),%eax
     301:	00 04 36             	add    %al,(%rsi,%rsi,1)
     304:	38 10                	cmp    %dl,(%rax)
     306:	15 16 01 00 00       	adc    $0x116,%eax
     30b:	04 37                	add    $0x37,%al
     30d:	38 02                	cmp    %al,(%rdx)
     30f:	10 2e                	adc    %ch,(%rsi)
  icmp_hdr->type = ICMP_ECHOREPLY;
     311:	5c                   	pop    %rsp
     312:	03 00                	add    (%rax),%eax
     314:	00 04 38             	add    %al,(%rax,%rdi,1)
  icmp_hdr->checksum += 0x0008;
     317:	38 02                	cmp    %al,(%rdx)
     319:	0f 00 10             	lldt   (%rax)
  iph->ttl = DEFAULT_TTL;
     31c:	04 38                	add    $0x38,%al
     31e:	0a 07                	or     (%rdi),%al
     320:	28 02                	sub    %al,(%rdx)
  iph->daddr = iph->saddr;
     322:	00 00                	add    %al,(%rax)
     324:	04 38                	add    $0x38,%al
  tmp_addr = iph->daddr;
     326:	00 0a                	add    %cl,(%rdx)
     328:	09 34 02             	or     %esi,(%rdx,%rax,1)
  iph->daddr = iph->saddr;
     32b:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
     32d:	04 38                	add    $0x38,%al
     32f:	24 0a                	and    $0xa,%al
    *csum += *next_iph_u16++;
     331:	0c ac                	or     $0xac,%al
     333:	02 00                	add    (%rax),%al
     335:	00 04 38             	add    %al,(%rax,%rdi,1)
     338:	50                   	push   %rax
     339:	0a 14 c4             	or     (%rsp,%rax,8),%dl
     33c:	02 00                	add    (%rax),%al
     33e:	00 04 38             	add    %al,(%rax,%rdi,1)
     341:	60                   	(bad)
     342:	00 00                	add    %al,(%rax)
     344:	04 a8                	add    $0xa8,%al
     346:	00 00                	add    %al,(%rax)
     348:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 3a9 <balancer_ingress+0x3a9>
     34e:	0c 00                	or     $0x0,%al
     350:	04 a8                	add    $0xa8,%al
     352:	00 00                	add    %al,(%rax)
     354:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 3b5 <balancer_ingress+0x3b5>
     35a:	80 00 04             	addb   $0x4,(%rax)
     35d:	67 03 00             	add    (%eax),%eax
     360:	00 12                	add    %dl,(%rdx)
     362:	5b                   	pop    %rbx
     363:	00 00                	add    %al,(%rax)
     365:	00 00                	add    %al,(%rax)
     367:	13 19                	adc    (%rcx),%ebx
     369:	03 00                	add    (%rax),%eax
     36b:	00 08                	add    %cl,(%rax)
     36d:	2f                   	(bad)
     36e:	77 03                	ja     373 <balancer_ingress+0x373>
    if (csum >> 16)
     370:	00 00                	add    %al,(%rax)
     372:	04 49                	add    $0x49,%al
     374:	02 a1 05 14 10 08    	add    0x8101405(%rcx),%ah
     37a:	00 08                	add    %cl,(%rax)
     37c:	04 43                	add    $0x43,%al
     37e:	0a 07                	or     (%rdi),%al
     380:	9c                   	pushf
     381:	00 00                	add    %al,(%rax)
     383:	00 04 44             	add    %al,(%rsp,%rax,2)
     386:	00 0a                	add    %cl,(%rdx)
     388:	09 ac 00 00 00 04 45 	or     %ebp,0x45040000(%rax,%rax,1)
     38f:	08 0a                	or     %cl,(%rdx)
     391:	0c ac                	or     $0xac,%al
     393:	00 00                	add    %al,(%rax)
     395:	00 04 46             	add    %al,(%rsi,%rax,2)
     398:	0c 0a                	or     $0xa,%al
     39a:	14 af                	adc    $0xaf,%al
     39c:	03 00                	add    (%rax),%eax
     39e:	00 04 47             	add    %al,(%rdi,%rax,2)
     3a1:	10 15 15 16 01 00    	adc    %dl,0x11615(%rip)        # 119bc <_license+0xfac9>
     3a7:	00 04 48             	add    %al,(%rax,%rcx,2)
     3aa:	10 08                	adc    %cl,(%rax)
     3ac:	00 08                	add    %cl,(%rax)
     3ae:	00 04 a8             	add    %al,(%rax,%rbp,4)
     3b1:	00 00                	add    %al,(%rax)
     3b3:	00 16                	add    %dl,(%rsi)
     3b5:	5b                   	pop    %rbx
     3b6:	00 00                	add    %al,(%rax)
     3b8:	00 00                	add    %al,(%rax)
     3ba:	02 00                	add    (%rax),%al
     3bc:	02 00                	add    (%rax),%al
     3be:	08 30                	or     %dh,(%rax)
     3c0:	c9                   	leave
     3c1:	03 00                	add    (%rax),%eax
     3c3:	00 04 52             	add    %al,(%rdx,%rdx,2)
     3c6:	02 a1 06 0f 20 40    	add    0x40200f06(%rcx),%ah
     3cc:	04 4c                	add    $0x4c,%al
     3ce:	0a 07                	or     (%rdi),%al
     3d0:	9c                   	pushf
     3d1:	00 00                	add    %al,(%rax)
     3d3:	00 04 4d 00 0a 09 ac 	add    %al,-0x53f6f600(,%rcx,2)
     3da:	00 00                	add    %al,(%rax)
     3dc:	00 04 4e             	add    %al,(%rsi,%rcx,2)
     3df:	08 0a                	or     %cl,(%rdx)
     3e1:	0c fd                	or     $0xfd,%al
     3e3:	03 00                	add    (%rax),%eax
     3e5:	00 04 4f             	add    %al,(%rdi,%rcx,2)
     3e8:	0c 0a                	or     $0xa,%al
     3ea:	14 2b                	adc    $0x2b,%al
     3ec:	04 00                	add    $0x0,%al
     3ee:	00 04 50             	add    %al,(%rax,%rdx,2)
     3f1:	20 10                	and    %dl,(%rax)
     3f3:	15 16 01 00 00       	adc    $0x116,%eax
     3f8:	04 51                	add    $0x51,%al
     3fa:	20 40 00             	and    %al,0x0(%rax)
     3fd:	0c 31                	or     $0x31,%al
     3ff:	14 03                	adc    $0x3,%al
     401:	54                   	push   %rsp
     402:	0d 0a 04 00 00       	or     $0x40a,%eax
     407:	03 55 00             	add    0x0(%rbp),%edx
     40a:	0e                   	(bad)
     40b:	10 03                	adc    %al,(%rbx)
     40d:	55                   	push   %rbp
     40e:	0a 25 a4 01 00 00    	or     0x1a4(%rip),%ah        # 5b8 <balancer_ingress+0x5b8>
     414:	03 56 00             	add    0x0(%rsi),%edx
  if (protocol == IPPROTO_TCP) {
     417:	0a 26                	or     (%rsi),%ah
     419:	ac                   	lods   %ds:(%rsi),%al
     41a:	01 00                	add    %eax,(%rax)
     41c:	00 03                	add    %al,(%rbx)
     41e:	57                   	push   %rdi
     41f:	00 00                	add    %al,(%rax)
     421:	0a 1f                	or     (%rdi),%bl
     423:	fe 00                	incb   (%rax)
  tcp = data + off;
     425:	00 00                	add    %al,(%rax)
     427:	03 59 10             	add    0x10(%rcx),%ebx
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     42a:	00 04 a8             	add    %al,(%rax,%rbp,4)
  tcp = data + off;
     42d:	00 00                	add    %al,(%rax)
     42f:	00 11                	add    %dl,(%rcx)
  if (tcp + 1 > data_end) {
     431:	5b                   	pop    %rbx
     432:	00 00                	add    %al,(%rax)
     434:	00 00                	add    %al,(%rax)
     436:	10 00                	adc    %al,(%rax)
     438:	08 32                	or     %dh,(%rdx)
     43a:	43 04 00             	rex.XB add $0x0,%al
  if (tcp->syn) {
     43d:	00 04 5b             	add    %al,(%rbx,%rbx,2)
     440:	02 a1 07 0f 30 40    	add    0x40300f07(%rcx),%ah
    pckt->flags |= F_SYN_SET;
     446:	04 55                	add    $0x55,%al
     448:	0a 07                	or     (%rdi),%al
     44a:	77 04                	ja     450 <balancer_ingress+0x450>
     44c:	00 00                	add    %al,(%rax)
      pckt->flow.src = iph->saddr;
     44e:	04 56                	add    $0x56,%al
     450:	00 0a                	add    %cl,(%rdx)
     452:	09 ac 00 00 00 04 57 	or     %ebp,0x57040000(%rax,%rax,1)
      pckt->flow.dst = iph->daddr;
     459:	18 0a                	sbb    %cl,(%rdx)
  if (protocol == IPPROTO_ICMPV6) {
     45b:	0c 83                	or     $0x83,%al
     45d:	04 00                	add    $0x0,%al
     45f:	00 04 58             	add    %al,(%rax,%rbx,2)
  if (icmp_hdr + 1 > data_end) {
     462:	20 0a                	and    %cl,(%rdx)
     464:	14 2b                	adc    $0x2b,%al
     466:	04 00                	add    $0x0,%al
     468:	00 04 59             	add    %al,(%rcx,%rbx,2)
     46b:	30 10                	xor    %dl,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     46d:	15 16 01 00 00       	adc    $0x116,%eax
     472:	04 5a                	add    $0x5a,%al
     474:	30 40 00             	xor    %al,0x0(%rax)
     477:	04 a8                	add    $0xa8,%al
     479:	00 00                	add    %al,(%rax)
     47b:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 4dc <balancer_ingress+0x4dc>
     481:	06                   	(bad)
     482:	00 0c 35 10 03 5d 0a 	add    %cl,0xa5d0310(,%rsi,1)
     489:	33 e6                	xor    %esi,%esp
     48b:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     48d:	00 03                	add    %al,(%rbx)
     48f:	5e                   	pop    %rsi
     490:	00 0a                	add    %cl,(%rdx)
     492:	34 e6                	xor    $0xe6,%al
     494:	00 00                	add    %al,(%rax)
       sizeof(struct icmp6hdr)) > data_end) {
     496:	00 03                	add    %al,(%rbx)
     498:	5f                   	pop    %rdi
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     499:	08 00                	or     %al,(%rax)
     49b:	08 36                	or     %dh,(%rsi)
     49d:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     49e:	04 00                	add    $0x0,%al
     4a0:	00 04 64             	add    %al,(%rsp,%riz,2)
     4a3:	02 a1 08 0f 20 40    	add    0x40200f08(%rcx),%ah
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     4a9:	04 5e                	add    $0x5e,%al
  udp = data + off;
     4ab:	0a 07                	or     (%rdi),%al
     4ad:	77 04                	ja     4b3 <balancer_ingress+0x4b3>
  if (udp + 1 > data_end) {
     4af:	00 00                	add    %al,(%rax)
     4b1:	04 5f                	add    $0x5f,%al
     4b3:	00 0a                	add    %cl,(%rdx)
     4b5:	09 ac 00 00 00 04 60 	or     %ebp,0x60040000(%rax,%rax,1)
     4bc:	18 0a                	sbb    %cl,(%rdx)
     4be:	0c ac                	or     $0xac,%al
     4c0:	00 00                	add    %al,(%rax)
     4c2:	00 04 61             	add    %al,(%rcx,%riz,2)
     4c5:	1c 0a                	sbb    $0xa,%al
     4c7:	14 2b                	adc    $0x2b,%al
     4c9:	04 00                	add    $0x0,%al
     4cb:	00 04 62             	add    %al,(%rdx,%riz,2)
     4ce:	20 10                	and    %dl,(%rax)
     4d0:	15 16 01 00 00       	adc    $0x116,%eax
     4d5:	04 63                	add    $0x63,%al
     4d7:	20 40 00             	and    %al,0x0(%rax)
     4da:	08 37                	or     %dh,(%rdi)
     4dc:	e5 04                	in     $0x4,%eax
     4de:	00 00                	add    %al,(%rax)
     4e0:	04 6c                	add    $0x6c,%al
     4e2:	02 a1 09 09 24 04    	add    0x4240909(%rcx),%ah
     4e8:	66 0a 07             	data16 or (%rdi),%al
     4eb:	9c                   	pushf
     4ec:	00 00                	add    %al,(%rax)
     4ee:	00 04 67             	add    %al,(%rdi,%riz,2)
     4f1:	00 0a                	add    %cl,(%rdx)
     4f3:	09 ac 00 00 00 04 68 	or     %ebp,0x68040000(%rax,%rax,1)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     4fa:	08 0a                	or     %cl,(%rdx)
  tcp = data + off;
     4fc:	0c 6d                	or     $0x6d,%al
     4fe:	01 00                	add    %eax,(%rax)
  if (tcp + 1 > data_end) {
     500:	00 04 69             	add    %al,(%rcx,%rbp,2)
     503:	0c 0a                	or     $0xa,%al
     505:	14 61                	adc    $0x61,%al
     507:	01 00                	add    %eax,(%rax)
     509:	00 04 6a             	add    %al,(%rdx,%rbp,2)
  if (tcp->syn) {
     50c:	20 0a                	and    %cl,(%rdx)
     50e:	15 16 01 00 00       	adc    $0x116,%eax
     513:	04 6b                	add    $0x6b,%al
     515:	24 00                	and    $0x0,%al
    pckt->flags |= F_SYN_SET;
     517:	08 38                	or     %bh,(%rax)
     519:	22 05 00 00 04 75    	and    0x75040000(%rip),%al        # 7504051f <_license+0x7503e62c>
     51f:	02 a1 0a 0f 30 10    	add    0x10300f0a(%rcx),%ah
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     525:	04 6f                	add    $0x6f,%al
     527:	0a 07                	or     (%rdi),%al
     529:	77 04                	ja     52f <balancer_ingress+0x52f>
     52b:	00 00                	add    %al,(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
     52d:	04 70                	add    $0x70,%al
     52f:	00 0a                	add    %cl,(%rdx)
     531:	09 ac 00 00 00 04 71 	or     %ebp,0x71040000(%rax,%rax,1)
     538:	18 0a                	sbb    %cl,(%rdx)
     53a:	0c 83                	or     $0x83,%al
     53c:	04 00                	add    $0x0,%al
     53e:	00 04 72             	add    %al,(%rdx,%rsi,2)
     541:	20 0a                	and    %cl,(%rdx)
    if (!icmp_ptb_v6_stats) {
     543:	14 56                	adc    $0x56,%al
     545:	05 00 00 04 73       	add    $0x73040000,%eax
     54a:	30 10                	xor    %dl,(%rax)
    icmp_ptb_v6_stats->v1 += 1;
     54c:	15 16 01 00 00       	adc    $0x116,%eax
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     551:	04 74                	add    $0x74,%al
     553:	30 10                	xor    %dl,(%rax)
     555:	00 04 a8             	add    %al,(%rax,%rbp,4)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     558:	00 00                	add    %al,(%rax)
     55a:	00 11                	add    %dl,(%rcx)
     55c:	5b                   	pop    %rbx
     55d:	00 00                	add    %al,(%rax)
      icmp_ptb_v6_stats->v2 += 1;
     55f:	00 00                	add    %al,(%rax)
     561:	04 00                	add    $0x0,%al
     563:	08 39                	or     %bh,(%rcx)
  if (ip6h + 1 > data_end) {
     565:	6e                   	outsb  %ds:(%rsi),(%dx)
     566:	05 00 00 04 7e       	add    $0x7e040000,%eax
     56b:	02 a1 0b 09 90 04    	add    0x490090b(%rcx),%ah
     571:	78 0a                	js     57d <balancer_ingress+0x57d>
  pckt->flow.proto = ip6h->nexthdr;
     573:	07                   	(bad)
     574:	77 04                	ja     57a <balancer_ingress+0x57a>
     576:	00 00                	add    %al,(%rax)
     578:	04 79                	add    $0x79,%al
  pckt->flags |= F_ICMP;
     57a:	00 0a                	add    %cl,(%rdx)
     57c:	09 ac 00 00 00 04 7a 	or     %ebp,0x7a040000(%rax,%rax,1)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     583:	18 0a                	sbb    %cl,(%rdx)
     585:	0c a0                	or     $0xa0,%al
     587:	05 00 00 04 7b       	add    $0x7b040000,%eax
     58c:	20 0a                	and    %cl,(%rdx)
     58e:	14 61                	adc    $0x61,%al
     590:	01 00                	add    %eax,(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     592:	00 04 7c             	add    %al,(%rsp,%rdi,2)
     595:	88 0a                	mov    %cl,(%rdx)
     597:	15 16 01 00 00       	adc    $0x116,%eax
     59c:	04 7d                	add    $0x7d,%al
     59e:	8c 00                	mov    %es,(%rax)
     5a0:	0c 47                	or     $0x47,%al
     5a2:	68 03 8e 0a 3a       	push   $0x3a0a8e03
     5a7:	e6 00                	out    %al,$0x0
     5a9:	00 00                	add    %al,(%rax)
     5ab:	03 8f 00 0a 3b e6    	add    -0x19c4f600(%rdi),%ecx
     5b1:	00 00                	add    %al,(%rax)
     5b3:	00 03                	add    %al,(%rbx)
     5b5:	90                   	nop
     5b6:	08 0a                	or     %cl,(%rdx)
     5b8:	3c e6                	cmp    $0xe6,%al
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     5ba:	00 00                	add    %al,(%rax)
     5bc:	00 03                	add    %al,(%rbx)
     5be:	91                   	xchg   %eax,%ecx
     5bf:	10 0a                	adc    %cl,(%rdx)
     5c1:	3d e6 00 00 00       	cmp    $0xe6,%eax
     5c6:	03 92 18 0a 3e e6    	add    -0x19c1f5e8(%rdx),%edx
     5cc:	00 00                	add    %al,(%rax)
     5ce:	00 03                	add    %al,(%rbx)
  vip.port = pckt.flow.port16[1];
     5d0:	93                   	xchg   %eax,%ebx
     5d1:	20 0a                	and    %cl,(%rdx)
     5d3:	3f                   	(bad)
     5d4:	e6 00                	out    %al,$0x0
     5d6:	00 00                	add    %al,(%rax)
     5d8:	03 94 28 0a 40 e6 00 	add    0xe6400a(%rax,%rbp,1),%edx
  vip.proto = pckt.flow.proto;
     5df:	00 00                	add    %al,(%rax)
     5e1:	03 95 30 0a 41 e6    	add    -0x19bef5d0(%rbp),%edx
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     5e7:	00 00                	add    %al,(%rax)
     5e9:	00 03                	add    %al,(%rbx)
     5eb:	96                   	xchg   %eax,%esi
     5ec:	38 0a                	cmp    %cl,(%rdx)
     5ee:	42 e6 00             	rex.X out %al,$0x0
     5f1:	00 00                	add    %al,(%rax)
     5f3:	03 97 40 0a 43 e6    	add    -0x19bcf5c0(%rdi),%edx
     5f9:	00 00                	add    %al,(%rax)
     5fb:	00 03                	add    %al,(%rbx)
     5fd:	98                   	cwtl
  if (!vip_info) {
     5fe:	48 0a 44 e6 00       	rex.W or 0x0(%rsi,%riz,8),%al
     603:	00 00                	add    %al,(%rax)
     605:	03 99 50 0a 45 e6    	add    -0x19baf5b0(%rcx),%ebx
  if (data_end - data > MAX_PCKT_SIZE) {
     60b:	00 00                	add    %al,(%rax)
     60d:	00 03                	add    %al,(%rbx)
     60f:	9a                   	(bad)
     610:	58                   	pop    %rax
     611:	0a 46 e6             	or     -0x1a(%rsi),%al
     614:	00 00                	add    %al,(%rax)
     616:	00 03                	add    %al,(%rbx)
     618:	9b                   	fwait
     619:	60                   	(bad)
     61a:	00 08                	add    %cl,(%rax)
     61c:	48                   	rex.W
     61d:	26 06                	es (bad)
     61f:	00 00                	add    %al,(%rax)
     621:	04 87                	add    $0x87,%al
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
     623:	02 a1 0c 09 50 04    	add    0x450090c(%rcx),%ah
     629:	81 0a 07 77 04 00    	orl    $0x47707,(%rdx)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     62f:	00 04 82             	add    %al,(%rdx,%rax,4)
     632:	00 0a                	add    %cl,(%rdx)
     634:	09 ac 00 00 00 04 83 	or     %ebp,-0x7cfc0000(%rax,%rax,1)
     63b:	18 0a                	sbb    %cl,(%rdx)
     63d:	0c 58                	or     $0x58,%al
     63f:	06                   	(bad)
     640:	00 00                	add    %al,(%rax)
     642:	04 84                	add    $0x84,%al
     644:	20 0a                	and    %cl,(%rdx)
     646:	14 61                	adc    $0x61,%al
  if (!data_stats) {
     648:	01 00                	add    %eax,(%rax)
     64a:	00 04 85 48 0a 15 16 	add    %al,0x16150a48(,%rax,4)
     651:	01 00                	add    %eax,(%rax)
     653:	00 04 86             	add    %al,(%rsi,%rax,4)
     656:	4c 00 0c 4a          	rex.WR add %r9b,(%rdx,%rcx,2)
  data_stats->v1 += 1;
     65a:	28 03                	sub    %al,(%rbx)
     65c:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     65d:	0a 3a                	or     (%rdx),%bh
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     65f:	e6 00                	out    %al,$0x0
     661:	00 00                	add    %al,(%rax)
     663:	03 a8 00 0a 3e e6    	add    -0x19c1f600(%rax),%ebp
    pckt.flow.port16[0] = 0;
     669:	00 00                	add    %al,(%rax)
  vip_num = vip_info->vip_num;
     66b:	00 03                	add    %al,(%rbx)
     66d:	a9 08 0a 3c e6       	test   $0xe63c0a08,%eax
     672:	00 00                	add    %al,(%rax)
     674:	00 03                	add    %al,(%rbx)
     676:	aa                   	stos   %al,%es:(%rdi)
     677:	10 0a                	adc    %cl,(%rdx)
     679:	3f                   	(bad)
     67a:	e6 00                	out    %al,$0x0
     67c:	00 00                	add    %al,(%rax)
     67e:	03 ab 18 0a 49 e6    	add    -0x19b6f5e8(%rbx),%ebp
  __u32 cpu_num = bpf_get_smp_processor_id();
     684:	00 00                	add    %al,(%rax)
     686:	00 03                	add    %al,(%rbx)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     688:	ac                   	lods   %ds:(%rsi),%al
     689:	20 00                	and    %al,(%rax)
     68b:	08 4b 96             	or     %cl,-0x6a(%rbx)
     68e:	06                   	(bad)
     68f:	00 00                	add    %al,(%rax)
     691:	04 90                	add    $0x90,%al
     693:	02 a1 0d 0f 30 08    	add    0x8300f0d(%rcx),%ah
     699:	04 8a                	add    $0x8a,%al
     69b:	0a 07                	or     (%rdi),%al
     69d:	77 04                	ja     6a3 <balancer_ingress+0x6a3>
     69f:	00 00                	add    %al,(%rax)
     6a1:	04 8b                	add    $0x8b,%al
     6a3:	00 0a                	add    %cl,(%rdx)
     6a5:	09 ac 00 00 00 04 8c 	or     %ebp,-0x73fc0000(%rax,%rax,1)
  if (!lru_map) {
     6ac:	18 0a                	sbb    %cl,(%rdx)
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
     6ae:	0c 83                	or     $0x83,%al
     6b0:	04 00                	add    $0x0,%al
     6b2:	00 04 8d 20 0a 14 dc 	add    %al,-0x23ebf5e0(,%rcx,4)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     6b9:	01 00                	add    %eax,(%rax)
     6bb:	00 04 8e             	add    %al,(%rsi,%rcx,4)
     6be:	30 10                	xor    %dl,(%rax)
     6c0:	15 16 01 00 00       	adc    $0x116,%eax
     6c5:	04 8f                	add    $0x8f,%al
     6c7:	30 08                	xor    %cl,(%rax)
     6c9:	00 08                	add    %cl,(%rax)
     6cb:	4c d5                	rex.WR (bad)
    if (!lru_stats) {
     6cd:	06                   	(bad)
     6ce:	00 00                	add    %al,(%rax)
     6d0:	04 a3                	add    $0xa3,%al
     6d2:	02 a1 0e 14 08 00    	add    0x8140e(%rcx),%ah
    lru_stats->v1 += 1;
     6d8:	00 04 04             	add    %al,(%rsp,%rax,1)
     6db:	9d                   	popf
     6dc:	0a 07                	or     (%rdi),%al
     6de:	9c                   	pushf
     6df:	00 00                	add    %al,(%rax)
     6e1:	00 04 9e             	add    %al,(%rsi,%rbx,4)
     6e4:	00 0a                	add    %cl,(%rdx)
     6e6:	09 ac 00 00 00 04 9f 	or     %ebp,-0x60fc0000(%rax,%rax,1)
     6ed:	08 0a                	or     %cl,(%rdx)
  if ((vip_info->flags & F_QUIC_VIP)) {
     6ef:	0c ac                	or     $0xac,%al
     6f1:	00 00                	add    %al,(%rax)
     6f3:	00 04 a0             	add    %al,(%rax,%riz,4)
     6f6:	0c 0a                	or     $0xa,%al
     6f8:	14 0d                	adc    $0xd,%al
    bool is_icmp = (pckt.flags & F_ICMP);
     6fa:	07                   	(bad)
     6fb:	00 00                	add    %al,(%rax)
     6fd:	04 a1                	add    $0xa1,%al
    if (is_icmp) {
     6ff:	10 15 15 16 01 00    	adc    %dl,0x11615(%rip)        # 11d1a <_license+0xfe27>
      __u32 quic_packets_stats_key = 0;
     705:	00 04 a2             	add    %al,(%rdx,%riz,4)
     708:	08 00                	or     %al,(%rax)
     70a:	00 04 00             	add    %al,(%rax,%rax,1)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     70d:	04 a8                	add    $0xa8,%al
     70f:	00 00                	add    %al,(%rax)
     711:	00 16                	add    %dl,(%rsi)
     713:	5b                   	pop    %rbx
     714:	00 00                	add    %al,(%rax)
     716:	00 fe                	add    %bh,%dh
     718:	ff                   	(bad)
     719:	ff 00                	incl   (%rax)
     71b:	00 08                	add    %cl,(%rax)
     71d:	4d 27                	rex.WRB (bad)
     71f:	07                   	(bad)
     720:	00 00                	add    %al,(%rax)
      if (!quic_packets_stats) {
     722:	04 dc                	add    $0xdc,%al
     724:	02 a1 0f 09 48 04    	add    0x448090f(%rcx),%ah
     72a:	d6                   	(bad)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     72b:	0a 07                	or     (%rdi),%al
     72d:	77 04                	ja     733 <balancer_ingress+0x733>
  bool is_icmp = (pckt->flags & F_ICMP);
     72f:	00 00                	add    %al,(%rax)
     731:	04 d7                	add    $0xd7,%al
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     733:	00 0a                	add    %cl,(%rdx)
     735:	09 ac 00 00 00 04 d8 	or     %ebp,-0x27fc0000(%rax,%rax,1)
     73c:	18 0a                	sbb    %cl,(%rdx)
     73e:	0c 59                	or     $0x59,%al
     740:	07                   	(bad)
     741:	00 00                	add    %al,(%rax)
     743:	04 d9                	add    $0xd9,%al
     745:	20 0a                	and    %cl,(%rdx)
     747:	14 61                	adc    $0x61,%al
        quic_packets_stats->ch_routed += 1;
     749:	01 00                	add    %eax,(%rax)
     74b:	00 04 da             	add    %al,(%rdx,%rbx,8)
     74e:	40 0a 15 16 01 00 00 	rex or 0x116(%rip),%dl        # 86b <balancer_ingress+0x86b>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     755:	04 db                	add    $0xdb,%al
     757:	44 00 0c 50          	add    %r9b,(%rax,%rdx,2)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     75b:	20 03                	and    %al,(%rbx)
     75d:	9f                   	lahf
     75e:	0a 3a                	or     (%rdx),%bh
     760:	e6 00                	out    %al,$0x0
        bpf_map_lookup_elem(&stats, &stats_key);
     762:	00 00                	add    %al,(%rax)
     764:	03 a0 00 0a 45 e6    	add    -0x19baf600(%rax),%esp
     76a:	00 00                	add    %al,(%rax)
     76c:	00 03                	add    %al,(%rbx)
     76e:	a1 08 0a 4e e6 00 00 	movabs 0x3000000e64e0a08,%eax
     775:	00 03 
     777:	a2 10 0a 4f e6 00 00 	movabs %al,0x3000000e64f0a10
     77e:	00 03 
    if (!icmp_ptb_v4_stats) {
     780:	a3 18 00 08 51 8e 07 	movabs %eax,0x78e51080018
     787:	00 00 
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     789:	04 e4                	add    $0xe4,%al
     78b:	02 a1 10 0f 30 08    	add    0x8300f10(%rcx),%ah
      icmp_ptb_v4_stats->v2 += 1;
     791:	04 de                	add    $0xde,%al
     793:	0a 07                	or     (%rdi),%al
  if (iph + 1 > data_end) {
     795:	77 04                	ja     79b <balancer_ingress+0x79b>
     797:	00 00                	add    %al,(%rax)
     799:	04 df                	add    $0xdf,%al
     79b:	00 0a                	add    %cl,(%rdx)
     79d:	09 ac 00 00 00 04 e0 	or     %ebp,-0x1ffc0000(%rax,%rax,1)
  if (iph->ihl != 5) {
     7a4:	18 0a                	sbb    %cl,(%rdx)
     7a6:	0c 83                	or     $0x83,%al
     7a8:	04 00                	add    $0x0,%al
     7aa:	00 04 e1             	add    %al,(%rcx,%riz,8)
     7ad:	20 0a                	and    %cl,(%rdx)
  pckt->flow.proto = iph->protocol;
     7af:	14 dc                	adc    $0xdc,%al
     7b1:	01 00                	add    %eax,(%rax)
     7b3:	00 04 e2             	add    %al,(%rdx,%riz,8)
  pckt->flags |= F_ICMP;
     7b6:	30 10                	xor    %dl,(%rax)
     7b8:	15 16 01 00 00       	adc    $0x116,%eax
     7bd:	04 e3                	add    $0xe3,%al
  pckt->flow.src = iph->daddr;
     7bf:	30 08                	xor    %cl,(%rax)
     7c1:	00 08                	add    %cl,(%rax)
     7c3:	52                   	push   %rdx
     7c4:	cd 07                	int    $0x7
  pckt->flow.dst = iph->saddr;
     7c6:	00 00                	add    %al,(%rax)
     7c8:	04 f8                	add    $0xf8,%al
     7ca:	02 a1 11 0f 50 08    	add    0x8500f11(%rcx),%ah
     7d0:	04 e7                	add    $0xe7,%al
    vip.port = 0;
     7d2:	0a 07                	or     (%rdi),%al
     7d4:	3f                   	(bad)
     7d5:	08 00                	or     %al,(%rax)
     7d7:	00 04 e8             	add    %al,(%rax,%rbp,8)
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     7da:	00 0a                	add    %cl,(%rdx)
     7dc:	09 6d 01             	or     %ebp,0x1(%rbp)
     7df:	00 00                	add    %al,(%rax)
     7e1:	04 e9                	add    $0xe9,%al
     7e3:	34 0a                	xor    $0xa,%al
     7e5:	0c ac                	or     $0xac,%al
     7e7:	00 00                	add    %al,(%rax)
     7e9:	00 04 ea             	add    %al,(%rdx,%rbp,8)
     7ec:	48 0a 14 dc          	rex.W or (%rsp,%rbx,8),%dl
     7f0:	01 00                	add    %eax,(%rax)
     7f2:	00 04 eb             	add    %al,(%rbx,%rbp,8)
    if (!vip_info) {
     7f5:	4c 10 15 61 01 00 00 	rex.WR adc %r10b,0x161(%rip)        # 95d <balancer_ingress+0x95d>
     7fc:	04 ec                	add    $0xec,%al
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     7fe:	4c 08 10             	rex.WR or %r10b,(%rax)
     801:	2e 4b 08 00          	cs rex.WXB or %al,(%r8)
     805:	00 04 ed 50 08 0f 10 	add    %al,0x100f0850(,%rbp,8)
      pckt.flow.port16[1] = 0;
     80c:	40 04 ed             	rex add $0xed,%al
     80f:	0a 07                	or     (%rdi),%al
  udp = data + off;
     811:	61                   	(bad)
     812:	01 00                	add    %eax,(%rax)
     814:	00 04 ed 00 0a 09 ac 	add    %al,-0x53f6f600(,%rbp,8)
  if (udp + 1 > data_end) {
     81b:	00 00                	add    %al,(%rax)
     81d:	00 04 ed 04 0a 0c fe 	add    %al,-0x1f3f5fc(,%rbp,8)
     824:	00 00                	add    %al,(%rax)
     826:	00 04 ed 08 0a 14 2b 	add    %al,0x2b140a08(,%rbp,8)
     82d:	04 00                	add    $0x0,%al
     82f:	00 04 ed 0c 10 15 61 	add    %al,0x6115100c(,%rbp,8)
     836:	01 00                	add    %eax,(%rax)
     838:	00 04 ed 0c 40 00 00 	add    %al,0x400c(,%rbp,8)
     83f:	04 a8                	add    $0xa8,%al
     841:	00 00                	add    %al,(%rax)
     843:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 8a4 <balancer_ingress+0x8a4>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     849:	0d 00 04 56 08       	or     $0x8560400,%eax
     84e:	00 00                	add    %al,(%rax)
     850:	12 5b 00             	adc    0x0(%rbx),%bl
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     853:	00 00                	add    %al,(%rax)
     855:	00 13                	add    %dl,(%rbx)
     857:	0a 08                	or     (%rax),%cl
     859:	00 00                	add    %al,(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
     85b:	17                   	(bad)
     85c:	53                   	push   %rbx
     85d:	63 08                	movsxd (%rax),%ecx
     85f:	00 00                	add    %al,(%rax)
     861:	06                   	(bad)
     862:	1a 13                	sbb    (%rbx),%dl
     864:	68 08 00 00 18       	push   $0x18000008
     869:	78 08                	js     873 <balancer_ingress+0x873>
     86b:	00 00                	add    %al,(%rax)
     86d:	19 78 08             	sbb    %edi,0x8(%rax)
     870:	00 00                	add    %al,(%rax)
    if (!icmp_ptb_v4_stats) {
     872:	19 78 08             	sbb    %edi,0x8(%rax)
     875:	00 00                	add    %al,(%rax)
     877:	00 1a                	add    %bl,(%rdx)
     879:	17                   	(bad)
    icmp_ptb_v4_stats->v1 += 1;
     87a:	54                   	push   %rsp
     87b:	81 08 00 00 06 34    	orl    $0x34060000,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     881:	13 86 08 00 00 1b    	adc    0x1b000008(%rsi),%eax
      icmp_ptb_v4_stats->v2 += 1;
     887:	ee                   	out    %al,(%dx)
     888:	00 00                	add    %al,(%rax)
     88a:	00 17                	add    %dl,(%rdi)
     88c:	55                   	push   %rbp
     88d:	81 08 00 00 06 2d    	orl    $0x2d060000,(%rax)
  if (iph + 1 > data_end) {
     893:	17                   	(bad)
     894:	56                   	push   %rsi
     895:	9b                   	fwait
     896:	08 00                	or     %al,(%rax)
     898:	00 06                	add    %al,(%rsi)
     89a:	1c 13                	sbb    $0x13,%al
  if (iph->ihl != 5) {
     89c:	a0 08 00 00 18 a8 00 	movabs 0xa818000008,%al
     8a3:	00 00 
     8a5:	19 78 08             	sbb    %edi,0x8(%rax)
  pckt->flow.proto = iph->protocol;
     8a8:	00 00                	add    %al,(%rax)
     8aa:	19 78 08             	sbb    %edi,0x8(%rax)
     8ad:	00 00                	add    %al,(%rax)
  pckt->flags |= F_ICMP;
     8af:	19 78 08             	sbb    %edi,0x8(%rax)
     8b2:	00 00                	add    %al,(%rax)
     8b4:	19 ee                	sbb    %ebp,%esi
  pckt->flow.src = iph->daddr;
     8b6:	00 00                	add    %al,(%rax)
     8b8:	00 00                	add    %al,(%rax)
     8ba:	17                   	(bad)
     8bb:	57                   	push   %rdi
     8bc:	c2 08 00             	ret    $0x8
  pckt->flow.dst = iph->saddr;
     8bf:	00 06                	add    %al,(%rsi)
     8c1:	60                   	(bad)
     8c2:	13 c7                	adc    %edi,%eax
     8c4:	08 00                	or     %al,(%rax)
     8c6:	00 18                	add    %bl,(%rax)
     8c8:	a8 00                	test   $0x0,%al
     8ca:	00 00                	add    %al,(%rax)
     8cc:	19 78 08             	sbb    %edi,0x8(%rax)
     8cf:	00 00                	add    %al,(%rax)
     8d1:	19 a8 00 00 00 00    	sbb    %ebp,0x0(%rax)
     8d7:	1c b4                	sbb    $0xb4,%al
     8d9:	00 00                	add    %al,(%rax)
     8db:	00 5d 04             	add    %bl,0x4(%rbp)
    vip.vip = pckt.flow.dst;
     8de:	07                   	(bad)
     8df:	28 0c 1d 58 00 1d 59 	sub    %cl,0x591d0058(,%rbx,1)
  vip.port = pckt.flow.port16[1];
     8e6:	01 1d 5a 02 1d 5b    	add    %ebx,0x5b1d025a(%rip)        # 5b1d0b46 <_license+0x5b1cec53>
     8ec:	03 1d 5c 04 00 1e    	add    0x1e00045c(%rip),%ebx        # 1e000d4e <_license+0x1dffee5b>
  vip.proto = pckt.flow.proto;
     8f2:	b4 00                	mov    $0x0,%ah
     8f4:	00 00                	add    %al,(%rax)
     8f6:	04 08                	add    $0x8,%al
     8f8:	1d 1d 5e 00 1d       	sbb    $0x1d005e1d,%eax
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     8fd:	5f                   	pop    %rdi
     8fe:	01 1d 60 02 1d 61    	add    %ebx,0x611d0260(%rip)        # 611d0b64 <_license+0x611cec71>
     904:	04 1d                	add    $0x1d,%al
     906:	62 06 1d 63 08       	(bad)
     90b:	1d 64 0c 1d 65       	sbb    $0x651d0c64,%eax
     910:	11 1d 66 16 1d 67    	adc    %ebx,0x671d1666(%rip)        # 671d1f7c <_license+0x671d0089>
  if (!vip_info) {
     916:	1d 1d 68 21 1d       	sbb    $0x1d21681d,%eax
     91b:	69 29 1d 6a 2e 1d    	imul   $0x1d2e6a1d,(%rcx),%ebp
  if (data_end - data > MAX_PCKT_SIZE) {
     921:	6b 2f 1d             	imul   $0x1d,(%rdi),%ebp
     924:	6c                   	insb   (%dx),%es:(%rdi)
     925:	32 1d 6d 33 1d 6e    	xor    0x6e1d336d(%rip),%bl        # 6e1d3c98 <_license+0x6e1d1da5>
     92b:	5c                   	pop    %rsp
     92c:	1d 6f 5e 1d 70       	sbb    $0x701d5e6f,%eax
     931:	62                   	(bad)
     932:	1d 71 67 1d 72       	sbb    $0x721d6771,%eax
     937:	6c                   	insb   (%dx),%es:(%rdi)
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
     938:	1d 73 73 1d 74       	sbb    $0x741d7373,%eax
     93d:	84 01                	test   %al,(%rcx)
     93f:	1d 75 88 01 1d       	sbb    $0x1d018875,%eax
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     944:	76 89                	jbe    8cf <balancer_ingress+0x8cf>
     946:	01 1d 77 8f 01 1d    	add    %ebx,0x1d018f77(%rip)        # 1d0198c3 <_license+0x1d0179d0>
     94c:	78 90                	js     8de <balancer_ingress+0x8de>
     94e:	01 1d 79 ff 01 1d    	add    %ebx,0x1d01ff79(%rip)        # 1d0208cd <_license+0x1d01e9da>
     954:	7a 80                	jp     8d6 <balancer_ingress+0x8d6>
     956:	02 1d 7b 86 02 1d    	add    0x1d02867b(%rip),%bl        # 1d028fd7 <_license+0x1d0270e4>
  if (!data_stats) {
     95c:	7c 87                	jl     8e5 <balancer_ingress+0x8e5>
     95e:	02 00                	add    (%rax),%al
     960:	06                   	(bad)
     961:	7d 05                	jge    968 <balancer_ingress+0x968>
     963:	08 13                	or     %dl,(%rbx)
     965:	ac                   	lods   %ds:(%rsi),%al
     966:	00 00                	add    %al,(%rax)
     968:	00 13                	add    %dl,(%rbx)
     96a:	57                   	push   %rdi
     96b:	00 00                	add    %al,(%rax)
  data_stats->v1 += 1;
     96d:	00 13                	add    %dl,(%rbx)
     96f:	b8 01 00 00 13       	mov    $0x13000001,%eax
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     974:	78 09                	js     97f <balancer_ingress+0x97f>
     976:	00 00                	add    %al,(%rax)
     978:	0c 81                	or     $0x81,%al
    pckt.flow.port16[0] = 0;
     97a:	0e                   	(bad)
     97b:	09 29                	or     %ebp,(%rcx)
     97d:	0a 1f                	or     (%rdi),%bl
  vip_num = vip_info->vip_num;
     97f:	fe 00                	incb   (%rax)
     981:	00 00                	add    %al,(%rax)
     983:	09 2a                	or     %ebp,(%rdx)
     985:	00 0a                	add    %cl,(%rdx)
     987:	7e ac                	jle    935 <balancer_ingress+0x935>
     989:	00 00                	add    %al,(%rax)
     98b:	00 09                	add    %cl,(%rcx)
     98d:	2b 01                	sub    (%rcx),%eax
     98f:	0a 7f fe             	or     -0x2(%rdi),%bh
     992:	00 00                	add    %al,(%rax)
     994:	00 09                	add    %cl,(%rcx)
  __u32 cpu_num = bpf_get_smp_processor_id();
     996:	2e 05 0a 80 a2 09    	cs add $0x9a2800a,%eax
     99c:	00 00                	add    %al,(%rax)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     99e:	09 32                	or     %esi,(%rdx)
     9a0:	06                   	(bad)
     9a1:	00 04 fe             	add    %al,(%rsi,%rdi,8)
     9a4:	00 00                	add    %al,(%rax)
     9a6:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # a07 <balancer_ingress+0xa07>
     9ac:	08 00                	or     %al,(%rax)
     9ae:	13 b3 09 00 00 0c    	adc    0xc000009(%rbx),%esi
     9b4:	83 09 09             	orl    $0x9,(%rcx)
     9b7:	35 0a 1f fe 00       	xor    $0xfe1f0a,%eax
     9bc:	00 00                	add    %al,(%rax)
  if (!lru_map) {
     9be:	09 36                	or     %esi,(%rsi)
     9c0:	00 0a                	add    %cl,(%rdx)
     9c2:	82                   	(bad)
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
     9c3:	a2 09 00 00 09 37 01 	movabs %al,0x1300013709000009
     9ca:	00 13 
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     9cc:	d0 09                	rorb   (%rcx)
     9ce:	00 00                	add    %al,(%rax)
     9d0:	0b b4 00 00 00 84 0a 	or     0xa840000(%rax,%rax,1),%esi
     9d7:	35 1f 85 00 a8       	xor    $0xa800851f,%eax
     9dc:	02 a8 00 00 00 20    	add    0x20000000(%rax),%ch
    if (!lru_stats) {
     9e2:	86 00                	xchg   %al,(%rax)
     9e4:	a8 02                	test   $0x2,%al
     9e6:	a0 0c 00 00 20 91 00 	movabs 0x2a800912000000c,%al
     9ed:	a8 02 
    lru_stats->v1 += 1;
     9ef:	e6 00                	out    %al,$0x0
     9f1:	00 00                	add    %al,(%rax)
     9f3:	20 92 00 a8 02 0a    	and    %dl,0xa02a800(%rdx)
     9f9:	0d 00 00 21 94       	or     $0x94210000,%eax
     9fe:	00 ad 02 0e 0d 00    	add    %ch,0xd0e02(%rbp)
  if ((vip_info->flags & F_QUIC_VIP)) {
     a04:	00 21                	add    %ah,(%rcx)
     a06:	17                   	(bad)
     a07:	00 ae 02 6d 01 00    	add    %ch,0x16d02(%rsi)
     a0d:	00 21                	add    %ah,(%rcx)
    bool is_icmp = (pckt.flags & F_ICMP);
     a0f:	87 00                	xchg   %eax,(%rax)
     a11:	a9 02 78 08 00       	test   $0x87802,%eax
    if (is_icmp) {
     a16:	00 21                	add    %ah,(%rcx)
     a18:	88 00                	mov    %al,(%rax)
      __u32 quic_packets_stats_key = 0;
     a1a:	aa                   	stos   %al,%es:(%rdi)
     a1b:	02 78 08             	add    0x8(%rax),%bh
     a1e:	00 00                	add    %al,(%rax)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     a20:	21 25 00 ac 02 38    	and    %esp,0x3802ac00(%rip)        # 3802b626 <_license+0x38029733>
     a26:	0d 00 00 21 99       	or     $0x99210000,%eax
     a2b:	00 b7 02 ac 00 00    	add    %dh,0xac02(%rdi)
     a31:	00 21                	add    %ah,(%rcx)
     a33:	9a                   	(bad)
     a34:	00 b9 02 e6 00 00    	add    %bh,0xe602(%rcx)
      if (!quic_packets_stats) {
     a3a:	00 21                	add    %ah,(%rcx)
     a3c:	9b                   	fwait
     a3d:	00 b5 02 a8 00 00    	add    %dh,0xa802(%rbp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     a43:	00 21                	add    %ah,(%rcx)
     a45:	9c                   	pushf
     a46:	00 b2 02 fe 00 00    	add    %dh,0xfe02(%rdx)
     a4c:	00 21                	add    %ah,(%rcx)
     a4e:	9d                   	popf
     a4f:	00 af 02 3d 0d 00    	add    %ch,0xd3d02(%rdi)
     a55:	00 21                	add    %ah,(%rcx)
     a57:	9e                   	sahf
     a58:	00 35 03 ac 00 00    	add    %dh,0xac03(%rip)        # b661 <_license+0x976e>
     a5e:	00 21                	add    %ah,(%rcx)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     a60:	9f                   	lahf
     a61:	00 b0 02 42 0d 00    	add    %dh,0xd4202(%rax)
     a67:	00 21                	add    %ah,(%rcx)
     a69:	20 00                	and    %al,(%rax)
     a6b:	b6 02                	mov    $0x2,%dh
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     a6d:	ac                   	lods   %ds:(%rsi),%al
     a6e:	00 00                	add    %al,(%rax)
     a70:	00 21                	add    %ah,(%rcx)
     a72:	a0 00 45 03 ac 00 00 	movabs 0x21000000ac034500,%al
     a79:	00 21 
     a7b:	a1 00 46 03 78 08 00 	movabs 0x2100000878034600,%eax
     a82:	00 21 
    vip.port = 0;
     a84:	a2 00 b8 02 b8 01 00 	movabs %al,0x21000001b802b800
     a8b:	00 21 
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     a8d:	a3 00 b3 02 b8 01 00 	movabs %eax,0x21000001b802b300
     a94:	00 21 
     a96:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     a97:	00 ab 02 47 0d 00    	add    %ch,0xd4702(%rbx)
     a9d:	00 21                	add    %ah,(%rcx)
     a9f:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     aa0:	00 b1 02 e6 00 00    	add    %dh,0xe602(%rcx)
    if (!vip_info) {
     aa6:	00 22                	add    %ah,(%rdx)
     aa8:	21 a6 00 12 03 78    	and    %esp,0x78031200(%rsi)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     aae:	08 00                	or     %al,(%rax)
     ab0:	00 22                	add    %ah,(%rdx)
     ab2:	21 07                	and    %eax,(%rdi)
      pckt.flow.port16[1] = 0;
     ab4:	00 12                	add    %dl,(%rdx)
     ab6:	03 4c 0d 00          	add    0x0(%rbp,%rcx,1),%ecx
     aba:	00 00                	add    %al,(%rax)
     abc:	00 22                	add    %ah,(%rdx)
     abe:	21 a6 00 15 03 78    	and    %esp,0x78031500(%rsi)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     ac4:	08 00                	or     %al,(%rax)
     ac6:	00 22                	add    %ah,(%rdx)
        bpf_map_lookup_elem(&stats, &stats_key);
     ac8:	21 07                	and    %eax,(%rdi)
     aca:	00 15 03 4c 0d 00    	add    %dl,0xd4c03(%rip)        # d56d3 <_license+0xd37e0>
     ad0:	00 00                	add    %al,(%rax)
     ad2:	00 22                	add    %ah,(%rdx)
     ad4:	21 a6 00 36 03 78    	and    %esp,0x78033600(%rsi)
     ada:	08 00                	or     %al,(%rax)
     adc:	00 22                	add    %ah,(%rdx)
     ade:	21 07                	and    %eax,(%rdi)
    if (!icmp_ptb_v6_stats) {
     ae0:	00 36                	add    %dh,(%rsi)
     ae2:	03 4c 0d 00          	add    0x0(%rbp,%rcx,1),%ecx
     ae6:	00 00                	add    %al,(%rax)
    icmp_ptb_v6_stats->v1 += 1;
     ae8:	00 22                	add    %ah,(%rdx)
     aea:	21 a6 00 46 03 78    	and    %esp,0x78034600(%rsi)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     af0:	08 00                	or     %al,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     af2:	00 22                	add    %ah,(%rdx)
     af4:	21 07                	and    %eax,(%rdi)
     af6:	00 46 03             	add    %al,0x3(%rsi)
     af9:	4c 0d 00 00 00 00    	rex.WR or $0x0,%rax
     aff:	22 21                	and    (%rcx),%ah
  if (ip6h + 1 > data_end) {
     b01:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     b02:	00 49 03             	add    %cl,0x3(%rcx)
     b05:	ac                   	lods   %ds:(%rsi),%al
     b06:	00 00                	add    %al,(%rax)
     b08:	00 21                	add    %ah,(%rcx)
     b0a:	a8 00                	test   $0x0,%al
     b0c:	4a 03 42 0d          	rex.WX add 0xd(%rdx),%rax
     b10:	00 00                	add    %al,(%rax)
  pckt->flow.proto = ip6h->nexthdr;
     b12:	22 21                	and    (%rcx),%ah
     b14:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     b15:	00 4a 03             	add    %cl,0x3(%rdx)
     b18:	78 08                	js     b22 <balancer_ingress+0xb22>
  pckt->flags |= F_ICMP;
     b1a:	00 00                	add    %al,(%rax)
     b1c:	22 21                	and    (%rcx),%ah
     b1e:	07                   	(bad)
     b1f:	00 4a 03             	add    %cl,0x3(%rdx)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     b22:	4c 0d 00 00 00 00    	rex.WR or $0x0,%rax
     b28:	00 22                	add    %ah,(%rdx)
     b2a:	21 a9 00 56 03 0a    	and    %ebp,0xa035600(%rcx)
     b30:	0d 00 00 22 21       	or     $0x21220000,%eax
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     b35:	aa                   	stos   %al,%es:(%rdi)
     b36:	00 69 03             	add    %ch,0x3(%rcx)
     b39:	ac                   	lods   %ds:(%rsi),%al
     b3a:	00 00                	add    %al,(%rax)
     b3c:	00 21                	add    %ah,(%rcx)
     b3e:	ab                   	stos   %eax,%es:(%rdi)
     b3f:	00 6a 03             	add    %ch,0x3(%rdx)
     b42:	51                   	push   %rcx
     b43:	0d 00 00 21 ac       	or     $0xac210000,%eax
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
     b48:	00 6f 03             	add    %ch,0x3(%rdi)
     b4b:	56                   	push   %rsi
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b4c:	0d 00 00 22 21       	or     $0x21220000,%eax
     b51:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     b52:	00 6b 03             	add    %ch,0x3(%rbx)
     b55:	78 08                	js     b5f <balancer_ingress+0xb5f>
     b57:	00 00                	add    %al,(%rax)
     b59:	22 21                	and    (%rcx),%ah
     b5b:	07                   	(bad)
     b5c:	00 6b 03             	add    %ch,0x3(%rbx)
     b5f:	4c 0d 00 00 00 00    	rex.WR or $0x0,%rax
      if (!data_stats) {
     b65:	22 21                	and    (%rcx),%ah
     b67:	09 00                	or     %eax,(%rax)
     b69:	74 03                	je     b6e <balancer_ingress+0xb6e>
     b6b:	ac                   	lods   %ds:(%rsi),%al
      data_stats->v1 += 1;
     b6c:	00 00                	add    %al,(%rax)
     b6e:	00 21                	add    %ah,(%rcx)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     b70:	b1 00                	mov    $0x0,%cl
     b72:	75 03                	jne    b77 <balancer_ingress+0xb77>
     b74:	64 09 00             	or     %eax,%fs:(%rax)
     b77:	00 22                	add    %ah,(%rdx)
     b79:	21 a6 00 75 03 78    	and    %esp,0x78037500(%rsi)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     b7f:	08 00                	or     %al,(%rax)
        data_stats->v2 += 1;
     b81:	00 22                	add    %ah,(%rdx)
     b83:	21 07                	and    %eax,(%rdi)
  original_sport = pckt.flow.port16[0];
     b85:	00 75 03             	add    %dh,0x3(%rbp)
     b88:	4c 0d 00 00 22 21    	rex.WR or $0x21220000,%rax
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     b8e:	b2 00                	mov    $0x0,%dl
        !(vip_info->flags & F_LRU_BYPASS)) {
     b90:	75 03                	jne    b95 <balancer_ingress+0xb95>
     b92:	ac                   	lods   %ds:(%rsi),%al
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     b93:	00 00                	add    %al,(%rax)
     b95:	00 21                	add    %ah,(%rcx)
     b97:	14 00                	adc    $0x0,%al
     b99:	75 03                	jne    b9e <balancer_ingress+0xb9e>
     b9b:	77 0d                	ja     baa <balancer_ingress+0xbaa>
     b9d:	00 00                	add    %al,(%rax)
     b9f:	21 b3 00 75 03 77    	and    %esi,0x77037500(%rbx)
     ba5:	0d 00 00 00 00       	or     $0x0,%eax
  if (!dst_lru) {
     baa:	00 22                	add    %ah,(%rdx)
     bac:	21 b4 00 89 03 a8 00 	and    %esi,0xa80389(%rax,%rax,1)
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
     bb3:	00 00                	add    %al,(%rax)
     bb5:	22 21                	and    (%rcx),%ah
     bb7:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     bb8:	00 81 03 78 08 00    	add    %al,0x87803(%rcx)
     bbe:	00 22                	add    %ah,(%rdx)
     bc0:	21 07                	and    %eax,(%rdi)
    cur_time = bpf_ktime_get_ns();
     bc2:	00 81 03 4c 0d 00    	add    %al,0xd4c03(%rcx)
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
     bc8:	00 22                	add    %ah,(%rdx)
     bca:	21 b2 00 81 03 ac    	and    %esi,-0x53fc7f00(%rdx)
     bd0:	00 00                	add    %al,(%rax)
     bd2:	00 21                	add    %ah,(%rcx)
     bd4:	14 00                	adc    $0x0,%al
     bd6:	81 03 77 0d 00 00    	addl   $0xd77,(%rbx)
     bdc:	21 b3 00 81 03 77    	and    %esi,0x77038100(%rbx)
     be2:	0d 00 00 00 00       	or     $0x0,%eax
     be7:	00 00                	add    %al,(%rax)
     be9:	00 00                	add    %al,(%rax)
     beb:	22 21                	and    (%rcx),%ah
     bed:	9e                   	sahf
     bee:	00 5e 03             	add    %bl,0x3(%rsi)
     bf1:	ac                   	lods   %ds:(%rsi),%al
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     bf2:	00 00                	add    %al,(%rax)
     bf4:	00 21                	add    %ah,(%rcx)
     bf6:	9f                   	lahf
     bf7:	00 5f 03             	add    %bl,0x3(%rdi)
     bfa:	42 0d 00 00 22 21    	rex.X or $0x21220000,%eax
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     c00:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     c01:	00 5f 03             	add    %bl,0x3(%rdi)
     c04:	78 08                	js     c0e <balancer_ingress+0xc0e>
     c06:	00 00                	add    %al,(%rax)
     c08:	22 21                	and    (%rcx),%ah
     c0a:	07                   	(bad)
     c0b:	00 5f 03             	add    %bl,0x3(%rdi)
  if (!connId) {
     c0e:	4c 0d 00 00 00 00    	rex.WR or $0x0,%rax
     c14:	00 00                	add    %al,(%rax)
     c16:	22 21                	and    (%rcx),%ah
  __u8 connIdVersion = (connId[0] >> 6);
     c18:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     c19:	00 e9                	add    %ch,%cl
     c1b:	03 ac 00 00 00 21 a8 	add    -0x57df0000(%rax,%rax,1),%ebp
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     c22:	00 ea                	add    %ch,%dl
     c24:	03 42 0d             	add    0xd(%rdx),%eax
     c27:	00 00                	add    %al,(%rax)
     c29:	22 21                	and    (%rcx),%ah
     c2b:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     c2c:	00 eb                	add    %ch,%bl
     c2e:	03 78 08             	add    0x8(%rax),%edi
     c31:	00 00                	add    %al,(%rax)
     c33:	22 21                	and    (%rcx),%ah
     c35:	07                   	(bad)
     c36:	00 eb                	add    %ch,%bl
     c38:	03 4c 0d 00          	add    0x0(%rbp,%rcx,1),%ecx
     c3c:	00 00                	add    %al,(%rax)
     c3e:	00 00                	add    %al,(%rax)
     c40:	22 21                	and    (%rcx),%ah
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     c42:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     c43:	00 0e                	add    %cl,(%rsi)
     c45:	04 78                	add    $0x78,%al
     c47:	08 00                	or     %al,(%rax)
     c49:	00 22                	add    %ah,(%rdx)
     c4b:	21 07                	and    %eax,(%rdi)
     c4d:	00 0e                	add    %cl,(%rsi)
     c4f:	04 4c                	add    $0x4c,%al
     c51:	0d 00 00 00 00       	or     $0x0,%eax
     c56:	22 21                	and    (%rcx),%ah
     c58:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     c59:	00 16                	add    %dl,(%rsi)
     c5b:	04 78                	add    $0x78,%al
     c5d:	08 00                	or     %al,(%rax)
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
     c5f:	00 22                	add    %ah,(%rdx)
     c61:	21 07                	and    %eax,(%rdi)
     c63:	00 16                	add    %dl,(%rsi)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c65:	04 4c                	add    $0x4c,%al
     c67:	0d 00 00 00 00       	or     $0x0,%eax
     c6c:	22 21                	and    (%rcx),%ah
     c6e:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     c6f:	00 08                	add    %cl,(%rax)
     c71:	04 78                	add    $0x78,%al
     c73:	08 00                	or     %al,(%rax)
     c75:	00 22                	add    %ah,(%rdx)
     c77:	21 07                	and    %eax,(%rdi)
     c79:	00 08                	add    %cl,(%rax)
     c7b:	04 4c                	add    $0x4c,%al
      if (!data_stats) {
     c7d:	0d 00 00 22 21       	or     $0x21220000,%eax
     c82:	b2 00                	mov    $0x0,%dl
     c84:	08 04 ac             	or     %al,(%rsp,%rbp,4)
      data_stats->v1 += 1;
     c87:	00 00                	add    %al,(%rax)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     c89:	00 21                	add    %ah,(%rcx)
     c8b:	14 00                	adc    $0x0,%al
     c8d:	08 04 77             	or     %al,(%rdi,%rsi,2)
     c90:	0d 00 00 21 b3       	or     $0xb3210000,%eax
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     c95:	00 08                	add    %cl,(%rax)
     c97:	04 77                	add    $0x77,%al
        data_stats->v2 += 1;
     c99:	0d 00 00 00 00       	or     $0x0,%eax
     c9e:	00 00                	add    %al,(%rax)
     ca0:	13 a5 0c 00 00 23    	adc    0x2300000c(%rbp),%esp
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     ca6:	90                   	nop
     ca7:	38 07                	cmp    %al,(%rdi)
     ca9:	3f                   	(bad)
     caa:	0c 24                	or     $0x24,%al
     cac:	87 78 08             	xchg   %edi,0x8(%rax)
     caf:	00 00                	add    %al,(%rax)
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     cb1:	07                   	(bad)
     cb2:	40 0c 00             	rex or $0x0,%al
     cb5:	24 88                	and    $0x88,%al
     cb7:	78 08                	js     cc1 <balancer_ingress+0xcc1>
        quic_packets_stats->cid_initial += 1;
     cb9:	00 00                	add    %al,(%rax)
     cbb:	07                   	(bad)
     cbc:	41 0c 08             	rex.B or $0x8,%al
     cbf:	24 89                	and    $0x89,%al
     cc1:	78 08                	js     ccb <balancer_ingress+0xccb>
     cc3:	00 00                	add    %al,(%rax)
     cc5:	07                   	(bad)
     cc6:	42 0c 10             	rex.X or $0x10,%al
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     cc9:	24 8a                	and    $0x8a,%al
     ccb:	78 08                	js     cd5 <balancer_ingress+0xcd5>
     ccd:	00 00                	add    %al,(%rax)
     ccf:	07                   	(bad)
     cd0:	43 0c 18             	rex.XB or $0x18,%al
     cd3:	24 8b                	and    $0x8b,%al
     cd5:	fc                   	cld
     cd6:	0c 00                	or     $0x0,%al
     cd8:	00 07                	add    %al,(%rdi)
     cda:	44 0c 20             	rex.R or $0x20,%al
     cdd:	24 8d                	and    $0x8d,%al
  if (!per_vip_stats) {
     cdf:	03 0d 00 00 07 45    	add    0x45070000(%rip),%ecx        # 45070ce5 <_license+0x4506edf2>
    per_vip_stats->v1 += 1;
     ce5:	0c 28                	or     $0x28,%al
     ce7:	24 8f                	and    $0x8f,%al
     ce9:	ac                   	lods   %ds:(%rsi),%al
     cea:	00 00                	add    %al,(%rax)
     cec:	00 07                	add    %al,(%rdi)
     cee:	46 0c 30             	rex.RX or $0x30,%al
    dst_lru->atime = cur_time;
     cf1:	24 1f                	and    $0x1f,%al
     cf3:	ac                   	lods   %ds:(%rsi),%al
  key = dst_lru->pos;
     cf4:	00 00                	add    %al,(%rax)
     cf6:	00 07                	add    %al,(%rdi)
     cf8:	47 0c 34             	rex.RXB or $0x34,%al
     cfb:	00 13                	add    %dl,(%rbx)
     cfd:	01 0d 00 00 25 8c    	add    %ecx,-0x73db0000(%rip)        # ffffffff8c250d03 <server_id_map+0x36fc4ba6cd03>
  *real = bpf_map_lookup_elem(&reals, &key);
     d03:	13 08                	adc    (%rax),%ecx
     d05:	0d 00 00 25 8e       	or     $0x8e250000,%eax
     d0a:	06                   	(bad)
     d0b:	93                   	xchg   %eax,%ebx
     d0c:	02 01                	add    (%rcx),%al
     d0e:	0c 98                	or     $0x98,%al
     d10:	30 03                	xor    %al,(%rbx)
     d12:	2b 0a                	sub    (%rdx),%ecx
     d14:	95                   	xchg   %eax,%ebp
     d15:	34 02                	xor    $0x2,%al
     d17:	00 00                	add    %al,(%rax)
     d19:	03 2c 00             	add    (%rax,%rax,1),%ebp
     d1c:	0a 96 ac 00 00 00    	or     0xac(%rsi),%dl
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     d22:	03 2d 28 0a 1f fe    	add    -0x1e0f5d8(%rip),%ebp        # fffffffffe1f1750 <server_id_map+0x36fcbda0d750>
     d28:	00 00                	add    %al,(%rax)
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
     d2a:	00 03                	add    %al,(%rbx)
     d2c:	2e 2c 0a             	cs sub $0xa,%al
     d2f:	97                   	xchg   %eax,%edi
     d30:	fe 00                	incb   (%rax)
     d32:	00 00                	add    %al,(%rax)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
     d34:	03 30                	add    (%rax),%esi
     d36:	2d 00 13 fd 03       	sub    $0x3fd1300,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     d3b:	00 00                	add    %al,(%rax)
     d3d:	13 c4                	adc    %esp,%eax
     d3f:	01 00                	add    %eax,(%rax)
     d41:	00 13                	add    %dl,(%rbx)
     d43:	83 04 00 00          	addl   $0x0,(%rax,%rax,1)
     d47:	13 b8 00 00 00 26    	adc    0x26000000(%rax),%edi
     d4d:	a8 00                	test   $0x0,%al
     d4f:	00 00                	add    %al,(%rax)
     d51:	13 a0 05 00 00 0c    	adc    0xc000005(%rax),%esp
  if (!conn_rate_stats) {
     d57:	b0 08                	mov    $0x8,%al
     d59:	09 3a                	or     %edi,(%rdx)
     d5b:	0a ad a8 00 00 00    	or     0xa8(%rbp),%ch
     d61:	09 3b                	or     %edi,(%rbx)
     d63:	00 0a                	add    %cl,(%rdx)
  *cur_time = bpf_ktime_get_ns();
     d65:	ae                   	scas   %es:(%rdi),%al
     d66:	fe 00                	incb   (%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     d68:	00 00                	add    %al,(%rax)
     d6a:	09 3c 04             	or     %edi,(%rsp,%rax,1)
     d6d:	0a af 0a 0d 00 00    	or     0xd0a(%rdi),%ch
     d73:	09 3d 05 00 26 ac    	or     %edi,-0x53d9fffb(%rip)        # ffffffffac260d7e <server_id_map+0x36fc6ba7cd7e>
    conn_rate_stats->v1 = 1;
     d79:	00 00                	add    %al,(%rax)
     d7b:	00 1f                	add    %bl,(%rdi)
     d7d:	b5 09                	mov    $0x9,%ch
    conn_rate_stats->v2 = *cur_time;
     d7f:	c3                   	ret
     d80:	01 a8 00 00 00 20    	add    %ebp,0x20000000(%rax)
    conn_rate_stats->v1 += 1;
     d86:	94                   	xchg   %eax,%esp
     d87:	09 c4                	or     %eax,%esp
     d89:	01 e9                	add    %ebp,%ecx
     d8b:	0d 00 00 20 9c       	or     $0x9c200000,%eax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
     d90:	09 c5                	or     %eax,%ebp
     d92:	01 ee                	add    %ebp,%esi
     d94:	0d 00 00 20 91       	or     $0x91200000,%eax
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
     d99:	09 c6                	or     %eax,%esi
     d9b:	01 e6                	add    %esp,%esi
     d9d:	00 00                	add    %al,(%rax)
     d9f:	00 20                	add    %ah,(%rax)
     da1:	9a                   	(bad)
     da2:	09 c7                	or     %eax,%edi
     da4:	01 f3                	add    %esi,%ebx
     da6:	0d 00 00 20 a2       	or     $0xa2200000,%eax
     dab:	09 c8                	or     %ecx,%eax
     dad:	01 6e 09             	add    %ebp,0x9(%rsi)
    if (down_reals_map) {
     db0:	00 00                	add    %al,(%rax)
     db2:	20 87 09 c9 01 78    	and    %al,0x7801c909(%rdi)
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
     db8:	08 00                	or     %al,(%rax)
     dba:	00 20                	add    %ah,(%rax)
     dbc:	88 09                	mov    %cl,(%rcx)
      if (down_real) {
     dbe:	ca 01 78             	lret   $0x7801
     dc1:	08 00                	or     %al,(%rax)
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
     dc3:	00 20                	add    %ah,(%rax)
     dc5:	92                   	xchg   %eax,%edx
     dc6:	09 cb                	or     %ecx,%ebx
     dc8:	01 0a                	add    %ecx,(%rdx)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
     dca:	0d 00 00 21 b6       	or     $0xb6210000,%eax
     dcf:	09 cd                	or     %ecx,%ebp
     dd1:	01 f8                	add    %edi,%eax
     dd3:	0d 00 00 21 c3       	or     $0xc3210000,%eax
     dd8:	09 ce                	or     %ecx,%esi
     dda:	01 b6 0e 00 00 21    	add    %esi,0x2100000e(%rsi)
     de0:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
        if (stats_data) {
     de1:	09 cc                	or     %ecx,%esp
     de3:	01 e6                	add    %esp,%esi
     de5:	00 00                	add    %al,(%rax)
     de7:	00 00                	add    %al,(%rax)
     de9:	13 0e                	adc    (%rsi),%ecx
          stats_data->v1 += 1;
     deb:	0d 00 00 13 fe       	or     $0xfe130000,%eax
     df0:	00 00                	add    %al,(%rax)
     df2:	00 13                	add    %dl,(%rbx)
    if (!dst) {
     df4:	e6 00                	out    %al,$0x0
     df6:	00 00                	add    %al,(%rax)
     df8:	13 fd                	adc    %ebp,%edi
     dfa:	0d 00 00 0c c2       	or     $0xc20c0000,%eax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
     dff:	14 0f                	adc    $0xf,%al
     e01:	57                   	push   %rdi
     e02:	27                   	(bad)
     e03:	b7 fe                	mov    $0xfe,%bh
     e05:	00 00                	add    %al,(%rax)
     e07:	00 0f                	add    %cl,(%rdi)
     e09:	59                   	pop    %rcx
     e0a:	01 04 04             	add    %eax,(%rsp,%rax,1)
     e0d:	00 27                	add    %ah,(%rdi)
     e0f:	7e fe                	jle    e0f <balancer_ingress+0xe0f>
     e11:	00 00                	add    %al,(%rax)
     e13:	00 0f                	add    %cl,(%rdi)
     e15:	5a                   	pop    %rdx
     e16:	01 04 00             	add    %eax,(%rax,%rax,1)
     e19:	00 0a                	add    %cl,(%rdx)
     e1b:	97                   	xchg   %eax,%edi
  if (!data_stats) {
     e1c:	fe 00                	incb   (%rax)
     e1e:	00 00                	add    %al,(%rax)
     e20:	0f 61 01             	punpcklwd (%rcx),%mm0
     e23:	0a b8 a6 0e 00 00    	or     0xea6(%rax),%bh
     e29:	0f 62 02             	punpckldq (%rdx),%mm0
     e2c:	0a ba a6 0e 00 00    	or     0xea6(%rdx),%bh
     e32:	0f 63 04 0a          	packsswb (%rdx,%rcx,1),%mm0
  data_stats->v1 += 1;
     e36:	bb a6 0e 00 00       	mov    $0xea6,%ebx
  data_stats->v2 += pkt_bytes;
     e3b:	0f 64 06             	pcmpgtb (%rsi),%mm0
     e3e:	0a bc fe 00 00 00 0f 	or     0xf000000(%rsi,%rdi,8),%bh
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
     e45:	65 08 0a             	or     %cl,%gs:(%rdx)
     e48:	9c                   	pushf
     e49:	fe 00                	incb   (%rax)
     e4b:	00 00                	add    %al,(%rax)
     e4d:	0f 66 09             	pcmpgtd (%rcx),%mm1
     e50:	0a bd ae 0e 00 00    	or     0xeae(%rbp),%bh
  if (!data_stats) {
     e56:	0f 67 0a             	packuswb (%rdx),%mm1
     e59:	0d 61 0e 00 00       	or     $0xe61,%eax
  data_stats->v1 += 1;
     e5e:	0f 68 0c 0e          	punpckhbw (%rsi,%rcx,1),%mm1
  data_stats->v2 += pkt_bytes;
     e62:	08 0f                	or     %cl,(%rdi)
     e64:	68 0d 6d 0e 00       	push   $0xe6d0d
  pckt.flow.port16[0] = original_sport;
     e69:	00 0f                	add    %cl,(%rdi)
     e6b:	68 00 09 08 0f       	push   $0xf080900
  if (dst->flags & F_IPV6) {
     e70:	68 0a bf a4 01       	push   $0x1a4bf0a
     e75:	00 00                	add    %al,(%rax)
     e77:	0f 68 00             	punpckhbw (%rax),%mm0
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
     e7a:	0a c0                	or     %al,%al
     e7c:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     e7d:	01 00                	add    %eax,(%rax)
     e7f:	00 0f                	add    %cl,(%rdi)
     e81:	68 04 00 0a c1       	push   $0xffffffffc10a0004
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
     e86:	8d 0e                	lea    (%rsi),%ecx
     e88:	00 00                	add    %al,(%rax)
     e8a:	0f 68 00             	punpckhbw (%rax),%mm0
     e8d:	09 08                	or     %ecx,(%rax)
     e8f:	0f 68 0a             	punpckhbw (%rdx),%mm1
     e92:	bf a4 01 00 00       	mov    $0x1a4,%edi
  data = (void*)(long)xdp->data;
     e97:	0f 68 00             	punpckhbw (%rax),%mm0
     e9a:	0a c0                	or     %al,%al
  data_end = (void*)(long)xdp->data_end;
     e9c:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     e9d:	01 00                	add    %eax,(%rax)
  iph = data + sizeof(struct ethhdr);
     e9f:	00 0f                	add    %cl,(%rdi)
     ea1:	68 04 00 00 00       	push   $0x4
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
     ea6:	0b b8 01 00 00 b9    	or     -0x46ffffff(%rax),%edi
     eac:	05 20 0b b8 01       	add    $0x1b80b20,%eax
     eb1:	00 00                	add    %al,(%rax)
     eb3:	be 05 26 13 bb       	mov    $0xbb132605,%esi
     eb8:	0e                   	(bad)
     eb9:	00 00                	add    %al,(%rax)
     ebb:	0c ce                	or     $0xce,%al
     ebd:	28 10                	sub    %dl,(%rax)
     ebf:	76 27                	jbe    ee8 <balancer_ingress+0xee8>
     ec1:	c4                   	(bad)
     ec2:	fe 00                	incb   (%rax)
     ec4:	00 00                	add    %al,(%rax)
     ec6:	10 78 01             	adc    %bh,0x1(%rax)
     ec9:	04 04                	add    $0x4,%al
     ecb:	00 27                	add    %ah,(%rdi)
     ecd:	7e fe                	jle    ecd <balancer_ingress+0xecd>
     ecf:	00 00                	add    %al,(%rax)
     ed1:	00 10                	add    %dl,(%rax)
     ed3:	79 01                	jns    ed6 <balancer_ingress+0xed6>
     ed5:	04 00                	add    $0x0,%al
  memcpy(new_eth->h_dest, cval->mac, 6);
     ed7:	00 0a                	add    %cl,(%rdx)
     ed9:	c5 49 0f             	(bad)
     edc:	00 00                	add    %al,(%rax)
     ede:	10 80 01 0a c6 a6    	adc    %al,-0x5939f5ff(%rax)
     ee4:	0e                   	(bad)
     ee5:	00 00                	add    %al,(%rax)
     ee7:	10 82 04 0a c7 fe    	adc    %al,-0x138f5fc(%rdx)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
     eed:	00 00                	add    %al,(%rax)
     eef:	00 10                	add    %dl,(%rax)
     ef1:	83 06 0a             	addl   $0xa,(%rsi)
     ef4:	c8 fe 00 00          	enter  $0xfe,$0x0
  new_eth->h_proto = BE_ETH_P_IP;
     ef8:	00 10                	add    %dl,(%rax)
     efa:	84 07                	test   %al,(%rdi)
     efc:	0d 04 0f 00 00       	or     $0xf04,%eax
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
     f01:	10 86 08 0e 20 10    	adc    %al,0x10200e08(%rsi)
  iph->ihl = 5;
     f07:	86 0d 10 0f 00 00    	xchg   %cl,0xf10(%rip)        # 1e1d <balancer_ingress+0x1e1d>
  iph->tos = tos;
     f0d:	10 86 00 09 20 10    	adc    %al,0x10200900(%rsi)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
     f13:	86 0a                	xchg   %cl,(%rdx)
     f15:	bf 55 0f 00 00       	mov    $0xf55,%edi
     f1a:	10 86 00 0a c0 55    	adc    %al,0x55c00a00(%rsi)
  iph->id = 0;
     f20:	0f 00 00             	sldt   (%rax)
  iph->daddr = daddr;
     f23:	10 86 10 00 0a c1    	adc    %al,-0x3ef5fff0(%rsi)
  iph->ttl = DEFAULT_TTL;
     f29:	30 0f                	xor    %cl,(%rdi)
     f2b:	00 00                	add    %al,(%rax)
     f2d:	10 86 00 09 20 10    	adc    %al,0x10200900(%rsi)
    *csum += *next_iph_u16++;
     f33:	86 0a                	xchg   %cl,(%rdx)
     f35:	bf 55 0f 00 00       	mov    $0xf55,%edi
     f3a:	10 86 00 0a c0 55    	adc    %al,0x55c00a00(%rsi)
     f40:	0f 00 00             	sldt   (%rax)
     f43:	10 86 10 00 00 00    	adc    %al,0x10(%rsi)
     f49:	04 fe                	add    $0xfe,%al
     f4b:	00 00                	add    %al,(%rax)
      if (pckt.flow.proto == IPPROTO_TCP) {
     f4d:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # fae <balancer_ingress+0xfae>
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
     f53:	03 00                	add    (%rax),%eax
     f55:	0c cd                	or     $0xcd,%al
     f57:	10 11                	adc    %dl,(%rcx)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
     f59:	21 0a                	and    %ecx,(%rdx)
     f5b:	c9                   	leave
     f5c:	63 0f                	movsxd (%rdi),%ecx
     f5e:	00 00                	add    %al,(%rax)
     f60:	11 28                	adc    %ebp,(%rax)
     f62:	00 0e                	add    %cl,(%rsi)
     f64:	10 11                	adc    %dl,(%rcx)
     f66:	22 0a                	and    (%rdx),%cl
     f68:	ca 84 0f             	lret   $0xf84
     f6b:	00 00                	add    %al,(%rax)
     f6d:	11 23                	adc    %esp,(%rbx)
     f6f:	00 0a                	add    %cl,(%rdx)
        if (!lru_stats) {
     f71:	cb                   	lret
     f72:	90                   	nop
     f73:	0f 00 00             	sldt   (%rax)
     f76:	11 25 00 0a cc ac    	adc    %esp,-0x5333f600(%rip)        # ffffffffaccc197c <server_id_map+0x36fc6c4dd97c>
        if (pckt.flags & F_SYN_SET) {
     f7c:	01 00                	add    %eax,(%rax)
     f7e:	00 11                	add    %dl,(%rcx)
     f80:	26 00 00             	es add %al,(%rax)
     f83:	00 04 fe             	add    %al,(%rsi,%rdi,8)
     f86:	00 00                	add    %al,(%rax)
     f88:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # fe9 <balancer_ingress+0xfe9>
  struct real_pos_lru new_dst_lru = {};
     f8e:	10 00                	adc    %al,(%rax)
     f90:	04 a6                	add    $0xa6,%al
     f92:	0e                   	(bad)
     f93:	00 00                	add    %al,(%rax)
     f95:	05 5b 00 00 00       	add    $0x5b,%eax
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
     f9a:	08 00                	or     %al,(%rax)
     f9c:	1f                   	(bad)
     f9d:	cf                   	iret
     f9e:	0b 13                	or     (%rbx),%edx
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     fa0:	01 a8 00 00 00 20    	add    %ebp,0x20000000(%rax)
     fa6:	87 0b                	xchg   %ecx,(%rbx)
     fa8:	14 01                	adc    $0x1,%al
     faa:	78 08                	js     fb4 <balancer_ingress+0xfb4>
     fac:	00 00                	add    %al,(%rax)
     fae:	20 88 0b 15 01 78    	and    %cl,0x7801150b(%rax)
     fb4:	08 00                	or     %al,(%rax)
     fb6:	00 20                	add    %ah,(%rax)
     fb8:	d0 0b                	rorb   (%rbx)
  if (!conn_rate_stats) {
     fba:	16                   	(bad)
     fbb:	01 e6                	add    %esp,%esi
     fbd:	00 00                	add    %al,(%rax)
     fbf:	00 20                	add    %ah,(%rax)
     fc1:	94                   	xchg   %eax,%esp
     fc2:	0b 17                	or     (%rdi),%edx
     fc4:	01 e9                	add    %ebp,%ecx
     fc6:	0d 00 00 21 d1       	or     $0xd1210000,%eax
     fcb:	0b 18                	or     (%rax),%ebx
  *cur_time = bpf_ktime_get_ns();
     fcd:	01 0f                	add    %ecx,(%rdi)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     fcf:	10 00                	adc    %al,(%rax)
     fd1:	00 21                	add    %ah,(%rcx)
     fd3:	b6 0b                	mov    $0xb,%dh
     fd5:	19 01                	sbb    %eax,(%rcx)
     fd7:	f8                   	clc
     fd8:	0d 00 00 22 21       	or     $0x21220000,%eax
     fdd:	9e                   	sahf
     fde:	0b 26                	or     (%rsi),%esp
     fe0:	01 ac 00 00 00 21 dd 	add    %ebp,-0x22df0000(%rax,%rax,1)
    conn_rate_stats->v1 = 1;
     fe7:	0b 27                	or     (%rdi),%esp
     fe9:	01 42 0d             	add    %eax,0xd(%rdx)
    conn_rate_stats->v2 = *cur_time;
     fec:	00 00                	add    %al,(%rax)
     fee:	21 da                	and    %ebx,%edx
     ff0:	0b 2d 01 b8 01 00    	or     0x1b801(%rip),%ebp        # 1c7f7 <_license+0x1a904>
     ff6:	00 22                	add    %ah,(%rdx)
     ff8:	21 a6 0b 28 01 78    	and    %esp,0x7801280b(%rsi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
     ffe:	08 00                	or     %al,(%rax)
    1000:	00 22                	add    %ah,(%rdx)
    1002:	21 07                	and    %eax,(%rdi)
    1004:	0b 28                	or     (%rax),%ebp
    1006:	01 4c 0d 00          	add    %ecx,0x0(%rbp,%rcx,1)
    100a:	00 00                	add    %al,(%rax)
    100c:	00 00                	add    %al,(%rax)
    100e:	00 13                	add    %dl,(%rbx)
  data = (void*)(long)xdp->data;
    1010:	14 10                	adc    $0x10,%al
    1012:	00 00                	add    %al,(%rax)
  data_end = (void*)(long)xdp->data_end;
    1014:	0c dc                	or     $0xdc,%al
    1016:	08 12                	or     %dl,(%rdx)
  ip6h = data + sizeof(struct ethhdr);
    1018:	59                   	pop    %rcx
    1019:	0a 07                	or     (%rdi),%al
    101b:	fe 00                	incb   (%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    101d:	00 00                	add    %al,(%rax)
    101f:	12 5a 00             	adc    0x0(%rdx),%bl
    1022:	0a d2                	or     %dl,%dl
    1024:	fe 00                	incb   (%rax)
    1026:	00 00                	add    %al,(%rax)
    1028:	12 5b 01             	adc    0x1(%rbx),%bl
    102b:	0a d3                	or     %bl,%dl
    102d:	ae                   	scas   %es:(%rdi),%al
    102e:	0e                   	(bad)
    102f:	00 00                	add    %al,(%rax)
    1031:	12 5c 02 0a          	adc    0xa(%rdx,%rax,1),%bl
    1035:	d4                   	(bad)
    1036:	3d 10 00 00 12       	cmp    $0x12000010,%eax
    103b:	68 04 0e 04 12       	push   $0x12040e04
  memcpy(new_eth->h_dest, cval->mac, 6);
    1040:	5d                   	pop    %rbp
    1041:	0a d5                	or     %ch,%dl
    1043:	4a 10 00             	rex.WX adc %al,(%rax)
    1046:	00 12                	add    %dl,(%rdx)
    1048:	61                   	(bad)
    1049:	00 09                	add    %cl,(%rcx)
    104b:	04 12                	add    $0x12,%al
    104d:	5e                   	pop    %rsi
    104e:	0a ba a6 0e 00 00    	or     0xea6(%rdx),%bh
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1054:	12 5f 00             	adc    0x0(%rdi),%bl
    1057:	0a d6                	or     %dh,%dl
    1059:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    105a:	0e                   	(bad)
    105b:	00 00                	add    %al,(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    105d:	12 60 02             	adc    0x2(%rax),%ah
    1060:	00 0a                	add    %cl,(%rdx)
    1062:	d7                   	xlat   %ds:(%rbx)
    1063:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    1064:	01 00                	add    %eax,(%rax)
    1066:	00 12                	add    %dl,(%rdx)
  saddr[3] = src ^ port;
    1068:	62                   	(bad)
    1069:	00 0a                	add    %cl,(%rdx)
    106b:	d8 73 10             	fdivs  0x10(%rbx)
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    106e:	00 00                	add    %al,(%rax)
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1070:	12 66 00             	adc    0x0(%rsi),%ah
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1073:	09 04 12             	or     %eax,(%rdx,%rdx,1)
    1076:	63 0a                	movsxd (%rdx),%ecx
    1078:	d9 a6 0e 00 00 12    	fldenv 0x1200000e(%rsi)
  ip6h->priority = (tc & 0xF0) >> 4;
    107e:	64 00 0a             	add    %cl,%fs:(%rdx)
    1081:	da a6 0e 00 00 12    	fisubl 0x1200000e(%rsi)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1087:	65 02 00             	add    %gs:(%rax),%al
  ip6h->nexthdr = proto;
    108a:	0a db                	or     %bl,%bl
    108c:	95                   	xchg   %eax,%ebp
    108d:	10 00                	adc    %al,(%rax)
    108f:	00 12                	add    %dl,(%rdx)
  ip6h->payload_len = bpf_htons(payload_len);
    1091:	67 00 00             	add    %al,(%eax)
    1094:	00 04 fe             	add    %al,(%rsi,%rdi,8)
    1097:	00 00                	add    %al,(%rax)
    1099:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 10fa <balancer_ingress+0x10fa>
    109f:	04 00                	add    $0x0,%al
    10a1:	1f                   	(bad)
    10a2:	de 0b                	fimuls (%rbx)
    10a4:	53                   	push   %rbx
    conn_rate_stats->v1 += 1;
    10a5:	01 a8 00 00 00 20    	add    %ebp,0x20000000(%rax)
    10ab:	87 0b                	xchg   %ecx,(%rbx)
    10ad:	54                   	push   %rsp
    10ae:	01 78 08             	add    %edi,0x8(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    10b1:	00 00                	add    %al,(%rax)
    10b3:	20 88 0b 55 01 78    	and    %cl,0x7801550b(%rax)
    10b9:	08 00                	or     %al,(%rax)
    10bb:	00 20                	add    %ah,(%rax)
    10bd:	d0 0b                	rorb   (%rbx)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    10bf:	56                   	push   %rsi
    10c0:	01 e6                	add    %esp,%esi
    10c2:	00 00                	add    %al,(%rax)
    10c4:	00 20                	add    %ah,(%rax)
    10c6:	94                   	xchg   %eax,%esp
    10c7:	0b 57 01             	or     0x1(%rdi),%edx
    b += *(u32*)(k + 4);
    10ca:	e9 0d 00 00 20       	jmp    200010dc <_license+0x1ffff1e9>
    c += *(u32*)(k + 8);
    10cf:	9c                   	pushf
      a += (u32)k[3] << 24;
    10d0:	0b 58 01             	or     0x1(%rax),%ebx
    10d3:	fe 00                	incb   (%rax)
      a += (u32)k[2] << 16;
    10d5:	00 00                	add    %al,(%rax)
    10d7:	00 28                	add    %ch,(%rax)
      a += (u32)k[1] << 8;
    10d9:	df 0b                	fisttps (%rbx)
    10db:	3e a8 00             	ds test $0x0,%al
      a += k[0];
    10de:	00 00                	add    %al,(%rax)
    10e0:	29 87 0b 3f 78 08    	sub    %eax,0x8783f0b(%rdi)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    10e6:	00 00                	add    %al,(%rax)
    10e8:	29 88 0b 40 78 08    	sub    %ecx,0x878400b(%rax)
      memset(pckt->flow.srcv6, 0, 16);
    10ee:	00 00                	add    %al,(%rax)
    10f0:	2a e0                	sub    %al,%ah
    10f2:	0b 43 ac             	or     -0x54(%rbx),%eax
    10f5:	00 00                	add    %al,(%rax)
    10f7:	00 2a                	add    %ch,(%rdx)
    10f9:	e1 0b                	loope  1106 <balancer_ingress+0x1106>
    10fb:	44 e6 00             	rex.R out %al,$0x0
    10fe:	00 00                	add    %al,(%rax)
    1100:	2a d0                	sub    %al,%dl
    1102:	0b 45 e6             	or     -0x1a(%rbp),%eax
    1105:	00 00                	add    %al,(%rax)
    1107:	00 2a                	add    %ch,(%rdx)
    1109:	d1 0b                	rorl   (%rbx)
    110b:	42 0f 10 00          	rex.X movups (%rax),%xmm0
    c += *(u32*)(k + 8);
    110f:	00 2a                	add    %ch,(%rdx)
    1111:	b6 0b                	mov    $0xb,%dh
    1113:	41 f8                	rex.B clc
    __jhash_mix(a, b, c);
    1115:	0d 00 00 00 2b       	or     $0x2b000000,%eax
    111a:	e2 0c                	loop   1128 <balancer_ingress+0x1128>
    b += *(u32*)(k + 4);
    111c:	32 29                	xor    (%rcx),%ch
    111e:	b6 0c                	mov    $0xc,%dh
    1120:	33 78 08             	xor    0x8(%rax),%edi
    1123:	00 00                	add    %al,(%rax)
    __jhash_mix(a, b, c);
    1125:	29 e1                	sub    %esp,%ecx
    1127:	0c 34                	or     $0x34,%al
    1129:	f3 0d 00 00 2a e3    	repz or $0xe32a0000,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    112f:	0c 35                	or     $0x35,%al
    1131:	6e                   	outsb  %ds:(%rsi),(%dx)
    1132:	09 00                	or     %eax,(%rax)
    __jhash_mix(a, b, c);
    1134:	00 22                	add    %ah,(%rdx)
    1136:	2a e4                	sub    %ah,%ah
  return (word << shift) | (word >> ((-shift) & 31));
    1138:	0c 37                	or     $0x37,%al
    113a:	a8 00                	test   $0x0,%al
    __jhash_mix(a, b, c);
    113c:	00 00                	add    %al,(%rax)
    113e:	00 00                	add    %al,(%rax)
    1140:	28 e5                	sub    %ah,%ch
    1142:	0c 1d                	or     $0x1d,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1144:	b8 01 00 00 29       	mov    $0x29000001,%eax
    __jhash_mix(a, b, c);
    1149:	e1 0c                	loope  1157 <balancer_ingress+0x1157>
    114b:	1e                   	(bad)
    114c:	e6 00                	out    %al,$0x0
    114e:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1150:	2a e4                	sub    %ah,%ah
    1152:	0c 1f                	or     $0x1f,%al
    __jhash_mix(a, b, c);
    1154:	a8 00                	test   $0x0,%al
    1156:	00 00                	add    %al,(%rax)
    1158:	00 28                	add    %ch,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    115a:	e6 0b                	out    %al,$0xb
    115c:	e4 a8                	in     $0xa8,%al
    115e:	00 00                	add    %al,(%rax)
    1160:	00 29                	add    %ch,(%rcx)
    __jhash_mix(a, b, c);
    1162:	87 0b                	xchg   %ecx,(%rbx)
      a += (u32)k[3] << 24;
    1164:	e5 78                	in     $0x78,%eax
    1166:	08 00                	or     %al,(%rax)
    1168:	00 29                	add    %ch,(%rcx)
      a += (u32)k[2] << 16;
    116a:	88 0b                	mov    %cl,(%rbx)
    116c:	e6 78                	out    %al,$0x78
    116e:	08 00                	or     %al,(%rax)
    1170:	00 29                	add    %ch,(%rcx)
      a += (u32)k[3] << 24;
    1172:	d0 0b                	rorb   (%rbx)
      a += (u32)k[1] << 8;
    1174:	e7 e6                	out    %eax,$0xe6
    1176:	00 00                	add    %al,(%rax)
    1178:	00 29                	add    %ch,(%rcx)
      a += (u32)k[2] << 16;
    117a:	94                   	xchg   %eax,%esp
    117b:	0b e8                	or     %eax,%ebp
      a += k[0];
    117d:	e9 0d 00 00 2a       	jmp    2a00118f <_license+0x29fff29c>
    1182:	d1 0b                	rorl   (%rbx)
    __jhash_mix(a, b, c);
    1184:	e9 c0 11 00 00       	jmp    2349 <_license+0x456>
  return (word << shift) | (word >> ((-shift) & 31));
    1189:	2a c3                	sub    %bl,%al
    118b:	0b ea                	or     %edx,%ebp
    118d:	b6 0e                	mov    $0xe,%dh
      __jhash_final(a, b, c);
    118f:	00 00                	add    %al,(%rax)
    1191:	22 2a                	and    (%rdx),%ch
  return (word << shift) | (word >> ((-shift) & 31));
    1193:	9e                   	sahf
    1194:	0b f8                	or     %eax,%edi
    1196:	ac                   	lods   %ds:(%rsi),%al
      __jhash_final(a, b, c);
    1197:	00 00                	add    %al,(%rax)
    1199:	00 2a                	add    %ch,(%rdx)
  return (word << shift) | (word >> ((-shift) & 31));
    119b:	ff 0b                	decl   (%rbx)
    119d:	f9                   	stc
    119e:	42 0d 00 00 2a da    	rex.X or $0xda2a0000,%eax
    11a4:	0b ff                	or     %edi,%edi
    11a6:	ac                   	lods   %ds:(%rsi),%al
    11a7:	00 00                	add    %al,(%rax)
      __jhash_final(a, b, c);
    11a9:	00 22                	add    %ah,(%rdx)
    11ab:	2a a6 0b fa 78 08    	sub    0x878fa0b(%rsi),%ah
  return (word << shift) | (word >> ((-shift) & 31));
    11b1:	00 00                	add    %al,(%rax)
      __jhash_final(a, b, c);
    11b3:	22 2a                	and    (%rdx),%ch
    11b5:	07                   	(bad)
  return (word << shift) | (word >> ((-shift) & 31));
    11b6:	0b fa                	or     %edx,%edi
    11b8:	4c 0d 00 00 00 00    	rex.WR or $0x0,%rax
    11be:	00 00                	add    %al,(%rax)
  a += initval;
    11c0:	13 c5                	adc    %ebp,%eax
    11c2:	11 00                	adc    %eax,(%rax)
    11c4:	00 0c fe             	add    %cl,(%rsi,%rdi,8)
  b += initval;
    11c7:	08 13                	or     %dl,(%rbx)
    11c9:	08 0a                	or     %cl,(%rdx)
  a += initval;
    11cb:	e7 fe                	out    %eax,$0xfe
    11cd:	00 00                	add    %al,(%rax)
    11cf:	00 13                	add    %dl,(%rbx)
  __jhash_final(a, b, c);
    11d1:	0a 00                	or     (%rax),%al
    11d3:	0a e8                	or     %al,%ch
    11d5:	fe 00                	incb   (%rax)
    11d7:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    11d9:	13 0b                	adc    (%rbx),%ecx
    11db:	01 0a                	add    %ecx,(%rdx)
  __jhash_final(a, b, c);
    11dd:	e9 ae 0e 00 00       	jmp    2090 <_license+0x19d>
  return (word << shift) | (word >> ((-shift) & 31));
    11e2:	13 0c 02             	adc    (%rdx,%rax,1),%ecx
    11e5:	0a ea                	or     %dl,%ch
  __jhash_final(a, b, c);
    11e7:	ee                   	out    %al,(%dx)
    11e8:	11 00                	adc    %eax,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    11ea:	00 13                	add    %dl,(%rbx)
    11ec:	3f                   	(bad)
    11ed:	04 0e                	add    $0xe,%al
  __jhash_final(a, b, c);
    11ef:	04 13                	add    $0x13,%al
    11f1:	0f 0a                	(bad)
  return (word << shift) | (word >> ((-shift) & 31));
    11f3:	eb 2a                	jmp    121f <balancer_ingress+0x121f>
    11f5:	12 00                	adc    (%rax),%al
    11f7:	00 13                	add    %dl,(%rbx)
  __jhash_final(a, b, c);
    11f9:	10 00                	adc    %al,(%rax)
    11fb:	0a ec                	or     %ah,%ch
  return (word << shift) | (word >> ((-shift) & 31));
    11fd:	36 12 00             	ss adc (%rax),%al
    1200:	00 13                	add    %dl,(%rbx)
  __jhash_final(a, b, c);
    1202:	11 00                	adc    %eax,(%rax)
    1204:	0a ed                	or     %ch,%ch
  return (word << shift) | (word >> ((-shift) & 31));
    1206:	95                   	xchg   %eax,%ebp
    1207:	10 00                	adc    %al,(%rax)
  __jhash_final(a, b, c);
    1209:	00 13                	add    %dl,(%rbx)
    120b:	12 00                	adc    (%rax),%al
  return (word << shift) | (word >> ((-shift) & 31));
    120d:	0a ee                	or     %dh,%ch
  __jhash_final(a, b, c);
    120f:	42 12 00             	rex.X adc (%rax),%al
    1212:	00 13                	add    %dl,(%rbx)
    1214:	17                   	(bad)
    1215:	00 0a                	add    %cl,(%rdx)
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1217:	f1                   	int1
    1218:	5a                   	pop    %rdx
    1219:	12 00                	adc    (%rax),%al
    121b:	00 13                	add    %dl,(%rbx)
    121d:	28 00                	sub    %al,(%rax)
    121f:	0a f7                	or     %bh,%dh
    1221:	9c                   	pushf
    1222:	12 00                	adc    (%rax),%al
    1224:	00 13                	add    %dl,(%rbx)
    1226:	3d 00 00 00 04       	cmp    $0x4000000,%eax
    key = RING_SIZE * (vip_info->vip_num) + hash;
    122b:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    122c:	01 00                	add    %eax,(%rax)
    122e:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 128f <balancer_ingress+0x128f>
    1234:	01 00                	add    %eax,(%rax)
    1236:	04 a6                	add    $0xa6,%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1238:	0e                   	(bad)
    1239:	00 00                	add    %al,(%rax)
    123b:	05 5b 00 00 00       	add    $0x5b,%eax
    if (!real_pos) {
    1240:	02 00                	add    (%rax),%al
    1242:	0c f0                	or     $0xf0,%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1244:	04 13                	add    $0x13,%al
    1246:	14 0a                	adc    $0xa,%al
    1248:	ef                   	out    %eax,(%dx)
    1249:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    124a:	0e                   	(bad)
    124b:	00 00                	add    %al,(%rax)
    124d:	13 15 00 0a d6 a6    	adc    -0x5929f600(%rip),%edx        # ffffffffa6d61c53 <server_id_map+0x36fc6657dc53>
    key = *real_pos;
    1253:	0e                   	(bad)
    1254:	00 00                	add    %al,(%rax)
    1256:	13 16                	adc    (%rsi),%edx
    1258:	02 00                	add    (%rax),%al
    if (key == 0) {
    125a:	0c f6                	or     $0xf6,%al
    125c:	04 13                	add    $0x13,%al
    125e:	19 27                	sbb    %esp,(%rdi)
  pckt->real_index = key;
    1260:	db ac 00 00 00 13 1b 	fldt   0x1b130000(%rax,%rax,1)
  *real = bpf_map_lookup_elem(&reals, &key);
    1267:	04 05                	add    $0x5,%al
  if (!(*real)) {
    1269:	1b 00                	sbb    (%rax),%eax
    126b:	27                   	(bad)
    126c:	f2 ac                	repnz lods %ds:(%rsi),%al
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    126e:	00 00                	add    %al,(%rax)
    1270:	00 13                	add    %dl,(%rbx)
    1272:	1c 04                	sbb    $0x4,%al
    1274:	01 1a                	add    %ebx,(%rdx)
    1276:	00 27                	add    %ah,(%rdi)
    1278:	f3 ac                	rep lods %ds:(%rsi),%al
    127a:	00 00                	add    %al,(%rax)
    127c:	00 13                	add    %dl,(%rbx)
    127e:	1d 04 01 19 00       	sbb    $0x190104,%eax
    1283:	27                   	(bad)
    1284:	f4                   	hlt
    1285:	ac                   	lods   %ds:(%rsi),%al
    1286:	00 00                	add    %al,(%rax)
    1288:	00 13                	add    %dl,(%rbx)
    128a:	1e                   	(bad)
    128b:	04 01                	add    $0x1,%al
    if (pckt->flow.proto == IPPROTO_UDP) {
    128d:	18 00                	sbb    %al,(%rax)
    128f:	27                   	(bad)
    1290:	f5                   	cmc
    1291:	ac                   	lods   %ds:(%rsi),%al
    1292:	00 00                	add    %al,(%rax)
      new_dst_lru.atime = cur_time;
    1294:	00 13                	add    %dl,(%rbx)
    1296:	1f                   	(bad)
    new_dst_lru.pos = key;
    1297:	04 18                	add    $0x18,%al
    1299:	00 00                	add    %al,(%rax)
    129b:	00 0c fd 04 13 2a 0a 	add    %cl,0xa2a1304(,%rdi,8)
    12a2:	c8 fe 00 00          	enter  $0xfe,$0x0
    12a6:	00 13                	add    %dl,(%rbx)
    12a8:	2b 00                	sub    (%rax),%eax
    12aa:	27                   	(bad)
    12ab:	db fe                	(bad)
    12ad:	00 00                	add    %al,(%rax)
    12af:	00 13                	add    %dl,(%rbx)
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    12b1:	2d 01 03 05 01       	sub    $0x1050301,%eax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    12b6:	27                   	(bad)
    12b7:	f8                   	clc
    12b8:	fe 00                	incb   (%rax)
    12ba:	00 00                	add    %al,(%rax)
    12bc:	13 2e                	adc    (%rsi),%ebp
    12be:	01 02                	add    %eax,(%rdx)
    12c0:	03 01                	add    (%rcx),%eax
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    12c2:	27                   	(bad)
    12c3:	f9                   	stc
    12c4:	fe 00                	incb   (%rax)
    12c6:	00 00                	add    %al,(%rax)
    12c8:	13 2f                	adc    (%rdi),%ebp
    12ca:	01 01                	add    %eax,(%rcx)
    12cc:	02 01                	add    (%rcx),%al
    12ce:	27                   	(bad)
    12cf:	fa                   	cli
    12d0:	fe 00                	incb   (%rax)
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    12d2:	00 00                	add    %al,(%rax)
    12d4:	13 30                	adc    (%rax),%esi
    12d6:	01 01                	add    %eax,(%rcx)
    12d8:	01 01                	add    %eax,(%rcx)
    12da:	27                   	(bad)
    12db:	fb                   	sti
    12dc:	fe 00                	incb   (%rax)
    12de:	00 00                	add    %al,(%rax)
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    12e0:	13 31                	adc    (%rcx),%esi
    12e2:	01 01                	add    %eax,(%rcx)
    12e4:	00 01                	add    %al,(%rcx)
    12e6:	0a fc                	or     %ah,%bh
    12e8:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    12e9:	0e                   	(bad)
    12ea:	00 00                	add    %al,(%rax)
    12ec:	13 3c 02             	adc    (%rdx,%rax,1),%edi
    12ef:	00 2c 00             	add    %ch,(%rax,%rax,1)
    12f2:	01 09                	add    %ecx,(%rcx)
    12f4:	75 0a                	jne    1300 <balancer_ingress+0x1300>
    12f6:	0d 00 00 29 87       	or     $0x87290000,%eax
    12fb:	09 76 78             	or     %esi,0x78(%rsi)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    12fe:	08 00                	or     %al,(%rax)
    1300:	00 29                	add    %ch,(%rcx)
    1302:	88 09                	mov    %cl,(%rcx)
    1304:	77 78                	ja     137e <balancer_ingress+0x137e>
    1306:	08 00                	or     %al,(%rax)
    1308:	00 29                	add    %ch,(%rcx)
    130a:	92                   	xchg   %eax,%edx
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    130b:	09 78 0a             	or     %edi,0xa(%rax)
    130e:	0d 00 00 29 94       	or     $0x94290000,%eax
    1313:	09 79 e9             	or     %edi,-0x17(%rcx)
    1316:	0d 00 00 2d 01       	or     $0x12d0000,%eax
  bool vip_match = address_match && port_match && proto_match;
    131b:	01 09                	add    %ecx,(%rcx)
    131d:	7c 33                	jl     1352 <balancer_ingress+0x1352>
    131f:	13 00                	adc    (%rax),%eax
    1321:	00 2a                	add    %ch,(%rdx)
    1323:	a9 09 7a 0a 0d       	test   $0xd0a7a09,%eax
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1328:	00 00                	add    %al,(%rax)
    132a:	2a d0                	sub    %al,%dl
    132c:	09 7b e6             	or     %edi,-0x1a(%rbx)
    132f:	00 00                	add    %al,(%rax)
    1331:	00 00                	add    %al,(%rax)
    1333:	13 38                	adc    (%rax),%edi
    1335:	13 00                	adc    (%rax),%eax
    1337:	00 2e                	add    %ch,(%rsi)
    1339:	13 01                	adc    (%rcx),%eax
    133b:	14 14                	adc    $0x14,%al
    133d:	19 2f                	sbb    %ebp,(%rdi)
    if (!lru_miss_stat) {
    133f:	02 01                	add    (%rcx),%al
    1341:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1342:	0e                   	(bad)
    1343:	00 00                	add    %al,(%rax)
    1345:	14 1a                	adc    $0x1a,%al
    1347:	00 2f                	add    %ch,(%rdi)
    *lru_miss_stat += 1;
    1349:	03 01                	add    (%rcx),%eax
    134b:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    134c:	0e                   	(bad)
    134d:	00 00                	add    %al,(%rax)
    134f:	14 1b                	adc    $0x1b,%al
    1351:	02 2f                	add    (%rdi),%ch
    1353:	04 01                	add    $0x1,%al
    1355:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    1356:	01 00                	add    %eax,(%rax)
    1358:	00 14 1c             	add    %dl,(%rsp,%rbx,1)
    135b:	04 2f                	add    $0x2f,%al
    135d:	05 01 a4 01 00       	add    $0x1a401,%eax
    1362:	00 14 1d 08 30 06 01 	add    %dl,0x1063008(,%rbx,1)
    1369:	b8 01 00 00 14       	mov    $0x14000001,%eax
      data_stats->v2 += 1;
    136e:	1f                   	(bad)
    136f:	02 01                	add    (%rcx),%al
    1371:	0f 0c                	(bad)
    1373:	30 07                	xor    %al,(%rdi)
    1375:	01 b8 01 00 00 14    	add    %edi,0x14000001(%rax)
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    137b:	20 02                	and    %al,(%rdx)
    137d:	03 0c 0c             	add    (%rsp,%rcx,1),%ecx
    1380:	30 08                	xor    %cl,(%rax)
    1382:	01 b8 01 00 00 14    	add    %edi,0x14000001(%rax)
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1388:	21 02                	and    %eax,(%rdx)
    138a:	04 08                	add    $0x8,%al
    138c:	0c 30                	or     $0x30,%al
        quic_packets_stats->cid_initial += 1;
    138e:	09 01                	or     %eax,(%rcx)
    1390:	b8 01 00 00 14       	mov    $0x14000001,%eax
    1395:	22 02                	and    (%rdx),%al
    1397:	01 07                	add    %eax,(%rdi)
    1399:	0c 30                	or     $0x30,%al
    139b:	0a 01                	or     (%rcx),%al
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    139d:	b8 01 00 00 14       	mov    $0x14000001,%eax
    13a2:	23 02                	and    (%rdx),%eax
    13a4:	01 06                	add    %eax,(%rsi)
    13a6:	0c 30                	or     $0x30,%al
    13a8:	0b 01                	or     (%rcx),%eax
    13aa:	b8 01 00 00 14       	mov    $0x14000001,%eax
    13af:	24 02                	and    $0x2,%al
    13b1:	01 05 0c 30 0c 01    	add    %eax,0x10c300c(%rip)        # 10c43c3 <_license+0x10c24d0>
  if (!per_vip_stats) {
    13b7:	b8 01 00 00 14       	mov    $0x14000001,%eax
    per_vip_stats->v1 += 1;
    13bc:	25 02 01 04 0c       	and    $0xc040102,%eax
    13c1:	30 0d 01 b8 01 00    	xor    %cl,0x1b801(%rip)        # 1cbc8 <_license+0x1acd5>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    13c7:	00 14 26             	add    %dl,(%rsi,%riz,1)
    13ca:	02 01                	add    (%rcx),%al
    13cc:	03 0c 30             	add    (%rax,%rsi,1),%ecx
    13cf:	0e                   	(bad)
    13d0:	01 b8 01 00 00 14    	add    %edi,0x14000001(%rax)
    13d6:	27                   	(bad)
    13d7:	02 01                	add    (%rcx),%al
    13d9:	02 0c 30             	add    (%rax,%rsi,1),%cl
  if (!connId) {
    13dc:	0f 01 b8 01 00 00 14 	invlpg 0x14000001(%rax)
    13e3:	28 02                	sub    %al,(%rdx)
    13e5:	01 01                	add    %eax,(%rcx)
    13e7:	0c 30                	or     $0x30,%al
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    13e9:	10 01                	adc    %al,(%rcx)
    13eb:	b8 01 00 00 14       	mov    $0x14000001,%eax
    13f0:	29 02                	sub    %eax,(%rdx)
    13f2:	01 00                	add    %eax,(%rax)
    13f4:	0c 2f                	or     $0x2f,%al
    13f6:	11 01                	adc    %eax,(%rcx)
    13f8:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    13f9:	0e                   	(bad)
    13fa:	00 00                	add    %al,(%rax)
    13fc:	14 39                	adc    $0x39,%al
    13fe:	0e                   	(bad)
    13ff:	0a bd ae 0e 00 00    	or     0xeae(%rbp),%bh
    1405:	14 3a                	adc    $0x3a,%al
    1407:	10 2f                	adc    %ch,(%rdi)
    1409:	12 01                	adc    (%rcx),%al
    140b:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    140c:	0e                   	(bad)
    140d:	00 00                	add    %al,(%rax)
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    140f:	14 3b                	adc    $0x3b,%al
    1411:	12 00                	adc    (%rax),%al
    1413:	2c 14                	sub    $0x14,%al
    1415:	01 0b                	add    %ecx,(%rbx)
    1417:	5e                   	pop    %rsi
    1418:	a8 00                	test   $0x0,%al
    141a:	00 00                	add    %al,(%rax)
    141c:	29 87 0b 5f 78 08    	sub    %eax,0x8785f0b(%rdi)
    1422:	00 00                	add    %al,(%rax)
    1424:	29 88 0b 60 78 08    	sub    %ecx,0x878600b(%rax)
    142a:	00 00                	add    %al,(%rax)
      if (qpr.server_id > 0) {
    142c:	2a e0                	sub    %al,%ah
    142e:	0b 63 ac             	or     -0x54(%rbx),%esp
    1431:	01 00                	add    %eax,(%rax)
    1433:	00 2a                	add    %ch,(%rdx)
    1435:	d0 0b                	rorb   (%rbx)
    1437:	64 e6 00             	fs out %al,$0x0
    143a:	00 00                	add    %al,(%rax)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    143c:	2a c3                	sub    %bl,%al
    143e:	0b 61 b6             	or     -0x4a(%rcx),%esp
    1441:	0e                   	(bad)
    1442:	00 00                	add    %al,(%rax)
    1444:	2a d1                	sub    %cl,%dl
    1446:	0b 62 c0             	or     -0x40(%rdx),%esp
    1449:	11 00                	adc    %eax,(%rax)
    144b:	00 00                	add    %al,(%rax)
    144d:	2c 15                	sub    $0x15,%al
    144f:	01 09                	add    %ecx,(%rcx)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1451:	5b                   	pop    %rbx
    1452:	0a 0d 00 00 29 87    	or     -0x78d70000(%rip),%cl        # ffffffff87291458 <server_id_map+0x36fc46aad458>
    1458:	09 5c 78 08          	or     %ebx,0x8(%rax,%rdi,2)
    145c:	00 00                	add    %al,(%rax)
    145e:	29 88 09 5d 78 08    	sub    %ecx,0x8785d09(%rax)
  if (!connId) {
    1464:	00 00                	add    %al,(%rax)
    1466:	29 92 09 5e 0a 0d    	sub    %edx,0xd0a5e09(%rdx)
  __u8 connIdVersion = (connId[0] >> 6);
    146c:	00 00                	add    %al,(%rax)
    146e:	29 94 09 5f e9 0d 00 	sub    %edx,0xde95f(%rcx,%rcx,1)
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    1475:	00 2d 16 01 09 62    	add    %ch,0x62090116(%rip)        # 62091591 <_license+0x6208f69e>
    147b:	90                   	nop
    147c:	14 00                	adc    $0x0,%al
    147e:	00 2a                	add    %ch,(%rdx)
    1480:	a9 09 60 0a 0d       	test   $0xd0a6009,%eax
    1485:	00 00                	add    %al,(%rax)
    1487:	2a d0                	sub    %al,%dl
    1489:	09 61 e6             	or     %esp,-0x1a(%rcx)
    148c:	00 00                	add    %al,(%rax)
    148e:	00 00                	add    %al,(%rax)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    1490:	13 95 14 00 00 2e    	adc    0x2e000014(%rbp),%edx
    1496:	18 01                	sbb    %al,(%rcx)
    1498:	08 15 17 2f 02 01    	or     %dl,0x1022f17(%rip)        # 10243b5 <_license+0x10224c2>
    149e:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    149f:	0e                   	(bad)
    14a0:	00 00                	add    %al,(%rax)
    14a2:	15 18 00 2f 03       	adc    $0x32f0018,%eax
    14a7:	01 a6 0e 00 00 15    	add    %esp,0x1500000e(%rsi)
    14ad:	19 02                	sbb    %eax,(%rdx)
    14af:	2f                   	(bad)
    14b0:	17                   	(bad)
    14b1:	01 a6 0e 00 00 15    	add    %esp,0x1500000e(%rsi)
    14b7:	1a 04 0a             	sbb    (%rdx,%rcx,1),%al
    14ba:	bd ae 0e 00 00       	mov    $0xeae,%ebp
    14bf:	15 1b 06 00 31       	adc    $0x3100061b,%eax
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    14c4:	19 01                	sbb    %eax,(%rcx)
    14c6:	09 53 01             	or     %edx,0x1(%rbx)
        if (real_pos) {
    14c9:	56                   	push   %rsi
    14ca:	0d 00 00 20 87       	or     $0x87200000,%eax
    14cf:	09 54 01 78          	or     %edx,0x78(%rcx,%rax,1)
    14d3:	08 00                	or     %al,(%rax)
          key = *real_pos;
    14d5:	00 20                	add    %ah,(%rax)
    14d7:	88 09                	mov    %cl,(%rcx)
    14d9:	55                   	push   %rbp
    14da:	01 78 08             	add    %edi,0x8(%rax)
    14dd:	00 00                	add    %al,(%rax)
          if (key == 0) {
    14df:	20 92 09 56 01 0a    	and    %dl,0xa015609(%rdx)
            pckt.real_index = key;
    14e5:	0d 00 00 20 94       	or     $0x94200000,%eax
            dst = bpf_map_lookup_elem(&reals, &key);
    14ea:	09 57 01             	or     %edx,0x1(%rdi)
    14ed:	e9 0d 00 00 32       	jmp    320014ff <_license+0x31fff60c>
    14f2:	1a 01                	sbb    (%rcx),%al
    14f4:	09 58 01             	or     %ebx,0x1(%rax)
    14f7:	56                   	push   %rsi
    14f8:	0d 00 00 32 1b       	or     $0x1b320000,%eax
    14fd:	01 09                	add    %ecx,(%rcx)
    14ff:	67 01 ee             	addr32 add %ebp,%esi
    1502:	0d 00 00 32 1c       	or     $0x1c320000,%eax
            if (!dst) {
    1507:	01 09                	add    %ecx,(%rcx)
    1509:	68 01 ee 0d 00       	push   $0xdee01
    150e:	00 32                	add    %dh,(%rdx)
    1510:	1d 01 09 69 01       	sbb    $0x1690901,%eax
    1515:	ee                   	out    %al,(%dx)
    1516:	0d 00 00 32 1e       	or     $0x1e320000,%eax
    151b:	01 09                	add    %ecx,(%rcx)
    151d:	8c 01                	mov    %es,(%rcx)
    151f:	fe 00                	incb   (%rax)
    1521:	00 00                	add    %al,(%rax)
    1523:	21 a9 09 5f 01 0a    	and    %ebp,0xa015f09(%rcx)
  if (dst_lru) {
    1529:	0d 00 00 21 d0       	or     $0xd0210000,%eax
    152e:	09 60 01             	or     %esp,0x1(%rax)
    if (dst_lru->pos == pckt->real_index) {
    1531:	e6 00                	out    %al,$0x0
    1533:	00 00                	add    %al,(%rax)
    1535:	22 32                	and    (%rdx),%dh
    1537:	1f                   	(bad)
    1538:	01 09                	add    %ecx,(%rcx)
    153a:	7b 01                	jnp    153d <balancer_ingress+0x153d>
              quic_packets_stats->dst_match_in_lru += 1;
    153c:	73 09                	jae    1547 <balancer_ingress+0x1547>
    153e:	00 00                	add    %al,(%rax)
    1540:	00 00                	add    %al,(%rax)
    1542:	31 20                	xor    %esp,(%rax)
    1544:	01 0b                	add    %ecx,(%rbx)
    1546:	44 01 0a             	add    %r9d,(%rdx)
    1549:	0d 00 00 20 87       	or     $0x87200000,%eax
    154e:	0b 44 01 78          	or     0x78(%rcx,%rax,1),%eax
    1552:	08 00                	or     %al,(%rax)
    1554:	00 20                	add    %ah,(%rax)
    1556:	88 0b                	mov    %cl,(%rbx)
    1558:	44 01 78 08          	add    %r15d,0x8(%rax)
    155c:	00 00                	add    %al,(%rax)
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    155e:	20 92 0b 44 01 0a    	and    %dl,0xa01440b(%rdx)
    1564:	0d 00 00 21 d0       	or     $0xd0210000,%eax
    1569:	0b 45 01             	or     0x1(%rbp),%eax
    156c:	e6 00                	out    %al,$0x0
    156e:	00 00                	add    %al,(%rax)
    1570:	22 21                	and    (%rcx),%ah
    1572:	d1 0b                	rorl   (%rbx)
    1574:	47 01 c0             	rex.RXB add %r8d,%r8d
    1577:	11 00                	adc    %eax,(%rax)
    1579:	00 00                	add    %al,(%rax)
    157b:	22 21                	and    (%rcx),%ah
    157d:	d1 0b                	rorl   (%rbx)
    157f:	4c 01 0f             	add    %r9,(%rdi)
    1582:	10 00                	adc    %al,(%rax)
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1584:	00 00                	add    %al,(%rax)
    1586:	00 33                	add    %dh,(%rbx)
    1588:	21 01                	and    %eax,(%rcx)
    158a:	00 b0 34 22 01 00    	add    %dh,0x12234(%rax)
    1590:	b1 f7                	mov    $0xf7,%cl
    1592:	15 00 00 29 94       	adc    $0x94290000,%eax
    1597:	00 b2 e9 0d 00 00    	add    %dh,0xde9(%rdx)
    159d:	29 a1 00 b3 78 08    	sub    %esp,0x878b300(%rcx)
      if (qpr.server_id > 0) {
    15a3:	00 00                	add    %al,(%rax)
    15a5:	34 23                	xor    $0x23,%al
    15a7:	01 00                	add    %eax,(%rax)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    15a9:	b4 0a                	mov    $0xa,%ah
    15ab:	0d 00 00 2d 24       	or     $0x242d0000,%eax
    15b0:	01 00                	add    %eax,(%rax)
    15b2:	b5 fc                	mov    $0xfc,%ch
    15b4:	15 00 00 2d 25       	adc    $0x252d0000,%eax
    15b9:	01 00                	add    %eax,(%rax)
    15bb:	b6 e6                	mov    $0xe6,%dh
    15bd:	00 00                	add    %al,(%rax)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    15bf:	00 2a                	add    %ch,(%rdx)
    15c1:	09 00                	or     %eax,(%rax)
    15c3:	b7 ac                	mov    $0xac,%bh
    15c5:	00 00                	add    %al,(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    15c7:	00 22                	add    %ah,(%rdx)
    15c9:	2a a6 00 c5 78 08    	sub    0x878c500(%rsi),%ah
    15cf:	00 00                	add    %al,(%rax)
    15d1:	22 2a                	and    (%rdx),%ch
    15d3:	07                   	(bad)
    15d4:	00 c5                	add    %al,%ch
    15d6:	4c 0d 00 00 22 2a    	rex.WR or $0x2a220000,%rax
  if (!conn_rate_stats) {
    15dc:	b2 00                	mov    $0x0,%dl
    15de:	c5 ac 00             	(bad)
    15e1:	00 00                	add    %al,(%rax)
    15e3:	2a 14 00             	sub    (%rax,%rax,1),%dl
    15e6:	c5 77 0d             	(bad)
    15e9:	00 00                	add    %al,(%rax)
  *cur_time = bpf_ktime_get_ns();
    15eb:	2a b3 00 c5 77 0d    	sub    0xd77c500(%rbx),%dh
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    15f1:	00 00                	add    %al,(%rax)
    15f3:	00 00                	add    %al,(%rax)
    15f5:	00 00                	add    %al,(%rax)
    15f7:	13 38                	adc    (%rax),%edi
    15f9:	0d 00 00 13 ac       	or     $0xac130000,%eax
    15fe:	02 00                	add    (%rax),%al
    conn_rate_stats->v1 = 1;
    1600:	00 35 26 01 00 7e    	add    %dh,0x7e000126(%rip)        # 7e00172c <_license+0x7dfff839>
    1606:	02 20                	add    (%rax),%ah
    conn_rate_stats->v2 = *cur_time;
    1608:	20 00                	and    %al,(%rax)
    160a:	7e 02                	jle    160e <balancer_ingress+0x160e>
    160c:	ac                   	lods   %ds:(%rsi),%al
    160d:	00 00                	add    %al,(%rax)
    160f:	00 36                	add    %dh,(%rsi)
    1611:	27                   	(bad)
    1612:	01 00                	add    %eax,(%rax)
    1614:	7e 02                	jle    1618 <balancer_ingress+0x1618>
    1616:	0a 0d 00 00 36 28    	or     0x28360000(%rip),%cl        # 2836161c <_license+0x2835f729>
    161c:	01 00                	add    %eax,(%rax)
    161e:	7e 02                	jle    1622 <balancer_ingress+0x1622>
    1620:	0a 0d 00 00 32 29    	or     0x29320000(%rip),%cl        # 29321626 <_license+0x2931f733>
    1626:	01 00                	add    %eax,(%rax)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1628:	7f 02                	jg     162c <balancer_ingress+0x162c>
    162a:	42 0d 00 00 22 21    	rex.X or $0x21220000,%eax
    1630:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1631:	00 80 02 78 08 00    	add    %al,0x87802(%rax)
    1637:	00 22                	add    %ah,(%rdx)
          key = *real_pos;
    1639:	21 07                	and    %eax,(%rdi)
    163b:	00 80 02 4c 0d 00    	add    %al,0xd4c02(%rax)
    1641:	00 00                	add    %al,(%rax)
          if (key == 0) {
    1643:	00 00                	add    %al,(%rax)
            pckt.real_index = key;
    1645:	31 2a                	xor    %ebp,(%rdx)
    1647:	01 00                	add    %eax,(%rax)
    1649:	8c 02                	mov    %es,(%rdx)
            dst = bpf_map_lookup_elem(&reals, &key);
    164b:	a8 00                	test   $0x0,%al
    164d:	00 00                	add    %al,(%rax)
    164f:	20 25 00 8d 02 f7    	and    %ah,-0x8fd7300(%rip)        # fffffffff702a355 <server_id_map+0x36fcb6846355>
    1655:	15 00 00 20 94       	adc    $0x94200000,%eax
    165a:	00 8e 02 e9 0d 00    	add    %cl,0xde902(%rsi)
    1660:	00 20                	add    %ah,(%rax)
    1662:	9d                   	popf
    1663:	00 8f 02 3d 0d 00    	add    %cl,0xd3d02(%rdi)
    1669:	00 20                	add    %ah,(%rax)
    166b:	17                   	(bad)
    166c:	00 90 02 d7 16 00    	add    %dl,0x16d702(%rax)
            if (!dst) {
    1672:	00 32                	add    %dh,(%rdx)
    1674:	25 01 00 91 02       	and    $0x2910001,%eax
    1679:	e6 00                	out    %al,$0x0
    167b:	00 00                	add    %al,(%rax)
    167d:	22 32                	and    (%rdx),%dh
    167f:	2b 01                	sub    (%rcx),%eax
    1681:	00 95 02 78 08 00    	add    %dl,0x87802(%rbp)
    1687:	00 22                	add    %ah,(%rdx)
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1689:	21 a6 00 95 02 78    	and    %esp,0x78029500(%rsi)
  if (dst_lru) {
    168f:	08 00                	or     %al,(%rax)
    1691:	00 22                	add    %ah,(%rdx)
    1693:	21 07                	and    %eax,(%rdi)
    if (dst_lru->pos == pckt->real_index) {
    1695:	00 95 02 4c 0d 00    	add    %dl,0xd4c02(%rbp)
    169b:	00 00                	add    %al,(%rax)
    169d:	00 22                	add    %ah,(%rdx)
    169f:	32 2c 01             	xor    (%rcx,%rax,1),%ch
              quic_packets_stats->dst_match_in_lru += 1;
    16a2:	00 97 02 78 08 00    	add    %dl,0x87802(%rdi)
    16a8:	00 22                	add    %ah,(%rdx)
    16aa:	21 9e 00 9c 02 ac    	and    %ebx,-0x53fd6400(%rsi)
    16b0:	00 00                	add    %al,(%rax)
    16b2:	00 32                	add    %dh,(%rdx)
    16b4:	2d 01 00 9d 02       	sub    $0x29d0001,%eax
    16b9:	42 0d 00 00 22 21    	rex.X or $0x21220000,%eax
  original_sport = pckt.flow.port16[0];
    16bf:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    16c0:	00 9d 02 78 08 00    	add    %bl,0x87802(%rbp)
    16c6:	00 22                	add    %ah,(%rdx)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    16c8:	21 07                	and    %eax,(%rdi)
    16ca:	00 9d 02 4c 0d 00    	add    %bl,0xd4c02(%rbp)
    16d0:	00 00                	add    %al,(%rax)
    16d2:	00 00                	add    %al,(%rax)
    16d4:	00 00                	add    %al,(%rax)
    16d6:	00 13                	add    %dl,(%rbx)
    16d8:	6d                   	insl   (%dx),%es:(%rdi)
    16d9:	01 00                	add    %eax,(%rax)
    16db:	00 2c 2e             	add    %ch,(%rsi,%rbp,1)
    16de:	01 00                	add    %eax,(%rax)
    16e0:	26 0a 0d 00 00 34 25 	es or  0x25340000(%rip),%cl        # 253416e7 <_license+0x2533f7f4>
  if (!dst_lru) {
    16e7:	01 00                	add    %eax,(%rax)
    16e9:	27                   	(bad)
    16ea:	f3 0d 00 00 2d 2f    	repz or $0x2f2d0000,%eax
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    16f0:	01 00                	add    %eax,(%rax)
    16f2:	28 ac 00 00 00 2d 30 	sub    %ch,0x302d0000(%rax,%rax,1)
    16f9:	01 00                	add    %eax,(%rax)
    cur_time = bpf_ktime_get_ns();
    16fb:	29 42 0d             	sub    %eax,0xd(%rdx)
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    16fe:	00 00                	add    %al,(%rax)
    1700:	22 2a                	and    (%rdx),%ch
    1702:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1703:	00 2a                	add    %ch,(%rdx)
    1705:	78 08                	js     170f <balancer_ingress+0x170f>
    1707:	00 00                	add    %al,(%rax)
    1709:	22 2a                	and    (%rdx),%ch
    170b:	07                   	(bad)
    170c:	00 2a                	add    %ch,(%rdx)
    170e:	4c 0d 00 00 00 00    	rex.WR or $0x0,%rax
    1714:	00 2c 31             	add    %ch,(%rcx,%rsi,1)
    1717:	01 0d 58 0a 0d 00    	add    %ecx,0xd0a58(%rip)        # d2175 <_license+0xd0282>
    dst_lru->atime = cur_time;
    171d:	00 29                	add    %ch,(%rcx)
  key = dst_lru->pos;
    171f:	86 0d 59 a0 0c 00    	xchg   %cl,0xca059(%rip)        # cb77e <_license+0xc988b>
    1725:	00 29                	add    %ch,(%rcx)
    1727:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    1728:	0d 5a 47 0d 00       	or     $0xd475a,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
    172d:	00 29                	add    %ch,(%rcx)
    172f:	94                   	xchg   %eax,%esp
    1730:	0d 5b e9 0d 00       	or     $0xde95b,%eax
    1735:	00 29                	add    %ch,(%rcx)
    1737:	25 0d 5c 38 0d       	and    $0xd385c0d,%eax
    173c:	00 00                	add    %al,(%rax)
    173e:	29 a2 0d 5d ac 00    	sub    %esp,0xac5d0d(%rdx)
    1744:	00 00                	add    %al,(%rax)
    1746:	2a b6 0d 60 f8 0d    	sub    0xdf8600d(%rsi),%dh
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    174c:	00 00                	add    %al,(%rax)
    174e:	2d 32 01 0d 63       	sub    $0x630d0132,%eax
    1753:	ac                   	lods   %ds:(%rsi),%al
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1754:	00 00                	add    %al,(%rax)
    1756:	00 2a                	add    %ch,(%rdx)
    1758:	e1 0d                	loope  1767 <balancer_ingress+0x1767>
    175a:	64 e6 00             	fs out %al,$0x0
    175d:	00 00                	add    %al,(%rax)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    175f:	2a 87 0d 5e 78 08    	sub    0x8785e0d(%rdi),%al
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1765:	00 00                	add    %al,(%rax)
    1767:	2a 88 0d 5f 78 08    	sub    0x8785f0d(%rax),%cl
    176d:	00 00                	add    %al,(%rax)
    176f:	2d 33 01 0d 61       	sub    $0x610d0133,%eax
    1774:	82                   	(bad)
    1775:	17                   	(bad)
    1776:	00 00                	add    %al,(%rax)
    1778:	2d 38 01 0d 62       	sub    $0x620d0138,%eax
  if (!conn_rate_stats) {
    177d:	82                   	(bad)
    177e:	17                   	(bad)
    177f:	00 00                	add    %al,(%rax)
    1781:	00 13                	add    %dl,(%rbx)
    1783:	87 17                	xchg   %edx,(%rdi)
    1785:	00 00                	add    %al,(%rax)
    1787:	2e 37                	cs (bad)
    1789:	01 0e                	add    %ecx,(%rsi)
    178b:	16                   	(bad)
    178c:	ad                   	lods   %ds:(%rsi),%eax
    178d:	2f                   	(bad)
    178e:	34 01                	xor    $0x1,%al
  *cur_time = bpf_ktime_get_ns();
    1790:	ac                   	lods   %ds:(%rsi),%al
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1791:	17                   	(bad)
    1792:	00 00                	add    %al,(%rax)
    1794:	16                   	(bad)
    1795:	ae                   	scas   %es:(%rdi),%al
    1796:	00 2f                	add    %ch,(%rdi)
    1798:	35 01 ac 17 00       	xor    $0x17ac01,%eax
    179d:	00 16                	add    %dl,(%rsi)
    179f:	af                   	scas   %es:(%rdi),%eax
    17a0:	06                   	(bad)
    conn_rate_stats->v1 = 1;
    17a1:	2f                   	(bad)
    17a2:	36 01 a6 0e 00 00 16 	ss add %esp,0x1600000e(%rsi)
    conn_rate_stats->v2 = *cur_time;
    17a9:	b0 0c                	mov    $0xc,%al
    17ab:	00 04 06             	add    %al,(%rsi,%rax,1)
    conn_rate_stats->v1 += 1;
    17ae:	01 00                	add    %eax,(%rax)
    17b0:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 1811 <balancer_ingress+0x1811>
    17b6:	06                   	(bad)
    17b7:	00 33                	add    %dh,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    17b9:	39 01                	cmp    %eax,(%rcx)
    17bb:	0e                   	(bad)
    17bc:	31 29                	xor    %ebp,(%rcx)
    17be:	b6 0e                	mov    $0xe,%dh
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    17c0:	32 f8                	xor    %al,%bh
    17c2:	0d 00 00 29 97       	or     $0x97290000,%eax
    17c7:	0e                   	(bad)
    17c8:	33 fe                	xor    %esi,%edi
    17ca:	00 00                	add    %al,(%rax)
    17cc:	00 29                	add    %ch,(%rcx)
    17ce:	bf 0e 34 ac 00       	mov    $0xac340e,%edi
    17d3:	00 00                	add    %al,(%rax)
    17d5:	29 c0                	sub    %eax,%eax
    17d7:	0e                   	(bad)
    17d8:	35 ac 00 00 00       	xor    $0xac,%eax
    if (down_reals_map) {
    17dd:	29 a2 0e 36 b8 01    	sub    %esp,0x1b8360e(%rdx)
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    17e3:	00 00                	add    %al,(%rax)
    17e5:	29 1d 0e 37 fe 00    	sub    %ebx,0xfe370e(%rip)        # fe4ef9 <_license+0xfe3006>
      if (down_real) {
    17eb:	00 00                	add    %al,(%rax)
    17ed:	2a e1                	sub    %cl,%ah
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
    17ef:	0e                   	(bad)
    17f0:	38 e6                	cmp    %ah,%dh
    17f2:	00 00                	add    %al,(%rax)
    17f4:	00 00                	add    %al,(%rax)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    17f6:	2c 3a                	sub    $0x3a,%al
    17f8:	01 00                	add    %eax,(%rax)
    17fa:	57                   	push   %rdi
    17fb:	0a 0d 00 00 34 22    	or     0x22340000(%rip),%cl        # 22341801 <_license+0x2233f90e>
    1801:	01 00                	add    %eax,(%rax)
    1803:	58                   	pop    %rax
    1804:	f7 15 00 00 29 94    	notl   -0x6bd70000(%rip)        # ffffffff9429180a <server_id_map+0x36fc53aad80a>
    180a:	00 59 e9             	add    %bl,-0x17(%rcx)
        if (stats_data) {
    180d:	0d 00 00 29 9d       	or     $0x9d290000,%eax
    1812:	00 5a 3d             	add    %bl,0x3d(%rdx)
    1815:	0d 00 00 29 92       	or     $0x92290000,%eax
          stats_data->v1 += 1;
    181a:	00 5b 0a             	add    %bl,0xa(%rbx)
    181d:	0d 00 00 29 a1       	or     $0xa1290000,%eax
    if (!dst) {
    1822:	00 5c 78 08          	add    %bl,0x8(%rax,%rdi,2)
    1826:	00 00                	add    %al,(%rax)
    1828:	2d 3b 01 00 5e       	sub    $0x5e00013b,%eax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    182d:	ac                   	lods   %ds:(%rsi),%al
    182e:	02 00                	add    (%rax),%al
    1830:	00 2d 3c 01 00 5f    	add    %ch,0x5f00013c(%rip)        # 5f001972 <_license+0x5efffa7f>
    1836:	0a 0d 00 00 2d 3d    	or     0x3d2d0000(%rip),%cl        # 3d2d183c <_license+0x3d2cf949>
    183c:	01 00                	add    %eax,(%rax)
    183e:	60                   	(bad)
    183f:	0a 0d 00 00 2d 25    	or     0x252d0000(%rip),%cl        # 252d1845 <_license+0x252cf952>
    1845:	01 00                	add    %eax,(%rax)
    1847:	62 e6                	(bad)
    1849:	00 00                	add    %al,(%rax)
    184b:	00 2d 3e 01 00 63    	add    %ch,0x6300013e(%rip)        # 6300198f <_license+0x62fffa9c>
  if (!data_stats) {
    1851:	ac                   	lods   %ds:(%rsi),%al
    1852:	00 00                	add    %al,(%rax)
    1854:	00 2a                	add    %ch,(%rdx)
    1856:	09 00                	or     %eax,(%rax)
    1858:	64 ac                	lods   %fs:(%rsi),%al
    185a:	00 00                	add    %al,(%rax)
    185c:	00 2a                	add    %ch,(%rdx)
    185e:	b1 00                	mov    $0x0,%cl
    1860:	61                   	(bad)
  data_stats->v1 += 1;
    1861:	64 09 00             	or     %eax,%fs:(%rax)
    1864:	00 22                	add    %ah,(%rdx)
  data_stats->v2 += pkt_bytes;
    1866:	2d 3f 01 00 86       	sub    $0x8600013f,%eax
    186b:	0a 0d 00 00 22 2a    	or     0x2a220000(%rip),%cl        # 2a221871 <_license+0x2a21f97e>
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1871:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1872:	00 92 78 08 00 00    	add    %dl,0x878(%rdx)
    1878:	22 2a                	and    (%rdx),%ch
    187a:	07                   	(bad)
    187b:	00 92 4c 0d 00 00    	add    %dl,0xd4c(%rdx)
  if (!data_stats) {
    1881:	22 2a                	and    (%rdx),%ch
    1883:	b2 00                	mov    $0x0,%dl
    1885:	92                   	xchg   %eax,%edx
    1886:	ac                   	lods   %ds:(%rsi),%al
  data_stats->v1 += 1;
    1887:	00 00                	add    %al,(%rax)
    1889:	00 2a                	add    %ch,(%rdx)
  data_stats->v2 += pkt_bytes;
    188b:	14 00                	adc    $0x0,%al
    188d:	92                   	xchg   %eax,%edx
    188e:	77 0d                	ja     189d <balancer_ingress+0x189d>
    1890:	00 00                	add    %al,(%rax)
    1892:	2a b3 00 92 77 0d    	sub    0xd779200(%rbx),%dh
  pckt.flow.port16[0] = original_sport;
    1898:	00 00                	add    %al,(%rax)
    189a:	00 00                	add    %al,(%rax)
    189c:	00 00                	add    %al,(%rax)
  if (dst->flags & F_IPV6) {
    189e:	22 2a                	and    (%rdx),%ch
    18a0:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    18a1:	00 9f 78 08 00 00    	add    %bl,0x878(%rdi)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    18a7:	22 2a                	and    (%rdx),%ch
    18a9:	07                   	(bad)
    18aa:	00 9f 4c 0d 00 00    	add    %bl,0xd4c(%rdi)
    18b0:	22 2a                	and    (%rdx),%ch
    18b2:	b2 00                	mov    $0x0,%dl
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    18b4:	9f                   	lahf
    18b5:	ac                   	lods   %ds:(%rsi),%al
    18b6:	00 00                	add    %al,(%rax)
    18b8:	00 2a                	add    %ch,(%rdx)
    18ba:	14 00                	adc    $0x0,%al
    18bc:	9f                   	lahf
    18bd:	77 0d                	ja     18cc <balancer_ingress+0x18cc>
    18bf:	00 00                	add    %al,(%rax)
    18c1:	2a b3 00 9f 77 0d    	sub    0xd779f00(%rbx),%dh
  data = (void*)(long)xdp->data;
    18c7:	00 00                	add    %al,(%rax)
  data_end = (void*)(long)xdp->data_end;
    18c9:	00 00                	add    %al,(%rax)
    18cb:	00 00                	add    %al,(%rax)
  iph = data + sizeof(struct ethhdr);
    18cd:	2c 40                	sub    $0x40,%al
    18cf:	01 0d 2a 0a 0d 00    	add    %ecx,0xd0a2a(%rip)        # d22ff <_license+0xd040c>
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    18d5:	00 29                	add    %ch,(%rcx)
    18d7:	86 0d 2b a0 0c 00    	xchg   %cl,0xca02b(%rip)        # cb908 <_license+0xc9a15>
    18dd:	00 29                	add    %ch,(%rcx)
    18df:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    18e0:	0d 2c 47 0d 00       	or     $0xd472c,%eax
    18e5:	00 29                	add    %ch,(%rcx)
    18e7:	92                   	xchg   %eax,%edx
    18e8:	0d 2d 0a 0d 00       	or     $0xd0a2d,%eax
    18ed:	00 29                	add    %ch,(%rcx)
    18ef:	94                   	xchg   %eax,%esp
    18f0:	0d 2e e9 0d 00       	or     $0xde92e,%eax
    18f5:	00 29                	add    %ch,(%rcx)
    18f7:	25 0d 2f 38 0d       	and    $0xd382f0d,%eax
    18fc:	00 00                	add    %al,(%rax)
    18fe:	29 a2 0d 30 ac 00    	sub    %esp,0xac300d(%rdx)
    1904:	00 00                	add    %al,(%rax)
    1906:	2a 87 0d 31 78 08    	sub    0x878310d(%rdi),%al
  memcpy(new_eth->h_dest, cval->mac, 6);
    190c:	00 00                	add    %al,(%rax)
    190e:	2a 88 0d 32 78 08    	sub    0x878320d(%rax),%cl
    1914:	00 00                	add    %al,(%rax)
    1916:	2d 33 01 0d 34       	sub    $0x340d0133,%eax
    191b:	82                   	(bad)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    191c:	17                   	(bad)
    191d:	00 00                	add    %al,(%rax)
    191f:	2a c3                	sub    %bl,%al
    1921:	0d 33 b6 0e 00       	or     $0xeb633,%eax
    1926:	00 2d 38 01 0d 35    	add    %ch,0x350d0138(%rip)        # 350d1a64 <_license+0x350cfb71>
  new_eth->h_proto = BE_ETH_P_IP;
    192c:	82                   	(bad)
    192d:	17                   	(bad)
    192e:	00 00                	add    %al,(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1930:	2a 1d 0d 38 fe 00    	sub    0xfe380d(%rip),%bl        # fe5143 <_license+0xfe3250>
    1936:	00 00                	add    %al,(%rax)
    1938:	2a bf 0d 37 49 19    	sub    0x1949370d(%rdi),%bh
  iph->tos = tos;
    193e:	00 00                	add    %al,(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1940:	2a c6                	sub    %dh,%al
    1942:	0d 36 b8 01 00       	or     $0x1b836,%eax
    1947:	00 00                	add    %al,(%rax)
    1949:	04 ac                	add    $0xac,%al
    194b:	00 00                	add    %al,(%rax)
    194d:	00 05 5b 00 00 00    	add    %al,0x5b(%rip)        # 19ae <balancer_ingress+0x19ae>
  iph->id = 0;
    1953:	04 00                	add    $0x0,%al
  iph->daddr = daddr;
    1955:	33 41 01             	xor    0x1(%rcx),%eax
  iph->saddr = saddr;
    1958:	0e                   	(bad)
    1959:	21 29                	and    %ebp,(%rcx)
  iph->ttl = DEFAULT_TTL;
    195b:	1a 0e                	sbb    (%rsi),%cl
    195d:	21 b8 01 00 00 29    	and    %edi,0x29000001(%rax)
    1963:	23 0e                	and    (%rsi),%ecx
    1965:	21 a4 01 00 00 29 bf 	and    %esp,-0x40d70000(%rcx,%rax,1)
    196c:	0e                   	(bad)
    196d:	21 64 09 00          	and    %esp,0x0(%rcx,%rcx,1)
    1971:	00 00                	add    %al,(%rax)
    1973:	33 42 01             	xor    0x1(%rdx),%eax
    1976:	0e                   	(bad)
    1977:	4c 29 c3             	sub    %r8,%rbx
    197a:	0e                   	(bad)
    197b:	4d b6 0e             	rex.WRB mov $0xe,%r14b
    197e:	00 00                	add    %al,(%rax)
    1980:	34 43                	xor    $0x43,%al
    1982:	01 0e                	add    %ecx,(%rsi)
    1984:	4e fe 00             	rex.WRX incb (%rax)
    1987:	00 00                	add    %al,(%rax)
    1989:	29 bf 0e 4f 64 09    	sub    %edi,0x9644f0e(%rdi)
    198f:	00 00                	add    %al,(%rax)
    1991:	29 c0                	sub    %eax,%eax
    1993:	0e                   	(bad)
    1994:	50                   	push   %rax
    1995:	64 09 00             	or     %eax,%fs:(%rax)
    1998:	00 29                	add    %ch,(%rcx)
    199a:	c6                   	(bad)
    199b:	0e                   	(bad)
    199c:	51                   	push   %rcx
    199d:	b8 01 00 00 29       	mov    $0x29000001,%eax
    19a2:	1d 0e 52 fe 00       	sbb    $0xfe520e,%eax
    19a7:	00 00                	add    %al,(%rax)
    19a9:	00 2c 44             	add    %ch,(%rsp,%rax,2)
    19ac:	01 00                	add    %eax,(%rax)
    19ae:	19 ac 00 00 00 29 94 	sbb    %ebp,-0x6bd70000(%rax,%rax,1)
    19b5:	00 1a                	add    %bl,(%rdx)
    19b7:	e9 0d 00 00 34       	jmp    340019c9 <_license+0x33fffad6>
    19bc:	3f                   	(bad)
    19bd:	01 00                	add    %eax,(%rax)
    19bf:	1b 0a                	sbb    (%rdx),%ecx
    19c1:	0d 00 00 00 2c       	or     $0x2c000000,%eax
    19c6:	45 01 0a             	add    %r9d,(%r10)
    19c9:	37                   	(bad)
    19ca:	d0 09                	rorb   (%rcx)
    19cc:	00 00                	add    %al,(%rax)
    19ce:	29 09                	sub    %ecx,(%rcx)
    19d0:	0a 37                	or     (%rdi),%dh
    19d2:	0d 1a 00 00 34       	or     $0x3400001a,%eax
    19d7:	46 01 0a             	rex.RX add %r9d,(%rdx)
    19da:	37                   	(bad)
    19db:	d0 09                	rorb   (%rcx)
    19dd:	00 00                	add    %al,(%rax)
    19df:	34 47                	xor    $0x47,%al
    19e1:	01 0a                	add    %ecx,(%rdx)
    19e3:	37                   	(bad)
    19e4:	d0 09                	rorb   (%rcx)
    19e6:	00 00                	add    %al,(%rax)
    19e8:	2d 48 01 0a 38       	sub    $0x380a0148,%eax
    19ed:	d0 09                	rorb   (%rcx)
    19ef:	00 00                	add    %al,(%rax)
    19f1:	2d 49 01 0a 38       	sub    $0x380a0149,%eax
    19f6:	d0 09                	rorb   (%rcx)
      if (pckt.flow.proto == IPPROTO_TCP) {
    19f8:	00 00                	add    %al,(%rax)
    19fa:	2d 4a 01 0a 38       	sub    $0x380a014a,%eax
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
    19ff:	d0 09                	rorb   (%rcx)
    1a01:	00 00                	add    %al,(%rax)
    1a03:	2d 4b 01 0a 39       	sub    $0x390a014b,%eax
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1a08:	13 1a                	adc    (%rdx),%ebx
    1a0a:	00 00                	add    %al,(%rax)
    1a0c:	00 13                	add    %dl,(%rbx)
    1a0e:	12 1a                	adc    (%rdx),%bl
    1a10:	00 00                	add    %al,(%rax)
    1a12:	37                   	(bad)
    1a13:	13 18                	adc    (%rax),%ebx
    1a15:	1a 00                	sbb    (%rax),%al
    1a17:	00 26                	add    %ah,(%rsi)
    1a19:	06                   	(bad)
    1a1a:	01 00                	add    %eax,(%rax)
        if (!lru_stats) {
    1a1c:	00 2c 4c             	add    %ch,(%rsp,%rcx,2)
    1a1f:	01 0a                	add    %ecx,(%rdx)
    1a21:	07                   	(bad)
    1a22:	ac                   	lods   %ds:(%rsi),%al
    1a23:	00 00                	add    %al,(%rax)
        if (pckt.flags & F_SYN_SET) {
    1a25:	00 34 4d 01 0a 07 ac 	add    %dh,-0x53f8f5ff(,%rcx,2)
    1a2c:	00 00                	add    %al,(%rax)
    1a2e:	00 34 4e             	add    %dh,(%rsi,%rcx,2)
    1a31:	01 0a                	add    %ecx,(%rdx)
    1a33:	07                   	(bad)
  struct real_pos_lru new_dst_lru = {};
    1a34:	b4 00                	mov    $0x0,%ah
    1a36:	00 00                	add    %al,(%rax)
    1a38:	00 2c 4f             	add    %ch,(%rdi,%rcx,2)
    1a3b:	01 0a                	add    %ecx,(%rdx)
    1a3d:	66 d0 09             	data16 rorb (%rcx)
    1a40:	00 00                	add    %al,(%rax)
    1a42:	34 49                	xor    $0x49,%al
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1a44:	01 0a                	add    %ecx,(%rdx)
    1a46:	66 d0 09             	data16 rorb (%rcx)
    1a49:	00 00                	add    %al,(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1a4b:	34 4a                	xor    $0x4a,%al
    1a4d:	01 0a                	add    %ecx,(%rdx)
    1a4f:	66 d0 09             	data16 rorb (%rcx)
    1a52:	00 00                	add    %al,(%rax)
    1a54:	34 48                	xor    $0x48,%al
    1a56:	01 0a                	add    %ecx,(%rdx)
    1a58:	66 d0 09             	data16 rorb (%rcx)
    1a5b:	00 00                	add    %al,(%rax)
    1a5d:	34 47                	xor    $0x47,%al
    1a5f:	01 0a                	add    %ecx,(%rdx)
    1a61:	66 d0 09             	data16 rorb (%rcx)
    1a64:	00 00                	add    %al,(%rax)
  if (!conn_rate_stats) {
    1a66:	00 2c 50             	add    %ch,(%rax,%rdx,2)
    1a69:	01 0a                	add    %ecx,(%rdx)
    1a6b:	6e                   	outsb  %ds:(%rsi),(%dx)
    1a6c:	d0 09                	rorb   (%rcx)
    1a6e:	00 00                	add    %al,(%rax)
    1a70:	34 49                	xor    $0x49,%al
    1a72:	01 0a                	add    %ecx,(%rdx)
    1a74:	6e                   	outsb  %ds:(%rsi),(%dx)
    1a75:	d0 09                	rorb   (%rcx)
    1a77:	00 00                	add    %al,(%rax)
  *cur_time = bpf_ktime_get_ns();
    1a79:	34 4a                	xor    $0x4a,%al
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1a7b:	01 0a                	add    %ecx,(%rdx)
    1a7d:	6e                   	outsb  %ds:(%rsi),(%dx)
    1a7e:	d0 09                	rorb   (%rcx)
    1a80:	00 00                	add    %al,(%rax)
    1a82:	34 47                	xor    $0x47,%al
    1a84:	01 0a                	add    %ecx,(%rdx)
    1a86:	6e                   	outsb  %ds:(%rsi),(%dx)
    1a87:	d0 09                	rorb   (%rcx)
    1a89:	00 00                	add    %al,(%rax)
    1a8b:	00 31                	add    %dh,(%rcx)
    1a8d:	51                   	push   %rcx
    conn_rate_stats->v1 = 1;
    1a8e:	01 00                	add    %eax,(%rax)
    1a90:	43 02 a8 00 00 00 20 	rex.XB add 0x20000000(%r8),%bpl
    conn_rate_stats->v2 = *cur_time;
    1a97:	17                   	(bad)
    1a98:	00 44 02 d7          	add    %al,-0x29(%rdx,%rax,1)
    1a9c:	16                   	(bad)
    1a9d:	00 00                	add    %al,(%rax)
    1a9f:	20 94 00 45 02 e9 0d 	and    %dl,0xde90245(%rax,%rax,1)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1aa6:	00 00                	add    %al,(%rax)
    1aa8:	20 9d 00 46 02 3d    	and    %bl,0x3d024600(%rbp)
    1aae:	0d 00 00 20 92       	or     $0x92200000,%eax
    1ab3:	00 47 02             	add    %al,0x2(%rdi)
    1ab6:	0a 0d 00 00 32 52    	or     0x52320000(%rip),%cl        # 52321abc <_license+0x5231fbc9>
  data_end = (void*)(long)xdp->data_end;
    1abc:	01 00                	add    %eax,(%rax)
    1abe:	49 02 ac 00 00 00 32 	rex.WB add 0x53320000(%r8,%rax,1),%bpl
    1ac5:	53 
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1ac6:	01 00                	add    %eax,(%rax)
    1ac8:	4a 02 d7             	rex.WX add %dil,%dl
    1acb:	16                   	(bad)
    1acc:	00 00                	add    %al,(%rax)
    1ace:	32 54 01 00          	xor    0x0(%rcx,%rax,1),%dl
    1ad2:	4f 02 0a             	rex.WRXB add (%r10),%r9b
    1ad5:	0d 00 00 32 55       	or     $0x55320000,%eax
    1ada:	01 00                	add    %eax,(%rax)
    1adc:	55                   	push   %rbp
    1add:	02 0a                	add    (%rdx),%cl
    1adf:	0d 00 00 32 56       	or     $0x56320000,%eax
  memcpy(new_eth->h_dest, cval->mac, 6);
    1ae4:	01 00                	add    %eax,(%rax)
    1ae6:	56                   	push   %rsi
    1ae7:	02 0a                	add    (%rdx),%cl
    1ae9:	0d 00 00 32 57       	or     $0x57320000,%eax
    1aee:	01 00                	add    %eax,(%rax)
    1af0:	57                   	push   %rdi
    1af1:	02 0a                	add    (%rdx),%cl
    1af3:	0d 00 00 22 21       	or     $0x21220000,%eax
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1af8:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    1af9:	00 59 02             	add    %bl,0x2(%rcx)
    1afc:	ac                   	lods   %ds:(%rsi),%al
    1afd:	00 00                	add    %al,(%rax)
    1aff:	00 32                	add    %dh,(%rdx)
    1b01:	58                   	pop    %rax
    1b02:	01 00                	add    %eax,(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    1b04:	5a                   	pop    %rdx
    1b05:	02 64 09 00          	add    0x0(%rcx,%rcx,1),%ah
    1b09:	00 22                	add    %ah,(%rdx)
    1b0b:	21 a6 00 5a 02 78    	and    %esp,0x78025a00(%rsi)
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1b11:	08 00                	or     %al,(%rax)
    1b13:	00 22                	add    %ah,(%rdx)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1b15:	21 07                	and    %eax,(%rdi)
    1b17:	00 5a 02             	add    %bl,0x2(%rdx)
  ip6h->priority = (tc & 0xF0) >> 4;
    1b1a:	4c 0d 00 00 00 00    	rex.WR or $0x0,%rax
    1b20:	00 22                	add    %ah,(%rdx)
    1b22:	21 a6 00 4b 02 78    	and    %esp,0x78024b00(%rsi)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1b28:	08 00                	or     %al,(%rax)
    1b2a:	00 22                	add    %ah,(%rdx)
  ip6h->nexthdr = proto;
    1b2c:	21 07                	and    %eax,(%rdi)
    1b2e:	00 4b 02             	add    %cl,0x2(%rbx)
    1b31:	4c 0d 00 00 22 21    	rex.WR or $0x21220000,%rax
  ip6h->payload_len = bpf_htons(payload_len);
    1b37:	b2 00                	mov    $0x0,%dl
    1b39:	4b 02 ac 00 00 00 21 	rex.WXB add 0x14210000(%r8,%r8,1),%bpl
    1b40:	14 
    1b41:	00 4b 02             	add    %cl,0x2(%rbx)
    1b44:	77 0d                	ja     1b53 <balancer_ingress+0x1b53>
    1b46:	00 00                	add    %al,(%rax)
    1b48:	21 b3 00 4b 02 77    	and    %esi,0x77024b00(%rbx)
    1b4e:	0d 00 00 00 00       	or     $0x0,%eax
    1b53:	00 00                	add    %al,(%rax)
    1b55:	35 59 01 00 35       	xor    $0x35000159,%eax
    1b5a:	02 20                	add    (%rax),%ah
    1b5c:	ab                   	stos   %eax,%es:(%rdi)
    1b5d:	00 36                	add    %dh,(%rsi)
    1b5f:	02 51 0d             	add    0xd(%rcx),%dl
    1b62:	00 00                	add    %al,(%rax)
    1b64:	20 ae 00 37 02 fe    	and    %ch,-0x1fdc900(%rsi)
    conn_rate_stats->v1 += 1;
    1b6a:	00 00                	add    %al,(%rax)
    1b6c:	00 00                	add    %al,(%rax)
    1b6e:	31 5a 01             	xor    %ebx,0x1(%rdx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1b71:	00 67 02             	add    %ah,0x2(%rdi)
    1b74:	a8 00                	test   $0x0,%al
    1b76:	00 00                	add    %al,(%rax)
    1b78:	20 94 00 68 02 e9 0d 	and    %dl,0xde90268(%rax,%rax,1)
    1b7f:	00 00                	add    %al,(%rax)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1b81:	20 a1 00 69 02 78    	and    %ah,0x78026900(%rcx)
    1b87:	08 00                	or     %al,(%rax)
    1b89:	00 32                	add    %dh,(%rdx)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1b8b:	3b 01                	cmp    (%rcx),%eax
    1b8d:	00 77 02             	add    %dh,0x2(%rdi)
    1b90:	ac                   	lods   %ds:(%rsi),%al
    1b91:	02 00                	add    (%rax),%al
      memset(pckt->flow.srcv6, 0, 16);
    1b93:	00 32                	add    %dh,(%rdx)
    1b95:	24 01                	and    $0x1,%al
    1b97:	00 6a 02             	add    %ch,0x2(%rdx)
    1b9a:	fc                   	cld
    1b9b:	15 00 00 32 25       	adc    $0x25320000,%eax
    1ba0:	01 00                	add    %eax,(%rax)
    1ba2:	73 02                	jae    1ba6 <balancer_ingress+0x1ba6>
    1ba4:	e6 00                	out    %al,$0x0
    1ba6:	00 00                	add    %al,(%rax)
    1ba8:	00 38                	add    %bh,(%rax)
  b += initval;
    1baa:	12 f3                	adc    %bl,%dh
    1bac:	1e                   	(bad)
  a += initval;
    1bad:	00 00                	add    %al,(%rax)
    1baf:	01 56 5f             	add    %edx,0x5f(%rsi)
    1bb2:	01 00                	add    %eax,(%rax)
  __jhash_final(a, b, c);
    1bb4:	31 04 a8             	xor    %eax,(%rax,%rbp,4)
    1bb7:	00 00                	add    %al,(%rax)
    1bb9:	00 39                	add    %bh,(%rcx)
  return (word << shift) | (word >> ((-shift) & 31));
    1bbb:	00 60 01             	add    %ah,0x1(%rax)
    1bbe:	00 31                	add    %dh,(%rcx)
  __jhash_final(a, b, c);
    1bc0:	04 a0                	add    $0xa0,%al
    1bc2:	0c 00                	or     $0x0,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1bc4:	00 3a                	add    %bh,(%rdx)
    1bc6:	01 87 00 32 04 78    	add    %eax,0x78043200(%rdi)
  __jhash_final(a, b, c);
    1bcc:	08 00                	or     %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1bce:	00 3a                	add    %bh,(%rdx)
    1bd0:	02 88 00 33 04 78    	add    0x78043300(%rax),%cl
    1bd6:	08 00                	or     %al,(%rax)
    1bd8:	00 3b                	add    %bh,(%rbx)
    1bda:	03 61 01             	add    0x1(%rcx),%esp
  __jhash_final(a, b, c);
    1bdd:	00 34 04             	add    %dh,(%rsp,%rax,1)
  return (word << shift) | (word >> ((-shift) & 31));
    1be0:	82                   	(bad)
    1be1:	17                   	(bad)
    1be2:	00 00                	add    %al,(%rax)
  __jhash_final(a, b, c);
    1be4:	3a 04 91             	cmp    (%rcx,%rdx,4),%al
    1be7:	00 36                	add    %dh,(%rsi)
  return (word << shift) | (word >> ((-shift) & 31));
    1be9:	04 ac                	add    $0xac,%al
  __jhash_final(a, b, c);
    1beb:	00 00                	add    %al,(%rax)
    1bed:	00 3b                	add    %bh,(%rbx)
  return (word << shift) | (word >> ((-shift) & 31));
    1bef:	05 62 01 00 35       	add    $0x35000162,%eax
    1bf4:	04 ac                	add    $0xac,%al
    1bf6:	00 00                	add    %al,(%rax)
    1bf8:	00 3c d8             	add    %bh,(%rax,%rbx,8)
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1bfb:	09 00                	or     %eax,(%rax)
    1bfd:	00 00                	add    %al,(%rax)
    1bff:	00 41 04             	add    %al,0x4(%rcx)
    1c02:	0c 3d                	or     $0x3d,%al
    1c04:	06                   	(bad)
    1c05:	e1 09                	loope  1c10 <balancer_ingress+0x1c10>
    1c07:	00 00                	add    %al,(%rax)
    1c09:	3d 07 ea 09 00       	cmp    $0x9ea07,%eax
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1c0e:	00 3d 08 f3 09 00    	add    %bh,0x9f308(%rip)        # a0f1c <_license+0x9f029>
    1c14:	00 3e                	add    %bh,(%rsi)
    1c16:	03 91 80 7f fc 09    	add    0x9fc7f80(%rcx),%edx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1c1c:	00 00                	add    %al,(%rax)
    1c1e:	3e 03 91 d8 7e 05 0a 	ds add 0xa057ed8(%rcx),%edx
    1c25:	00 00                	add    %al,(%rax)
    1c27:	3f                   	(bad)
    1c28:	09 0e                	or     %ecx,(%rsi)
    1c2a:	0a 00                	or     (%rax),%al
    1c2c:	00 3f                	add    %bh,(%rdi)
    key = *real_pos;
    1c2e:	0a 17                	or     (%rdi),%dl
    1c30:	0a 00                	or     (%rax),%al
    1c32:	00 3f                	add    %bh,(%rdi)
    1c34:	0b 20                	or     (%rax),%esp
    1c36:	0a 00                	or     (%rax),%al
    if (key == 0) {
    1c38:	00 3f                	add    %bh,(%rdi)
  pckt->real_index = key;
    1c3a:	0c 29                	or     $0x29,%al
    1c3c:	0a 00                	or     (%rax),%al
  *real = bpf_map_lookup_elem(&reals, &key);
    1c3e:	00 3f                	add    %bh,(%rdi)
    1c40:	0d 32 0a 00 00       	or     $0xa32,%eax
    1c45:	3f                   	(bad)
    1c46:	45 3b 0a             	cmp    (%r10),%r9d
    1c49:	00 00                	add    %al,(%rax)
    1c4b:	3f                   	(bad)
    1c4c:	46                   	rex.RX
    1c4d:	44 0a 00             	or     (%rax),%r8b
    1c50:	00 3f                	add    %bh,(%rdi)
    1c52:	77 4d                	ja     1ca1 <balancer_ingress+0x1ca1>
    1c54:	0a 00                	or     (%rax),%al
    1c56:	00 3f                	add    %bh,(%rdi)
    1c58:	78 56                	js     1cb0 <balancer_ingress+0x1cb0>
    1c5a:	0a 00                	or     (%rax),%al
    1c5c:	00 3f                	add    %bh,(%rdi)
    1c5e:	7a 5f                	jp     1cbf <balancer_ingress+0x1cbf>
    1c60:	0a 00                	or     (%rax),%al
    1c62:	00 3f                	add    %bh,(%rdi)
    1c64:	7b 68                	jnp    1cce <balancer_ingress+0x1cce>
    1c66:	0a 00                	or     (%rax),%al
    1c68:	00 3f                	add    %bh,(%rdi)
    1c6a:	7c 71                	jl     1cdd <balancer_ingress+0x1cdd>
    1c6c:	0a 00                	or     (%rax),%al
    1c6e:	00 3f                	add    %bh,(%rdi)
    1c70:	7e 7a                	jle    1cec <balancer_ingress+0x1cec>
    1c72:	0a 00                	or     (%rax),%al
    1c74:	00 3f                	add    %bh,(%rdi)
    1c76:	96                   	xchg   %eax,%esi
    1c77:	02 83 0a 00 00 3f    	add    0x3f00000a(%rbx),%al
    1c7d:	d1 02                	roll   (%rdx)
    1c7f:	8c 0a                	mov    %cs,(%rdx)
    1c81:	00 00                	add    %al,(%rax)
    1c83:	3c 7c                	cmp    $0x7c,%al
    1c85:	0d 00 00 01 00       	or     $0x10000,%eax
    1c8a:	ba 02 0c 3d 0e       	mov    $0xe3d0c02,%edx
    1c8f:	85 0d 00 00 3d 0f    	test   %ecx,0xf3d0000(%rip)        # f3d1c95 <_license+0xf3cfda2>
    1c95:	97                   	xchg   %eax,%edi
    1c96:	0d 00 00 3d 10       	or     $0x103d0000,%eax
}
    1c9b:	b2 0d                	mov    $0xd,%dl
    1c9d:	00 00                	add    %al,(%rax)
    1c9f:	3d 11 bb 0d 00       	cmp    $0xdbb11,%eax
    1ca4:	00 3d 12 c4 0d 00    	add    %bh,0xdc412(%rip)        # de0bc <_license+0xdc1c9>
    1caa:	00 3f                	add    %bh,(%rdi)
    1cac:	13 cd                	adc    %ebp,%ecx
    1cae:	0d 00 00 00 3c       	or     $0x3c000000,%eax
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1cb3:	a1 10 00 00 02 00 bf 	movabs 0xc02bf0002000010,%eax
    1cba:	02 0c 
    1cbc:	3d 47 aa 10 00       	cmp    $0x10aa47,%eax
    1cc1:	00 3d 48 b3 10 00    	add    %bh,0x10b348(%rip)        # 10d00f <_license+0x10b11c>
    1cc7:	00 3d 49 bc 10 00    	add    %bh,0x10bc49(%rip)        # 10d916 <_license+0x10ba23>
    1ccd:	00 3d 4a c5 10 00    	add    %bh,0x10c54a(%rip)        # 10e21d <_license+0x10c32a>
    if (pckt->flow.proto == IPPROTO_UDP) {
    1cd3:	00 3d 4b ce 10 00    	add    %bh,0x10ce4b(%rip)        # 10eb24 <_license+0x10cc31>
    new_dst_lru.pos = key;
    1cd9:	00 3c 9c             	add    %bh,(%rsp,%rbx,4)
    1cdc:	0f 00 00             	sldt   (%rax)
    1cdf:	03 0b                	add    (%rbx),%ecx
    1ce1:	5c                   	pop    %rsp
    1ce2:	01 0c 3d 14 a5 0f 00 	add    %ecx,0xfa514(,%rdi,1)
    1ce9:	00 3d 15 ae 0f 00    	add    %bh,0xfae15(%rip)        # fcb04 <_license+0xfac11>
    1cef:	00 3d 16 b7 0f 00    	add    %bh,0xfb716(%rip)        # fd40b <_license+0xfb518>
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    1cf5:	00 3d 17 c0 0f 00    	add    %bh,0xfc017(%rip)        # fdd12 <_license+0xfbe1f>
    1cfb:	00 3f                	add    %bh,(%rdi)
    1cfd:	18 c9                	sbb    %cl,%cl
    1cff:	0f 00 00             	sldt   (%rax)
    1d02:	3f                   	(bad)
    1d03:	75 d2                	jne    1cd7 <balancer_ingress+0x1cd7>
    1d05:	0f 00 00             	sldt   (%rax)
    1d08:	40 d8 10             	rex fcoms (%rax)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1d0b:	00 00                	add    %al,(%rax)
    1d0d:	13 72 00             	adc    0x0(%rdx),%esi
    1d10:	00 00                	add    %al,(%rax)
    1d12:	0b 1f                	or     (%rdi),%ebx
    1d14:	01 0c 41             	add    %ecx,(%rcx,%rax,2)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1d17:	01 5e e0             	add    %ebx,-0x20(%rsi)
    1d1a:	10 00                	adc    %al,(%rax)
    1d1c:	00 41 01             	add    %al,0x1(%rcx)
    1d1f:	5c                   	pop    %rsp
    1d20:	e8 10 00 00 3f       	call   3f001d35 <_license+0x3efffe42>
    1d25:	19 f0                	sbb    %esi,%eax
    1d27:	10 00                	adc    %al,(%rax)
  bool vip_match = address_match && port_match && proto_match;
    1d29:	00 42 00             	add    %al,0x0(%rdx)
    1d2c:	f8                   	clc
    1d2d:	10 00                	adc    %al,(%rax)
    1d2f:	00 42 22             	add    %al,0x22(%rdx)
    1d32:	00 11                	add    %dl,(%rcx)
    __u32 lru_stats_key = pckt->real_index;
    1d34:	00 00                	add    %al,(%rax)
    1d36:	3e 01 5f 08          	ds add %ebx,0x8(%rdi)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1d3a:	11 00                	adc    %eax,(%rax)
    1d3c:	00 43 19             	add    %al,0x19(%rbx)
    1d3f:	11 00                	adc    %eax,(%rax)
    1d41:	00 14 52             	add    %dl,(%rdx,%rdx,2)
    1d44:	00 00                	add    %al,(%rax)
    1d46:	00 0b                	add    %cl,(%rbx)
    1d48:	59                   	pop    %rcx
    1d49:	03 3f                	add    (%rdi),%edi
    1d4b:	1b 2d 11 00 00 44    	sbb    0x44000011(%rip),%ebp        # 44001d62 <_license+0x43fffe6f>
    if (!lru_miss_stat) {
    1d51:	14 35                	adc    $0x35,%al
    1d53:	00 00                	add    %al,(%rax)
    1d55:	00 3f                	add    %bh,(%rdi)
    1d57:	1a 36                	sbb    (%rsi),%dh
    *lru_miss_stat += 1;
    1d59:	11 00                	adc    %eax,(%rax)
    1d5b:	00 00                	add    %al,(%rax)
    1d5d:	43                   	rex.XB
    1d5e:	40 11 00             	rex adc %eax,(%rax)
    1d61:	00 15 1d 00 00 00    	add    %dl,0x1d(%rip)        # 1d84 <balancer_ingress+0x1d84>
    1d67:	0c 3a                	or     $0x3a,%al
    1d69:	0b 3d 1c 48 11 00    	or     0x11481c(%rip),%edi        # 11658b <_license+0x114698>
    1d6f:	00 3f                	add    %bh,(%rdi)
    1d71:	1d 50 11 00 00       	sbb    $0x1150,%eax
    1d76:	00 00                	add    %al,(%rax)
    1d78:	00 44 16 37          	add    %al,0x37(%rsi,%rdx,1)
    1d7c:	00 00                	add    %al,(%rax)
      data_stats->v2 += 1;
    1d7e:	00 3f                	add    %bh,(%rdi)
    1d80:	72 dc                	jb     1d5e <balancer_ingress+0x1d5e>
    1d82:	0f 00 00             	sldt   (%rax)
    1d85:	3f                   	(bad)
    1d86:	74 e5                	je     1d6d <balancer_ingress+0x1d6d>
    1d88:	0f 00 00             	sldt   (%rax)
    1d8b:	44 17                	rex.R (bad)
    1d8d:	17                   	(bad)
    1d8e:	00 00                	add    %al,(%rax)
    1d90:	00 3f                	add    %bh,(%rdi)
      dst_lru->pos = pckt->real_index;
    1d92:	73 f8                	jae    1d8c <balancer_ingress+0x1d8c>
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1d94:	0f 00 00             	sldt   (%rax)
    1d97:	44 17                	rex.R (bad)
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    1d99:	17                   	(bad)
    1d9a:	00 00                	add    %al,(%rax)
    1d9c:	00 45 06             	add    %al,0x6(%rbp)
    1d9f:	02 10                	add    (%rax),%dl
    1da1:	00 00                	add    %al,(%rax)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1da3:	00 00                	add    %al,(%rax)
    1da5:	00 00                	add    %al,(%rax)
    1da7:	3c 59                	cmp    $0x59,%al
    1da9:	11 00                	adc    %eax,(%rax)
    1dab:	00 04 0b             	add    %al,(%rbx,%rcx,1)
    1dae:	5a                   	pop    %rdx
    1daf:	01 0c 3d 4c 61 11 00 	add    %ecx,0x11614c(,%rdi,1)
    1db6:	00 3d 4d 69 11 00    	add    %bh,0x11694d(%rip)        # 118709 <_license+0x116816>
  if (!per_vip_stats) {
    1dbc:	00 3d 4e 71 11 00    	add    %bh,0x11714e(%rip)        # 118f10 <_license+0x11701d>
    per_vip_stats->v2 += 1;
    1dc2:	00 3d 4f 79 11 00    	add    %bh,0x11794f(%rip)        # 119717 <_license+0x117824>
    conn_rate_stats->v1 += 1;
    1dc8:	00 3f                	add    %bh,(%rdi)
    1dca:	50                   	push   %rax
    1dcb:	81 11 00 00 3f 91    	adcl   $0x913f0000,(%rcx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1dd1:	01 89 11 00 00 43    	add    %ecx,0x43000011(%rcx)
  struct real_pos_lru new_dst_lru = {};
    1dd7:	13 14 00             	adc    (%rax,%rax,1),%edx
    1dda:	00 18                	add    %bl,(%rax)
    1ddc:	17                   	(bad)
    1ddd:	00 00                	add    %al,(%rax)
    1ddf:	00 0b                	add    %cl,(%rbx)
    1de1:	f0 0c 41             	lock or $0x41,%al
    1de4:	01 5e 1c             	add    %ebx,0x1c(%rsi)
  new_dst_lru.pos = pckt->real_index;
    1de7:	14 00                	adc    $0x0,%al
    1de9:	00 41 01             	add    %al,0x1(%rcx)
    1dec:	5c                   	pop    %rsp
    1ded:	24 14                	and    $0x14,%al
    1def:	00 00                	add    %al,(%rax)
    1df1:	3e 02 91 40 2c 14 00 	ds add 0x142c40(%rcx),%dl
    1df8:	00 42 00             	add    %al,0x0(%rdx)
    1dfb:	34 14                	xor    $0x14,%al
    1dfd:	00 00                	add    %al,(%rax)
    1dff:	00 44 19 3e          	add    %al,0x3e(%rcx,%rbx,1)
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1e03:	00 00                	add    %al,(%rax)
    1e05:	00 3f                	add    %bh,(%rdi)
              quic_packets_stats->dst_not_found_in_lru += 1;
    1e07:	8d 01                	lea    (%rcx),%eax
    1e09:	92                   	xchg   %eax,%edx
    1e0a:	11 00                	adc    %eax,(%rax)
            quic_packets_stats->cid_routed += 1;
    1e0c:	00 3f                	add    %bh,(%rdi)
    1e0e:	8f 01                	pop    (%rcx)
    1e10:	9a                   	(bad)
  original_sport = pckt.flow.port16[0];
    1e11:	11 00                	adc    %eax,(%rax)
    1e13:	00 3f                	add    %bh,(%rdi)
    1e15:	90                   	nop
    1e16:	01 a2 11 00 00 44    	add    %esp,0x44000011(%rdx)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1e1c:	1a 17                	sbb    (%rdi),%dl
    1e1e:	00 00                	add    %al,(%rax)
    1e20:	00 3f                	add    %bh,(%rdi)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1e22:	8e 01                	mov    (%rcx),%es
    1e24:	ab                   	stos   %eax,%es:(%rdi)
    1e25:	11 00                	adc    %eax,(%rax)
    1e27:	00 44 1a 17          	add    %al,0x17(%rdx,%rbx,1)
    1e2b:	00 00                	add    %al,(%rax)
    1e2d:	00 45 06             	add    %al,0x6(%rbp)
    1e30:	b4 11                	mov    $0x11,%ah
    1e32:	00 00                	add    %al,(%rax)
  if (!conn_rate_stats) {
    1e34:	00 00                	add    %al,(%rax)
    1e36:	00 00                	add    %al,(%rax)
    1e38:	00 40 f0             	add    %al,-0x10(%rax)
    1e3b:	12 00                	adc    (%rax),%al
    1e3d:	00 1b                	add    %bl,(%rbx)
    1e3f:	2e 00 00             	cs add %al,(%rax)
    1e42:	00 00                	add    %al,(%rax)
    1e44:	f3 02 0a             	repz add (%rdx),%cl
  *cur_time = bpf_ktime_get_ns();
    1e47:	41 01 5e f9          	add    %ebx,-0x7(%r14)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1e4b:	12 00                	adc    (%rax),%al
    1e4d:	00 41 01             	add    %al,0x1(%rcx)
    1e50:	5c                   	pop    %rsp
    1e51:	01 13                	add    %edx,(%rbx)
    1e53:	00 00                	add    %al,(%rax)
    1e55:	41 02 30             	add    (%r8),%sil
    conn_rate_stats->v1 = 1;
    1e58:	9f                   	lahf
    1e59:	09 13                	or     %edx,(%rbx)
    1e5b:	00 00                	add    %al,(%rax)
    1e5d:	41 04 91             	rex.B add $0x91,%al
    conn_rate_stats->v2 = *cur_time;
    1e60:	80 7f 9f 11          	cmpb   $0x11,-0x61(%rdi)
    1e64:	13 00                	adc    (%rax),%eax
      dst_lru->pos = pckt->real_index;
    1e66:	00 3f                	add    %bh,(%rdi)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1e68:	52                   	push   %rdx
    1e69:	19 13                	sbb    %edx,(%rbx)
    1e6b:	00 00                	add    %al,(%rax)
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    1e6d:	00 40 4d             	add    %al,0x4d(%rax)
    1e70:	14 00                	adc    $0x0,%al
    1e72:	00 1c 17             	add    %bl,(%rdi,%rdx,1)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1e75:	00 00                	add    %al,(%rax)
    1e77:	00 00                	add    %al,(%rax)
    1e79:	f7 02 0a 41 01 5e    	testl  $0x5e01410a,(%rdx)
    1e7f:	56                   	push   %rsi
    1e80:	14 00                	adc    $0x0,%al
    1e82:	00 41 01             	add    %al,0x1(%rcx)
    1e85:	5c                   	pop    %rsp
    1e86:	5e                   	pop    %rsi
    1e87:	14 00                	adc    $0x0,%al
    1e89:	00 41 02             	add    %al,0x2(%rcx)
  if (!per_vip_stats) {
    1e8c:	30 9f 66 14 00 00    	xor    %bl,0x1466(%rdi)
    per_vip_stats->v2 += 1;
    1e92:	41 04 91             	rex.B add $0x91,%al
    1e95:	80 7f 9f 6e          	cmpb   $0x6e,-0x61(%rdi)
    conn_rate_stats->v1 += 1;
    1e99:	14 00                	adc    $0x0,%al
    1e9b:	00 3f                	add    %bh,(%rdi)
    1e9d:	71 76                	jno    1f15 <_license+0x22>
    1e9f:	14 00                	adc    $0x0,%al
    1ea1:	00 00                	add    %al,(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1ea3:	44 1d 1a 00 00 00    	rex.R sbb $0x1a,%eax
    1ea9:	3f                   	(bad)
  struct real_pos_lru new_dst_lru = {};
    1eaa:	76 a8                	jbe    1e54 <balancer_ingress+0x1e54>
    1eac:	0a 00                	or     (%rax),%al
    1eae:	00 44 1d 1a          	add    %al,0x1a(%rbp,%rbx,1)
    1eb2:	00 00                	add    %al,(%rax)
    1eb4:	00 45 01             	add    %al,0x1(%rbp)
    1eb7:	b2 0a                	mov    $0xa,%dl
    1eb9:	00 00                	add    %al,(%rax)
  new_dst_lru.pos = pckt->real_index;
    1ebb:	00 00                	add    %al,(%rax)
    1ebd:	44 1e                	rex.R (bad)
    1ebf:	1a 00                	sbb    (%rax),%al
    1ec1:	00 00                	add    %al,(%rax)
    1ec3:	3f                   	(bad)
    1ec4:	8c 01                	mov    %es,(%rcx)
    1ec6:	be 0a 00 00 44       	mov    $0x4400000a,%esi
    1ecb:	1e                   	(bad)
    1ecc:	1a 00                	sbb    (%rax),%al
    1ece:	00 00                	add    %al,(%rax)
    1ed0:	45 01 c8             	add    %r9d,%r8d
    1ed3:	0a 00                	or     (%rax),%al
    1ed5:	00 00                	add    %al,(%rax)
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1ed7:	00 44 1f 1a          	add    %al,0x1a(%rdi,%rbx,1)
              quic_packets_stats->dst_not_found_in_lru += 1;
    1edb:	00 00                	add    %al,(%rax)
    1edd:	00 3f                	add    %bh,(%rdi)
            quic_packets_stats->cid_routed += 1;
    1edf:	79 d4                	jns    1eb5 <balancer_ingress+0x1eb5>
    1ee1:	0a 00                	or     (%rax),%al
    1ee3:	00 44 1f 1a          	add    %al,0x1a(%rdi,%rbx,1)
  original_sport = pckt.flow.port16[0];
    1ee7:	00 00                	add    %al,(%rax)
    1ee9:	00 45 06             	add    %al,0x6(%rbp)
    1eec:	de 0a                	fimuls (%rdx)
    1eee:	00 00                	add    %al,(%rax)
    1ef0:	00 00                	add    %al,(%rax)
    1ef2:	44 20 21             	and    %r12b,(%rcx)
    1ef5:	00 00                	add    %al,(%rax)
    1ef7:	00 3f                	add    %bh,(%rdi)
    1ef9:	7d ea                	jge    1ee5 <balancer_ingress+0x1ee5>
    1efb:	0a 00                	or     (%rax),%al
    1efd:	00 44 20 21          	add    %al,0x21(%rax,%riz,1)
    1f01:	00 00                	add    %al,(%rax)
    1f03:	00 45 0c             	add    %al,0xc(%rbp)
    1f06:	f4                   	hlt
    1f07:	0a 00                	or     (%rax),%al
    1f09:	00 00                	add    %al,(%rax)
    1f0b:	00 44 21 40          	add    %al,0x40(%rcx,%riz,1)
    1f0f:	00 00                	add    %al,(%rax)
    1f11:	00 3f                	add    %bh,(%rdi)
    1f13:	7f 00                	jg     1f15 <_license+0x22>
    1f15:	0b 00                	or     (%rax),%eax
    1f17:	00 3f                	add    %bh,(%rdi)
    1f19:	81 01 09 0b 00 00    	addl   $0xb09,(%rcx)
    1f1f:	44 22 17             	and    (%rdi),%r10b
    1f22:	00 00                	add    %al,(%rax)
    1f24:	00 3f                	add    %bh,(%rdi)
    1f26:	80 01 13             	addb   $0x13,(%rcx)
    1f29:	0b 00                	or     (%rax),%eax
    1f2b:	00 44 22 17          	add    %al,0x17(%rdx,%riz,1)
    1f2f:	00 00                	add    %al,(%rax)
    1f31:	00 45 06             	add    %al,0x6(%rbp)
    1f34:	1d 0b 00 00 00       	sbb    $0xb,%eax
    1f39:	00 00                	add    %al,(%rax)
    1f3b:	46 05 3f 82 01 34    	rex.RX add $0x3401823f,%eax
    1f41:	0b 00                	or     (%rax),%eax
    1f43:	00 3f                	add    %bh,(%rdi)
    1f45:	84 01                	test   %al,(%rcx)
    1f47:	3d 0b 00 00 3f       	cmp    $0x3f00000b,%eax
    1f4c:	f5                   	cmc
    1f4d:	01 46 0b             	add    %eax,0xb(%rsi)
    1f50:	00 00                	add    %al,(%rax)
    1f52:	44 23 17             	and    (%rdi),%r10d
    1f55:	00 00                	add    %al,(%rax)
    1f57:	00 3f                	add    %bh,(%rdi)
    1f59:	83 01 50             	addl   $0x50,(%rcx)
    1f5c:	0b 00                	or     (%rax),%eax
    1f5e:	00 44 23 17          	add    %al,0x17(%rbx,%riz,1)
    1f62:	00 00                	add    %al,(%rax)
    1f64:	00 45 06             	add    %al,0x6(%rbp)
    1f67:	5a                   	pop    %rdx
    1f68:	0b 00                	or     (%rax),%eax
    1f6a:	00 00                	add    %al,(%rax)
    1f6c:	00 3c c3             	add    %bh,(%rbx,%rax,8)
    1f6f:	14 00                	adc    $0x0,%al
    1f71:	00 06                	add    %al,(%rsi)
    1f73:	00 6f 03             	add    %ch,0x3(%rdi)
    1f76:	26 3d 85 01 cd 14    	es cmp $0x14cd0185,%eax
    1f7c:	00 00                	add    %al,(%rax)
    1f7e:	3d 86 01 d6 14       	cmp    $0x14d60186,%eax
    1f83:	00 00                	add    %al,(%rax)
    1f85:	3d 87 01 df 14       	cmp    $0x14df0187,%eax
    1f8a:	00 00                	add    %al,(%rax)
    1f8c:	3f                   	(bad)
    1f8d:	88 01                	mov    %al,(%rcx)
    1f8f:	f1                   	int1
    1f90:	14 00                	adc    $0x0,%al
    1f92:	00 3f                	add    %bh,(%rdi)
    1f94:	89 01                	mov    %eax,(%rcx)
    1f96:	fb                   	sti
    1f97:	14 00                	adc    $0x0,%al
    1f99:	00 3f                	add    %bh,(%rdi)
    1f9b:	8a 01                	mov    (%rcx),%al
    1f9d:	05 15 00 00 3f       	add    $0x3f000015,%eax
    1fa2:	8b 01                	mov    (%rcx),%eax
    1fa4:	0f 15 00             	unpckhps (%rax),%xmm0
    1fa7:	00 3f                	add    %bh,(%rdi)
    1fa9:	ec                   	in     (%dx),%al
    1faa:	01 19                	add    %ebx,(%rcx)
    1fac:	15 00 00 46 07       	adc    $0x7460000,%eax
    1fb1:	3f                   	(bad)
    1fb2:	eb 01                	jmp    1fb5 <_license+0xc2>
    1fb4:	36 15 00 00 00 00    	ss adc $0x0,%eax
    1fba:	40 01 16             	rex add %edx,(%rsi)
    1fbd:	00 00                	add    %al,(%rax)
    1fbf:	24 29                	and    $0x29,%al
    1fc1:	00 00                	add    %al,(%rax)
    1fc3:	00 00                	add    %al,(%rax)
    1fc5:	a1 03 09 41 02 91 40 	movabs 0x1607409102410903,%eax
    1fcc:	07 16 
    1fce:	00 00                	add    %al,(%rax)
    1fd0:	41 02 31             	add    (%r9),%sil
    1fd3:	9f                   	lahf
    1fd4:	10 16                	adc    %dl,(%rsi)
    1fd6:	00 00                	add    %al,(%rax)
    1fd8:	41 02 30             	add    (%r8),%sil
    1fdb:	9f                   	lahf
    1fdc:	1a 16                	sbb    (%rsi),%dl
    1fde:	00 00                	add    %al,(%rax)
    1fe0:	3f                   	(bad)
    1fe1:	e6 01                	out    %al,$0x1
    1fe3:	24 16                	and    $0x16,%al
    1fe5:	00 00                	add    %al,(%rax)
    1fe7:	44 24 17             	rex.R and $0x17,%al
    1fea:	00 00                	add    %al,(%rax)
    1fec:	00 3f                	add    %bh,(%rdi)
    1fee:	e5 01                	in     $0x1,%eax
    1ff0:	2f                   	(bad)
    1ff1:	16                   	(bad)
    1ff2:	00 00                	add    %al,(%rax)
    1ff4:	44 24 17             	rex.R and $0x17,%al
    1ff7:	00 00                	add    %al,(%rax)
    1ff9:	00 45 06             	add    %al,0x6(%rbp)
    1ffc:	39 16                	cmp    %edx,(%rsi)
    1ffe:	00 00                	add    %al,(%rax)
    2000:	00 00                	add    %al,(%rax)
    2002:	00 46 08             	add    %al,0x8(%rsi)
    2005:	3f                   	(bad)
    2006:	fb                   	sti
    2007:	01 66 0b             	add    %esp,0xb(%rsi)
    200a:	00 00                	add    %al,(%rax)
    200c:	3c 55                	cmp    $0x55,%al
    200e:	1b 00                	sbb    (%rax),%eax
    2010:	00 09                	add    %cl,(%rcx)
    2012:	00 73 03             	add    %dh,0x3(%rbx)
    2015:	09 3d f6 01 5b 1b    	or     %edi,0x1b5b01f6(%rip)        # 1b5b2211 <_license+0x1b5b031e>
    201b:	00 00                	add    %al,(%rax)
    201d:	3d f7 01 64 1b       	cmp    $0x1b6401f7,%eax
    2022:	00 00                	add    %al,(%rax)
    2024:	00 44 25 05          	add    %al,0x5(%rbp,%riz,1)
    2028:	00 00                	add    %al,(%rax)
    202a:	00 3f                	add    %bh,(%rdi)
    202c:	fc                   	cld
    202d:	01 79 0b             	add    %edi,0xb(%rcx)
    2030:	00 00                	add    %al,(%rax)
    2032:	44 25 05 00 00 00    	rex.R and $0x5,%eax
    2038:	45 02 83 0b 00 00 44 	add    0x4400000b(%r11),%r8b
    203f:	25 05 00 00 00       	and    $0x5,%eax
    2044:	3e 01 50 8d          	ds add %edx,-0x73(%rax)
    2048:	0b 00                	or     (%rax),%eax
    204a:	00 42 fe             	add    %al,-0x2(%rdx)
    204d:	ff                   	(bad)
    204e:	ff 07                	incl   (%rdi)
    2050:	96                   	xchg   %eax,%esi
    2051:	0b 00                	or     (%rax),%eax
    2053:	00 42 04             	add    %al,0x4(%rdx)
    2056:	9f                   	lahf
    2057:	0b 00                	or     (%rax),%eax
    2059:	00 00                	add    %al,(%rax)
    205b:	00 00                	add    %al,(%rax)
    205d:	46 0a 3f             	rex.RX or (%rdi),%r15b
    2060:	82                   	(bad)
    2061:	02 ac 0b 00 00 44 26 	add    0x26440000(%rbx,%rcx,1),%ch
    2068:	24 00                	and    $0x0,%al
    206a:	00 00                	add    %al,(%rax)
    206c:	3f                   	(bad)
    206d:	fd                   	std
    206e:	01 b6 0b 00 00 44    	add    %esi,0x4400000b(%rsi)
    2074:	26 24 00             	es and $0x0,%al
    2077:	00 00                	add    %al,(%rax)
    2079:	45 02 c0             	add    %r8b,%r8b
    207c:	0b 00                	or     (%rax),%eax
    207e:	00 44 26 24          	add    %al,0x24(%rsi,%riz,1)
    2082:	00 00                	add    %al,(%rax)
    2084:	00 3f                	add    %bh,(%rdi)
    2086:	fe 01                	incb   (%rcx)
    2088:	ca 0b 00             	lret   $0xb
    208b:	00 42 80             	add    %al,-0x80(%rdx)
    208e:	20 d3                	and    %dl,%bl
    2090:	0b 00                	or     (%rax),%eax
    2092:	00 42 14             	add    %al,0x14(%rdx)
    2095:	dc 0b                	fmull  (%rbx)
    2097:	00 00                	add    %al,(%rax)
    2099:	00 00                	add    %al,(%rax)
    209b:	00 3c 6e             	add    %bh,(%rsi,%rbp,2)
    209e:	1b 00                	sbb    (%rax),%eax
    20a0:	00 0b                	add    %cl,(%rbx)
    20a2:	00 89 03 17 3d ff    	add    %cl,-0xc2e8fd(%rcx)
    20a8:	01 78 1b             	add    %edi,0x1b(%rax)
    20ab:	00 00                	add    %al,(%rax)
    20ad:	3d 80 02 81 1b       	cmp    $0x1b810280,%eax
    20b2:	00 00                	add    %al,(%rax)
    20b4:	3e 02 91 40 8a 1b 00 	ds add 0x1b8a40(%rcx),%dl
    20bb:	00 3f                	add    %bh,(%rdi)
    20bd:	81 02 94 1b 00 00    	addl   $0x1b94,(%rdx)
    20c3:	3c dc                	cmp    $0xdc,%al
    20c5:	16                   	(bad)
    20c6:	00 00                	add    %al,(%rax)
    20c8:	0c 00                	or     $0x0,%al
    20ca:	74 02                	je     20ce <_license+0x1db>
    20cc:	07                   	(bad)
    20cd:	3f                   	(bad)
    20ce:	cc                   	int3
    20cf:	02 ee                	add    %dh,%ch
    20d1:	16                   	(bad)
    20d2:	00 00                	add    %al,(%rax)
    20d4:	3f                   	(bad)
    20d5:	ce                   	(bad)
    20d6:	02 f7                	add    %bh,%dh
    20d8:	16                   	(bad)
    20d9:	00 00                	add    %al,(%rax)
    20db:	44 27                	rex.R (bad)
    20dd:	11 00                	adc    %eax,(%rax)
    20df:	00 00                	add    %al,(%rax)
    20e1:	3f                   	(bad)
    20e2:	cd 02                	int    $0x2
    20e4:	01 17                	add    %edx,(%rdi)
    20e6:	00 00                	add    %al,(%rax)
    20e8:	44 27                	rex.R (bad)
    20ea:	11 00                	adc    %eax,(%rax)
    20ec:	00 00                	add    %al,(%rax)
    20ee:	45 06                	rex.RB (bad)
    20f0:	0a 17                	or     (%rdi),%dl
    20f2:	00 00                	add    %al,(%rax)
    20f4:	00 00                	add    %al,(%rax)
    20f6:	00 00                	add    %al,(%rax)
    20f8:	40 01 16             	rex add %edx,(%rsi)
    20fb:	00 00                	add    %al,(%rax)
    20fd:	28 23                	sub    %ah,(%rbx)
    20ff:	00 00                	add    %al,(%rax)
    2101:	00 00                	add    %al,(%rax)
    2103:	8e 03                	mov    (%rbx),%es
    2105:	0f 41 02             	cmovno (%rdx),%eax
    2108:	91                   	xchg   %eax,%ecx
    2109:	40 07                	rex (bad)
    210b:	16                   	(bad)
    210c:	00 00                	add    %al,(%rax)
    210e:	41 02 30             	add    (%r8),%sil
    2111:	9f                   	lahf
    2112:	10 16                	adc    %dl,(%rsi)
    2114:	00 00                	add    %al,(%rax)
    2116:	41 02 31             	add    (%r9),%sil
    2119:	9f                   	lahf
    211a:	1a 16                	sbb    (%rsi),%dl
    211c:	00 00                	add    %al,(%rax)
    211e:	3f                   	(bad)
    211f:	d0 02                	rolb   (%rdx)
    2121:	24 16                	and    $0x16,%al
    2123:	00 00                	add    %al,(%rax)
    2125:	44 28 17             	sub    %r10b,(%rdi)
    2128:	00 00                	add    %al,(%rax)
    212a:	00 3f                	add    %bh,(%rdi)
    212c:	cf                   	iret
    212d:	02 2f                	add    (%rdi),%ch
    212f:	16                   	(bad)
    2130:	00 00                	add    %al,(%rax)
    2132:	44 28 17             	sub    %r10b,(%rdi)
    2135:	00 00                	add    %al,(%rax)
    2137:	00 45 06             	add    %al,0x6(%rbp)
    213a:	39 16                	cmp    %edx,(%rsi)
	...
    2144:	44 29 45 00          	sub    %r8d,0x0(%rbp)
    2148:	00 00                	add    %al,(%rax)
    214a:	3f                   	(bad)
    214b:	9e                   	sahf
    214c:	01 ec                	add    %ebp,%esp
    214e:	0b 00                	or     (%rax),%eax
    2150:	00 3f                	add    %bh,(%rdi)
    2152:	a0 01 f5 0b 00 00 44 	movabs 0x172a4400000bf501,%al
    2159:	2a 17 
    215b:	00 00                	add    %al,(%rax)
    215d:	00 3f                	add    %bh,(%rdi)
    215f:	9f                   	lahf
    2160:	01 ff                	add    %edi,%edi
    2162:	0b 00                	or     (%rax),%eax
    2164:	00 44 2a 17          	add    %al,0x17(%rdx,%rbp,1)
    2168:	00 00                	add    %al,(%rax)
    216a:	00 45 06             	add    %al,0x6(%rbp)
    216d:	09 0c 00             	or     %ecx,(%rax,%rax,1)
    2170:	00 00                	add    %al,(%rax)
    2172:	00 40 42             	add    %al,0x42(%rax)
    2175:	15 00 00 2b 0a       	adc    $0xa2b0000,%eax
    217a:	00 00                	add    %al,(%rax)
    217c:	00 00                	add    %al,(%rax)
    217e:	65 03 0b             	add    %gs:(%rbx),%ecx
    2181:	41 01 5e 4c          	add    %ebx,0x4c(%r14)
    2185:	15 00 00 41 02       	adc    $0x2410000,%eax
    218a:	30 9f 5e 15 00 00    	xor    %bl,0x155e(%rdi)
    2190:	42 0e                	rex.X (bad)
    2192:	67 15 00 00 44 2b    	addr32 adc $0x2b440000,%eax
    2198:	0a 00                	or     (%rax),%al
    219a:	00 00                	add    %al,(%rax)
    219c:	3e 03 7e 22          	ds add 0x22(%rsi),%edi
    21a0:	9f                   	lahf
    21a1:	7c 15                	jl     21b8 <_license+0x2c5>
    21a3:	00 00                	add    %al,(%rax)
    21a5:	00 00                	add    %al,(%rax)
    21a7:	00 40 87             	add    %al,-0x79(%rax)
    21aa:	15 00 00 2c 62       	adc    $0x622c0000,%eax
    21af:	00 00                	add    %al,(%rax)
    21b1:	00 00                	add    %al,(%rax)
    21b3:	d7                   	xlat   %ds:(%rbx)
    21b4:	03 07                	add    (%rdi),%eax
    21b6:	3d 83 02 95 15       	cmp    $0x15950283,%eax
    21bb:	00 00                	add    %al,(%rax)
    21bd:	3d 84 02 9d 15       	cmp    $0x159d0284,%eax
    21c2:	00 00                	add    %al,(%rax)
    21c4:	3d 85 02 a5 15       	cmp    $0x15a50285,%eax
    21c9:	00 00                	add    %al,(%rax)
    21cb:	3f                   	(bad)
    21cc:	86 02                	xchg   %al,(%rdx)
    21ce:	ae                   	scas   %es:(%rdi),%al
    21cf:	15 00 00 3f 87       	adc    $0x873f0000,%eax
    21d4:	02 b7 15 00 00 3f    	add    0x3f000015(%rdi),%dh
    21da:	88 02                	mov    %al,(%rdx)
    21dc:	c0 15 00 00 44 2d 1a 	rclb   $0x1a,0x2d440000(%rip)        # 2d4421e3 <_license+0x2d4402f0>
    21e3:	00 00                	add    %al,(%rax)
    21e5:	00 3f                	add    %bh,(%rdi)
    21e7:	8a 02                	mov    (%rdx),%al
    21e9:	c9                   	leave
    21ea:	15 00 00 44 2d       	adc    $0x2d440000,%eax
    21ef:	1a 00                	sbb    (%rax),%al
    21f1:	00 00                	add    %al,(%rax)
    21f3:	45 02 d2             	add    %r10b,%r10b
    21f6:	15 00 00 44 2d       	adc    $0x2d440000,%eax
    21fb:	1a 00                	sbb    (%rax),%al
    21fd:	00 00                	add    %al,(%rax)
    21ff:	3f                   	(bad)
    2200:	89 02                	mov    %eax,(%rdx)
    2202:	db 15 00 00 42 80    	fistl  -0x7fbe0000(%rip)        # ffffffff80422208 <server_id_map+0x36fc3fc3e208>
    2208:	20 e3                	and    %ah,%bl
    220a:	15 00 00 42 14       	adc    $0x14420000,%eax
    220f:	eb 15                	jmp    2226 <_license+0x333>
    2211:	00 00                	add    %al,(%rax)
    2213:	00 00                	add    %al,(%rax)
    2215:	00 00                	add    %al,(%rax)
    2217:	40                   	rex
    2218:	45 16                	rex.RB (bad)
    221a:	00 00                	add    %al,(%rax)
    221c:	2e d5                	cs (bad)
    221e:	00 00                	add    %al,(%rax)
    2220:	00 00                	add    %al,(%rax)
    2222:	e4 03                	in     $0x3,%al
    2224:	05 41 04 91 80       	add    $0x80910441,%eax
    2229:	7f 9f                	jg     21ca <_license+0x2d7>
    222b:	58                   	pop    %rax
    222c:	16                   	(bad)
    222d:	00 00                	add    %al,(%rax)
    222f:	3d 8b 02 61 16       	cmp    $0x1661028b,%eax
    2234:	00 00                	add    %al,(%rax)
    2236:	41 04 91             	rex.B add $0x91,%al
    2239:	d8 7e 9f             	fdivrs -0x61(%rsi)
    223c:	6a 16                	push   $0x16
    223e:	00 00                	add    %al,(%rax)
    2240:	40 dc 16             	rex fcoml (%rsi)
    2243:	00 00                	add    %al,(%rax)
    2245:	2f                   	(bad)
    2246:	62                   	(bad)
    2247:	00 00                	add    %al,(%rax)
    2249:	00 00                	add    %al,(%rax)
    224b:	93                   	xchg   %eax,%ebx
    224c:	02 32                	add    (%rdx),%dh
    224e:	3f                   	(bad)
    224f:	8c 02                	mov    %es,(%rdx)
    2251:	ee                   	out    %al,(%dx)
    2252:	16                   	(bad)
    2253:	00 00                	add    %al,(%rax)
    2255:	3f                   	(bad)
    2256:	8e 02                	mov    (%rdx),%es
    2258:	f7 16                	notl   (%rsi)
    225a:	00 00                	add    %al,(%rax)
    225c:	44 30 17             	xor    %r10b,(%rdi)
    225f:	00 00                	add    %al,(%rax)
    2261:	00 3f                	add    %bh,(%rdi)
    2263:	8d 02                	lea    (%rdx),%eax
    2265:	01 17                	add    %edx,(%rdi)
    2267:	00 00                	add    %al,(%rax)
    2269:	44 30 17             	xor    %r10b,(%rdi)
    226c:	00 00                	add    %al,(%rax)
    226e:	00 45 06             	add    %al,0x6(%rbp)
    2271:	0a 17                	or     (%rdi),%dl
    2273:	00 00                	add    %al,(%rax)
    2275:	00 00                	add    %al,(%rax)
    2277:	00 44 31 5f          	add    %al,0x5f(%rcx,%rsi,1)
    227b:	00 00                	add    %al,(%rax)
    227d:	00 3f                	add    %bh,(%rdi)
    227f:	90                   	nop
    2280:	02 7e 16             	add    0x16(%rsi),%bh
    2283:	00 00                	add    %al,(%rax)
    2285:	44 31 1b             	xor    %r11d,(%rbx)
    2288:	00 00                	add    %al,(%rax)
    228a:	00 3f                	add    %bh,(%rdi)
    228c:	8f 02                	pop    (%rdx)
    228e:	89 16                	mov    %edx,(%rsi)
    2290:	00 00                	add    %al,(%rax)
    2292:	44 31 1b             	xor    %r11d,(%rbx)
    2295:	00 00                	add    %al,(%rax)
    2297:	00 45 0d             	add    %al,0xd(%rbp)
    229a:	93                   	xchg   %eax,%ebx
    229b:	16                   	(bad)
    229c:	00 00                	add    %al,(%rax)
    229e:	00 00                	add    %al,(%rax)
    22a0:	44 32 3f             	xor    (%rdi),%r15b
    22a3:	00 00                	add    %al,(%rax)
    22a5:	00 3f                	add    %bh,(%rdi)
    22a7:	91                   	xchg   %eax,%ecx
    22a8:	02 9f 16 00 00 44    	add    0x44000016(%rdi),%bl
    22ae:	33 30                	xor    (%rax),%esi
    22b0:	00 00                	add    %al,(%rax)
    22b2:	00 3f                	add    %bh,(%rdi)
    22b4:	92                   	xchg   %eax,%edx
    22b5:	02 aa 16 00 00 3f    	add    0x3f000016(%rdx),%ch
    22bb:	94                   	xchg   %eax,%esp
    22bc:	02 b3 16 00 00 44    	add    0x44000016(%rbx),%dh
    22c2:	34 17                	xor    $0x17,%al
    22c4:	00 00                	add    %al,(%rax)
    22c6:	00 3f                	add    %bh,(%rdi)
    22c8:	93                   	xchg   %eax,%ebx
    22c9:	02 be 16 00 00 44    	add    0x44000016(%rsi),%bh
    22cf:	34 17                	xor    $0x17,%al
    22d1:	00 00                	add    %al,(%rax)
    22d3:	00 45 06             	add    %al,0x6(%rbp)
    22d6:	c8 16 00 00          	enter  $0x16,$0x0
    22da:	00 00                	add    %al,(%rax)
    22dc:	00 00                	add    %al,(%rax)
    22de:	00 00                	add    %al,(%rax)
    22e0:	44 35 37 00 00 00    	rex.R xor $0x37,%eax
    22e6:	3f                   	(bad)
    22e7:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    22e8:	02 17                	add    (%rdi),%dl
    22ea:	0c 00                	or     $0x0,%al
    22ec:	00 3f                	add    %bh,(%rdi)
    22ee:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    22ef:	02 20                	add    (%rax),%ah
    22f1:	0c 00                	or     $0x0,%al
    22f3:	00 44 36 17          	add    %al,0x17(%rsi,%rsi,1)
    22f7:	00 00                	add    %al,(%rax)
    22f9:	00 3f                	add    %bh,(%rdi)
    22fb:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    22fc:	02 2a                	add    (%rdx),%ch
    22fe:	0c 00                	or     $0x0,%al
    2300:	00 44 36 17          	add    %al,0x17(%rsi,%rsi,1)
    2304:	00 00                	add    %al,(%rax)
    2306:	00 45 06             	add    %al,0x6(%rbp)
    2309:	34 0c                	xor    $0xc,%al
    230b:	00 00                	add    %al,(%rax)
    230d:	00 00                	add    %al,(%rax)
    230f:	00 3c f6             	add    %bh,(%rsi,%rsi,8)
    2312:	17                   	(bad)
    2313:	00 00                	add    %al,(%rax)
    2315:	0d 00 fa 03 0c       	or     $0xc03fa00,%eax
    231a:	3d a8 02 08 18       	cmp    $0x180802a8,%eax
    231f:	00 00                	add    %al,(%rax)
    2321:	3d a9 02 10 18       	cmp    $0x181002a9,%eax
    2326:	00 00                	add    %al,(%rax)
    2328:	3d aa 02 18 18       	cmp    $0x181802aa,%eax
    232d:	00 00                	add    %al,(%rax)
    232f:	3d ab 02 20 18       	cmp    $0x182002ab,%eax
    2334:	00 00                	add    %al,(%rax)
    2336:	3e 02 91 40 28 18 00 	ds add 0x182840(%rcx),%dl
    233d:	00 3f                	add    %bh,(%rdi)
    233f:	ac                   	lods   %ds:(%rsi),%al
    2340:	02 31                	add    (%rcx),%dh
    2342:	18 00                	sbb    %al,(%rax)
    2344:	00 3f                	add    %bh,(%rdi)
    2346:	ad                   	lods   %ds:(%rsi),%eax
    2347:	02 3a                	add    (%rdx),%bh
    2349:	18 00                	sbb    %al,(%rax)
    234b:	00 3f                	add    %bh,(%rdi)
    234d:	ae                   	scas   %es:(%rdi),%al
    234e:	02 43 18             	add    0x18(%rbx),%al
    2351:	00 00                	add    %al,(%rax)
    2353:	3f                   	(bad)
    2354:	c1 02 4c             	roll   $0x4c,(%rdx)
    2357:	18 00                	sbb    %al,(%rax)
    2359:	00 3f                	add    %bh,(%rdi)
    235b:	c2 02 55             	ret    $0x5502
    235e:	18 00                	sbb    %al,(%rax)
    2360:	00 47 dc             	add    %al,-0x24(%rdi)
    2363:	16                   	(bad)
    2364:	00 00                	add    %al,(%rax)
    2366:	0e                   	(bad)
    2367:	00 66 11             	add    %ah,0x11(%rsi)
    236a:	3f                   	(bad)
    236b:	af                   	scas   %es:(%rdi),%eax
    236c:	02 ee                	add    %dh,%ch
    236e:	16                   	(bad)
    236f:	00 00                	add    %al,(%rax)
    2371:	3f                   	(bad)
    2372:	b1 02                	mov    $0x2,%cl
    2374:	f7 16                	notl   (%rsi)
    2376:	00 00                	add    %al,(%rax)
    2378:	44 37                	rex.R (bad)
    237a:	1a 00                	sbb    (%rax),%al
    237c:	00 00                	add    %al,(%rax)
    237e:	3f                   	(bad)
    237f:	b0 02                	mov    $0x2,%al
    2381:	01 17                	add    %edx,(%rdi)
    2383:	00 00                	add    %al,(%rax)
    2385:	44 37                	rex.R (bad)
    2387:	1a 00                	sbb    (%rax),%al
    2389:	00 00                	add    %al,(%rax)
    238b:	45 06                	rex.RB (bad)
    238d:	0a 17                	or     (%rdi),%dl
    238f:	00 00                	add    %al,(%rax)
    2391:	00 00                	add    %al,(%rax)
    2393:	00 44 38 b9          	add    %al,-0x47(%rax,%rdi,1)
    2397:	00 00                	add    %al,(%rax)
    2399:	00 3e                	add    %bh,(%rsi)
    239b:	02 30                	add    (%rax),%dh
    239d:	9f                   	lahf
    239e:	66 18 00             	data16 sbb %al,(%rax)
    23a1:	00 47 aa             	add    %al,-0x56(%rdi)
    23a4:	19 00                	sbb    %eax,(%rax)
    23a6:	00 0f                	add    %cl,(%rdi)
    23a8:	00 8f 0c 3d bb 02    	add    %cl,0x2bb3d0c(%rdi)
    23ae:	b3 19                	mov    $0x19,%bl
    23b0:	00 00                	add    %al,(%rax)
    23b2:	3d bc 02 bb 19       	cmp    $0x19bb02bc,%eax
    23b7:	00 00                	add    %al,(%rax)
    23b9:	43                   	rex.XB
    23ba:	67 1a 00             	sbb    (%eax),%al
    23bd:	00 39                	add    %bh,(%rcx)
    23bf:	4f 00 00             	rex.WRXB add %r8b,(%r8)
    23c2:	00 00                	add    %al,(%rax)
    23c4:	22 0c 3d bd 02 70 1a 	and    0x1a7002bd(,%rdi,1),%cl
    23cb:	00 00                	add    %al,(%rax)
    23cd:	48 80 84 80 10 82 1a 	rex.W addb $0x0,0x1a8210(%rax,%rax,4)
    23d4:	00 00 
    23d6:	43 39 1a             	rex.XB cmp %ebx,(%r10)
    23d9:	00 00                	add    %al,(%rax)
    23db:	39 4f 00             	cmp    %ecx,0x0(%rdi)
    23de:	00 00                	add    %al,(%rax)
    23e0:	0a 6f 0a             	or     0xa(%rdi),%ch
    23e3:	3d be 02 42 1a       	cmp    $0x1a4202be,%eax
    23e8:	00 00                	add    %al,(%rax)
    23ea:	3d bf 02 4b 1a       	cmp    $0x1a4b02bf,%eax
    23ef:	00 00                	add    %al,(%rax)
    23f1:	3d c0 02 54 1a       	cmp    $0x1a5402c0,%eax
    23f6:	00 00                	add    %al,(%rax)
    23f8:	48 f7 81 b7 85 fe ff 	testq  $0x1ffffff,-0x17a49(%rcx)
    23ff:	ff ff ff 01 
    2403:	5d                   	pop    %rbp
    2404:	1a 00                	sbb    (%rax),%al
    2406:	00 43 1d             	add    %al,0x1d(%rbx)
    2409:	1a 00                	sbb    (%rax),%al
    240b:	00 3a                	add    %bh,(%rdx)
    240d:	05 00 00 00 0a       	add    $0xa000000,%eax
    2412:	6a 03                	push   $0x3
    2414:	41 01 54 26 1a       	add    %edx,0x1a(%r14,%riz,1)
    2419:	00 00                	add    %al,(%rax)
    241b:	48 0e                	rex.W (bad)
    241d:	2f                   	(bad)
    241e:	1a 00                	sbb    (%rax),%al
    2420:	00 00                	add    %al,(%rax)
    2422:	43 1d 1a 00 00 3b    	rex.XB sbb $0x3b00001a,%eax
    2428:	05 00 00 00 0a       	add    $0xa000000,%eax
    242d:	6a 03                	push   $0x3
    242f:	41 01 52 26          	add    %edx,0x26(%r10)
    2433:	1a 00                	sbb    (%rax),%al
    2435:	00 48 0b             	add    %cl,0xb(%rax)
    2438:	2f                   	(bad)
    2439:	1a 00                	sbb    (%rax),%al
    243b:	00 00                	add    %al,(%rax)
    243d:	43 1d 1a 00 00 3c    	rex.XB sbb $0x3c00001a,%eax
    2443:	05 00 00 00 0a       	add    $0xa000000,%eax
    2448:	6a 03                	push   $0x3
    244a:	41 01 51 26          	add    %edx,0x26(%r9)
    244e:	1a 00                	sbb    (%rax),%al
    2450:	00 48 19             	add    %cl,0x19(%rax)
    2453:	2f                   	(bad)
    2454:	1a 00                	sbb    (%rax),%al
    2456:	00 00                	add    %al,(%rax)
    2458:	43 1d 1a 00 00 3d    	rex.XB sbb $0x3d00001a,%eax
    245e:	05 00 00 00 0a       	add    $0xa000000,%eax
    2463:	6a 03                	push   $0x3
    2465:	41 01 54 26 1a       	add    %edx,0x1a(%r14,%riz,1)
    246a:	00 00                	add    %al,(%rax)
    246c:	48 10 2f             	rex.W adc %bpl,(%rdi)
    246f:	1a 00                	sbb    (%rax),%al
    2471:	00 00                	add    %al,(%rax)
    2473:	43 1d 1a 00 00 3e    	rex.XB sbb $0x3e00001a,%eax
    2479:	05 00 00 00 0a       	add    $0xa000000,%eax
    247e:	6a 03                	push   $0x3
    2480:	41 01 52 26          	add    %edx,0x26(%r10)
    2484:	1a 00                	sbb    (%rax),%al
    2486:	00 48 04             	add    %cl,0x4(%rax)
    2489:	2f                   	(bad)
    248a:	1a 00                	sbb    (%rax),%al
    248c:	00 00                	add    %al,(%rax)
    248e:	43 1d 1a 00 00 3f    	rex.XB sbb $0x3f00001a,%eax
    2494:	03 00                	add    (%rax),%eax
    2496:	00 00                	add    %al,(%rax)
    2498:	0a 6a 03             	or     0x3(%rdx),%ch
    249b:	41 01 51 26          	add    %edx,0x26(%r9)
    249f:	1a 00                	sbb    (%rax),%al
    24a1:	00 48 0e             	add    %cl,0xe(%rax)
    24a4:	2f                   	(bad)
    24a5:	1a 00                	sbb    (%rax),%al
    24a7:	00 00                	add    %al,(%rax)
    24a9:	43 1d 1a 00 00 40    	rex.XB sbb $0x4000001a,%eax
    24af:	03 00                	add    (%rax),%eax
    24b1:	00 00                	add    %al,(%rax)
    24b3:	0a 6a 03             	or     0x3(%rdx),%ch
    24b6:	41 01 54 26 1a       	add    %edx,0x1a(%r14,%riz,1)
    24bb:	00 00                	add    %al,(%rax)
    24bd:	48 18 2f             	rex.W sbb %bpl,(%rdi)
    24c0:	1a 00                	sbb    (%rax),%al
    24c2:	00 00                	add    %al,(%rax)
    24c4:	00 00                	add    %al,(%rax)
    24c6:	00 46 10             	add    %al,0x10(%rsi)
    24c9:	3f                   	(bad)
    24ca:	c3                   	ret
    24cb:	02 70 18             	add    0x18(%rax),%dh
    24ce:	00 00                	add    %al,(%rax)
    24d0:	46 11 45 02          	rex.RX adc %r8d,0x2(%rbp)
    24d4:	79 18                	jns    24ee <_license+0x5fb>
    24d6:	00 00                	add    %al,(%rax)
    24d8:	46 12 3e             	rex.RX adc (%rsi),%r15b
    24db:	01 51 82             	add    %edx,-0x7e(%rcx)
    24de:	18 00                	sbb    %al,(%rax)
    24e0:	00 42 80             	add    %al,-0x80(%rdx)
    24e3:	84 80 10 8a 18 00    	test   %al,0x188a10(%rax)
    24e9:	00 42 04             	add    %al,0x4(%rdx)
    24ec:	92                   	xchg   %eax,%edx
    24ed:	18 00                	sbb    %al,(%rax)
    24ef:	00 00                	add    %al,(%rax)
    24f1:	00 00                	add    %al,(%rax)
    24f3:	00 44 41 06          	add    %al,0x6(%rcx,%rax,2)
    24f7:	00 00                	add    %al,(%rax)
    24f9:	00 3f                	add    %bh,(%rdi)
    24fb:	c4 02 9f 18          	(bad)
    24ff:	00 00                	add    %al,(%rax)
    2501:	44                   	rex.R
    2502:	41 06                	rex.B (bad)
    2504:	00 00                	add    %al,(%rax)
    2506:	00 45 02             	add    %al,0x2(%rbp)
    2509:	a8 18                	test   $0x18,%al
    250b:	00 00                	add    %al,(%rax)
    250d:	44                   	rex.R
    250e:	41 06                	rex.B (bad)
    2510:	00 00                	add    %al,(%rax)
    2512:	00 3e                	add    %bh,(%rsi)
    2514:	01 53 b1             	add    %edx,-0x4f(%rbx)
    2517:	18 00                	sbb    %al,(%rax)
    2519:	00 42 80             	add    %al,-0x80(%rdx)
    251c:	20 b9 18 00 00 42    	and    %bh,0x42000018(%rcx)
    2522:	14 c1                	adc    $0xc1,%al
    2524:	18 00                	sbb    %al,(%rax)
    2526:	00 00                	add    %al,(%rax)
    2528:	00 00                	add    %al,(%rax)
    252a:	00 40 8c             	add    %al,-0x74(%rax)
    252d:	1a 00                	sbb    (%rax),%al
    252f:	00 42 58             	add    %al,0x58(%rdx)
    2532:	00 00                	add    %al,(%rax)
    2534:	00 00                	add    %al,(%rax)
    2536:	ff 03                	incl   (%rbx)
    2538:	0b 41 04             	or     0x4(%rcx),%eax
    253b:	91                   	xchg   %eax,%ecx
    253c:	d8 7e 9f             	fdivrs -0x61(%rsi)
    253f:	96                   	xchg   %eax,%esi
    2540:	1a 00                	sbb    (%rax),%al
    2542:	00 41 02             	add    %al,0x2(%rcx)
    2545:	30 9f b1 1a 00 00    	xor    %bl,0x1ab1(%rdi)
    254b:	3f                   	(bad)
    254c:	c5 02 c4             	(bad)
    254f:	1a 00                	sbb    (%rax),%al
    2551:	00 42 00             	add    %al,0x0(%rdx)
    2554:	ba 1a 00 00 44       	mov    $0x4400001a,%edx
    2559:	43 27                	rex.XB (bad)
    255b:	00 00                	add    %al,(%rax)
    255d:	00 3f                	add    %bh,(%rdi)
    255f:	c6 02 f7             	movb   $0xf7,(%rdx)
    2562:	1a 00                	sbb    (%rax),%al
    2564:	00 3f                	add    %bh,(%rdi)
    2566:	c8 02 00 1b          	enter  $0x2,$0x1b
    256a:	00 00                	add    %al,(%rax)
    256c:	44                   	rex.R
    256d:	44 17                	rex.R (bad)
    256f:	00 00                	add    %al,(%rax)
    2571:	00 3f                	add    %bh,(%rdi)
    2573:	c7 02 0b 1b 00 00    	movl   $0x1b0b,(%rdx)
    2579:	44                   	rex.R
    257a:	44 17                	rex.R (bad)
    257c:	00 00                	add    %al,(%rax)
    257e:	00 45 06             	add    %al,0x6(%rbp)
    2581:	15 1b 00 00 00       	adc    $0x1b,%eax
    2586:	00 00                	add    %al,(%rax)
    2588:	00 44 45 20          	add    %al,0x20(%rbp,%rax,2)
    258c:	00 00                	add    %al,(%rax)
    258e:	00 3f                	add    %bh,(%rdi)
    2590:	95                   	xchg   %eax,%ebp
    2591:	02 41 0c             	add    0xc(%rcx),%al
    2594:	00 00                	add    %al,(%rax)
    2596:	44                   	rex.R
    2597:	45 20 00             	and    %r8b,(%r8)
    259a:	00 00                	add    %al,(%rax)
    259c:	45 06                	rex.RB (bad)
    259e:	4b 0c 00             	rex.WXB or $0x0,%al
    25a1:	00 00                	add    %al,(%rax)
    25a3:	00 44 46 11          	add    %al,0x11(%rsi,%rax,2)
    25a7:	00 00                	add    %al,(%rax)
    25a9:	00 3f                	add    %bh,(%rdi)
    25ab:	97                   	xchg   %eax,%edi
    25ac:	02 57 0c             	add    0xc(%rdi),%dl
    25af:	00 00                	add    %al,(%rax)
    25b1:	44                   	rex.R
    25b2:	46 11 00             	rex.RX adc %r8d,(%rax)
    25b5:	00 00                	add    %al,(%rax)
    25b7:	45 06                	rex.RB (bad)
    25b9:	61                   	(bad)
    25ba:	0c 00                	or     $0x0,%al
    25bc:	00 00                	add    %al,(%rax)
    25be:	00 40 15             	add    %al,0x15(%rax)
    25c1:	17                   	(bad)
    25c2:	00 00                	add    %al,(%rax)
    25c4:	47 d3 00             	rex.RXB roll %cl,(%r8)
    25c7:	00 00                	add    %al,(%rax)
    25c9:	00 28                	add    %ch,(%rax)
    25cb:	04 0a                	add    $0xa,%al
    25cd:	41 01 5d 1e          	add    %ebx,0x1e(%r13)
    25d1:	17                   	(bad)
    25d2:	00 00                	add    %al,(%rax)
    25d4:	41 04 91             	rex.B add $0x91,%al
    25d7:	80 7f 9f 2e          	cmpb   $0x2e,-0x61(%rdi)
    25db:	17                   	(bad)
    25dc:	00 00                	add    %al,(%rax)
    25de:	3d 98 02 36 17       	cmp    $0x17360298,%eax
    25e3:	00 00                	add    %al,(%rax)
    25e5:	3d 99 02 3e 17       	cmp    $0x173e0299,%eax
    25ea:	00 00                	add    %al,(%rax)
    25ec:	3f                   	(bad)
    25ed:	9a                   	(bad)
    25ee:	02 4e 17             	add    0x17(%rsi),%cl
    25f1:	00 00                	add    %al,(%rax)
    25f3:	3f                   	(bad)
    25f4:	9b                   	fwait
    25f5:	02 57 17             	add    0x17(%rdi),%dl
    25f8:	00 00                	add    %al,(%rax)
    25fa:	3f                   	(bad)
    25fb:	9c                   	pushf
    25fc:	02 5f 17             	add    0x17(%rdi),%bl
    25ff:	00 00                	add    %al,(%rax)
    2601:	3f                   	(bad)
    2602:	9d                   	popf
    2603:	02 67 17             	add    0x17(%rdi),%ah
    2606:	00 00                	add    %al,(%rax)
    2608:	3f                   	(bad)
    2609:	9e                   	sahf
    260a:	02 6f 17             	add    0x17(%rdi),%ch
    260d:	00 00                	add    %al,(%rax)
    260f:	3f                   	(bad)
    2610:	9f                   	lahf
    2611:	02 46 17             	add    0x17(%rsi),%al
    2614:	00 00                	add    %al,(%rax)
    2616:	3f                   	(bad)
    2617:	a0 02 78 17 00 00 43 	movabs 0x17b8430000177802,%al
    261e:	b8 17 
    2620:	00 00                	add    %al,(%rax)
    2622:	48                   	rex.W
    2623:	41 00 00             	add    %al,(%r8)
    2626:	00 0d 75 03 41 01    	add    %cl,0x1410375(%rip)        # 14129a1 <_license+0x1410aae>
    262c:	53                   	push   %rbx
    262d:	c5 17 00             	(bad)
    2630:	00 3d a1 02 cd 17    	add    %bh,0x17cd02a1(%rip)        # 17cd28d7 <_license+0x17cd09e4>
    2636:	00 00                	add    %al,(%rax)
    2638:	41 01 52 d5          	add    %edx,-0x2b(%r10)
    263c:	17                   	(bad)
    263d:	00 00                	add    %al,(%rax)
    263f:	3d a2 02 dd 17       	cmp    $0x17dd02a2,%eax
    2644:	00 00                	add    %al,(%rax)
    2646:	48 04 e5             	rex.W add $0xe5,%al
    2649:	17                   	(bad)
    264a:	00 00                	add    %al,(%rax)
    264c:	42 00 ed             	rex.X add %bpl,%bpl
    264f:	17                   	(bad)
    2650:	00 00                	add    %al,(%rax)
    2652:	43 19 11             	rex.XB sbb %edx,(%r9)
    2655:	00 00                	add    %al,(%rax)
    2657:	49 19 00             	sbb    %rax,(%r8)
    265a:	00 00                	add    %al,(%rax)
    265c:	0e                   	(bad)
    265d:	48 03 41 03          	add    0x3(%rcx),%rax
    2661:	70 0e                	jo     2671 <_license+0x77e>
    2663:	9f                   	lahf
    2664:	1d 11 00 00 3f       	sbb    $0x3f000011,%eax
    2669:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    266a:	02 2d 11 00 00 44    	add    0x44000011(%rip),%ch        # 44002681 <_license+0x4400078e>
    2670:	49 19 00             	sbb    %rax,(%r8)
    2673:	00 00                	add    %al,(%rax)
    2675:	3f                   	(bad)
    2676:	a3 02 36 11 00 00 00 	movabs %eax,0x113602
    267d:	00 00 
    267f:	00 40 cd             	add    %al,-0x33(%rax)
    2682:	18 00                	sbb    %al,(%rax)
    2684:	00 4a 94             	add    %cl,-0x6c(%rdx)
    2687:	00 00                	add    %al,(%rax)
    2689:	00 00                	add    %al,(%rax)
    268b:	24 04                	and    $0x4,%al
    268d:	0a 41 01             	or     0x1(%rcx),%al
    2690:	5d                   	pop    %rbp
    2691:	d6                   	(bad)
    2692:	18 00                	sbb    %al,(%rax)
    2694:	00 41 02             	add    %al,0x2(%rcx)
    2697:	30 9f e6 18 00 00    	xor    %bl,0x18e6(%rdi)
    269d:	41 04 91             	rex.B add $0x91,%al
    26a0:	80 7f 9f ee          	cmpb   $0xee,-0x61(%rdi)
    26a4:	18 00                	sbb    %al,(%rax)
    26a6:	00 41 02             	add    %al,0x2(%rcx)
    26a9:	91                   	xchg   %eax,%ecx
    26aa:	50                   	push   %rax
    26ab:	f6 18                	negb   (%rax)
    26ad:	00 00                	add    %al,(%rax)
    26af:	41 12 7c 00 10       	adc    0x10(%r8,%rax,1),%dil
    26b4:	ff                   	(bad)
    26b5:	ff 03                	incl   (%rbx)
    26b7:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
    26bd:	a8 b0                	test   $0xb0,%al
    26bf:	80 80 00 9f fe 18 00 	addb   $0x0,0x18fe9f00(%rax)
    26c6:	00 3f                	add    %bh,(%rdi)
    26c8:	b2 02                	mov    $0x2,%dl
    26ca:	06                   	(bad)
    26cb:	19 00                	sbb    %eax,(%rax)
    26cd:	00 3f                	add    %bh,(%rdi)
    26cf:	b3 02                	mov    $0x2,%bl
    26d1:	0e                   	(bad)
    26d2:	19 00                	sbb    %eax,(%rax)
    26d4:	00 3f                	add    %bh,(%rdi)
    26d6:	b4 02                	mov    $0x2,%ah
    26d8:	16                   	(bad)
    26d9:	19 00                	sbb    %eax,(%rax)
    26db:	00 3f                	add    %bh,(%rdi)
    26dd:	b5 02                	mov    $0x2,%ch
    26df:	1f                   	(bad)
    26e0:	19 00                	sbb    %eax,(%rax)
    26e2:	00 3f                	add    %bh,(%rdi)
    26e4:	b6 02                	mov    $0x2,%dh
    26e6:	27                   	(bad)
    26e7:	19 00                	sbb    %eax,(%rax)
    26e9:	00 3f                	add    %bh,(%rdi)
    26eb:	b7 02                	mov    $0x2,%bh
    26ed:	30 19                	xor    %bl,(%rcx)
    26ef:	00 00                	add    %al,(%rax)
    26f1:	3f                   	(bad)
    26f2:	b8 02 38 19 00       	mov    $0x193802,%eax
    26f7:	00 3f                	add    %bh,(%rdi)
    26f9:	b9 02 40 19 00       	mov    $0x194002,%ecx
    26fe:	00 49 55             	add    %cl,0x55(%rcx)
    2701:	19 00                	sbb    %eax,(%rax)
    2703:	00 4b 03             	add    %cl,0x3(%rbx)
    2706:	00 00                	add    %al,(%rax)
    2708:	00 0d 4f 05 43 73    	add    %cl,0x7343054f(%rip)        # 73432c5d <_license+0x73430d6a>
    270e:	19 00                	sbb    %eax,(%rax)
    2710:	00 4c 25 00          	add    %cl,0x0(%rbp,%riz,1)
    2714:	00 00                	add    %al,(%rax)
    2716:	0d 53 03 3d ba       	or     $0xba3d0353,%eax
    271b:	02 80 19 00 00 41    	add    0x41000019(%rax),%al
    2721:	02 91 50 91 19 00    	add    0x199150(%rcx),%dl
    2727:	00 41 01             	add    %al,0x1(%rcx)
    272a:	5c                   	pop    %rsp
    272b:	99                   	cltd
    272c:	19 00                	sbb    %eax,(%rax)
    272e:	00 48 04             	add    %cl,0x4(%rax)
    2731:	a1 19 00 00 00 00 00 	movabs 0xd83c000000000019,%eax
    2738:	3c d8 
    273a:	09 00                	or     %eax,(%rax)
    273c:	00 13                	add    %dl,(%rbx)
    273e:	00 43 04             	add    %al,0x4(%rbx)
    2741:	0c 3d                	or     $0x3d,%al
    2743:	1e                   	(bad)
    2744:	e1 09                	loope  274f <_license+0x85c>
    2746:	00 00                	add    %al,(%rax)
    2748:	3d 1f ea 09 00       	cmp    $0x9ea1f,%eax
    274d:	00 3d 20 f3 09 00    	add    %bh,0x9f320(%rip)        # a1a73 <_license+0x9fb80>
    2753:	00 3e                	add    %bh,(%rsi)
    2755:	03 91 80 7f fc 09    	add    0x9fc7f80(%rcx),%edx
    275b:	00 00                	add    %al,(%rax)
    275d:	3e 03 91 d8 7e 05 0a 	ds add 0xa057ed8(%rcx),%edx
    2764:	00 00                	add    %al,(%rax)
    2766:	3f                   	(bad)
    2767:	21 0e                	and    %ecx,(%rsi)
    2769:	0a 00                	or     (%rax),%al
    276b:	00 3f                	add    %bh,(%rdi)
    276d:	22 17                	and    (%rdi),%dl
    276f:	0a 00                	or     (%rax),%al
    2771:	00 3f                	add    %bh,(%rdi)
    2773:	23 20                	and    (%rax),%esp
    2775:	0a 00                	or     (%rax),%al
    2777:	00 3f                	add    %bh,(%rdi)
    2779:	24 29                	and    $0x29,%al
    277b:	0a 00                	or     (%rax),%al
    277d:	00 3f                	add    %bh,(%rdi)
    277f:	25 32 0a 00 00       	and    $0xa32,%eax
    2784:	3f                   	(bad)
    2785:	31 3b                	xor    %edi,(%rbx)
    2787:	0a 00                	or     (%rax),%al
    2789:	00 3f                	add    %bh,(%rdi)
    278b:	32 44 0a 00          	xor    0x0(%rdx,%rcx,1),%al
    278f:	00 3f                	add    %bh,(%rdi)
    2791:	5a                   	pop    %rdx
    2792:	4d 0a 00             	rex.WRB or (%r8),%r8b
    2795:	00 3f                	add    %bh,(%rdi)
    2797:	5b                   	pop    %rbx
    2798:	56                   	push   %rsi
    2799:	0a 00                	or     (%rax),%al
    279b:	00 3f                	add    %bh,(%rdi)
    279d:	5d                   	pop    %rbp
    279e:	5f                   	pop    %rdi
    279f:	0a 00                	or     (%rax),%al
    27a1:	00 3f                	add    %bh,(%rdi)
    27a3:	5e                   	pop    %rsi
    27a4:	68 0a 00 00 3f       	push   $0x3f00000a
    27a9:	5f                   	pop    %rdi
    27aa:	71 0a                	jno    27b6 <_license+0x8c3>
    27ac:	00 00                	add    %al,(%rax)
    27ae:	3f                   	(bad)
    27af:	61                   	(bad)
    27b0:	7a 0a                	jp     27bc <_license+0x8c9>
    27b2:	00 00                	add    %al,(%rax)
    27b4:	3f                   	(bad)
    27b5:	cb                   	lret
    27b6:	02 8c 0a 00 00 3c 7c 	add    0x7c3c0000(%rdx,%rcx,1),%cl
    27bd:	0d 00 00 14 00       	or     $0x140000,%eax
    27c2:	ba 02 0c 3d 26       	mov    $0x263d0c02,%edx
    27c7:	85 0d 00 00 3d 27    	test   %ecx,0x273d0000(%rip)        # 273d27cd <_license+0x273d08da>
    27cd:	97                   	xchg   %eax,%edi
    27ce:	0d 00 00 3d 28       	or     $0x283d0000,%eax
    27d3:	b2 0d                	mov    $0xd,%dl
    27d5:	00 00                	add    %al,(%rax)
    27d7:	3d 29 bb 0d 00       	cmp    $0xdbb29,%eax
    27dc:	00 3d 2a c4 0d 00    	add    %bh,0xdc42a(%rip)        # dec0c <_license+0xdcd19>
    27e2:	00 3f                	add    %bh,(%rdi)
    27e4:	2b d6                	sub    %esi,%edx
    27e6:	0d 00 00 3f 2c       	or     $0x2c3f0000,%eax
    27eb:	df 0d 00 00 00 3c    	fisttps 0x3c000000(%rip)        # 3c0027f1 <_license+0x3c0008fe>
    27f1:	a1 10 00 00 15 00 bf 	movabs 0xc02bf0015000010,%eax
    27f8:	02 0c 
    27fa:	3d 33 aa 10 00       	cmp    $0x10aa33,%eax
    27ff:	00 3d 34 b3 10 00    	add    %bh,0x10b334(%rip)        # 10db39 <_license+0x10bc46>
    2805:	00 3d 35 bc 10 00    	add    %bh,0x10bc35(%rip)        # 10e440 <_license+0x10c54d>
    280b:	00 3d 36 c5 10 00    	add    %bh,0x10c536(%rip)        # 10ed47 <_license+0x10ce54>
    2811:	00 3d 37 ce 10 00    	add    %bh,0x10ce37(%rip)        # 10f64e <_license+0x10d75b>
    2817:	00 3c 59             	add    %bh,(%rcx,%rbx,2)
    281a:	11 00                	adc    %eax,(%rax)
    281c:	00 16                	add    %dl,(%rsi)
    281e:	0b 5a 01             	or     0x1(%rdx),%ebx
    2821:	0c 3d                	or     $0x3d,%al
    2823:	2d 61 11 00 00       	sub    $0x1161,%eax
    2828:	3d 2e 69 11 00       	cmp    $0x11692e,%eax
    282d:	00 3d 57 71 11 00    	add    %bh,0x117157(%rip)        # 11998a <_license+0x117a97>
    2833:	00 3d 2f 79 11 00    	add    %bh,0x11792f(%rip)        # 11a168 <_license+0x118275>
    2839:	00 3f                	add    %bh,(%rdi)
    283b:	30 81 11 00 00 3f    	xor    %al,0x3f000011(%rcx)
    2841:	58                   	pop    %rax
    2842:	89 11                	mov    %edx,(%rcx)
    2844:	00 00                	add    %al,(%rax)
    2846:	44                   	rex.R
    2847:	4d                   	rex.WRB
    2848:	3e 00 00             	ds add %al,(%rax)
    284b:	00 3f                	add    %bh,(%rdi)
    284d:	53                   	push   %rbx
    284e:	92                   	xchg   %eax,%edx
    284f:	11 00                	adc    %eax,(%rax)
    2851:	00 3f                	add    %bh,(%rdi)
    2853:	55                   	push   %rbp
    2854:	9a                   	(bad)
    2855:	11 00                	adc    %eax,(%rax)
    2857:	00 3f                	add    %bh,(%rdi)
    2859:	56                   	push   %rsi
    285a:	a2 11 00 00 44 4e 17 	movabs %al,0x174e44000011
    2861:	00 00 
    2863:	00 3f                	add    %bh,(%rdi)
    2865:	54                   	push   %rsp
    2866:	ab                   	stos   %eax,%es:(%rdi)
    2867:	11 00                	adc    %eax,(%rax)
    2869:	00 44 4e 17          	add    %al,0x17(%rsi,%rcx,2)
    286d:	00 00                	add    %al,(%rax)
    286f:	00 45 06             	add    %al,0x6(%rbp)
    2872:	b4 11                	mov    $0x11,%ah
    2874:	00 00                	add    %al,(%rax)
    2876:	00 00                	add    %al,(%rax)
    2878:	00 00                	add    %al,(%rax)
    287a:	3c 9c                	cmp    $0x9c,%al
    287c:	0f 00 00             	sldt   (%rax)
    287f:	17                   	(bad)
    2880:	0b 5c 01 0c          	or     0xc(%rcx,%rax,1),%ebx
    2884:	3d 38 a5 0f 00       	cmp    $0xfa538,%eax
    2889:	00 3d 39 ae 0f 00    	add    %bh,0xfae39(%rip)        # fd6c8 <_license+0xfb7d5>
    288f:	00 3d 3a b7 0f 00    	add    %bh,0xfb73a(%rip)        # fdfcf <_license+0xfc0dc>
    2895:	00 3d 3b c0 0f 00    	add    %bh,0xfc03b(%rip)        # fe8d6 <_license+0xfc9e3>
    289b:	00 3f                	add    %bh,(%rdi)
    289d:	3c c9                	cmp    $0xc9,%al
    289f:	0f 00 00             	sldt   (%rax)
    28a2:	3f                   	(bad)
    28a3:	6f                   	outsl  %ds:(%rsi),(%dx)
    28a4:	d2 0f                	rorb   %cl,(%rdi)
    28a6:	00 00                	add    %al,(%rax)
    28a8:	40 d8 10             	rex fcoms (%rax)
    28ab:	00 00                	add    %al,(%rax)
    28ad:	4f 88 00             	rex.WRXB mov %r8b,(%r8)
    28b0:	00 00                	add    %al,(%rax)
    28b2:	0b 1f                	or     (%rdi),%ebx
    28b4:	01 0c 41             	add    %ecx,(%rcx,%rax,2)
    28b7:	01 5e e0             	add    %ebx,-0x20(%rsi)
    28ba:	10 00                	adc    %al,(%rax)
    28bc:	00 41 01             	add    %al,0x1(%rcx)
    28bf:	5c                   	pop    %rsp
    28c0:	e8 10 00 00 3f       	call   3f0028d5 <_license+0x3f0009e2>
    28c5:	3d f0 10 00 00       	cmp    $0x10f0,%eax
    28ca:	42 00 f8             	rex.X add %dil,%al
    28cd:	10 00                	adc    %al,(%rax)
    28cf:	00 3f                	add    %bh,(%rdi)
    28d1:	3e 00 11             	ds add %dl,(%rcx)
    28d4:	00 00                	add    %al,(%rax)
    28d6:	3f                   	(bad)
    28d7:	3f                   	(bad)
    28d8:	08 11                	or     %dl,(%rcx)
    28da:	00 00                	add    %al,(%rax)
    28dc:	43 19 11             	rex.XB sbb %edx,(%r9)
    28df:	00 00                	add    %al,(%rax)
    28e1:	50                   	push   %rax
    28e2:	56                   	push   %rsi
    28e3:	00 00                	add    %al,(%rax)
    28e5:	00 0b                	add    %cl,(%rbx)
    28e7:	59                   	pop    %rcx
    28e8:	03 3f                	add    (%rdi),%edi
    28ea:	41 2d 11 00 00 44    	rex.B sub $0x44000011,%eax
    28f0:	50                   	push   %rax
    28f1:	3f                   	(bad)
    28f2:	00 00                	add    %al,(%rax)
    28f4:	00 3f                	add    %bh,(%rdi)
    28f6:	40                   	rex
    28f7:	36 11 00             	ss adc %eax,(%rax)
    28fa:	00 00                	add    %al,(%rax)
    28fc:	43                   	rex.XB
    28fd:	40 11 00             	rex adc %eax,(%rax)
    2900:	00 51 17             	add    %dl,0x17(%rcx)
    2903:	00 00                	add    %al,(%rax)
    2905:	00 0c 3a             	add    %cl,(%rdx,%rdi,1)
    2908:	0b 41 01             	or     0x1(%rcx),%eax
    290b:	50                   	push   %rax
    290c:	48 11 00             	adc    %rax,(%rax)
    290f:	00 3f                	add    %bh,(%rdi)
    2911:	42 50                	rex.X push %rax
    2913:	11 00                	adc    %eax,(%rax)
    2915:	00 00                	add    %al,(%rax)
    2917:	00 00                	add    %al,(%rax)
    2919:	44 52                	rex.R push %rdx
    291b:	37                   	(bad)
    291c:	00 00                	add    %al,(%rax)
    291e:	00 3f                	add    %bh,(%rdi)
    2920:	6c                   	insb   (%dx),%es:(%rdi)
    2921:	dc 0f                	fmull  (%rdi)
    2923:	00 00                	add    %al,(%rax)
    2925:	3f                   	(bad)
    2926:	6e                   	outsb  %ds:(%rsi),(%dx)
    2927:	e5 0f                	in     $0xf,%eax
    2929:	00 00                	add    %al,(%rax)
    292b:	44 53                	rex.R push %rbx
    292d:	17                   	(bad)
    292e:	00 00                	add    %al,(%rax)
    2930:	00 3f                	add    %bh,(%rdi)
    2932:	6d                   	insl   (%dx),%es:(%rdi)
    2933:	f8                   	clc
    2934:	0f 00 00             	sldt   (%rax)
    2937:	44 53                	rex.R push %rbx
    2939:	17                   	(bad)
    293a:	00 00                	add    %al,(%rax)
    293c:	00 45 06             	add    %al,0x6(%rbp)
    293f:	02 10                	add    (%rax),%dl
    2941:	00 00                	add    %al,(%rax)
    2943:	00 00                	add    %al,(%rax)
    2945:	00 00                	add    %al,(%rax)
    2947:	00 40 f0             	add    %al,-0x10(%rax)
    294a:	12 00                	adc    (%rax),%al
    294c:	00 54 28 00          	add    %dl,0x0(%rax,%rbp,1)
    2950:	00 00                	add    %al,(%rax)
    2952:	00 f3                	add    %dh,%bl
    2954:	02 0a                	add    (%rdx),%cl
    2956:	41 01 5e f9          	add    %ebx,-0x7(%r14)
    295a:	12 00                	adc    (%rax),%al
    295c:	00 41 01             	add    %al,0x1(%rcx)
    295f:	5c                   	pop    %rsp
    2960:	01 13                	add    %edx,(%rbx)
    2962:	00 00                	add    %al,(%rax)
    2964:	41 02 31             	add    (%r9),%sil
    2967:	9f                   	lahf
    2968:	09 13                	or     %edx,(%rbx)
    296a:	00 00                	add    %al,(%rax)
    296c:	41 04 91             	rex.B add $0x91,%al
    296f:	80 7f 9f 11          	cmpb   $0x11,-0x61(%rdi)
    2973:	13 00                	adc    (%rax),%eax
    2975:	00 3f                	add    %bh,(%rdi)
    2977:	44 19 13             	sbb    %r10d,(%rbx)
    297a:	00 00                	add    %al,(%rax)
    297c:	00 40 4d             	add    %al,0x4d(%rax)
    297f:	14 00                	adc    $0x0,%al
    2981:	00 55 18             	add    %dl,0x18(%rbp)
    2984:	00 00                	add    %al,(%rax)
    2986:	00 00                	add    %al,(%rax)
    2988:	f7 02 0a 41 01 5e    	testl  $0x5e01410a,(%rdx)
    298e:	56                   	push   %rsi
    298f:	14 00                	adc    $0x0,%al
    2991:	00 41 01             	add    %al,0x1(%rcx)
    2994:	5c                   	pop    %rsp
    2995:	5e                   	pop    %rsi
    2996:	14 00                	adc    $0x0,%al
    2998:	00 41 02             	add    %al,0x2(%rcx)
    299b:	31 9f 66 14 00 00    	xor    %ebx,0x1466(%rdi)
    29a1:	41 04 91             	rex.B add $0x91,%al
    29a4:	80 7f 9f 6e          	cmpb   $0x6e,-0x61(%rdi)
    29a8:	14 00                	adc    $0x0,%al
    29aa:	00 3f                	add    %bh,(%rdi)
    29ac:	51                   	push   %rcx
    29ad:	76 14                	jbe    29c3 <_license+0xad0>
    29af:	00 00                	add    %al,(%rax)
    29b1:	00 44 56 1a          	add    %al,0x1a(%rsi,%rdx,2)
    29b5:	00 00                	add    %al,(%rax)
    29b7:	00 3f                	add    %bh,(%rdi)
    29b9:	59                   	pop    %rcx
    29ba:	a8 0a                	test   $0xa,%al
    29bc:	00 00                	add    %al,(%rax)
    29be:	44 56                	rex.R push %rsi
    29c0:	1a 00                	sbb    (%rax),%al
    29c2:	00 00                	add    %al,(%rax)
    29c4:	45 01 b2 0a 00 00 00 	add    %r14d,0xa(%r10)
    29cb:	00 44 57 1a          	add    %al,0x1a(%rdi,%rdx,2)
    29cf:	00 00                	add    %al,(%rax)
    29d1:	00 3f                	add    %bh,(%rdi)
    29d3:	70 be                	jo     2993 <_license+0xaa0>
    29d5:	0a 00                	or     (%rax),%al
    29d7:	00 44 57 1a          	add    %al,0x1a(%rdi,%rdx,2)
    29db:	00 00                	add    %al,(%rax)
    29dd:	00 45 01             	add    %al,0x1(%rbp)
    29e0:	c8 0a 00 00          	enter  $0xa,$0x0
    29e4:	00 00                	add    %al,(%rax)
    29e6:	44 58                	rex.R pop %rax
    29e8:	1a 00                	sbb    (%rax),%al
    29ea:	00 00                	add    %al,(%rax)
    29ec:	3f                   	(bad)
    29ed:	5c                   	pop    %rsp
    29ee:	d4                   	(bad)
    29ef:	0a 00                	or     (%rax),%al
    29f1:	00 44 58 1a          	add    %al,0x1a(%rax,%rbx,2)
    29f5:	00 00                	add    %al,(%rax)
    29f7:	00 45 06             	add    %al,0x6(%rbp)
    29fa:	de 0a                	fimuls (%rdx)
    29fc:	00 00                	add    %al,(%rax)
    29fe:	00 00                	add    %al,(%rax)
    2a00:	44 59                	rex.R pop %rcx
    2a02:	21 00                	and    %eax,(%rax)
    2a04:	00 00                	add    %al,(%rax)
    2a06:	3f                   	(bad)
    2a07:	60                   	(bad)
    2a08:	ea                   	(bad)
    2a09:	0a 00                	or     (%rax),%al
    2a0b:	00 44 59 21          	add    %al,0x21(%rcx,%rbx,2)
    2a0f:	00 00                	add    %al,(%rax)
    2a11:	00 45 0c             	add    %al,0xc(%rbp)
    2a14:	f4                   	hlt
    2a15:	0a 00                	or     (%rax),%al
    2a17:	00 00                	add    %al,(%rax)
    2a19:	00 44 5a 40          	add    %al,0x40(%rdx,%rbx,2)
    2a1d:	00 00                	add    %al,(%rax)
    2a1f:	00 3f                	add    %bh,(%rdi)
    2a21:	62                   	(bad)
    2a22:	00 0b                	add    %cl,(%rbx)
    2a24:	00 00                	add    %al,(%rax)
    2a26:	3f                   	(bad)
    2a27:	64 09 0b             	or     %ecx,%fs:(%rbx)
    2a2a:	00 00                	add    %al,(%rax)
    2a2c:	44 5b                	rex.R pop %rbx
    2a2e:	17                   	(bad)
    2a2f:	00 00                	add    %al,(%rax)
    2a31:	00 3f                	add    %bh,(%rdi)
    2a33:	63 13                	movsxd (%rbx),%edx
    2a35:	0b 00                	or     (%rax),%eax
    2a37:	00 44 5b 17          	add    %al,0x17(%rbx,%rbx,2)
    2a3b:	00 00                	add    %al,(%rax)
    2a3d:	00 45 06             	add    %al,0x6(%rbp)
    2a40:	1d 0b 00 00 00       	sbb    $0xb,%eax
    2a45:	00 00                	add    %al,(%rax)
    2a47:	46 18 3f             	rex.RX sbb %r15b,(%rdi)
    2a4a:	65 34 0b             	gs xor $0xb,%al
    2a4d:	00 00                	add    %al,(%rax)
    2a4f:	3f                   	(bad)
    2a50:	67 3d 0b 00 00 3f    	addr32 cmp $0x3f00000b,%eax
    2a56:	e8 01 46 0b 00       	call   b705c <_license+0xb5169>
    2a5b:	00 44 5c 17          	add    %al,0x17(%rsp,%rbx,2)
    2a5f:	00 00                	add    %al,(%rax)
    2a61:	00 3f                	add    %bh,(%rdi)
    2a63:	66 50                	push   %ax
    2a65:	0b 00                	or     (%rax),%eax
    2a67:	00 44 5c 17          	add    %al,0x17(%rsp,%rbx,2)
    2a6b:	00 00                	add    %al,(%rax)
    2a6d:	00 45 06             	add    %al,0x6(%rbp)
    2a70:	5a                   	pop    %rdx
    2a71:	0b 00                	or     (%rax),%eax
    2a73:	00 00                	add    %al,(%rax)
    2a75:	00 3c c3             	add    %bh,(%rbx,%rax,8)
    2a78:	14 00                	adc    $0x0,%al
    2a7a:	00 19                	add    %bl,(%rcx)
    2a7c:	00 6f 03             	add    %ch,0x3(%rdi)
    2a7f:	26 3d 68 cd 14 00    	es cmp $0x14cd68,%eax
    2a85:	00 3d 69 d6 14 00    	add    %bh,0x14d669(%rip)        # 1500f4 <_license+0x14e201>
    2a8b:	00 3d 6a df 14 00    	add    %bh,0x14df6a(%rip)        # 1509fb <_license+0x14eb08>
    2a91:	00 3f                	add    %bh,(%rdi)
    2a93:	6b f1 14             	imul   $0x14,%ecx,%esi
    2a96:	00 00                	add    %al,(%rax)
    2a98:	3f                   	(bad)
    2a99:	9a                   	(bad)
    2a9a:	01 fb                	add    %edi,%ebx
    2a9c:	14 00                	adc    $0x0,%al
    2a9e:	00 3f                	add    %bh,(%rdi)
    2aa0:	9b                   	fwait
    2aa1:	01 05 15 00 00 3f    	add    %eax,0x3f000015(%rip)        # 3f002abc <_license+0x3f000bc9>
    2aa7:	9c                   	pushf
    2aa8:	01 0f                	add    %ecx,(%rdi)
    2aaa:	15 00 00 3f 9d       	adc    $0x9d3f0000,%eax
    2aaf:	01 19                	add    %ebx,(%rcx)
    2ab1:	15 00 00 46 1a       	adc    $0x1a460000,%eax
    2ab6:	3f                   	(bad)
    2ab7:	e7 01                	out    %eax,$0x1
    2ab9:	36 15 00 00 00 00    	ss adc $0x0,%eax
    2abf:	40 01 16             	rex add %edx,(%rsi)
    2ac2:	00 00                	add    %al,(%rax)
    2ac4:	5d                   	pop    %rbp
    2ac5:	20 00                	and    %al,(%rax)
    2ac7:	00 00                	add    %al,(%rax)
    2ac9:	00 a1 03 09 41 02    	add    %ah,0x2410903(%rcx)
    2acf:	91                   	xchg   %eax,%ecx
    2ad0:	40 07                	rex (bad)
    2ad2:	16                   	(bad)
    2ad3:	00 00                	add    %al,(%rax)
    2ad5:	41 02 31             	add    (%r9),%sil
    2ad8:	9f                   	lahf
    2ad9:	10 16                	adc    %dl,(%rsi)
    2adb:	00 00                	add    %al,(%rax)
    2add:	41 02 30             	add    (%r8),%sil
    2ae0:	9f                   	lahf
    2ae1:	1a 16                	sbb    (%rsi),%dl
    2ae3:	00 00                	add    %al,(%rax)
    2ae5:	3f                   	(bad)
    2ae6:	a2 01 24 16 00 00 44 	movabs %al,0x175d440000162401
    2aed:	5d 17 
    2aef:	00 00                	add    %al,(%rax)
    2af1:	00 3f                	add    %bh,(%rdi)
    2af3:	a1 01 2f 16 00 00 44 	movabs 0x175d440000162f01,%eax
    2afa:	5d 17 
    2afc:	00 00                	add    %al,(%rax)
    2afe:	00 45 06             	add    %al,0x6(%rbp)
    2b01:	39 16                	cmp    %edx,(%rsi)
    2b03:	00 00                	add    %al,(%rax)
    2b05:	00 00                	add    %al,(%rax)
    2b07:	00 46 1b             	add    %al,0x1b(%rsi)
    2b0a:	3f                   	(bad)
    2b0b:	ed                   	in     (%dx),%eax
    2b0c:	01 66 0b             	add    %esp,0xb(%rsi)
    2b0f:	00 00                	add    %al,(%rax)
    2b11:	3c 55                	cmp    $0x55,%al
    2b13:	1b 00                	sbb    (%rax),%eax
    2b15:	00 1c 00             	add    %bl,(%rax,%rax,1)
    2b18:	73 03                	jae    2b1d <_license+0xc2a>
    2b1a:	09 3d e9 01 5b 1b    	or     %edi,0x1b5b01e9(%rip)        # 1b5b2d09 <_license+0x1b5b0e16>
    2b20:	00 00                	add    %al,(%rax)
    2b22:	3d ea 01 64 1b       	cmp    $0x1b6401ea,%eax
    2b27:	00 00                	add    %al,(%rax)
    2b29:	00 44 5e 06          	add    %al,0x6(%rsi,%rbx,2)
    2b2d:	00 00                	add    %al,(%rax)
    2b2f:	00 3f                	add    %bh,(%rdi)
    2b31:	ee                   	out    %al,(%dx)
    2b32:	01 79 0b             	add    %edi,0xb(%rcx)
    2b35:	00 00                	add    %al,(%rax)
    2b37:	44 5e                	rex.R pop %rsi
    2b39:	06                   	(bad)
    2b3a:	00 00                	add    %al,(%rax)
    2b3c:	00 45 02             	add    %al,0x2(%rbp)
    2b3f:	83 0b 00             	orl    $0x0,(%rbx)
    2b42:	00 44 5e 06          	add    %al,0x6(%rsi,%rbx,2)
    2b46:	00 00                	add    %al,(%rax)
    2b48:	00 3e                	add    %bh,(%rsi)
    2b4a:	01 55 8d             	add    %edx,-0x73(%rbp)
    2b4d:	0b 00                	or     (%rax),%eax
    2b4f:	00 42 fe             	add    %al,-0x2(%rdx)
    2b52:	ff                   	(bad)
    2b53:	ff 07                	incl   (%rdi)
    2b55:	96                   	xchg   %eax,%esi
    2b56:	0b 00                	or     (%rax),%eax
    2b58:	00 42 04             	add    %al,0x4(%rdx)
    2b5b:	9f                   	lahf
    2b5c:	0b 00                	or     (%rax),%eax
    2b5e:	00 00                	add    %al,(%rax)
    2b60:	00 00                	add    %al,(%rax)
    2b62:	46 1d 3f f4 01 ac    	rex.RX sbb $0xac01f43f,%eax
    2b68:	0b 00                	or     (%rax),%eax
    2b6a:	00 44 5f 20          	add    %al,0x20(%rdi,%rbx,2)
    2b6e:	00 00                	add    %al,(%rax)
    2b70:	00 3f                	add    %bh,(%rdi)
    2b72:	ef                   	out    %eax,(%dx)
    2b73:	01 b6 0b 00 00 44    	add    %esi,0x4400000b(%rsi)
    2b79:	5f                   	pop    %rdi
    2b7a:	20 00                	and    %al,(%rax)
    2b7c:	00 00                	add    %al,(%rax)
    2b7e:	45 02 c0             	add    %r8b,%r8b
    2b81:	0b 00                	or     (%rax),%eax
    2b83:	00 44 5f 20          	add    %al,0x20(%rdi,%rbx,2)
    2b87:	00 00                	add    %al,(%rax)
    2b89:	00 3f                	add    %bh,(%rdi)
    2b8b:	f0 01 ca             	lock add %ecx,%edx
    2b8e:	0b 00                	or     (%rax),%eax
    2b90:	00 42 80             	add    %al,-0x80(%rdx)
    2b93:	20 d3                	and    %dl,%bl
    2b95:	0b 00                	or     (%rax),%eax
    2b97:	00 42 14             	add    %al,0x14(%rdx)
    2b9a:	dc 0b                	fmull  (%rbx)
    2b9c:	00 00                	add    %al,(%rax)
    2b9e:	00 00                	add    %al,(%rax)
    2ba0:	00 3c 6e             	add    %bh,(%rsi,%rbp,2)
    2ba3:	1b 00                	sbb    (%rax),%eax
    2ba5:	00 1e                	add    %bl,(%rsi)
    2ba7:	00 89 03 17 3d f1    	add    %cl,-0xec2e8fd(%rcx)
    2bad:	01 78 1b             	add    %edi,0x1b(%rax)
    2bb0:	00 00                	add    %al,(%rax)
    2bb2:	3d f2 01 81 1b       	cmp    $0x1b8101f2,%eax
    2bb7:	00 00                	add    %al,(%rax)
    2bb9:	3e 02 91 40 8a 1b 00 	ds add 0x1b8a40(%rcx),%dl
    2bc0:	00 3f                	add    %bh,(%rdi)
    2bc2:	f3 01 94 1b 00 00 3c 	repz add %edx,-0x23c40000(%rbx,%rbx,1)
    2bc9:	dc 
    2bca:	16                   	(bad)
    2bcb:	00 00                	add    %al,(%rax)
    2bcd:	1f                   	(bad)
    2bce:	00 74 02 07          	add    %dh,0x7(%rdx,%rax,1)
    2bd2:	3f                   	(bad)
    2bd3:	f8                   	clc
    2bd4:	01 ee                	add    %ebp,%esi
    2bd6:	16                   	(bad)
    2bd7:	00 00                	add    %al,(%rax)
    2bd9:	3f                   	(bad)
    2bda:	fa                   	cli
    2bdb:	01 f7                	add    %esi,%edi
    2bdd:	16                   	(bad)
    2bde:	00 00                	add    %al,(%rax)
    2be0:	44 60                	rex.R (bad)
    2be2:	11 00                	adc    %eax,(%rax)
    2be4:	00 00                	add    %al,(%rax)
    2be6:	3f                   	(bad)
    2be7:	f9                   	stc
    2be8:	01 01                	add    %eax,(%rcx)
    2bea:	17                   	(bad)
    2beb:	00 00                	add    %al,(%rax)
    2bed:	44 60                	rex.R (bad)
    2bef:	11 00                	adc    %eax,(%rax)
    2bf1:	00 00                	add    %al,(%rax)
    2bf3:	45 06                	rex.RB (bad)
    2bf5:	0a 17                	or     (%rdi),%dl
    2bf7:	00 00                	add    %al,(%rax)
    2bf9:	00 00                	add    %al,(%rax)
    2bfb:	00 00                	add    %al,(%rax)
    2bfd:	40 01 16             	rex add %edx,(%rsi)
    2c00:	00 00                	add    %al,(%rax)
    2c02:	61                   	(bad)
    2c03:	23 00                	and    (%rax),%eax
    2c05:	00 00                	add    %al,(%rax)
    2c07:	00 8e 03 0f 41 02    	add    %cl,0x2410f03(%rsi)
    2c0d:	91                   	xchg   %eax,%ecx
    2c0e:	40 07                	rex (bad)
    2c10:	16                   	(bad)
    2c11:	00 00                	add    %al,(%rax)
    2c13:	41 02 30             	add    (%r8),%sil
    2c16:	9f                   	lahf
    2c17:	10 16                	adc    %dl,(%rsi)
    2c19:	00 00                	add    %al,(%rax)
    2c1b:	41 02 31             	add    (%r9),%sil
    2c1e:	9f                   	lahf
    2c1f:	1a 16                	sbb    (%rsi),%dl
    2c21:	00 00                	add    %al,(%rax)
    2c23:	3f                   	(bad)
    2c24:	ca 02 24             	lret   $0x2402
    2c27:	16                   	(bad)
    2c28:	00 00                	add    %al,(%rax)
    2c2a:	44 61                	rex.R (bad)
    2c2c:	17                   	(bad)
    2c2d:	00 00                	add    %al,(%rax)
    2c2f:	00 3f                	add    %bh,(%rdi)
    2c31:	c9                   	leave
    2c32:	02 2f                	add    (%rdi),%ch
    2c34:	16                   	(bad)
    2c35:	00 00                	add    %al,(%rax)
    2c37:	44 61                	rex.R (bad)
    2c39:	17                   	(bad)
    2c3a:	00 00                	add    %al,(%rax)
    2c3c:	00 45 06             	add    %al,0x6(%rbp)
    2c3f:	39 16                	cmp    %edx,(%rsi)
	...
    2c49:	44 62                	rex.R (bad)
    2c4b:	40 00 00             	rex add %al,(%rax)
    2c4e:	00 3f                	add    %bh,(%rdi)
    2c50:	92                   	xchg   %eax,%edx
    2c51:	01 ec                	add    %ebp,%esp
    2c53:	0b 00                	or     (%rax),%eax
    2c55:	00 3f                	add    %bh,(%rdi)
    2c57:	94                   	xchg   %eax,%esp
    2c58:	01 f5                	add    %esi,%ebp
    2c5a:	0b 00                	or     (%rax),%eax
    2c5c:	00 44 63 17          	add    %al,0x17(%rbx,%riz,2)
    2c60:	00 00                	add    %al,(%rax)
    2c62:	00 3f                	add    %bh,(%rdi)
    2c64:	93                   	xchg   %eax,%ebx
    2c65:	01 ff                	add    %edi,%edi
    2c67:	0b 00                	or     (%rax),%eax
    2c69:	00 44 63 17          	add    %al,0x17(%rbx,%riz,2)
    2c6d:	00 00                	add    %al,(%rax)
    2c6f:	00 45 06             	add    %al,0x6(%rbp)
    2c72:	09 0c 00             	or     %ecx,(%rax,%rax,1)
    2c75:	00 00                	add    %al,(%rax)
    2c77:	00 40 42             	add    %al,0x42(%rax)
    2c7a:	15 00 00 64 0e       	adc    $0xe640000,%eax
    2c7f:	00 00                	add    %al,(%rax)
    2c81:	00 00                	add    %al,(%rax)
    2c83:	65 03 0b             	add    %gs:(%rbx),%ecx
    2c86:	41 01 5e 4c          	add    %ebx,0x4c(%r14)
    2c8a:	15 00 00 41 02       	adc    $0x2410000,%eax
    2c8f:	31 9f 5e 15 00 00    	xor    %ebx,0x155e(%rdi)
    2c95:	42 0e                	rex.X (bad)
    2c97:	67 15 00 00 44 64    	addr32 adc $0x64440000,%eax
    2c9d:	0e                   	(bad)
    2c9e:	00 00                	add    %al,(%rax)
    2ca0:	00 3e                	add    %bh,(%rsi)
    2ca2:	03 7e 36             	add    0x36(%rsi),%edi
    2ca5:	9f                   	lahf
    2ca6:	71 15                	jno    2cbd <_license+0xdca>
    2ca8:	00 00                	add    %al,(%rax)
    2caa:	00 00                	add    %al,(%rax)
    2cac:	00 3c 87             	add    %bh,(%rdi,%rax,4)
    2caf:	15 00 00 20 00       	adc    $0x200000,%eax
    2cb4:	d7                   	xlat   %ds:(%rbx)
    2cb5:	03 07                	add    (%rdi),%eax
    2cb7:	3d 95 01 95 15       	cmp    $0x15950195,%eax
    2cbc:	00 00                	add    %al,(%rax)
    2cbe:	3d 96 01 9d 15       	cmp    $0x159d0196,%eax
    2cc3:	00 00                	add    %al,(%rax)
    2cc5:	3d 97 01 a5 15       	cmp    $0x15a50197,%eax
    2cca:	00 00                	add    %al,(%rax)
    2ccc:	3f                   	(bad)
    2ccd:	98                   	cwtl
    2cce:	01 ae 15 00 00 3f    	add    %ebp,0x3f000015(%rsi)
    2cd4:	99                   	cltd
    2cd5:	01 b7 15 00 00 3f    	add    %esi,0x3f000015(%rdi)
    2cdb:	a3 01 c0 15 00 00 44 	movabs %eax,0x1a6544000015c001
    2ce2:	65 1a 
    2ce4:	00 00                	add    %al,(%rax)
    2ce6:	00 3f                	add    %bh,(%rdi)
    2ce8:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2ce9:	01 c9                	add    %ecx,%ecx
    2ceb:	15 00 00 44 65       	adc    $0x65440000,%eax
    2cf0:	1a 00                	sbb    (%rax),%al
    2cf2:	00 00                	add    %al,(%rax)
    2cf4:	45 02 d2             	add    %r10b,%r10b
    2cf7:	15 00 00 44 65       	adc    $0x65440000,%eax
    2cfc:	1a 00                	sbb    (%rax),%al
    2cfe:	00 00                	add    %al,(%rax)
    2d00:	3f                   	(bad)
    2d01:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    2d02:	01 db                	add    %ebx,%ebx
    2d04:	15 00 00 42 80       	adc    $0x80420000,%eax
    2d09:	20 e3                	and    %ah,%bl
    2d0b:	15 00 00 42 14       	adc    $0x14420000,%eax
    2d10:	eb 15                	jmp    2d27 <_license+0xe34>
    2d12:	00 00                	add    %al,(%rax)
    2d14:	00 00                	add    %al,(%rax)
    2d16:	00 00                	add    %al,(%rax)
    2d18:	40                   	rex
    2d19:	45 16                	rex.RB (bad)
    2d1b:	00 00                	add    %al,(%rax)
    2d1d:	66 d3 00             	rolw   %cl,(%rax)
    2d20:	00 00                	add    %al,(%rax)
    2d22:	00 e4                	add    %ah,%ah
    2d24:	03 05 41 04 91 80    	add    -0x7f6efbbf(%rip),%eax        # ffffffff8091316b <server_id_map+0x36fc4012f16b>
    2d2a:	7f 9f                	jg     2ccb <_license+0xdd8>
    2d2c:	58                   	pop    %rax
    2d2d:	16                   	(bad)
    2d2e:	00 00                	add    %al,(%rax)
    2d30:	3d a6 01 61 16       	cmp    $0x166101a6,%eax
    2d35:	00 00                	add    %al,(%rax)
    2d37:	41 04 91             	rex.B add $0x91,%al
    2d3a:	d8 7e 9f             	fdivrs -0x61(%rsi)
    2d3d:	6a 16                	push   $0x16
    2d3f:	00 00                	add    %al,(%rax)
    2d41:	40 dc 16             	rex fcoml (%rsi)
    2d44:	00 00                	add    %al,(%rax)
    2d46:	67 62                	addr32 (bad)
    2d48:	00 00                	add    %al,(%rax)
    2d4a:	00 00                	add    %al,(%rax)
    2d4c:	93                   	xchg   %eax,%ebx
    2d4d:	02 32                	add    (%rdx),%dh
    2d4f:	3f                   	(bad)
    2d50:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    2d51:	01 ee                	add    %ebp,%esi
    2d53:	16                   	(bad)
    2d54:	00 00                	add    %al,(%rax)
    2d56:	3f                   	(bad)
    2d57:	a9 01 f7 16 00       	test   $0x16f701,%eax
    2d5c:	00 44 68 17          	add    %al,0x17(%rax,%rbp,2)
    2d60:	00 00                	add    %al,(%rax)
    2d62:	00 3f                	add    %bh,(%rdi)
    2d64:	a8 01                	test   $0x1,%al
    2d66:	01 17                	add    %edx,(%rdi)
    2d68:	00 00                	add    %al,(%rax)
    2d6a:	44 68 17 00 00 00    	rex.R push $0x17
    2d70:	45 06                	rex.RB (bad)
    2d72:	0a 17                	or     (%rdi),%dl
    2d74:	00 00                	add    %al,(%rax)
    2d76:	00 00                	add    %al,(%rax)
    2d78:	00 44 69 5d          	add    %al,0x5d(%rcx,%rbp,2)
    2d7c:	00 00                	add    %al,(%rax)
    2d7e:	00 3f                	add    %bh,(%rdi)
    2d80:	ab                   	stos   %eax,%es:(%rdi)
    2d81:	01 7e 16             	add    %edi,0x16(%rsi)
    2d84:	00 00                	add    %al,(%rax)
    2d86:	44 69 1a 00 00 00 3f 	imul   $0x3f000000,(%rdx),%r11d
    2d8d:	aa                   	stos   %al,%es:(%rdi)
    2d8e:	01 89 16 00 00 44    	add    %ecx,0x44000016(%rcx)
    2d94:	69 1a 00 00 00 45    	imul   $0x45000000,(%rdx),%ebx
    2d9a:	0d 93 16 00 00       	or     $0x1693,%eax
    2d9f:	00 00                	add    %al,(%rax)
    2da1:	44 6a 3e             	rex.R push $0x3e
    2da4:	00 00                	add    %al,(%rax)
    2da6:	00 3f                	add    %bh,(%rdi)
    2da8:	ac                   	lods   %ds:(%rsi),%al
    2da9:	01 9f 16 00 00 44    	add    %ebx,0x44000016(%rdi)
    2daf:	6b 30 00             	imul   $0x0,(%rax),%esi
    2db2:	00 00                	add    %al,(%rax)
    2db4:	3f                   	(bad)
    2db5:	ad                   	lods   %ds:(%rsi),%eax
    2db6:	01 aa 16 00 00 3f    	add    %ebp,0x3f000016(%rdx)
    2dbc:	af                   	scas   %es:(%rdi),%eax
    2dbd:	01 b3 16 00 00 44    	add    %esi,0x44000016(%rbx)
    2dc3:	6c                   	insb   (%dx),%es:(%rdi)
    2dc4:	17                   	(bad)
    2dc5:	00 00                	add    %al,(%rax)
    2dc7:	00 3f                	add    %bh,(%rdi)
    2dc9:	ae                   	scas   %es:(%rdi),%al
    2dca:	01 be 16 00 00 44    	add    %edi,0x44000016(%rsi)
    2dd0:	6c                   	insb   (%dx),%es:(%rdi)
    2dd1:	17                   	(bad)
    2dd2:	00 00                	add    %al,(%rax)
    2dd4:	00 45 06             	add    %al,0x6(%rbp)
    2dd7:	c8 16 00 00          	enter  $0x16,$0x0
    2ddb:	00 00                	add    %al,(%rax)
    2ddd:	00 00                	add    %al,(%rax)
    2ddf:	00 00                	add    %al,(%rax)
    2de1:	44 6d                	rex.R insl (%dx),%es:(%rdi)
    2de3:	37                   	(bad)
    2de4:	00 00                	add    %al,(%rax)
    2de6:	00 3f                	add    %bh,(%rdi)
    2de8:	bc 01 17 0c 00       	mov    $0xc1701,%esp
    2ded:	00 3f                	add    %bh,(%rdi)
    2def:	be 01 20 0c 00       	mov    $0xc2001,%esi
    2df4:	00 44 6e 17          	add    %al,0x17(%rsi,%rbp,2)
    2df8:	00 00                	add    %al,(%rax)
    2dfa:	00 3f                	add    %bh,(%rdi)
    2dfc:	bd 01 2a 0c 00       	mov    $0xc2a01,%ebp
    2e01:	00 44 6e 17          	add    %al,0x17(%rsi,%rbp,2)
    2e05:	00 00                	add    %al,(%rax)
    2e07:	00 45 06             	add    %al,0x6(%rbp)
    2e0a:	34 0c                	xor    $0xc,%al
    2e0c:	00 00                	add    %al,(%rax)
    2e0e:	00 00                	add    %al,(%rax)
    2e10:	00 3c f6             	add    %bh,(%rsi,%rsi,8)
    2e13:	17                   	(bad)
    2e14:	00 00                	add    %al,(%rax)
    2e16:	21 00                	and    %eax,(%rax)
    2e18:	fa                   	cli
    2e19:	03 0c 3d bf 01 08 18 	add    0x180801bf(,%rdi,1),%ecx
    2e20:	00 00                	add    %al,(%rax)
    2e22:	3d c0 01 10 18       	cmp    $0x181001c0,%eax
    2e27:	00 00                	add    %al,(%rax)
    2e29:	3d c1 01 18 18       	cmp    $0x181801c1,%eax
    2e2e:	00 00                	add    %al,(%rax)
    2e30:	3d c2 01 20 18       	cmp    $0x182001c2,%eax
    2e35:	00 00                	add    %al,(%rax)
    2e37:	3e 02 91 40 28 18 00 	ds add 0x182840(%rcx),%dl
    2e3e:	00 3f                	add    %bh,(%rdi)
    2e40:	c3                   	ret
    2e41:	01 31                	add    %esi,(%rcx)
    2e43:	18 00                	sbb    %al,(%rax)
    2e45:	00 3f                	add    %bh,(%rdi)
    2e47:	c4 01 3a 18          	(bad)
    2e4b:	00 00                	add    %al,(%rax)
    2e4d:	3f                   	(bad)
    2e4e:	c5 01 43             	(bad)
    2e51:	18 00                	sbb    %al,(%rax)
    2e53:	00 3f                	add    %bh,(%rdi)
    2e55:	dd 01                	fldl   (%rcx)
    2e57:	4c 18 00             	rex.WR sbb %r8b,(%rax)
    2e5a:	00 3f                	add    %bh,(%rdi)
    2e5c:	de 01                	fiadds (%rcx)
    2e5e:	55                   	push   %rbp
    2e5f:	18 00                	sbb    %al,(%rax)
    2e61:	00 47 dc             	add    %al,-0x24(%rdi)
    2e64:	16                   	(bad)
    2e65:	00 00                	add    %al,(%rax)
    2e67:	22 00                	and    (%rax),%al
    2e69:	66 11 3f             	adc    %di,(%rdi)
    2e6c:	c6 01 ee             	movb   $0xee,(%rcx)
    2e6f:	16                   	(bad)
    2e70:	00 00                	add    %al,(%rax)
    2e72:	3f                   	(bad)
    2e73:	c8 01 f7 16          	enter  $0xf701,$0x16
    2e77:	00 00                	add    %al,(%rax)
    2e79:	44 6f                	rex.R outsl %ds:(%rsi),(%dx)
    2e7b:	1a 00                	sbb    (%rax),%al
    2e7d:	00 00                	add    %al,(%rax)
    2e7f:	3f                   	(bad)
    2e80:	c7 01 01 17 00 00    	movl   $0x1701,(%rcx)
    2e86:	44 6f                	rex.R outsl %ds:(%rsi),(%dx)
    2e88:	1a 00                	sbb    (%rax),%al
    2e8a:	00 00                	add    %al,(%rax)
    2e8c:	45 06                	rex.RB (bad)
    2e8e:	0a 17                	or     (%rdi),%dl
    2e90:	00 00                	add    %al,(%rax)
    2e92:	00 00                	add    %al,(%rax)
    2e94:	00 44 70 a0          	add    %al,-0x60(%rax,%rsi,2)
    2e98:	01 00                	add    %eax,(%rax)
    2e9a:	00 3e                	add    %bh,(%rsi)
    2e9c:	02 31                	add    (%rcx),%dh
    2e9e:	9f                   	lahf
    2e9f:	66 18 00             	data16 sbb %al,(%rax)
    2ea2:	00 47 aa             	add    %al,-0x56(%rdi)
    2ea5:	19 00                	sbb    %eax,(%rax)
    2ea7:	00 23                	add    %ah,(%rbx)
    2ea9:	00 8f 0c 3d d5 01    	add    %cl,0x1d53d0c(%rdi)
    2eaf:	b3 19                	mov    $0x19,%bl
    2eb1:	00 00                	add    %al,(%rax)
    2eb3:	3d d6 01 bb 19       	cmp    $0x19bb01d6,%eax
    2eb8:	00 00                	add    %al,(%rax)
    2eba:	47 c5 19 00          	(bad)
    2ebe:	00 24 00             	add    %ah,(%rax,%rax,1)
    2ec1:	1e                   	(bad)
    2ec2:	09 3d d7 01 df 19    	or     %edi,0x19df01d7(%rip)        # 19df309f <_license+0x19df11ac>
    2ec8:	00 00                	add    %al,(%rax)
    2eca:	3f                   	(bad)
    2ecb:	d3 01                	roll   %cl,(%rcx)
    2ecd:	e8 19 00 00 3f       	call   3f002eeb <_license+0x3f000ff8>
    2ed2:	d4                   	(bad)
    2ed3:	01 f1                	add    %esi,%ecx
    2ed5:	19 00                	sbb    %eax,(%rax)
    2ed7:	00 3f                	add    %bh,(%rdi)
    2ed9:	d8 01                	fadds  (%rcx)
    2edb:	fa                   	cli
    2edc:	19 00                	sbb    %eax,(%rax)
    2ede:	00 3f                	add    %bh,(%rdi)
    2ee0:	d9 01                	flds   (%rcx)
    2ee2:	03 1a                	add    (%rdx),%ebx
    2ee4:	00 00                	add    %al,(%rax)
    2ee6:	43 1d 1a 00 00 71    	rex.XB sbb $0x7100001a,%eax
    2eec:	03 00                	add    (%rax),%eax
    2eee:	00 00                	add    %al,(%rax)
    2ef0:	0a 41 05             	or     0x5(%rcx),%al
    2ef3:	41 01 53 26          	add    %edx,0x26(%r11)
    2ef7:	1a 00                	sbb    (%rax),%al
    2ef9:	00 48 04             	add    %cl,0x4(%rax)
    2efc:	2f                   	(bad)
    2efd:	1a 00                	sbb    (%rax),%al
    2eff:	00 00                	add    %al,(%rax)
    2f01:	43 1d 1a 00 00 72    	rex.XB sbb $0x7200001a,%eax
    2f07:	05 00 00 00 0a       	add    $0xa000000,%eax
    2f0c:	41 05 41 01 53 26    	rex.B add $0x26530141,%eax
    2f12:	1a 00                	sbb    (%rax),%al
    2f14:	00 48 06             	add    %cl,0x6(%rax)
    2f17:	2f                   	(bad)
    2f18:	1a 00                	sbb    (%rax),%al
    2f1a:	00 00                	add    %al,(%rax)
    2f1c:	43 1d 1a 00 00 73    	rex.XB sbb $0x7300001a,%eax
    2f22:	05 00 00 00 0a       	add    $0xa000000,%eax
    2f27:	41 05 41 01 54 26    	rex.B add $0x26540141,%eax
    2f2d:	1a 00                	sbb    (%rax),%al
    2f2f:	00 48 08             	add    %cl,0x8(%rax)
    2f32:	2f                   	(bad)
    2f33:	1a 00                	sbb    (%rax),%al
    2f35:	00 00                	add    %al,(%rax)
    2f37:	43 1d 1a 00 00 74    	rex.XB sbb $0x7400001a,%eax
    2f3d:	05 00 00 00 0a       	add    $0xa000000,%eax
    2f42:	41 05 41 01 52 26    	rex.B add $0x26520141,%eax
    2f48:	1a 00                	sbb    (%rax),%al
    2f4a:	00 48 10             	add    %cl,0x10(%rax)
    2f4d:	2f                   	(bad)
    2f4e:	1a 00                	sbb    (%rax),%al
    2f50:	00 00                	add    %al,(%rax)
    2f52:	43 1d 1a 00 00 75    	rex.XB sbb $0x7500001a,%eax
    2f58:	05 00 00 00 0a       	add    $0xa000000,%eax
    2f5d:	41 05 41 01 55 26    	rex.B add $0x26550141,%eax
    2f63:	1a 00                	sbb    (%rax),%al
    2f65:	00 48 13             	add    %cl,0x13(%rax)
    2f68:	2f                   	(bad)
    2f69:	1a 00                	sbb    (%rax),%al
    2f6b:	00 00                	add    %al,(%rax)
    2f6d:	43 1d 1a 00 00 76    	rex.XB sbb $0x7600001a,%eax
    2f73:	07                   	(bad)
    2f74:	00 00                	add    %al,(%rax)
    2f76:	00 0a                	add    %cl,(%rdx)
    2f78:	41 05 41 01 51 26    	rex.B add $0x26510141,%eax
    2f7e:	1a 00                	sbb    (%rax),%al
    2f80:	00 48 04             	add    %cl,0x4(%rax)
    2f83:	2f                   	(bad)
    2f84:	1a 00                	sbb    (%rax),%al
    2f86:	00 00                	add    %al,(%rax)
    2f88:	43 1d 1a 00 00 77    	rex.XB sbb $0x7700001a,%eax
    2f8e:	05 00 00 00 0a       	add    $0xa000000,%eax
    2f93:	5e                   	pop    %rsi
    2f94:	07                   	(bad)
    2f95:	41 01 51 26          	add    %edx,0x26(%r9)
    2f99:	1a 00                	sbb    (%rax),%al
    2f9b:	00 48 0e             	add    %cl,0xe(%rax)
    2f9e:	2f                   	(bad)
    2f9f:	1a 00                	sbb    (%rax),%al
    2fa1:	00 00                	add    %al,(%rax)
    2fa3:	43 1d 1a 00 00 78    	rex.XB sbb $0x7800001a,%eax
    2fa9:	05 00 00 00 0a       	add    $0xa000000,%eax
    2fae:	5e                   	pop    %rsi
    2faf:	07                   	(bad)
    2fb0:	41 01 52 26          	add    %edx,0x26(%r10)
    2fb4:	1a 00                	sbb    (%rax),%al
    2fb6:	00 48 0b             	add    %cl,0xb(%rax)
    2fb9:	2f                   	(bad)
    2fba:	1a 00                	sbb    (%rax),%al
    2fbc:	00 00                	add    %al,(%rax)
    2fbe:	43 1d 1a 00 00 79    	rex.XB sbb $0x7900001a,%eax
    2fc4:	05 00 00 00 0a       	add    $0xa000000,%eax
    2fc9:	5e                   	pop    %rsi
    2fca:	07                   	(bad)
    2fcb:	41 01 54 26 1a       	add    %edx,0x1a(%r14,%riz,1)
    2fd0:	00 00                	add    %al,(%rax)
    2fd2:	48 19 2f             	sbb    %rbp,(%rdi)
    2fd5:	1a 00                	sbb    (%rax),%al
    2fd7:	00 00                	add    %al,(%rax)
    2fd9:	43 1d 1a 00 00 7a    	rex.XB sbb $0x7a00001a,%eax
    2fdf:	05 00 00 00 0a       	add    $0xa000000,%eax
    2fe4:	5e                   	pop    %rsi
    2fe5:	07                   	(bad)
    2fe6:	41 01 51 26          	add    %edx,0x26(%r9)
    2fea:	1a 00                	sbb    (%rax),%al
    2fec:	00 48 10             	add    %cl,0x10(%rax)
    2fef:	2f                   	(bad)
    2ff0:	1a 00                	sbb    (%rax),%al
    2ff2:	00 00                	add    %al,(%rax)
    2ff4:	43 1d 1a 00 00 7b    	rex.XB sbb $0x7b00001a,%eax
    2ffa:	05 00 00 00 0a       	add    $0xa000000,%eax
    2fff:	5e                   	pop    %rsi
    3000:	07                   	(bad)
    3001:	41 01 52 26          	add    %edx,0x26(%r10)
    3005:	1a 00                	sbb    (%rax),%al
    3007:	00 48 04             	add    %cl,0x4(%rax)
    300a:	2f                   	(bad)
    300b:	1a 00                	sbb    (%rax),%al
    300d:	00 00                	add    %al,(%rax)
    300f:	43 1d 1a 00 00 7c    	rex.XB sbb $0x7c00001a,%eax
    3015:	03 00                	add    (%rax),%eax
    3017:	00 00                	add    %al,(%rax)
    3019:	0a 5e 07             	or     0x7(%rsi),%bl
    301c:	41 01 54 26 1a       	add    %edx,0x1a(%r14,%riz,1)
    3021:	00 00                	add    %al,(%rax)
    3023:	48 0e                	rex.W (bad)
    3025:	2f                   	(bad)
    3026:	1a 00                	sbb    (%rax),%al
    3028:	00 00                	add    %al,(%rax)
    302a:	43 1d 1a 00 00 7d    	rex.XB sbb $0x7d00001a,%eax
    3030:	03 00                	add    (%rax),%eax
    3032:	00 00                	add    %al,(%rax)
    3034:	0a 5e 07             	or     0x7(%rsi),%bl
    3037:	41 01 51 26          	add    %edx,0x26(%r9)
    303b:	1a 00                	sbb    (%rax),%al
    303d:	00 48 18             	add    %cl,0x18(%rax)
    3040:	2f                   	(bad)
    3041:	1a 00                	sbb    (%rax),%al
    3043:	00 00                	add    %al,(%rax)
    3045:	00 43 67             	add    %al,0x67(%rbx)
    3048:	1a 00                	sbb    (%rax),%al
    304a:	00 7e 56             	add    %bh,0x56(%rsi)
    304d:	00 00                	add    %al,(%rax)
    304f:	00 00                	add    %al,(%rax)
    3051:	1d 0c 48 80 84       	sbb    $0x8480480c,%eax
    3056:	80 10 82             	adcb   $0x82,(%rax)
    3059:	1a 00                	sbb    (%rax),%al
    305b:	00 43 39             	add    %al,0x39(%rbx)
    305e:	1a 00                	sbb    (%rax),%al
    3060:	00 7e 56             	add    %bh,0x56(%rsi)
    3063:	00 00                	add    %al,(%rax)
    3065:	00 0a                	add    %cl,(%rdx)
    3067:	6f                   	outsl  %ds:(%rsi),(%dx)
    3068:	0a 3d da 01 42 1a    	or     0x1a4201da(%rip),%bh        # 1a423248 <_license+0x1a421355>
    306e:	00 00                	add    %al,(%rax)
    3070:	3d db 01 4b 1a       	cmp    $0x1a4b01db,%eax
    3075:	00 00                	add    %al,(%rax)
    3077:	3d dc 01 54 1a       	cmp    $0x1a5401dc,%eax
    307c:	00 00                	add    %al,(%rax)
    307e:	48 f7 81 b7 85 fe ff 	testq  $0x1ffffff,-0x17a49(%rcx)
    3085:	ff ff ff 01 
    3089:	5d                   	pop    %rbp
    308a:	1a 00                	sbb    (%rax),%al
    308c:	00 43 1d             	add    %al,0x1d(%rbx)
    308f:	1a 00                	sbb    (%rax),%al
    3091:	00 7f 05             	add    %bh,0x5(%rdi)
    3094:	00 00                	add    %al,(%rax)
    3096:	00 0a                	add    %cl,(%rdx)
    3098:	6a 03                	push   $0x3
    309a:	41 01 54 26 1a       	add    %edx,0x1a(%r14,%riz,1)
    309f:	00 00                	add    %al,(%rax)
    30a1:	48 0e                	rex.W (bad)
    30a3:	2f                   	(bad)
    30a4:	1a 00                	sbb    (%rax),%al
    30a6:	00 00                	add    %al,(%rax)
    30a8:	43 1d 1a 00 00 80    	rex.XB sbb $0x8000001a,%eax
    30ae:	01 05 00 00 00 0a    	add    %eax,0xa000000(%rip)        # a0030b4 <_license+0xa0011c1>
    30b4:	6a 03                	push   $0x3
    30b6:	41 01 51 26          	add    %edx,0x26(%r9)
    30ba:	1a 00                	sbb    (%rax),%al
    30bc:	00 48 0b             	add    %cl,0xb(%rax)
    30bf:	2f                   	(bad)
    30c0:	1a 00                	sbb    (%rax),%al
    30c2:	00 00                	add    %al,(%rax)
    30c4:	43 1d 1a 00 00 81    	rex.XB sbb $0x8100001a,%eax
    30ca:	01 05 00 00 00 0a    	add    %eax,0xa000000(%rip)        # a0030d0 <_license+0xa0011dd>
    30d0:	6a 03                	push   $0x3
    30d2:	41 01 52 26          	add    %edx,0x26(%r10)
    30d6:	1a 00                	sbb    (%rax),%al
    30d8:	00 48 19             	add    %cl,0x19(%rax)
    30db:	2f                   	(bad)
    30dc:	1a 00                	sbb    (%rax),%al
    30de:	00 00                	add    %al,(%rax)
    30e0:	43 1d 1a 00 00 82    	rex.XB sbb $0x8200001a,%eax
    30e6:	01 05 00 00 00 0a    	add    %eax,0xa000000(%rip)        # a0030ec <_license+0xa0011f9>
    30ec:	6a 03                	push   $0x3
    30ee:	41 01 54 26 1a       	add    %edx,0x1a(%r14,%riz,1)
    30f3:	00 00                	add    %al,(%rax)
    30f5:	48 10 2f             	rex.W adc %bpl,(%rdi)
    30f8:	1a 00                	sbb    (%rax),%al
    30fa:	00 00                	add    %al,(%rax)
    30fc:	43 1d 1a 00 00 83    	rex.XB sbb $0x8300001a,%eax
    3102:	01 05 00 00 00 0a    	add    %eax,0xa000000(%rip)        # a003108 <_license+0xa001215>
    3108:	6a 03                	push   $0x3
    310a:	41 01 51 26          	add    %edx,0x26(%r9)
    310e:	1a 00                	sbb    (%rax),%al
    3110:	00 48 04             	add    %cl,0x4(%rax)
    3113:	2f                   	(bad)
    3114:	1a 00                	sbb    (%rax),%al
    3116:	00 00                	add    %al,(%rax)
    3118:	43 1d 1a 00 00 84    	rex.XB sbb $0x8400001a,%eax
    311e:	01 03                	add    %eax,(%rbx)
    3120:	00 00                	add    %al,(%rax)
    3122:	00 0a                	add    %cl,(%rdx)
    3124:	6a 03                	push   $0x3
    3126:	41 01 52 26          	add    %edx,0x26(%r10)
    312a:	1a 00                	sbb    (%rax),%al
    312c:	00 48 0e             	add    %cl,0xe(%rax)
    312f:	2f                   	(bad)
    3130:	1a 00                	sbb    (%rax),%al
    3132:	00 00                	add    %al,(%rax)
    3134:	43 1d 1a 00 00 85    	rex.XB sbb $0x8500001a,%eax
    313a:	01 03                	add    %eax,(%rbx)
    313c:	00 00                	add    %al,(%rax)
    313e:	00 0a                	add    %cl,(%rdx)
    3140:	6a 03                	push   $0x3
    3142:	41 01 54 26 1a       	add    %edx,0x1a(%r14,%riz,1)
    3147:	00 00                	add    %al,(%rax)
    3149:	48 18 2f             	rex.W sbb %bpl,(%rdi)
    314c:	1a 00                	sbb    (%rax),%al
    314e:	00 00                	add    %al,(%rax)
    3150:	00 00                	add    %al,(%rax)
    3152:	00 46 25             	add    %al,0x25(%rsi)
    3155:	3f                   	(bad)
    3156:	e0 01                	loopne 3159 <_license+0x1266>
    3158:	70 18                	jo     3172 <_license+0x127f>
    315a:	00 00                	add    %al,(%rax)
    315c:	46                   	rex.RX
    315d:	26 45 02 79 18       	es add 0x18(%r9),%r15b
    3162:	00 00                	add    %al,(%rax)
    3164:	46 27                	rex.RX (bad)
    3166:	3f                   	(bad)
    3167:	df 01                	filds  (%rcx)
    3169:	82                   	(bad)
    316a:	18 00                	sbb    %al,(%rax)
    316c:	00 42 80             	add    %al,-0x80(%rdx)
    316f:	84 80 10 8a 18 00    	test   %al,0x188a10(%rax)
    3175:	00 42 04             	add    %al,0x4(%rdx)
    3178:	92                   	xchg   %eax,%edx
    3179:	18 00                	sbb    %al,(%rax)
    317b:	00 00                	add    %al,(%rax)
    317d:	00 00                	add    %al,(%rax)
    317f:	00 44 86 01          	add    %al,0x1(%rsi,%rax,4)
    3183:	06                   	(bad)
    3184:	00 00                	add    %al,(%rax)
    3186:	00 3f                	add    %bh,(%rdi)
    3188:	e1 01                	loope  318b <_license+0x1298>
    318a:	9f                   	lahf
    318b:	18 00                	sbb    %al,(%rax)
    318d:	00 44 86 01          	add    %al,0x1(%rsi,%rax,4)
    3191:	06                   	(bad)
    3192:	00 00                	add    %al,(%rax)
    3194:	00 45 02             	add    %al,0x2(%rbp)
    3197:	a8 18                	test   $0x18,%al
    3199:	00 00                	add    %al,(%rax)
    319b:	44 86 01             	xchg   %r8b,(%rcx)
    319e:	06                   	(bad)
    319f:	00 00                	add    %al,(%rax)
    31a1:	00 3e                	add    %bh,(%rsi)
    31a3:	01 53 b1             	add    %edx,-0x4f(%rbx)
    31a6:	18 00                	sbb    %al,(%rax)
    31a8:	00 42 80             	add    %al,-0x80(%rdx)
    31ab:	20 b9 18 00 00 42    	and    %bh,0x42000018(%rcx)
    31b1:	14 c1                	adc    $0xc1,%al
    31b3:	18 00                	sbb    %al,(%rax)
    31b5:	00 00                	add    %al,(%rax)
    31b7:	00 00                	add    %al,(%rax)
    31b9:	00 40 8c             	add    %al,-0x74(%rax)
    31bc:	1a 00                	sbb    (%rax),%al
    31be:	00 87 01 89 00 00    	add    %al,0x8901(%rdi)
    31c4:	00 00                	add    %al,(%rax)
    31c6:	ff 03                	incl   (%rbx)
    31c8:	0b 41 04             	or     0x4(%rcx),%eax
    31cb:	91                   	xchg   %eax,%ecx
    31cc:	d8 7e 9f             	fdivrs -0x61(%rsi)
    31cf:	96                   	xchg   %eax,%esi
    31d0:	1a 00                	sbb    (%rax),%al
    31d2:	00 41 02             	add    %al,0x2(%rcx)
    31d5:	31 9f b1 1a 00 00    	xor    %ebx,0x1ab1(%rdi)
    31db:	42 00 ba 1a 00 00 44 	rex.X add %dil,0x4400001a(%rdx)
    31e2:	88 01                	mov    %al,(%rcx)
    31e4:	27                   	(bad)
    31e5:	00 00                	add    %al,(%rax)
    31e7:	00 3f                	add    %bh,(%rdi)
    31e9:	e2 01                	loop   31ec <_license+0x12f9>
    31eb:	f7 1a                	negl   (%rdx)
    31ed:	00 00                	add    %al,(%rax)
    31ef:	3f                   	(bad)
    31f0:	e4 01                	in     $0x1,%al
    31f2:	00 1b                	add    %bl,(%rbx)
    31f4:	00 00                	add    %al,(%rax)
    31f6:	44 89 01             	mov    %r8d,(%rcx)
    31f9:	17                   	(bad)
    31fa:	00 00                	add    %al,(%rax)
    31fc:	00 3f                	add    %bh,(%rdi)
    31fe:	e3 01                	jrcxz  3201 <_license+0x130e>
    3200:	0b 1b                	or     (%rbx),%ebx
    3202:	00 00                	add    %al,(%rax)
    3204:	44 89 01             	mov    %r8d,(%rcx)
    3207:	17                   	(bad)
    3208:	00 00                	add    %al,(%rax)
    320a:	00 45 06             	add    %al,0x6(%rbp)
    320d:	15 1b 00 00 00       	adc    $0x1b,%eax
    3212:	00 00                	add    %al,(%rax)
    3214:	00 44 8a 01          	add    %al,0x1(%rdx,%rcx,4)
    3218:	20 00                	and    %al,(%rax)
    321a:	00 00                	add    %al,(%rax)
    321c:	3f                   	(bad)
    321d:	b0 01                	mov    $0x1,%al
    321f:	41 0c 00             	rex.B or $0x0,%al
    3222:	00 44 8a 01          	add    %al,0x1(%rdx,%rcx,4)
    3226:	20 00                	and    %al,(%rax)
    3228:	00 00                	add    %al,(%rax)
    322a:	45 06                	rex.RB (bad)
    322c:	4b 0c 00             	rex.WXB or $0x0,%al
    322f:	00 00                	add    %al,(%rax)
    3231:	00 44 8b 01          	add    %al,0x1(%rbx,%rcx,4)
    3235:	11 00                	adc    %eax,(%rax)
    3237:	00 00                	add    %al,(%rax)
    3239:	3f                   	(bad)
    323a:	b1 01                	mov    $0x1,%cl
    323c:	57                   	push   %rdi
    323d:	0c 00                	or     $0x0,%al
    323f:	00 44 8b 01          	add    %al,0x1(%rbx,%rcx,4)
    3243:	11 00                	adc    %eax,(%rax)
    3245:	00 00                	add    %al,(%rax)
    3247:	45 06                	rex.RB (bad)
    3249:	61                   	(bad)
    324a:	0c 00                	or     $0x0,%al
    324c:	00 00                	add    %al,(%rax)
    324e:	00 40 15             	add    %al,0x15(%rax)
    3251:	17                   	(bad)
    3252:	00 00                	add    %al,(%rax)
    3254:	8c 01                	mov    %es,(%rcx)
    3256:	d3 00                	roll   %cl,(%rax)
    3258:	00 00                	add    %al,(%rax)
    325a:	00 28                	add    %ch,(%rax)
    325c:	04 0a                	add    $0xa,%al
    325e:	41 01 5d 1e          	add    %ebx,0x1e(%r13)
    3262:	17                   	(bad)
    3263:	00 00                	add    %al,(%rax)
    3265:	41 04 91             	rex.B add $0x91,%al
    3268:	80 7f 9f 2e          	cmpb   $0x2e,-0x61(%rdi)
    326c:	17                   	(bad)
    326d:	00 00                	add    %al,(%rax)
    326f:	3d b2 01 36 17       	cmp    $0x173601b2,%eax
    3274:	00 00                	add    %al,(%rax)
    3276:	3f                   	(bad)
    3277:	43                   	rex.XB
    3278:	46 17                	rex.RX (bad)
    327a:	00 00                	add    %al,(%rax)
    327c:	3f                   	(bad)
    327d:	b3 01                	mov    $0x1,%bl
    327f:	4e 17                	rex.WRX (bad)
    3281:	00 00                	add    %al,(%rax)
    3283:	3f                   	(bad)
    3284:	b4 01                	mov    $0x1,%ah
    3286:	57                   	push   %rdi
    3287:	17                   	(bad)
    3288:	00 00                	add    %al,(%rax)
    328a:	3f                   	(bad)
    328b:	b5 01                	mov    $0x1,%ch
    328d:	5f                   	pop    %rdi
    328e:	17                   	(bad)
    328f:	00 00                	add    %al,(%rax)
    3291:	3f                   	(bad)
    3292:	b6 01                	mov    $0x1,%dh
    3294:	67 17                	addr32 (bad)
    3296:	00 00                	add    %al,(%rax)
    3298:	3f                   	(bad)
    3299:	b7 01                	mov    $0x1,%bh
    329b:	6f                   	outsl  %ds:(%rsi),(%dx)
    329c:	17                   	(bad)
    329d:	00 00                	add    %al,(%rax)
    329f:	3f                   	(bad)
    32a0:	b8 01 78 17 00       	mov    $0x177801,%eax
    32a5:	00 43 b8             	add    %al,-0x48(%rbx)
    32a8:	17                   	(bad)
    32a9:	00 00                	add    %al,(%rax)
    32ab:	8d 01                	lea    (%rcx),%eax
    32ad:	45 00 00             	add    %r8b,(%r8)
    32b0:	00 0d 75 03 41 01    	add    %cl,0x1410375(%rip)        # 141362b <_license+0x1411738>
    32b6:	53                   	push   %rbx
    32b7:	c5 17 00             	(bad)
    32ba:	00 3d b9 01 cd 17    	add    %bh,0x17cd01b9(%rip)        # 17cd3479 <_license+0x17cd1586>
    32c0:	00 00                	add    %al,(%rax)
    32c2:	41 01 52 d5          	add    %edx,-0x2b(%r10)
    32c6:	17                   	(bad)
    32c7:	00 00                	add    %al,(%rax)
    32c9:	48 04 e5             	rex.W add $0xe5,%al
    32cc:	17                   	(bad)
    32cd:	00 00                	add    %al,(%rax)
    32cf:	42 00 ed             	rex.X add %bpl,%bpl
    32d2:	17                   	(bad)
    32d3:	00 00                	add    %al,(%rax)
    32d5:	43 19 11             	rex.XB sbb %edx,(%r9)
    32d8:	00 00                	add    %al,(%rax)
    32da:	8e 01                	mov    (%rcx),%es
    32dc:	1d 00 00 00 0e       	sbb    $0xe000000,%eax
    32e1:	48 03 41 03          	add    0x3(%rcx),%rax
    32e5:	70 0e                	jo     32f5 <_license+0x1402>
    32e7:	9f                   	lahf
    32e8:	1d 11 00 00 3f       	sbb    $0x3f000011,%eax
    32ed:	bb 01 2d 11 00       	mov    $0x112d01,%ebx
    32f2:	00 44 8e 01          	add    %al,0x1(%rsi,%rcx,4)
    32f6:	1d 00 00 00 3f       	sbb    $0x3f000000,%eax
    32fb:	ba 01 36 11 00       	mov    $0x113601,%edx
    3300:	00 00                	add    %al,(%rax)
    3302:	00 00                	add    %al,(%rax)
    3304:	00 40 cd             	add    %al,-0x33(%rax)
    3307:	18 00                	sbb    %al,(%rax)
    3309:	00 8f 01 9f 00 00    	add    %cl,0x9f01(%rdi)
    330f:	00 00                	add    %al,(%rax)
    3311:	24 04                	and    $0x4,%al
    3313:	0a 41 01             	or     0x1(%rcx),%al
    3316:	5d                   	pop    %rbp
    3317:	d6                   	(bad)
    3318:	18 00                	sbb    %al,(%rax)
    331a:	00 41 02             	add    %al,0x2(%rcx)
    331d:	31 9f e6 18 00 00    	xor    %ebx,0x18e6(%rdi)
    3323:	41 04 91             	rex.B add $0x91,%al
    3326:	80 7f 9f ee          	cmpb   $0xee,-0x61(%rdi)
    332a:	18 00                	sbb    %al,(%rax)
    332c:	00 41 02             	add    %al,0x2(%rcx)
    332f:	91                   	xchg   %eax,%ecx
    3330:	50                   	push   %rax
    3331:	f6 18                	negb   (%rax)
    3333:	00 00                	add    %al,(%rax)
    3335:	3f                   	(bad)
    3336:	c9                   	leave
    3337:	01 06                	add    %eax,(%rsi)
    3339:	19 00                	sbb    %eax,(%rax)
    333b:	00 3f                	add    %bh,(%rdi)
    333d:	ca 01 0e             	lret   $0xe01
    3340:	19 00                	sbb    %eax,(%rax)
    3342:	00 3f                	add    %bh,(%rdi)
    3344:	cb                   	lret
    3345:	01 16                	add    %edx,(%rsi)
    3347:	19 00                	sbb    %eax,(%rax)
    3349:	00 3f                	add    %bh,(%rdi)
    334b:	cc                   	int3
    334c:	01 1f                	add    %ebx,(%rdi)
    334e:	19 00                	sbb    %eax,(%rax)
    3350:	00 3f                	add    %bh,(%rdi)
    3352:	cd 01                	int    $0x1
    3354:	27                   	(bad)
    3355:	19 00                	sbb    %eax,(%rax)
    3357:	00 3f                	add    %bh,(%rdi)
    3359:	ce                   	(bad)
    335a:	01 30                	add    %esi,(%rax)
    335c:	19 00                	sbb    %eax,(%rax)
    335e:	00 3f                	add    %bh,(%rdi)
    3360:	cf                   	iret
    3361:	01 38                	add    %edi,(%rax)
    3363:	19 00                	sbb    %eax,(%rax)
    3365:	00 3f                	add    %bh,(%rdi)
    3367:	d0 01                	rolb   (%rcx)
    3369:	40 19 00             	rex sbb %eax,(%rax)
    336c:	00 49 55             	add    %cl,0x55(%rcx)
    336f:	19 00                	sbb    %eax,(%rax)
    3371:	00 90 01 06 00 00    	add    %dl,0x601(%rax)
    3377:	00 0d 4b 05 43 73    	add    %cl,0x7343054b(%rip)        # 734338c8 <_license+0x734319d5>
    337d:	19 00                	sbb    %eax,(%rax)
    337f:	00 91 01 2a 00 00    	add    %dl,0x2a01(%rcx)
    3385:	00 0d 53 03 3d d2    	add    %cl,-0x2dc2fcad(%rip)        # ffffffffd23d36de <server_id_map+0x36fc91bef6de>
    338b:	01 80 19 00 00 41    	add    %eax,0x41000019(%rax)
    3391:	02 91 50 91 19 00    	add    0x199150(%rcx),%dl
    3397:	00 3d d1 01 99 19    	add    %bh,0x199901d1(%rip)        # 1999356e <_license+0x1999167b>
    339d:	00 00                	add    %al,(%rax)
    339f:	48 29 a1 19 00 00 00 	sub    %rsp,0x19(%rcx)
    33a6:	00 00                	add    %al,(%rax)
    33a8:	4a 01 50 92          	rex.WX add %rdx,-0x6e(%rax)
    33ac:	01 4a 01             	add    %ecx,0x1(%rdx)
    33af:	50                   	push   %rax
    33b0:	93                   	xchg   %eax,%ebx
    33b1:	01 4a 01             	add    %ecx,0x1(%rdx)
    33b4:	50                   	push   %rax
    33b5:	94                   	xchg   %eax,%esp
    33b6:	01 4a 01             	add    %ecx,0x1(%rdx)
    33b9:	50                   	push   %rax
    33ba:	95                   	xchg   %eax,%ebp
    33bb:	01 4a 01             	add    %ecx,0x1(%rdx)
    33be:	50                   	push   %rax
    33bf:	96                   	xchg   %eax,%esi
    33c0:	01 4a 01             	add    %ecx,0x1(%rdx)
    33c3:	50                   	push   %rax
    33c4:	97                   	xchg   %eax,%edi
    33c5:	01 4a 01             	add    %ecx,0x1(%rdx)
    33c8:	50                   	push   %rax
    33c9:	98                   	cwtl
    33ca:	01 4a 01             	add    %ecx,0x1(%rdx)
    33cd:	50                   	push   %rax
    33ce:	99                   	cltd
    33cf:	01 4a 01             	add    %ecx,0x1(%rdx)
    33d2:	50                   	push   %rax
    33d3:	9a                   	(bad)
    33d4:	01 4a 01             	add    %ecx,0x1(%rdx)
    33d7:	50                   	push   %rax
    33d8:	9b                   	fwait
    33d9:	01 4a 01             	add    %ecx,0x1(%rdx)
    33dc:	50                   	push   %rax
    33dd:	9c                   	pushf
    33de:	01 4a 01             	add    %ecx,0x1(%rdx)
    33e1:	50                   	push   %rax
    33e2:	9d                   	popf
    33e3:	01 4a 01             	add    %ecx,0x1(%rdx)
    33e6:	50                   	push   %rax
    33e7:	9e                   	sahf
    33e8:	01 4a 01             	add    %ecx,0x1(%rdx)
    33eb:	50                   	push   %rax
    33ec:	9f                   	lahf
    33ed:	01 4a 01             	add    %ecx,0x1(%rdx)
    33f0:	50                   	push   %rax
    33f1:	a0 01 4a 01 50 a1 01 	movabs 0x14a01a150014a01,%al
    33f8:	4a 01 
    33fa:	50                   	push   %rax
    33fb:	a2 01 4a 01 50 a3 01 	movabs %al,0x14a01a350014a01
    3402:	4a 01 
    3404:	50                   	push   %rax
    3405:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    3406:	01 4a 01             	add    %ecx,0x1(%rdx)
    3409:	50                   	push   %rax
    340a:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    340b:	01 4a 01             	add    %ecx,0x1(%rdx)
    340e:	50                   	push   %rax
    340f:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    3410:	01 4a 01             	add    %ecx,0x1(%rdx)
    3413:	50                   	push   %rax
    3414:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    3415:	01 4a 01             	add    %ecx,0x1(%rdx)
    3418:	50                   	push   %rax
    3419:	a8 01                	test   $0x1,%al
    341b:	4a 01 50 a9          	rex.WX add %rdx,-0x57(%rax)
    341f:	01 4a 01             	add    %ecx,0x1(%rdx)
    3422:	50                   	push   %rax
    3423:	aa                   	stos   %al,%es:(%rdi)
    3424:	01 4a 01             	add    %ecx,0x1(%rdx)
    3427:	53                   	push   %rbx
    3428:	ab                   	stos   %eax,%es:(%rdi)
    3429:	01 4a 01             	add    %ecx,0x1(%rdx)
    342c:	53                   	push   %rbx
    342d:	ac                   	lods   %ds:(%rsi),%al
    342e:	01 4a 01             	add    %ecx,0x1(%rdx)
    3431:	50                   	push   %rax
    3432:	ad                   	lods   %ds:(%rsi),%eax
    3433:	01 4a 01             	add    %ecx,0x1(%rdx)
    3436:	5c                   	pop    %rsp
    3437:	ae                   	scas   %es:(%rdi),%al
    3438:	01 4a 01             	add    %ecx,0x1(%rdx)
    343b:	5c                   	pop    %rsp
    343c:	af                   	scas   %es:(%rdi),%eax
    343d:	01 4a 01             	add    %ecx,0x1(%rdx)
    3440:	50                   	push   %rax
    3441:	b0 01                	mov    $0x1,%al
    3443:	4a 01 50 b1          	rex.WX add %rdx,-0x4f(%rax)
    3447:	01 4a 01             	add    %ecx,0x1(%rdx)
    344a:	50                   	push   %rax
    344b:	b2 01                	mov    $0x1,%dl
    344d:	4a 01 50 b3          	rex.WX add %rdx,-0x4d(%rax)
    3451:	01 4a 01             	add    %ecx,0x1(%rdx)
    3454:	50                   	push   %rax
    3455:	b4 01                	mov    $0x1,%ah
    3457:	4a 01 50 b5          	rex.WX add %rdx,-0x4b(%rax)
    345b:	01 4a 01             	add    %ecx,0x1(%rdx)
    345e:	50                   	push   %rax
    345f:	b6 01                	mov    $0x1,%dh
    3461:	4a 01 50 b7          	rex.WX add %rdx,-0x49(%rax)
    3465:	01 4a 01             	add    %ecx,0x1(%rdx)
    3468:	5e                   	pop    %rsi
    3469:	b8 01 4a 01 5e       	mov    $0x5e014a01,%eax
    346e:	b9 01 4a 01 50       	mov    $0x50014a01,%ecx
    3473:	ba 01 4a 01 5e       	mov    $0x5e014a01,%edx
    3478:	bb 01 4a 01 50       	mov    $0x50014a01,%ebx
    347d:	bc 01 4a 01 50       	mov    $0x50014a01,%esp
    3482:	bd 01 4a 01 50       	mov    $0x50014a01,%ebp
    3487:	be 01 4a 01 50       	mov    $0x50014a01,%esi
    348c:	bf 01 4a 01 5e       	mov    $0x5e014a01,%edi
    3491:	c0 01 4a             	rolb   $0x4a,(%rcx)
    3494:	01 5e c1             	add    %ebx,-0x3f(%rsi)
    3497:	01 4a 01             	add    %ecx,0x1(%rdx)
    349a:	50                   	push   %rax
    349b:	c2 01 4a             	ret    $0x4a01
    349e:	01 5e c3             	add    %ebx,-0x3d(%rsi)
    34a1:	01 4a 01             	add    %ecx,0x1(%rdx)
    34a4:	5e                   	pop    %rsi
    34a5:	c4 01 4a 01          	(bad)
    34a9:	50                   	push   %rax
    34aa:	c5 01 4a             	(bad)
    34ad:	01 50 c6             	add    %edx,-0x3a(%rax)
    34b0:	01 4a 01             	add    %ecx,0x1(%rdx)
    34b3:	50                   	push   %rax
    34b4:	c7 01 4a 01 50 c8    	movl   $0xc850014a,(%rcx)
    34ba:	01 4a 01             	add    %ecx,0x1(%rdx)
    34bd:	50                   	push   %rax
    34be:	c9                   	leave
    34bf:	01 4a 01             	add    %ecx,0x1(%rdx)
    34c2:	50                   	push   %rax
    34c3:	ca 01 4a             	lret   $0x4a01
    34c6:	01 50 cb             	add    %edx,-0x35(%rax)
    34c9:	01 4a 01             	add    %ecx,0x1(%rdx)
    34cc:	50                   	push   %rax
    34cd:	cc                   	int3
    34ce:	01 4a 01             	add    %ecx,0x1(%rdx)
    34d1:	50                   	push   %rax
    34d2:	cd 01                	int    $0x1
    34d4:	4a 01 50 ce          	rex.WX add %rdx,-0x32(%rax)
    34d8:	01 4a 01             	add    %ecx,0x1(%rdx)
    34db:	50                   	push   %rax
    34dc:	cf                   	iret
    34dd:	01 4a 01             	add    %ecx,0x1(%rdx)
    34e0:	5e                   	pop    %rsi
    34e1:	d0 01                	rolb   (%rcx)
    34e3:	4a 01 50 d1          	rex.WX add %rdx,-0x2f(%rax)
    34e7:	01 4a 01             	add    %ecx,0x1(%rdx)
    34ea:	50                   	push   %rax
    34eb:	d2 01                	rolb   %cl,(%rcx)
    34ed:	4a 01 50 d3          	rex.WX add %rdx,-0x2d(%rax)
    34f1:	01 00                	add    %eax,(%rax)
	...

Disassembly of section .debug_rnglists:

0000000000000000 <.debug_rnglists>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	4f 03 00             	rex.WRXB add (%r8),%r8
   3:	00 05 00 08 00 28    	add    %al,0x28000800(%rip)        # 28000809 <_license+0x27ffe916>
   9:	00 00                	add    %al,(%rax)
   b:	00 a0 00 00 00 e1    	add    %ah,-0x1f000000(%rax)
  11:	00 00                	add    %al,(%rax)
  13:	00 f1                	add    %dh,%cl
  15:	00 00                	add    %al,(%rax)
  17:	00 0b                	add    %cl,(%rbx)
  void* data = (void*)(long)ctx->data;
  19:	01 00                	add    %eax,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
  1b:	00 16                	add    %dl,(%rsi)
  1d:	01 00                	add    %eax,(%rax)
  if (data + nh_off > data_end) {
  1f:	00 26                	add    %ah,(%rsi)
  21:	01 00                	add    %eax,(%rax)
  23:	00 45 01             	add    %al,0x1(%rbp)
  26:	00 00                	add    %al,(%rax)
  28:	5a                   	pop    %rdx
  29:	01 00                	add    %eax,(%rax)
  2b:	00 65 01             	add    %ah,0x1(%rbp)
  2e:	00 00                	add    %al,(%rax)
  30:	75 01                	jne    33 <balancer_ingress+0x33>
  32:	00 00                	add    %al,(%rax)
  eth_proto = eth->h_proto;
  34:	80 01 00             	addb   $0x0,(%rcx)
  37:	00 8b 01 00 00 9b    	add    %cl,-0x64ffffff(%rbx)
  if (eth_proto == BE_ETH_P_IP) {
  3d:	01 00                	add    %eax,(%rax)
  3f:	00 a6 01 00 00 b6    	add    %ah,-0x49ffffff(%rsi)
  45:	01 00                	add    %eax,(%rax)
  47:	00 c1                	add    %al,%cl
  49:	01 00                	add    %eax,(%rax)
  4b:	00 cc                	add    %cl,%ah
  4d:	01 00                	add    %eax,(%rax)
  4f:	00 d7                	add    %dl,%bh
  51:	01 00                	add    %eax,(%rax)
  53:	00 e2                	add    %ah,%dl
  struct packet_description pckt = {};
  55:	01 00                	add    %eax,(%rax)
  57:	00 ed                	add    %ch,%ch
  59:	01 00                	add    %eax,(%rax)
  5b:	00 25 02 00 00 30    	add    %ah,0x30000002(%rip)        # 30000063 <_license+0x2fffe170>
  61:	02 00                	add    (%rax),%al
  63:	00 45 02             	add    %al,0x2(%rbp)
  66:	00 00                	add    %al,(%rax)
  68:	50                   	push   %rax
  69:	02 00                	add    (%rax),%al
  6b:	00 5b 02             	add    %bl,0x2(%rbx)
  6e:	00 00                	add    %al,(%rax)
  70:	7f 02                	jg     74 <balancer_ingress+0x74>
  72:	00 00                	add    %al,(%rax)
  74:	94                   	xchg   %eax,%esp
  75:	02 00                	add    (%rax),%al
  77:	00 9f 02 00 00 b4    	add    %bl,-0x4bfffffe(%rdi)
  7d:	02 00                	add    (%rax),%al
  7f:	00 bf 02 00 00 cf    	add    %bh,-0x30fffffe(%rdi)
  struct vip_definition vip = {};
  85:	02 00                	add    (%rax),%al
  87:	00 e4                	add    %ah,%ah
  89:	02 00                	add    (%rax),%al
  8b:	00 ef                	add    %ch,%bh
  8d:	02 00                	add    (%rax),%al
  8f:	00 fa                	add    %bh,%dl
  91:	02 00                	add    (%rax),%al
  93:	00 05 03 00 00 10    	add    %al,0x10000003(%rip)        # 1000009c <_license+0xfffe1a9>
  99:	03 00                	add    (%rax),%eax
  9b:	00 1b                	add    %bl,(%rbx)
  9d:	03 00                	add    (%rax),%eax
  9f:	00 26                	add    %ah,(%rsi)
  a1:	03 00                	add    (%rax),%eax
  a3:	00 31                	add    %dh,(%rcx)
    if (iph + 1 > data_end) {
  a5:	03 00                	add    (%rax),%eax
  a7:	00 3c 03             	add    %bh,(%rbx,%rax,1)
  aa:	00 00                	add    %al,(%rax)
  ac:	04 54                	add    $0x54,%al
  ae:	86 03                	xchg   %al,(%rbx)
  b0:	04 cd                	add    $0xcd,%al
    if (iph->ihl != 5) {
  b2:	08 a4 09 04 e3 09 a3 	or     %ah,-0x5cf61cfc(%rcx,%rcx,1)
  b9:	0a 04 91             	or     (%rcx,%rdx,4),%al
  bc:	10 c5                	adc    %al,%ch
    pckt->tos = iph->tos;
  be:	16                   	(bad)
  bf:	04 de                	add    $0xde,%al
  c1:	18 a3 19 04 f8 26    	sbb    %ah,0x26f80419(%rbx)
    *protocol = iph->protocol;
  c7:	c5 27 04             	(bad)
    pckt->flow.proto = *protocol;
  ca:	d1 28                	shrl   (%rax)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  cc:	ab                   	stos   %eax,%es:(%rdi)
  cd:	29 04 de             	sub    %eax,(%rsi,%rbx,8)
  d0:	2a b8 2b 04 a3 2c    	sub    0x2ca3042b(%rax),%bh
  d6:	fa                   	cli
  d7:	32 04 f7             	xor    (%rdi,%rsi,8),%al
  da:	33 b9 36 04 e7 36    	xor    0x36e70436(%rcx),%edi
    if (*protocol == IPPROTO_ICMP) {
  e0:	c5 38 04             	(bad)
  e3:	af                   	scas   %es:(%rdi),%eax
  e4:	39 88 3b 04 9b 3c    	cmp    %ecx,0x3c9b043b(%rax)
  if (icmp_hdr + 1 > data_end) {
  ea:	f3 3d 00 04 a4 01    	repz cmp $0x1a40400,%eax
  f0:	db 01                	fildl  (%rcx)
  f2:	04 e0                	add    $0xe0,%al
  f4:	01 e9                	add    %ebp,%ecx
  if (icmp_hdr->type == ICMP_ECHO) {
  f6:	01 04 cd 08 db 08 00 	add    %eax,0x8db08(,%rcx,8)
  fd:	04 e9                	add    $0xe9,%al
  ff:	01 86 03 04 db 08    	add    %eax,0x8db0403(%rsi)
 105:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
 106:	09 04 c8             	or     %eax,(%rax,%rcx,8)
 109:	10 c9                	adc    %cl,%cl
 10b:	11 04 c1             	adc    %eax,(%rcx,%rax,8)
 10e:	15 8e 16 04 92       	adc    $0x9204168e,%eax
 113:	16                   	(bad)
  icmp_hdr->type = ICMP_ECHOREPLY;
 114:	c5 16 00             	(bad)
 117:	04 e9                	add    $0xe9,%al
  icmp_hdr->checksum += 0x0008;
 119:	01 86 03 04 c8 10    	add    %eax,0x10c80403(%rsi)
  iph->ttl = DEFAULT_TTL;
 11f:	c9                   	leave
 120:	11 00                	adc    %eax,(%rax)
 122:	04 e0                	add    $0xe0,%al
  iph->daddr = iph->saddr;
 124:	08 a4 09 04 c1 15 8e 	or     %ah,-0x71ea3efc(%rcx,%rcx,1)
  tmp_addr = iph->daddr;
 12b:	16                   	(bad)
  iph->daddr = iph->saddr;
 12c:	04 92                	add    $0x92,%al
 12e:	16                   	(bad)
 12f:	c5 16 00             	(bad)
  iph->saddr = tmp_addr;
 132:	04 99                	add    $0x99,%al
 134:	14 ff                	adc    $0xff,%al
 136:	14 04                	adc    $0x4,%al
 138:	f8                   	clc
 139:	26 c5 27 04          	(bad)
 13d:	d1 28                	shrl   (%rax)
 13f:	ab                   	stos   %eax,%es:(%rdi)
 140:	29 04 de             	sub    %eax,(%rsi,%rbx,8)
 143:	2a b8 2b 04 a3 2c    	sub    0x2ca3042b(%rax),%bh
 149:	b9 2d 04 9b 3c       	mov    $0x3c9b042d,%ecx
 14e:	e4 3d                	in     $0x3d,%al
 150:	00 04 c3             	add    %al,(%rbx,%rax,8)
 153:	14 ff                	adc    $0xff,%al
 155:	14 04                	adc    $0x4,%al
 157:	f8                   	clc
 158:	26 8e 27             	es mov (%rdi),%fs
 15b:	04 d1                	add    $0xd1,%al
 15d:	28 ab 29 04 de 2a    	sub    %ch,0x2ade0429(%rbx)
 163:	a1 2b 00 04 f8 26 8e 	movabs 0x4278e26f804002b,%eax
 16a:	27 04 
    if (csum >> 16)
 16c:	d1 28                	shrl   (%rax)
 16e:	dc 28                	fsubrl (%rax)
 170:	00 04 a9             	add    %al,(%rcx,%rbp,4)
 173:	2b b8 2b 04 a3 2c    	sub    0x2ca3042b(%rax),%edi
 179:	b5 2d                	mov    $0x2d,%ch
 17b:	04 9b                	add    $0x9b,%al
 17d:	3c e4                	cmp    $0xe4,%al
 17f:	3d 00 04 a9 2b       	cmp    $0x2ba90400,%eax
 184:	b8 2b 04 a3 2c       	mov    $0x2ca3042b,%eax
  struct packet_description pckt = {};
 189:	a8 2c                	test   $0x2c,%al
 18b:	00 04 c5 2c aa 2d 04 	add    %al,0x42daa2c(,%rax,8)
 192:	9b                   	fwait
 193:	3c e4                	cmp    $0xe4,%al
 195:	3d 00 04 89 2d       	cmp    $0x2d890400,%eax
 19a:	a0 2d 04 9b 3c e7 3c 	movabs 0x98043ce73c9b042d,%al
 1a1:	04 98 
 1a3:	3d da 3d 00 04       	cmp    $0x4003dda,%eax
 1a8:	9b                   	fwait
 1a9:	3c e5                	cmp    $0xe5,%al
 1ab:	3c 04                	cmp    $0x4,%al
 1ad:	98                   	cwtl
 1ae:	3d aa 3d 00 04       	cmp    $0x4003daa,%eax
 1b3:	b4 34                	mov    $0x34,%ah
 1b5:	9e                   	sahf
  struct vip_definition vip = {};
 1b6:	35 04 e7 36 c5       	xor    $0xc536e704,%eax
 1bb:	38 04 af             	cmp    %al,(%rdi,%rbp,4)
 1be:	39 f5                	cmp    %esi,%ebp
 1c0:	39 00                	cmp    %eax,(%rax)
 1c2:	04 c4                	add    $0xc4,%al
 1c4:	34 9e                	xor    $0x9e,%al
 1c6:	35 04 e7 36 fa       	xor    $0xfa36e704,%eax
 1cb:	36 00 04 86          	ss add %al,(%rsi,%rax,4)
 1cf:	37                   	(bad)
 1d0:	8b 37                	mov    (%rdi),%esi
 1d2:	04 aa                	add    $0xaa,%al
 1d4:	37                   	(bad)
 1d5:	f9                   	stc
    if (ip6h + 1 > data_end) {
 1d6:	37                   	(bad)
 1d7:	00 04 9a             	add    %al,(%rdx,%rbx,4)
 1da:	38 a0 38 04 a2 38    	cmp    %ah,0x38a20438(%rax)
 1e0:	ae                   	scas   %es:(%rdi),%al
 1e1:	38 00                	cmp    %al,(%rax)
    *protocol = ip6h->nexthdr;
 1e3:	04 9a                	add    $0x9a,%al
 1e5:	38 a0 38 04 a2 38    	cmp    %ah,0x38a20438(%rax)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1eb:	ae                   	scas   %es:(%rdi),%al
 1ec:	38 00                	cmp    %al,(%rax)
 1ee:	04 9a                	add    $0x9a,%al
 1f0:	38 a0 38 04 a2 38    	cmp    %ah,0x38a20438(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1f6:	ae                   	scas   %es:(%rdi),%al
 1f7:	38 00                	cmp    %al,(%rax)
 1f9:	04 86                	add    $0x86,%al
 1fb:	03 c2                	add    %edx,%eax
 1fd:	04 04                	add    $0x4,%al
 1ff:	b2 05                	mov    $0x5,%dl
    if (*protocol == IPPROTO_FRAGMENT) {
 201:	87 07                	xchg   %eax,(%rdi)
 203:	04 95                	add    $0x95,%al
 205:	08 cd                	or     %cl,%ch
 207:	08 04 a4             	or     %al,(%rsp,%riz,4)
 20a:	09 dc                	or     %ebx,%esp
 20c:	09 04 a5 0a 91 10 04 	or     %eax,0x410910a(,%riz,4)
 213:	c5 16 de             	(bad)
  if (icmp_hdr + 1 > data_end) {
 216:	18 04 a3             	sbb    %al,(%rbx,%riz,4)
 219:	19 f8                	sbb    %edi,%eax
 21b:	26 04 c5             	es add $0xc5,%al
 21e:	27                   	(bad)
 21f:	ca 28 04             	lret   $0x428
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 222:	be 29 de 2a 04       	mov    $0x42ade29,%esi
 227:	bf 2b 90 2c 04       	mov    $0x42c902b,%edi
 22c:	92                   	xchg   %eax,%edx
 22d:	3b 9b 3c 00 04 d6    	cmp    -0x29fbffc4(%rbx),%ebx
 233:	03 95 04 04 b2 05    	add    0x5b20404(%rbp),%edx
 239:	d2 05 00 04 95 04    	rolb   %cl,0x4950400(%rip)        # 495063f <_license+0x494e74c>
 23f:	c2 04 04             	ret    $0x404
 242:	d2 05 87 07 04 a5    	rolb   %cl,-0x5afbf879(%rip)        # ffffffffa50409cf <server_id_map+0x36fc6485c9cf>
 248:	0a a7 0b 04 d1 0e    	or     0xed1040b(%rdi),%ah
 24e:	d1 0f                	rorl   (%rdi)
 250:	00 04 95 04 c2 04 04 	add    %al,0x404c204(,%rdx,4)
 257:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
 258:	0a a7 0b 00 04 da    	or     -0x25fbfff5(%rdi),%ah
 25e:	05 87 07 04 d1       	add    $0xd1040787,%eax
 263:	0e                   	(bad)
 264:	d1 0f                	rorl   (%rdi)
 266:	00 04 84             	add    %al,(%rsp,%rax,4)
 269:	0e                   	(bad)
 26a:	d1 0e                	rorl   (%rsi)
 26c:	04 ee                	add    $0xee,%al
 26e:	17                   	(bad)
 26f:	de 18                	ficomps (%rax)
 271:	04 a3                	add    $0xa3,%al
 273:	19 e7                	sbb    %esp,%edi
 275:	19 04 c5 27 ca 28 04 	sbb    %eax,0x428ca27(,%rax,8)
 27c:	be 29 de 2a 04       	mov    $0x42ade29,%esi
 281:	bf 2b 90 2c 04       	mov    $0x42c902b,%edi
 286:	92                   	xchg   %eax,%edx
 287:	3b 91 3c 00 04 ab    	cmp    -0x54fbffc4(%rcx),%edx
 28d:	0e                   	(bad)
 28e:	c8 0e 04 ee          	enter  $0x40e,$0xee
 292:	17                   	(bad)
 293:	de 18                	ficomps (%rax)
 295:	04 a3                	add    $0xa3,%al
 297:	19 b9 19 04 c5 27    	sbb    %edi,0x27c50419(%rcx)
 29d:	ac                   	lods   %ds:(%rsi),%al
 29e:	28 00                	sub    %al,(%rax)
 2a0:	04 a3                	add    $0xa3,%al
 2a2:	19 b9 19 04 c5 27    	sbb    %edi,0x27c50419(%rcx)
 2a8:	d4                   	(bad)
 2a9:	27                   	(bad)
 2aa:	00 04 bb             	add    %al,(%rbx,%rdi,4)
 2ad:	28 ca                	sub    %cl,%dl
 2af:	28 04 be             	sub    %al,(%rsi,%rdi,4)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2b2:	29 de                	sub    %ebx,%esi
 2b4:	2a 04 bf             	sub    (%rdi,%rdi,4),%al
 2b7:	2b 90 2c 04 92 3b    	sub    0x3b92042c(%rax),%edx
 2bd:	91                   	xchg   %eax,%ecx
 2be:	3c 00                	cmp    $0x0,%al
 2c0:	04 bb                	add    $0xbb,%al
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2c2:	28 ca                	sub    %cl,%dl
 2c4:	28 04 be             	sub    %al,(%rsi,%rdi,4)
 2c7:	29 c3                	sub    %eax,%ebx
 2c9:	29 00                	sub    %eax,(%rax)
 2cb:	04 e1                	add    $0xe1,%al
 2cd:	29 c5                	sub    %eax,%ebp
 2cf:	2a 04 bf             	sub    (%rdi,%rdi,4),%al
  if (protocol == IPPROTO_ICMPV6) {
 2d2:	2b 90 2c 04 92 3b    	sub    0x3b92042c(%rax),%edx
 2d8:	91                   	xchg   %eax,%ecx
 2d9:	3c 00                	cmp    $0x0,%al
  if (icmp_hdr + 1 > data_end) {
 2db:	04 a4                	add    $0xa4,%al
 2dd:	2a bb 2a 04 bf 2b    	sub    0x2bbf042a(%rbx),%bh
 2e3:	90                   	nop
 2e4:	2c 04                	sub    $0x4,%al
 2e6:	92                   	xchg   %eax,%edx
  if (icmp_hdr->type == ICMP_ECHO) {
 2e7:	3b 94 3b 04 c5 3b 87 	cmp    -0x78c43afc(%rbx,%rdi,1),%edx
 2ee:	3c 00                	cmp    $0x0,%al
 2f0:	04 bf                	add    $0xbf,%al
 2f2:	2b 90 2c 04 c5 3b    	sub    0x3bc5042c(%rax),%edx
 2f8:	d7                   	xlat   %ds:(%rbx)
 2f9:	3b 00                	cmp    (%rax),%eax
 2fb:	04 a7                	add    $0xa7,%al
 2fd:	17                   	(bad)
 2fe:	de 17                	ficoms (%rdi)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 300:	04 f0                	add    $0xf0,%al
 302:	19 9c 1a 00 04 89 1f 	sbb    %ebx,0x1f890400(%rdx,%rbx,1)
       sizeof(struct icmphdr)) > data_end) {
 309:	f7 1f                	negl   (%rdi)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 30b:	04 a5                	add    $0xa5,%al
 30d:	21 b4 25 00 04 99 1f 	and    %esi,0x1f990400(%rbp,%riz,1)
  icmp_hdr->type = ICMP_ECHOREPLY;
 314:	f7 1f                	negl   (%rdi)
  icmp_hdr->checksum += 0x0008;
 316:	04 a5                	add    $0xa5,%al
 318:	21 bc 21 00 04 c7 21 	and    %edi,0x21c70400(%rcx,%riz,1)
  iph->ttl = DEFAULT_TTL;
 31f:	e2 21                	loop   342 <balancer_ingress+0x342>
  iph->daddr = iph->saddr;
 321:	04 8f                	add    $0x8f,%al
 323:	22 96 24 00 04 ca    	and    -0x35fbffdc(%rsi),%dl
 329:	21 e2                	and    %esp,%edx
 32b:	21 04 8f             	and    %eax,(%rdi,%rcx,4)
  iph->saddr = tmp_addr;
 32e:	22 c0                	and    %al,%al
 330:	23 00                	and    (%rax),%eax
    *csum += *next_iph_u16++;
 332:	04 b7                	add    $0xb7,%al
 334:	24 bd                	and    $0xbd,%al
 336:	24 04                	and    $0x4,%al
 338:	c3                   	ret
 339:	24 cf                	and    $0xcf,%al
 33b:	24 00                	and    $0x0,%al
 33d:	04 b7                	add    $0xb7,%al
 33f:	24 bd                	and    $0xbd,%al
 341:	24 04                	and    $0x4,%al
 343:	c3                   	ret
 344:	24 cf                	and    $0xcf,%al
 346:	24 00                	and    $0x0,%al
 348:	04 b7                	add    $0xb7,%al
 34a:	24 bd                	and    $0xbd,%al
 34c:	24 04                	and    $0x4,%al
 34e:	c3                   	ret
 34f:	24 cf                	and    $0xcf,%al
 351:	24 00                	and    $0x0,%al

Disassembly of section .debug_str_offsets:

0000000000000000 <.debug_str_offsets>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	90                   	nop
   1:	05 00 00 05 00       	add    $0x50000,%eax
   6:	00 00                	add    %al,(%rax)
   8:	00 00                	add    %al,(%rax)
   a:	00 00                	add    %al,(%rax)
   c:	1c 00                	sbb    $0x0,%al
   e:	00 00                	add    %al,(%rax)
  10:	3a 00                	cmp    (%rax),%al
  12:	00 00                	add    %al,(%rax)
  14:	65 00 00             	add    %al,%gs:(%rax)
  17:	00 cd                	add    %cl,%ch
  void* data = (void*)(long)ctx->data;
  19:	00 00                	add    %al,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
  1b:	00 6e 00             	add    %ch,0x0(%rsi)
  1e:	00 00                	add    %al,(%rax)
  if (data + nh_off > data_end) {
  20:	82                   	(bad)
  21:	00 00                	add    %al,(%rax)
  23:	00 23                	add    %ah,(%rbx)
  25:	09 00                	or     %eax,(%rax)
  27:	00 95 00 00 00 99    	add    %dl,-0x67000000(%rbp)
  2d:	0b 00                	or     (%rax),%eax
  2f:	00 8c 00 00 00 99 00 	add    %cl,0x990000(%rax,%rax,1)
  eth_proto = eth->h_proto;
  36:	00 00                	add    %al,(%rax)
  38:	db 00                	fildl  (%rax)
  if (eth_proto == BE_ETH_P_IP) {
  3a:	00 00                	add    %al,(%rax)
  3c:	9f                   	lahf
  3d:	00 00                	add    %al,(%rax)
  3f:	00 b2 00 00 00 b8    	add    %dh,-0x48000000(%rdx)
  45:	00 00                	add    %al,(%rax)
  47:	00 c0                	add    %al,%al
  49:	00 00                	add    %al,(%rax)
  4b:	00 c4                	add    %al,%ah
  4d:	00 00                	add    %al,(%rax)
  4f:	00 d2                	add    %dl,%dl
  51:	00 00                	add    %al,(%rax)
  53:	00 d7                	add    %dl,%bh
  struct packet_description pckt = {};
  55:	00 00                	add    %al,(%rax)
  57:	00 e1                	add    %ah,%cl
  59:	00 00                	add    %al,(%rax)
  5b:	00 ed                	add    %ch,%ch
  5d:	00 00                	add    %al,(%rax)
  5f:	00 f7                	add    %dh,%bh
  61:	00 00                	add    %al,(%rax)
  63:	00 e3                	add    %ah,%bl
  65:	0c 00                	or     $0x0,%al
  67:	00 ff                	add    %bh,%bh
  69:	00 00                	add    %al,(%rax)
  6b:	00 06                	add    %al,(%rsi)
  6d:	01 00                	add    %eax,(%rax)
  6f:	00 f3                	add    %dh,%bl
  71:	06                   	(bad)
  72:	00 00                	add    %al,(%rax)
  74:	0c 01                	or     $0x1,%al
  76:	00 00                	add    %al,(%rax)
  78:	1b 01                	sbb    (%rcx),%eax
  7a:	00 00                	add    %al,(%rax)
  7c:	cb                   	lret
  7d:	0d 00 00 21 01       	or     $0x1210000,%eax
  82:	00 00                	add    %al,(%rax)
  struct vip_definition vip = {};
  84:	f1                   	int1
  85:	00 00                	add    %al,(%rax)
  87:	00 30                	add    %dh,(%rax)
  89:	01 00                	add    %eax,(%rax)
  8b:	00 38                	add    %bh,(%rax)
  8d:	01 00                	add    %eax,(%rax)
  8f:	00 41 01             	add    %al,0x1(%rcx)
  92:	00 00                	add    %al,(%rax)
  94:	3f                   	(bad)
  95:	0c 00                	or     $0x0,%al
  97:	00 50 01             	add    %dl,0x1(%rax)
  9a:	00 00                	add    %al,(%rax)
  9c:	fd                   	std
  9d:	0b 00                	or     (%rax),%eax
  9f:	00 56 01             	add    %dl,0x1(%rsi)
  a2:	00 00                	add    %al,(%rax)
    if (iph + 1 > data_end) {
  a4:	5c                   	pop    %rsp
  a5:	01 00                	add    %eax,(%rax)
  a7:	00 62 01             	add    %ah,0x1(%rdx)
  aa:	00 00                	add    %al,(%rax)
  ac:	69 01 00 00 75 07    	imul   $0x7750000,(%rcx),%eax
    if (iph->ihl != 5) {
  b2:	00 00                	add    %al,(%rax)
  b4:	72 01                	jb     b7 <balancer_ingress+0xb7>
  b6:	00 00                	add    %al,(%rax)
  b8:	78 01                	js     bb <balancer_ingress+0xbb>
  ba:	00 00                	add    %al,(%rax)
  bc:	85 01                	test   %eax,(%rcx)
    pckt->tos = iph->tos;
  be:	00 00                	add    %al,(%rax)
  c0:	91                   	xchg   %eax,%ecx
  c1:	01 00                	add    %eax,(%rax)
  c3:	00 98 01 00 00 a1    	add    %bl,-0x5effffff(%rax)
    pckt->flow.proto = *protocol;
  c9:	01 00                	add    %eax,(%rax)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  cb:	00 a7 01 00 00 b7    	add    %ah,-0x48ffffff(%rdi)
  d1:	01 00                	add    %eax,(%rax)
  d3:	00 62 02             	add    %ah,0x2(%rdx)
  d6:	00 00                	add    %al,(%rax)
  d8:	69 02 00 00 c3 01    	imul   $0x1c30000,(%rdx),%eax
  de:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
  e0:	b3 0c                	mov    $0xc,%bl
  e2:	00 00                	add    %al,(%rax)
  e4:	cc                   	int3
  e5:	01 00                	add    %eax,(%rax)
  e7:	00 ac 08 00 00 db 01 	add    %ch,0x1db0000(%rax,%rcx,1)
  if (icmp_hdr + 1 > data_end) {
  ee:	00 00                	add    %al,(%rax)
  f0:	ea                   	(bad)
  f1:	01 00                	add    %eax,(%rax)
  f3:	00 f4                	add    %dh,%ah
  f5:	01 00                	add    %eax,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
  f7:	00 00                	add    %al,(%rax)
  f9:	02 00                	add    (%rax),%al
  fb:	00 16                	add    %dl,(%rsi)
  fd:	02 00                	add    (%rax),%al
  ff:	00 33                	add    %dh,(%rbx)
 101:	02 00                	add    (%rax),%al
 103:	00 3e                	add    %bh,(%rsi)
 105:	02 00                	add    (%rax),%al
 107:	00 57 02             	add    %dl,0x2(%rdi)
 10a:	00 00                	add    %al,(%rax)
 10c:	5e                   	pop    %rsi
 10d:	02 00                	add    (%rax),%al
 10f:	00 65 02             	add    %ah,0x2(%rbp)
 112:	00 00                	add    %al,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
 114:	6c                   	insb   (%dx),%es:(%rdi)
 115:	02 00                	add    (%rax),%al
 117:	00 73 02             	add    %dh,0x2(%rbx)
  icmp_hdr->checksum += 0x0008;
 11a:	00 00                	add    %al,(%rax)
 11c:	84 02                	test   %al,(%rdx)
 11e:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 120:	98                   	cwtl
 121:	02 00                	add    (%rax),%al
 123:	00 ad 02 00 00 c3    	add    %ch,-0x3cfffffe(%rbp)
  tmp_addr = iph->daddr;
 129:	02 00                	add    (%rax),%al
 12b:	00 d3                	add    %dl,%bl
  iph->daddr = iph->saddr;
 12d:	02 00                	add    (%rax),%al
 12f:	00 e7                	add    %ah,%bh
  iph->saddr = tmp_addr;
 131:	02 00                	add    (%rax),%al
 133:	00 02                	add    %al,(%rdx)
 135:	03 00                	add    (%rax),%eax
 137:	00 12                	add    %dl,(%rdx)
 139:	03 00                	add    (%rax),%eax
 13b:	00 20                	add    %ah,(%rax)
 13d:	03 00                	add    (%rax),%eax
 13f:	00 2e                	add    %ch,(%rsi)
 141:	03 00                	add    (%rax),%eax
 143:	00 39                	add    %bh,(%rcx)
 145:	03 00                	add    (%rax),%eax
 147:	00 41 03             	add    %al,0x3(%rcx)
 14a:	00 00                	add    %al,(%rax)
 14c:	56                   	push   %rsi
 14d:	03 00                	add    (%rax),%eax
 14f:	00 66 03             	add    %ah,0x3(%rsi)
 152:	00 00                	add    %al,(%rax)
 154:	7c 03                	jl     159 <balancer_ingress+0x159>
 156:	00 00                	add    %al,(%rax)
 158:	95                   	xchg   %eax,%ebp
 159:	03 00                	add    (%rax),%eax
 15b:	00 ae 03 00 00 bf    	add    %ch,-0x40fffffd(%rsi)
 161:	03 00                	add    (%rax),%eax
 163:	00 d3                	add    %dl,%bl
 165:	03 00                	add    (%rax),%eax
 167:	00 e7                	add    %ah,%bh
    if (csum >> 16)
 169:	03 00                	add    (%rax),%eax
 16b:	00 f3                	add    %dh,%bl
 16d:	03 00                	add    (%rax),%eax
 16f:	00 fc                	add    %bh,%ah
 171:	03 00                	add    (%rax),%eax
 173:	00 05 04 00 00 0c    	add    %al,0xc000004(%rip)        # c00017d <_license+0xbffe28a>
 179:	04 00                	add    $0x0,%al
 17b:	00 19                	add    %bl,(%rcx)
 17d:	04 00                	add    $0x0,%al
 17f:	00 24 04             	add    %ah,(%rsp,%rax,1)
 182:	00 00                	add    %al,(%rax)
 184:	2f                   	(bad)
 185:	04 00                	add    $0x0,%al
  struct packet_description pckt = {};
 187:	00 3c 04             	add    %bh,(%rsp,%rax,1)
 18a:	00 00                	add    %al,(%rax)
 18c:	49 04 00             	rex.WB add $0x0,%al
 18f:	00 56 04             	add    %dl,0x4(%rsi)
 192:	00 00                	add    %al,(%rax)
 194:	62                   	(bad)
 195:	04 00                	add    $0x0,%al
 197:	00 6e 04             	add    %ch,0x4(%rsi)
 19a:	00 00                	add    %al,(%rax)
 19c:	7a 04                	jp     1a2 <balancer_ingress+0x1a2>
 19e:	00 00                	add    %al,(%rax)
 1a0:	86 04 00             	xchg   %al,(%rax,%rax,1)
 1a3:	00 92 04 00 00 9d    	add    %dl,-0x62fffffc(%rdx)
 1a9:	04 00                	add    $0x0,%al
 1ab:	00 aa 04 00 00 b7    	add    %ch,-0x48fffffc(%rdx)
 1b1:	04 00                	add    $0x0,%al
 1b3:	00 c4                	add    %al,%ah
 1b5:	04 00                	add    $0x0,%al
  struct vip_definition vip = {};
 1b7:	00 d0                	add    %dl,%al
 1b9:	04 00                	add    $0x0,%al
 1bb:	00 dc                	add    %bl,%ah
 1bd:	04 00                	add    $0x0,%al
 1bf:	00 e7                	add    %ah,%bh
 1c1:	04 00                	add    $0x0,%al
 1c3:	00 f3                	add    %dh,%bl
 1c5:	04 00                	add    $0x0,%al
 1c7:	00 02                	add    %al,(%rdx)
 1c9:	05 00 00 10 05       	add    $0x5100000,%eax
 1ce:	00 00                	add    %al,(%rax)
 1d0:	1c 05                	sbb    $0x5,%al
 1d2:	00 00                	add    %al,(%rax)
 1d4:	29 05 00 00 36 05    	sub    %eax,0x5360000(%rip)        # 53601da <_license+0x535e2e7>
    if (ip6h + 1 > data_end) {
 1da:	00 00                	add    %al,(%rax)
 1dc:	43 05 00 00 53 05    	rex.XB add $0x5530000,%eax
 1e2:	00 00                	add    %al,(%rax)
    *protocol = ip6h->nexthdr;
 1e4:	60                   	(bad)
 1e5:	05 00 00 71 05       	add    $0x5710000,%eax
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1ea:	00 00                	add    %al,(%rax)
 1ec:	81 05 00 00 8d 05 00 	addl   $0x5990000,0x58d0000(%rip)        # 58d01f6 <_license+0x58ce303>
 1f3:	00 99 05 
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1f6:	00 00                	add    %al,(%rax)
 1f8:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
 1f9:	05 00 00 ad 00       	add    $0xad0000,%eax
 1fe:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_FRAGMENT) {
 200:	4b 07                	rex.WXB (bad)
 202:	00 00                	add    %al,(%rax)
 204:	b3 05                	mov    $0x5,%bl
 206:	00 00                	add    %al,(%rax)
 208:	c0 05 00 00 d2 05 00 	rolb   $0x0,0x5d20000(%rip)        # 5d2020f <_license+0x5d1e31c>
 20f:	00 c4                	add    %al,%ah
 211:	05 00 00 e3 05       	add    $0x5e30000,%eax
  if (icmp_hdr + 1 > data_end) {
 216:	00 00                	add    %al,(%rax)
 218:	9b                   	fwait
 219:	00 00                	add    %al,(%rax)
 21b:	00 f5                	add    %dh,%ch
 21d:	05 00 00 04 06       	add    $0x6040000,%eax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 222:	00 00                	add    %al,(%rax)
 224:	a8 0a                	test   $0xa,%al
 226:	00 00                	add    %al,(%rax)
 228:	08 06                	or     %al,(%rsi)
 22a:	00 00                	add    %al,(%rax)
 22c:	11 06                	adc    %eax,(%rsi)
 22e:	00 00                	add    %al,(%rax)
 230:	1b 06                	sbb    (%rsi),%eax
 232:	00 00                	add    %al,(%rax)
 234:	2b 06                	sub    (%rsi),%eax
 236:	00 00                	add    %al,(%rax)
 238:	2f                   	(bad)
 239:	06                   	(bad)
 23a:	00 00                	add    %al,(%rax)
 23c:	3c 06                	cmp    $0x6,%al
 23e:	00 00                	add    %al,(%rax)
 240:	40 06                	rex (bad)
 242:	00 00                	add    %al,(%rax)
 244:	4d 06                	rex.WRB (bad)
 246:	00 00                	add    %al,(%rax)
 248:	56                   	push   %rsi
 249:	06                   	(bad)
 24a:	00 00                	add    %al,(%rax)
 24c:	5d                   	pop    %rbp
 24d:	06                   	(bad)
 24e:	00 00                	add    %al,(%rax)
 250:	64 06                	fs (bad)
 252:	00 00                	add    %al,(%rax)
 254:	6c                   	insb   (%dx),%es:(%rdi)
 255:	06                   	(bad)
 256:	00 00                	add    %al,(%rax)
 258:	72 06                	jb     260 <balancer_ingress+0x260>
 25a:	00 00                	add    %al,(%rax)
 25c:	77 06                	ja     264 <balancer_ingress+0x264>
 25e:	00 00                	add    %al,(%rax)
 260:	7c 06                	jl     268 <balancer_ingress+0x268>
 262:	00 00                	add    %al,(%rax)
 264:	87 06                	xchg   %eax,(%rsi)
 266:	00 00                	add    %al,(%rax)
 268:	8b 06                	mov    (%rsi),%eax
 26a:	00 00                	add    %al,(%rax)
 26c:	9e                   	sahf
 26d:	06                   	(bad)
 26e:	00 00                	add    %al,(%rax)
 270:	ab                   	stos   %eax,%es:(%rdi)
 271:	06                   	(bad)
 272:	00 00                	add    %al,(%rax)
 274:	1d 04 00 00 b2       	sbb    $0xb2000004,%eax
 279:	06                   	(bad)
 27a:	00 00                	add    %al,(%rax)
 27c:	bb 06 00 00 cb       	mov    $0xcb000006,%ebx
 281:	0c 00                	or     $0x0,%al
 283:	00 c4                	add    %al,%ah
 285:	06                   	(bad)
 286:	00 00                	add    %al,(%rax)
 288:	cf                   	iret
 289:	06                   	(bad)
 28a:	00 00                	add    %al,(%rax)
 28c:	d7                   	xlat   %ds:(%rbx)
 28d:	06                   	(bad)
 28e:	00 00                	add    %al,(%rax)
 290:	df 06                	filds  (%rsi)
 292:	00 00                	add    %al,(%rax)
 294:	e9 06 00 00 f8       	jmp    fffffffff800029f <server_id_map+0x36fcb781c29f>
 299:	06                   	(bad)
 29a:	00 00                	add    %al,(%rax)
 29c:	fd                   	std
 29d:	06                   	(bad)
 29e:	00 00                	add    %al,(%rax)
 2a0:	05 07 00 00 0c       	add    $0xc000007,%eax
 2a5:	07                   	(bad)
 2a6:	00 00                	add    %al,(%rax)
 2a8:	1a 07                	sbb    (%rdi),%al
 2aa:	00 00                	add    %al,(%rax)
 2ac:	24 07                	and    $0x7,%al
 2ae:	00 00                	add    %al,(%rax)
 2b0:	2c 07                	sub    $0x7,%al
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2b2:	00 00                	add    %al,(%rax)
 2b4:	b0 02                	mov    $0x2,%al
 2b6:	00 00                	add    %al,(%rax)
 2b8:	43 07                	rex.XB (bad)
 2ba:	00 00                	add    %al,(%rax)
 2bc:	0c 02                	or     $0x2,%al
 2be:	00 00                	add    %al,(%rax)
 2c0:	47 07                	rex.RXB (bad)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2c2:	00 00                	add    %al,(%rax)
 2c4:	53                   	push   %rbx
 2c5:	07                   	(bad)
 2c6:	00 00                	add    %al,(%rax)
 2c8:	5e                   	pop    %rsi
 2c9:	07                   	(bad)
 2ca:	00 00                	add    %al,(%rax)
 2cc:	70 07                	jo     2d5 <balancer_ingress+0x2d5>
 2ce:	00 00                	add    %al,(%rax)
 2d0:	79 07                	jns    2d9 <balancer_ingress+0x2d9>
  if (protocol == IPPROTO_ICMPV6) {
 2d2:	00 00                	add    %al,(%rax)
 2d4:	7d 07                	jge    2dd <balancer_ingress+0x2dd>
 2d6:	00 00                	add    %al,(%rax)
 2d8:	87 07                	xchg   %eax,(%rdi)
  if (icmp_hdr + 1 > data_end) {
 2da:	00 00                	add    %al,(%rax)
 2dc:	8b 07                	mov    (%rdi),%eax
 2de:	00 00                	add    %al,(%rax)
 2e0:	9c                   	pushf
 2e1:	07                   	(bad)
 2e2:	00 00                	add    %al,(%rax)
 2e4:	a0 07 00 00 a4 07 00 	movabs 0xac000007a4000007,%al
 2eb:	00 ac 
  if (icmp_hdr->type == ICMP_ECHO) {
 2ed:	07                   	(bad)
 2ee:	00 00                	add    %al,(%rax)
 2f0:	cf                   	iret
 2f1:	05 00 00 b3 07       	add    $0x7b30000,%eax
 2f6:	00 00                	add    %al,(%rax)
 2f8:	bc 07 00 00 c0       	mov    $0xc0000007,%esp
 2fd:	07                   	(bad)
 2fe:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 300:	c6 07 00             	movb   $0x0,(%rdi)
 303:	00 ce                	add    %cl,%dh
 305:	07                   	(bad)
 306:	00 00                	add    %al,(%rax)
       sizeof(struct icmphdr)) > data_end) {
 308:	d4                   	(bad)
 309:	07                   	(bad)
 30a:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 30c:	da 07                	fiaddl (%rdi)
 30e:	00 00                	add    %al,(%rax)
 310:	e0 07                	loopne 319 <balancer_ingress+0x319>
  icmp_hdr->type = ICMP_ECHOREPLY;
 312:	00 00                	add    %al,(%rax)
 314:	e6 07                	out    %al,$0x7
  icmp_hdr->checksum += 0x0008;
 316:	00 00                	add    %al,(%rax)
 318:	eb 07                	jmp    321 <balancer_ingress+0x321>
 31a:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 31c:	f4                   	hlt
 31d:	07                   	(bad)
 31e:	00 00                	add    %al,(%rax)
 320:	fd                   	std
  iph->daddr = iph->saddr;
 321:	07                   	(bad)
 322:	00 00                	add    %al,(%rax)
 324:	09 08                	or     %ecx,(%rax)
  tmp_addr = iph->daddr;
 326:	00 00                	add    %al,(%rax)
 328:	11 08                	adc    %ecx,(%rax)
  iph->daddr = iph->saddr;
 32a:	00 00                	add    %al,(%rax)
 32c:	1b 08                	sbb    (%rax),%ecx
  iph->saddr = tmp_addr;
 32e:	00 00                	add    %al,(%rax)
 330:	21 08                	and    %ecx,(%rax)
    *csum += *next_iph_u16++;
 332:	00 00                	add    %al,(%rax)
 334:	2a 08                	sub    (%rax),%cl
 336:	00 00                	add    %al,(%rax)
 338:	34 08                	xor    $0x8,%al
 33a:	00 00                	add    %al,(%rax)
 33c:	3e 08 00             	ds or  %al,(%rax)
 33f:	00 47 08             	add    %al,0x8(%rdi)
 342:	00 00                	add    %al,(%rax)
 344:	4f 08 00             	rex.WRXB or %r8b,(%r8)
 347:	00 b8 07 00 00 5a    	add    %bh,0x5a000007(%rax)
 34d:	08 00                	or     %al,(%rax)
 34f:	00 2e                	add    %ch,(%rsi)
 351:	09 00                	or     %eax,(%rax)
 353:	00 63 08             	add    %ah,0x8(%rbx)
 356:	00 00                	add    %al,(%rax)
 358:	49 09 00             	or     %rax,(%r8)
 35b:	00 82 09 00 00 6c    	add    %al,0x6c000009(%rdx)
 361:	08 00                	or     %al,(%rax)
 363:	00 75 08             	add    %dh,0x8(%rbp)
 366:	00 00                	add    %al,(%rax)
 368:	7d 08                	jge    372 <balancer_ingress+0x372>
 36a:	00 00                	add    %al,(%rax)
 36c:	82                   	(bad)
 36d:	08 00                	or     %al,(%rax)
 36f:	00 8b 08 00 00 8f    	add    %cl,-0x70fffff8(%rbx)
    if (csum >> 16)
 375:	08 00                	or     %al,(%rax)
 377:	00 98 08 00 00 a0    	add    %bl,-0x5ffffff8(%rax)
 37d:	08 00                	or     %al,(%rax)
 37f:	00 b2 08 00 00 c1    	add    %dh,-0x3efffff8(%rdx)
 385:	08 00                	or     %al,(%rax)
 387:	00 d1                	add    %dl,%cl
 389:	08 00                	or     %al,(%rax)
 38b:	00 da                	add    %bl,%dl
 38d:	08 00                	or     %al,(%rax)
 38f:	00 df                	add    %bl,%bh
 391:	08 00                	or     %al,(%rax)
 393:	00 f0                	add    %dh,%al
 395:	08 00                	or     %al,(%rax)
 397:	00 fd                	add    %bh,%ch
 399:	08 00                	or     %al,(%rax)
 39b:	00 ff                	add    %bh,%bh
 39d:	08 00                	or     %al,(%rax)
 39f:	00 10                	add    %dl,(%rax)
 3a1:	09 00                	or     %eax,(%rax)
 3a3:	00 1d 09 00 00 28    	add    %bl,0x28000009(%rip)        # 280003b2 <_license+0x27ffe4bf>
 3a9:	09 00                	or     %eax,(%rax)
 3ab:	00 33                	add    %dh,(%rbx)
 3ad:	09 00                	or     %eax,(%rax)
 3af:	00 3f                	add    %bh,(%rdi)
 3b1:	09 00                	or     %eax,(%rax)
 3b3:	00 4c 09 00          	add    %cl,0x0(%rcx,%rcx,1)
 3b7:	00 56 09             	add    %dl,0x9(%rsi)
 3ba:	00 00                	add    %al,(%rax)
 3bc:	60                   	(bad)
 3bd:	09 00                	or     %eax,(%rax)
 3bf:	00 69 09             	add    %ch,0x9(%rcx)
 3c2:	00 00                	add    %al,(%rax)
 3c4:	70 09                	jo     3cf <balancer_ingress+0x3cf>
 3c6:	00 00                	add    %al,(%rax)
 3c8:	7b 09                	jnp    3d3 <balancer_ingress+0x3d3>
 3ca:	00 00                	add    %al,(%rax)
 3cc:	87 09                	xchg   %ecx,(%rcx)
 3ce:	00 00                	add    %al,(%rax)
 3d0:	91                   	xchg   %eax,%ecx
 3d1:	09 00                	or     %eax,(%rax)
 3d3:	00 9a 09 00 00 a4    	add    %bl,-0x5bfffff7(%rdx)
 3d9:	09 00                	or     %eax,(%rax)
 3db:	00 ab 09 00 00 b5    	add    %ch,-0x4afffff7(%rbx)
 3e1:	09 00                	or     %eax,(%rax)
 3e3:	00 c4                	add    %al,%ah
 3e5:	09 00                	or     %eax,(%rax)
 3e7:	00 cc                	add    %cl,%ah
 3e9:	09 00                	or     %eax,(%rax)
 3eb:	00 d8                	add    %bl,%al
 3ed:	09 00                	or     %eax,(%rax)
 3ef:	00 e3                	add    %ah,%bl
 3f1:	09 00                	or     %eax,(%rax)
 3f3:	00 e9                	add    %ch,%cl
 3f5:	09 00                	or     %eax,(%rax)
 3f7:	00 f1                	add    %dh,%cl
 3f9:	09 00                	or     %eax,(%rax)
 3fb:	00 fd                	add    %bh,%ch
 3fd:	09 00                	or     %eax,(%rax)
 3ff:	00 0a                	add    %cl,(%rdx)
 401:	0a 00                	or     (%rax),%al
 403:	00 13                	add    %dl,(%rbx)
 405:	0a 00                	or     (%rax),%al
 407:	00 25 0a 00 00 2b    	add    %ah,0x2b00000a(%rip)        # 2b000417 <_license+0x2affe524>
 40d:	0a 00                	or     (%rax),%al
 40f:	00 ce                	add    %cl,%dh
 411:	0b 00                	or     (%rax),%eax
 413:	00 c7                	add    %al,%bh
  if (protocol == IPPROTO_TCP) {
 415:	0b 00                	or     (%rax),%eax
 417:	00 33                	add    %dh,(%rbx)
 419:	0a 00                	or     (%rax),%al
 41b:	00 2f                	add    %ch,(%rdi)
 41d:	0a 00                	or     (%rax),%al
 41f:	00 37                	add    %dh,(%rdi)
 421:	0a 00                	or     (%rax),%al
 423:	00 3a                	add    %bh,(%rdx)
  tcp = data + off;
 425:	0a 00                	or     (%rax),%al
 427:	00 3f                	add    %bh,(%rdi)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 429:	0a 00                	or     (%rax),%al
 42b:	00 44 0a 00          	add    %al,0x0(%rdx,%rcx,1)
  tcp = data + off;
 42f:	00 3d 03 00 00 48    	add    %bh,0x48000003(%rip)        # 48000438 <_license+0x47ffe545>
  if (tcp + 1 > data_end) {
 435:	0a 00                	or     (%rax),%al
 437:	00 4c 0a 00          	add    %cl,0x0(%rdx,%rcx,1)
 43b:	00 50 0a             	add    %dl,0xa(%rax)
  if (tcp->syn) {
 43e:	00 00                	add    %al,(%rax)
 440:	54                   	push   %rsp
 441:	0a 00                	or     (%rax),%al
    pckt->flags |= F_SYN_SET;
 443:	00 58 0a             	add    %bl,0xa(%rax)
 446:	00 00                	add    %al,(%rax)
 448:	5c                   	pop    %rsp
 449:	0a 00                	or     (%rax),%al
 44b:	00 60 0a             	add    %ah,0xa(%rax)
      pckt->flow.src = iph->saddr;
 44e:	00 00                	add    %al,(%rax)
 450:	67 0a 00             	or     (%eax),%al
 453:	00 6f 0a             	add    %ch,0xa(%rdi)
      pckt->flow.dst = iph->daddr;
 456:	00 00                	add    %al,(%rax)
 458:	76 0a                	jbe    464 <balancer_ingress+0x464>
 45a:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 45c:	87 0a                	xchg   %ecx,(%rdx)
 45e:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 460:	8d 0a                	lea    (%rdx),%ecx
 462:	00 00                	add    %al,(%rax)
 464:	05 08 00 00 91       	add    $0x91000008,%eax
 469:	0a 00                	or     (%rax),%al
 46b:	00 98 0a 00 00 69    	add    %bl,0x6900000a(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 471:	07                   	(bad)
 472:	00 00                	add    %al,(%rax)
 474:	a3 0a 00 00 ad 0a 00 	movabs %eax,0xb600000aad00000a
 47b:	00 b6 
 47d:	0a 00                	or     (%rax),%al
 47f:	00 bd 0a 00 00 d7    	add    %bh,-0x28fffff6(%rbp)
 485:	05 00 00 cb 0a       	add    $0xacb0000,%eax
 48a:	00 00                	add    %al,(%rax)
 48c:	e4 0a                	in     $0xa,%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 48e:	00 00                	add    %al,(%rax)
 490:	70 0b                	jo     49d <balancer_ingress+0x49d>
 492:	00 00                	add    %al,(%rax)
 494:	fc                   	cld
 495:	0a 00                	or     (%rax),%al
       sizeof(struct icmp6hdr)) > data_end) {
 497:	00 05 0c 00 00 08    	add    %al,0x800000c(%rip)        # 80004a9 <_license+0x7ffe5b6>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 49d:	0b 00                	or     (%rax),%eax
 49f:	00 11                	add    %dl,(%rcx)
 4a1:	0b 00                	or     (%rax),%eax
 4a3:	00 2e                	add    %ch,(%rsi)
  udp = data + off;
 4a5:	0b 00                	or     (%rax),%eax
 4a7:	00 36                	add    %dh,(%rsi)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 4a9:	0b 00                	or     (%rax),%eax
  udp = data + off;
 4ab:	00 44 0b 00          	add    %al,0x0(%rbx,%rcx,1)
  if (udp + 1 > data_end) {
 4af:	00 52 0b             	add    %dl,0xb(%rdx)
 4b2:	00 00                	add    %al,(%rax)
 4b4:	6d                   	insl   (%dx),%es:(%rdi)
 4b5:	03 00                	add    (%rax),%eax
 4b7:	00 6b 0b             	add    %ch,0xb(%rbx)
 4ba:	00 00                	add    %al,(%rax)
 4bc:	75 0b                	jne    4c9 <balancer_ingress+0x4c9>
 4be:	00 00                	add    %al,(%rax)
 4c0:	80 0b 00             	orb    $0x0,(%rbx)
 4c3:	00 8f 0b 00 00 9d    	add    %cl,-0x62fffff5(%rdi)
 4c9:	0b 00                	or     (%rax),%eax
 4cb:	00 ad 0b 00 00 b6    	add    %ch,-0x49fffff5(%rbp)
 4d1:	0b 00                	or     (%rax),%eax
 4d3:	00 bd 0b 00 00 c5    	add    %bh,-0x3afffff5(%rbp)
 4d9:	0b 00                	or     (%rax),%eax
 4db:	00 cc                	add    %cl,%ah
 4dd:	0b 00                	or     (%rax),%eax
 4df:	00 c9                	add    %cl,%cl
 4e1:	0d 00 00 d5 0b       	or     $0xbd50000,%eax
 4e6:	00 00                	add    %al,(%rax)
 4e8:	dc 0b                	fmull  (%rbx)
 4ea:	00 00                	add    %al,(%rax)
 4ec:	e4 0b                	in     $0xb,%al
 4ee:	00 00                	add    %al,(%rax)
 4f0:	f2 0b 00             	repnz or (%rax),%eax
 4f3:	00 01                	add    %al,(%rcx)
  tcp = data + off;
 4f5:	0c 00                	or     $0x0,%al
 4f7:	00 83 0b 00 00 0d    	add    %al,0xd00000b(%rbx)
 4fd:	0c 00                	or     $0x0,%al
  if (tcp + 1 > data_end) {
 4ff:	00 5f 0c             	add    %bl,0xc(%rdi)
 502:	00 00                	add    %al,(%rax)
 504:	17                   	(bad)
 505:	0c 00                	or     $0x0,%al
 507:	00 24 0c             	add    %ah,(%rsp,%rcx,1)
 50a:	00 00                	add    %al,(%rax)
  if (tcp->syn) {
 50c:	2d 0c 00 00 43       	sub    $0x4300000c,%eax
 511:	0c 00                	or     $0x0,%al
 513:	00 51 0c             	add    %dl,0xc(%rcx)
    pckt->flags |= F_SYN_SET;
 516:	00 00                	add    %al,(%rax)
 518:	54                   	push   %rsp
 519:	0c 00                	or     $0x0,%al
 51b:	00 64 0c 00          	add    %ah,0x0(%rsp,%rcx,1)
 51f:	00 6a 0c             	add    %ch,0xc(%rdx)
 522:	00 00                	add    %al,(%rax)
 524:	71 0c                	jno    532 <balancer_ingress+0x532>
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
 526:	00 00                	add    %al,(%rax)
 528:	38 00                	cmp    %al,(%rax)
 52a:	00 00                	add    %al,(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
 52c:	08 0a                	or     %cl,(%rdx)
 52e:	00 00                	add    %al,(%rax)
 530:	79 0c                	jns    53e <balancer_ingress+0x53e>
 532:	00 00                	add    %al,(%rax)
 534:	52                   	push   %rdx
 535:	0a 00                	or     (%rax),%al
 537:	00 7b 0c             	add    %bh,0xc(%rbx)
 53a:	00 00                	add    %al,(%rax)
 53c:	81 0c 00 00 86 0c 00 	orl    $0xc8600,(%rax,%rax,1)
    if (!icmp_ptb_v6_stats) {
 543:	00 8c 0c 00 00 9b 0c 	add    %cl,0xc9b0000(%rsp,%rcx,1)
 54a:	00 00                	add    %al,(%rax)
    icmp_ptb_v6_stats->v1 += 1;
 54c:	a8 0c                	test   $0xc,%al
 54e:	00 00                	add    %al,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 550:	c2 0c 00             	ret    $0xc
 553:	00 d5                	add    %dl,%ch
 555:	0c 00                	or     $0x0,%al
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 557:	00 e7                	add    %ah,%bh
 559:	0c 00                	or     $0x0,%al
 55b:	00 f5                	add    %dh,%ch
 55d:	0c 00                	or     $0x0,%al
      icmp_ptb_v6_stats->v2 += 1;
 55f:	00 00                	add    %al,(%rax)
 561:	0d 00 00 0c 0d       	or     $0xd0c0000,%eax
  if (ip6h + 1 > data_end) {
 566:	00 00                	add    %al,(%rax)
 568:	16                   	(bad)
 569:	0d 00 00 24 0d       	or     $0xd240000,%eax
 56e:	00 00                	add    %al,(%rax)
 570:	45 0d 00 00 68 0d    	rex.RB or $0xd680000,%eax
  pckt->flow.proto = ip6h->nexthdr;
 576:	00 00                	add    %al,(%rax)
 578:	7a 0d                	jp     587 <balancer_ingress+0x587>
  pckt->flags |= F_ICMP;
 57a:	00 00                	add    %al,(%rax)
 57c:	8c 0d 00 00 9f 0d    	mov    %cs,0xd9f0000(%rip)        # d9f0582 <_license+0xd9ee68f>
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 582:	00 00                	add    %al,(%rax)
 584:	b2 0d                	mov    $0xd,%dl
 586:	00 00                	add    %al,(%rax)
 588:	c3                   	ret
 589:	0d 00 00 e0 0b       	or     $0xbe00000,%eax
 58e:	00 00                	add    %al,(%rax)
 590:	c7                   	(bad)
 591:	0d                   	.byte 0xd
	...

Disassembly of section .debug_str:

0000000000000000 <.debug_str>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	44                   	rex.R
   1:	65 62                	gs (bad)
   3:	69 61 6e 20 63 6c 61 	imul   $0x616c6320,0x6e(%rcx),%esp
   a:	6e                   	outsb  %ds:(%rsi),(%dx)
   b:	67 20 76 65          	and    %dh,0x65(%esi)
   f:	72 73                	jb     84 <balancer_ingress+0x84>
  11:	69 6f 6e 20 31 34 2e 	imul   $0x2e343120,0x6e(%rdi),%ebp
  void* data = (void*)(long)ctx->data;
  18:	30 2e                	xor    %ch,(%rsi)
  1a:	36 00 6b 61          	ss add %ch,0x61(%rbx)
  void* data_end = (void*)(long)ctx->data_end;
  1e:	74 72                	je     92 <balancer_ingress+0x92>
  if (data + nh_off > data_end) {
  20:	61                   	(bad)
  21:	6e                   	outsb  %ds:(%rsi),(%dx)
  22:	2f                   	(bad)
  23:	6c                   	insb   (%dx),%es:(%rdi)
  24:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
  2b:	62 61 6c 61 6e       	(bad)
  30:	63 65 72             	movsxd 0x72(%rbp),%esp
  33:	2e 62                	cs (bad)
  eth_proto = eth->h_proto;
  35:	70 66                	jo     9d <balancer_ingress+0x9d>
  37:	2e 63 00             	cs movsxd (%rax),%eax
  if (eth_proto == BE_ETH_P_IP) {
  3a:	2f                   	(bad)
  3b:	72 6f                	jb     ac <balancer_ingress+0xac>
  3d:	6f                   	outsl  %ds:(%rsi),(%dx)
  3e:	74 2f                	je     6f <balancer_ingress+0x6f>
  40:	57                   	push   %rdi
  41:	6f                   	outsl  %ds:(%rsi),(%dx)
  42:	72 6b                	jb     af <balancer_ingress+0xaf>
  44:	73 70                	jae    b6 <balancer_ingress+0xb6>
  46:	61                   	(bad)
  47:	63 65 2f             	movsxd 0x2f(%rbp),%esp
  4a:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  4e:	61                   	(bad)
  4f:	6e                   	outsb  %ds:(%rsi),(%dx)
  50:	2f                   	(bad)
  51:	5f                   	pop    %rdi
  52:	62 75                	(bad)
  struct packet_description pckt = {};
  54:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
  5b:	73 
  5c:	2f                   	(bad)
  5d:	62                   	(bad)
  5e:	70 66                	jo     c6 <balancer_ingress+0xc6>
  60:	70 72                	jo     d4 <balancer_ingress+0xd4>
  62:	6f                   	outsl  %ds:(%rsi),(%dx)
  63:	67 00 5f 6c          	add    %bl,0x6c(%edi)
  67:	69 63 65 6e 73 65 00 	imul   $0x65736e,0x65(%rbx),%esp
  6e:	5f                   	pop    %rdi
  6f:	5f                   	pop    %rdi
  70:	41 52                	push   %r10
  72:	52                   	push   %rdx
  73:	41 59                	pop    %r9
  75:	5f                   	pop    %rdi
  76:	53                   	push   %rbx
  77:	49 5a                	rex.WB pop %r10
  79:	45 5f                	rex.RB pop %r15
  7b:	54                   	push   %rsp
  7c:	59                   	pop    %rcx
  7d:	50                   	push   %rax
  7e:	45 5f                	rex.RB pop %r15
  80:	5f                   	pop    %rdi
  81:	00 63 74             	add    %ah,0x74(%rbx)
  struct vip_definition vip = {};
  84:	6c                   	insb   (%dx),%es:(%rdi)
  85:	5f                   	pop    %rdi
  86:	61                   	(bad)
  87:	72 72                	jb     fb <balancer_ingress+0xfb>
  89:	61                   	(bad)
  8a:	79 00                	jns    8c <balancer_ingress+0x8c>
  8c:	75 6e                	jne    fc <balancer_ingress+0xfc>
  8e:	73 69                	jae    f9 <balancer_ingress+0xf9>
  90:	67 6e                	outsb  %ds:(%esi),(%dx)
  92:	65 64 20 69 6e       	gs and %ch,%fs:0x6e(%rcx)
  97:	74 00                	je     99 <balancer_ingress+0x99>
  99:	5f                   	pop    %rdi
  9a:	5f                   	pop    %rdi
  9b:	75 33                	jne    d0 <balancer_ingress+0xd0>
  9d:	32 00                	xor    (%rax),%al
  9f:	75 6e                	jne    10f <balancer_ingress+0x10f>
  a1:	73 69                	jae    10c <balancer_ingress+0x10c>
  a3:	67 6e                	outsb  %ds:(%esi),(%dx)
    if (iph + 1 > data_end) {
  a5:	65 64 20 6c 6f 6e    	gs and %ch,%fs:0x6e(%rdi,%rbp,2)
  ab:	67 20 6c 6f 6e       	and    %ch,0x6e(%edi,%ebp,2)
  b0:	67 00 5f 5f          	add    %bl,0x5f(%edi)
    if (iph->ihl != 5) {
  b4:	75 36                	jne    ec <balancer_ingress+0xec>
  b6:	34 00                	xor    $0x0,%al
  b8:	69 66 69 6e 64 65 78 	imul   $0x7865646e,0x69(%rsi),%esp
    pckt->tos = iph->tos;
  bf:	00 6d 61             	add    %ch,0x61(%rbp)
  c2:	63 00                	movsxd (%rax),%eax
    *protocol = iph->protocol;
  c4:	75 6e                	jne    134 <balancer_ingress+0x134>
  c6:	73 69                	jae    131 <balancer_ingress+0x131>
    pckt->flow.proto = *protocol;
  c8:	67 6e                	outsb  %ds:(%esi),(%dx)
  ca:	65 64 20 63 68       	gs and %ah,%fs:0x68(%rbx)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  cf:	61                   	(bad)
  d0:	72 00                	jb     d2 <balancer_ingress+0xd2>
  d2:	5f                   	pop    %rdi
  d3:	5f                   	pop    %rdi
  d4:	75 38                	jne    10e <balancer_ingress+0x10e>
  d6:	00 63 74             	add    %ah,0x74(%rbx)
  d9:	6c                   	insb   (%dx),%es:(%rdi)
  da:	5f                   	pop    %rdi
  db:	76 61                	jbe    13e <balancer_ingress+0x13e>
  dd:	6c                   	insb   (%dx),%es:(%rdi)
  de:	75 65                	jne    145 <balancer_ingress+0x145>
    if (*protocol == IPPROTO_ICMP) {
  e0:	00 6d 61             	add    %ch,0x61(%rbp)
  e3:	78 5f                	js     144 <balancer_ingress+0x144>
  e5:	65 6e                	outsb  %gs:(%rsi),(%dx)
  e7:	74 72                	je     15b <balancer_ingress+0x15b>
  if (icmp_hdr + 1 > data_end) {
  e9:	69 65 73 00 6d 61 70 	imul   $0x70616d00,0x73(%rbp),%esp
  f0:	5f                   	pop    %rdi
  f1:	66 6c                	data16 insb (%dx),%es:(%rdi)
  f3:	61                   	(bad)
  f4:	67 73 00             	addr32 jae f7 <balancer_ingress+0xf7>
  if (icmp_hdr->type == ICMP_ECHO) {
  f7:	76 69                	jbe    162 <balancer_ingress+0x162>
  f9:	70 5f                	jo     15a <balancer_ingress+0x15a>
  fb:	6d                   	insl   (%dx),%es:(%rdi)
  fc:	61                   	(bad)
  fd:	70 00                	jo     ff <balancer_ingress+0xff>
  ff:	5f                   	pop    %rdi
 100:	5f                   	pop    %rdi
 101:	62 65                	(bad)
 103:	33 32                	xor    (%rdx),%esi
 105:	00 76 69             	add    %dh,0x69(%rsi)
 108:	70 76                	jo     180 <balancer_ingress+0x180>
 10a:	36 00 75 6e          	ss add %dh,0x6e(%rbp)
 10e:	73 69                	jae    179 <balancer_ingress+0x179>
 110:	67 6e                	outsb  %ds:(%esi),(%dx)
 112:	65 64 20 73 68       	gs and %dh,%fs:0x68(%rbx)
  icmp_hdr->type = ICMP_ECHOREPLY;
 117:	6f                   	outsl  %ds:(%rsi),(%dx)
 118:	72 74                	jb     18e <balancer_ingress+0x18e>
  icmp_hdr->checksum += 0x0008;
 11a:	00 5f 5f             	add    %bl,0x5f(%rdi)
 11d:	75 31                	jne    150 <balancer_ingress+0x150>
  iph->ttl = DEFAULT_TTL;
 11f:	36 00 76 69          	ss add %dh,0x69(%rsi)
 123:	70 5f                	jo     184 <balancer_ingress+0x184>
  iph->daddr = iph->saddr;
 125:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
 12c:	69 
 12d:	6f                   	outsl  %ds:(%rsi),(%dx)
 12e:	6e                   	outsb  %ds:(%rsi),(%dx)
 12f:	00 76 69             	add    %dh,0x69(%rsi)
  iph->saddr = tmp_addr;
 132:	70 5f                	jo     193 <balancer_ingress+0x193>
    *csum += *next_iph_u16++;
 134:	6e                   	outsb  %ds:(%rsi),(%dx)
 135:	75 6d                	jne    1a4 <balancer_ingress+0x1a4>
 137:	00 76 69             	add    %dh,0x69(%rsi)
 13a:	70 5f                	jo     19b <balancer_ingress+0x19b>
 13c:	6d                   	insl   (%dx),%es:(%rdi)
 13d:	65 74 61             	gs je  1a1 <balancer_ingress+0x1a1>
 140:	00 66 61             	add    %ah,0x61(%rsi)
 143:	6c                   	insb   (%dx),%es:(%rdi)
 144:	6c                   	insb   (%dx),%es:(%rdi)
 145:	62 61                	(bad)
 147:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 14a:	63 61 63             	movsxd 0x63(%rcx),%esp
 14d:	68 65 00 73 72       	push   $0x72730065
 152:	63 76 36             	movsxd 0x36(%rsi),%esi
 155:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 159:	76 36                	jbe    191 <balancer_ingress+0x191>
 15b:	00 70 6f             	add    %dh,0x6f(%rax)
 15e:	72 74                	jb     1d4 <balancer_ingress+0x1d4>
 160:	73 00                	jae    162 <balancer_ingress+0x162>
 162:	70 6f                	jo     1d3 <balancer_ingress+0x1d3>
 164:	72 74                	jb     1da <balancer_ingress+0x1da>
 166:	31 36                	xor    %esi,(%rsi)
 168:	00 66 6c             	add    %ah,0x6c(%rsi)
    if (csum >> 16)
 16b:	6f                   	outsl  %ds:(%rsi),(%dx)
 16c:	77 5f                	ja     1cd <balancer_ingress+0x1cd>
 16e:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 172:	61                   	(bad)
 173:	74 69                	je     1de <balancer_ingress+0x1de>
 175:	6d                   	insl   (%dx),%es:(%rdi)
 176:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
 17a:	61                   	(bad)
 17b:	6c                   	insb   (%dx),%es:(%rdi)
 17c:	5f                   	pop    %rdi
 17d:	70 6f                	jo     1ee <balancer_ingress+0x1ee>
 17f:	73 5f                	jae    1e0 <balancer_ingress+0x1e0>
 181:	6c                   	insb   (%dx),%es:(%rdi)
 182:	72 75                	jb     1f9 <balancer_ingress+0x1f9>
 184:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
  struct packet_description pckt = {};
 188:	5f                   	pop    %rdi
 189:	6d                   	insl   (%dx),%es:(%rdi)
 18a:	61                   	(bad)
 18b:	70 70                	jo     1fd <balancer_ingress+0x1fd>
 18d:	69 6e 67 00 76 61 6c 	imul   $0x6c617600,0x67(%rsi),%ebp
 194:	75 65                	jne    1fb <balancer_ingress+0x1fb>
 196:	73 00                	jae    198 <balancer_ingress+0x198>
 198:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 19b:	72 69                	jb     206 <balancer_ingress+0x206>
 19d:	6e                   	outsb  %ds:(%rsi),(%dx)
 19e:	67 73 00             	addr32 jae 1a1 <balancer_ingress+0x1a1>
 1a1:	72 65                	jb     208 <balancer_ingress+0x208>
 1a3:	61                   	(bad)
 1a4:	6c                   	insb   (%dx),%es:(%rdi)
 1a5:	73 00                	jae    1a7 <balancer_ingress+0x1a7>
 1a7:	72 65                	jb     20e <balancer_ingress+0x20e>
 1a9:	61                   	(bad)
 1aa:	6c                   	insb   (%dx),%es:(%rdi)
 1ab:	5f                   	pop    %rdi
 1ac:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
 1b3:	69 
 1b4:	6f                   	outsl  %ds:(%rsi),(%dx)
 1b5:	6e                   	outsb  %ds:(%rsi),(%dx)
  struct vip_definition vip = {};
 1b6:	00 72 65             	add    %dh,0x65(%rdx)
 1b9:	61                   	(bad)
 1ba:	6c                   	insb   (%dx),%es:(%rdi)
 1bb:	73 5f                	jae    21c <balancer_ingress+0x21c>
 1bd:	73 74                	jae    233 <balancer_ingress+0x233>
 1bf:	61                   	(bad)
 1c0:	74 73                	je     235 <balancer_ingress+0x235>
 1c2:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 1c6:	73 74                	jae    23c <balancer_ingress+0x23c>
 1c8:	61                   	(bad)
 1c9:	74 73                	je     23e <balancer_ingress+0x23e>
 1cb:	00 76 69             	add    %dh,0x69(%rsi)
 1ce:	70 5f                	jo     22f <balancer_ingress+0x22f>
 1d0:	6d                   	insl   (%dx),%es:(%rdi)
 1d1:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
    if (ip6h + 1 > data_end) {
 1d8:	74 73                	je     24d <balancer_ingress+0x24d>
 1da:	00 71 75             	add    %dh,0x75(%rcx)
 1dd:	69 63 5f 73 74 61 74 	imul   $0x74617473,0x5f(%rbx),%esp
    *protocol = ip6h->nexthdr;
 1e4:	73 5f                	jae    245 <balancer_ingress+0x245>
 1e6:	6d                   	insl   (%dx),%es:(%rdi)
    pckt->flow.proto = *protocol;
 1e7:	61                   	(bad)
 1e8:	70 00                	jo     1ea <balancer_ingress+0x1ea>
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1ea:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 1ed:	72 6f                	jb     25e <balancer_ingress+0x25e>
 1ef:	75 74                	jne    265 <balancer_ingress+0x265>
 1f1:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1f6:	64 5f                	fs pop %rdi
 1f8:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
 1ff:	00 63 69             	add    %ah,0x69(%rbx)
    if (*protocol == IPPROTO_FRAGMENT) {
 202:	64 5f                	fs pop %rdi
 204:	69 6e 76 61 6c 69 64 	imul   $0x64696c61,0x76(%rsi),%ebp
 20b:	5f                   	pop    %rdi
 20c:	73 65                	jae    273 <balancer_ingress+0x273>
 20e:	72 76                	jb     286 <balancer_ingress+0x286>
 210:	65 72 5f             	gs jb  272 <balancer_ingress+0x272>
 213:	69 64 00 63 69 64 5f 	imul   $0x695f6469,0x63(%rax,%rax,1),%esp
 21a:	69 
  if (icmp_hdr + 1 > data_end) {
 21b:	6e                   	outsb  %ds:(%rsi),(%dx)
 21c:	76 61                	jbe    27f <balancer_ingress+0x27f>
 21e:	6c                   	insb   (%dx),%es:(%rdi)
 21f:	69 64 5f 73 65 72 76 	imul   $0x65767265,0x73(%rdi,%rbx,2),%esp
 226:	65 
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 227:	72 5f                	jb     288 <balancer_ingress+0x288>
 229:	69 64 5f 73 61 6d 70 	imul   $0x6c706d61,0x73(%rdi,%rbx,2),%esp
 230:	6c 
 231:	65 00 63 69          	add    %ah,%gs:0x69(%rbx)
 235:	64 5f                	fs pop %rdi
 237:	72 6f                	jb     2a8 <balancer_ingress+0x2a8>
 239:	75 74                	jne    2af <balancer_ingress+0x2af>
 23b:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 240:	64 5f                	fs pop %rdi
 242:	75 6e                	jne    2b2 <balancer_ingress+0x2b2>
 244:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
 248:	6e                   	outsb  %ds:(%rsi),(%dx)
 249:	5f                   	pop    %rdi
 24a:	72 65                	jb     2b1 <balancer_ingress+0x2b1>
 24c:	61                   	(bad)
 24d:	6c                   	insb   (%dx),%es:(%rdi)
 24e:	5f                   	pop    %rdi
 24f:	64 72 6f             	fs jb  2c1 <balancer_ingress+0x2c1>
 252:	70 70                	jo     2c4 <balancer_ingress+0x2c4>
 254:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 259:	64 5f                	fs pop %rdi
 25b:	76 30                	jbe    28d <balancer_ingress+0x28d>
 25d:	00 63 69             	add    %ah,0x69(%rbx)
 260:	64 5f                	fs pop %rdi
 262:	76 31                	jbe    295 <balancer_ingress+0x295>
 264:	00 63 69             	add    %ah,0x69(%rbx)
 267:	64 5f                	fs pop %rdi
 269:	76 32                	jbe    29d <balancer_ingress+0x29d>
 26b:	00 63 69             	add    %ah,0x69(%rbx)
 26e:	64 5f                	fs pop %rdi
 270:	76 33                	jbe    2a5 <balancer_ingress+0x2a5>
 272:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 276:	5f                   	pop    %rdi
 277:	6d                   	insl   (%dx),%es:(%rdi)
 278:	61                   	(bad)
 279:	74 63                	je     2de <balancer_ingress+0x2de>
 27b:	68 5f 69 6e 5f       	push   $0x5f6e695f
 280:	6c                   	insb   (%dx),%es:(%rdi)
 281:	72 75                	jb     2f8 <balancer_ingress+0x2f8>
 283:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 287:	5f                   	pop    %rdi
 288:	6d                   	insl   (%dx),%es:(%rdi)
 289:	69 73 6d 61 74 63 68 	imul   $0x68637461,0x6d(%rbx),%esi
 290:	5f                   	pop    %rdi
 291:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
 298:	64 73 74             	fs jae 30f <balancer_ingress+0x30f>
 29b:	5f                   	pop    %rdi
 29c:	6e                   	outsb  %ds:(%rsi),(%dx)
 29d:	6f                   	outsl  %ds:(%rsi),(%dx)
 29e:	74 5f                	je     2ff <balancer_ingress+0x2ff>
 2a0:	66 6f                	outsw  %ds:(%rsi),(%dx)
 2a2:	75 6e                	jne    312 <balancer_ingress+0x312>
 2a4:	64 5f                	fs pop %rdi
 2a6:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
 2ad:	6c                   	insb   (%dx),%es:(%rdi)
 2ae:	62                   	(bad)
 2af:	5f                   	pop    %rdi
 2b0:	71 75                	jno    327 <balancer_ingress+0x327>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2b2:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
 2b9:	65 74 73             	gs je  32f <balancer_ingress+0x32f>
 2bc:	5f                   	pop    %rdi
 2bd:	73 74                	jae    333 <balancer_ingress+0x333>
 2bf:	61                   	(bad)
 2c0:	74 73                	je     335 <balancer_ingress+0x335>
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2c2:	00 73 74             	add    %dh,0x74(%rbx)
 2c5:	61                   	(bad)
 2c6:	62                   	(bad)
 2c7:	6c                   	insb   (%dx),%es:(%rdi)
 2c8:	65 5f                	gs pop %rdi
 2ca:	72 74                	jb     340 <balancer_ingress+0x340>
 2cc:	5f                   	pop    %rdi
 2cd:	73 74                	jae    343 <balancer_ingress+0x343>
 2cf:	61                   	(bad)
 2d0:	74 73                	je     345 <balancer_ingress+0x345>
  if (protocol == IPPROTO_ICMPV6) {
 2d2:	00 69 6e             	add    %ch,0x6e(%rcx)
 2d5:	76 61                	jbe    338 <balancer_ingress+0x338>
 2d7:	6c                   	insb   (%dx),%es:(%rdi)
 2d8:	69 64 5f 70 61 63 6b 	imul   $0x656b6361,0x70(%rdi,%rbx,2),%esp
 2df:	65 
  if (icmp_hdr + 1 > data_end) {
 2e0:	74 5f                	je     341 <balancer_ingress+0x341>
 2e2:	74 79                	je     35d <balancer_ingress+0x35d>
 2e4:	70 65                	jo     34b <balancer_ingress+0x34b>
 2e6:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
  if (icmp_hdr->type == ICMP_ECHO) {
 2ea:	73 74                	jae    360 <balancer_ingress+0x360>
 2ec:	61                   	(bad)
 2ed:	62                   	(bad)
 2ee:	6c                   	insb   (%dx),%es:(%rdi)
 2ef:	65 5f                	gs pop %rdi
 2f1:	72 74                	jb     367 <balancer_ingress+0x367>
 2f3:	5f                   	pop    %rdi
 2f4:	70 61                	jo     357 <balancer_ingress+0x357>
 2f6:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 2f9:	74 73                	je     36e <balancer_ingress+0x36e>
 2fb:	5f                   	pop    %rdi
 2fc:	73 74                	jae    372 <balancer_ingress+0x372>
 2fe:	61                   	(bad)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2ff:	74 73                	je     374 <balancer_ingress+0x374>
 301:	00 64 65 63          	add    %ah,0x63(%rbp,%riz,2)
 305:	61                   	(bad)
 306:	70 5f                	jo     367 <balancer_ingress+0x367>
       sizeof(struct icmphdr)) > data_end) {
 308:	76 69                	jbe    373 <balancer_ingress+0x373>
 30a:	70 5f                	jo     36b <balancer_ingress+0x36b>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 30c:	73 74                	jae    382 <balancer_ingress+0x382>
 30e:	61                   	(bad)
 30f:	74 73                	je     384 <balancer_ingress+0x384>
  icmp_hdr->type = ICMP_ECHOREPLY;
 311:	00 73 65             	add    %dh,0x65(%rbx)
 314:	72 76                	jb     38c <balancer_ingress+0x38c>
  icmp_hdr->checksum += 0x0008;
 316:	65 72 5f             	gs jb  378 <balancer_ingress+0x378>
 319:	69 64 5f 6d 61 70 00 	imul   $0x74007061,0x6d(%rdi,%rbx,2),%esp
 320:	74 
  iph->daddr = iph->saddr;
 321:	70 72                	jo     395 <balancer_ingress+0x395>
 323:	5f                   	pop    %rdi
 324:	73 74                	jae    39a <balancer_ingress+0x39a>
  tmp_addr = iph->daddr;
 326:	61                   	(bad)
 327:	74 73                	je     39c <balancer_ingress+0x39c>
  iph->daddr = iph->saddr;
 329:	5f                   	pop    %rdi
 32a:	6d                   	insl   (%dx),%es:(%rdi)
 32b:	61                   	(bad)
 32c:	70 00                	jo     32e <balancer_ingress+0x32e>
  iph->saddr = tmp_addr;
 32e:	73 69                	jae    399 <balancer_ingress+0x399>
 330:	64 5f                	fs pop %rdi
    *csum += *next_iph_u16++;
 332:	72 6f                	jb     3a3 <balancer_ingress+0x3a3>
 334:	75 74                	jne    3aa <balancer_ingress+0x3aa>
 336:	65 64 00 74 63 70    	gs add %dh,%fs:0x70(%rbx,%riz,2)
 33c:	5f                   	pop    %rdi
 33d:	73 79                	jae    3b8 <balancer_ingress+0x3b8>
 33f:	6e                   	outsb  %ds:(%rsi),(%dx)
 340:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 344:	74 70                	je     3b6 <balancer_ingress+0x3b6>
 346:	72 5f                	jb     3a7 <balancer_ingress+0x3a7>
 348:	70 61                	jo     3ab <balancer_ingress+0x3ab>
 34a:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 34d:	74 73                	je     3c2 <balancer_ingress+0x3c2>
 34f:	5f                   	pop    %rdi
 350:	73 74                	jae    3c6 <balancer_ingress+0x3c6>
 352:	61                   	(bad)
 353:	74 73                	je     3c8 <balancer_ingress+0x3c8>
 355:	00 73 65             	add    %dh,0x65(%rbx)
 358:	72 76                	jb     3d0 <balancer_ingress+0x3d0>
 35a:	65 72 5f             	gs jb  3bc <balancer_ingress+0x3bc>
 35d:	69 64 5f 73 74 61 74 	imul   $0x73746174,0x73(%rdi,%rbx,2),%esp
 364:	73 
 365:	00 76 69             	add    %dh,0x69(%rsi)
 368:	70 5f                	jo     3c9 <balancer_ingress+0x3c9>
 36a:	74 6f                	je     3db <balancer_ingress+0x3db>
 36c:	5f                   	pop    %rdi
 36d:	64 6f                	outsl  %fs:(%rsi),(%dx)
 36f:	77 6e                	ja     3df <balancer_ingress+0x3df>
    if (csum >> 16)
 371:	5f                   	pop    %rdi
 372:	72 65                	jb     3d9 <balancer_ingress+0x3d9>
 374:	61                   	(bad)
 375:	6c                   	insb   (%dx),%es:(%rdi)
 376:	73 5f                	jae    3d7 <balancer_ingress+0x3d7>
 378:	6d                   	insl   (%dx),%es:(%rdi)
 379:	61                   	(bad)
 37a:	70 00                	jo     37c <balancer_ingress+0x37c>
 37c:	72 65                	jb     3e3 <balancer_ingress+0x3e3>
 37e:	61                   	(bad)
 37f:	6c                   	insb   (%dx),%es:(%rdi)
 380:	5f                   	pop    %rdi
 381:	62                   	(bad)
 382:	70 66                	jo     3ea <balancer_ingress+0x3ea>
 384:	5f                   	pop    %rdi
 385:	6d                   	insl   (%dx),%es:(%rdi)
 386:	61                   	(bad)
 387:	70 5f                	jo     3e8 <balancer_ingress+0x3e8>
 389:	6c                   	insb   (%dx),%es:(%rdi)
 38a:	6f                   	outsl  %ds:(%rsi),(%dx)
 38b:	6f                   	outsl  %ds:(%rsi),(%dx)
 38c:	6b 75 70 5f          	imul   $0x5f,0x70(%rbp),%esi
 390:	65 6c                	gs insb (%dx),%es:(%rdi)
 392:	65 6d                	gs insl (%dx),%es:(%rdi)
 394:	00 62 70             	add    %ah,0x70(%rdx)
 397:	66 5f                	pop    %di
 399:	67 65 74 5f          	addr32 gs je 3fc <balancer_ingress+0x3fc>
 39d:	73 6d                	jae    40c <balancer_ingress+0x40c>
 39f:	70 5f                	jo     400 <balancer_ingress+0x400>
 3a1:	70 72                	jo     415 <balancer_ingress+0x415>
 3a3:	6f                   	outsl  %ds:(%rsi),(%dx)
 3a4:	63 65 73             	movsxd 0x73(%rbp),%esp
 3a7:	73 6f                	jae    418 <balancer_ingress+0x418>
 3a9:	72 5f                	jb     40a <balancer_ingress+0x40a>
 3ab:	69 64 00 62 70 66 5f 	imul   $0x6b5f6670,0x62(%rax,%rax,1),%esp
 3b2:	6b 
 3b3:	74 69                	je     41e <balancer_ingress+0x41e>
 3b5:	6d                   	insl   (%dx),%es:(%rdi)
 3b6:	65 5f                	gs pop %rdi
 3b8:	67 65 74 5f          	addr32 gs je 41b <balancer_ingress+0x41b>
 3bc:	6e                   	outsb  %ds:(%rsi),(%dx)
 3bd:	73 00                	jae    3bf <balancer_ingress+0x3bf>
 3bf:	62                   	(bad)
 3c0:	70 66                	jo     428 <balancer_ingress+0x428>
 3c2:	5f                   	pop    %rdi
 3c3:	6d                   	insl   (%dx),%es:(%rdi)
 3c4:	61                   	(bad)
 3c5:	70 5f                	jo     426 <balancer_ingress+0x426>
 3c7:	75 70                	jne    439 <balancer_ingress+0x439>
 3c9:	64 61                	fs (bad)
 3cb:	74 65                	je     432 <balancer_ingress+0x432>
 3cd:	5f                   	pop    %rdi
 3ce:	65 6c                	gs insb (%dx),%es:(%rdi)
 3d0:	65 6d                	gs insl (%dx),%es:(%rdi)
 3d2:	00 62 70             	add    %ah,0x70(%rdx)
 3d5:	66 5f                	pop    %di
 3d7:	78 64                	js     43d <balancer_ingress+0x43d>
 3d9:	70 5f                	jo     43a <balancer_ingress+0x43a>
 3db:	61                   	(bad)
 3dc:	64 6a 75             	fs push $0x75
 3df:	73 74                	jae    455 <balancer_ingress+0x455>
 3e1:	5f                   	pop    %rdi
 3e2:	68 65 61 64 00       	push   $0x646165
 3e7:	58                   	pop    %rax
 3e8:	44 50                	rex.R push %rax
 3ea:	5f                   	pop    %rdi
 3eb:	41                   	rex.B
 3ec:	42                   	rex.X
 3ed:	4f 52                	rex.WRXB push %r10
 3ef:	54                   	push   %rsp
 3f0:	45                   	rex.RB
 3f1:	44 00 58 44          	add    %r11b,0x44(%rax)
 3f5:	50                   	push   %rax
 3f6:	5f                   	pop    %rdi
 3f7:	44 52                	rex.R push %rdx
 3f9:	4f 50                	rex.WRXB push %r8
 3fb:	00 58 44             	add    %bl,0x44(%rax)
 3fe:	50                   	push   %rax
 3ff:	5f                   	pop    %rdi
 400:	50                   	push   %rax
 401:	41 53                	push   %r11
 403:	53                   	push   %rbx
 404:	00 58 44             	add    %bl,0x44(%rax)
 407:	50                   	push   %rax
 408:	5f                   	pop    %rdi
 409:	54                   	push   %rsp
 40a:	58                   	pop    %rax
 40b:	00 58 44             	add    %bl,0x44(%rax)
 40e:	50                   	push   %rax
 40f:	5f                   	pop    %rdi
 410:	52                   	push   %rdx
 411:	45                   	rex.RB
 412:	44                   	rex.R
 413:	49 52                	rex.WB push %r10
  if (protocol == IPPROTO_TCP) {
 415:	45                   	rex.RB
 416:	43 54                	rex.XB push %r12
 418:	00 78 64             	add    %bh,0x64(%rax)
 41b:	70 5f                	jo     47c <balancer_ingress+0x47c>
 41d:	61                   	(bad)
 41e:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
 422:	6e                   	outsb  %ds:(%rsi),(%dx)
 423:	00 49 50             	add    %cl,0x50(%rcx)
  tcp = data + off;
 426:	50                   	push   %rax
 427:	52                   	push   %rdx
 428:	4f 54                	rex.WRXB push %r12
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 42a:	4f 5f                	rex.WRXB pop %r15
  tcp = data + off;
 42c:	49 50                	rex.WB push %r8
 42e:	00 49 50             	add    %cl,0x50(%rcx)
  if (tcp + 1 > data_end) {
 431:	50                   	push   %rax
 432:	52                   	push   %rdx
 433:	4f 54                	rex.WRXB push %r12
 435:	4f 5f                	rex.WRXB pop %r15
 437:	49                   	rex.WB
 438:	43                   	rex.XB
 439:	4d 50                	rex.WRB push %r8
 43b:	00 49 50             	add    %cl,0x50(%rcx)
  if (tcp->syn) {
 43e:	50                   	push   %rax
 43f:	52                   	push   %rdx
 440:	4f 54                	rex.WRXB push %r12
 442:	4f 5f                	rex.WRXB pop %r15
    pckt->flags |= F_SYN_SET;
 444:	49                   	rex.WB
 445:	47                   	rex.RXB
 446:	4d 50                	rex.WRB push %r8
 448:	00 49 50             	add    %cl,0x50(%rcx)
 44b:	50                   	push   %rax
 44c:	52                   	push   %rdx
      pckt->flow.src = iph->saddr;
 44d:	4f 54                	rex.WRXB push %r12
 44f:	4f 5f                	rex.WRXB pop %r15
 451:	49 50                	rex.WB push %r8
 453:	49 50                	rex.WB push %r8
      pckt->flow.dst = iph->daddr;
 455:	00 49 50             	add    %cl,0x50(%rcx)
 458:	50                   	push   %rax
 459:	52                   	push   %rdx
 45a:	4f 54                	rex.WRXB push %r12
  if (protocol == IPPROTO_ICMPV6) {
 45c:	4f 5f                	rex.WRXB pop %r15
 45e:	54                   	push   %rsp
 45f:	43 50                	rex.XB push %r8
  if (icmp_hdr + 1 > data_end) {
 461:	00 49 50             	add    %cl,0x50(%rcx)
 464:	50                   	push   %rax
 465:	52                   	push   %rdx
 466:	4f 54                	rex.WRXB push %r12
 468:	4f 5f                	rex.WRXB pop %r15
 46a:	45                   	rex.RB
 46b:	47 50                	rex.RXB push %r8
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 46d:	00 49 50             	add    %cl,0x50(%rcx)
 470:	50                   	push   %rax
 471:	52                   	push   %rdx
 472:	4f 54                	rex.WRXB push %r12
 474:	4f 5f                	rex.WRXB pop %r15
 476:	50                   	push   %rax
 477:	55                   	push   %rbp
 478:	50                   	push   %rax
 479:	00 49 50             	add    %cl,0x50(%rcx)
 47c:	50                   	push   %rax
 47d:	52                   	push   %rdx
 47e:	4f 54                	rex.WRXB push %r12
 480:	4f 5f                	rex.WRXB pop %r15
 482:	55                   	push   %rbp
 483:	44 50                	rex.R push %rax
 485:	00 49 50             	add    %cl,0x50(%rcx)
 488:	50                   	push   %rax
 489:	52                   	push   %rdx
 48a:	4f 54                	rex.WRXB push %r12
 48c:	4f 5f                	rex.WRXB pop %r15
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 48e:	49                   	rex.WB
 48f:	44 50                	rex.R push %rax
 491:	00 49 50             	add    %cl,0x50(%rcx)
 494:	50                   	push   %rax
 495:	52                   	push   %rdx
       sizeof(struct icmp6hdr)) > data_end) {
 496:	4f 54                	rex.WRXB push %r12
 498:	4f 5f                	rex.WRXB pop %r15
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 49a:	54                   	push   %rsp
 49b:	50                   	push   %rax
 49c:	00 49 50             	add    %cl,0x50(%rcx)
 49f:	50                   	push   %rax
 4a0:	52                   	push   %rdx
 4a1:	4f 54                	rex.WRXB push %r12
 4a3:	4f 5f                	rex.WRXB pop %r15
  udp = data + off;
 4a5:	44                   	rex.R
 4a6:	43                   	rex.XB
 4a7:	43 50                	rex.XB push %r8
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 4a9:	00 49 50             	add    %cl,0x50(%rcx)
  udp = data + off;
 4ac:	50                   	push   %rax
 4ad:	52                   	push   %rdx
 4ae:	4f 54                	rex.WRXB push %r12
  if (udp + 1 > data_end) {
 4b0:	4f 5f                	rex.WRXB pop %r15
 4b2:	49 50                	rex.WB push %r8
 4b4:	56                   	push   %rsi
 4b5:	36 00 49 50          	ss add %cl,0x50(%rcx)
 4b9:	50                   	push   %rax
 4ba:	52                   	push   %rdx
 4bb:	4f 54                	rex.WRXB push %r12
 4bd:	4f 5f                	rex.WRXB pop %r15
 4bf:	52                   	push   %rdx
 4c0:	53                   	push   %rbx
 4c1:	56                   	push   %rsi
 4c2:	50                   	push   %rax
 4c3:	00 49 50             	add    %cl,0x50(%rcx)
 4c6:	50                   	push   %rax
 4c7:	52                   	push   %rdx
 4c8:	4f 54                	rex.WRXB push %r12
 4ca:	4f 5f                	rex.WRXB pop %r15
 4cc:	47 52                	rex.RXB push %r10
 4ce:	45 00 49 50          	add    %r9b,0x50(%r9)
 4d2:	50                   	push   %rax
 4d3:	52                   	push   %rdx
 4d4:	4f 54                	rex.WRXB push %r12
 4d6:	4f 5f                	rex.WRXB pop %r15
 4d8:	45 53                	rex.RB push %r11
 4da:	50                   	push   %rax
 4db:	00 49 50             	add    %cl,0x50(%rcx)
 4de:	50                   	push   %rax
 4df:	52                   	push   %rdx
 4e0:	4f 54                	rex.WRXB push %r12
 4e2:	4f 5f                	rex.WRXB pop %r15
 4e4:	41                   	rex.B
 4e5:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
 4e9:	50                   	push   %rax
 4ea:	52                   	push   %rdx
 4eb:	4f 54                	rex.WRXB push %r12
 4ed:	4f 5f                	rex.WRXB pop %r15
 4ef:	4d 54                	rex.WRB push %r12
 4f1:	50                   	push   %rax
 4f2:	00 49 50             	add    %cl,0x50(%rcx)
  tcp = data + off;
 4f5:	50                   	push   %rax
 4f6:	52                   	push   %rdx
 4f7:	4f 54                	rex.WRXB push %r12
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 4f9:	4f 5f                	rex.WRXB pop %r15
  tcp = data + off;
 4fb:	42                   	rex.X
 4fc:	45                   	rex.RB
 4fd:	45 54                	rex.RB push %r12
  if (tcp + 1 > data_end) {
 4ff:	50                   	push   %rax
 500:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
 504:	50                   	push   %rax
 505:	52                   	push   %rdx
 506:	4f 54                	rex.WRXB push %r12
 508:	4f 5f                	rex.WRXB pop %r15
 50a:	45                   	rex.RB
 50b:	4e                   	rex.WRX
  if (tcp->syn) {
 50c:	43                   	rex.XB
 50d:	41 50                	push   %r8
 50f:	00 49 50             	add    %cl,0x50(%rcx)
 512:	50                   	push   %rax
 513:	52                   	push   %rdx
 514:	4f 54                	rex.WRXB push %r12
    pckt->flags |= F_SYN_SET;
 516:	4f 5f                	rex.WRXB pop %r15
 518:	50                   	push   %rax
 519:	49                   	rex.WB
 51a:	4d 00 49 50          	rex.WRB add %r9b,0x50(%r9)
 51e:	50                   	push   %rax
 51f:	52                   	push   %rdx
 520:	4f 54                	rex.WRXB push %r12
 522:	4f 5f                	rex.WRXB pop %r15
 524:	43                   	rex.XB
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
 525:	4f                   	rex.WRXB
 526:	4d 50                	rex.WRB push %r8
 528:	00 49 50             	add    %cl,0x50(%rcx)
 52b:	50                   	push   %rax
        bpf_map_lookup_elem(&stats, &stats_key);
 52c:	52                   	push   %rdx
 52d:	4f 54                	rex.WRXB push %r12
 52f:	4f 5f                	rex.WRXB pop %r15
 531:	4c 32 54 50 00       	rex.WR xor 0x0(%rax,%rdx,2),%r10b
 536:	49 50                	rex.WB push %r8
 538:	50                   	push   %rax
 539:	52                   	push   %rdx
 53a:	4f 54                	rex.WRXB push %r12
 53c:	4f 5f                	rex.WRXB pop %r15
 53e:	53                   	push   %rbx
 53f:	43 54                	rex.XB push %r12
 541:	50                   	push   %rax
 542:	00 49 50             	add    %cl,0x50(%rcx)
    if (!icmp_ptb_v6_stats) {
 545:	50                   	push   %rax
 546:	52                   	push   %rdx
 547:	4f 54                	rex.WRXB push %r12
 549:	4f 5f                	rex.WRXB pop %r15
 54b:	55                   	push   %rbp
    icmp_ptb_v6_stats->v1 += 1;
 54c:	44 50                	rex.R push %rax
 54e:	4c                   	rex.WR
 54f:	49 54                	rex.WB push %r12
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 551:	45 00 49 50          	add    %r9b,0x50(%r9)
 555:	50                   	push   %rax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 556:	52                   	push   %rdx
 557:	4f 54                	rex.WRXB push %r12
 559:	4f 5f                	rex.WRXB pop %r15
 55b:	4d 50                	rex.WRB push %r8
 55d:	4c 53                	rex.WR push %rbx
      icmp_ptb_v6_stats->v2 += 1;
 55f:	00 49 50             	add    %cl,0x50(%rcx)
 562:	50                   	push   %rax
 563:	52                   	push   %rdx
 564:	4f 54                	rex.WRXB push %r12
  if (ip6h + 1 > data_end) {
 566:	4f 5f                	rex.WRXB pop %r15
 568:	45 54                	rex.RB push %r12
 56a:	48                   	rex.W
 56b:	45 52                	rex.RB push %r10
 56d:	4e                   	rex.WRX
 56e:	45 54                	rex.RB push %r12
 570:	00 49 50             	add    %cl,0x50(%rcx)
  pckt->flow.proto = ip6h->nexthdr;
 573:	50                   	push   %rax
 574:	52                   	push   %rdx
 575:	4f 54                	rex.WRXB push %r12
 577:	4f 5f                	rex.WRXB pop %r15
  pckt->flags |= F_ICMP;
 579:	41                   	rex.B
 57a:	47                   	rex.RXB
 57b:	47                   	rex.RXB
 57c:	46 52                	rex.RX push %rdx
 57e:	41                   	rex.B
 57f:	47 00 49 50          	rex.RXB add %r9b,0x50(%r9)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 583:	50                   	push   %rax
 584:	52                   	push   %rdx
 585:	4f 54                	rex.WRXB push %r12
 587:	4f 5f                	rex.WRXB pop %r15
 589:	52                   	push   %rdx
 58a:	41 57                	push   %r15
 58c:	00 49 50             	add    %cl,0x50(%rcx)
 58f:	50                   	push   %rax
 590:	52                   	push   %rdx
 591:	4f 54                	rex.WRXB push %r12
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 593:	4f 5f                	rex.WRXB pop %r15
 595:	53                   	push   %rbx
 596:	4d                   	rex.WRB
 597:	43 00 49 50          	rex.XB add %cl,0x50(%r9)
 59b:	50                   	push   %rax
 59c:	52                   	push   %rdx
 59d:	4f 54                	rex.WRXB push %r12
 59f:	4f 5f                	rex.WRXB pop %r15
 5a1:	4d 50                	rex.WRB push %r8
 5a3:	54                   	push   %rsp
 5a4:	43 50                	rex.XB push %r8
 5a6:	00 49 50             	add    %cl,0x50(%rcx)
 5a9:	50                   	push   %rax
 5aa:	52                   	push   %rdx
 5ab:	4f 54                	rex.WRXB push %r12
 5ad:	4f 5f                	rex.WRXB pop %r15
 5af:	4d                   	rex.WRB
 5b0:	41 58                	pop    %r8
 5b2:	00 63 6f             	add    %ah,0x6f(%rbx)
 5b5:	6e                   	outsb  %ds:(%rsi),(%dx)
 5b6:	6e                   	outsb  %ds:(%rsi),(%dx)
 5b7:	5f                   	pop    %rdi
 5b8:	69 64 5f 6c 65 6e 73 	imul   $0x736e65,0x6c(%rdi,%rbx,2),%esp
 5bf:	00 
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
 5c0:	64 73 74             	fs jae 637 <balancer_ingress+0x637>
 5c3:	5f                   	pop    %rdi
 5c4:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
 5c7:	6e                   	outsb  %ds:(%rsi),(%dx)
 5c8:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
 5cd:	6e                   	outsb  %ds:(%rsi),(%dx)
 5ce:	5f                   	pop    %rdi
 5cf:	69 64 00 71 75 69 63 	imul   $0x5f636975,0x71(%rax,%rax,1),%esp
 5d6:	5f 
  vip.port = pckt.flow.port16[1];
 5d7:	6c                   	insb   (%dx),%es:(%rdi)
 5d8:	6f                   	outsl  %ds:(%rsi),(%dx)
 5d9:	6e                   	outsb  %ds:(%rsi),(%dx)
 5da:	67 5f                	addr32 pop %rdi
  vip.proto = pckt.flow.proto;
 5dc:	68 65 61 64 65       	push   $0x65646165
 5e1:	72 00                	jb     5e3 <balancer_ingress+0x5e3>
 5e3:	71 75                	jno    65a <balancer_ingress+0x65a>
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 5e5:	69 63 5f 73 68 6f 72 	imul   $0x726f6873,0x5f(%rbx),%esp
 5ec:	74 5f                	je     64d <balancer_ingress+0x64d>
 5ee:	68 65 61 64 65       	push   $0x65646165
 5f3:	72 00                	jb     5f5 <balancer_ingress+0x5f5>
 5f5:	70 72                	jo     669 <balancer_ingress+0x669>
 5f7:	6f                   	outsl  %ds:(%rsi),(%dx)
 5f8:	63 65 73             	movsxd 0x73(%rbp),%esp
 5fb:	73 5f                	jae    65c <balancer_ingress+0x65c>
 5fd:	70 61                	jo     660 <balancer_ingress+0x660>
  if (!vip_info) {
 5ff:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 602:	74 00                	je     604 <balancer_ingress+0x604>
 604:	78 64                	js     66a <balancer_ingress+0x66a>
 606:	70 00                	jo     608 <balancer_ingress+0x608>
  if (data_end - data > MAX_PCKT_SIZE) {
 608:	64 61                	fs (bad)
 60a:	74 61                	je     66d <balancer_ingress+0x66d>
 60c:	5f                   	pop    %rdi
 60d:	65 6e                	outsb  %gs:(%rsi),(%dx)
 60f:	64 00 64 61 74       	add    %ah,%fs:0x74(%rcx,%riz,2)
 614:	61                   	(bad)
 615:	5f                   	pop    %rdi
 616:	6d                   	insl   (%dx),%es:(%rdi)
 617:	65 74 61             	gs je  67b <balancer_ingress+0x67b>
 61a:	00 64 61 74          	add    %ah,0x74(%rcx,%riz,2)
 61e:	61                   	(bad)
 61f:	5f                   	pop    %rdi
 620:	68 61 72 64 5f       	push   $0x5f647261
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
 625:	73 74                	jae    69b <balancer_ingress+0x69b>
 627:	61                   	(bad)
 628:	72 74                	jb     69e <balancer_ingress+0x69e>
 62a:	00 72 78             	add    %dh,0x78(%rdx)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 62d:	71 00                	jno    62f <balancer_ingress+0x62f>
 62f:	78 64                	js     695 <balancer_ingress+0x695>
 631:	70 5f                	jo     692 <balancer_ingress+0x692>
 633:	72 78                	jb     6ad <balancer_ingress+0x6ad>
 635:	71 5f                	jno    696 <balancer_ingress+0x696>
 637:	69 6e 66 6f 00 74 78 	imul   $0x7874006f,0x66(%rsi),%ebp
 63e:	71 00                	jno    640 <balancer_ingress+0x640>
 640:	78 64                	js     6a6 <balancer_ingress+0x6a6>
 642:	70 5f                	jo     6a3 <balancer_ingress+0x6a3>
 644:	74 78                	je     6be <balancer_ingress+0x6be>
 646:	71 5f                	jno    6a7 <balancer_ingress+0x6a7>
  if (!data_stats) {
 648:	69 6e 66 6f 00 66 72 	imul   $0x7266006f,0x66(%rsi),%ebp
 64f:	61                   	(bad)
 650:	6d                   	insl   (%dx),%es:(%rdi)
 651:	65 5f                	gs pop %rdi
 653:	73 7a                	jae    6cf <balancer_ingress+0x6cf>
 655:	00 78 64             	add    %bh,0x64(%rax)
  data_stats->v1 += 1;
 658:	70 5f                	jo     6b9 <balancer_ingress+0x6b9>
 65a:	6d                   	insl   (%dx),%es:(%rdi)
 65b:	64 00 6e 68          	add    %ch,%fs:0x68(%rsi)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 65f:	5f                   	pop    %rdi
 660:	6f                   	outsl  %ds:(%rsi),(%dx)
 661:	66 66 00 69 73       	data16 data16 add %ch,0x73(%rcx)
    pckt.flow.port16[0] = 0;
 666:	5f                   	pop    %rdi
 667:	69 70 76 36 00 5f 42 	imul   $0x425f0036,0x76(%rax),%esi
 66e:	6f                   	outsl  %ds:(%rsi),(%dx)
 66f:	6f                   	outsl  %ds:(%rsi),(%dx)
 670:	6c                   	insb   (%dx),%es:(%rdi)
 671:	00 70 63             	add    %dh,0x63(%rax)
  vip_num = vip_info->vip_num;
 674:	6b 74 00 66 6c       	imul   $0x6c,0x66(%rax,%rax,1),%esi
 679:	6f                   	outsl  %ds:(%rsi),(%dx)
 67a:	77 00                	ja     67c <balancer_ingress+0x67c>
 67c:	72 65                	jb     6e3 <balancer_ingress+0x6e3>
 67e:	61                   	(bad)
 67f:	6c                   	insb   (%dx),%es:(%rdi)
  __u32 cpu_num = bpf_get_smp_processor_id();
 680:	5f                   	pop    %rdi
 681:	69 6e 64 65 78 00 74 	imul   $0x74007865,0x64(%rsi),%ebp
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 688:	6f                   	outsl  %ds:(%rsi),(%dx)
 689:	73 00                	jae    68b <balancer_ingress+0x68b>
 68b:	70 61                	jo     6ee <balancer_ingress+0x6ee>
 68d:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 690:	74 5f                	je     6f1 <balancer_ingress+0x6f1>
 692:	64 65 73 63          	fs gs jae 6f9 <balancer_ingress+0x6f9>
 696:	72 69                	jb     701 <balancer_ingress+0x701>
 698:	70 74                	jo     70e <balancer_ingress+0x70e>
 69a:	69 6f 6e 00 6d 61 63 	imul   $0x63616d00,0x6e(%rdi),%ebp
 6a1:	5f                   	pop    %rdi
 6a2:	61                   	(bad)
 6a3:	64 64 72 5f          	fs fs jb 706 <balancer_ingress+0x706>
 6a7:	70 6f                	jo     718 <balancer_ingress+0x718>
  if (!lru_map) {
 6a9:	73 00                	jae    6ab <balancer_ingress+0x6ab>
 6ab:	74 68                	je     715 <balancer_ingress+0x715>
 6ad:	5f                   	pop    %rdi
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
 6ae:	6f                   	outsl  %ds:(%rsi),(%dx)
 6af:	66 66 00 70 72       	data16 data16 add %dh,0x72(%rax)
 6b4:	6f                   	outsl  %ds:(%rsi),(%dx)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
 6b5:	74 6f                	je     726 <balancer_ingress+0x726>
 6b7:	63 6f 6c             	movsxd 0x6c(%rdi),%ebp
 6ba:	00 76 69             	add    %dh,0x69(%rsi)
 6bd:	70 5f                	jo     71e <balancer_ingress+0x71e>
 6bf:	69 6e 66 6f 00 64 61 	imul   $0x6164006f,0x66(%rsi),%ebp
 6c6:	74 61                	je     729 <balancer_ingress+0x729>
 6c8:	5f                   	pop    %rdi
 6c9:	73 74                	jae    73f <balancer_ingress+0x73f>
 6cb:	61                   	(bad)
    if (!lru_stats) {
 6cc:	74 73                	je     741 <balancer_ingress+0x741>
 6ce:	00 63 70             	add    %ah,0x70(%rbx)
 6d1:	75 5f                	jne    732 <balancer_ingress+0x732>
 6d3:	6e                   	outsb  %ds:(%rsi),(%dx)
 6d4:	75 6d                	jne    743 <balancer_ingress+0x743>
    lru_stats->v1 += 1;
 6d6:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
 6da:	5f                   	pop    %rdi
 6db:	6d                   	insl   (%dx),%es:(%rdi)
 6dc:	61                   	(bad)
 6dd:	70 00                	jo     6df <balancer_ingress+0x6df>
 6df:	70 6b                	jo     74c <balancer_ingress+0x74c>
 6e1:	74 5f                	je     742 <balancer_ingress+0x742>
 6e3:	62                   	(bad)
 6e4:	79 74                	jns    75a <balancer_ingress+0x75a>
 6e6:	65 73 00             	gs jae 6e9 <balancer_ingress+0x6e9>
 6e9:	6f                   	outsl  %ds:(%rsi),(%dx)
 6ea:	72 69                	jb     755 <balancer_ingress+0x755>
 6ec:	67 69 6e 61 6c 5f 73 	imul   $0x70735f6c,0x61(%esi),%ebp
 6f3:	70 
  if ((vip_info->flags & F_QUIC_VIP)) {
 6f4:	6f                   	outsl  %ds:(%rsi),(%dx)
 6f5:	72 74                	jb     76b <balancer_ingress+0x76b>
 6f7:	00 63 76             	add    %ah,0x76(%rbx)
    bool is_icmp = (pckt.flags & F_ICMP);
 6fa:	61                   	(bad)
 6fb:	6c                   	insb   (%dx),%es:(%rdi)
 6fc:	00 69 70             	add    %ch,0x70(%rcx)
    if (is_icmp) {
 6ff:	68 5f 6c 65 6e       	push   $0x6e656c5f
      __u32 quic_packets_stats_key = 0;
 704:	00 5f 5f             	add    %bl,0x5f(%rdi)
 707:	65 6c                	gs insb (%dx),%es:(%rdi)
 709:	65 6d                	gs insl (%dx),%es:(%rdi)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
 70b:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
 70f:	5f                   	pop    %rdi
 710:	73 74                	jae    786 <balancer_ingress+0x786>
 712:	61                   	(bad)
 713:	74 73                	je     788 <balancer_ingress+0x788>
 715:	5f                   	pop    %rdi
 716:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 71a:	6c                   	insb   (%dx),%es:(%rdi)
 71b:	72 75                	jb     792 <balancer_ingress+0x792>
 71d:	5f                   	pop    %rdi
 71e:	73 74                	jae    794 <balancer_ingress+0x794>
 720:	61                   	(bad)
 721:	74 73                	je     796 <balancer_ingress+0x796>
      if (!quic_packets_stats) {
 723:	00 69 73             	add    %ch,0x73(%rcx)
 726:	5f                   	pop    %rdi
 727:	69 63 6d 70 00 71 75 	imul   $0x75710070,0x6d(%rbx),%esp
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
 72e:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
 735:	65 74 73             	gs je  7ab <balancer_ingress+0x7ab>
 738:	5f                   	pop    %rdi
 739:	73 74                	jae    7af <balancer_ingress+0x7af>
 73b:	61                   	(bad)
 73c:	74 73                	je     7b1 <balancer_ingress+0x7b1>
 73e:	5f                   	pop    %rdi
 73f:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 743:	71 70                	jno    7b5 <balancer_ingress+0x7b5>
 745:	72 00                	jb     747 <balancer_ingress+0x747>
 747:	63 69 64             	movsxd 0x64(%rcx),%ebp
        quic_packets_stats->ch_routed += 1;
 74a:	5f                   	pop    %rdi
 74b:	76 65                	jbe    7b2 <balancer_ingress+0x7b2>
 74d:	72 73                	jb     7c2 <balancer_ingress+0x7c2>
 74f:	69 6f 6e 00 69 73 5f 	imul   $0x5f736900,0x6e(%rdi),%ebp
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 756:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
 75d:	00 71 75             	add    %dh,0x75(%rcx)
 760:	69 63 5f 70 61 72 73 	imul   $0x73726170,0x5f(%rbx),%esp
        bpf_map_lookup_elem(&stats, &stats_key);
 767:	65 5f                	gs pop %rdi
 769:	72 65                	jb     7d0 <balancer_ingress+0x7d0>
 76b:	73 75                	jae    7e2 <balancer_ingress+0x7e2>
 76d:	6c                   	insb   (%dx),%es:(%rdi)
 76e:	74 00                	je     770 <balancer_ingress+0x770>
 770:	72 65                	jb     7d7 <balancer_ingress+0x7d7>
 772:	61                   	(bad)
 773:	6c                   	insb   (%dx),%es:(%rdi)
 774:	5f                   	pop    %rdi
 775:	70 6f                	jo     7e6 <balancer_ingress+0x7e6>
 777:	73 00                	jae    779 <balancer_ingress+0x779>
    if (!icmp_ptb_v4_stats) {
 779:	69 64 78 00 65 6c 65 	imul   $0x6d656c65,0x0(%rax,%rdi,2),%esp
 780:	6d 
 781:	5f                   	pop    %rdi
    icmp_ptb_v4_stats->v1 += 1;
 782:	73 69                	jae    7ed <balancer_ingress+0x7ed>
 784:	7a 65                	jp     7eb <balancer_ingress+0x7eb>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 786:	00 72 65             	add    %dh,0x65(%rdx)
 789:	73 00                	jae    78b <balancer_ingress+0x78b>
 78b:	70 61                	jo     7ee <balancer_ingress+0x7ee>
      icmp_ptb_v4_stats->v2 += 1;
 78d:	72 73                	jb     802 <balancer_ingress+0x802>
 78f:	65 5f                	gs pop %rdi
 791:	6c                   	insb   (%dx),%es:(%rdi)
 792:	33 5f 68             	xor    0x68(%rdi),%ebx
  if (iph + 1 > data_end) {
 795:	65 61                	gs (bad)
 797:	64 65 72 73          	fs gs jb 80e <balancer_ingress+0x80e>
 79b:	00 69 70             	add    %ch,0x70(%rcx)
 79e:	68 00 69 68 6c       	push   $0x6c686900
  if (iph->ihl != 5) {
 7a3:	00 74 6f 74          	add    %dh,0x74(%rdi,%rbp,2)
 7a7:	5f                   	pop    %rdi
 7a8:	6c                   	insb   (%dx),%es:(%rdi)
 7a9:	65 6e                	outsb  %gs:(%rsi),(%dx)
 7ab:	00 5f 5f             	add    %bl,0x5f(%rdi)
  pckt->flow.proto = iph->protocol;
 7ae:	62 65                	(bad)
 7b0:	31 36                	xor    %esi,(%rsi)
 7b2:	00 66 72             	add    %ah,0x72(%rsi)
  pckt->flags |= F_ICMP;
 7b5:	61                   	(bad)
 7b6:	67 5f                	addr32 pop %rdi
 7b8:	6f                   	outsl  %ds:(%rsi),(%dx)
 7b9:	66 66 00 74 74 6c    	data16 data16 add %dh,0x6c(%rsp,%rsi,2)
  pckt->flow.src = iph->daddr;
 7bf:	00 63 68             	add    %ah,0x68(%rbx)
 7c2:	65 63 6b 00          	movsxd %gs:0x0(%rbx),%ebp
  pckt->flow.dst = iph->saddr;
 7c6:	5f                   	pop    %rdi
 7c7:	5f                   	pop    %rdi
 7c8:	73 75                	jae    83f <balancer_ingress+0x83f>
 7ca:	6d                   	insl   (%dx),%es:(%rdi)
 7cb:	31 36                	xor    %esi,(%rsi)
 7cd:	00 73 61             	add    %dh,0x61(%rbx)
 7d0:	64 64 72 00          	fs fs jb 7d4 <balancer_ingress+0x7d4>
    vip.port = 0;
 7d4:	64 61                	fs (bad)
 7d6:	64 64 72 00          	fs fs jb 7da <balancer_ingress+0x7da>
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 7da:	61                   	(bad)
 7db:	64 64 72 73          	fs fs jb 852 <balancer_ingress+0x852>
 7df:	00 69 70             	add    %ch,0x70(%rcx)
 7e2:	68 64 72 00 69       	push   $0x69007264
 7e7:	70 36                	jo     81f <balancer_ingress+0x81f>
 7e9:	68 00 70 72 69       	push   $0x69727000
 7ee:	6f                   	outsl  %ds:(%rsi),(%dx)
 7ef:	72 69                	jb     85a <balancer_ingress+0x85a>
 7f1:	74 79                	je     86c <balancer_ingress+0x86c>
 7f3:	00 66 6c             	add    %ah,0x6c(%rsi)
    if (!vip_info) {
 7f6:	6f                   	outsl  %ds:(%rsi),(%dx)
 7f7:	77 5f                	ja     858 <balancer_ingress+0x858>
 7f9:	6c                   	insb   (%dx),%es:(%rdi)
 7fa:	62                   	(bad)
 7fb:	6c                   	insb   (%dx),%es:(%rdi)
 7fc:	00 70 61             	add    %dh,0x61(%rax)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 7ff:	79 6c                	jns    86d <balancer_ingress+0x86d>
 801:	6f                   	outsl  %ds:(%rsi),(%dx)
 802:	61                   	(bad)
 803:	64 5f                	fs pop %rdi
 805:	6c                   	insb   (%dx),%es:(%rdi)
      pckt.flow.port16[1] = 0;
 806:	65 6e                	outsb  %gs:(%rsi),(%dx)
 808:	00 6e 65             	add    %ch,0x65(%rsi)
 80b:	78 74                	js     881 <balancer_ingress+0x881>
 80d:	68 64 72 00 68       	push   $0x68007264
  udp = data + off;
 812:	6f                   	outsl  %ds:(%rsi),(%dx)
 813:	70 5f                	jo     874 <balancer_ingress+0x874>
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 815:	6c                   	insb   (%dx),%es:(%rdi)
 816:	69 6d 69 74 00 69 6e 	imul   $0x6e690074,0x69(%rbp),%ebp
  if (udp + 1 > data_end) {
 81d:	36 5f                	ss pop %rdi
 81f:	75 00                	jne    821 <balancer_ingress+0x821>
 821:	75 36                	jne    859 <balancer_ingress+0x859>
 823:	5f                   	pop    %rdi
 824:	61                   	(bad)
 825:	64 64 72 38          	fs fs jb 861 <balancer_ingress+0x861>
 829:	00 75 36             	add    %dh,0x36(%rbp)
 82c:	5f                   	pop    %rdi
 82d:	61                   	(bad)
 82e:	64 64 72 31          	fs fs jb 863 <balancer_ingress+0x863>
 832:	36 00 75 36          	ss add %dh,0x36(%rbp)
 836:	5f                   	pop    %rdi
 837:	61                   	(bad)
 838:	64 64 72 33          	fs fs jb 86f <balancer_ingress+0x86f>
 83c:	32 00                	xor    (%rax),%al
 83e:	69 6e 36 5f 61 64 64 	imul   $0x6464615f,0x36(%rsi),%ebp
 845:	72 00                	jb     847 <balancer_ingress+0x847>
 847:	69 70 76 36 68 64 72 	imul   $0x72646836,0x76(%rax),%esi
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 84e:	00 70 61             	add    %dh,0x61(%rax)
 851:	72 73                	jb     8c6 <balancer_ingress+0x8c6>
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
 853:	65 5f                	gs pop %rdi
 855:	69 63 6d 70 00 69 63 	imul   $0x63690070,0x6d(%rbx),%esp
        bpf_map_lookup_elem(&stats, &stats_key);
 85c:	6d                   	insl   (%dx),%es:(%rdi)
 85d:	70 5f                	jo     8be <balancer_ingress+0x8be>
 85f:	68 64 72 00 63       	push   $0x63007264
 864:	68 65 63 6b 73       	push   $0x736b6365
 869:	75 6d                	jne    8d8 <balancer_ingress+0x8d8>
 86b:	00 73 65             	add    %dh,0x65(%rbx)
 86e:	71 75                	jno    8e5 <balancer_ingress+0x8e5>
 870:	65 6e                	outsb  %gs:(%rsi),(%dx)
    if (!icmp_ptb_v4_stats) {
 872:	63 65 00             	movsxd 0x0(%rbp),%esp
 875:	67 61                	addr32 (bad)
 877:	74 65                	je     8de <balancer_ingress+0x8de>
 879:	77 61                	ja     8dc <balancer_ingress+0x8dc>
    icmp_ptb_v4_stats->v1 += 1;
 87b:	79 00                	jns    87d <balancer_ingress+0x87d>
 87d:	66 72 61             	data16 jb 8e1 <balancer_ingress+0x8e1>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 880:	67 00 5f 5f          	add    %bl,0x5f(%edi)
 884:	75 6e                	jne    8f4 <balancer_ingress+0x8f4>
      icmp_ptb_v4_stats->v2 += 1;
 886:	75 73                	jne    8fb <balancer_ingress+0x8fb>
 888:	65 64 00 6d 74       	gs add %ch,%fs:0x74(%rbp)
 88d:	75 00                	jne    88f <balancer_ingress+0x88f>
  if (iph + 1 > data_end) {
 88f:	72 65                	jb     8f6 <balancer_ingress+0x8f6>
 891:	73 65                	jae    8f8 <balancer_ingress+0x8f8>
 893:	72 76                	jb     90b <balancer_ingress+0x90b>
 895:	65 64 00 69 63       	gs add %ch,%fs:0x63(%rcx)
 89a:	6d                   	insl   (%dx),%es:(%rdi)
  if (iph->ihl != 5) {
 89b:	70 68                	jo     905 <balancer_ingress+0x905>
 89d:	64 72 00             	fs jb  8a0 <balancer_ingress+0x8a0>
 8a0:	69 63 6d 70 5f 70 74 	imul   $0x74705f70,0x6d(%rbx),%esp
  pckt->flow.proto = iph->protocol;
 8a7:	62                   	(bad)
 8a8:	5f                   	pop    %rdi
 8a9:	76 34                	jbe    8df <balancer_ingress+0x8df>
 8ab:	5f                   	pop    %rdi
 8ac:	73 74                	jae    922 <balancer_ingress+0x922>
  pckt->flags |= F_ICMP;
 8ae:	61                   	(bad)
 8af:	74 73                	je     924 <balancer_ingress+0x924>
 8b1:	00 68 61             	add    %ch,0x61(%rax)
 8b4:	6e                   	outsb  %ds:(%rsi),(%dx)
 8b5:	64 6c                	fs insb (%dx),%es:(%rdi)
  pckt->flow.src = iph->daddr;
 8b7:	65 5f                	gs pop %rdi
 8b9:	69 66 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rsi),%esp
  pckt->flow.dst = iph->saddr;
 8c0:	00 73 65             	add    %dh,0x65(%rbx)
 8c3:	6e                   	outsb  %ds:(%rsi),(%dx)
 8c4:	64 5f                	fs pop %rdi
 8c6:	69 63 6d 70 5f 72 65 	imul   $0x65725f70,0x6d(%rbx),%esp
 8cd:	70 6c                	jo     93b <balancer_ingress+0x93b>
 8cf:	79 00                	jns    8d1 <balancer_ingress+0x8d1>
 8d1:	74 6d                	je     940 <balancer_ingress+0x940>
 8d3:	70 5f                	jo     934 <balancer_ingress+0x934>
 8d5:	61                   	(bad)
 8d6:	64 64 72 00          	fs fs jb 8da <balancer_ingress+0x8da>
 8da:	63 73 75             	movsxd 0x75(%rbx),%esi
    vip.vip = pckt.flow.dst;
 8dd:	6d                   	insl   (%dx),%es:(%rdi)
 8de:	00 69 70             	add    %ch,0x70(%rcx)
 8e1:	76 34                	jbe    917 <balancer_ingress+0x917>
 8e3:	5f                   	pop    %rdi
 8e4:	63 73 75             	movsxd 0x75(%rbx),%esi
  vip.port = pckt.flow.port16[1];
 8e7:	6d                   	insl   (%dx),%es:(%rdi)
 8e8:	5f                   	pop    %rdi
 8e9:	69 6e 6c 69 6e 65 00 	imul   $0x656e69,0x6c(%rsi),%ebp
  vip.proto = pckt.flow.proto;
 8f0:	6e                   	outsb  %ds:(%rsi),(%dx)
 8f1:	65 78 74             	gs js  968 <balancer_ingress+0x968>
 8f4:	5f                   	pop    %rdi
 8f5:	69 70 68 5f 75 31 36 	imul   $0x3631755f,0x68(%rax),%esi
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 8fc:	00 69 00             	add    %ch,0x0(%rcx)
 8ff:	63 73 75             	movsxd 0x75(%rbx),%esi
 902:	6d                   	insl   (%dx),%es:(%rdi)
 903:	5f                   	pop    %rdi
 904:	66 6f                	outsw  %ds:(%rsi),(%dx)
 906:	6c                   	insb   (%dx),%es:(%rdi)
 907:	64 5f                	fs pop %rdi
 909:	68 65 6c 70 65       	push   $0x65706c65
 90e:	72 00                	jb     910 <balancer_ingress+0x910>
 910:	70 61                	jo     973 <balancer_ingress+0x973>
 912:	72 73                	jb     987 <balancer_ingress+0x987>
  if (!vip_info) {
 914:	65 5f                	gs pop %rdi
 916:	69 63 6d 70 76 36 00 	imul   $0x367670,0x6d(%rbx),%esp
  if (data_end - data > MAX_PCKT_SIZE) {
 91d:	69 63 6d 70 36 5f 74 	imul   $0x745f3670,0x6d(%rbx),%esp
 924:	79 70                	jns    996 <balancer_ingress+0x996>
 926:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
 92a:	6d                   	insl   (%dx),%es:(%rdi)
 92b:	70 36                	jo     963 <balancer_ingress+0x963>
 92d:	5f                   	pop    %rdi
 92e:	63 6f 64             	movsxd 0x64(%rdi),%ebp
 931:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
 935:	6d                   	insl   (%dx),%es:(%rdi)
 936:	70 36                	jo     96e <balancer_ingress+0x96e>
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
 938:	5f                   	pop    %rdi
 939:	63 6b 73             	movsxd 0x73(%rbx),%ebp
 93c:	75 6d                	jne    9ab <balancer_ingress+0x9ab>
 93e:	00 69 63             	add    %ch,0x63(%rcx)
 941:	6d                   	insl   (%dx),%es:(%rdi)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 942:	70 36                	jo     97a <balancer_ingress+0x97a>
 944:	5f                   	pop    %rdi
 945:	64 61                	fs (bad)
 947:	74 61                	je     9aa <balancer_ingress+0x9aa>
 949:	75 6e                	jne    9b9 <balancer_ingress+0x9b9>
 94b:	00 75 6e             	add    %dh,0x6e(%rbp)
 94e:	5f                   	pop    %rdi
 94f:	64 61                	fs (bad)
 951:	74 61                	je     9b4 <balancer_ingress+0x9b4>
 953:	33 32                	xor    (%rdx),%esi
 955:	00 75 6e             	add    %dh,0x6e(%rbp)
 958:	5f                   	pop    %rdi
 959:	64 61                	fs (bad)
 95b:	74 61                	je     9be <balancer_ingress+0x9be>
  if (!data_stats) {
 95d:	31 36                	xor    %esi,(%rsi)
 95f:	00 75 6e             	add    %dh,0x6e(%rbp)
 962:	5f                   	pop    %rdi
 963:	64 61                	fs (bad)
 965:	74 61                	je     9c8 <balancer_ingress+0x9c8>
 967:	38 00                	cmp    %al,(%rax)
 969:	75 5f                	jne    9ca <balancer_ingress+0x9ca>
 96b:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
  data_stats->v1 += 1;
 96f:	00 69 64             	add    %ch,0x64(%rcx)
 972:	65 6e                	outsb  %gs:(%rsi),(%dx)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 974:	74 69                	je     9df <balancer_ingress+0x9df>
 976:	66 69 65 72 00 69    	imul   $0x6900,0x72(%rbp),%sp
    pckt.flow.port16[0] = 0;
 97c:	63 6d 70             	movsxd 0x70(%rbp),%ebp
  vip_num = vip_info->vip_num;
 97f:	76 36                	jbe    9b7 <balancer_ingress+0x9b7>
 981:	5f                   	pop    %rdi
 982:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
 986:	00 75 5f             	add    %dh,0x5f(%rbp)
 989:	6e                   	outsb  %ds:(%rsi),(%dx)
 98a:	64 5f                	fs pop %rdi
 98c:	61                   	(bad)
 98d:	64 76 74             	fs jbe a04 <balancer_ingress+0xa04>
 990:	00 6f 76             	add    %ch,0x76(%rdi)
 993:	65 72 72             	gs jb  a08 <balancer_ingress+0xa08>
  __u32 cpu_num = bpf_get_smp_processor_id();
 996:	69 64 65 00 73 6f 6c 	imul   $0x696c6f73,0x0(%rbp,%riz,2),%esp
 99d:	69 
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 99e:	63 69 74             	movsxd 0x74(%rcx),%ebp
 9a1:	65 64 00 72 6f       	gs add %dh,%fs:0x6f(%rdx)
 9a6:	75 74                	jne    a1c <balancer_ingress+0xa1c>
 9a8:	65 72 00             	gs jb  9ab <balancer_ingress+0x9ab>
 9ab:	72 65                	jb     a12 <balancer_ingress+0xa12>
 9ad:	73 65                	jae    a14 <balancer_ingress+0xa14>
 9af:	72 76                	jb     a27 <balancer_ingress+0xa27>
 9b1:	65 64 32 00          	gs xor %fs:(%rax),%al
 9b5:	69 63 6d 70 76 36 5f 	imul   $0x5f367670,0x6d(%rbx),%esp
 9bc:	6e                   	outsb  %ds:(%rsi),(%dx)
 9bd:	64 5f                	fs pop %rdi
  if (!lru_map) {
 9bf:	61                   	(bad)
 9c0:	64 76 74             	fs jbe a37 <balancer_ingress+0xa37>
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
 9c3:	00 75 5f             	add    %dh,0x5f(%rbp)
 9c6:	6e                   	outsb  %ds:(%rsi),(%dx)
 9c7:	64 5f                	fs pop %rdi
 9c9:	72 61                	jb     a2c <balancer_ingress+0xa2c>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
 9cb:	00 72 6f             	add    %dh,0x6f(%rdx)
 9ce:	75 74                	jne    a44 <balancer_ingress+0xa44>
 9d0:	65 72 5f             	gs jb  a32 <balancer_ingress+0xa32>
 9d3:	70 72                	jo     a47 <balancer_ingress+0xa47>
 9d5:	65 66 00 68 6f       	data16 add %ch,%gs:0x6f(%rax)
 9da:	6d                   	insl   (%dx),%es:(%rdi)
 9db:	65 5f                	gs pop %rdi
 9dd:	61                   	(bad)
 9de:	67 65 6e             	outsb  %gs:(%esi),(%dx)
    if (!lru_stats) {
 9e1:	74 00                	je     9e3 <balancer_ingress+0x9e3>
 9e3:	6f                   	outsl  %ds:(%rsi),(%dx)
 9e4:	74 68                	je     a4e <balancer_ingress+0xa4e>
 9e6:	65 72 00             	gs jb  9e9 <balancer_ingress+0x9e9>
 9e9:	6d                   	insl   (%dx),%es:(%rdi)
    lru_stats->v1 += 1;
 9ea:	61                   	(bad)
 9eb:	6e                   	outsb  %ds:(%rsi),(%dx)
 9ec:	61                   	(bad)
 9ed:	67 65 64 00 72 74    	gs add %dh,%fs:0x74(%edx)
 9f3:	5f                   	pop    %rdi
 9f4:	6c                   	insb   (%dx),%es:(%rdi)
 9f5:	69 66 65 74 69 6d 65 	imul   $0x656d6974,0x65(%rsi),%esp
 9fc:	00 69 63             	add    %ch,0x63(%rcx)
 9ff:	6d                   	insl   (%dx),%es:(%rdi)
 a00:	70 76                	jo     a78 <balancer_ingress+0xa78>
 a02:	36 5f                	ss pop %rdi
  if ((vip_info->flags & F_QUIC_VIP)) {
 a04:	6e                   	outsb  %ds:(%rsi),(%dx)
 a05:	64 5f                	fs pop %rdi
 a07:	72 61                	jb     a6a <balancer_ingress+0xa6a>
 a09:	00 69 63             	add    %ch,0x63(%rcx)
 a0c:	6d                   	insl   (%dx),%es:(%rdi)
 a0d:	70 36                	jo     a45 <balancer_ingress+0xa45>
    bool is_icmp = (pckt.flags & F_ICMP);
 a0f:	68 64 72 00 69       	push   $0x69007264
    if (is_icmp) {
 a14:	63 6d 70             	movsxd 0x70(%rbp),%ebp
 a17:	5f                   	pop    %rdi
 a18:	70 74                	jo     a8e <balancer_ingress+0xa8e>
      __u32 quic_packets_stats_key = 0;
 a1a:	62                   	(bad)
 a1b:	5f                   	pop    %rdi
 a1c:	76 36                	jbe    a54 <balancer_ingress+0xa54>
 a1e:	5f                   	pop    %rdi
 a1f:	73 74                	jae    a95 <balancer_ingress+0xa95>
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
 a21:	61                   	(bad)
 a22:	74 73                	je     a97 <balancer_ingress+0xa97>
 a24:	00 70 61             	add    %dh,0x61(%rax)
 a27:	72 73                	jb     a9c <balancer_ingress+0xa9c>
 a29:	65 5f                	gs pop %rdi
 a2b:	74 63                	je     a90 <balancer_ingress+0xa90>
 a2d:	70 00                	jo     a2f <balancer_ingress+0xa2f>
 a2f:	61                   	(bad)
 a30:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 a33:	73 65                	jae    a9a <balancer_ingress+0xa9a>
 a35:	71 00                	jno    a37 <balancer_ingress+0xa37>
      if (!quic_packets_stats) {
 a37:	61                   	(bad)
 a38:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
 a3c:	73 31                	jae    a6f <balancer_ingress+0xa6f>
 a3e:	00 64 6f 66          	add    %ah,0x66(%rdi,%rbp,2)
 a42:	66 00 66 69          	data16 add %ah,0x69(%rsi)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
 a46:	6e                   	outsb  %ds:(%rsi),(%dx)
  bool is_icmp = (pckt->flags & F_ICMP);
 a47:	00 72 73             	add    %dh,0x73(%rdx)
 a4a:	74 00                	je     a4c <balancer_ingress+0xa4c>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
 a4c:	70 73                	jo     ac1 <balancer_ingress+0xac1>
 a4e:	68 00 61 63 6b       	push   $0x6b636100
 a53:	00 75 72             	add    %dh,0x72(%rbp)
 a56:	67 00 65 63          	add    %ah,0x63(%ebp)
 a5a:	65 00 63 77          	add    %ah,%gs:0x77(%rbx)
 a5e:	72 00                	jb     a60 <balancer_ingress+0xa60>
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
 a60:	77 69                	ja     acb <balancer_ingress+0xacb>
 a62:	6e                   	outsb  %ds:(%rsi),(%dx)
 a63:	64 6f                	outsl  %fs:(%rsi),(%dx)
 a65:	77 00                	ja     a67 <balancer_ingress+0xa67>
 a67:	75 72                	jne    adb <balancer_ingress+0xadb>
 a69:	67 5f                	addr32 pop %rdi
 a6b:	70 74                	jo     ae1 <balancer_ingress+0xae1>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
 a6d:	72 00                	jb     a6f <balancer_ingress+0xa6f>
 a6f:	74 63                	je     ad4 <balancer_ingress+0xad4>
 a71:	70 68                	jo     adb <balancer_ingress+0xadb>
 a73:	64 72 00             	fs jb  a76 <balancer_ingress+0xa76>
 a76:	73 65                	jae    add <balancer_ingress+0xadd>
 a78:	6e                   	outsb  %ds:(%rsi),(%dx)
 a79:	64 5f                	fs pop %rdi
 a7b:	69 63 6d 70 36 5f 72 	imul   $0x725f3670,0x6d(%rbx),%esp
    vip.port = 0;
 a82:	65 70 6c             	gs jo  af1 <balancer_ingress+0xaf1>
 a85:	79 00                	jns    a87 <balancer_ingress+0xa87>
 a87:	70 61                	jo     aea <balancer_ingress+0xaea>
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 a89:	72 73                	jb     afe <balancer_ingress+0xafe>
 a8b:	65 5f                	gs pop %rdi
 a8d:	75 64                	jne    af3 <balancer_ingress+0xaf3>
 a8f:	70 00                	jo     a91 <balancer_ingress+0xa91>
 a91:	75 64                	jne    af7 <balancer_ingress+0xaf7>
 a93:	70 68                	jo     afd <balancer_ingress+0xafd>
 a95:	64 72 00             	fs jb  a98 <balancer_ingress+0xa98>
 a98:	70 61                	jo     afb <balancer_ingress+0xafb>
 a9a:	72 73                	jb     b0f <balancer_ingress+0xb0f>
 a9c:	65 5f                	gs pop %rdi
 a9e:	71 75                	jno    b15 <balancer_ingress+0xb15>
 aa0:	69 63 00 71 75 69 63 	imul   $0x63697571,0x0(%rbx),%esp
    if (!vip_info) {
 aa7:	5f                   	pop    %rdi
 aa8:	64 61                	fs (bad)
 aaa:	74 61                	je     b0d <balancer_ingress+0xb0d>
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 aac:	00 70 6b             	add    %dh,0x6b(%rax)
 aaf:	74 5f                	je     b10 <balancer_ingress+0xb10>
 ab1:	74 79                	je     b2c <balancer_ingress+0xb2c>
 ab3:	70 65                	jo     b1a <balancer_ingress+0xb1a>
      pckt.flow.port16[1] = 0;
 ab5:	00 63 6f             	add    %ah,0x6f(%rbx)
 ab8:	6e                   	outsb  %ds:(%rsi),(%dx)
 ab9:	6e                   	outsb  %ds:(%rsi),(%dx)
 aba:	49                   	rex.WB
 abb:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
 abf:	6e                   	outsb  %ds:(%rsi),(%dx)
 ac0:	6e                   	outsb  %ds:(%rsi),(%dx)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
 ac1:	49                   	rex.WB
 ac2:	64 56                	fs push %rsi
 ac4:	65 72 73             	gs jb  b3a <balancer_ingress+0xb3a>
 ac7:	69 6f 6e 00 69 67 6e 	imul   $0x6e676900,0x6e(%rdi),%ebp
        bpf_map_lookup_elem(&stats, &stats_key);
 ace:	6f                   	outsl  %ds:(%rsi),(%dx)
 acf:	72 61                	jb     b32 <balancer_ingress+0xb32>
 ad1:	62                   	(bad)
 ad2:	6c                   	insb   (%dx),%es:(%rdi)
 ad3:	65 5f                	gs pop %rdi
 ad5:	71 75                	jno    b4c <balancer_ingress+0xb4c>
 ad7:	69 63 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rbx),%esp
 ade:	5f                   	pop    %rdi
    if (!icmp_ptb_v6_stats) {
 adf:	63 6f 64             	movsxd 0x64(%rdi),%ebp
 ae2:	65 00 63 6f          	add    %ah,%gs:0x6f(%rbx)
 ae6:	6e                   	outsb  %ds:(%rsi),(%dx)
 ae7:	6e                   	outsb  %ds:(%rsi),(%dx)
    icmp_ptb_v6_stats->v1 += 1;
 ae8:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 aed:	6e                   	outsb  %ds:(%rsi),(%dx)
 aee:	5f                   	pop    %rdi
 aef:	74 61                	je     b52 <balancer_ingress+0xb52>
 af1:	62                   	(bad)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 af2:	6c                   	insb   (%dx),%es:(%rdi)
 af3:	65 5f                	gs pop %rdi
 af5:	6c                   	insb   (%dx),%es:(%rdi)
 af6:	6f                   	outsl  %ds:(%rsi),(%dx)
 af7:	6f                   	outsl  %ds:(%rsi),(%dx)
 af8:	6b 75 70 00          	imul   $0x0,0x70(%rbp),%esi
      icmp_ptb_v6_stats->v2 += 1;
 afc:	69 73 47 6c 6f 62 61 	imul   $0x61626f6c,0x47(%rbx),%esi
  if (ip6h + 1 > data_end) {
 b03:	6c                   	insb   (%dx),%es:(%rdi)
 b04:	4c 72 75             	rex.WR jb b7c <balancer_ingress+0xb7c>
 b07:	00 63 75             	add    %ah,0x75(%rbx)
 b0a:	72 5f                	jb     b6b <balancer_ingress+0xb6b>
 b0c:	74 69                	je     b77 <balancer_ingress+0xb77>
 b0e:	6d                   	insl   (%dx),%es:(%rdi)
 b0f:	65 00 69 6e          	add    %ch,%gs:0x6e(%rcx)
  pckt->flow.proto = ip6h->nexthdr;
 b13:	63 72 5f             	movsxd 0x5f(%rdx),%esi
 b16:	73 65                	jae    b7d <balancer_ingress+0xb7d>
 b18:	72 76                	jb     b90 <balancer_ingress+0xb90>
  pckt->flags |= F_ICMP;
 b1a:	65 72 5f             	gs jb  b7c <balancer_ingress+0xb7c>
 b1d:	69 64 5f 72 6f 75 74 	imul   $0x6974756f,0x72(%rdi,%rbx,2),%esp
 b24:	69 
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 b25:	6e                   	outsb  %ds:(%rsi),(%dx)
 b26:	67 5f                	addr32 pop %rdi
 b28:	73 74                	jae    b9e <balancer_ingress+0xb9e>
 b2a:	61                   	(bad)
 b2b:	74 73                	je     ba0 <balancer_ingress+0xba0>
 b2d:	00 6e 65             	add    %ch,0x65(%rsi)
 b30:	77 43                	ja     b75 <balancer_ingress+0xb75>
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 b32:	6f                   	outsl  %ds:(%rsi),(%dx)
 b33:	6e                   	outsb  %ds:(%rsi),(%dx)
 b34:	6e                   	outsb  %ds:(%rsi),(%dx)
 b35:	00 6d 69             	add    %ch,0x69(%rbp)
 b38:	73 4d                	jae    b87 <balancer_ingress+0xb87>
 b3a:	61                   	(bad)
 b3b:	74 63                	je     ba0 <balancer_ingress+0xba0>
 b3d:	68 49 6e 4c 52       	push   $0x524c6e49
 b42:	55                   	push   %rbp
 b43:	00 70 65             	add    %dh,0x65(%rax)
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
 b46:	72 5f                	jb     ba7 <balancer_ingress+0xba7>
 b48:	76 69                	jbe    bb3 <balancer_ingress+0xbb3>
 b4a:	70 5f                	jo     bab <balancer_ingress+0xbab>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 b4c:	73 74                	jae    bc2 <balancer_ingress+0xbc2>
 b4e:	61                   	(bad)
 b4f:	74 73                	je     bc4 <balancer_ingress+0xbc4>
 b51:	00 63 68             	add    %ah,0x68(%rbx)
 b54:	65 63 6b 5f          	movsxd %gs:0x5f(%rbx),%ebp
 b58:	75 64                	jne    bbe <balancer_ingress+0xbbe>
 b5a:	70 5f                	jo     bbb <balancer_ingress+0xbbb>
 b5c:	66 6c                	data16 insb (%dx),%es:(%rdi)
 b5e:	6f                   	outsl  %ds:(%rsi),(%dx)
 b5f:	77 5f                	ja     bc0 <balancer_ingress+0xbc0>
 b61:	6d                   	insl   (%dx),%es:(%rdi)
 b62:	69 67 72 61 74 69 6f 	imul   $0x6f697461,0x72(%rdi),%esp
      if (!data_stats) {
 b69:	6e                   	outsb  %ds:(%rsi),(%dx)
 b6a:	00 64 6f 77          	add    %ah,0x77(%rdi,%rbp,2)
      data_stats->v1 += 1;
 b6e:	6e                   	outsb  %ds:(%rsi),(%dx)
 b6f:	5f                   	pop    %rdi
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
 b70:	72 65                	jb     bd7 <balancer_ingress+0xbd7>
 b72:	61                   	(bad)
 b73:	6c                   	insb   (%dx),%es:(%rdi)
 b74:	00 73 74             	add    %dh,0x74(%rbx)
 b77:	61                   	(bad)
 b78:	74 73                	je     bed <balancer_ingress+0xbed>
 b7a:	5f                   	pop    %rdi
 b7b:	64 61                	fs (bad)
 b7d:	74 61                	je     be0 <balancer_ingress+0xbe0>
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
 b7f:	00 69 73             	add    %ch,0x73(%rcx)
        data_stats->v2 += 1;
 b82:	5f                   	pop    %rdi
 b83:	75 6e                	jne    bf3 <balancer_ingress+0xbf3>
  original_sport = pckt.flow.port16[0];
 b85:	64 65 72 5f          	fs gs jb be8 <balancer_ingress+0xbe8>
 b89:	66 6c                	data16 insb (%dx),%es:(%rdi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
 b8b:	6f                   	outsl  %ds:(%rsi),(%dx)
 b8c:	6f                   	outsl  %ds:(%rsi),(%dx)
 b8d:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
        !(vip_info->flags & F_LRU_BYPASS)) {
 b91:	6e                   	outsb  %ds:(%rsi),(%dx)
 b92:	6e                   	outsb  %ds:(%rsi),(%dx)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
 b93:	5f                   	pop    %rdi
 b94:	72 61                	jb     bf7 <balancer_ingress+0xbf7>
 b96:	74 65                	je     bfd <balancer_ingress+0xbfd>
 b98:	5f                   	pop    %rdi
 b99:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 b9d:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
 ba0:	6e                   	outsb  %ds:(%rsi),(%dx)
 ba1:	5f                   	pop    %rdi
 ba2:	72 61                	jb     c05 <balancer_ingress+0xc05>
 ba4:	74 65                	je     c0b <balancer_ingress+0xc0b>
 ba6:	5f                   	pop    %rdi
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
 ba7:	73 74                	jae    c1d <balancer_ingress+0xc1d>
  if (!dst_lru) {
 ba9:	61                   	(bad)
 baa:	74 73                	je     c1f <balancer_ingress+0xc1f>
 bac:	00 65 6e             	add    %ah,0x6e(%rbp)
 baf:	63 61 70             	movsxd 0x70(%rcx),%esp
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
 bb2:	5f                   	pop    %rdi
 bb3:	76 34                	jbe    be9 <balancer_ingress+0xbe9>
 bb5:	00 69 70             	add    %ch,0x70(%rcx)
 bb8:	5f                   	pop    %rdi
 bb9:	73 72                	jae    c2d <balancer_ingress+0xc2d>
 bbb:	63 00                	movsxd (%rax),%eax
 bbd:	6e                   	outsb  %ds:(%rsi),(%dx)
 bbe:	65 77 5f             	gs ja  c20 <balancer_ingress+0xc20>
 bc1:	65 74 68             	gs je  c2c <balancer_ingress+0xc2c>
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
 bc4:	00 68 5f             	add    %ch,0x5f(%rax)
 bc7:	64 65 73 74          	fs gs jae c3f <balancer_ingress+0xc3f>
 bcb:	00 68 5f             	add    %ch,0x5f(%rax)
 bce:	73 6f                	jae    c3f <balancer_ingress+0xc3f>
 bd0:	75 72                	jne    c44 <balancer_ingress+0xc44>
 bd2:	63 65 00             	movsxd 0x0(%rbp),%esp
 bd5:	65 74 68             	gs je  c40 <balancer_ingress+0xc40>
 bd8:	68 64 72 00 6f       	push   $0x6f007264
 bdd:	6c                   	insb   (%dx),%es:(%rdi)
 bde:	64 5f                	fs pop %rdi
 be0:	65 74 68             	gs je  c4b <balancer_ingress+0xc4b>
 be3:	00 63 72             	add    %ah,0x72(%rbx)
 be6:	65 61                	gs (bad)
 be8:	74 65                	je     c4f <balancer_ingress+0xc4f>
 bea:	5f                   	pop    %rdi
 beb:	76 34                	jbe    c21 <balancer_ingress+0xc21>
 bed:	5f                   	pop    %rdi
 bee:	68 64 72 00 67       	push   $0x67007264
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
 bf3:	65 74 5f             	gs je  c55 <balancer_ingress+0xc55>
 bf6:	70 61                	jo     c59 <balancer_ingress+0xc59>
 bf8:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 bfb:	74 5f                	je     c5c <balancer_ingress+0xc5c>
 bfd:	64 73 74             	fs jae c74 <balancer_ingress+0xc74>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
 c00:	00 6e 65             	add    %ch,0x65(%rsi)
 c03:	77 5f                	ja     c64 <balancer_ingress+0xc64>
 c05:	64 73 74             	fs jae c7c <balancer_ingress+0xc7c>
 c08:	5f                   	pop    %rdi
 c09:	6c                   	insb   (%dx),%es:(%rdi)
 c0a:	72 75                	jb     c81 <balancer_ingress+0xc81>
  if (!connId) {
 c0c:	00 73 72             	add    %dh,0x72(%rbx)
 c0f:	63 5f 66             	movsxd 0x66(%rdi),%ebx
 c12:	6f                   	outsl  %ds:(%rsi),(%dx)
 c13:	75 6e                	jne    c83 <balancer_ingress+0xc83>
 c15:	64 00 68 61          	add    %ch,%fs:0x61(%rax)
  __u8 connIdVersion = (connId[0] >> 6);
 c19:	73 68                	jae    c83 <balancer_ingress+0xc83>
 c1b:	5f                   	pop    %rdi
 c1c:	31 36                	xor    %esi,(%rsi)
 c1e:	62                   	(bad)
 c1f:	79 74                	jns    c95 <balancer_ingress+0xc95>
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
 c21:	65 73 00             	gs jae c24 <balancer_ingress+0xc24>
 c24:	65 6e                	outsb  %gs:(%rsi),(%dx)
 c26:	63 61 70             	movsxd 0x70(%rcx),%esp
 c29:	5f                   	pop    %rdi
 c2a:	76 36                	jbe    c62 <balancer_ingress+0xc62>
 c2c:	00 63 72             	add    %ah,0x72(%rbx)
 c2f:	65 61                	gs (bad)
 c31:	74 65                	je     c98 <balancer_ingress+0xc98>
 c33:	5f                   	pop    %rdi
 c34:	65 6e                	outsb  %gs:(%rsi),(%dx)
 c36:	63 61 70             	movsxd 0x70(%rcx),%esp
 c39:	5f                   	pop    %rdi
 c3a:	69 70 76 36 5f 73 72 	imul   $0x72735f36,0x76(%rax),%esi
 c41:	63 00                	movsxd (%rax),%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
 c43:	63 72 65             	movsxd 0x65(%rdx),%esi
 c46:	61                   	(bad)
 c47:	74 65                	je     cae <balancer_ingress+0xcae>
 c49:	5f                   	pop    %rdi
 c4a:	76 36                	jbe    c82 <balancer_ingress+0xc82>
 c4c:	5f                   	pop    %rdi
 c4d:	68 64 72 00 74       	push   $0x74007264
 c52:	63 00                	movsxd (%rax),%eax
 c54:	67 65 74 5f          	addr32 gs je cb7 <balancer_ingress+0xcb7>
 c58:	70 61                	jo     cbb <balancer_ingress+0xcbb>
 c5a:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 c5d:	74 5f                	je     cbe <balancer_ingress+0xcbe>
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
 c5f:	68 61 73 68 00       	push   $0x687361
 c64:	6a 68                	push   $0x68
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 c66:	61                   	(bad)
 c67:	73 68                	jae    cd1 <balancer_ingress+0xcd1>
 c69:	00 6c 65 6e          	add    %ch,0x6e(%rbp,%riz,2)
 c6d:	67 74 68             	addr32 je cd8 <balancer_ingress+0xcd8>
 c70:	00 69 6e             	add    %ch,0x6e(%rcx)
 c73:	69 74 76 61 6c 00 62 	imul   $0x62006c,0x61(%rsi,%rsi,2),%esi
 c7a:	00 
 c7b:	72 6f                	jb     cec <balancer_ingress+0xcec>
      if (!data_stats) {
 c7d:	6c                   	insb   (%dx),%es:(%rdi)
 c7e:	33 32                	xor    (%rdx),%esi
 c80:	00 77 6f             	add    %dh,0x6f(%rdi)
 c83:	72 64                	jb     ce9 <balancer_ingress+0xce9>
      data_stats->v1 += 1;
 c85:	00 73 68             	add    %dh,0x68(%rbx)
 c88:	69 66 74 00 5f 5f 6a 	imul   $0x6a5f5f00,0x74(%rsi),%esp
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
 c8f:	68 61 73 68 5f       	push   $0x5f687361
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
 c94:	6e                   	outsb  %ds:(%rsi),(%dx)
 c95:	77 6f                	ja     d06 <balancer_ingress+0xd06>
 c97:	72 64                	jb     cfd <balancer_ingress+0xcfd>
        data_stats->v2 += 1;
 c99:	73 00                	jae    c9b <balancer_ingress+0xc9b>
 c9b:	6a 68                	push   $0x68
 c9d:	61                   	(bad)
 c9e:	73 68                	jae    d08 <balancer_ingress+0xd08>
 ca0:	5f                   	pop    %rdi
 ca1:	32 77 6f             	xor    0x6f(%rdi),%dh
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
 ca4:	72 64                	jb     d0a <balancer_ingress+0xd0a>
 ca6:	73 00                	jae    ca8 <balancer_ingress+0xca8>
 ca8:	75 70                	jne    d1a <balancer_ingress+0xd1a>
 caa:	64 61                	fs (bad)
 cac:	74 65                	je     d13 <balancer_ingress+0xd13>
 cae:	5f                   	pop    %rdi
 caf:	76 69                	jbe    d1a <balancer_ingress+0xd1a>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
 cb1:	70 5f                	jo     d12 <balancer_ingress+0xd12>
 cb3:	6c                   	insb   (%dx),%es:(%rdi)
 cb4:	72 75                	jb     d2b <balancer_ingress+0xd2b>
 cb6:	5f                   	pop    %rdi
 cb7:	6d                   	insl   (%dx),%es:(%rdi)
 cb8:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
        quic_packets_stats->cid_initial += 1;
 cbf:	74 73                	je     d34 <balancer_ingress+0xd34>
 cc1:	00 76 69             	add    %dh,0x69(%rsi)
 cc4:	70 5f                	jo     d25 <balancer_ingress+0xd25>
 cc6:	6d                   	insl   (%dx),%es:(%rdi)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
 cc7:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 cce:	74 73                	je     d43 <balancer_ingress+0xd43>
 cd0:	5f                   	pop    %rdi
 cd1:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 cd5:	6c                   	insb   (%dx),%es:(%rdi)
 cd6:	72 75                	jb     d4d <balancer_ingress+0xd4d>
 cd8:	5f                   	pop    %rdi
 cd9:	6d                   	insl   (%dx),%es:(%rdi)
 cda:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
  if (!per_vip_stats) {
 ce1:	74 5f                	je     d42 <balancer_ingress+0xd42>
    per_vip_stats->v1 += 1;
 ce3:	76 69                	jbe    d4e <balancer_ingress+0xd4e>
 ce5:	70 00                	jo     ce7 <balancer_ingress+0xce7>
 ce7:	61                   	(bad)
 ce8:	64 64 72 65          	fs fs jb d51 <balancer_ingress+0xd51>
 cec:	73 73                	jae    d61 <balancer_ingress+0xd61>
 cee:	5f                   	pop    %rdi
 cef:	6d                   	insl   (%dx),%es:(%rdi)
    dst_lru->atime = cur_time;
 cf0:	61                   	(bad)
 cf1:	74 63                	je     d56 <balancer_ingress+0xd56>
 cf3:	68 00 70 6f 72       	push   $0x726f7000
 cf8:	74 5f                	je     d59 <balancer_ingress+0xd59>
  key = dst_lru->pos;
 cfa:	6d                   	insl   (%dx),%es:(%rdi)
 cfb:	61                   	(bad)
 cfc:	74 63                	je     d61 <balancer_ingress+0xd61>
 cfe:	68 00 70 72 6f       	push   $0x6f727000
  *real = bpf_map_lookup_elem(&reals, &key);
 d03:	74 6f                	je     d74 <balancer_ingress+0xd74>
 d05:	5f                   	pop    %rdi
 d06:	6d                   	insl   (%dx),%es:(%rdi)
 d07:	61                   	(bad)
 d08:	74 63                	je     d6d <balancer_ingress+0xd6d>
 d0a:	68 00 76 69 70       	push   $0x70697600
 d0f:	5f                   	pop    %rdi
 d10:	6d                   	insl   (%dx),%es:(%rdi)
 d11:	61                   	(bad)
 d12:	74 63                	je     d77 <balancer_ingress+0xd77>
 d14:	68 00 6c 72 75       	push   $0x75726c00
 d19:	5f                   	pop    %rdi
 d1a:	6d                   	insl   (%dx),%es:(%rdi)
 d1b:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
 d22:	74 00                	je     d24 <balancer_ingress+0xd24>
 d24:	69 6e 63 72 65 6d 65 	imul   $0x656d6572,0x63(%rsi),%ebp
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
 d2b:	6e                   	outsb  %ds:(%rsi),(%dx)
 d2c:	74 5f                	je     d8d <balancer_ingress+0xd8d>
 d2e:	71 75                	jno    da5 <balancer_ingress+0xda5>
 d30:	69 63 5f 63 69 64 5f 	imul   $0x5f646963,0x5f(%rbx),%esp
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
 d37:	76 65                	jbe    d9e <balancer_ingress+0xd9e>
 d39:	72 73                	jb     dae <balancer_ingress+0xdae>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
 d3b:	69 6f 6e 5f 73 74 61 	imul   $0x6174735f,0x6e(%rdi),%ebp
 d42:	74 73                	je     db7 <balancer_ingress+0xdb7>
 d44:	00 63 68             	add    %ah,0x68(%rbx)
 d47:	65 63 6b 5f          	movsxd %gs:0x5f(%rbx),%ebp
 d4b:	61                   	(bad)
 d4c:	6e                   	outsb  %ds:(%rsi),(%dx)
 d4d:	64 5f                	fs pop %rdi
 d4f:	75 70                	jne    dc1 <balancer_ingress+0xdc1>
 d51:	64 61                	fs (bad)
  if (!conn_rate_stats) {
 d53:	74 65                	je     dba <balancer_ingress+0xdba>
 d55:	5f                   	pop    %rdi
 d56:	72 65                	jb     dbd <balancer_ingress+0xdbd>
 d58:	61                   	(bad)
 d59:	6c                   	insb   (%dx),%es:(%rdi)
 d5a:	5f                   	pop    %rdi
 d5b:	69 6e 64 65 78 5f 69 	imul   $0x695f7865,0x64(%rsi),%ebp
 d62:	6e                   	outsb  %ds:(%rsi),(%dx)
 d63:	5f                   	pop    %rdi
 d64:	6c                   	insb   (%dx),%es:(%rdi)
  *cur_time = bpf_ktime_get_ns();
 d65:	72 75                	jb     ddc <balancer_ingress+0xddc>
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
 d67:	00 44 57 5f          	add    %al,0x5f(%rdi,%rdx,2)
 d6b:	41 54                	push   %r12
 d6d:	45 5f                	rex.RB pop %r15
 d6f:	75 6e                	jne    ddf <balancer_ingress+0xddf>
 d71:	73 69                	jae    ddc <balancer_ingress+0xddc>
 d73:	67 6e                	outsb  %ds:(%esi),(%dx)
 d75:	65 64 5f             	gs fs pop %rdi
    conn_rate_stats->v1 = 1;
 d78:	38 00                	cmp    %al,(%rax)
 d7a:	44 57                	rex.R push %rdi
 d7c:	5f                   	pop    %rdi
 d7d:	41 54                	push   %r12
    conn_rate_stats->v2 = *cur_time;
 d7f:	45 5f                	rex.RB pop %r15
 d81:	75 6e                	jne    df1 <balancer_ingress+0xdf1>
 d83:	73 69                	jae    dee <balancer_ingress+0xdee>
    conn_rate_stats->v1 += 1;
 d85:	67 6e                	outsb  %ds:(%esi),(%dx)
 d87:	65 64 5f             	gs fs pop %rdi
 d8a:	31 00                	xor    %eax,(%rax)
 d8c:	44 57                	rex.R push %rdi
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
 d8e:	5f                   	pop    %rdi
 d8f:	41 54                	push   %r12
 d91:	45 5f                	rex.RB pop %r15
 d93:	75 6e                	jne    e03 <balancer_ingress+0xe03>
 d95:	73 69                	jae    e00 <balancer_ingress+0xe00>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
 d97:	67 6e                	outsb  %ds:(%esi),(%dx)
 d99:	65 64 5f             	gs fs pop %rdi
 d9c:	33 32                	xor    (%rdx),%esi
 d9e:	00 44 57 5f          	add    %al,0x5f(%rdi,%rdx,2)
 da2:	41 54                	push   %r12
 da4:	45 5f                	rex.RB pop %r15
 da6:	75 6e                	jne    e16 <balancer_ingress+0xe16>
 da8:	73 69                	jae    e13 <balancer_ingress+0xe13>
 daa:	67 6e                	outsb  %ds:(%esi),(%dx)
 dac:	65 64 5f             	gs fs pop %rdi
 daf:	31 36                	xor    %esi,(%rsi)
    if (down_reals_map) {
 db1:	00 62 61             	add    %ah,0x61(%rdx)
 db4:	6c                   	insb   (%dx),%es:(%rdi)
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
 db5:	61                   	(bad)
 db6:	6e                   	outsb  %ds:(%rsi),(%dx)
 db7:	63 65 72             	movsxd 0x72(%rbp),%esp
 dba:	5f                   	pop    %rdi
 dbb:	69 6e 67 72 65 73 73 	imul   $0x73736572,0x67(%rsi),%ebp
      if (down_real) {
 dc2:	00 63 74             	add    %ah,0x74(%rbx)
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
 dc5:	78 00                	js     dc7 <balancer_ingress+0xdc7>
 dc7:	65 74 68             	gs je  e32 <balancer_ingress+0xe32>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
 dca:	5f                   	pop    %rdi
 dcb:	70 72                	jo     e3f <balancer_ingress+0xe3f>
 dcd:	6f                   	outsl  %ds:(%rsi),(%dx)
 dce:	74 6f                	je     e3f <balancer_ingress+0xe3f>
	...

Disassembly of section .debug_addr:

0000000000000000 <.debug_addr>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
   1:	06                   	(bad)
   2:	00 00                	add    %al,(%rax)
   4:	05 00 08 00 f3       	add    $0xf3000800,%eax
   9:	1e                   	(bad)
   a:	00 00                	add    %al,(%rax)
   c:	00 00                	add    %al,(%rax)
   e:	00 00                	add    %al,(%rax)
  10:	00 d8                	add    %bl,%al
  12:	b9 7e 81 88 ff       	mov    $0xff88817e,%ecx
  17:	ff 00                	incl   (%rax)
  void* data = (void*)(long)ctx->data;
  19:	60                   	(bad)
  1a:	27                   	(bad)
  void* data_end = (void*)(long)ctx->data_end;
  1b:	43 81 88 ff ff 00 58 	rex.XB orl $0x88814327,0x5800ffff(%r8)
  22:	27 43 81 88 
  if (data + nh_off > data_end) {
  26:	ff                   	(bad)
  27:	ff 00                	incl   (%rax)
  29:	50                   	push   %rax
  2a:	01 d4                	add    %edx,%esp
  2c:	81 88 ff ff 00 10 73 	orl    $0xc9033073,0x1000ffff(%rax)
  33:	30 03 c9 
  eth_proto = eth->h_proto;
  36:	ff                   	(bad)
  37:	ff 00                	incl   (%rax)
  if (eth_proto == BE_ETH_P_IP) {
  39:	60                   	(bad)
  3a:	7b 40                	jnp    7c <balancer_ingress+0x7c>
  3c:	03 c9                	add    %ecx,%ecx
  3e:	ff                   	(bad)
  3f:	ff 00                	incl   (%rax)
  41:	00 7d 40             	add    %bh,0x40(%rbp)
  44:	03 c9                	add    %ecx,%ecx
  46:	ff                   	(bad)
  47:	ff 00                	incl   (%rax)
  49:	a0 7d 40 03 c9 ff ff 	movabs 0xdc00ffffc903407d,%al
  50:	00 dc 
  52:	b9 7e 81 88 ff       	mov    $0xff88817e,%ecx
  struct packet_description pckt = {};
  57:	ff 00                	incl   (%rax)
  59:	c0 71 77 81          	shlb   $0x81,0x77(%rcx)
  5d:	88 ff                	mov    %bh,%bh
  5f:	ff 00                	incl   (%rax)
  61:	e0 b9                	loopne 1c <balancer_ingress+0x1c>
  63:	7e 81                	jle    ffffffffffffffe6 <server_id_map+0x36fcbf81bfe6>
  65:	88 ff                	mov    %bh,%bh
  67:	ff 00                	incl   (%rax)
  69:	e4 b9                	in     $0xb9,%al
  6b:	7e 81                	jle    ffffffffffffffee <server_id_map+0x36fcbf81bfee>
  6d:	88 ff                	mov    %bh,%bh
  6f:	ff 00                	incl   (%rax)
  71:	00 77 c4             	add    %dh,-0x3c(%rdi)
  74:	81 88 ff ff 00 40 7e 	orl    $0xc903407e,0x4000ffff(%rax)
  7b:	40 03 c9 
  7e:	ff                   	(bad)
  7f:	ff 00                	incl   (%rax)
  81:	e8 b9 7e 81 88       	call   ffffffff88817f3f <server_id_map+0x36fc48033f3f>
  struct vip_definition vip = {};
  86:	ff                   	(bad)
  87:	ff 00                	incl   (%rax)
  89:	c0 75 c4 81          	shlb   $0x81,-0x3c(%rbp)
  8d:	88 ff                	mov    %bh,%bh
  8f:	ff 00                	incl   (%rax)
  91:	58                   	pop    %rax
  92:	9e                   	sahf
  93:	5a                   	pop    %rdx
  94:	81 88 ff ff 00 00 00 	orl    $0x0,0xffff(%rax)
  9b:	00 00 00 
  9e:	00 00                	add    %al,(%rax)
  a0:	14 01                	adc    $0x1,%al
  a2:	00 00                	add    %al,(%rax)
    if (iph + 1 > data_end) {
  a4:	00 00                	add    %al,(%rax)
  a6:	00 00                	add    %al,(%rax)
  a8:	34 01                	xor    $0x1,%al
  aa:	00 00                	add    %al,(%rax)
  ac:	00 00                	add    %al,(%rax)
  ae:	00 00                	add    %al,(%rax)
  b0:	69 01 00 00 00 00    	imul   $0x0,(%rcx),%eax
    if (iph->ihl != 5) {
  b6:	00 00                	add    %al,(%rax)
  b8:	53                   	push   %rbx
  b9:	08 00                	or     %al,(%rax)
  bb:	00 00                	add    %al,(%rax)
    pckt->tos = iph->tos;
  bd:	00 00                	add    %al,(%rax)
  bf:	00 5a 08             	add    %bl,0x8(%rdx)
  c2:	00 00                	add    %al,(%rax)
    *protocol = iph->protocol;
  c4:	00 00                	add    %al,(%rax)
  c6:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
  c8:	8d 04 00             	lea    (%rax,%rax,1),%eax
    if (iph->frag_off & PCKT_FRAGMENTED) {
  cb:	00 00                	add    %al,(%rax)
  cd:	00 00                	add    %al,(%rax)
  cf:	00 c1                	add    %al,%cl
  d1:	0a 00                	or     (%rax),%al
  d3:	00 00                	add    %al,(%rax)
  d5:	00 00                	add    %al,(%rax)
  d7:	00 c8                	add    %cl,%al
  d9:	0a 00                	or     (%rax),%al
  db:	00 00                	add    %al,(%rax)
  dd:	00 00                	add    %al,(%rax)
  df:	00 f5                	add    %dh,%ch
    if (*protocol == IPPROTO_ICMP) {
  e1:	04 00                	add    $0x0,%al
  e3:	00 00                	add    %al,(%rax)
  e5:	00 00                	add    %al,(%rax)
  e7:	00 11                	add    %dl,(%rcx)
  if (icmp_hdr + 1 > data_end) {
  e9:	08 00                	or     %al,(%rax)
  eb:	00 00                	add    %al,(%rax)
  ed:	00 00                	add    %al,(%rax)
  ef:	00 f9                	add    %bh,%cl
  f1:	08 00                	or     %al,(%rax)
  f3:	00 00                	add    %al,(%rax)
  f5:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
  f7:	00 88 0a 00 00 00    	add    %cl,0xa(%rax)
  fd:	00 00                	add    %al,(%rax)
  ff:	00 42 09             	add    %al,0x9(%rdx)
 102:	00 00                	add    %al,(%rax)
 104:	00 00                	add    %al,(%rax)
 106:	00 00                	add    %al,(%rax)
 108:	9d                   	popf
 109:	09 00                	or     %eax,(%rax)
 10b:	00 00                	add    %al,(%rax)
 10d:	00 00                	add    %al,(%rax)
 10f:	00 c3                	add    %al,%bl
 111:	09 00                	or     %eax,(%rax)
 113:	00 00                	add    %al,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
 115:	00 00                	add    %al,(%rax)
 117:	00 ca                	add    %cl,%dl
  icmp_hdr->checksum += 0x0008;
 119:	09 00                	or     %eax,(%rax)
 11b:	00 00                	add    %al,(%rax)
 11d:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 11f:	00 20                	add    %ah,(%rax)
 121:	0a 00                	or     (%rax),%al
 123:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
 125:	00 00                	add    %al,(%rax)
 127:	00 9c 13 00 00 00 00 	add    %bl,0x0(%rbx,%rdx,1)
 12e:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
 130:	28 16                	sub    %dl,(%rsi)
 132:	00 00                	add    %al,(%rax)
    *csum += *next_iph_u16++;
 134:	00 00                	add    %al,(%rax)
 136:	00 00                	add    %al,(%rax)
 138:	4a 16                	rex.WX (bad)
 13a:	00 00                	add    %al,(%rax)
 13c:	00 00                	add    %al,(%rax)
 13e:	00 00                	add    %al,(%rax)
 140:	22 1e                	and    (%rsi),%bl
 142:	00 00                	add    %al,(%rax)
 144:	00 00                	add    %al,(%rax)
 146:	00 00                	add    %al,(%rax)
 148:	75 1e                	jne    168 <balancer_ingress+0x168>
 14a:	00 00                	add    %al,(%rax)
 14c:	00 00                	add    %al,(%rax)
 14e:	00 00                	add    %al,(%rax)
 150:	5e                   	pop    %rsi
 151:	0c 00                	or     $0x0,%al
 153:	00 00                	add    %al,(%rax)
 155:	00 00                	add    %al,(%rax)
 157:	00 65 0c             	add    %ah,0xc(%rbp)
 15a:	00 00                	add    %al,(%rax)
 15c:	00 00                	add    %al,(%rax)
 15e:	00 00                	add    %al,(%rax)
 160:	89 0c 00             	mov    %ecx,(%rax,%rax,1)
 163:	00 00                	add    %al,(%rax)
 165:	00 00                	add    %al,(%rax)
 167:	00 e4                	add    %ah,%ah
    if (csum >> 16)
 169:	16                   	(bad)
 16a:	00 00                	add    %al,(%rax)
 16c:	00 00                	add    %al,(%rax)
 16e:	00 00                	add    %al,(%rax)
 170:	2c 17                	sub    $0x17,%al
 172:	00 00                	add    %al,(%rax)
 174:	00 00                	add    %al,(%rax)
 176:	00 00                	add    %al,(%rax)
 178:	4a 17                	rex.WX (bad)
 17a:	00 00                	add    %al,(%rax)
 17c:	00 00                	add    %al,(%rax)
 17e:	00 00                	add    %al,(%rax)
 180:	5e                   	pop    %rsi
 181:	17                   	(bad)
 182:	00 00                	add    %al,(%rax)
 184:	00 00                	add    %al,(%rax)
  struct packet_description pckt = {};
 186:	00 00                	add    %al,(%rax)
 188:	65 17                	gs (bad)
 18a:	00 00                	add    %al,(%rax)
 18c:	00 00                	add    %al,(%rax)
 18e:	00 00                	add    %al,(%rax)
 190:	c0 17 00             	rclb   $0x0,(%rdi)
 193:	00 00                	add    %al,(%rax)
 195:	00 00                	add    %al,(%rax)
 197:	00 e0                	add    %ah,%al
 199:	17                   	(bad)
 19a:	00 00                	add    %al,(%rax)
 19c:	00 00                	add    %al,(%rax)
 19e:	00 00                	add    %al,(%rax)
 1a0:	ef                   	out    %eax,(%dx)
 1a1:	17                   	(bad)
 1a2:	00 00                	add    %al,(%rax)
 1a4:	00 00                	add    %al,(%rax)
 1a6:	00 00                	add    %al,(%rax)
 1a8:	f6 17                	notb   (%rdi)
 1aa:	00 00                	add    %al,(%rax)
 1ac:	00 00                	add    %al,(%rax)
 1ae:	00 00                	add    %al,(%rax)
 1b0:	fd                   	std
 1b1:	19 00                	sbb    %eax,(%rax)
 1b3:	00 00                	add    %al,(%rax)
 1b5:	00 00                	add    %al,(%rax)
  struct vip_definition vip = {};
 1b7:	00 04 1a             	add    %al,(%rdx,%rbx,1)
 1ba:	00 00                	add    %al,(%rax)
 1bc:	00 00                	add    %al,(%rax)
 1be:	00 00                	add    %al,(%rax)
 1c0:	4b 1a 00             	rex.WXB sbb (%r8),%al
 1c3:	00 00                	add    %al,(%rax)
 1c5:	00 00                	add    %al,(%rax)
 1c7:	00 81 1b 00 00 00    	add    %al,0x1b(%rcx)
 1cd:	00 00                	add    %al,(%rax)
 1cf:	00 aa 1b 00 00 00    	add    %ch,0x1b(%rdx)
 1d5:	00 00                	add    %al,(%rax)
    if (ip6h + 1 > data_end) {
 1d7:	00 bb 1b 00 00 00    	add    %bh,0x1b(%rbx)
 1dd:	00 00                	add    %al,(%rax)
 1df:	00 c4                	add    %al,%ah
 1e1:	1b 00                	sbb    (%rax),%eax
    *protocol = ip6h->nexthdr;
 1e3:	00 00                	add    %al,(%rax)
 1e5:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
 1e7:	00 cd                	add    %cl,%ch
 1e9:	1b 00                	sbb    (%rax),%eax
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1eb:	00 00                	add    %al,(%rax)
 1ed:	00 00                	add    %al,(%rax)
 1ef:	00 d6                	add    %dl,%dh
 1f1:	1b 00                	sbb    (%rax),%eax
 1f3:	00 00                	add    %al,(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1f5:	00 00                	add    %al,(%rax)
 1f7:	00 df                	add    %bl,%bh
 1f9:	1b 00                	sbb    (%rax),%eax
 1fb:	00 00                	add    %al,(%rax)
 1fd:	00 00                	add    %al,(%rax)
 1ff:	00 e8                	add    %ch,%al
    if (*protocol == IPPROTO_FRAGMENT) {
 201:	1b 00                	sbb    (%rax),%eax
 203:	00 00                	add    %al,(%rax)
 205:	00 00                	add    %al,(%rax)
 207:	00 ef                	add    %ch,%bh
 209:	1b 00                	sbb    (%rax),%eax
 20b:	00 00                	add    %al,(%rax)
 20d:	00 00                	add    %al,(%rax)
 20f:	00 3d 1c 00 00 00    	add    %bh,0x1c(%rip)        # 231 <balancer_ingress+0x231>
  if (icmp_hdr + 1 > data_end) {
 215:	00 00                	add    %al,(%rax)
 217:	00 03                	add    %al,(%rbx)
 219:	1d 00 00 00 00       	sbb    $0x0,%eax
 21e:	00 00                	add    %al,(%rax)
 220:	34 1d                	xor    $0x1d,%al
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 222:	00 00                	add    %al,(%rax)
 224:	00 00                	add    %al,(%rax)
 226:	00 00                	add    %al,(%rax)
 228:	38 1d 00 00 00 00    	cmp    %bl,0x0(%rip)        # 22e <balancer_ingress+0x22e>
 22e:	00 00                	add    %al,(%rax)
 230:	2c 18                	sub    $0x18,%al
 232:	00 00                	add    %al,(%rax)
 234:	00 00                	add    %al,(%rax)
 236:	00 00                	add    %al,(%rax)
 238:	6d                   	insl   (%dx),%es:(%rdi)
 239:	18 00                	sbb    %al,(%rax)
 23b:	00 00                	add    %al,(%rax)
 23d:	00 00                	add    %al,(%rax)
 23f:	00 a7 18 00 00 00    	add    %ah,0x18(%rdi)
 245:	00 00                	add    %al,(%rax)
 247:	00 39                	add    %bh,(%rcx)
 249:	19 00                	sbb    %eax,(%rax)
 24b:	00 00                	add    %al,(%rax)
 24d:	00 00                	add    %al,(%rax)
 24f:	00 61 19             	add    %ah,0x19(%rcx)
 252:	00 00                	add    %al,(%rax)
 254:	00 00                	add    %al,(%rax)
 256:	00 00                	add    %al,(%rax)
 258:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
 259:	1a 00                	sbb    (%rax),%al
 25b:	00 00                	add    %al,(%rax)
 25d:	00 00                	add    %al,(%rax)
 25f:	00 0e                	add    %cl,(%rsi)
 261:	1b 00                	sbb    (%rax),%eax
 263:	00 00                	add    %al,(%rax)
 265:	00 00                	add    %al,(%rax)
 267:	00 14 1b             	add    %dl,(%rbx,%rbx,1)
 26a:	00 00                	add    %al,(%rax)
 26c:	00 00                	add    %al,(%rax)
 26e:	00 00                	add    %al,(%rax)
 270:	25 05 00 00 00       	and    $0x5,%eax
 275:	00 00                	add    %al,(%rax)
 277:	00 2c 05 00 00 00 00 	add    %ch,0x0(,%rax,1)
 27e:	00 00                	add    %al,(%rax)
 280:	ff 02                	incl   (%rdx)
 282:	00 00                	add    %al,(%rax)
 284:	00 00                	add    %al,(%rax)
 286:	00 00                	add    %al,(%rax)
 288:	31 03                	xor    %eax,(%rbx)
 28a:	00 00                	add    %al,(%rax)
 28c:	00 00                	add    %al,(%rax)
 28e:	00 00                	add    %al,(%rax)
 290:	70 03                	jo     295 <balancer_ingress+0x295>
 292:	00 00                	add    %al,(%rax)
 294:	00 00                	add    %al,(%rax)
 296:	00 00                	add    %al,(%rax)
 298:	5b                   	pop    %rbx
 299:	07                   	(bad)
 29a:	00 00                	add    %al,(%rax)
 29c:	00 00                	add    %al,(%rax)
 29e:	00 00                	add    %al,(%rax)
 2a0:	62                   	(bad)
 2a1:	07                   	(bad)
 2a2:	00 00                	add    %al,(%rax)
 2a4:	00 00                	add    %al,(%rax)
 2a6:	00 00                	add    %al,(%rax)
 2a8:	25 04 00 00 00       	and    $0x4,%eax
 2ad:	00 00                	add    %al,(%rax)
 2af:	00 a4 04 00 00 00 00 	add    %ah,0x0(%rsp,%rax,1)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2b6:	00 00                	add    %al,(%rax)
 2b8:	e4 05                	in     $0x5,%al
 2ba:	00 00                	add    %al,(%rax)
 2bc:	00 00                	add    %al,(%rax)
 2be:	00 00                	add    %al,(%rax)
 2c0:	da 07                	fiaddl (%rdi)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2c2:	00 00                	add    %al,(%rax)
 2c4:	00 00                	add    %al,(%rax)
 2c6:	00 00                	add    %al,(%rax)
 2c8:	2d 06 00 00 00       	sub    $0x6,%eax
 2cd:	00 00                	add    %al,(%rax)
 2cf:	00 88 06 00 00 00    	add    %cl,0x6(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 2d5:	00 00                	add    %al,(%rax)
 2d7:	00 ae 06 00 00 00    	add    %ch,0x6(%rsi)
  if (icmp_hdr + 1 > data_end) {
 2dd:	00 00                	add    %al,(%rax)
 2df:	00 b5 06 00 00 00    	add    %dh,0x6(%rbp)
 2e5:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
 2e7:	00 0b                	add    %cl,(%rbx)
 2e9:	07                   	(bad)
 2ea:	00 00                	add    %al,(%rax)
 2ec:	00 00                	add    %al,(%rax)
 2ee:	00 00                	add    %al,(%rax)
 2f0:	c7                   	(bad)
 2f1:	0c 00                	or     $0x0,%al
 2f3:	00 00                	add    %al,(%rax)
 2f5:	00 00                	add    %al,(%rax)
 2f7:	00 c3                	add    %al,%bl
 2f9:	14 00                	adc    $0x0,%al
 2fb:	00 00                	add    %al,(%rax)
 2fd:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2ff:	00 e6                	add    %ah,%dh
 301:	14 00                	adc    $0x0,%al
 303:	00 00                	add    %al,(%rax)
 305:	00 00                	add    %al,(%rax)
 307:	00 c6                	add    %al,%dh
       sizeof(struct icmphdr)) > data_end) {
 309:	15 00 00 00 00       	adc    $0x0,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 30e:	00 00                	add    %al,(%rax)
 310:	a2 1d 00 00 00 00 00 	movabs %al,0x450000000000001d
 317:	00 45 
  icmp_hdr->checksum += 0x0008;
 319:	0b 00                	or     (%rax),%eax
 31b:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 31d:	00 00                	add    %al,(%rax)
 31f:	00 4c 0b 00          	add    %cl,0x0(%rbx,%rcx,1)
  iph->daddr = iph->saddr;
 323:	00 00                	add    %al,(%rax)
  tmp_addr = iph->daddr;
 325:	00 00                	add    %al,(%rax)
 327:	00 70 0b             	add    %dh,0xb(%rax)
  iph->daddr = iph->saddr;
 32a:	00 00                	add    %al,(%rax)
 32c:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
 32e:	00 00                	add    %al,(%rax)
 330:	02 0d 00 00 00 00    	add    0x0(%rip),%cl        # 336 <balancer_ingress+0x336>
    *csum += *next_iph_u16++;
 336:	00 00                	add    %al,(%rax)
 338:	20 0d 00 00 00 00    	and    %cl,0x0(%rip)        # 33e <balancer_ingress+0x33e>
 33e:	00 00                	add    %al,(%rax)
 340:	34 0d                	xor    $0xd,%al
 342:	00 00                	add    %al,(%rax)
 344:	00 00                	add    %al,(%rax)
 346:	00 00                	add    %al,(%rax)
 348:	3b 0d 00 00 00 00    	cmp    0x0(%rip),%ecx        # 34e <balancer_ingress+0x34e>
 34e:	00 00                	add    %al,(%rax)
 350:	96                   	xchg   %eax,%esi
 351:	0d 00 00 00 00       	or     $0x0,%eax
 356:	00 00                	add    %al,(%rax)
 358:	b5 0d                	mov    $0xd,%ch
 35a:	00 00                	add    %al,(%rax)
 35c:	00 00                	add    %al,(%rax)
 35e:	00 00                	add    %al,(%rax)
 360:	c3                   	ret
 361:	0d 00 00 00 00       	or     $0x0,%eax
 366:	00 00                	add    %al,(%rax)
 368:	ca 0d 00             	lret   $0xd
 36b:	00 00                	add    %al,(%rax)
 36d:	00 00                	add    %al,(%rax)
 36f:	00 52 0f             	add    %dl,0xf(%rdx)
    if (csum >> 16)
 372:	00 00                	add    %al,(%rax)
 374:	00 00                	add    %al,(%rax)
 376:	00 00                	add    %al,(%rax)
 378:	59                   	pop    %rcx
 379:	0f 00 00             	sldt   (%rax)
 37c:	00 00                	add    %al,(%rax)
 37e:	00 00                	add    %al,(%rax)
 380:	a0 0f 00 00 00 00 00 	movabs 0xbf0000000000000f,%al
 387:	00 bf 
 389:	10 00                	adc    %al,(%rax)
 38b:	00 00                	add    %al,(%rax)
 38d:	00 00                	add    %al,(%rax)
 38f:	00 17                	add    %dl,(%rdi)
 391:	11 00                	adc    %eax,(%rax)
 393:	00 00                	add    %al,(%rax)
 395:	00 00                	add    %al,(%rax)
 397:	00 2e                	add    %ch,(%rsi)
 399:	11 00                	adc    %eax,(%rax)
 39b:	00 00                	add    %al,(%rax)
 39d:	00 00                	add    %al,(%rax)
 39f:	00 37                	add    %dh,(%rdi)
 3a1:	11 00                	adc    %eax,(%rax)
 3a3:	00 00                	add    %al,(%rax)
 3a5:	00 00                	add    %al,(%rax)
 3a7:	00 44 11 00          	add    %al,0x0(%rcx,%rdx,1)
 3ab:	00 00                	add    %al,(%rax)
 3ad:	00 00                	add    %al,(%rax)
 3af:	00 4f 11             	add    %cl,0x11(%rdi)
 3b2:	00 00                	add    %al,(%rax)
 3b4:	00 00                	add    %al,(%rax)
 3b6:	00 00                	add    %al,(%rax)
 3b8:	5a                   	pop    %rdx
 3b9:	11 00                	adc    %eax,(%rax)
 3bb:	00 00                	add    %al,(%rax)
 3bd:	00 00                	add    %al,(%rax)
 3bf:	00 89 11 00 00 00    	add    %cl,0x11(%rcx)
 3c5:	00 00                	add    %al,(%rax)
 3c7:	00 92 11 00 00 00    	add    %dl,0x11(%rdx)
 3cd:	00 00                	add    %al,(%rax)
 3cf:	00 9b 11 00 00 00    	add    %bl,0x11(%rbx)
 3d5:	00 00                	add    %al,(%rax)
 3d7:	00 a4 11 00 00 00 00 	add    %ah,0x0(%rcx,%rdx,1)
 3de:	00 00                	add    %al,(%rax)
 3e0:	ad                   	lods   %ds:(%rsi),%eax
 3e1:	11 00                	adc    %eax,(%rax)
 3e3:	00 00                	add    %al,(%rax)
 3e5:	00 00                	add    %al,(%rax)
 3e7:	00 b6 11 00 00 00    	add    %dh,0x11(%rsi)
 3ed:	00 00                	add    %al,(%rax)
 3ef:	00 bd 11 00 00 00    	add    %bh,0x11(%rbp)
 3f5:	00 00                	add    %al,(%rax)
 3f7:	00 c0                	add    %al,%al
 3f9:	11 00                	adc    %eax,(%rax)
 3fb:	00 00                	add    %al,(%rax)
 3fd:	00 00                	add    %al,(%rax)
 3ff:	00 d8                	add    %bl,%al
 401:	11 00                	adc    %eax,(%rax)
 403:	00 00                	add    %al,(%rax)
 405:	00 00                	add    %al,(%rax)
 407:	00 e1                	add    %ah,%cl
 409:	11 00                	adc    %eax,(%rax)
 40b:	00 00                	add    %al,(%rax)
 40d:	00 00                	add    %al,(%rax)
 40f:	00 ea                	add    %ch,%dl
 411:	11 00                	adc    %eax,(%rax)
 413:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_TCP) {
 415:	00 00                	add    %al,(%rax)
 417:	00 f3                	add    %dh,%bl
 419:	11 00                	adc    %eax,(%rax)
 41b:	00 00                	add    %al,(%rax)
 41d:	00 00                	add    %al,(%rax)
 41f:	00 fc                	add    %bh,%ah
 421:	11 00                	adc    %eax,(%rax)
 423:	00 00                	add    %al,(%rax)
  tcp = data + off;
 425:	00 00                	add    %al,(%rax)
 427:	00 05 12 00 00 00    	add    %al,0x12(%rip)        # 43f <balancer_ingress+0x43f>
 42d:	00 00                	add    %al,(%rax)
 42f:	00 0c 12             	add    %cl,(%rdx,%rdx,1)
  if (tcp + 1 > data_end) {
 432:	00 00                	add    %al,(%rax)
 434:	00 00                	add    %al,(%rax)
 436:	00 00                	add    %al,(%rax)
 438:	62 12                	(bad)
 43a:	00 00                	add    %al,(%rax)
 43c:	00 00                	add    %al,(%rax)
  if (tcp->syn) {
 43e:	00 00                	add    %al,(%rax)
 440:	c2 12 00             	ret    $0x12
    pckt->flags |= F_SYN_SET;
 443:	00 00                	add    %al,(%rax)
 445:	00 00                	add    %al,(%rax)
 447:	00 24 13             	add    %ah,(%rbx,%rdx,1)
 44a:	00 00                	add    %al,(%rax)
 44c:	00 00                	add    %al,(%rax)
      pckt->flow.src = iph->saddr;
 44e:	00 00                	add    %al,(%rax)
 450:	28 13                	sub    %dl,(%rbx)
 452:	00 00                	add    %al,(%rax)
      pckt->flow.dst = iph->daddr;
 454:	00 00                	add    %al,(%rax)
 456:	00 00                	add    %al,(%rax)
 458:	fc                   	cld
 459:	0d 00 00 00 00       	or     $0x0,%eax
  if (protocol == IPPROTO_ICMPV6) {
 45e:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 460:	42 0e                	rex.X (bad)
 462:	00 00                	add    %al,(%rax)
 464:	00 00                	add    %al,(%rax)
 466:	00 00                	add    %al,(%rax)
 468:	79 0e                	jns    478 <balancer_ingress+0x478>
 46a:	00 00                	add    %al,(%rax)
 46c:	00 00                	add    %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 46e:	00 00                	add    %al,(%rax)
 470:	07                   	(bad)
 471:	0f 00 00             	sldt   (%rax)
 474:	00 00                	add    %al,(%rax)
 476:	00 00                	add    %al,(%rax)
 478:	2f                   	(bad)
 479:	0f 00 00             	sldt   (%rax)
 47c:	00 00                	add    %al,(%rax)
 47e:	00 00                	add    %al,(%rax)
 480:	fe 0f                	decb   (%rdi)
 482:	00 00                	add    %al,(%rax)
 484:	00 00                	add    %al,(%rax)
 486:	00 00                	add    %al,(%rax)
 488:	67 10 00             	adc    %al,(%eax)
 48b:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 48d:	00 00                	add    %al,(%rax)
 48f:	00 73 10             	add    %dh,0x10(%rbx)
 492:	00 00                	add    %al,(%rax)
 494:	00 00                	add    %al,(%rax)
       sizeof(struct icmp6hdr)) > data_end) {
 496:	00 00                	add    %al,(%rax)
 498:	43 05 00 00 00 00    	rex.XB add $0x0,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 49e:	00 00                	add    %al,(%rax)
 4a0:	fe 05 00 00 00 00    	incb   0x0(%rip)        # 4a6 <balancer_ingress+0x4a6>
  udp = data + off;
 4a6:	00 00                	add    %al,(%rax)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 4a8:	47 06                	rex.RXB (bad)
 4aa:	00 00                	add    %al,(%rax)
  udp = data + off;
 4ac:	00 00                	add    %al,(%rax)
 4ae:	00 00                	add    %al,(%rax)
  if (udp + 1 > data_end) {
 4b0:	82                   	(bad)
 4b1:	06                   	(bad)
 4b2:	00 00                	add    %al,(%rax)
 4b4:	00 00                	add    %al,(%rax)
 4b6:	00 00                	add    %al,(%rax)
 4b8:	a2 06 00 00 00 00 00 	movabs %al,0xcc00000000000006
 4bf:	00 cc 
 4c1:	06                   	(bad)
 4c2:	00 00                	add    %al,(%rax)
 4c4:	00 00                	add    %al,(%rax)
 4c6:	00 00                	add    %al,(%rax)
 4c8:	22 07                	and    (%rdi),%al
 4ca:	00 00                	add    %al,(%rax)
 4cc:	00 00                	add    %al,(%rax)
 4ce:	00 00                	add    %al,(%rax)
 4d0:	79 07                	jns    4d9 <balancer_ingress+0x4d9>
 4d2:	00 00                	add    %al,(%rax)
 4d4:	00 00                	add    %al,(%rax)
 4d6:	00 00                	add    %al,(%rax)
 4d8:	f4                   	hlt
 4d9:	07                   	(bad)
 4da:	00 00                	add    %al,(%rax)
 4dc:	00 00                	add    %al,(%rax)
 4de:	00 00                	add    %al,(%rax)
 4e0:	71 08                	jno    4ea <balancer_ingress+0x4ea>
 4e2:	00 00                	add    %al,(%rax)
 4e4:	00 00                	add    %al,(%rax)
 4e6:	00 00                	add    %al,(%rax)
 4e8:	13 09                	adc    (%rcx),%ecx
 4ea:	00 00                	add    %al,(%rax)
 4ec:	00 00                	add    %al,(%rax)
 4ee:	00 00                	add    %al,(%rax)
 4f0:	5c                   	pop    %rsp
 4f1:	09 00                	or     %eax,(%rax)
 4f3:	00 00                	add    %al,(%rax)
  tcp = data + off;
 4f5:	00 00                	add    %al,(%rax)
 4f7:	00 97 09 00 00 00    	add    %dl,0x9(%rdi)
 4fd:	00 00                	add    %al,(%rax)
  if (tcp + 1 > data_end) {
 4ff:	00 b7 09 00 00 00    	add    %dh,0x9(%rdi)
 505:	00 00                	add    %al,(%rax)
 507:	00 e1                	add    %ah,%cl
 509:	09 00                	or     %eax,(%rax)
 50b:	00 00                	add    %al,(%rax)
  if (tcp->syn) {
 50d:	00 00                	add    %al,(%rax)
 50f:	00 37                	add    %dh,(%rdi)
 511:	0a 00                	or     (%rax),%al
 513:	00 00                	add    %al,(%rax)
 515:	00 00                	add    %al,(%rax)
    pckt->flags |= F_SYN_SET;
 517:	00 a2 0a 00 00 00    	add    %ah,0xa(%rdx)
 51d:	00 00                	add    %al,(%rax)
 51f:	00 df                	add    %bl,%bh
 521:	0a 00                	or     (%rax),%al
 523:	00 00                	add    %al,(%rax)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
 525:	00 00                	add    %al,(%rax)
 527:	00 63 0b             	add    %ah,0xb(%rbx)
 52a:	00 00                	add    %al,(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
 52c:	00 00                	add    %al,(%rax)
 52e:	00 00                	add    %al,(%rax)
 530:	a9 0b 00 00 00       	test   $0xb,%eax
 535:	00 00                	add    %al,(%rax)
 537:	00 c4                	add    %al,%ah
 539:	0b 00                	or     (%rax),%eax
 53b:	00 00                	add    %al,(%rax)
 53d:	00 00                	add    %al,(%rax)
 53f:	00 7c 0c 00          	add    %bh,0x0(%rsp,%rcx,1)
    if (!icmp_ptb_v6_stats) {
 543:	00 00                	add    %al,(%rax)
 545:	00 00                	add    %al,(%rax)
 547:	00 de                	add    %bl,%dh
 549:	0c 00                	or     $0x0,%al
 54b:	00 00                	add    %al,(%rax)
    icmp_ptb_v6_stats->v1 += 1;
 54d:	00 00                	add    %al,(%rax)
 54f:	00 52 0d             	add    %dl,0xd(%rdx)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 552:	00 00                	add    %al,(%rax)
 554:	00 00                	add    %al,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 556:	00 00                	add    %al,(%rax)
 558:	67 0d 00 00 00 00    	addr32 or $0x0,%eax
      icmp_ptb_v6_stats->v2 += 1;
 55e:	00 00                	add    %al,(%rax)
 560:	b0 0d                	mov    $0xd,%al
 562:	00 00                	add    %al,(%rax)
 564:	00 00                	add    %al,(%rax)
  if (ip6h + 1 > data_end) {
 566:	00 00                	add    %al,(%rax)
 568:	be 0d 00 00 00       	mov    $0xd,%esi
 56d:	00 00                	add    %al,(%rax)
 56f:	00 e1                	add    %ah,%cl
 571:	0d 00 00 00 00       	or     $0x0,%eax
  pckt->flow.proto = ip6h->nexthdr;
 576:	00 00                	add    %al,(%rax)
 578:	17                   	(bad)
  pckt->flags |= F_ICMP;
 579:	0e                   	(bad)
 57a:	00 00                	add    %al,(%rax)
 57c:	00 00                	add    %al,(%rax)
 57e:	00 00                	add    %al,(%rax)
 580:	53                   	push   %rbx
 581:	0e                   	(bad)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 582:	00 00                	add    %al,(%rax)
 584:	00 00                	add    %al,(%rax)
 586:	00 00                	add    %al,(%rax)
 588:	8f                   	(bad)
 589:	0e                   	(bad)
 58a:	00 00                	add    %al,(%rax)
 58c:	00 00                	add    %al,(%rax)
 58e:	00 00                	add    %al,(%rax)
 590:	70 0f                	jo     5a1 <balancer_ingress+0x5a1>
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 592:	00 00                	add    %al,(%rax)
 594:	00 00                	add    %al,(%rax)
 596:	00 00                	add    %al,(%rax)
 598:	b7 0f                	mov    $0xf,%bh
 59a:	00 00                	add    %al,(%rax)
 59c:	00 00                	add    %al,(%rax)
 59e:	00 00                	add    %al,(%rax)
 5a0:	cf                   	iret
 5a1:	0f 00 00             	sldt   (%rax)
 5a4:	00 00                	add    %al,(%rax)
 5a6:	00 00                	add    %al,(%rax)
 5a8:	08 10                	or     %dl,(%rax)
 5aa:	00 00                	add    %al,(%rax)
 5ac:	00 00                	add    %al,(%rax)
 5ae:	00 00                	add    %al,(%rax)
 5b0:	b4 12                	mov    $0x12,%ah
 5b2:	00 00                	add    %al,(%rax)
 5b4:	00 00                	add    %al,(%rax)
 5b6:	00 00                	add    %al,(%rax)
 5b8:	3f                   	(bad)
 5b9:	13 00                	adc    (%rax),%eax
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
 5bb:	00 00                	add    %al,(%rax)
 5bd:	00 00                	add    %al,(%rax)
 5bf:	00 b3 13 00 00 00    	add    %dh,0x13(%rbx)
 5c5:	00 00                	add    %al,(%rax)
 5c7:	00 27                	add    %ah,(%rdi)
 5c9:	15 00 00 00 00       	adc    $0x0,%eax
 5ce:	00 00                	add    %al,(%rax)
  vip.port = pckt.flow.port16[1];
 5d0:	d7                   	xlat   %ds:(%rbx)
 5d1:	15 00 00 00 00       	adc    $0x0,%eax
 5d6:	00 00                	add    %al,(%rax)
 5d8:	ec                   	in     (%dx),%al
 5d9:	15 00 00 00 00       	adc    $0x0,%eax
  vip.proto = pckt.flow.proto;
 5de:	00 00                	add    %al,(%rax)
 5e0:	8c 16                	mov    %ss,(%rsi)
 5e2:	00 00                	add    %al,(%rax)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 5e4:	00 00                	add    %al,(%rax)
 5e6:	00 00                	add    %al,(%rax)
 5e8:	e6 16                	out    %al,$0x16
 5ea:	00 00                	add    %al,(%rax)
 5ec:	00 00                	add    %al,(%rax)
 5ee:	00 00                	add    %al,(%rax)
 5f0:	fd                   	std
 5f1:	16                   	(bad)
 5f2:	00 00                	add    %al,(%rax)
 5f4:	00 00                	add    %al,(%rax)
 5f6:	00 00                	add    %al,(%rax)
 5f8:	7c 17                	jl     611 <balancer_ingress+0x611>
 5fa:	00 00                	add    %al,(%rax)
 5fc:	00 00                	add    %al,(%rax)
  if (!vip_info) {
 5fe:	00 00                	add    %al,(%rax)
 600:	91                   	xchg   %eax,%ecx
 601:	17                   	(bad)
 602:	00 00                	add    %al,(%rax)
 604:	00 00                	add    %al,(%rax)
 606:	00 00                	add    %al,(%rax)
  if (data_end - data > MAX_PCKT_SIZE) {
 608:	db 17                	fistl  (%rdi)
 60a:	00 00                	add    %al,(%rax)
 60c:	00 00                	add    %al,(%rax)
 60e:	00 00                	add    %al,(%rax)
 610:	ea                   	(bad)
 611:	17                   	(bad)
 612:	00 00                	add    %al,(%rax)
 614:	00 00                	add    %al,(%rax)
 616:	00 00                	add    %al,(%rax)
 618:	0d 18 00 00 00       	or     $0x18,%eax
 61d:	00 00                	add    %al,(%rax)
 61f:	00 47 18             	add    %al,0x18(%rdi)
 622:	00 00                	add    %al,(%rax)
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
 624:	00 00                	add    %al,(%rax)
 626:	00 00                	add    %al,(%rax)
 628:	7e 18                	jle    642 <balancer_ingress+0x642>
 62a:	00 00                	add    %al,(%rax)
 62c:	00 00                	add    %al,(%rax)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 62e:	00 00                	add    %al,(%rax)
 630:	bd 18 00 00 00       	mov    $0x18,%ebp
 635:	00 00                	add    %al,(%rax)
 637:	00 1b                	add    %bl,(%rbx)
 639:	1a 00                	sbb    (%rax),%al
 63b:	00 00                	add    %al,(%rax)
 63d:	00 00                	add    %al,(%rax)
 63f:	00 62 1a             	add    %ah,0x1a(%rdx)
 642:	00 00                	add    %al,(%rax)
 644:	00 00                	add    %al,(%rax)
 646:	00 00                	add    %al,(%rax)
  if (!data_stats) {
 648:	7a 1a                	jp     664 <balancer_ingress+0x664>
 64a:	00 00                	add    %al,(%rax)
 64c:	00 00                	add    %al,(%rax)
 64e:	00 00                	add    %al,(%rax)
 650:	af                   	scas   %es:(%rdi),%eax
 651:	1a 00                	sbb    (%rax),%al
 653:	00 00                	add    %al,(%rax)
 655:	00 00                	add    %al,(%rax)
  data_stats->v1 += 1;
 657:	00 63 1c             	add    %ah,0x1c(%rbx)
 65a:	00 00                	add    %al,(%rax)
 65c:	00 00                	add    %al,(%rax)
 65e:	00 00                	add    %al,(%rax)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 660:	8c 1c 00             	mov    %ds,(%rax,%rax,1)
 663:	00 00                	add    %al,(%rax)
    pckt.flow.port16[0] = 0;
 665:	00 00                	add    %al,(%rax)
 667:	00 f5                	add    %dh,%ch
 669:	1c 00                	sbb    $0x0,%al
  vip_num = vip_info->vip_num;
 66b:	00 00                	add    %al,(%rax)
 66d:	00 00                	add    %al,(%rax)
 66f:	00 4f 1d             	add    %cl,0x1d(%rdi)
 672:	00 00                	add    %al,(%rax)
 674:	00 00                	add    %al,(%rax)
 676:	00 00                	add    %al,(%rax)
 678:	b9 1d 00 00 00       	mov    $0x1d,%ecx
 67d:	00 00                	add    %al,(%rax)
 67f:	00 07                	add    %al,(%rdi)
  __u32 cpu_num = bpf_get_smp_processor_id();
 681:	1e                   	(bad)
 682:	00 00                	add    %al,(%rax)
 684:	00 00                	add    %al,(%rax)
 686:	00 00                	add    %al,(%rax)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 688:	33 1e                	xor    (%rsi),%ebx
 68a:	00 00                	add    %al,(%rax)
 68c:	00 00                	add    %al,(%rax)
 68e:	00 00                	add    %al,(%rax)
 690:	48 1e                	rex.W (bad)
 692:	00 00                	add    %al,(%rax)
 694:	00 00                	add    %al,(%rax)
 696:	00 00                	add    %al,(%rax)
 698:	8c 1e                	mov    %ds,(%rsi)
 69a:	00 00                	add    %al,(%rax)
 69c:	00 00                	add    %al,(%rax)
 69e:	00 00                	add    %al,(%rax)
 6a0:	da 1e                	ficompl (%rsi)
 6a2:	00 00                	add    %al,(%rax)
 6a4:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_line:

0000000000000000 <.debug_line>:
int balancer_ingress(struct xdp_md* ctx) {
       0:	77 15                	ja     17 <balancer_ingress+0x17>
       2:	00 00                	add    %al,(%rax)
       4:	05 00 08 00 19       	add    $0x19000800,%eax
       9:	02 00                	add    (%rax),%al
       b:	00 01                	add    %al,(%rcx)
       d:	01 01                	add    %eax,(%rcx)
       f:	fb                   	sti
      10:	0e                   	(bad)
      11:	0d 00 01 01 01       	or     $0x1010100,%eax
      16:	01 00                	add    %eax,(%rax)
  void* data = (void*)(long)ctx->data;
      18:	00 00                	add    %al,(%rax)
      1a:	01 00                	add    %eax,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
      1c:	00 01                	add    %al,(%rcx)
      1e:	01 01                	add    %eax,(%rcx)
  if (data + nh_off > data_end) {
      20:	1f                   	(bad)
      21:	06                   	(bad)
      22:	00 00                	add    %al,(%rax)
      24:	00 00                	add    %al,(%rax)
      26:	2b 00                	sub    (%rax),%eax
      28:	00 00                	add    %al,(%rax)
      2a:	3c 00                	cmp    $0x0,%al
      2c:	00 00                	add    %al,(%rax)
      2e:	55                   	push   %rbp
      2f:	00 00                	add    %al,(%rax)
      31:	00 68 00             	add    %ch,0x0(%rax)
  eth_proto = eth->h_proto;
      34:	00 00                	add    %al,(%rax)
      36:	97                   	xchg   %eax,%edi
      37:	00 00                	add    %al,(%rax)
  if (eth_proto == BE_ETH_P_IP) {
      39:	00 03                	add    %al,(%rbx)
      3b:	01 1f                	add    %ebx,(%rdi)
      3d:	02 0f                	add    (%rdi),%cl
      3f:	05 1e 17 b3 00       	add    $0xb3171e,%eax
      44:	00 00                	add    %al,(%rax)
      46:	00 29                	add    %ch,(%rcx)
      48:	b8 64 55 2d 42       	mov    $0x422d5564,%eax
      4d:	48 11 96 a1 56 28 f9 	adc    %rdx,-0x6d7a95f(%rsi)
  struct packet_description pckt = {};
      54:	61                   	(bad)
      55:	78 bb                	js     12 <balancer_ingress+0x12>
      57:	d1 00                	roll   (%rax)
      59:	00 00                	add    %al,(%rax)
      5b:	01 5b e9             	add    %ebx,-0x17(%rbx)
      5e:	d1 d0                	rcl    %eax
      60:	ad                   	lods   %ds:(%rsi),%eax
      61:	34 bd                	xor    $0xbd,%al
      63:	71 a1                	jno    6 <balancer_ingress+0x6>
      65:	66 7a 92             	data16 jp fffffffffffffffa <server_id_map+0x36fcbf81bffa>
      68:	98                   	cwtl
      69:	70 c0                	jo     2b <balancer_ingress+0x2b>
      6b:	11 e5                	adc    %esp,%ebp
      6d:	00 00                	add    %al,(%rax)
      6f:	00 02                	add    %al,(%rdx)
      71:	b8 10 f2 70 73       	mov    $0x7370f210,%eax
      76:	3e 10 63 19          	ds adc %ah,0x19(%rbx)
      7a:	b6 7e                	mov    $0x7e,%dh
      7c:	f5                   	cmc
      7d:	12 c6                	adc    %dh,%al
      7f:	24 6e                	and    $0x6e,%al
      81:	f0 00 00             	lock add %al,(%rax)
  struct vip_definition vip = {};
      84:	00 01                	add    %al,(%rcx)
      86:	bc 5f e5 9e a4       	mov    $0xa49ee55f,%esp
      8b:	ca 18 d4             	lret   $0xd418
      8e:	61                   	(bad)
      8f:	6a 93                	push   $0xffffffffffffff93
      91:	aa                   	stos   %al,%es:(%rdi)
      92:	35 0e 3d 0b 03       	xor    $0x30b3d0e,%eax
      97:	01 00                	add    %eax,(%rax)
      99:	00 01                	add    %al,(%rcx)
      9b:	b5 26                	mov    $0x26,%ch
      9d:	23 e8                	and    %eax,%ebp
      9f:	bc 42 2f 8a 08       	mov    $0x88a2f42,%esp
    if (iph + 1 > data_end) {
      a4:	35 23 90 b1 84       	xor    $0x84b19023,%eax
      a9:	d4                   	(bad)
      aa:	30 13                	xor    %dl,(%rbx)
      ac:	01 00                	add    %eax,(%rax)
      ae:	00 03                	add    %al,(%rbx)
      b0:	c0 ad e1 a1 a3 09 d6 	shrb   $0xd6,0x9a3a1e1(%rbp)
    if (iph->ihl != 5) {
      b7:	89 6c e6 08          	mov    %ebp,0x8(%rsi,%riz,8)
      bb:	0a 51 a2             	or     -0x5e(%rcx),%dl
    pckt->tos = iph->tos;
      be:	d1 05 1b 01 00 00    	roll   0x11b(%rip)        # 1df <balancer_ingress+0x1df>
    *protocol = iph->protocol;
      c4:	04 7d                	add    $0x7d,%al
      c6:	69 ae 28 67 64 8b 88 	imul   $0x60522088,-0x749b98d8(%rsi),%ebp
      cd:	20 52 60 
    if (iph->frag_off & PCKT_FRAGMENTED) {
      d0:	c0 50 92 e1          	rclb   $0xe1,-0x6e(%rax)
      d4:	72 29                	jb     ff <balancer_ingress+0xff>
      d6:	01 00                	add    %eax,(%rax)
      d8:	00 04 1a             	add    %al,(%rdx,%rbx,1)
      db:	44 71 1e             	rex.R jno fc <balancer_ingress+0xfc>
      de:	c9                   	leave
      df:	6a fe                	push   $0xfffffffffffffffe
    if (*protocol == IPPROTO_ICMP) {
      e1:	11 5d c1             	adc    %ebx,-0x3f(%rbp)
      e4:	30 dc                	xor    %bl,%ah
      e6:	e0 25                	loopne 10d <balancer_ingress+0x10d>
      e8:	7a 60                	jp     14a <balancer_ingress+0x14a>
  if (icmp_hdr + 1 > data_end) {
      ea:	2f                   	(bad)
      eb:	01 00                	add    %eax,(%rax)
      ed:	00 03                	add    %al,(%rbx)
      ef:	fc                   	cld
      f0:	de 28                	fisubrs (%rax)
      f2:	42 9f                	rex.X lahf
      f4:	cb                   	lret
      f5:	e6 6e                	out    %al,$0x6e
  if (icmp_hdr->type == ICMP_ECHO) {
      f7:	10 9e 5f e5 b9 9c    	adc    %bl,-0x63461aa1(%rsi)
      fd:	cd 45                	int    $0x45
      ff:	34 01                	xor    $0x1,%al
     101:	00 00                	add    %al,(%rax)
     103:	01 dd                	add    %ebx,%ebp
     105:	5f                   	pop    %rdi
     106:	2d 0c a8 b9 51       	sub    $0x51b9a80c,%eax
     10b:	1e                   	(bad)
     10c:	8f a8 d1 c6          	(bad)
     110:	4e d3 b3 ac 43 01 00 	rex.WRX shlq %cl,0x143ac(%rbx)
  icmp_hdr->type = ICMP_ECHOREPLY;
     117:	00 05 02 65 bf 5d    	add    %al,0x5dbf6502(%rip)        # 5dbf661f <_license+0x5dbf472c>
  icmp_hdr->checksum += 0x0008;
     11d:	da 79 6c             	fidivrl 0x6c(%rcx)
  iph->ttl = DEFAULT_TTL;
     120:	c0 b0 02 70 b2 7d c7 	shlb   $0xc7,0x7db27002(%rax)
  iph->daddr = iph->saddr;
     127:	a1 8e 4b 01 00 00 01 	movabs 0x5c24010000014b8e,%eax
     12e:	24 5c 
  iph->saddr = tmp_addr;
     130:	80 12 ea             	adcb   $0xea,(%rdx)
     133:	92                   	xchg   %eax,%edx
    *csum += *next_iph_u16++;
     134:	00 48 b4             	add    %cl,-0x4c(%rax)
     137:	e4 bf                	in     $0xbf,%al
     139:	3b 10                	cmp    (%rax),%edx
     13b:	c5 7e 15             	(bad)
     13e:	59                   	pop    %rcx
     13f:	01 00                	add    %eax,(%rax)
     141:	00 01                	add    %al,(%rcx)
     143:	f0 b1 d3             	lock mov $0xd3,%cl
     146:	dc 61 ec             	fsubl  -0x14(%rcx)
     149:	02 2c e5 2a 49 e7 c4 	add    -0x3b18b6d6(,%riz,8),%ch
     150:	a9 2a d6 68 01       	test   $0x168d62a,%eax
     155:	00 00                	add    %al,(%rax)
     157:	01 5a 90             	add    %ebx,-0x70(%rdx)
     15a:	58                   	pop    %rax
     15b:	46 07                	rex.RX (bad)
     15d:	61                   	(bad)
     15e:	27                   	(bad)
     15f:	c3                   	ret
     160:	c1 4a e0 0e          	rorl   $0xe,-0x20(%rdx)
     164:	b0 62                	mov    $0x62,%al
     166:	0c ca                	or     $0xca,%al
     168:	75 01                	jne    16b <balancer_ingress+0x16b>
    if (csum >> 16)
     16a:	00 00                	add    %al,(%rax)
     16c:	01 8a eb 55 f9 37    	add    %ecx,0x37f955eb(%rdx)
     172:	57                   	push   %rdi
     173:	66 5e                	pop    %si
     175:	31 61 34             	xor    %esp,0x34(%rcx)
     178:	d7                   	xlat   %ds:(%rbx)
     179:	5b                   	pop    %rbx
     17a:	72 4a                	jb     1c6 <balancer_ingress+0x1c6>
     17c:	48 85 01             	test   %rax,(%rcx)
     17f:	00 00                	add    %al,(%rax)
     181:	03 5c 58 d0          	add    -0x30(%rax,%rbx,2),%ebx
     185:	77 e9                	ja     170 <balancer_ingress+0x170>
  struct packet_description pckt = {};
     187:	10 b6 c2 58 85 5d    	adc    %dh,0x5d8558c2(%rsi)
     18d:	ca 54 d0             	lret   $0xd054
     190:	ec                   	in     (%dx),%al
     191:	22 8a 01 00 00 03    	and    0x3000001(%rdx),%cl
     197:	d2 88 e3 08 e1 42    	rorb   %cl,0x42e108e3(%rax)
     19d:	e5 1c                	in     $0x1c,%eax
     19f:	48 e7 42             	rex.W out %eax,$0x42
     1a2:	2f                   	(bad)
     1a3:	4f bb aa 3f 91 01 00 	rex.WRXB movabs $0xfc03000001913faa,%r11
     1aa:	00 03 fc 
     1ad:	a1 88 9f 02 74 df 06 	movabs 0x496e06df74029f88,%eax
     1b4:	6e 49 
  struct vip_definition vip = {};
     1b6:	cf                   	iret
     1b7:	4d 8d b8 01 1e 52 01 	lea    0x1521e01(%r8),%r15
     1be:	00 00                	add    %al,(%rax)
     1c0:	03 a5 05 63 28 98    	add    -0x67d79cfb(%rbp),%esp
     1c6:	dc e5                	fsub   %st,%st(5)
     1c8:	46 63 8b 33 44 62 7d 	rex.RX movsxd 0x7d624433(%rbx),%r9d
     1cf:	33 4b 97             	xor    -0x69(%rbx),%ecx
     1d2:	01 00                	add    %eax,(%rax)
     1d4:	00 03                	add    %al,(%rbx)
    if (ip6h + 1 > data_end) {
     1d6:	c5 73 77             	(bad)
     1d9:	4d 0b 3c 9a          	or     (%r10,%rbx,4),%r15
     1dd:	61                   	(bad)
     1de:	b5 51                	mov    $0x51,%ch
     1e0:	0b e7                	or     %edi,%esp
     1e2:	5a                   	pop    %rdx
    *protocol = ip6h->nexthdr;
     1e3:	6f                   	outsl  %ds:(%rsi),(%dx)
     1e4:	f3 74 a0             	repz je 187 <balancer_ingress+0x187>
    pckt->flow.proto = *protocol;
     1e7:	01 00                	add    %eax,(%rax)
     1e9:	00 03                	add    %al,(%rbx)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1eb:	5c                   	pop    %rsp
     1ec:	57                   	push   %rdi
     1ed:	70 df                	jo     1ce <balancer_ingress+0x1ce>
     1ef:	b5 68                	mov    $0x68,%ch
     1f1:	97                   	xchg   %eax,%edi
     1f2:	d0 23                	shlb   (%rbx)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1f4:	c1 9c 17 13 f3 42 24 	rcrl   $0xa6,0x2442f313(%rdi,%rdx,1)
     1fb:	a6 
     1fc:	01 00                	add    %eax,(%rax)
     1fe:	00 03                	add    %al,(%rbx)
    if (*protocol == IPPROTO_FRAGMENT) {
     200:	45 bc 38 cb 16 db    	rex.RB mov $0xdb16cb38,%r12d
     206:	bc 75 84 26 5a       	mov    $0x5a268475,%esp
     20b:	fc                   	cld
     20c:	29 89 c9 cc ac 01    	sub    %ecx,0x1acccc9(%rcx)
     212:	00 00                	add    %al,(%rax)
     214:	03 16                	add    (%rsi),%edx
  if (icmp_hdr + 1 > data_end) {
     216:	3f                   	(bad)
     217:	54                   	push   %rsp
     218:	fb                   	sti
     219:	1a f2                	sbb    %dl,%dh
     21b:	e2 1f                	loop   23c <balancer_ingress+0x23c>
     21d:	ea                   	(bad)
     21e:	41 0f 14 eb          	unpcklps %xmm11,%xmm5
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     222:	18 fa                	sbb    %bh,%dl
     224:	76 04                	jbe    22a <balancer_ingress+0x22a>
     226:	00 00                	add    %al,(%rax)
     228:	09 02                	or     %eax,(%rdx)
	...
     232:	03 b0 08 01 05 22    	add    0x22050108(%rax),%esi
     238:	0a 08                	or     (%rax),%cl
     23a:	75 05                	jne    241 <balancer_ingress+0x241>
     23c:	26 3d 05 0c 50 05    	es cmp $0x5500c05,%eax
     242:	15 06 90 05 07       	adc    $0x7059006,%eax
     247:	3c 03                	cmp    $0x3,%al
     249:	c7                   	(bad)
     24a:	77 66                	ja     2b2 <balancer_ingress+0x2b2>
     24c:	05 14 06 03 be       	add    $0xbe030614,%eax
     251:	08 3c 05 07 5a 06 03 	or     %bh,0x3065a07(,%rax,1)
     258:	c0 77 ba 03          	shlb   $0x3,-0x46(%rdi)
     25c:	c0 08 58             	rorb   $0x58,(%rax)
     25f:	05 1d 06 03 ed       	add    $0xed03061d,%eax
     264:	7c 9e                	jl     204 <balancer_ingress+0x204>
     266:	05 19 02 30 13       	add    $0x13300219,%eax
     26b:	04 09                	add    $0x9,%al
     26d:	05 0d 03 bc 7e       	add    $0x7ebc030d,%eax
     272:	08 e4                	or     %ah,%ah
     274:	05 11 06 4a 05       	add    $0x54a0611,%eax
     279:	09 3c 05 0e 06 6a 05 	or     %edi,0x56a060e(,%rax,1)
     280:	12 06                	adc    (%rsi),%al
     282:	4a 05 09 2e 05 16    	rex.WX add $0x16052e09,%rax
     288:	06                   	(bad)
     289:	6b 05 0f 06 4a 05 16 	imul   $0x16,0x54a060f(%rip),%eax        # 54a089f <_license+0x549e9ac>
     290:	06                   	(bad)
     291:	3d 4b 05 0e 40       	cmp    $0x400e054b,%eax
     296:	05 17 06 58 05       	add    $0x5580617,%eax
     29b:	09 58 04             	or     %ebx,0x4(%rax)
     29e:	00 05 00 03 87 7c    	add    %al,0x7c870300(%rip)        # 7c8705a4 <_license+0x7c86e6b1>
     2a4:	66 04 09             	data16 add $0x9,%al
     2a7:	05 13 06 03 fd       	add    $0xfd030613,%eax
     2ac:	03 58 05             	add    0x5(%rax),%ebx
     2af:	09 06                	or     %eax,(%rsi)
     2b1:	3c 04                	cmp    $0x4,%al
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     2b3:	0b 05 10 06 03 9e    	or     -0x61fcf9f0(%rip),%eax        # ffffffff9e0308c9 <server_id_map+0x36fc5d84c8c9>
     2b9:	7e 66                	jle    321 <balancer_ingress+0x321>
     2bb:	05 14 06 4a 05       	add    $0x54a0614,%eax
     2c0:	07                   	(bad)
     2c1:	3c 05                	cmp    $0x5,%al
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2c3:	11 06                	adc    %eax,(%rsi)
     2c5:	69 05 07 06 3c 03 e2 	imul   $0x3907de2,0x33c0607(%rip),%eax        # 33c08d6 <_license+0x33be9e3>
     2cc:	7d 90 03 
     2cf:	9e                   	sahf
     2d0:	02 58 03             	add    0x3(%rax),%bl
  if (protocol == IPPROTO_ICMPV6) {
     2d3:	e2 7d                	loop   352 <balancer_ingress+0x352>
     2d5:	90                   	nop
     2d6:	05 12 06 03 cf       	add    $0xcf030612,%eax
  if (icmp_hdr + 1 > data_end) {
     2db:	00 4a 05             	add    %cl,0x5(%rdx)
     2de:	16                   	(bad)
     2df:	5c                   	pop    %rsp
     2e0:	05 0c 67 05 15       	add    $0x1505670c,%eax
     2e5:	5a                   	pop    %rdx
     2e6:	05 13 49 05 0e       	add    $0xe054913,%eax
  if (icmp_hdr->type == ICMP_ECHO) {
     2eb:	4b                   	rex.WXB
     2ec:	4b 04 0c             	rex.WXB add $0xc,%al
     2ef:	03 61 4a             	add    0x4a(%rcx),%esp
     2f2:	05 0b 06 08 58       	add    $0x5808060b,%eax
     2f7:	05 0e 3c 05 0b       	add    $0xb053c0e,%eax
     2fc:	3c 05                	cmp    $0x5,%al
     2fe:	0e                   	(bad)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2ff:	3c 05                	cmp    $0x5,%al
     301:	0b 4a 05             	or     0x5(%rdx),%ecx
     304:	09 06                	or     %eax,(%rsi)
     306:	03 6a 08             	add    0x8(%rdx),%ebp
       sizeof(struct icmphdr)) > data_end) {
     309:	20 05 0e 06 c8 05    	and    %al,0x5c8060e(%rip)        # 5c8091d <_license+0x5c7ea2a>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     30f:	09 74 03 5e          	or     %esi,0x5e(%rbx,%rax,1)
  icmp_hdr->type = ICMP_ECHOREPLY;
     313:	4a 04 00             	rex.WX add $0x0,%al
  icmp_hdr->checksum += 0x0008;
     316:	05 1d 06 03 ad       	add    $0xad03061d,%eax
     31b:	05 58 05 19 02       	add    $0x2190558,%eax
  iph->ttl = DEFAULT_TTL;
     320:	30 13                	xor    %dl,(%rbx)
  iph->daddr = iph->saddr;
     322:	04 09                	add    $0x9,%al
     324:	05 0e 03 a3 7e       	add    $0x7ea3030e,%eax
     329:	08 e4                	or     %ah,%ah
     32b:	05 12 06 4a 05       	add    $0x54a0612,%eax
  iph->saddr = tmp_addr;
     330:	09 3c 05 17 06 6b 05 	or     %edi,0x56b0617(,%rax,1)
    *csum += *next_iph_u16++;
     337:	16                   	(bad)
     338:	4b 05 18 3f 05 21    	rex.WXB add $0x21053f18,%rax
     33e:	06                   	(bad)
     33f:	4a 05 0f 3c 05 1f    	rex.WX add $0x1f053c0f,%rax
     345:	06                   	(bad)
     346:	3d 05 1b 06 4a       	cmp    $0x4a061b05,%eax
     34b:	05 0f 58 05 09       	add    $0x905580f,%eax
     350:	06                   	(bad)
     351:	40 05 00 06 03 a1    	rex add $0xa1030600,%eax
     357:	7c 82                	jl     2db <balancer_ingress+0x2db>
     359:	05 09 03 df 03       	add    $0x3df0309,%eax
     35e:	58                   	pop    %rax
     35f:	04 0b                	add    $0xb,%al
     361:	05 10 06 03 8d       	add    $0x8d030610,%eax
     366:	7e 82                	jle    2ea <balancer_ingress+0x2ea>
     368:	05 14 06 4a 05       	add    $0x54a0614,%eax
     36d:	07                   	(bad)
     36e:	3c 05                	cmp    $0x5,%al
    if (csum >> 16)
     370:	11 06                	adc    %eax,(%rsi)
     372:	69 05 07 06 3c 03 91 	imul   $0x3f27e91,0x33c0607(%rip),%eax        # 33c0983 <_license+0x33bea90>
     379:	7e f2 03 
     37c:	ef                   	out    %eax,(%dx)
     37d:	01 58 04             	add    %ebx,0x4(%rax)
     380:	00 05 00 03 91 7e    	add    %al,0x7e910300(%rip)        # 7e910686 <_license+0x7e90e793>
     386:	82                   	(bad)
     387:	04 09                	add    $0x9,%al
     389:	05 07 06 03 e5       	add    $0xe5030607,%eax
     38e:	03 02                	add    (%rdx),%eax
     390:	70 01                	jo     393 <balancer_ingress+0x393>
     392:	f3 04 0b             	repz add $0xb,%al
     395:	03 f3                	add    %ebx,%esi
     397:	7e f2                	jle    38b <balancer_ingress+0x38b>
     399:	05 10 03 42 82       	add    $0x82420310,%eax
     39e:	05 14 06 4a 05       	add    $0x54a0614,%eax
     3a3:	07                   	(bad)
     3a4:	3c 05                	cmp    $0x5,%al
     3a6:	11 06                	adc    %eax,(%rsi)
     3a8:	69 05 07 06 3c 03 e2 	imul   $0x3827de2,0x33c0607(%rip),%eax        # 33c09b9 <_license+0x33beac6>
     3af:	7d 82 03 
     3b2:	9e                   	sahf
     3b3:	02 58 05             	add    0x5(%rax),%bl
     3b6:	3c 06                	cmp    $0x6,%al
     3b8:	03 a9 7e 82 05 20    	add    0x2005827e(%rcx),%ebp
     3be:	91                   	xchg   %eax,%ecx
     3bf:	05 07 3b 05 12       	add    $0x12053b07,%eax
     3c4:	6e                   	outsb  %ds:(%rsi),(%dx)
     3c5:	05 16 5c 05 0c       	add    $0xc055c16,%eax
     3ca:	67 05 15 5a 05 13    	addr32 add $0x13055a15,%eax
     3d0:	49 05 0e 4b 4b 04    	rex.WB add $0x44b4b0e,%rax
     3d6:	0c 03                	or     $0x3,%al
     3d8:	61                   	(bad)
     3d9:	4a 05 0b 06 08 e4    	rex.WX add $0xffffffffe408060b,%rax
     3df:	05 0e 3c 05 0b       	add    $0xb053c0e,%eax
     3e4:	3c 05                	cmp    $0x5,%al
     3e6:	0e                   	(bad)
     3e7:	3c 05                	cmp    $0x5,%al
     3e9:	0b 4a 05             	or     0x5(%rdx),%ecx
     3ec:	09 06                	or     %eax,(%rsi)
     3ee:	03 6a 08             	add    0x8(%rdx),%ebp
     3f1:	20 05 0e 06 c8 05    	and    %al,0x5c8060e(%rip)        # 5c80a05 <_license+0x5c7eb12>
     3f7:	09 66 04             	or     %esp,0x4(%rsi)
     3fa:	00 05 00 03 5e 4a    	add    %al,0x4a5e0300(%rip)        # 4a5e0700 <_license+0x4a5de80d>
     400:	05 07 06 03 f2       	add    $0xf2030607,%eax
     405:	05 02 8e 01 01       	add    $0x1018e02,%eax
     40a:	04 09                	add    $0x9,%al
     40c:	05 0e 03 8b 7b       	add    $0x7b8b030e,%eax
     411:	f2 05 2b 47 05 0e    	repnz add $0xe05472b,%eax
  if (protocol == IPPROTO_TCP) {
     417:	3f                   	(bad)
     418:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
     41d:	06                   	(bad)
     41e:	4a 05 07 3c 06 6a    	rex.WX add $0x6a063c07,%rax
     424:	06                   	(bad)
  tcp = data + off;
     425:	4a 05 11 06 2f 05    	rex.WX add $0x52f0611,%rax
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     42b:	1d 03 fc 02 9e       	sbb    $0x9e02fc03,%eax
  if (tcp + 1 > data_end) {
     430:	05 16 06 4a 05       	add    $0x54a0616,%eax
     435:	1d 06 3d 05 16       	sbb    $0x16053d06,%eax
     43a:	06                   	(bad)
     43b:	4a 04 0b             	rex.WX add $0xb,%al
  if (tcp->syn) {
     43e:	05 07 06 03 d8       	add    $0xd8030607,%eax
    pckt->flags |= F_SYN_SET;
     443:	7e 3c                	jle    481 <balancer_ingress+0x481>
     445:	05 10 03 93 7f       	add    $0x7f930310,%eax
     44a:	58                   	pop    %rax
     44b:	05 14 06 4a 05       	add    $0x54a0614,%eax
      pckt->flow.src = iph->saddr;
     450:	07                   	(bad)
     451:	3c 05                	cmp    $0x5,%al
     453:	11 06                	adc    %eax,(%rsi)
      pckt->flow.dst = iph->daddr;
     455:	69 05 07 06 3c 03 91 	imul   $0x3f27e91,0x33c0607(%rip),%eax        # 33c0a66 <_license+0x33beb73>
     45c:	7e f2 03 
  if (protocol == IPPROTO_ICMPV6) {
     45f:	ef                   	out    %eax,(%dx)
  if (icmp_hdr + 1 > data_end) {
     460:	01 58 05             	add    %ebx,0x5(%rax)
     463:	3e 06                	ds (bad)
     465:	03 f6                	add    %esi,%esi
     467:	7e 82                	jle    3eb <balancer_ingress+0x3eb>
     469:	05 21 91 05 07       	add    $0x7059121,%eax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     46e:	3b 04 09             	cmp    (%rcx,%rcx,1),%eax
     471:	05 0e aa 05 2b       	add    $0x2b05aa0e,%eax
     476:	47 05 0e 3f 05 0b    	rex.RXB add $0xb053f0e,%eax
     47c:	4c 05 0f 06 4a 05    	rex.WR add $0x54a060f,%rax
     482:	07                   	(bad)
     483:	3c 04                	cmp    $0x4,%al
     485:	00 05 00 03 9b 7f    	add    %al,0x7f9b0300(%rip)        # 7f9b078b <_license+0x7f9ae898>
     48b:	66 05 07 06          	add    $0x607,%ax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     48f:	03 f2                	add    %edx,%esi
     491:	05 02 27 01 04       	add    $0x4012702,%eax
       sizeof(struct icmp6hdr)) > data_end) {
     496:	09 05 0e 03 8b 7b    	or     %eax,0x7b8b030e(%rip)        # 7b8b07aa <_license+0x7b8ae8b7>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     49c:	08 20                	or     %ah,(%rax)
     49e:	05 2b 47 05 0e       	add    $0xe05472b,%eax
     4a3:	31 05 0b 4c 05 0f    	xor    %eax,0xf054c0b(%rip)        # f0550b4 <_license+0xf0531c1>
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     4a9:	06                   	(bad)
     4aa:	4a 05 07 3c 06 6a    	rex.WX add $0x6a063c07,%rax
  if (udp + 1 > data_end) {
     4b0:	06                   	(bad)
     4b1:	4a 05 11 06 67 06    	rex.WX add $0x6670611,%rax
     4b7:	03 fc                	add    %esp,%edi
     4b9:	7e c8                	jle    483 <balancer_ingress+0x483>
     4bb:	04 0b                	add    $0xb,%al
     4bd:	05 0b 06 03 f8       	add    $0xf803060b,%eax
     4c2:	01 2e                	add    %ebp,(%rsi)
     4c4:	05 09 76 05 0a       	add    $0xa057609,%eax
     4c9:	08 67 05             	or     %ah,0x5(%rdi)
     4cc:	09 06                	or     %eax,(%rsi)
     4ce:	3c 05                	cmp    $0x5,%al
     4d0:	1b 06                	sbb    (%rsi),%eax
     4d2:	69 05 11 4b 05 0d 67 	imul   $0x6090567,0xd054b11(%rip),%eax        # d054fed <_license+0xd0530fa>
     4d9:	05 09 06 
     4dc:	66 05 1d 06          	add    $0x61d,%ax
     4e0:	2f                   	(bad)
     4e1:	06                   	(bad)
     4e2:	03 ff                	add    %edi,%edi
     4e4:	7d 58                	jge    53e <balancer_ingress+0x53e>
     4e6:	05 0c 06 03 89       	add    $0x8903060c,%eax
     4eb:	02 2e                	add    (%rsi),%ch
     4ed:	05 10 06 4a 05       	add    $0x54a0610,%eax
     4f2:	07                   	(bad)
     4f3:	3c 05                	cmp    $0x5,%al
  tcp = data + off;
     4f5:	1c 06                	sbb    $0x6,%al
     4f7:	69 05 14 06 4a 05 0f 	imul   $0x53d060f,0x54a0614(%rip),%eax        # 54a0b15 <_license+0x549ec22>
     4fe:	06 3d 05 
  if (tcp + 1 > data_end) {
     501:	03 91 f3 04 00 05    	add    0x50004f3(%rcx),%edx
     507:	00 06                	add    %al,(%rsi)
     509:	03 f1                	add    %ecx,%esi
     50b:	7d 08                	jge    515 <balancer_ingress+0x515>
  if (tcp->syn) {
     50d:	4a 05 05 06 03 8b    	rex.WX add $0xffffffff8b030605,%rax
     513:	06                   	(bad)
     514:	08 2e                	or     %ch,(%rsi)
    pckt->flags |= F_SYN_SET;
     516:	05 0e 08 5d 05       	add    $0x55d080e,%eax
     51b:	0c 06                	or     $0x6,%al
     51d:	4a 05 19 06 75 05    	rex.WX add $0x5750619,%rax
     523:	0d 06 3c 05 0e       	or     $0xe053c06,%eax
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     528:	06                   	(bad)
     529:	67 05 08 08 91 05    	addr32 add $0x5910808,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     52f:	07                   	(bad)
     530:	06                   	(bad)
     531:	3c 05                	cmp    $0x5,%al
     533:	10 06                	adc    %al,(%rsi)
     535:	03 0f                	add    (%rdi),%ecx
     537:	66 05 17 06          	add    $0x617,%ax
     53b:	ac                   	lods   %ds:(%rsi),%al
     53c:	05 07 74 03 de       	add    $0xde037407,%eax
     541:	79 66                	jns    5a9 <balancer_ingress+0x5a9>
    if (!icmp_ptb_v6_stats) {
     543:	05 09 06 03 b5       	add    $0xb5030609,%eax
     548:	06                   	(bad)
     549:	4a 05 10 9f 05 08    	rex.WX add $0x8059f10,%rax
    icmp_ptb_v6_stats->v1 += 1;
     54f:	08 91 05 07 06 3c    	or     %dl,0x3c060705(%rcx)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     555:	03 c9                	add    %ecx,%ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     557:	79 66                	jns    5bf <balancer_ingress+0x5bf>
     559:	05 12 06 03 bc       	add    $0xbc030612,%eax
      icmp_ptb_v6_stats->v2 += 1;
     55e:	06                   	(bad)
     55f:	74 05                	je     566 <balancer_ingress+0x566>
     561:	18 84 05 07 06 3c 05 	sbb    %al,0x53c0607(%rbp,%rax,1)
  if (ip6h + 1 > data_end) {
     568:	19 06                	sbb    %eax,(%rsi)
     56a:	31 05 17 69 06 03    	xor    %eax,0x3066917(%rip)        # 3066e87 <_license+0x3064f94>
     570:	bc 79 3c 05 0b       	mov    $0xb053c79,%esp
  pckt->flow.proto = ip6h->nexthdr;
     575:	03 c4                	add    %esp,%eax
     577:	06                   	(bad)
     578:	66 05 13 06          	add    $0x613,%ax
  pckt->flags |= F_ICMP;
     57c:	c9                   	leave
     57d:	05 09 06 2e 05       	add    $0x52e0609,%eax
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     582:	13 06                	adc    (%rsi),%eax
     584:	67 06                	addr32 (bad)
     586:	03 ba 79 08 90 05    	add    0x5900879(%rdx),%edi
     58c:	08 06                	or     %al,(%rsi)
     58e:	03 c7                	add    %edi,%eax
     590:	06                   	(bad)
     591:	74 05                	je     598 <balancer_ingress+0x598>
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     593:	07                   	(bad)
     594:	06                   	(bad)
     595:	3c 05                	cmp    $0x5,%al
     597:	0b 06                	or     (%rsi),%eax
     599:	30 05 22 75 05 0a    	xor    %al,0xa057522(%rip)        # a057ac1 <_license+0xa055bce>
     59f:	08 67 05             	or     %ah,0x5(%rdi)
     5a2:	09 06                	or     %eax,(%rsi)
     5a4:	3c 05                	cmp    $0x5,%al
     5a6:	13 06                	adc    (%rsi),%eax
     5a8:	6c                   	insb   (%dx),%es:(%rdi)
     5a9:	06                   	(bad)
     5aa:	03 af 79 d6 05 18    	add    0x1805d679(%rdi),%ebp
     5b0:	06                   	(bad)
     5b1:	03 d5                	add    %ebp,%edx
     5b3:	06                   	(bad)
     5b4:	ac                   	lods   %ds:(%rsi),%al
     5b5:	05 07 06 66 05       	add    $0x5660607,%eax
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     5ba:	14 06                	adc    $0x6,%al
     5bc:	67 05 09 4b 05 0d    	addr32 add $0xd054b09,%eax
     5c2:	03 12                	add    (%rdx),%edx
     5c4:	66 05 0b 76          	add    $0x760b,%ax
     5c8:	05 0c 08 67 05       	add    $0x567080c,%eax
     5cd:	0b 06                	or     (%rsi),%eax
     5cf:	3c 04                	cmp    $0x4,%al
  vip.port = pckt.flow.port16[1];
     5d1:	09 05 0d 06 03 f7    	or     %eax,-0x8fcf9f3(%rip)        # fffffffff7030be4 <server_id_map+0x36fcb684cbe4>
     5d7:	7b 66                	jnp    63f <balancer_ingress+0x63f>
     5d9:	05 12 46 05 0d       	add    $0xd054612,%eax
  vip.proto = pckt.flow.proto;
     5de:	4e 05 2b 06 4a 05    	rex.WRX add $0x54a062b,%rax
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     5e4:	3b 4a 05             	cmp    0x5(%rdx),%ecx
     5e7:	07                   	(bad)
     5e8:	74 04                	je     5ee <balancer_ingress+0x5ee>
     5ea:	00 05 27 06 03 bb    	add    %al,-0x44fcf9d9(%rip)        # ffffffffbb030c17 <server_id_map+0x36fc7a84cc17>
     5f0:	04 66                	add    $0x66,%al
     5f2:	04 0b                	add    $0xb,%al
     5f4:	05 16 03 87 7b       	add    $0x7b870316,%eax
     5f9:	90                   	nop
     5fa:	05 07 06 58 03       	add    $0x3580607,%eax
  if (!vip_info) {
     5ff:	db 7d 2e             	fstpt  0x2e(%rbp)
     602:	05 0b 06 03 a6       	add    $0xa603060b,%eax
  if (data_end - data > MAX_PCKT_SIZE) {
     607:	02 3c 05 09 76 05 0a 	add    0xa057609(,%rax,1),%bh
     60e:	08 67 05             	or     %ah,0x5(%rdi)
     611:	09 06                	or     %eax,(%rsi)
     613:	3c 05                	cmp    $0x5,%al
     615:	1b 06                	sbb    (%rsi),%eax
     617:	69 05 0d 4c 05 09 06 	imul   $0x1d055806,0x9054c0d(%rip),%eax        # 905522e <_license+0x905333b>
     61e:	58 05 1d 
     621:	06                   	(bad)
     622:	2f                   	(bad)
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
     623:	06                   	(bad)
     624:	03 d1                	add    %ecx,%edx
     626:	7d 58                	jge    680 <balancer_ingress+0x680>
     628:	05 0b 06 03 b5       	add    $0xb503060b,%eax
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     62d:	02 3c 05 0f 06 4a 05 	add    0x54a060f(,%rax,1),%bh
     634:	07                   	(bad)
     635:	3c 05                	cmp    $0x5,%al
     637:	0c 06                	or     $0x6,%al
     639:	69 05 10 06 4a 05 07 	imul   $0x1b052e07,0x54a0610(%rip),%eax        # 54a0c53 <_license+0x549ed60>
     640:	2e 05 1b 
     643:	06                   	(bad)
     644:	69 05 14 06 4a 05 0f 	imul   $0x53d060f,0x54a0614(%rip),%eax        # 54a0c62 <_license+0x549ed6f>
     64b:	06 3d 05 
  if (!data_stats) {
     64e:	19 91 05 12 06 4a    	sbb    %edx,0x4a061205(%rcx)
     654:	05 19 06 3d 05       	add    $0x53d0619,%eax
  data_stats->v1 += 1;
     659:	12 06                	adc    (%rsi),%al
     65b:	4a 04 00             	rex.WX add $0x0,%al
     65e:	05 0e 06 03 d6       	add    $0xd603060e,%eax
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     663:	03 82 05 10 91 05    	add    0x5911005(%rdx),%eax
    pckt.flow.port16[0] = 0;
     669:	0a 08                	or     (%rax),%cl
  vip_num = vip_info->vip_num;
     66b:	91                   	xchg   %eax,%ecx
     66c:	05 09 06 3c 05       	add    $0x53c0609,%eax
     671:	30 06                	xor    %al,(%rsi)
     673:	6a 05                	push   $0x5
     675:	1b 94 04 09 05 0e 03 	sbb    0x30e0509(%rsp,%rax,1),%edx
     67c:	c5 7a ac             	(bad)
     67f:	05 2b 47 05 0e       	add    $0xe05472b,%eax
  __u32 cpu_num = bpf_get_smp_processor_id();
     684:	31 05 0b 4c 05 0f    	xor    %eax,0xf054c0b(%rip)        # f055295 <_license+0xf0533a2>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     68a:	06                   	(bad)
     68b:	4a 05 07 3c 03 9b    	rex.WX add $0xffffffff9b033c07,%rax
     691:	7f 66                	jg     6f9 <balancer_ingress+0x6f9>
     693:	04 0b                	add    $0xb,%al
     695:	05 16 06 03 a5       	add    $0xa5030616,%eax
     69a:	02 08                	add    (%rax),%cl
     69c:	e4 05                	in     $0x5,%al
     69e:	07                   	(bad)
     69f:	06                   	(bad)
     6a0:	58                   	pop    %rax
     6a1:	03 db                	add    %ebx,%ebx
     6a3:	7d 2e                	jge    6d3 <balancer_ingress+0x6d3>
     6a5:	05 0b 06 03 a6       	add    $0xa603060b,%eax
  if (!lru_map) {
     6aa:	02 4a 05             	add    0x5(%rdx),%cl
     6ad:	09 76 05             	or     %esi,0x5(%rsi)
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
     6b0:	0a 08                	or     (%rax),%cl
     6b2:	67 05 09 06 3c 05    	addr32 add $0x53c0609,%eax
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     6b8:	1b 06                	sbb    (%rsi),%eax
     6ba:	69 05 0d 4c 05 09 06 	imul   $0x1d055806,0x9054c0d(%rip),%eax        # 90552d1 <_license+0x90533de>
     6c1:	58 05 1d 
     6c4:	06                   	(bad)
     6c5:	2f                   	(bad)
     6c6:	06                   	(bad)
     6c7:	03 d1                	add    %ecx,%edx
     6c9:	7d 58                	jge    723 <balancer_ingress+0x723>
     6cb:	05 0b 06 03 b5       	add    $0xb503060b,%eax
    if (!lru_stats) {
     6d0:	02 4a 05             	add    0x5(%rdx),%cl
     6d3:	0f 06                	clts
    lru_stats->v1 += 1;
     6d5:	4a 05 07 3c 05 0c    	rex.WX add $0xc053c07,%rax
     6db:	06                   	(bad)
     6dc:	69 05 10 06 4a 05 07 	imul   $0x1b052e07,0x54a0610(%rip),%eax        # 54a0cf6 <_license+0x549ee03>
     6e3:	2e 05 1b 
     6e6:	06                   	(bad)
     6e7:	69 05 14 06 4a 05 0f 	imul   $0x53d060f,0x54a0614(%rip),%eax        # 54a0d05 <_license+0x549ee12>
     6ee:	06 3d 05 
  if ((vip_info->flags & F_QUIC_VIP)) {
     6f1:	19 83 05 12 06 4a    	sbb    %eax,0x4a061205(%rbx)
     6f7:	05 19 06 3d 05       	add    $0x53d0619,%eax
    bool is_icmp = (pckt.flags & F_ICMP);
     6fc:	12 06                	adc    (%rsi),%al
    if (is_icmp) {
     6fe:	4a 04 00             	rex.WX add $0x0,%al
     701:	05 00 03 c2 7d       	add    $0x7dc20300,%eax
      __u32 quic_packets_stats_key = 0;
     706:	82                   	(bad)
     707:	05 19 06 03 8d       	add    $0x8d030619,%eax
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     70c:	06                   	(bad)
     70d:	08 2e                	or     %ch,(%rsi)
     70f:	05 0d 06 3c 05       	add    $0x53c060d,%eax
     714:	0e                   	(bad)
     715:	06                   	(bad)
     716:	69 05 0c 06 4a 05 19 	imul   $0x5750619,0x54a060c(%rip),%eax        # 54a0d2c <_license+0x549ee39>
     71d:	06 75 05 
     720:	0d 06 3c 05 0e       	or     $0xe053c06,%eax
      if (!quic_packets_stats) {
     725:	06                   	(bad)
     726:	67 05 08 08 91 05    	addr32 add $0x5910808,%eax
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     72c:	07                   	(bad)
     72d:	06                   	(bad)
     72e:	3c 05                	cmp    $0x5,%al
  bool is_icmp = (pckt->flags & F_ICMP);
     730:	10 06                	adc    %al,(%rsi)
     732:	03 0f                	add    (%rdi),%ecx
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     734:	66 05 17 06          	add    $0x617,%ax
     738:	ac                   	lods   %ds:(%rsi),%al
     739:	05 07 74 03 de       	add    $0xde037407,%eax
     73e:	79 66                	jns    7a6 <balancer_ingress+0x7a6>
     740:	05 09 06 03 b5       	add    $0xb5030609,%eax
     745:	06                   	(bad)
     746:	4a 05 10 9f 05 08    	rex.WX add $0x8059f10,%rax
        quic_packets_stats->ch_routed += 1;
     74c:	08 91 05 07 06 3c    	or     %dl,0x3c060705(%rcx)
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     752:	03 c9                	add    %ecx,%ecx
     754:	79 66                	jns    7bc <balancer_ingress+0x7bc>
     756:	05 12 06 03 bc       	add    $0xbc030612,%eax
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     75b:	06                   	(bad)
     75c:	74 05                	je     763 <balancer_ingress+0x763>
     75e:	18 84 05 07 06 3c 05 	sbb    %al,0x53c0607(%rbp,%rax,1)
        bpf_map_lookup_elem(&stats, &stats_key);
     765:	19 06                	sbb    %eax,(%rsi)
     767:	31 05 17 69 06 03    	xor    %eax,0x3066917(%rip)        # 3067084 <_license+0x3065191>
     76d:	bc 79 3c 05 0b       	mov    $0xb053c79,%esp
     772:	03 c4                	add    %esp,%eax
     774:	06                   	(bad)
     775:	66 05 13 06          	add    $0x613,%ax
    if (!icmp_ptb_v4_stats) {
     779:	c9                   	leave
     77a:	05 09 06 2e 05       	add    $0x52e0609,%eax
     77f:	13 06                	adc    (%rsi),%eax
     781:	67 06                	addr32 (bad)
    icmp_ptb_v4_stats->v1 += 1;
     783:	03 ba 79 08 90 05    	add    0x5900879(%rdx),%edi
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     789:	08 06                	or     %al,(%rsi)
     78b:	03 c7                	add    %edi,%eax
      icmp_ptb_v4_stats->v2 += 1;
     78d:	06                   	(bad)
     78e:	74 05                	je     795 <balancer_ingress+0x795>
     790:	07                   	(bad)
     791:	06                   	(bad)
     792:	3c 05                	cmp    $0x5,%al
     794:	0b 06                	or     (%rsi),%eax
  if (iph + 1 > data_end) {
     796:	30 05 22 75 05 0a    	xor    %al,0xa057522(%rip)        # a057cbe <_license+0xa055dcb>
     79c:	08 67 05             	or     %ah,0x5(%rdi)
     79f:	09 06                	or     %eax,(%rsi)
     7a1:	3c 05                	cmp    $0x5,%al
  if (iph->ihl != 5) {
     7a3:	13 06                	adc    (%rsi),%eax
     7a5:	6c                   	insb   (%dx),%es:(%rdi)
     7a6:	06                   	(bad)
     7a7:	03 af 79 d6 05 18    	add    0x1805d679(%rdi),%ebp
     7ad:	06                   	(bad)
  pckt->flow.proto = iph->protocol;
     7ae:	03 d5                	add    %ebp,%edx
     7b0:	06                   	(bad)
     7b1:	ac                   	lods   %ds:(%rsi),%al
     7b2:	05 07 06 66 05       	add    $0x5660607,%eax
  pckt->flags |= F_ICMP;
     7b7:	14 06                	adc    $0x6,%al
     7b9:	67 05 09 4b 05 0d    	addr32 add $0xd054b09,%eax
  pckt->flow.src = iph->daddr;
     7bf:	03 12                	add    (%rdx),%edx
     7c1:	66 05 0b 76          	add    $0x760b,%ax
  pckt->flow.dst = iph->saddr;
     7c5:	05 0c 08 67 05       	add    $0x567080c,%eax
     7ca:	0b 06                	or     (%rsi),%eax
     7cc:	3c 03                	cmp    $0x3,%al
     7ce:	94                   	xchg   %eax,%esp
     7cf:	79 66                	jns    837 <balancer_ingress+0x837>
    vip.port = 0;
     7d1:	04 09                	add    $0x9,%al
     7d3:	05 0d 06 03 e3       	add    $0xe303060d,%eax
     7d8:	02 3c 05 12 46 05 0d 	add    0xd054612(,%rax,1),%bh
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     7df:	4e 05 2b 06 4a 05    	rex.WRX add $0x54a062b,%rax
     7e5:	3b 4a 05             	cmp    0x5(%rdx),%ecx
     7e8:	07                   	(bad)
     7e9:	3c 05                	cmp    $0x5,%al
     7eb:	00 03                	add    %al,(%rbx)
     7ed:	9d                   	popf
     7ee:	7d 66                	jge    856 <balancer_ingress+0x856>
     7f0:	05 08 06 03 ef       	add    $0xef030608,%eax
    if (!vip_info) {
     7f5:	02 4a 05             	add    0x5(%rdx),%cl
     7f8:	26 06                	es (bad)
     7fa:	4a 05 07 3c 05 13    	rex.WX add $0x13053c07,%rax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     800:	06                   	(bad)
     801:	03 14 66             	add    (%rsi,%riz,2),%edx
     804:	05 36 06 4a 05       	add    $0x54a0636,%eax
      pckt.flow.port16[1] = 0;
     809:	09 3c 04             	or     %edi,(%rsp,%rax,1)
     80c:	00 05 0e 06 03 91    	add    %al,-0x6efcf9f2(%rip)        # ffffffff91030e20 <server_id_map+0x36fc5084ce20>
  udp = data + off;
     812:	03 ac 05 10 91 05 0a 	add    0xa059110(%rbp,%rax,1),%ebp
     819:	08 91 05 09 06 3c    	or     %dl,0x3c060905(%rcx)
  if (udp + 1 > data_end) {
     81f:	05 30 06 6a 05       	add    $0x56a0630,%eax
     824:	1b 94 06 03 e2 79 ac 	sbb    -0x53861dfd(%rsi,%rax,1),%edx
     82b:	04 0b                	add    $0xb,%al
     82d:	05 0b 06 03 f8       	add    $0xf803060b,%eax
     832:	01 2e                	add    %ebp,(%rsi)
     834:	05 09 76 05 0a       	add    $0xa057609,%eax
     839:	08 67 05             	or     %ah,0x5(%rdi)
     83c:	09 06                	or     %eax,(%rsi)
     83e:	3c 05                	cmp    $0x5,%al
     840:	1b 06                	sbb    (%rsi),%eax
     842:	69 05 11 4b 05 0d 67 	imul   $0x6090567,0xd054b11(%rip),%eax        # d05535d <_license+0xd05346a>
     849:	05 09 06 
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     84c:	66 05 1d 06          	add    $0x61d,%ax
     850:	2f                   	(bad)
     851:	06                   	(bad)
     852:	03 ff                	add    %edi,%edi
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     854:	7d 58                	jge    8ae <balancer_ingress+0x8ae>
     856:	05 0c 06 03 89       	add    $0x8903060c,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     85b:	02 2e                	add    (%rsi),%ch
     85d:	05 10 06 4a 05       	add    $0x54a0610,%eax
     862:	07                   	(bad)
     863:	3c 04                	cmp    $0x4,%al
     865:	00 05 00 03 f7 7d    	add    %al,0x7df70300(%rip)        # 7df70b6b <_license+0x7df6ec78>
     86b:	66 04 0b             	data16 add $0xb,%al
     86e:	05 1c 06 03 8c       	add    $0x8c03061c,%eax
    if (!icmp_ptb_v4_stats) {
     873:	02 4a 05             	add    0x5(%rdx),%cl
     876:	14 06                	adc    $0x6,%al
     878:	4a 05 0f 06 3d 05    	rex.WX add $0x53d060f,%rax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     87e:	03 83 f3 04 00 05    	add    0x50004f3(%rbx),%eax
     884:	0d 03 cf 04 08       	or     $0x804cf03,%eax
      icmp_ptb_v4_stats->v2 += 1;
     889:	3c 05                	cmp    $0x5,%al
     88b:	25 75 05 0c 08       	and    $0x80c0575,%eax
  if (iph + 1 > data_end) {
     890:	67 05 0b 06 3c 05    	addr32 add $0x53c060b,%eax
     896:	16                   	(bad)
     897:	06                   	(bad)
     898:	69 04 0b 05 14 03 e6 	imul   $0xe6031405,(%rbx,%rcx,1),%eax
  if (iph->ihl != 5) {
     89f:	7b 4a                	jnp    8eb <balancer_ingress+0x8eb>
     8a1:	05 37 06 4a 04       	add    $0x44a0637,%eax
     8a6:	00 05 0b 06 03 9c    	add    %al,-0x63fcf9f5(%rip)        # ffffffff9c030eb7 <server_id_map+0x36fc5b84ceb7>
  pckt->flow.proto = iph->protocol;
     8ac:	04 9e                	add    $0x9e,%al
  pckt->flags |= F_ICMP;
     8ae:	05 18 2f 05 14       	add    $0x14052f18,%eax
     8b3:	03 c9                	add    %ecx,%ecx
     8b5:	00 58 05             	add    %bl,0x5(%rax)
  pckt->flow.src = iph->daddr;
     8b8:	1e                   	(bad)
     8b9:	03 26                	add    (%rsi),%esp
     8bb:	58                   	pop    %rax
     8bc:	05 2b 06 4a 05       	add    $0x54a062b,%eax
  pckt->flow.dst = iph->saddr;
     8c1:	1b 06                	sbb    (%rsi),%eax
     8c3:	2f                   	(bad)
     8c4:	05 09 3b 06 03       	add    $0x3063b09,%eax
     8c9:	ab                   	stos   %eax,%es:(%rdi)
     8ca:	78 2e                	js     8fa <balancer_ingress+0x8fa>
     8cc:	05 0d 06 03 b8       	add    $0xb803060d,%eax
     8d1:	01 08                	add    %ecx,(%rax)
     8d3:	20 05 08 2f 05 07    	and    %al,0x7052f08(%rip)        # 70537e1 <_license+0x70518ee>
     8d9:	06                   	(bad)
     8da:	3c 05                	cmp    $0x5,%al
    vip.vip = pckt.flow.dst;
     8dc:	00 03                	add    %al,(%rbx)
     8de:	c7                   	(bad)
     8df:	7e 2e                	jle    90f <balancer_ingress+0x90f>
     8e1:	05 28 06 03 bc       	add    $0xbc030628,%eax
  vip.port = pckt.flow.port16[1];
     8e6:	01 3c 05 07 06 4a 03 	add    %edi,0x34a0607(,%rax,1)
     8ed:	c4                   	(bad)
     8ee:	7e 66                	jle    956 <balancer_ingress+0x956>
  vip.proto = pckt.flow.proto;
     8f0:	05 10 06 03 bd       	add    $0xbd030610,%eax
     8f5:	01 74 05 12          	add    %esi,0x12(%rbp,%rax,1)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     8f9:	2f                   	(bad)
     8fa:	05 23 06 08 12       	add    $0x12080623,%eax
     8ff:	05 09 3c 03 c2       	add    $0xc2033c09,%eax
     904:	7e 66                	jle    96c <balancer_ingress+0x96c>
     906:	04 09                	add    $0x9,%al
     908:	05 08 06 03 ef       	add    $0xef030608,%eax
     90d:	02 08                	add    (%rax),%cl
     90f:	3c 05                	cmp    $0x5,%al
     911:	26 06                	es (bad)
  if (!vip_info) {
     913:	4a 05 07 3c 05 13    	rex.WX add $0x13053c07,%rax
     919:	06                   	(bad)
     91a:	03 14 66             	add    (%rsi,%riz,2),%edx
  if (data_end - data > MAX_PCKT_SIZE) {
     91d:	05 36 06 4a 05       	add    $0x54a0636,%eax
     922:	09 3c 05 08 06 6b 05 	or     %edi,0x56b0608(,%rax,1)
     929:	07                   	(bad)
     92a:	06                   	(bad)
     92b:	3c 03                	cmp    $0x3,%al
     92d:	f8                   	clc
     92e:	7c 66                	jl     996 <balancer_ingress+0x996>
     930:	05 19 06 03 8c       	add    $0x8c030619,%eax
     935:	03 3c 05 23 06 3c 05 	add    0x53c0623(,%rax,1),%edi
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
     93c:	07                   	(bad)
     93d:	06                   	(bad)
     93e:	5a                   	pop    %rdx
     93f:	06                   	(bad)
     940:	03 f2                	add    %edx,%esi
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     942:	7c 08                	jl     94c <balancer_ingress+0x94c>
     944:	82                   	(bad)
     945:	03 8e 03 3c 05 15    	add    0x15053c03(%rsi),%ecx
     94b:	06                   	(bad)
     94c:	6a 05                	push   $0x5
     94e:	1d 06 3c 05 27       	sbb    $0x27053c06,%eax
     953:	4a 05 24 4a 05 3a    	rex.WX add $0x3a054a24,%rax
     959:	4a 05 44 3c 04 00    	rex.WX add $0x43c44,%rax
  if (!data_stats) {
     95f:	05 0d 06 03 cc       	add    $0xcc03060d,%eax
     964:	03 9e 05 25 75 05    	add    0x5752505(%rsi),%ebx
     96a:	0c 08                	or     $0x8,%al
  data_stats->v1 += 1;
     96c:	67 05 0b 06 3c 05    	addr32 add $0x53c060b,%eax
     972:	16                   	(bad)
     973:	06                   	(bad)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     974:	69 04 0b 05 14 03 eb 	imul   $0xeb031405,(%rbx,%rcx,1),%eax
    pckt.flow.port16[0] = 0;
     97b:	7b 4a                	jnp    9c7 <balancer_ingress+0x9c7>
     97d:	05 2f 06 4a 04       	add    $0x44a062f,%eax
     982:	00 05 0b 06 03 97    	add    %al,-0x68fcf9f5(%rip)        # ffffffff97030f93 <server_id_map+0x36fc5684cf93>
  vip_num = vip_info->vip_num;
     988:	04 66                	add    $0x66,%al
     98a:	05 18 67 04 09       	add    $0x9046718,%eax
     98f:	05 13 03 8b 7c       	add    $0x7c8b0313,%eax
     994:	9e                   	sahf
  __u32 cpu_num = bpf_get_smp_processor_id();
     995:	05 35 06 4a 05       	add    $0x54a0635,%eax
     99a:	09 3c 05 2d 06 69 05 	or     %edi,0x569062d(,%rax,1)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     9a1:	09 06                	or     %eax,(%rsi)
     9a3:	3c 04                	cmp    $0x4,%al
     9a5:	00 05 29 06 03 ac    	add    %al,-0x53fcf9d7(%rip)        # ffffffffac030fd4 <server_id_map+0x36fc6b84cfd4>
     9ab:	04 66                	add    $0x66,%al
     9ad:	06                   	(bad)
     9ae:	03 e0                	add    %eax,%esp
     9b0:	78 ac                	js     95e <balancer_ingress+0x95e>
     9b2:	05 07 06 03 80       	add    $0x80030607,%eax
     9b7:	05 3c 05 08 08       	add    $0x808053c,%eax
     9bc:	67 05 07 06 3c 05    	addr32 add $0x53c0607,%eax
  if (!lru_map) {
     9c2:	17                   	(bad)
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
     9c3:	06                   	(bad)
     9c4:	32 06                	xor    (%rsi),%al
     9c6:	03 fb                	add    %ebx,%edi
     9c8:	7a 4a                	jp     a14 <balancer_ingress+0xa14>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     9ca:	05 14 06 03 c1       	add    $0xc1030614,%eax
     9cf:	01 90 05 12 4c 06    	add    %edx,0x64c1205(%rax)
     9d5:	03 bd 7e 2e 03 c3    	add    -0x3cfcd182(%rbp),%edi
     9db:	01 3c 05 14 06 67 05 	add    %edi,0x5670614(,%rax,1)
    if (!lru_stats) {
     9e2:	0b 3d 06 03 bb 7e    	or     0x7ebb0306(%rip),%edi        # 7ebb0cee <_license+0x7ebaedfb>
     9e8:	4a 03 c5             	rex.WX add %rbp,%rax
    lru_stats->v1 += 1;
     9eb:	01 9e 03 bb 7e ba    	add    %ebx,-0x458144fd(%rsi)
     9f1:	05 1f 06 03 92       	add    $0x9203061f,%eax
     9f6:	05 4a 05 2e 06       	add    $0x62e054a,%eax
     9fb:	4a 05 17 06 67 05    	rex.WX add $0x5670617,%rax
     a01:	2e 06                	cs (bad)
  if ((vip_info->flags & F_QUIC_VIP)) {
     a03:	4a 05 09 06 03 95    	rex.WX add $0xffffffff95030609,%rax
     a09:	7b 66                	jnp    a71 <balancer_ingress+0xa71>
     a0b:	05 07 76 06 03       	add    $0x3067607,%eax
    bool is_icmp = (pckt.flags & F_ICMP);
     a10:	56                   	push   %rsi
     a11:	d6                   	(bad)
     a12:	03 2a                	add    (%rdx),%ebp
    if (is_icmp) {
     a14:	74 05                	je     a1b <balancer_ingress+0xa1b>
     a16:	08 06                	or     %al,(%rsi)
     a18:	2f                   	(bad)
      __u32 quic_packets_stats_key = 0;
     a19:	05 07 06 3c 05       	add    $0x53c0607,%eax
     a1e:	00 03                	add    %al,(%rbx)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     a20:	55                   	push   %rbp
     a21:	66 05 0f 06          	add    $0x60f,%ax
     a25:	03 2e                	add    (%rsi),%ebp
     a27:	9e                   	sahf
     a28:	05 12 32 05 29       	add    $0x29053212,%eax
     a2d:	06                   	(bad)
     a2e:	74 05                	je     a35 <balancer_ingress+0xa35>
     a30:	07                   	(bad)
     a31:	74 05                	je     a38 <balancer_ingress+0xa38>
     a33:	19 06                	sbb    %eax,(%rsi)
     a35:	30 75 68             	xor    %dh,0x68(%rbp)
      if (!quic_packets_stats) {
     a38:	05 1d 9f 05 09       	add    $0x9059f1d,%eax
     a3d:	06                   	(bad)
     a3e:	66 05 1c 06          	add    $0x61c,%ax
     a42:	03 dd                	add    %ebp,%ebx
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     a44:	04 2e                	add    $0x2e,%al
     a46:	05 09 08 91 06       	add    $0x6910809,%eax
     a4b:	3c 05                	cmp    $0x5,%al
     a4d:	49 06                	rex.WB (bad)
     a4f:	2f                   	(bad)
     a50:	05 19 06 4a 05       	add    $0x54a0619,%eax
     a55:	0b 06                	or     (%rsi),%eax
     a57:	59                   	pop    %rcx
     a58:	06                   	(bad)
     a59:	3c 05                	cmp    $0x5,%al
     a5b:	0f 06                	clts
     a5d:	32 05 27 75 05 0d    	xor    0xd057527(%rip),%al        # d057f8a <_license+0xd056097>
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     a63:	08 67 06             	or     %ah,0x6(%rdi)
     a66:	3c 05                	cmp    $0x5,%al
     a68:	1a 06                	sbb    (%rsi),%al
     a6a:	67 05 0a 03 c8 02    	addr32 add $0x2c8030a,%eax
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     a70:	90                   	nop
     a71:	05 09 06 3c 05       	add    $0x53c0609,%eax
     a76:	10 06                	adc    %al,(%rsi)
     a78:	03 27                	add    (%rdi),%esp
     a7a:	66 06                	data16 (bad)
     a7c:	03 f2                	add    %edx,%esi
     a7e:	77 08                	ja     a88 <balancer_ingress+0xa88>
    vip.port = 0;
     a80:	9e                   	sahf
     a81:	05 08 06 03 8f       	add    $0x8f030608,%eax
     a86:	08 58 05             	or     %bl,0x5(%rax)
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     a89:	07                   	(bad)
     a8a:	06                   	(bad)
     a8b:	3c 03                	cmp    $0x3,%al
     a8d:	f1                   	int1
     a8e:	77 66                	ja     af6 <balancer_ingress+0xaf6>
     a90:	05 12 06 03 92       	add    $0x92030612,%eax
     a95:	08 d6                	or     %dl,%dh
     a97:	05 15 75 05 12       	add    $0x12057515,%eax
     a9c:	06                   	(bad)
     a9d:	4a 05 10 06 4d 05    	rex.WX add $0x54d0610,%rax
    if (!vip_info) {
     aa3:	08 08                	or     %cl,(%rax)
     aa5:	13 05 07 06 3c 05    	adc    0x53c0607(%rip),%eax        # 53c10b2 <_license+0x53bf1bf>
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     aab:	12 06                	adc    (%rsi),%al
     aad:	69 4b 05 17 7b 06 03 	imul   $0x3067b17,0x5(%rbx),%ecx
      pckt.flow.port16[1] = 0;
     ab4:	de 77 4a             	fidivs 0x4a(%rdi)
     ab7:	05 12 06 03 a3       	add    $0xa3030612,%eax
     abc:	08 4a 05             	or     %cl,0x5(%rdx)
     abf:	07                   	(bad)
     ac0:	06                   	(bad)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     ac1:	4a 04 0d             	rex.WX add $0xd,%al
     ac4:	05 49 06 03 c0       	add    $0xc0030649,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     ac9:	78 66                	js     b31 <balancer_ingress+0xb31>
     acb:	06                   	(bad)
     acc:	03 9d 7f 58 05 07    	add    0x705587f(%rbp),%ebx
     ad2:	06                   	(bad)
     ad3:	03 e6                	add    %esi,%esp
     ad5:	00 74 06 ba          	add    %dh,-0x46(%rsi,%rax,1)
     ad9:	05 1c 06 69 05       	add    $0x569061c,%eax
     ade:	20 4b 05             	and    %cl,0x5(%rbx)
    if (!icmp_ptb_v6_stats) {
     ae1:	0e                   	(bad)
     ae2:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
    icmp_ptb_v6_stats->v1 += 1;
     ae8:	06                   	(bad)
     ae9:	3c 03                	cmp    $0x3,%al
     aeb:	92                   	xchg   %eax,%edx
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     aec:	7f 66                	jg     b54 <balancer_ingress+0xb54>
     aee:	03 ee                	add    %esi,%ebp
     af0:	00 4a 03             	add    %cl,0x3(%rdx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     af3:	92                   	xchg   %eax,%edx
     af4:	7f 90                	jg     a86 <balancer_ingress+0xa86>
     af6:	05 03 06 03 f1       	add    $0xf1030603,%eax
      icmp_ptb_v6_stats->v2 += 1;
     afb:	00 08                	add    %cl,(%rax)
     afd:	c8 08 2f 05          	enter  $0x2f08,$0x5
  if (ip6h + 1 > data_end) {
     b01:	14 d7                	adc    $0xd7,%al
     b03:	05 1c 68 05 2e       	add    $0x2e05681c,%eax
     b08:	06                   	(bad)
     b09:	74 04                	je     b0f <balancer_ingress+0xb0f>
     b0b:	0e                   	(bad)
     b0c:	05 0c 06 03 45       	add    $0x4503060c,%eax
     b11:	2e 4f 05 12 6a 05 10 	cs rex.WRXB add $0x10056a12,%rax
  pckt->flow.proto = ip6h->nexthdr;
     b18:	06                   	(bad)
  pckt->flags |= F_ICMP;
     b19:	74 05                	je     b20 <balancer_ingress+0xb20>
     b1b:	0b 06                	or     (%rsi),%eax
     b1d:	4b 05 0e 75 3d 05    	rex.WXB add $0x53d750e,%rax
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     b23:	0c 3d                	or     $0x3d,%al
     b25:	04 0c                	add    $0xc,%al
     b27:	05 0e 03 71 66       	add    $0x6671030e,%eax
     b2c:	05 0b 06 e4 05       	add    $0x5e4060b,%eax
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     b31:	0e                   	(bad)
     b32:	3c 05                	cmp    $0x5,%al
     b34:	0b 3c 04             	or     (%rsp,%rax,1),%edi
     b37:	00 05 1b 06 03 b0    	add    %al,-0x4ffcf9e5(%rip)        # ffffffffb0031158 <server_id_map+0x36fc6f84d158>
     b3d:	07                   	(bad)
     b3e:	82                   	(bad)
     b3f:	05 0b 06 4a 05       	add    $0x54a060b,%eax
     b44:	0f 06                	clts
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
     b46:	2f                   	(bad)
     b47:	05 0d 76 05 0e       	add    $0xe05760d,%eax
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b4c:	08 67 05             	or     %ah,0x5(%rdi)
     b4f:	0d 06 3c 06 69       	or     $0x69063c06,%eax
     b54:	05 00 06 03 91       	add    $0x91030600,%eax
     b59:	78 ac                	js     b07 <balancer_ingress+0xb07>
     b5b:	05 17 06 03 de       	add    $0xde030617,%eax
     b60:	00 58 05             	add    %bl,0x5(%rax)
      if (!data_stats) {
     b63:	09 03                	or     %eax,(%rbx)
     b65:	4a                   	rex.WX
     b66:	f2 05 07 76 06 03    	repnz add $0x3067607,%eax
      data_stats->v1 += 1;
     b6c:	56                   	push   %rsi
     b6d:	08 66 05             	or     %ah,0x5(%rsi)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     b70:	08 06                	or     %al,(%rsi)
     b72:	03 2b                	add    (%rbx),%ebp
     b74:	3c 05                	cmp    $0x5,%al
     b76:	07                   	(bad)
     b77:	06                   	(bad)
     b78:	3c 05                	cmp    $0x5,%al
     b7a:	00 03                	add    %al,(%rbx)
     b7c:	55                   	push   %rbp
     b7d:	66 05 0f 06          	add    $0x60f,%ax
        data_stats->v2 += 1;
     b81:	03 2e                	add    (%rsi),%ebp
     b83:	9e                   	sahf
     b84:	05 12 32 05 29       	add    $0x29053212,%eax
  original_sport = pckt.flow.port16[0];
     b89:	06                   	(bad)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     b8a:	74 05                	je     b91 <balancer_ingress+0xb91>
     b8c:	07                   	(bad)
     b8d:	74 05                	je     b94 <balancer_ingress+0xb94>
     b8f:	19 06                	sbb    %eax,(%rsi)
        !(vip_info->flags & F_LRU_BYPASS)) {
     b91:	68 75 06 03 4b       	push   $0x4b030675
     b96:	82                   	(bad)
     b97:	04 0d                	add    $0xd,%al
     b99:	05 07 06 03 3a       	add    $0x3a030607,%eax
     b9e:	ba 06 ba 05 1c       	mov    $0x1c05ba06,%edx
     ba3:	06                   	(bad)
     ba4:	69 05 20 4b 05 0f 4c 	imul   $0x4c13054c,0xf054b20(%rip),%eax        # f0556ce <_license+0xf0537db>
     bab:	05 13 4c 
     bae:	05 1e 06 3c 03       	add    $0x33c061e,%eax
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
     bb3:	be 7f 66 03 c2       	mov    $0xc203667f,%esi
     bb8:	00 4a 03             	add    %cl,0x3(%rdx)
     bbb:	be 7f 90 05 03       	mov    $0x305907f,%esi
     bc0:	06                   	(bad)
     bc1:	03 c5                	add    %ebp,%eax
    cur_time = bpf_ktime_get_ns();
     bc3:	00 9e 08 2f 05 14    	add    %bl,0x14052f08(%rsi)
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
     bc9:	d7                   	xlat   %ds:(%rbx)
     bca:	05 00 06 03 b9       	add    $0xb9030600,%eax
     bcf:	7f 66                	jg     c37 <balancer_ingress+0xc37>
     bd1:	04 0e                	add    $0xe,%al
     bd3:	05 12 06 03 25       	add    $0x25030612,%eax
     bd8:	4a 06                	rex.WX (bad)
     bda:	03 5b 3c             	add    0x3c(%rbx),%ebx
     bdd:	04 0d                	add    $0xd,%al
     bdf:	05 1d 06 03 cc       	add    $0xcc03061d,%eax
     be4:	00 3c 43             	add    %bh,(%rbx,%rax,2)
     be7:	04 0e                	add    $0xe,%al
     be9:	05 03 3d 05 20       	add    $0x20053d03,%eax
     bee:	68 05 12 06 58       	push   $0x58061205
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     bf3:	05 23 06 67 05       	add    $0x5670623,%eax
     bf8:	15 06 3c 05 11       	adc    $0x11053c06,%eax
     bfd:	06                   	(bad)
     bfe:	40 05 17 67 05 15    	rex add $0x15056717,%eax
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     c04:	06                   	(bad)
     c05:	4a 03 a4 7f 90 04 00 	add    0x5000490(%rdi,%r15,2),%rsp
     c0c:	05 
  if (!connId) {
     c0d:	19 06                	sbb    %eax,(%rsi)
     c0f:	03 37                	add    (%rdi),%esi
     c11:	82                   	(bad)
     c12:	05 1d 9f 05 09       	add    $0x9059f1d,%eax
     c17:	06                   	(bad)
  __u8 connIdVersion = (connId[0] >> 6);
     c18:	ac                   	lods   %ds:(%rsi),%al
     c19:	03 48 2e             	add    0x2e(%rax),%ecx
     c1c:	05 19 06 03 88       	add    $0x88030619,%eax
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     c21:	01 3c 05 09 06 3c 03 	add    %edi,0x33c0609(,%rax,1)
     c28:	f8                   	clc
     c29:	7e 2e                	jle    c59 <balancer_ingress+0xc59>
     c2b:	04 0a                	add    $0xa,%al
     c2d:	05 0a 06 03 3f       	add    $0x3f03060a,%eax
     c32:	66 3d 05 11          	cmp    $0x1105,%ax
     c36:	03 17                	add    (%rdi),%edx
     c38:	3c 4c                	cmp    $0x4c,%al
     c3a:	4c 05 0c 4c 06 03    	rex.WR add $0x3064c0c,%rax
     c40:	a3 7f 66 04 00 05 1e 	movabs %eax,0x3061e050004667f
     c47:	06 03 
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     c49:	8c 01                	mov    %es,(%rcx)
     c4b:	3c 05                	cmp    $0x5,%al
     c4d:	1c 06                	sbb    $0x6,%al
     c4f:	4a 05 07 06 4b 04    	rex.WX add $0x44b0607,%rax
     c55:	0a 03                	or     (%rbx),%al
     c57:	b3 7f                	mov    $0x7f,%bl
     c59:	02 22                	add    (%rdx),%ah
     c5b:	01 05 05 67 05 1a    	add    %eax,0x1a056705(%rip)        # 1a057366 <_license+0x1a055473>
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
     c61:	03 47 2e             	add    0x2e(%rdi),%eax
     c64:	05 05 03 39 3c       	add    $0x3c390305,%eax
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c69:	05 07 2c 05 05       	add    $0x5052c07,%eax
     c6e:	84 05 1a 03 47 9e    	test   %al,-0x61b8fce6(%rip)        # ffffffff9e470f8e <server_id_map+0x36fc5dc8cf8e>
     c74:	05 05 03 39 58       	add    $0x58390305,%eax
     c79:	05 1a 03 47 4a       	add    $0x4a47031a,%eax
      if (!data_stats) {
     c7e:	05 05 03 39 58       	add    $0x58390305,%eax
     c83:	05 1a 03 47 82       	add    $0x8247031a,%eax
      data_stats->v1 += 1;
     c88:	05 05 03 39 58       	add    $0x58390305,%eax
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     c8d:	05 1a 03 47 66       	add    $0x6647031a,%eax
     c92:	05 05 03 39 58       	add    $0x58390305,%eax
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     c97:	05 1a 03 47 66       	add    $0x6647031a,%eax
        data_stats->v2 += 1;
     c9c:	05 05 03 39 74       	add    $0x74390305,%eax
     ca1:	05 0c 03 16 2e       	add    $0x2e16030c,%eax
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     ca6:	05 16 06 4a 05       	add    $0x54a0616,%eax
     cab:	0c 06                	or     $0x6,%al
     cad:	3e 05 16 06 4a 05    	ds add $0x54a0616,%eax
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     cb3:	09 06                	or     %eax,(%rsi)
     cb5:	3a 05 0c 32 05 16    	cmp    0x1605320c(%rip),%al        # 16053ec7 <_license+0x16051fd4>
        quic_packets_stats->cid_initial += 1;
     cbb:	06                   	(bad)
     cbc:	4a 05 09 06 3a 05    	rex.WX add $0x53a0609,%rax
     cc2:	0c 32                	or     $0x32,%al
     cc4:	05 09 48 30 05       	add    $0x5304809,%eax
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     cc9:	05 03 64 2e 05       	add    $0x52e6403,%eax
     cce:	07                   	(bad)
     ccf:	03 1d 2e 05 1a 03    	add    0x31a052e(%rip),%ebx        # 31a1203 <_license+0x319f310>
     cd5:	aa                   	stos   %al,%es:(%rdi)
     cd6:	7f 3c                	jg     d14 <balancer_ingress+0xd14>
     cd8:	05 07 03 d6 00       	add    $0xd60307,%eax
     cdd:	58                   	pop    %rax
  if (!per_vip_stats) {
     cde:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    per_vip_stats->v1 += 1;
     ce3:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
     ce9:	58                   	pop    %rax
     cea:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
     cef:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
  key = dst_lru->pos;
     cf5:	58                   	pop    %rax
     cf6:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
     cfb:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
  pckt->real_index = key;
     d01:	58                   	pop    %rax
  *real = bpf_map_lookup_elem(&reals, &key);
     d02:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
     d07:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
     d0d:	58                   	pop    %rax
     d0e:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
     d13:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
     d19:	3c 05                	cmp    $0x5,%al
     d1b:	1a 03                	sbb    (%rbx),%al
     d1d:	aa                   	stos   %al,%es:(%rdi)
     d1e:	7f 4a                	jg     d6a <balancer_ingress+0xd6a>
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     d20:	05 05 03 df 00       	add    $0xdf0305,%eax
     d25:	3c 75                	cmp    $0x75,%al
     d27:	3b 05 03 69 05 1a    	cmp    0x1a056903(%rip),%eax        # 1a057630 <_license+0x1a05573d>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
     d2d:	03 9e 7f 82 05 03    	add    0x305827f(%rsi),%ebx
     d33:	03 e2                	add    %edx,%esp
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
     d35:	00 58 05             	add    %bl,0x5(%rax)
     d38:	1a 03                	sbb    (%rbx),%al
     d3a:	9e                   	sahf
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     d3b:	7f 4a                	jg     d87 <balancer_ingress+0xd87>
     d3d:	05 03 03 e2 00       	add    $0xe20303,%eax
     d42:	58                   	pop    %rax
     d43:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
     d48:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
     d4e:	58                   	pop    %rax
     d4f:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
  if (!conn_rate_stats) {
     d54:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
     d5a:	58                   	pop    %rax
     d5b:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
     d60:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
  *cur_time = bpf_ktime_get_ns();
     d66:	58                   	pop    %rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     d67:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
     d6c:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
     d72:	3c 05                	cmp    $0x5,%al
     d74:	1a 03                	sbb    (%rbx),%al
     d76:	9e                   	sahf
    conn_rate_stats->v1 = 1;
     d77:	7f 4a                	jg     dc3 <balancer_ingress+0xdc3>
     d79:	05 03 03 e2 00       	add    $0xe20303,%eax
    conn_rate_stats->v2 = *cur_time;
     d7e:	3c 06                	cmp    $0x6,%al
     d80:	03 96 7f 2e 04 00    	add    0x42e7f(%rsi),%edx
    conn_rate_stats->v1 += 1;
     d86:	05 30 06 03 8f       	add    $0x8f030630,%eax
     d8b:	01 58 06             	add    %ebx,0x6(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
     d8e:	03 f1                	add    %ecx,%esi
     d90:	7e 08                	jle    d9a <balancer_ingress+0xd9a>
     d92:	12 05 22 06 03 90    	adc    -0x6ffcf9de(%rip),%al        # ffffffff900313ba <server_id_map+0x36fc4f84d3ba>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
     d98:	01 4a 05             	add    %ecx,0x5(%rdx)
     d9b:	15 06 3c 05 2b       	adc    $0x2b053c06,%eax
     da0:	74 05                	je     da7 <balancer_ingress+0xda7>
     da2:	10 06                	adc    %al,(%rsi)
     da4:	30 05 09 67 05 10    	xor    %al,0x10056709(%rip)        # 100574b3 <_license+0x100555c0>
     daa:	65 06                	gs (bad)
     dac:	03 ee                	add    %esi,%ebp
     dae:	7e 2e                	jle    dde <balancer_ingress+0xdde>
    if (down_reals_map) {
     db0:	05 0b 06 03 96       	add    $0x9603060b,%eax
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
     db5:	01 9e 05 09 9f 05    	add    %ebx,0x59f0905(%rsi)
     dbb:	14 6d                	adc    $0x6d,%al
     dbd:	05 0b 3d 05 07       	add    $0x7053d0b,%eax
      if (down_real) {
     dc2:	67 6c                	insb   (%dx),%es:(%edi)
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
     dc4:	05 0f 06 82 03       	add    $0x382060f,%eax
     dc9:	da 7e 2e             	fidivrl 0x2e(%rsi)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
     dcc:	05 24 03 a6 01       	add    $0x1a60324,%eax
     dd1:	4a 05 34 74 03 da    	rex.WX add $0xffffffffda037434,%rax
     dd7:	7e 58                	jle    e31 <balancer_ingress+0xe31>
     dd9:	05 1a 06 03 a7       	add    $0xa703061a,%eax
     dde:	01 58 05             	add    %ebx,0x5(%rax)
        if (stats_data) {
     de1:	09 06                	or     %eax,(%rsi)
     de3:	4a 05 19 06 2f 05    	rex.WX add $0x52f0619,%rax
     de9:	15 4c 05 05 08       	adc    $0x805054c,%eax
          stats_data->v1 += 1;
     dee:	83 05 0b 03 d4 06 4a 	addl   $0x4a,0x6d4030b(%rip)        # 6d41100 <_license+0x6d3f20d>
    if (!dst) {
     df5:	06                   	(bad)
     df6:	03 81 78 4a 05 1a    	add    0x1a054a78(%rcx),%eax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
     dfc:	06                   	(bad)
     dfd:	03 d0                	add    %eax,%edx
     dff:	04 9e                	add    $0x9e,%al
     e01:	05 36 06 82 05       	add    $0x5820636,%eax
     e06:	47                   	rex.RXB
     e07:	66 05 1a 06          	add    $0x61a,%ax
     e0b:	2f                   	(bad)
     e0c:	05 36 06 66 05       	add    $0x5660636,%eax
     e11:	47                   	rex.RXB
     e12:	66 05 1a 06          	add    $0x61a,%ax
     e16:	2f                   	(bad)
     e17:	05 36 06 66 05       	add    $0x5660636,%eax
  if (!data_stats) {
     e1c:	47                   	rex.RXB
     e1d:	66 05 00 03          	add    $0x300,%ax
     e21:	ae                   	scas   %es:(%rdi),%al
     e22:	7b 2e                	jnp    e52 <balancer_ingress+0xe52>
     e24:	05 28 06 03 d5       	add    $0xd5030628,%eax
     e29:	04 e4                	add    $0xe4,%al
     e2b:	05 35 06 74 05       	add    $0x5740635,%eax
     e30:	36 06                	ss (bad)
     e32:	75 05                	jne    e39 <balancer_ingress+0xe39>
  data_stats->v1 += 1;
     e34:	2f                   	(bad)
     e35:	06                   	(bad)
     e36:	66 05 22 06          	add    $0x622,%ax
  data_stats->v2 += pkt_bytes;
     e3a:	67 05 0b ca 05 1c    	addr32 add $0x1c05ca0b,%eax
     e40:	4b 05 0a 08 67 05    	rex.WXB add $0x567080a,%rax
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
     e46:	09 06                	or     %eax,(%rsi)
     e48:	3c 05                	cmp    $0x5,%al
     e4a:	14 06                	adc    $0x6,%al
     e4c:	69 06 03 a2 7b 3c    	imul   $0x3c7ba203,(%rsi),%eax
     e52:	05 16 06 03 84       	add    $0x84030616,%eax
  if (!data_stats) {
     e57:	08 08                	or     %cl,(%rax)
     e59:	e4 04                	in     $0x4,%al
     e5b:	09 05 13 03 ed 7a    	or     %eax,0x7aed0313(%rip)        # 7aed1174 <_license+0x7aecf281>
  data_stats->v2 += pkt_bytes;
     e61:	c8 05 35 06          	enter  $0x3505,$0x6
     e65:	4a 05 09 3c 05 2d    	rex.WX add $0x2d053c09,%rax
     e6b:	06                   	(bad)
     e6c:	69 05 09 06 3c 04 00 	imul   $0x6290500,0x43c0609(%rip),%eax        # 43c147f <_license+0x43bf58c>
     e73:	05 29 06 
  if (dst->flags & F_IPV6) {
     e76:	03 ac 04 66 06 03 e0 	add    -0x1ffcf99a(%rsp,%rax,1),%ebp
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
     e7d:	78 ac                	js     e2b <balancer_ingress+0xe2b>
     e7f:	05 07 06 03 80       	add    $0x80030607,%eax
     e84:	05 3c 05 08 08       	add    $0x808053c,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
     e89:	67 05 07 06 3c 05    	addr32 add $0x53c0607,%eax
     e8f:	17                   	(bad)
     e90:	06                   	(bad)
     e91:	6a 04                	push   $0x4
     e93:	09 05 23 03 f8 7d    	or     %eax,0x7df80323(%rip)        # 7df811bc <_license+0x7df7f2c9>
  data = (void*)(long)xdp->data;
     e99:	90                   	nop
     e9a:	06                   	(bad)
  data_end = (void*)(long)xdp->data_end;
     e9b:	03 83 7d 58 05 08    	add    0x805587d(%rbx),%eax
  iph = data + sizeof(struct ethhdr);
     ea1:	06                   	(bad)
     ea2:	03 88 03 08 12 05    	add    0x5120803(%rax),%ecx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
     ea8:	0a 03                	or     (%rbx),%al
     eaa:	11 d6                	adc    %edx,%esi
     eac:	05 14 06 4a 05       	add    $0x54a0614,%eax
     eb1:	1e                   	(bad)
     eb2:	4a 05 28 4a 05 1b    	rex.WX add $0x1b054a28,%rax
     eb8:	4a 05 32 3c 05 3c    	rex.WX add $0x3c053c32,%rax
     ebe:	4a 05 2f 4a 05 45    	rex.WX add $0x45054a2f,%rax
     ec4:	3c 03                	cmp    $0x3,%al
     ec6:	e7 7c                	out    %eax,$0x7c
     ec8:	3c 05                	cmp    $0x5,%al
     eca:	19 06                	sbb    %eax,(%rsi)
     ecc:	03 95 03 4a 05 23    	add    0x23054a03(%rbp),%edx
     ed2:	06                   	(bad)
     ed3:	4a 05 2d 4a 05 37    	rex.WX add $0x37054a2d,%rax
  memcpy(new_eth->h_dest, cval->mac, 6);
     ed9:	4a 05 2a 4a 05 40    	rex.WX add $0x40054a2a,%rax
     edf:	3c 03                	cmp    $0x3,%al
     ee1:	eb 7c                	jmp    f5f <balancer_ingress+0xf5f>
     ee3:	3c 04                	cmp    $0x4,%al
     ee5:	00 05 19 06 03 f0    	add    %al,-0xffcf9e7(%rip)        # fffffffff0031504 <server_id_map+0x36fcaf84d504>
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
     eeb:	06                   	(bad)
     eec:	82                   	(bad)
     eed:	06                   	(bad)
     eee:	03 90 79 66 05 0b    	add    0xb056679(%rax),%edx
     ef4:	03 f0                	add    %eax,%esi
     ef6:	06                   	(bad)
     ef7:	3c 05                	cmp    $0x5,%al
  new_eth->h_proto = BE_ETH_P_IP;
     ef9:	07                   	(bad)
     efa:	06                   	(bad)
     efb:	03 c8                	add    %eax,%ecx
     efd:	7d 66                	jge    f65 <balancer_ingress+0xf65>
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
     eff:	06                   	(bad)
     f00:	03 c8                	add    %eax,%ecx
     f02:	7b e4                	jnp    ee8 <balancer_ingress+0xee8>
     f04:	04 09                	add    $0x9,%al
     f06:	05 23 06 03 fd       	add    $0xfd030623,%eax
  iph->tos = tos;
     f0b:	02 74 06 03          	add    0x3(%rsi,%rax,1),%dh
     f0f:	83 7d 58 05          	cmpl   $0x5,0x58(%rbp)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
     f13:	08 06                	or     %al,(%rsi)
     f15:	03 88 03 c8 05 07    	add    0x705c803(%rax),%ecx
     f1b:	06                   	(bad)
  iph->id = 0;
     f1c:	3c 05                	cmp    $0x5,%al
     f1e:	19 06                	sbb    %eax,(%rsi)
     f20:	6a 05                	push   $0x5
     f22:	23 06                	and    (%rsi),%eax
  iph->daddr = daddr;
     f24:	3c 05                	cmp    $0x5,%al
  iph->saddr = saddr;
     f26:	07                   	(bad)
     f27:	06                   	(bad)
     f28:	5a                   	pop    %rdx
  iph->ttl = DEFAULT_TTL;
     f29:	05 15 08 a2 05       	add    $0x5a20815,%eax
     f2e:	1d 06 3c 05 27       	sbb    $0x27053c06,%eax
    *csum += *next_iph_u16++;
     f33:	4a 05 24 4a 05 3a    	rex.WX add $0x3a054a24,%rax
     f39:	4a 05 44 3c 03 ee    	rex.WX add $0xffffffffee033c44,%rax
     f3f:	7c 9e                	jl     edf <balancer_ingress+0xedf>
     f41:	04 00                	add    $0x0,%al
     f43:	05 1b 06 03 f5       	add    $0xf503061b,%eax
     f48:	06                   	(bad)
     f49:	08 74 05 0d          	or     %dh,0xd(%rbp,%rax,1)
      if (pckt.flow.proto == IPPROTO_TCP) {
     f4d:	67 06                	addr32 (bad)
     f4f:	03 8a 79 2e 05 11    	add    0x11052e79(%rdx),%ecx
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
     f55:	06                   	(bad)
     f56:	03 f8                	add    %eax,%edi
     f58:	06                   	(bad)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
     f59:	9e                   	sahf
     f5a:	05 0f 9f 05 1d       	add    $0x1d059f0f,%eax
     f5f:	35 05 13 59 06       	xor    $0x6591305,%eax
     f64:	66 05 12 06          	add    $0x612,%ax
     f68:	08 91 05 11 06 3c    	or     %dl,0x3c061105(%rcx)
     f6e:	03 fe                	add    %esi,%edi
        if (!lru_stats) {
     f70:	78 66                	js     fd8 <balancer_ingress+0xfd8>
     f72:	05 22 06 03 ea       	add    $0xea030622,%eax
     f77:	04 08                	add    $0x8,%al
        if (pckt.flags & F_SYN_SET) {
     f79:	4a 05 07 3d 06 3c    	rex.WX add $0x3c063d07,%rax
     f7f:	05 1f 06 67 05       	add    $0x567061f,%eax
     f84:	16                   	(bad)
     f85:	06                   	(bad)
     f86:	3c 05                	cmp    $0x5,%al
     f88:	09 2e                	or     %ebp,(%rsi)
  struct real_pos_lru new_dst_lru = {};
     f8a:	05 34 06 03 9f       	add    $0x9f030634,%eax
     f8f:	02 66 05             	add    0x5(%rsi),%ah
     f92:	00 06                	add    %al,(%rsi)
     f94:	03 f5                	add    %ebp,%esi
     f96:	78 9e                	js     f36 <balancer_ingress+0xf36>
     f98:	04 09                	add    $0x9,%al
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
     f9a:	05 0a 06 03 99       	add    $0x9903060a,%eax
     f9f:	03 08                	add    (%rax),%ecx
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     fa1:	82                   	(bad)
     fa2:	05 14 06 4a 05       	add    $0x54a0614,%eax
     fa7:	1e                   	(bad)
     fa8:	4a 05 28 4a 05 1b    	rex.WX add $0x1b054a28,%rax
     fae:	4a 05 32 3c 05 3c    	rex.WX add $0x3c053c32,%rax
     fb4:	4a 05 2f 4a 05 45    	rex.WX add $0x45054a2f,%rax
  if (!conn_rate_stats) {
     fba:	3c 03                	cmp    $0x3,%al
     fbc:	e7 7c                	out    %eax,$0x7c
     fbe:	3c 05                	cmp    $0x5,%al
     fc0:	19 06                	sbb    %eax,(%rsi)
     fc2:	03 95 03 4a 05 23    	add    0x23054a03(%rbp),%edx
     fc8:	06                   	(bad)
     fc9:	4a 05 2d 4a 05 37    	rex.WX add $0x37054a2d,%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     fcf:	4a 05 2a 4a 05 40    	rex.WX add $0x40054a2a,%rax
     fd5:	3c 03                	cmp    $0x3,%al
     fd7:	eb 7c                	jmp    1055 <balancer_ingress+0x1055>
     fd9:	3c 04                	cmp    $0x4,%al
     fdb:	00 05 19 06 03 f0    	add    %al,-0xffcf9e7(%rip)        # fffffffff00315fa <server_id_map+0x36fcaf84d5fa>
     fe1:	06                   	(bad)
     fe2:	82                   	(bad)
    conn_rate_stats->v1 = 1;
     fe3:	05 0b 06 2e 05       	add    $0x52e060b,%eax
     fe8:	07                   	(bad)
     fe9:	06                   	(bad)
    conn_rate_stats->v2 = *cur_time;
     fea:	03 c8                	add    %eax,%ecx
     fec:	7d 66                	jge    1054 <balancer_ingress+0x1054>
     fee:	06                   	(bad)
     fef:	03 c8                	add    %eax,%ecx
     ff1:	7b e4                	jnp    fd7 <balancer_ingress+0xfd7>
     ff3:	05 09 06 03 28       	add    $0x28030609,%eax
     ff8:	74 05                	je     fff <balancer_ingress+0xfff>
     ffa:	07                   	(bad)
     ffb:	76 05                	jbe    1002 <balancer_ingress+0x1002>
     ffd:	08 08                	or     %cl,(%rax)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
     fff:	13 05 07 06 3c 05    	adc    0x53c0607(%rip),%eax        # 53c160c <_license+0x53bf719>
    1005:	00 03                	add    %al,(%rbx)
    1007:	55                   	push   %rbp
    1008:	66 05 0f 06          	add    $0x60f,%ax
    100c:	03 2e                	add    (%rsi),%ebp
    100e:	9e                   	sahf
    100f:	05 12 32 05 29       	add    $0x29053212,%eax
  data_end = (void*)(long)xdp->data_end;
    1014:	06                   	(bad)
    1015:	74 05                	je     101c <balancer_ingress+0x101c>
    1017:	07                   	(bad)
  ip6h = data + sizeof(struct ethhdr);
    1018:	74 05                	je     101f <balancer_ingress+0x101f>
    101a:	19 06                	sbb    %eax,(%rsi)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    101c:	68 75 06 03 4b       	push   $0x4b030675
    1021:	90                   	nop
    1022:	05 1b 06 03 f5       	add    $0xf503061b,%eax
    1027:	06                   	(bad)
    1028:	08 74 05 0d          	or     %dh,0xd(%rbp,%rax,1)
    102c:	59                   	pop    %rcx
    102d:	06                   	(bad)
    102e:	03 8a 79 2e 05 11    	add    0x11052e79(%rdx),%ecx
    1034:	06                   	(bad)
    1035:	03 f8                	add    %eax,%edi
    1037:	06                   	(bad)
    1038:	9e                   	sahf
    1039:	05 0f 9f 05 1d       	add    $0x1d059f0f,%eax
  memcpy(new_eth->h_dest, cval->mac, 6);
    103e:	35 05 13 59 06       	xor    $0x6591305,%eax
    1043:	66 03 ff             	add    %di,%di
    1046:	78 4a                	js     1092 <balancer_ingress+0x1092>
    1048:	03 81 07 9e 03 ff    	add    -0xfc61f9(%rcx),%eax
    104e:	78 ba                	js     100a <balancer_ingress+0x100a>
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1050:	05 12 06 03 82       	add    $0x82030612,%eax
    1055:	07                   	(bad)
    1056:	4a 05 11 06 3c 03    	rex.WX add $0x33c0611,%rax
    105c:	fe                   	(bad)
  new_eth->h_proto = BE_ETH_P_IPV6;
    105d:	78 66                	js     10c5 <balancer_ingress+0x10c5>
    105f:	05 22 06 03 ea       	add    $0xea030622,%eax
    1064:	04 08                	add    $0x8,%al
    1066:	20 05 07 3d 06 3c    	and    %al,0x3c063d07(%rip)        # 3c064d73 <_license+0x3c062e80>
    106c:	05 1f 06 67 05       	add    $0x567061f,%eax
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1071:	16                   	(bad)
    1072:	06                   	(bad)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1073:	3c 05                	cmp    $0x5,%al
    1075:	09 2e                	or     %ebp,(%rsi)
    1077:	05 34 06 03 9f       	add    $0x9f030634,%eax
  ip6h->priority = (tc & 0xF0) >> 4;
    107c:	02 66 05             	add    0x5(%rsi),%ah
    107f:	00 06                	add    %al,(%rsi)
    1081:	03 f5                	add    %ebp,%esi
    1083:	78 9e                	js     1023 <balancer_ingress+0x1023>
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1085:	05 14 06 03 af       	add    $0xaf030614,%eax
  ip6h->nexthdr = proto;
    108a:	07                   	(bad)
    108b:	08 2e                	or     %ch,(%rsi)
    108d:	05 1e 03 26 9e       	add    $0x9e26031e,%eax
  ip6h->payload_len = bpf_htons(payload_len);
    1092:	05 2b 06 4a 05       	add    $0x54a062b,%eax
    1097:	1b 06                	sbb    (%rsi),%eax
    1099:	2f                   	(bad)
    109a:	05 09 3b 06 03       	add    $0x3063b09,%eax
    109f:	ab                   	stos   %eax,%es:(%rdi)
    10a0:	78 2e                	js     10d0 <balancer_ingress+0x10d0>
    10a2:	05 0d 06 03 b8       	add    $0xb803060d,%eax
    conn_rate_stats->v1 += 1;
    10a7:	01 08                	add    %ecx,(%rax)
    10a9:	20 05 08 2f 05 07    	and    %al,0x7052f08(%rip)        # 7053fb7 <_license+0x70520c4>
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    10af:	06                   	(bad)
    10b0:	3c 05                	cmp    $0x5,%al
    10b2:	00 03                	add    %al,(%rbx)
    10b4:	c7                   	(bad)
    10b5:	7e 2e                	jle    10e5 <balancer_ingress+0x10e5>
    10b7:	05 28 06 03 bc       	add    $0xbc030628,%eax
    10bc:	01 3c 05 07 06 4a 03 	add    %edi,0x34a0607(,%rax,1)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    10c3:	c4                   	(bad)
    10c4:	7e 2e                	jle    10f4 <balancer_ingress+0x10f4>
    10c6:	05 10 06 03 bd       	add    $0xbd030610,%eax
    b += *(u32*)(k + 4);
    10cb:	01 74 05 12          	add    %esi,0x12(%rbp,%rax,1)
    c += *(u32*)(k + 8);
    10cf:	2f                   	(bad)
      a += (u32)k[3] << 24;
    10d0:	05 23 06 08 12       	add    $0x12080623,%eax
      a += (u32)k[2] << 16;
    10d5:	05 09 3c 03 c2       	add    $0xc2033c09,%eax
      a += (u32)k[1] << 8;
    10da:	7e 2e                	jle    110a <balancer_ingress+0x110a>
      a += k[0];
    10dc:	05 14 06 03 c1       	add    $0xc1030614,%eax
    10e1:	01 82 05 12 4c 06    	add    %eax,0x64c1205(%rdx)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    10e7:	03 bd 7e 2e 03 c3    	add    -0x3cfcd182(%rbp),%edi
      memset(pckt->flow.srcv6, 0, 16);
    10ed:	01 2e                	add    %ebp,(%rsi)
    10ef:	05 14 06 67 05       	add    $0x5670614,%eax
    10f4:	0b 3d 06 03 bb 7e    	or     0x7ebb0306(%rip),%edi        # 7ebb1400 <_license+0x7ebaf50d>
    10fa:	4a 03 c5             	rex.WX add %rbp,%rax
    10fd:	01 9e 03 bb 7e ba    	add    %ebx,-0x458144fd(%rsi)
    1103:	05 1f 06 03 92       	add    $0x9203061f,%eax
    1108:	05 4a 05 2e 06       	add    $0x62e054a,%eax
    110d:	4a 05 17 06 67 05    	rex.WX add $0x5670617,%rax
    c += *(u32*)(k + 8);
    1113:	2e 06                	cs (bad)
    __jhash_mix(a, b, c);
    1115:	4a 05 09 06 03 95    	rex.WX add $0xffffffff95030609,%rax
    111b:	7b 66                	jnp    1183 <balancer_ingress+0x1183>
    b += *(u32*)(k + 4);
    111d:	05 07 76 05 08       	add    $0x8057607,%eax
    1122:	08 67 05             	or     %ah,0x5(%rdi)
    __jhash_mix(a, b, c);
    1125:	07                   	(bad)
    1126:	06                   	(bad)
    1127:	3c 05                	cmp    $0x5,%al
    1129:	00 03                	add    %al,(%rbx)
    112b:	55                   	push   %rbp
    112c:	66 05 0f 06          	add    $0x60f,%ax
  return (word << shift) | (word >> ((-shift) & 31));
    1130:	03 2e                	add    (%rsi),%ebp
    1132:	9e                   	sahf
    __jhash_mix(a, b, c);
    1133:	05 12 32 05 29       	add    $0x29053212,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1138:	06                   	(bad)
    1139:	74 05                	je     1140 <balancer_ingress+0x1140>
    113b:	07                   	(bad)
    __jhash_mix(a, b, c);
    113c:	74 05                	je     1143 <balancer_ingress+0x1143>
    113e:	19 06                	sbb    %eax,(%rsi)
    1140:	30 75 68             	xor    %dh,0x68(%rbp)
    1143:	05 1d 9f 05 09       	add    $0x9059f1d,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1148:	06                   	(bad)
    __jhash_mix(a, b, c);
    1149:	66 05 1c 06          	add    $0x61c,%ax
    114d:	03 dd                	add    %ebp,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    114f:	04 2e                	add    $0x2e,%al
    1151:	05 09 08 9f 06       	add    $0x69f0809,%eax
    __jhash_mix(a, b, c);
    1156:	3c 05                	cmp    $0x5,%al
    1158:	49 06                	rex.WB (bad)
  return (word << shift) | (word >> ((-shift) & 31));
    115a:	2f                   	(bad)
    115b:	05 19 06 4a 05       	add    $0x54a0619,%eax
    1160:	0b 06                	or     (%rsi),%eax
    __jhash_mix(a, b, c);
    1162:	67 06                	addr32 (bad)
      a += (u32)k[3] << 24;
    1164:	3c 05                	cmp    $0x5,%al
    1166:	0f 06                	clts
    1168:	32 05 27 75 05 0d    	xor    0xd057527(%rip),%al        # d058695 <_license+0xd0567a2>
      a += (u32)k[2] << 16;
    116e:	08 67 06             	or     %ah,0x6(%rdi)
      a += (u32)k[3] << 24;
    1171:	3c 05                	cmp    $0x5,%al
      a += (u32)k[1] << 8;
    1173:	1a 06                	sbb    (%rsi),%al
    1175:	67 05 0a 03 c8 02    	addr32 add $0x2c8030a,%eax
      a += (u32)k[2] << 16;
    117b:	90                   	nop
      a += k[0];
    117c:	05 09 06 3c 03       	add    $0x33c0609,%eax
      a += (u32)k[1] << 8;
    1181:	99                   	cltd
      a += k[0];
    1182:	78 66                	js     11ea <balancer_ingress+0x11ea>
    __jhash_mix(a, b, c);
    1184:	05 10 06 03 8e       	add    $0x8e030610,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1189:	08 4a 06             	or     %cl,0x6(%rdx)
    118c:	03 f2                	add    %edx,%esi
      __jhash_final(a, b, c);
    118e:	77 08                	ja     1198 <balancer_ingress+0x1198>
    1190:	9e                   	sahf
    1191:	05 08 06 03 8f       	add    $0x8f030608,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1196:	08 58 05             	or     %bl,0x5(%rax)
      __jhash_final(a, b, c);
    1199:	07                   	(bad)
    119a:	06                   	(bad)
  return (word << shift) | (word >> ((-shift) & 31));
    119b:	3c 03                	cmp    $0x3,%al
    119d:	f1                   	int1
    119e:	77 66                	ja     1206 <balancer_ingress+0x1206>
      __jhash_final(a, b, c);
    11a0:	05 12 06 03 92       	add    $0x92030612,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    11a5:	08 ba 05 15 4b 05    	or     %bh,0x54b1505(%rdx)
      __jhash_final(a, b, c);
    11ab:	12 06                	adc    (%rsi),%al
  return (word << shift) | (word >> ((-shift) & 31));
    11ad:	4a 05 10 06 4d 05    	rex.WX add $0x54d0610,%rax
      __jhash_final(a, b, c);
    11b3:	08 08                	or     %cl,(%rax)
    11b5:	13 05 07 06 3c 05    	adc    0x53c0607(%rip),%eax        # 53c17c2 <_license+0x53bf8cf>
    11bb:	12 06                	adc    (%rsi),%al
  return (word << shift) | (word >> ((-shift) & 31));
    11bd:	69 4b 05 17 a5 06 03 	imul   $0x306a517,0x5(%rbx),%ecx
  a += initval;
    11c4:	de 77 4a             	fidivs 0x4a(%rdi)
  b += initval;
    11c7:	05 12 06 03 a3       	add    $0xa3030612,%eax
  a += initval;
    11cc:	08 4a 05             	or     %cl,0x5(%rdx)
    11cf:	07                   	(bad)
  __jhash_final(a, b, c);
    11d0:	06                   	(bad)
    11d1:	4a 04 0d             	rex.WX add $0xd,%al
    11d4:	05 49 06 03 c0       	add    $0xc0030649,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    11d9:	78 66                	js     1241 <balancer_ingress+0x1241>
    11db:	06                   	(bad)
    11dc:	03 9d 7f 58 05 07    	add    0x705587f(%rbp),%ebx
    11e2:	06                   	(bad)
    11e3:	03 e6                	add    %esi,%esp
    11e5:	00 74 06 ba          	add    %dh,-0x46(%rsi,%rax,1)
  __jhash_final(a, b, c);
    11e9:	05 1c 06 69 05       	add    $0x569061c,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    11ee:	20 4b 05             	and    %cl,0x5(%rbx)
  __jhash_final(a, b, c);
    11f1:	0e                   	(bad)
    11f2:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
    11f8:	06                   	(bad)
    11f9:	3c 03                	cmp    $0x3,%al
    11fb:	92                   	xchg   %eax,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    11fc:	7f 66                	jg     1264 <balancer_ingress+0x1264>
    11fe:	03 ee                	add    %esi,%ebp
    1200:	00 4a 03             	add    %cl,0x3(%rdx)
  __jhash_final(a, b, c);
    1203:	92                   	xchg   %eax,%edx
    1204:	7f 90                	jg     1196 <balancer_ingress+0x1196>
  return (word << shift) | (word >> ((-shift) & 31));
    1206:	05 03 06 03 f1       	add    $0xf1030603,%eax
  __jhash_final(a, b, c);
    120b:	00 02                	add    %al,(%rdx)
  return (word << shift) | (word >> ((-shift) & 31));
    120d:	22 01                	and    (%rcx),%al
  __jhash_final(a, b, c);
    120f:	08 2f                	or     %ch,(%rdi)
    1211:	05 14 d7 05 1c       	add    $0x1c05d714,%eax
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1216:	68 05 2e 06 74       	push   $0x74062e05
    121b:	04 0e                	add    $0xe,%al
    121d:	05 0c 06 03 45       	add    $0x4503060c,%eax
    1222:	2e 4f 05 12 40 05 10 	cs rex.WRXB add $0x10054012,%rax
    1229:	06                   	(bad)
    122a:	90                   	nop
    key = RING_SIZE * (vip_info->vip_num) + hash;
    122b:	05 0b 06 59 05       	add    $0x559060b,%eax
    1230:	0e                   	(bad)
    1231:	75 3d                	jne    1270 <balancer_ingress+0x1270>
    1233:	05 0c 3d 04 0c       	add    $0xc043d0c,%eax
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1238:	05 0e 03 71 66       	add    $0x6671030e,%eax
    if (!real_pos) {
    123d:	05 0b 06 f2 05       	add    $0x5f2060b,%eax
    1242:	0e                   	(bad)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1243:	3c 05                	cmp    $0x5,%al
    1245:	0b 3c 04             	or     (%rsp,%rax,1),%edi
    1248:	00 05 00 03 48 3c    	add    %al,0x3c480300(%rip)        # 3c48154e <_license+0x3c47f65b>
    124e:	05 1b 06 03 e8       	add    $0xe803061b,%eax
    key = *real_pos;
    1253:	07                   	(bad)
    1254:	02 7d 01             	add    0x1(%rbp),%bh
    1257:	05 0b 06 4a 05       	add    $0x54a060b,%eax
    if (key == 0) {
    125c:	0f 06                	clts
    125e:	2f                   	(bad)
  pckt->real_index = key;
    125f:	05 0d 76 05 0e       	add    $0xe05760d,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
    1264:	08 67 05             	or     %ah,0x5(%rdi)
    1267:	0d 06 3c 06 69       	or     $0x69063c06,%eax
  if (!(*real)) {
    126c:	05 00 06 03 91       	add    $0x91030600,%eax
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1271:	78 ac                	js     121f <balancer_ingress+0x121f>
    1273:	05 17 06 03 de       	add    $0xde030617,%eax
    1278:	00 58 05             	add    %bl,0x5(%rax)
    127b:	09 03                	or     %eax,(%rbx)
    127d:	4a                   	rex.WX
    127e:	f2 05 07 76 06 03    	repnz add $0x3067607,%eax
    1284:	56                   	push   %rsi
    1285:	08 66 05             	or     %ah,0x5(%rsi)
    1288:	08 06                	or     %al,(%rsi)
    128a:	03 2b                	add    (%rbx),%ebp
    128c:	3c 05                	cmp    $0x5,%al
    if (pckt->flow.proto == IPPROTO_UDP) {
    128e:	07                   	(bad)
    128f:	06                   	(bad)
    1290:	3c 05                	cmp    $0x5,%al
    1292:	00 03                	add    %al,(%rbx)
      new_dst_lru.atime = cur_time;
    1294:	55                   	push   %rbp
    1295:	66 05 0f 06          	add    $0x60f,%ax
    new_dst_lru.pos = key;
    1299:	03 2e                	add    (%rsi),%ebp
    129b:	9e                   	sahf
    129c:	05 12 32 05 29       	add    $0x29053212,%eax
    12a1:	06                   	(bad)
    12a2:	74 05                	je     12a9 <balancer_ingress+0x12a9>
    12a4:	07                   	(bad)
    12a5:	74 05                	je     12ac <balancer_ingress+0x12ac>
    12a7:	19 06                	sbb    %eax,(%rsi)
    12a9:	68 75 06 03 4b       	push   $0x4b030675
    12ae:	90                   	nop
    12af:	04 0d                	add    $0xd,%al
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    12b1:	05 07 06 03 3a       	add    $0x3a030607,%eax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    12b6:	74 06                	je     12be <balancer_ingress+0x12be>
    12b8:	ba 05 1c 06 69       	mov    $0x69061c05,%edx
    12bd:	05 20 4b 05 0f       	add    $0xf054b20,%eax
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    12c2:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
    12c8:	06                   	(bad)
    12c9:	3c 03                	cmp    $0x3,%al
    12cb:	be 7f 66 03 c2       	mov    $0xc203667f,%esi
    12d0:	00 4a 03             	add    %cl,0x3(%rdx)
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    12d3:	be 7f 90 05 03       	mov    $0x305907f,%esi
    12d8:	06                   	(bad)
    12d9:	03 c5                	add    %ebp,%eax
    12db:	00 9e 08 2f 05 14    	add    %bl,0x14052f08(%rsi)
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    12e1:	d7                   	xlat   %ds:(%rbx)
    12e2:	05 00 06 03 b9       	add    $0xb9030600,%eax
    12e7:	7f 66                	jg     134f <balancer_ingress+0x134f>
    12e9:	04 0e                	add    $0xe,%al
    12eb:	05 12 06 03 25       	add    $0x25030612,%eax
    12f0:	4a 04 0d             	rex.WX add $0xd,%al
    12f3:	05 1d 03 2e 3c       	add    $0x3c2e031d,%eax
    12f8:	04 0e                	add    $0xe,%al
    12fa:	05 03 3d 05 20       	add    $0x20053d03,%eax
  bool port_match = lru_miss_stat_vip->port == vip->port;
    12ff:	68 05 12 06 58       	push   $0x58061205
    1304:	05 23 06 67 05       	add    $0x5670623,%eax
    1309:	15 06 3c 05 11       	adc    $0x11053c06,%eax
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    130e:	06                   	(bad)
    130f:	40 05 15 9f 04 00    	rex add $0x49f15,%eax
    1315:	05 00 06 03 a4       	add    $0xa4030600,%eax
  bool vip_match = address_match && port_match && proto_match;
    131a:	7f 4a                	jg     1366 <balancer_ingress+0x1366>
    131c:	05 19 06 03 37       	add    $0x37030619,%eax
    1321:	02 2e                	add    (%rsi),%ch
    1323:	01 05 1d 9f 05 09    	add    %eax,0x9059f1d(%rip)        # 905b246 <_license+0x9059353>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1329:	06                   	(bad)
    132a:	74 03                	je     132f <balancer_ingress+0x132f>
    132c:	48                   	rex.W
    132d:	2e 05 19 06 03 88    	cs add $0x88030619,%eax
    1333:	01 74 05 09          	add    %esi,0x9(%rbp,%rax,1)
    1337:	06                   	(bad)
    1338:	3c 05                	cmp    $0x5,%al
    133a:	00 03                	add    %al,(%rbx)
    133c:	f8                   	clc
    133d:	7e 2e                	jle    136d <balancer_ingress+0x136d>
    if (!lru_miss_stat) {
    133f:	05 1e 06 03 8c       	add    $0x8c03061e,%eax
    1344:	01 58 05             	add    %ebx,0x5(%rax)
    1347:	1c 06                	sbb    $0x6,%al
    *lru_miss_stat += 1;
    1349:	4a 05 07 06 4b 06    	rex.WX add $0x64b0607,%rax
    134f:	03 f3                	add    %ebx,%esi
    1351:	7e 08                	jle    135b <balancer_ingress+0x135b>
    1353:	20 04 0a             	and    %al,(%rdx,%rcx,1)
    1356:	05 05 06 03 e8       	add    $0xe8030605,%eax
    135b:	00 58 3b             	add    %bl,0x3b(%rax)
    135e:	05 03 69 05 1a       	add    $0x1a056903,%eax
    1363:	03 9e 7f 82 05 03    	add    0x305827f(%rsi),%ebx
    1369:	03 e2                	add    %edx,%esp
      data_stats->v2 += 1;
    136b:	00 58 05             	add    %bl,0x5(%rax)
    136e:	1a 03                	sbb    (%rbx),%al
    1370:	9e                   	sahf
    1371:	7f 4a                	jg     13bd <balancer_ingress+0x13bd>
    1373:	05 03 03 e2 00       	add    $0xe20303,%eax
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1378:	58                   	pop    %rax
    1379:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    137e:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    1384:	58                   	pop    %rax
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1385:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    138a:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
        quic_packets_stats->cid_initial += 1;
    1390:	58                   	pop    %rax
    1391:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    1396:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    139c:	58                   	pop    %rax
    139d:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    13a2:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    13a8:	3c 05                	cmp    $0x5,%al
    13aa:	1a 03                	sbb    (%rbx),%al
    13ac:	9e                   	sahf
    13ad:	7f 4a                	jg     13f9 <balancer_ingress+0x13f9>
    13af:	05 03 03 e2 00       	add    $0xe20303,%eax
  if (!per_vip_stats) {
    13b4:	3c 06                	cmp    $0x6,%al
    13b6:	03 96 7f 2e 04 00    	add    0x42e7f(%rsi),%edx
    per_vip_stats->v1 += 1;
    13bc:	05 30 06 03 8f       	add    $0x8f030630,%eax
    13c1:	01 58 06             	add    %ebx,0x6(%rax)
    13c4:	03 f1                	add    %ecx,%esi
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    13c6:	7e 08                	jle    13d0 <balancer_ingress+0x13d0>
    13c8:	12 05 22 06 03 90    	adc    -0x6ffcf9de(%rip),%al        # ffffffff900319f0 <server_id_map+0x36fc4f84d9f0>
    13ce:	01 4a 05             	add    %ecx,0x5(%rdx)
    13d1:	15 06 3c 05 2b       	adc    $0x2b053c06,%eax
    13d6:	74 05                	je     13dd <balancer_ingress+0x13dd>
    13d8:	10 06                	adc    %al,(%rsi)
    13da:	30 05 09 67 05 10    	xor    %al,0x10056709(%rip)        # 10057ae9 <_license+0x10055bf6>
  if (!connId) {
    13e0:	2d 06 03 ee 7e       	sub    $0x7eee0306,%eax
    13e5:	2e 05 0b 06 03 96    	cs add $0x9603060b,%eax
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    13eb:	01 9e 05 09 9f 05    	add    %ebx,0x59f0905(%rsi)
    13f1:	14 35                	adc    $0x35,%al
    13f3:	05 0b 3d 05 07       	add    $0x7053d0b,%eax
    13f8:	67 05 00 06 03 e0    	addr32 add $0xe0030600,%eax
    13fe:	7e 2e                	jle    142e <balancer_ingress+0x142e>
    1400:	05 01 06 03 c8       	add    $0xc8030601,%eax
    1405:	08 02                	or     %al,(%rdx)
    1407:	56                   	push   %rsi
    1408:	01 05 07 03 de 78    	add    %eax,0x78de0307(%rip)        # 78de1715 <_license+0x78ddf822>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    140e:	08 3c 05 0f 06 82 03 	or     %bh,0x382060f(,%rax,1)
    1415:	da 7e 2e             	fidivrl 0x2e(%rsi)
    1418:	05 24 03 a6 01       	add    $0x1a60324,%eax
    141d:	4a 05 34 74 03 da    	rex.WX add $0xffffffffda037434,%rax
    1423:	7e 58                	jle    147d <balancer_ingress+0x147d>
    1425:	05 1a 06 03 a7       	add    $0xa703061a,%eax
    142a:	01 58 05             	add    %ebx,0x5(%rax)
      if (qpr.server_id > 0) {
    142d:	09 06                	or     %eax,(%rsi)
    142f:	4a 05 19 06 2f 05    	rex.WX add $0x52f0619,%rax
    1435:	15 4c 05 05 08       	adc    $0x805054c,%eax
    143a:	83 05 0b 03 d4 06 4a 	addl   $0x4a,0x6d4030b(%rip)        # 6d4174c <_license+0x6d3f859>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1441:	06                   	(bad)
    1442:	03 81 78 4a 05 28    	add    0x28054a78(%rcx),%eax
    1448:	06                   	(bad)
    1449:	03 d5                	add    %ebp,%edx
    144b:	04 f2                	add    $0xf2,%al
    144d:	05 35 06 74 05       	add    $0x5740635,%eax
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1452:	36 06                	ss (bad)
    1454:	75 05                	jne    145b <balancer_ingress+0x145b>
    1456:	2f                   	(bad)
    1457:	06                   	(bad)
    1458:	66 05 00 03          	add    $0x300,%ax
    145c:	aa                   	stos   %al,%es:(%rdi)
    145d:	7b 66                	jnp    14c5 <balancer_ingress+0x14c5>
    145f:	05 22 06 03 d7       	add    $0xd7030622,%eax
  if (!connId) {
    1464:	04 66                	add    $0x66,%al
    1466:	05 0b ae 05 1c       	add    $0x1c05ae0b,%eax
    146b:	4b 06                	rex.WXB (bad)
  __u8 connIdVersion = (connId[0] >> 6);
    146d:	03 a6 7b 9e 03 da    	add    -0x25fc6185(%rsi),%esp
    1473:	04 ac                	add    $0xac,%al
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    1475:	05 0a 06 2f 05       	add    $0x52f060a,%eax
    147a:	09 06                	or     %eax,(%rsi)
    147c:	3c 05                	cmp    $0x5,%al
    147e:	14 06                	adc    $0x6,%al
    1480:	69 06 03 a2 7b 3c    	imul   $0x3c7ba203,(%rsi),%eax
    1486:	05 16 06 03 84       	add    $0x84030616,%eax
    148b:	08 02                	or     %al,(%rdx)
    148d:	23 01                	and    (%rcx),%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    148f:	05 00 06 03 fc       	add    $0xfc030600,%eax
    1494:	77 9e                	ja     1434 <balancer_ingress+0x1434>
    1496:	05 14 06 03 ef       	add    $0xef030614,%eax
    149b:	04 9e                	add    $0x9e,%al
    149d:	05 37 03 9e 02       	add    $0x29e0337,%eax
    14a2:	2e 05 13 5a 06 03    	cs add $0x3065a13,%eax
    14a8:	f1                   	int1
    14a9:	78 66                	js     1511 <balancer_ingress+0x1511>
    14ab:	05 07 06 03 80       	add    $0x80030607,%eax
    14b0:	05 3c 05 08 08       	add    $0x808053c,%eax
    14b5:	67 05 07 06 3c 05    	addr32 add $0x53c0607,%eax
    14bb:	17                   	(bad)
    14bc:	06                   	(bad)
    14bd:	35 05 19 03 af       	xor    $0xaf031905,%eax
    14c2:	7b 74                	jnp    1538 <balancer_ingress+0x1538>
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    14c4:	05 1d 9f 05 09       	add    $0x9059f1d,%eax
        if (real_pos) {
    14c9:	06                   	(bad)
    14ca:	66 05 17 06          	add    $0x617,%ax
    14ce:	03 bf 04 2e 05 1b    	add    0x1b052e04(%rdi),%edi
    14d4:	f3 05 13 06 3c 05    	repz add $0x53c0613,%eax
          key = *real_pos;
    14da:	03 06                	add    (%rsi),%eax
    14dc:	08 83 05 38 03 99    	or     %al,-0x66fcc7fb(%rbx)
            pckt.real_index = key;
    14e2:	02 4a 05             	add    0x5(%rdx),%cl
    14e5:	2c 5a                	sub    $0x5a,%al
            dst = bpf_map_lookup_elem(&reals, &key);
    14e7:	05 14 03 1b 58       	add    $0x581b0314,%eax
    14ec:	06                   	(bad)
    14ed:	03 d1                	add    %ecx,%edx
    14ef:	78 58                	js     1549 <balancer_ingress+0x1549>
    14f1:	05 09 06 03 28       	add    $0x28030609,%eax
    14f6:	58                   	pop    %rax
    14f7:	05 07 76 05 08       	add    $0x8057607,%eax
    14fc:	08 13                	or     %dl,(%rbx)
    14fe:	05 07 06 3c 05       	add    $0x53c0607,%eax
    1503:	00 03                	add    %al,(%rbx)
    1505:	55                   	push   %rbp
            if (!dst) {
    1506:	66 05 0f 06          	add    $0x60f,%ax
    150a:	03 2e                	add    (%rsi),%ebp
    150c:	9e                   	sahf
    150d:	05 12 32 05 29       	add    $0x29053212,%eax
    1512:	06                   	(bad)
    1513:	74 05                	je     151a <balancer_ingress+0x151a>
    1515:	07                   	(bad)
    1516:	74 05                	je     151d <balancer_ingress+0x151d>
    1518:	19 06                	sbb    %eax,(%rsi)
    151a:	30 75 05             	xor    %dh,0x5(%rbp)
    151d:	14 03                	adc    $0x3,%al
    151f:	ba 04 66 05 37       	mov    $0x37056604,%edx
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1524:	03 9e 02 2e 05 13    	add    0x13052e02(%rsi),%ebx
  if (dst_lru) {
    152a:	5a                   	pop    %rdx
    152b:	06                   	(bad)
    152c:	03 f1                	add    %ecx,%esi
    152e:	78 66                	js     1596 <balancer_ingress+0x1596>
    if (dst_lru->pos == pckt->real_index) {
    1530:	05 07 06 03 80       	add    $0x80030607,%eax
    1535:	05 3c 05 08 08       	add    $0x808053c,%eax
    153a:	67 05 07 06 3c 05    	addr32 add $0x53c0607,%eax
              quic_packets_stats->dst_match_in_lru += 1;
    1540:	17                   	(bad)
    1541:	06                   	(bad)
    1542:	35 05 19 03 af       	xor    $0xaf031905,%eax
    1547:	7b 74                	jnp    15bd <balancer_ingress+0x15bd>
    1549:	05 1d 9f 05 09       	add    $0x9059f1d,%eax
    154e:	06                   	(bad)
    154f:	66 05 17 06          	add    $0x617,%ax
    1553:	03 bf 04 2e 05 1b    	add    0x1b052e04(%rdi),%edi
    1559:	f3 05 13 06 3c 05    	repz add $0x53c0613,%eax
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    155f:	03 06                	add    (%rsi),%eax
    1561:	08 83 05 38 03 99    	or     %al,-0x66fcc7fb(%rbx)
    1567:	02 4a 05             	add    0x5(%rdx),%cl
    156a:	2c 5a                	sub    $0x5a,%al
    156c:	05 14 03 1b 58       	add    $0x581b0314,%eax
    1571:	06                   	(bad)
    1572:	03 d1                	add    %ecx,%edx
    1574:	78 4a                	js     15c0 <balancer_ingress+0x15c0>
    1576:	02 0b                	add    (%rbx),%cl
    1578:	00 01                	add    %al,(%rcx)
    157a:	01                   	.byte 0x1

Disassembly of section .debug_line_str:

0000000000000000 <.debug_line_str>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	2f                   	(bad)
   1:	72 6f                	jb     72 <balancer_ingress+0x72>
   3:	6f                   	outsl  %ds:(%rsi),(%dx)
   4:	74 2f                	je     35 <balancer_ingress+0x35>
   6:	57                   	push   %rdi
   7:	6f                   	outsl  %ds:(%rsi),(%dx)
   8:	72 6b                	jb     75 <balancer_ingress+0x75>
   a:	73 70                	jae    7c <balancer_ingress+0x7c>
   c:	61                   	(bad)
   d:	63 65 2f             	movsxd 0x2f(%rbp),%esp
  10:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  14:	61                   	(bad)
  15:	6e                   	outsb  %ds:(%rsi),(%dx)
  16:	2f                   	(bad)
  17:	5f                   	pop    %rdi
  void* data = (void*)(long)ctx->data;
  18:	62 75                	(bad)
  1a:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
  21:	73 
  if (data + nh_off > data_end) {
  22:	2f                   	(bad)
  23:	62                   	(bad)
  24:	70 66                	jo     8c <balancer_ingress+0x8c>
  26:	70 72                	jo     9a <balancer_ingress+0x9a>
  28:	6f                   	outsl  %ds:(%rsi),(%dx)
  29:	67 00 2e             	add    %ch,(%esi)
  2c:	2f                   	(bad)
  2d:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  31:	61                   	(bad)
  32:	6e                   	outsb  %ds:(%rsi),(%dx)
  33:	2f                   	(bad)
  eth_proto = eth->h_proto;
  34:	6c                   	insb   (%dx),%es:(%rdi)
  35:	69 62 2f 62 70 66 00 	imul   $0x667062,0x2f(%rdx),%esp
  if (eth_proto == BE_ETH_P_IP) {
  3c:	2f                   	(bad)
  3d:	75 73                	jne    b2 <balancer_ingress+0xb2>
  3f:	72 2f                	jb     70 <balancer_ingress+0x70>
  41:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  48:	2f                   	(bad)
  49:	61                   	(bad)
  4a:	73 6d                	jae    b9 <balancer_ingress+0xb9>
  4c:	2d 67 65 6e 65       	sub    $0x656e6567,%eax
  51:	72 69                	jb     bc <balancer_ingress+0xbc>
  53:	63 00                	movsxd (%rax),%eax
  struct packet_description pckt = {};
  55:	2f                   	(bad)
  56:	75 73                	jne    cb <balancer_ingress+0xcb>
  58:	72 2f                	jb     89 <balancer_ingress+0x89>
  5a:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  61:	2f                   	(bad)
  62:	6c                   	insb   (%dx),%es:(%rdi)
  63:	69 6e 75 78 00 2e 2f 	imul   $0x2f2e0078,0x75(%rsi),%ebp
  6a:	2e 68 65 61 64 65    	cs push $0x65646165
  70:	72 5f                	jb     d1 <balancer_ingress+0xd1>
  72:	6f                   	outsl  %ds:(%rsi),(%dx)
  73:	76 65                	jbe    da <balancer_ingress+0xda>
  75:	72 72                	jb     e9 <balancer_ingress+0xe9>
  77:	69 64 65 2f 36 2f 6b 	imul   $0x616b2f36,0x2f(%rbp,%riz,2),%esp
  7e:	61 
  7f:	74 72                	je     f3 <balancer_ingress+0xf3>
  81:	61                   	(bad)
  82:	6e                   	outsb  %ds:(%rsi),(%dx)
  83:	2f                   	(bad)
  struct vip_definition vip = {};
  84:	6c                   	insb   (%dx),%es:(%rdi)
  85:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
  8c:	78 5f                	js     ed <balancer_ingress+0xed>
  8e:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  95:	73 00                	jae    97 <balancer_ingress+0x97>
  97:	2e 2f                	cs (bad)
  99:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  9d:	61                   	(bad)
  9e:	6e                   	outsb  %ds:(%rsi),(%dx)
  9f:	2f                   	(bad)
  a0:	6c                   	insb   (%dx),%es:(%rdi)
  a1:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
    if (iph + 1 > data_end) {
  a8:	78 5f                	js     109 <balancer_ingress+0x109>
  aa:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
    if (iph->ihl != 5) {
  b1:	73 00                	jae    b3 <balancer_ingress+0xb3>
  b3:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  b7:	61                   	(bad)
  b8:	6e                   	outsb  %ds:(%rsi),(%dx)
  b9:	2f                   	(bad)
  ba:	6c                   	insb   (%dx),%es:(%rdi)
  bb:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
    pckt->tos = iph->tos;
  c2:	62 61 6c 61 6e       	(bad)
    *protocol = iph->protocol;
  c7:	63 65 72             	movsxd 0x72(%rbp),%esp
    pckt->flow.proto = *protocol;
  ca:	2e 62                	cs (bad)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  cc:	70 66                	jo     134 <balancer_ingress+0x134>
  ce:	2e 63 00             	cs movsxd (%rax),%eax
  d1:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
  d4:	74 72                	je     148 <balancer_ingress+0x148>
  d6:	6f                   	outsl  %ds:(%rsi),(%dx)
  d7:	6c                   	insb   (%dx),%es:(%rdi)
  d8:	5f                   	pop    %rdi
  d9:	64 61                	fs (bad)
  db:	74 61                	je     13e <balancer_ingress+0x13e>
  dd:	5f                   	pop    %rdi
  de:	6d                   	insl   (%dx),%es:(%rdi)
  df:	61                   	(bad)
    if (*protocol == IPPROTO_ICMP) {
  e0:	70 73                	jo     155 <balancer_ingress+0x155>
  e2:	2e 68 00 69 6e 74    	cs push $0x746e6900
  e8:	2d 6c 6c 36 34       	sub    $0x34366c6c,%eax
  if (icmp_hdr + 1 > data_end) {
  ed:	2e 68 00 62 61 6c    	cs push $0x6c616200
  f3:	61                   	(bad)
  f4:	6e                   	outsb  %ds:(%rsi),(%dx)
  f5:	63 65 72             	movsxd 0x72(%rbp),%esp
  if (icmp_hdr->type == ICMP_ECHO) {
  f8:	5f                   	pop    %rdi
  f9:	73 74                	jae    16f <balancer_ingress+0x16f>
  fb:	72 75                	jb     172 <balancer_ingress+0x172>
  fd:	63 74 73 2e          	movsxd 0x2e(%rbx,%rsi,2),%esi
 101:	68 00 62 61 6c       	push   $0x6c616200
 106:	61                   	(bad)
 107:	6e                   	outsb  %ds:(%rsi),(%dx)
 108:	63 65 72             	movsxd 0x72(%rbp),%esp
 10b:	5f                   	pop    %rdi
 10c:	6d                   	insl   (%dx),%es:(%rdi)
 10d:	61                   	(bad)
 10e:	70 73                	jo     183 <balancer_ingress+0x183>
 110:	2e 68 00 74 79 70    	cs push $0x70797400
  icmp_hdr->type = ICMP_ECHOREPLY;
 116:	65 73 2e             	gs jae 147 <balancer_ingress+0x147>
  icmp_hdr->checksum += 0x0008;
 119:	68 00 62 70 66       	push   $0x66706200
 11e:	5f                   	pop    %rdi
  iph->ttl = DEFAULT_TTL;
 11f:	68 65 6c 70 65       	push   $0x65706c65
  iph->daddr = iph->saddr;
 124:	72 73                	jb     199 <balancer_ingress+0x199>
 126:	2e 68 00 62 70 66    	cs push $0x66706200
 12c:	2e 68 00 69 6e 2e    	cs push $0x2e6e6900
  iph->saddr = tmp_addr;
 132:	68 00 70 63 6b       	push   $0x6b637000
 137:	74 5f                	je     198 <balancer_ingress+0x198>
 139:	70 61                	jo     19c <balancer_ingress+0x19c>
 13b:	72 73                	jb     1b0 <balancer_ingress+0x1b0>
 13d:	69 6e 67 2e 68 00 6a 	imul   $0x6a00682e,0x67(%rsi),%ebp
 144:	68 61 73 68 2e       	push   $0x2e687361
 149:	68 00 68 61 6e       	push   $0x6e616800
 14e:	64 6c                	fs insb (%dx),%es:(%rdi)
 150:	65 5f                	gs pop %rdi
 152:	69 63 6d 70 2e 68 00 	imul   $0x682e70,0x6d(%rbx),%esp
 159:	63 73 75             	movsxd 0x75(%rbx),%esi
 15c:	6d                   	insl   (%dx),%es:(%rdi)
 15d:	5f                   	pop    %rdi
 15e:	68 65 6c 70 65       	push   $0x65706c65
 163:	72 73                	jb     1d8 <balancer_ingress+0x1d8>
 165:	2e 68 00 70 63 6b    	cs push $0x6b637000
    if (csum >> 16)
 16b:	74 5f                	je     1cc <balancer_ingress+0x1cc>
 16d:	65 6e                	outsb  %gs:(%rsi),(%dx)
 16f:	63 61 70             	movsxd 0x70(%rcx),%esp
 172:	2e 68 00 65 6e 63    	cs push $0x636e6500
 178:	61                   	(bad)
 179:	70 5f                	jo     1da <balancer_ingress+0x1da>
 17b:	68 65 6c 70 65       	push   $0x65706c65
 180:	72 73                	jb     1f5 <balancer_ingress+0x1f5>
 182:	2e 68 00 69 70 2e    	cs push $0x2e706900
  struct packet_description pckt = {};
 188:	68 00 69 70 76       	push   $0x76706900
 18d:	36 2e 68 00 69 6e 36 	ss cs push $0x366e6900
 194:	2e 68 00 69 63 6d    	cs push $0x6d636900
 19a:	70 76                	jo     212 <balancer_ingress+0x212>
 19c:	36 2e 68 00 74 63 70 	ss cs push $0x70637400
 1a3:	2e 68 00 75 64 70    	cs push $0x70647500
 1a9:	2e 68 00 69 66 5f    	cs push $0x5f666900
 1af:	65 74 68             	gs je  21a <balancer_ingress+0x21a>
 1b2:	65 72 2e             	gs jb  1e3 <balancer_ingress+0x1e3>
 1b5:	68                   	.byte 0x68
	...
