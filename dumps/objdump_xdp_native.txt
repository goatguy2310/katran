
_build/deps/bpfprog/bpf/native/balancer.bpf:     file format elf64-x86-64


Disassembly of section xdp:

0000000000000000 <balancer_ingress>:
  return XDP_TX;
}

SEC(PROG_SEC_NAME)
int balancer_ingress(struct xdp_md* ctx) {
  void* data = (void*)(long)ctx->data;
       0:	f3 0f 1e fa          	endbr64
       4:	55                   	push   %rbp
       5:	41 57                	push   %r15
       7:	41 56                	push   %r14
       9:	41 55                	push   %r13
       b:	41 54                	push   %r12
       d:	53                   	push   %rbx
       e:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
      15:	48 8b 1f             	mov    (%rdi),%rbx
  void* data_end = (void*)(long)ctx->data_end;
      18:	4c 8b 7f 08          	mov    0x8(%rdi),%r15
  struct ethhdr* eth = data;
  __u32 eth_proto;
  __u32 nh_off;
  nh_off = sizeof(struct ethhdr);

  if (data + nh_off > data_end) {
      1c:	48 8d 43 0e          	lea    0xe(%rbx),%rax
      20:	bd 01 00 00 00       	mov    $0x1,%ebp
      25:	4c 39 f8             	cmp    %r15,%rax
      28:	0f 87 ad 1b 00 00    	ja     1bdb <balancer_ingress+0x1bdb>
      2e:	49 89 fd             	mov    %rdi,%r13
    // bogus packet, len less than minimum ethernet frame size
    return XDP_DROP;
  }

  eth_proto = eth->h_proto;
      31:	0f b7 4b 0c          	movzwl 0xc(%rbx),%ecx

  if (eth_proto == BE_ETH_P_IP) {
      35:	81 f9 86 dd 00 00    	cmp    $0xdd86,%ecx
      3b:	74 68                	je     a5 <balancer_ingress+0xa5>
      3d:	bd 02 00 00 00       	mov    $0x2,%ebp
      42:	66 83 f9 08          	cmp    $0x8,%cx
      46:	0f 85 8f 1b 00 00    	jne    1bdb <balancer_ingress+0x1bdb>
  struct packet_description pckt = {};
      4c:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
      53:	00 00 
      55:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
      5c:	00 00 
      5e:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
      65:	00 00 
      67:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
      6e:	00 00 
      70:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
      77:	00 00 
      79:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
      80:	00 00 
      82:	48 b9 00 a4 b4 07 01 	movabs $0xff11000107b4a400,%rcx
      89:	00 11 ff 
  bpf_tail_call(xdp, &subprograms, 0);
      8c:	48 8b 89 00 01 00 00 	mov    0x100(%rcx),%rcx
      93:	48 85 c9             	test   %rcx,%rcx
      96:	74 6a                	je     102 <balancer_ingress+0x102>
      98:	4c 89 ef             	mov    %r13,%rdi
      9b:	ff 51 30             	call   *0x30(%rcx)
      9e:	89 c5                	mov    %eax,%ebp
      a0:	e9 36 1b 00 00       	jmp    1bdb <balancer_ingress+0x1bdb>
  struct packet_description pckt = {};
      a5:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
      ac:	00 00 
      ae:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
      b5:	00 00 
      b7:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
      be:	00 00 
      c0:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
      c7:	00 00 
      c9:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
      d0:	00 00 
      d2:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
      d9:	00 00 
      db:	48 b8 00 a4 b4 07 01 	movabs $0xff11000107b4a400,%rax
      e2:	00 11 ff 
  bpf_tail_call(xdp, &subprograms, 0);
      e5:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
      ec:	48 85 c0             	test   %rax,%rax
      ef:	0f 84 e7 00 00 00    	je     1dc <balancer_ingress+0x1dc>
      f5:	4c 89 ef             	mov    %r13,%rdi
      f8:	ff 50 30             	call   *0x30(%rax)
      fb:	89 c5                	mov    %eax,%ebp
      fd:	e9 d9 1a 00 00       	jmp    1bdb <balancer_ingress+0x1bdb>
  struct vip_definition vip = {};
     102:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%rsp)
     109:	00 
     10a:	48 c7 44 24 70 00 00 	movq   $0x0,0x70(%rsp)
     111:	00 00 
     113:	48 c7 44 24 68 00 00 	movq   $0x0,0x68(%rsp)
     11a:	00 00 
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
    }
  } else {
    iph = data + nh_off;
    if (iph + 1 > data_end) {
     11c:	4c 8d 63 22          	lea    0x22(%rbx),%r12
     120:	4d 39 fc             	cmp    %r15,%r12
     123:	0f 87 ad 1a 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
      return XDP_DROP;
    }
    // ihl contains len of ipv4 header in 32bit words
    if (iph->ihl != 5) {
     129:	8a 00                	mov    (%rax),%al
     12b:	24 0f                	and    $0xf,%al
     12d:	3c 05                	cmp    $0x5,%al
     12f:	0f 85 a1 1a 00 00    	jne    1bd6 <balancer_ingress+0x1bd6>
      // if len of ipv4 hdr is not equal to 20bytes that means that header
      // contains ip options, and we dont support em
      return XDP_DROP;
    }
    pckt->tos = iph->tos;
     135:	8a 43 0f             	mov    0xf(%rbx),%al
     138:	88 44 24 35          	mov    %al,0x35(%rsp)
    *protocol = iph->protocol;
     13c:	8a 43 17             	mov    0x17(%rbx),%al
    pckt->flow.proto = *protocol;
     13f:	88 44 24 2c          	mov    %al,0x2c(%rsp)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;

    if (iph->frag_off & PCKT_FRAGMENTED) {
     143:	0f b7 4b 14          	movzwl 0x14(%rbx),%ecx
     147:	f7 c1 3f ff 00 00    	test   $0xff3f,%ecx
     14d:	0f 85 83 1a 00 00    	jne    1bd6 <balancer_ingress+0x1bd6>
     153:	0f b7 7b 10          	movzwl 0x10(%rbx),%edi
      // we drop fragmented packets.
      return XDP_DROP;
    }
    if (*protocol == IPPROTO_ICMP) {
     157:	3c 01                	cmp    $0x1,%al
     159:	0f 85 1c 03 00 00    	jne    47b <balancer_ingress+0x47b>
    __u64 off,
    struct packet_description* pckt) {
  struct icmphdr* icmp_hdr;
  struct iphdr* iph;
  icmp_hdr = data + off;
  if (icmp_hdr + 1 > data_end) {
     15f:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
     163:	4c 39 f8             	cmp    %r15,%rax
     166:	0f 87 6a 1a 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    return XDP_DROP;
  }
  if (icmp_hdr->type == ICMP_ECHO) {
     16c:	41 8a 14 24          	mov    (%r12),%dl
     170:	80 fa 03             	cmp    $0x3,%dl
     173:	0f 84 8b 06 00 00    	je     804 <balancer_ingress+0x804>
     179:	bd 02 00 00 00       	mov    $0x2,%ebp
     17e:	80 fa 08             	cmp    $0x8,%dl
     181:	0f 85 54 1a 00 00    	jne    1bdb <balancer_ingress+0x1bdb>
     187:	44 0f b7 c7          	movzwl %di,%r8d
  icmp_hdr->type = ICMP_ECHOREPLY;
     18b:	c6 43 22 00          	movb   $0x0,0x22(%rbx)
  icmp_hdr->checksum += 0x0008;
     18f:	66 83 43 24 08       	addw   $0x8,0x24(%rbx)
  iph->ttl = DEFAULT_TTL;
     194:	c6 43 16 40          	movb   $0x40,0x16(%rbx)
  iph->daddr = iph->saddr;
     198:	8b 43 1a             	mov    0x1a(%rbx),%eax
  tmp_addr = iph->daddr;
     19b:	8b 73 1e             	mov    0x1e(%rbx),%esi
  iph->daddr = iph->saddr;
     19e:	89 43 1e             	mov    %eax,0x1e(%rbx)
  iph->saddr = tmp_addr;
     1a1:	89 73 1a             	mov    %esi,0x1a(%rbx)
    void* iph,
    __u64* csum) {
  __u16* next_iph_u16 = (__u16*)iph;
#pragma clang loop unroll(full)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    *csum += *next_iph_u16++;
     1a4:	0f b7 7b 0e          	movzwl 0xe(%rbx),%edi
     1a8:	0f b7 6b 12          	movzwl 0x12(%rbx),%ebp
     1ac:	44 0f b7 4b 16       	movzwl 0x16(%rbx),%r9d
     1b1:	0f b7 d6             	movzwl %si,%edx
     1b4:	48 c1 ee 10          	shr    $0x10,%rsi
     1b8:	48 01 d6             	add    %rdx,%rsi
     1bb:	0f b7 d0             	movzwl %ax,%edx
     1be:	48 01 f2             	add    %rsi,%rdx
     1c1:	48 c1 e8 10          	shr    $0x10,%rax
     1c5:	48 01 d0             	add    %rdx,%rax
     1c8:	48 01 f8             	add    %rdi,%rax
     1cb:	4c 01 c0             	add    %r8,%rax
     1ce:	48 01 e8             	add    %rbp,%rax
     1d1:	48 01 c8             	add    %rcx,%rax
     1d4:	4c 01 c8             	add    %r9,%rax
     1d7:	e9 bb 01 00 00       	jmp    397 <balancer_ingress+0x397>
     1dc:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%rsp)
     1e3:	00 
     1e4:	48 c7 44 24 70 00 00 	movq   $0x0,0x70(%rsp)
     1eb:	00 00 
     1ed:	48 c7 44 24 68 00 00 	movq   $0x0,0x68(%rsp)
     1f4:	00 00 
    if (ip6h + 1 > data_end) {
     1f6:	4c 8d 63 36          	lea    0x36(%rbx),%r12
     1fa:	4d 39 fc             	cmp    %r15,%r12
     1fd:	0f 87 d3 19 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    *protocol = ip6h->nexthdr;
     203:	8a 43 14             	mov    0x14(%rbx),%al
    pckt->flow.proto = *protocol;
     206:	88 44 24 2c          	mov    %al,0x2c(%rsp)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     20a:	8a 4b 0e             	mov    0xe(%rbx),%cl
     20d:	c0 e1 04             	shl    $0x4,%cl
     210:	88 4c 24 35          	mov    %cl,0x35(%rsp)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     214:	8a 53 0f             	mov    0xf(%rbx),%dl
     217:	c0 ea 04             	shr    $0x4,%dl
     21a:	08 ca                	or     %cl,%dl
     21c:	88 54 24 35          	mov    %dl,0x35(%rsp)
    if (*protocol == IPPROTO_FRAGMENT) {
     220:	3c 2c                	cmp    $0x2c,%al
     222:	0f 84 ae 19 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
     228:	0f b7 7b 12          	movzwl 0x12(%rbx),%edi
     22c:	3c 3a                	cmp    $0x3a,%al
     22e:	0f 85 a8 00 00 00    	jne    2dc <balancer_ingress+0x2dc>
  if (icmp_hdr + 1 > data_end) {
     234:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     238:	4c 39 f8             	cmp    %r15,%rax
     23b:	0f 87 95 19 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     241:	41 8a 04 24          	mov    (%r12),%al
     245:	3c 02                	cmp    $0x2,%al
     247:	0f 84 d0 02 00 00    	je     51d <balancer_ingress+0x51d>
     24d:	3c 01                	cmp    $0x1,%al
     24f:	0f 84 01 03 00 00    	je     556 <balancer_ingress+0x556>
     255:	bd 02 00 00 00       	mov    $0x2,%ebp
     25a:	3c 80                	cmp    $0x80,%al
     25c:	0f 85 79 19 00 00    	jne    1bdb <balancer_ingress+0x1bdb>
     262:	c6 43 36 81          	movb   $0x81,0x36(%rbx)
     266:	66 83 43 38 ff       	addw   $0xffff,0x38(%rbx)
     26b:	c6 43 15 40          	movb   $0x40,0x15(%rbx)
     26f:	48 8b 43 16          	mov    0x16(%rbx),%rax
     273:	48 8b 4b 1e          	mov    0x1e(%rbx),%rcx
     277:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     27c:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
     281:	48 8b 43 26          	mov    0x26(%rbx),%rax
     285:	48 8b 4b 2e          	mov    0x2e(%rbx),%rcx
     289:	48 89 43 16          	mov    %rax,0x16(%rbx)
     28d:	48 89 4b 1e          	mov    %rcx,0x1e(%rbx)
     291:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
     296:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
     29b:	48 89 43 26          	mov    %rax,0x26(%rbx)
     29f:	48 89 4b 2e          	mov    %rcx,0x2e(%rbx)
     2a3:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     2a7:	66 89 84 24 84 00 00 	mov    %ax,0x84(%rsp)
     2ae:	00 
     2af:	8b 43 06             	mov    0x6(%rbx),%eax
     2b2:	89 84 24 80 00 00 00 	mov    %eax,0x80(%rsp)
     2b9:	8b 03                	mov    (%rbx),%eax
     2bb:	89 43 06             	mov    %eax,0x6(%rbx)
     2be:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     2c2:	66 89 43 0a          	mov    %ax,0xa(%rbx)
     2c6:	8b 84 24 80 00 00 00 	mov    0x80(%rsp),%eax
     2cd:	89 03                	mov    %eax,(%rbx)
     2cf:	0f b7 84 24 84 00 00 	movzwl 0x84(%rsp),%eax
     2d6:	00 
     2d7:	e9 46 01 00 00       	jmp    422 <balancer_ingress+0x422>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     2dc:	48 8b 4b 16          	mov    0x16(%rbx),%rcx
     2e0:	48 8b 53 1e          	mov    0x1e(%rbx),%rdx
     2e4:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
     2e9:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2ee:	48 8b 4b 26          	mov    0x26(%rbx),%rcx
     2f2:	48 8b 53 2e          	mov    0x2e(%rbx),%rdx
     2f6:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
     2fb:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
    void* data,
    void* data_end,
    __u64 off,
    struct packet_description* pckt,
    __u8 protocol) {
  if (protocol == IPPROTO_ICMPV6) {
     300:	3c 01                	cmp    $0x1,%al
     302:	0f 85 28 01 00 00    	jne    430 <balancer_ingress+0x430>
  if (icmp_hdr + 1 > data_end) {
     308:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     30c:	4c 39 f8             	cmp    %r15,%rax
     30f:	0f 87 c1 18 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
  if (icmp_hdr->type == ICMP_ECHO) {
     315:	41 8a 0c 24          	mov    (%r12),%cl
     319:	80 f9 03             	cmp    $0x3,%cl
     31c:	0f 84 7c 03 00 00    	je     69e <balancer_ingress+0x69e>
     322:	bd 02 00 00 00       	mov    $0x2,%ebp
     327:	80 f9 08             	cmp    $0x8,%cl
     32a:	0f 85 ab 18 00 00    	jne    1bdb <balancer_ingress+0x1bdb>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     330:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
     334:	bd 01 00 00 00       	mov    $0x1,%ebp
       sizeof(struct icmphdr)) > data_end) {
     339:	4c 39 f8             	cmp    %r15,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     33c:	0f 87 99 18 00 00    	ja     1bdb <balancer_ingress+0x1bdb>
  icmp_hdr->type = ICMP_ECHOREPLY;
     342:	c6 43 22 00          	movb   $0x0,0x22(%rbx)
  icmp_hdr->checksum += 0x0008;
     346:	66 83 43 24 08       	addw   $0x8,0x24(%rbx)
  iph->ttl = DEFAULT_TTL;
     34b:	c6 43 16 40          	movb   $0x40,0x16(%rbx)
  iph->daddr = iph->saddr;
     34f:	8b 43 1a             	mov    0x1a(%rbx),%eax
  tmp_addr = iph->daddr;
     352:	8b 4b 1e             	mov    0x1e(%rbx),%ecx
  iph->daddr = iph->saddr;
     355:	89 43 1e             	mov    %eax,0x1e(%rbx)
  iph->saddr = tmp_addr;
     358:	89 4b 1a             	mov    %ecx,0x1a(%rbx)
     35b:	44 0f b7 4b 0e       	movzwl 0xe(%rbx),%r9d
     360:	0f b7 73 10          	movzwl 0x10(%rbx),%esi
     364:	0f b7 7b 12          	movzwl 0x12(%rbx),%edi
     368:	0f b7 6b 14          	movzwl 0x14(%rbx),%ebp
     36c:	44 0f b7 43 16       	movzwl 0x16(%rbx),%r8d
     371:	0f b7 d1             	movzwl %cx,%edx
     374:	48 c1 e9 10          	shr    $0x10,%rcx
     378:	48 01 d1             	add    %rdx,%rcx
     37b:	0f b7 d0             	movzwl %ax,%edx
     37e:	48 01 ca             	add    %rcx,%rdx
     381:	48 c1 e8 10          	shr    $0x10,%rax
     385:	48 01 d0             	add    %rdx,%rax
     388:	4c 01 c8             	add    %r9,%rax
     38b:	48 01 f0             	add    %rsi,%rax
     38e:	48 01 f8             	add    %rdi,%rax
     391:	48 01 e8             	add    %rbp,%rax
     394:	4c 01 c0             	add    %r8,%rax
     397:	48 89 c1             	mov    %rax,%rcx
     39a:	48 c1 e9 10          	shr    $0x10,%rcx
     39e:	0f b7 d0             	movzwl %ax,%edx
     3a1:	48 01 ca             	add    %rcx,%rdx
     3a4:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
     3aa:	48 0f 42 d0          	cmovb  %rax,%rdx
     3ae:	48 89 d0             	mov    %rdx,%rax
     3b1:	48 c1 e8 10          	shr    $0x10,%rax
     3b5:	0f b7 ca             	movzwl %dx,%ecx
     3b8:	48 01 c1             	add    %rax,%rcx
     3bb:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     3c2:	48 0f 42 ca          	cmovb  %rdx,%rcx
     3c6:	48 89 c8             	mov    %rcx,%rax
     3c9:	48 c1 e8 10          	shr    $0x10,%rax
     3cd:	0f b7 d1             	movzwl %cx,%edx
     3d0:	48 01 c2             	add    %rax,%rdx
     3d3:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
     3da:	48 0f 42 d1          	cmovb  %rcx,%rdx
     3de:	89 d0                	mov    %edx,%eax
     3e0:	c1 e8 10             	shr    $0x10,%eax
     3e3:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     3ea:	b9 00 00 01 00       	mov    $0x10000,%ecx
     3ef:	0f 43 c8             	cmovae %eax,%ecx
     3f2:	01 d1                	add    %edx,%ecx
     3f4:	f7 d1                	not    %ecx
     3f6:	66 89 4b 18          	mov    %cx,0x18(%rbx)
     3fa:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     3fe:	66 89 44 24 44       	mov    %ax,0x44(%rsp)
     403:	8b 43 06             	mov    0x6(%rbx),%eax
     406:	89 44 24 40          	mov    %eax,0x40(%rsp)
     40a:	8b 03                	mov    (%rbx),%eax
     40c:	89 43 06             	mov    %eax,0x6(%rbx)
     40f:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     413:	66 89 43 0a          	mov    %ax,0xa(%rbx)
     417:	8b 44 24 40          	mov    0x40(%rsp),%eax
     41b:	89 03                	mov    %eax,(%rbx)
     41d:	0f b7 44 24 44       	movzwl 0x44(%rsp),%eax
     422:	66 89 43 04          	mov    %ax,0x4(%rbx)
     426:	bd 03 00 00 00       	mov    $0x3,%ebp
     42b:	e9 ab 17 00 00       	jmp    1bdb <balancer_ingress+0x1bdb>
     430:	b2 02                	mov    $0x2,%dl
     432:	b1 01                	mov    $0x1,%cl
     434:	bd 02 00 00 00       	mov    $0x2,%ebp
  if (protocol == IPPROTO_IPIP) {
     439:	3c 10                	cmp    $0x10,%al
     43b:	0f 8f 63 01 00 00    	jg     5a4 <balancer_ingress+0x5a4>
     441:	3c 04                	cmp    $0x4,%al
     443:	0f 84 c5 01 00 00    	je     60e <balancer_ingress+0x60e>
     449:	3c 06                	cmp    $0x6,%al
     44b:	0f 85 8a 17 00 00    	jne    1bdb <balancer_ingress+0x1bdb>
  tcp = data + off;
     451:	48 8d 43 66          	lea    0x66(%rbx),%rax
  if (is_ipv6) {
     455:	84 c9                	test   %cl,%cl
  tcp = data + off;
     457:	49 0f 45 c4          	cmovne %r12,%rax
  if (tcp + 1 > data_end) {
     45b:	48 8d 70 14          	lea    0x14(%rax),%rsi
     45f:	4c 39 fe             	cmp    %r15,%rsi
     462:	0f 87 6e 17 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
  if (tcp->syn) {
     468:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     46c:	0f 84 0d 02 00 00    	je     67f <balancer_ingress+0x67f>
    pckt->flags |= F_SYN_SET;
     472:	88 54 24 34          	mov    %dl,0x34(%rsp)
     476:	e9 04 02 00 00       	jmp    67f <balancer_ingress+0x67f>
      return FURTHER_PROCESSING;
    } else {
      pckt->flow.src = iph->saddr;
     47b:	8b 4b 1a             	mov    0x1a(%rbx),%ecx
     47e:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
      pckt->flow.dst = iph->daddr;
     482:	8b 4b 1e             	mov    0x1e(%rbx),%ecx
     485:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
  if (protocol == IPPROTO_ICMPV6) {
     489:	3c 3a                	cmp    $0x3a,%al
     48b:	75 45                	jne    4d2 <balancer_ingress+0x4d2>
  if (icmp_hdr + 1 > data_end) {
     48d:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
     491:	4c 39 f8             	cmp    %r15,%rax
     494:	0f 87 3c 17 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     49a:	41 8a 04 24          	mov    (%r12),%al
     49e:	3c 02                	cmp    $0x2,%al
     4a0:	0f 84 63 04 00 00    	je     909 <balancer_ingress+0x909>
     4a6:	3c 01                	cmp    $0x1,%al
     4a8:	0f 84 94 04 00 00    	je     942 <balancer_ingress+0x942>
     4ae:	bd 02 00 00 00       	mov    $0x2,%ebp
     4b3:	3c 80                	cmp    $0x80,%al
     4b5:	0f 85 20 17 00 00    	jne    1bdb <balancer_ingress+0x1bdb>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4bb:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     4bf:	bd 01 00 00 00       	mov    $0x1,%ebp
       sizeof(struct icmp6hdr)) > data_end) {
     4c4:	4c 39 f8             	cmp    %r15,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4c7:	0f 87 0e 17 00 00    	ja     1bdb <balancer_ingress+0x1bdb>
     4cd:	e9 90 fd ff ff       	jmp    262 <balancer_ingress+0x262>
     4d2:	b2 02                	mov    $0x2,%dl
     4d4:	b1 01                	mov    $0x1,%cl
     4d6:	bd 02 00 00 00       	mov    $0x2,%ebp
     4db:	3c 10                	cmp    $0x10,%al
     4dd:	0f 8f af 04 00 00    	jg     992 <balancer_ingress+0x992>
     4e3:	3c 04                	cmp    $0x4,%al
     4e5:	0f 84 bf 03 00 00    	je     8aa <balancer_ingress+0x8aa>
     4eb:	3c 06                	cmp    $0x6,%al
     4ed:	0f 85 e8 16 00 00    	jne    1bdb <balancer_ingress+0x1bdb>
  tcp = data + off;
     4f3:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
  if (is_ipv6) {
     4f7:	84 c9                	test   %cl,%cl
  tcp = data + off;
     4f9:	49 0f 45 c4          	cmovne %r12,%rax
  if (tcp + 1 > data_end) {
     4fd:	48 8d 70 14          	lea    0x14(%rax),%rsi
     501:	4c 39 fe             	cmp    %r15,%rsi
     504:	0f 87 cc 16 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
  if (tcp->syn) {
     50a:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     50e:	0f 84 04 05 00 00    	je     a18 <balancer_ingress+0xa18>
    pckt->flags |= F_SYN_SET;
     514:	88 54 24 34          	mov    %dl,0x34(%rsp)
     518:	e9 fb 04 00 00       	jmp    a18 <balancer_ingress+0xa18>
     51d:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     524:	00 11 ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     527:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     52e:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     535:	39 a4 
    if (!icmp_ptb_v6_stats) {
     537:	48 85 c0             	test   %rax,%rax
     53a:	0f 84 96 16 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
    icmp_ptb_v6_stats->v1 += 1;
     540:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     544:	8b 4b 3a             	mov    0x3a(%rbx),%ecx
     547:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     549:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     54f:	77 05                	ja     556 <balancer_ingress+0x556>
      icmp_ptb_v6_stats->v2 += 1;
     551:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     556:	48 8d 43 66          	lea    0x66(%rbx),%rax
     55a:	4c 39 f8             	cmp    %r15,%rax
     55d:	0f 87 73 16 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
  pckt->flow.proto = ip6h->nexthdr;
     563:	8a 43 44             	mov    0x44(%rbx),%al
     566:	88 44 24 2c          	mov    %al,0x2c(%rsp)
  pckt->flags |= F_ICMP;
     56a:	c6 44 24 34 01       	movb   $0x1,0x34(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     56f:	48 8b 4b 56          	mov    0x56(%rbx),%rcx
     573:	48 8b 53 5e          	mov    0x5e(%rbx),%rdx
     577:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
     57c:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     581:	48 8b 4b 46          	mov    0x46(%rbx),%rcx
     585:	48 8b 53 4e          	mov    0x4e(%rbx),%rdx
     589:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
     58e:	48 89 54 24 20       	mov    %rdx,0x20(%rsp)
     593:	b2 03                	mov    $0x3,%dl
     595:	31 c9                	xor    %ecx,%ecx
     597:	bd 02 00 00 00       	mov    $0x2,%ebp
     59c:	3c 10                	cmp    $0x10,%al
     59e:	0f 8e 9d fe ff ff    	jle    441 <balancer_ingress+0x441>
     5a4:	3c 11                	cmp    $0x11,%al
     5a6:	0f 84 bc 00 00 00    	je     668 <balancer_ingress+0x668>
     5ac:	3c 29                	cmp    $0x29,%al
     5ae:	0f 85 27 16 00 00    	jne    1bdb <balancer_ingress+0x1bdb>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     5b4:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
     5b9:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
     5be:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     5c3:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
#define BPF_MAP_OPS_INLINE(name, pref, ret_type, decl_args, type_args, func_params)	\
	__attribute__((__always_inline__)) static inline ret_type pref##bpf_##name decl_args {	\
		return ((ret_type (*) type_args) (access_ptr_at_u64(access_ptr_at_u64(map, BPF_MAP_OPS_OFF), name##_off))) func_params;	\
	}

BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
     5c8:	48 bf 00 e0 f2 a3 01 	movabs $0xff110001a3f2e000,%rdi
     5cf:	00 11 ff 
     5d2:	48 8b 07             	mov    (%rdi),%rax
     5d5:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     5da:	ff 50 60             	call   *0x60(%rax)
  if (decap_dst_flags) {
     5dd:	48 85 c0             	test   %rax,%rax
     5e0:	0f 84 f5 15 00 00    	je     1bdb <balancer_ingress+0x1bdb>
     5e6:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     5ed:	00 11 ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     5f0:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     5f7:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     5fe:	39 a4 
    if (!data_stats) {
     600:	48 85 c0             	test   %rax,%rax
     603:	0f 85 ef 03 00 00    	jne    9f8 <balancer_ingress+0x9f8>
     609:	e9 cd 15 00 00       	jmp    1bdb <balancer_ingress+0x1bdb>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     60e:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
     613:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
     618:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     61d:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
     622:	48 bf 00 e0 f2 a3 01 	movabs $0xff110001a3f2e000,%rdi
     629:	00 11 ff 
     62c:	48 8b 07             	mov    (%rdi),%rax
     62f:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     634:	ff 50 60             	call   *0x60(%rax)
  if (decap_dst_flags) {
     637:	48 85 c0             	test   %rax,%rax
     63a:	0f 84 9b 15 00 00    	je     1bdb <balancer_ingress+0x1bdb>
     640:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     647:	00 11 ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     64a:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     651:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     658:	39 a4 
    if (!data_stats) {
     65a:	48 85 c0             	test   %rax,%rax
     65d:	0f 85 95 03 00 00    	jne    9f8 <balancer_ingress+0x9f8>
     663:	e9 73 15 00 00       	jmp    1bdb <balancer_ingress+0x1bdb>
  udp = data + off;
     668:	48 8d 43 66          	lea    0x66(%rbx),%rax
  if (is_ipv6) {
     66c:	84 c9                	test   %cl,%cl
  udp = data + off;
     66e:	49 0f 45 c4          	cmovne %r12,%rax
  if (udp + 1 > data_end) {
     672:	48 8d 50 08          	lea    0x8(%rax),%rdx
     676:	4c 39 fa             	cmp    %r15,%rdx
     679:	0f 87 57 15 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
     67f:	84 c9                	test   %cl,%cl
     681:	89 7c 24 5c          	mov    %edi,0x5c(%rsp)
     685:	0f 84 83 00 00 00    	je     70e <balancer_ingress+0x70e>
     68b:	0f b7 10             	movzwl (%rax),%edx
     68e:	48 8d 4c 24 28       	lea    0x28(%rsp),%rcx
     693:	66 89 54 24 28       	mov    %dx,0x28(%rsp)
     698:	48 83 c0 02          	add    $0x2,%rax
     69c:	eb 7e                	jmp    71c <balancer_ingress+0x71c>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     69e:	80 7b 37 04          	cmpb   $0x4,0x37(%rbx)
     6a2:	75 32                	jne    6d6 <balancer_ingress+0x6d6>
     6a4:	48 b9 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rcx
     6ab:	00 11 ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     6ae:	48 8b 89 68 11 00 00 	mov    0x1168(%rcx),%rcx
     6b5:	65 48 03 0c 25 28 10 	add    %gs:0xffffffffa4391028,%rcx
     6bc:	39 a4 
    if (!icmp_ptb_v4_stats) {
     6be:	48 85 c9             	test   %rcx,%rcx
     6c1:	0f 84 0f 15 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
    icmp_ptb_v4_stats->v1 += 1;
     6c7:	48 83 01 01          	addq   $0x1,(%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     6cb:	80 7b 3c 04          	cmpb   $0x4,0x3c(%rbx)
     6cf:	77 05                	ja     6d6 <balancer_ingress+0x6d6>
      icmp_ptb_v4_stats->v2 += 1;
     6d1:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (iph + 1 > data_end) {
     6d6:	48 8d 4b 52          	lea    0x52(%rbx),%rcx
     6da:	4c 39 f9             	cmp    %r15,%rcx
     6dd:	0f 87 f3 14 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
  if (iph->ihl != 5) {
     6e3:	8a 00                	mov    (%rax),%al
     6e5:	24 0f                	and    $0xf,%al
     6e7:	3c 05                	cmp    $0x5,%al
     6e9:	0f 85 e7 14 00 00    	jne    1bd6 <balancer_ingress+0x1bd6>
  pckt->flow.proto = iph->protocol;
     6ef:	8a 43 47             	mov    0x47(%rbx),%al
     6f2:	88 44 24 2c          	mov    %al,0x2c(%rsp)
  pckt->flags |= F_ICMP;
     6f6:	c6 44 24 34 01       	movb   $0x1,0x34(%rsp)
  pckt->flow.src = iph->daddr;
     6fb:	8b 4b 4e             	mov    0x4e(%rbx),%ecx
     6fe:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
  pckt->flow.dst = iph->saddr;
     702:	8b 4b 4a             	mov    0x4a(%rbx),%ecx
     705:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
     709:	e9 85 fe ff ff       	jmp    593 <balancer_ingress+0x593>
     70e:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     712:	48 8d 4c 24 28       	lea    0x28(%rsp),%rcx
     717:	66 89 54 24 28       	mov    %dx,0x28(%rsp)
     71c:	0f b7 00             	movzwl (%rax),%eax
     71f:	66 89 41 02          	mov    %ax,0x2(%rcx)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     723:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
     728:	48 8b 4c 24 20       	mov    0x20(%rsp),%rcx
     72d:	48 89 4c 24 70       	mov    %rcx,0x70(%rsp)
     732:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
  vip.port = pckt.flow.port16[1];
     737:	0f b7 44 24 2a       	movzwl 0x2a(%rsp),%eax
     73c:	66 89 44 24 78       	mov    %ax,0x78(%rsp)
  vip.proto = pckt.flow.proto;
     741:	8a 44 24 2c          	mov    0x2c(%rsp),%al
     745:	88 44 24 7a          	mov    %al,0x7a(%rsp)
     749:	49 be 00 f0 f2 a3 01 	movabs $0xff110001a3f2f000,%r14
     750:	00 11 ff 
     753:	49 8b 06             	mov    (%r14),%rax
     756:	48 8d 74 24 68       	lea    0x68(%rsp),%rsi
     75b:	4c 89 f7             	mov    %r14,%rdi
     75e:	ff 50 60             	call   *0x60(%rax)
     761:	48 89 c7             	mov    %rax,%rdi
  if (!vip_info) {
     764:	48 85 c0             	test   %rax,%rax
     767:	0f 84 07 01 00 00    	je     874 <balancer_ingress+0x874>
  if (data_end - data > MAX_PCKT_SIZE) {
     76d:	4c 89 f8             	mov    %r15,%rax
     770:	48 29 d8             	sub    %rbx,%rax
     773:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     779:	0f 8f 57 14 00 00    	jg     1bd6 <balancer_ingress+0x1bd6>
     77f:	48 ba 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rdx
     786:	00 11 ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     789:	4c 8b b2 00 11 00 00 	mov    0x1100(%rdx),%r14
     790:	65 4c 03 34 25 28 10 	add    %gs:0xffffffffa4391028,%r14
     797:	39 a4 
  if (!data_stats) {
     799:	4d 85 f6             	test   %r14,%r14
     79c:	0f 84 34 14 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
  data_stats->v1 += 1;
     7a2:	49 83 06 01          	addq   $0x1,(%r14)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     7a6:	f6 07 01             	testb  $0x1,(%rdi)
     7a9:	74 07                	je     7b2 <balancer_ingress+0x7b2>
    pckt.flow.port16[0] = 0;
     7ab:	66 c7 44 24 28 00 00 	movw   $0x0,0x28(%rsp)
  vip_num = vip_info->vip_num;
     7b2:	8b 77 04             	mov    0x4(%rdi),%esi
     7b5:	48 c7 c0 34 10 39 a4 	mov    $0xffffffffa4391034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     7bc:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     7c3:	39 a4 
     7c5:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     7c8:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     7cd:	0f 84 5a 03 00 00    	je     b2d <balancer_ingress+0xb2d>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     7d3:	48 8b 82 18 11 00 00 	mov    0x1118(%rdx),%rax
     7da:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     7e1:	39 a4 
    if (!lru_stats) {
     7e3:	48 85 c0             	test   %rax,%rax
     7e6:	0f 84 ea 13 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
    lru_stats->v1 += 1;
     7ec:	48 83 00 01          	addq   $0x1,(%rax)
     7f0:	48 b8 00 e8 f2 a3 01 	movabs $0xff110001a3f2e800,%rax
     7f7:	00 11 ff 
     7fa:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
     7ff:	e9 4b 03 00 00       	jmp    b4f <balancer_ingress+0xb4f>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     804:	80 7b 23 04          	cmpb   $0x4,0x23(%rbx)
     808:	75 32                	jne    83c <balancer_ingress+0x83c>
     80a:	48 b9 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rcx
     811:	00 11 ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     814:	48 8b 89 68 11 00 00 	mov    0x1168(%rcx),%rcx
     81b:	65 48 03 0c 25 28 10 	add    %gs:0xffffffffa4391028,%rcx
     822:	39 a4 
    if (!icmp_ptb_v4_stats) {
     824:	48 85 c9             	test   %rcx,%rcx
     827:	0f 84 a9 13 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
    icmp_ptb_v4_stats->v1 += 1;
     82d:	48 83 01 01          	addq   $0x1,(%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     831:	80 7b 28 04          	cmpb   $0x4,0x28(%rbx)
     835:	77 05                	ja     83c <balancer_ingress+0x83c>
      icmp_ptb_v4_stats->v2 += 1;
     837:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (iph + 1 > data_end) {
     83c:	48 8d 4b 3e          	lea    0x3e(%rbx),%rcx
     840:	4c 39 f9             	cmp    %r15,%rcx
     843:	0f 87 8d 13 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
  if (iph->ihl != 5) {
     849:	8a 00                	mov    (%rax),%al
     84b:	24 0f                	and    $0xf,%al
     84d:	3c 05                	cmp    $0x5,%al
     84f:	0f 85 81 13 00 00    	jne    1bd6 <balancer_ingress+0x1bd6>
  pckt->flow.proto = iph->protocol;
     855:	8a 43 33             	mov    0x33(%rbx),%al
     858:	88 44 24 2c          	mov    %al,0x2c(%rsp)
  pckt->flags |= F_ICMP;
     85c:	c6 44 24 34 01       	movb   $0x1,0x34(%rsp)
  pckt->flow.src = iph->daddr;
     861:	8b 4b 3a             	mov    0x3a(%rbx),%ecx
     864:	89 4c 24 08          	mov    %ecx,0x8(%rsp)
  pckt->flow.dst = iph->saddr;
     868:	8b 4b 36             	mov    0x36(%rbx),%ecx
     86b:	89 4c 24 18          	mov    %ecx,0x18(%rsp)
     86f:	e9 0d 01 00 00       	jmp    981 <balancer_ingress+0x981>
    vip.port = 0;
     874:	66 c7 44 24 78 00 00 	movw   $0x0,0x78(%rsp)
     87b:	49 8b 06             	mov    (%r14),%rax
     87e:	48 8d 74 24 68       	lea    0x68(%rsp),%rsi
     883:	4c 89 f7             	mov    %r14,%rdi
     886:	ff 50 60             	call   *0x60(%rax)
    if (!vip_info) {
     889:	48 85 c0             	test   %rax,%rax
     88c:	0f 84 49 13 00 00    	je     1bdb <balancer_ingress+0x1bdb>
     892:	48 89 c7             	mov    %rax,%rdi
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     895:	f6 00 88             	testb  $0x88,(%rax)
     898:	0f 85 cf fe ff ff    	jne    76d <balancer_ingress+0x76d>
      pckt.flow.port16[1] = 0;
     89e:	66 c7 44 24 2a 00 00 	movw   $0x0,0x2a(%rsp)
     8a5:	e9 c3 fe ff ff       	jmp    76d <balancer_ingress+0x76d>
  struct address dst_addr = {};
     8aa:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%rsp)
     8b1:	00 
     8b2:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
     8b9:	00 00 
    dst_addr.addr = pckt->flow.dst;
     8bb:	8b 44 24 18          	mov    0x18(%rsp),%eax
     8bf:	89 44 24 40          	mov    %eax,0x40(%rsp)
     8c3:	48 bf 00 e0 f2 a3 01 	movabs $0xff110001a3f2e000,%rdi
     8ca:	00 11 ff 
     8cd:	48 8b 07             	mov    (%rdi),%rax
     8d0:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     8d5:	ff 50 60             	call   *0x60(%rax)
  if (decap_dst_flags) {
     8d8:	48 85 c0             	test   %rax,%rax
     8db:	0f 84 fa 12 00 00    	je     1bdb <balancer_ingress+0x1bdb>
     8e1:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     8e8:	00 11 ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8eb:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     8f2:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     8f9:	39 a4 
    if (!data_stats) {
     8fb:	48 85 c0             	test   %rax,%rax
     8fe:	0f 85 f4 00 00 00    	jne    9f8 <balancer_ingress+0x9f8>
     904:	e9 d2 12 00 00       	jmp    1bdb <balancer_ingress+0x1bdb>
     909:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     910:	00 11 ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     913:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     91a:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     921:	39 a4 
    if (!icmp_ptb_v6_stats) {
     923:	48 85 c0             	test   %rax,%rax
     926:	0f 84 aa 12 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
    icmp_ptb_v6_stats->v1 += 1;
     92c:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     930:	8b 4b 26             	mov    0x26(%rbx),%ecx
     933:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     935:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     93b:	77 05                	ja     942 <balancer_ingress+0x942>
      icmp_ptb_v6_stats->v2 += 1;
     93d:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     942:	48 8d 43 52          	lea    0x52(%rbx),%rax
     946:	4c 39 f8             	cmp    %r15,%rax
     949:	0f 87 87 12 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
     94f:	48 8d 4c 24 18       	lea    0x18(%rsp),%rcx
  pckt->flow.proto = ip6h->nexthdr;
     954:	8a 43 30             	mov    0x30(%rbx),%al
     957:	88 44 24 2c          	mov    %al,0x2c(%rsp)
  pckt->flags |= F_ICMP;
     95b:	c6 44 24 34 01       	movb   $0x1,0x34(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     960:	48 8b 53 42          	mov    0x42(%rbx),%rdx
     964:	48 8b 73 4a          	mov    0x4a(%rbx),%rsi
     968:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
     96d:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     972:	48 8b 53 32          	mov    0x32(%rbx),%rdx
     976:	48 8b 73 3a          	mov    0x3a(%rbx),%rsi
     97a:	48 89 11             	mov    %rdx,(%rcx)
     97d:	48 89 71 08          	mov    %rsi,0x8(%rcx)
     981:	b2 03                	mov    $0x3,%dl
     983:	31 c9                	xor    %ecx,%ecx
     985:	bd 02 00 00 00       	mov    $0x2,%ebp
  if (protocol == IPPROTO_IPIP) {
     98a:	3c 10                	cmp    $0x10,%al
     98c:	0f 8e 51 fb ff ff    	jle    4e3 <balancer_ingress+0x4e3>
     992:	3c 11                	cmp    $0x11,%al
     994:	74 6b                	je     a01 <balancer_ingress+0xa01>
     996:	3c 29                	cmp    $0x29,%al
     998:	0f 85 3d 12 00 00    	jne    1bdb <balancer_ingress+0x1bdb>
  struct address dst_addr = {};
     99e:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%rsp)
     9a5:	00 
     9a6:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
     9ad:	00 00 
    dst_addr.addr = pckt->flow.dst;
     9af:	8b 44 24 18          	mov    0x18(%rsp),%eax
     9b3:	89 44 24 40          	mov    %eax,0x40(%rsp)
     9b7:	48 bf 00 e0 f2 a3 01 	movabs $0xff110001a3f2e000,%rdi
     9be:	00 11 ff 
     9c1:	48 8b 07             	mov    (%rdi),%rax
     9c4:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     9c9:	ff 50 60             	call   *0x60(%rax)
  if (decap_dst_flags) {
     9cc:	48 85 c0             	test   %rax,%rax
     9cf:	0f 84 06 12 00 00    	je     1bdb <balancer_ingress+0x1bdb>
     9d5:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     9dc:	00 11 ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     9df:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     9e6:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     9ed:	39 a4 
    if (!data_stats) {
     9ef:	48 85 c0             	test   %rax,%rax
     9f2:	0f 84 e3 11 00 00    	je     1bdb <balancer_ingress+0x1bdb>
     9f8:	48 83 00 01          	addq   $0x1,(%rax)
     9fc:	e9 da 11 00 00       	jmp    1bdb <balancer_ingress+0x1bdb>
  udp = data + off;
     a01:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
  if (is_ipv6) {
     a05:	84 c9                	test   %cl,%cl
  udp = data + off;
     a07:	49 0f 45 c4          	cmovne %r12,%rax
  if (udp + 1 > data_end) {
     a0b:	48 8d 50 08          	lea    0x8(%rax),%rdx
     a0f:	4c 39 fa             	cmp    %r15,%rdx
     a12:	0f 87 be 11 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
     a18:	84 c9                	test   %cl,%cl
     a1a:	66 89 7c 24 5c       	mov    %di,0x5c(%rsp)
     a1f:	74 13                	je     a34 <balancer_ingress+0xa34>
     a21:	0f b7 10             	movzwl (%rax),%edx
     a24:	48 8d 4c 24 28       	lea    0x28(%rsp),%rcx
     a29:	66 89 54 24 28       	mov    %dx,0x28(%rsp)
     a2e:	48 83 c0 02          	add    $0x2,%rax
     a32:	eb 0e                	jmp    a42 <balancer_ingress+0xa42>
     a34:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     a38:	48 8d 4c 24 28       	lea    0x28(%rsp),%rcx
     a3d:	66 89 54 24 28       	mov    %dx,0x28(%rsp)
     a42:	0f b7 00             	movzwl (%rax),%eax
     a45:	66 89 41 02          	mov    %ax,0x2(%rcx)
    vip.vip = pckt.flow.dst;
     a49:	8b 44 24 18          	mov    0x18(%rsp),%eax
     a4d:	89 44 24 68          	mov    %eax,0x68(%rsp)
  vip.port = pckt.flow.port16[1];
     a51:	0f b7 44 24 2a       	movzwl 0x2a(%rsp),%eax
     a56:	66 89 44 24 78       	mov    %ax,0x78(%rsp)
  vip.proto = pckt.flow.proto;
     a5b:	8a 44 24 2c          	mov    0x2c(%rsp),%al
     a5f:	88 44 24 7a          	mov    %al,0x7a(%rsp)
     a63:	49 be 00 f0 f2 a3 01 	movabs $0xff110001a3f2f000,%r14
     a6a:	00 11 ff 
     a6d:	49 8b 06             	mov    (%r14),%rax
     a70:	48 8d 74 24 68       	lea    0x68(%rsp),%rsi
     a75:	4c 89 f7             	mov    %r14,%rdi
     a78:	ff 50 60             	call   *0x60(%rax)
     a7b:	48 89 c2             	mov    %rax,%rdx
  if (!vip_info) {
     a7e:	48 85 c0             	test   %rax,%rax
     a81:	0f 84 45 01 00 00    	je     bcc <balancer_ingress+0xbcc>
  if (data_end - data > MAX_PCKT_SIZE) {
     a87:	4c 89 f8             	mov    %r15,%rax
     a8a:	48 29 d8             	sub    %rbx,%rax
     a8d:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     a93:	0f 8f 3d 11 00 00    	jg     1bd6 <balancer_ingress+0x1bd6>
     a99:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     aa0:	00 11 ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     aa3:	4c 8b b0 00 11 00 00 	mov    0x1100(%rax),%r14
     aaa:	65 4c 03 34 25 28 10 	add    %gs:0xffffffffa4391028,%r14
     ab1:	39 a4 
  if (!data_stats) {
     ab3:	4d 85 f6             	test   %r14,%r14
     ab6:	0f 84 1a 11 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
  data_stats->v1 += 1;
     abc:	49 83 06 01          	addq   $0x1,(%r14)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     ac0:	f6 02 01             	testb  $0x1,(%rdx)
     ac3:	74 07                	je     acc <balancer_ingress+0xacc>
    pckt.flow.port16[0] = 0;
     ac5:	66 c7 44 24 28 00 00 	movw   $0x0,0x28(%rsp)
  vip_num = vip_info->vip_num;
     acc:	8b 42 04             	mov    0x4(%rdx),%eax
     acf:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
     ad4:	48 c7 c0 34 10 39 a4 	mov    $0xffffffffa4391034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     adb:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     ae2:	39 a4 
     ae4:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     ae7:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     aec:	0f 84 53 01 00 00    	je     c45 <balancer_ingress+0xc45>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     af2:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     af9:	00 11 ff 
     afc:	48 8b 80 18 11 00 00 	mov    0x1118(%rax),%rax
     b03:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     b0a:	39 a4 
    if (!lru_stats) {
     b0c:	48 85 c0             	test   %rax,%rax
     b0f:	0f 84 c1 10 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
    lru_stats->v1 += 1;
     b15:	48 83 00 01          	addq   $0x1,(%rax)
     b19:	48 b8 00 e8 f2 a3 01 	movabs $0xff110001a3f2e800,%rax
     b20:	00 11 ff 
     b23:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
     b28:	e9 3a 01 00 00       	jmp    c67 <balancer_ingress+0xc67>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     b2d:	89 c0                	mov    %eax,%eax
     b2f:	48 b9 00 40 1c a1 01 	movabs $0xff110001a11c4000,%rcx
     b36:	00 11 ff 
     b39:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     b40:	00 
     b41:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  if (!lru_map) {
     b46:	48 85 c0             	test   %rax,%rax
     b49:	0f 84 84 fc ff ff    	je     7d3 <balancer_ingress+0x7d3>
     b4f:	48 89 74 24 60       	mov    %rsi,0x60(%rsp)
  if ((vip_info->flags & F_QUIC_VIP)) {
     b54:	f6 07 04             	testb  $0x4,(%rdi)
     b57:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
     b5c:	0f 84 89 0a 00 00    	je     15eb <balancer_ingress+0x15eb>
    bool is_icmp = (pckt.flags & F_ICMP);
     b62:	f6 44 24 34 01       	testb  $0x1,0x34(%rsp)
    if (is_icmp) {
     b67:	0f 85 95 00 00 00    	jne    c02 <balancer_ingress+0xc02>
     b6d:	48 b8 00 b4 b4 07 01 	movabs $0xff11000107b4b400,%rax
     b74:	00 11 ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     b77:	48 8b a8 00 01 00 00 	mov    0x100(%rax),%rbp
     b7e:	65 48 03 2c 25 28 10 	add    %gs:0xffffffffa4391028,%rbp
     b85:	39 a4 
      if (!quic_packets_stats) {
     b87:	48 85 ed             	test   %rbp,%rbp
     b8a:	0f 84 46 10 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b90:	48 83 c3 66          	add    $0x66,%rbx
  bool is_icmp = (pckt->flags & F_ICMP);
     b94:	f6 44 24 34 01       	testb  $0x1,0x34(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b99:	49 0f 44 dc          	cmove  %r12,%rbx
     b9d:	48 8d 43 09          	lea    0x9(%rbx),%rax
     ba1:	4c 39 f8             	cmp    %r15,%rax
     ba4:	0f 87 37 0a 00 00    	ja     15e1 <balancer_ingress+0x15e1>
     baa:	48 83 c3 08          	add    $0x8,%rbx
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     bae:	0f b6 0b             	movzbl (%rbx),%ecx
     bb1:	f6 c1 80             	test   $0x80,%cl
     bb4:	0f 85 59 02 00 00    	jne    e13 <balancer_ingress+0xe13>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     bba:	48 83 c3 09          	add    $0x9,%rbx
     bbe:	4c 39 fb             	cmp    %r15,%rbx
     bc1:	0f 87 1a 0a 00 00    	ja     15e1 <balancer_ingress+0x15e1>
     bc7:	e9 82 03 00 00       	jmp    f4e <balancer_ingress+0xf4e>
    vip.port = 0;
     bcc:	66 c7 44 24 78 00 00 	movw   $0x0,0x78(%rsp)
     bd3:	49 8b 06             	mov    (%r14),%rax
     bd6:	48 8d 74 24 68       	lea    0x68(%rsp),%rsi
     bdb:	4c 89 f7             	mov    %r14,%rdi
     bde:	ff 50 60             	call   *0x60(%rax)
    if (!vip_info) {
     be1:	48 85 c0             	test   %rax,%rax
     be4:	0f 84 f1 0f 00 00    	je     1bdb <balancer_ingress+0x1bdb>
     bea:	48 89 c2             	mov    %rax,%rdx
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     bed:	f6 00 88             	testb  $0x88,(%rax)
     bf0:	0f 85 91 fe ff ff    	jne    a87 <balancer_ingress+0xa87>
      pckt.flow.port16[1] = 0;
     bf6:	66 c7 44 24 2a 00 00 	movw   $0x0,0x2a(%rsp)
     bfd:	e9 85 fe ff ff       	jmp    a87 <balancer_ingress+0xa87>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c02:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     c09:	00 11 ff 
     c0c:	48 8b a8 58 11 00 00 	mov    0x1158(%rax),%rbp
     c13:	65 48 03 2c 25 28 10 	add    %gs:0xffffffffa4391028,%rbp
     c1a:	39 a4 
      if (!data_stats) {
     c1c:	48 85 ed             	test   %rbp,%rbp
     c1f:	0f 84 b1 0f 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
      data_stats->v1 += 1;
     c25:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     c2a:	8a 43 37             	mov    0x37(%rbx),%al
     c2d:	04 fd                	add    $0xfd,%al
     c2f:	3c 01                	cmp    $0x1,%al
     c31:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     c36:	0f 87 af 09 00 00    	ja     15eb <balancer_ingress+0x15eb>
        data_stats->v2 += 1;
     c3c:	48 83 c5 08          	add    $0x8,%rbp
     c40:	e9 a1 09 00 00       	jmp    15e6 <balancer_ingress+0x15e6>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     c45:	89 c0                	mov    %eax,%eax
     c47:	48 b9 00 40 1c a1 01 	movabs $0xff110001a11c4000,%rcx
     c4e:	00 11 ff 
     c51:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     c58:	00 
     c59:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  if (!lru_map) {
     c5e:	48 85 c0             	test   %rax,%rax
     c61:	0f 84 8b fe ff ff    	je     af2 <balancer_ingress+0xaf2>
     c67:	48 89 54 24 38       	mov    %rdx,0x38(%rsp)
  if ((vip_info->flags & F_QUIC_VIP)) {
     c6c:	f6 02 04             	testb  $0x4,(%rdx)
     c6f:	0f 84 db 00 00 00    	je     d50 <balancer_ingress+0xd50>
    bool is_icmp = (pckt.flags & F_ICMP);
     c75:	f6 44 24 34 01       	testb  $0x1,0x34(%rsp)
    if (is_icmp) {
     c7a:	0f 85 96 00 00 00    	jne    d16 <balancer_ingress+0xd16>
     c80:	48 b8 00 b4 b4 07 01 	movabs $0xff11000107b4b400,%rax
     c87:	00 11 ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     c8a:	48 8b a8 00 01 00 00 	mov    0x100(%rax),%rbp
     c91:	65 48 03 2c 25 28 10 	add    %gs:0xffffffffa4391028,%rbp
     c98:	39 a4 
      if (!quic_packets_stats) {
     c9a:	48 85 ed             	test   %rbp,%rbp
     c9d:	0f 84 33 0f 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     ca3:	48 83 c3 3e          	add    $0x3e,%rbx
  bool is_icmp = (pckt->flags & F_ICMP);
     ca7:	f6 44 24 34 01       	testb  $0x1,0x34(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     cac:	49 0f 44 dc          	cmove  %r12,%rbx
     cb0:	48 8d 43 09          	lea    0x9(%rbx),%rax
     cb4:	4c 39 f8             	cmp    %r15,%rax
     cb7:	0f 87 8e 00 00 00    	ja     d4b <balancer_ingress+0xd4b>
     cbd:	48 83 c3 08          	add    $0x8,%rbx
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     cc1:	0f b6 0b             	movzbl (%rbx),%ecx
     cc4:	f6 c1 80             	test   $0x80,%cl
     cc7:	0f 85 19 02 00 00    	jne    ee6 <balancer_ingress+0xee6>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     ccd:	48 83 c3 09          	add    $0x9,%rbx
     cd1:	4c 39 fb             	cmp    %r15,%rbx
     cd4:	77 75                	ja     d4b <balancer_ingress+0xd4b>
  if (!connId) {
     cd6:	48 85 c0             	test   %rax,%rax
     cd9:	74 70                	je     d4b <balancer_ingress+0xd4b>
  __u8 connIdVersion = (connId[0] >> 6);
     cdb:	0f b6 08             	movzbl (%rax),%ecx
     cde:	89 ca                	mov    %ecx,%edx
     ce0:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     ce3:	80 fa 03             	cmp    $0x3,%dl
     ce6:	0f 84 d3 10 00 00    	je     1dbf <balancer_ingress+0x1dbf>
     cec:	80 fa 02             	cmp    $0x2,%dl
     cef:	0f 84 ef 10 00 00    	je     1de4 <balancer_ingress+0x1de4>
     cf5:	80 fa 01             	cmp    $0x1,%dl
     cf8:	75 51                	jne    d4b <balancer_ingress+0xd4b>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     cfa:	83 e1 3f             	and    $0x3f,%ecx
     cfd:	48 c1 e1 0a          	shl    $0xa,%rcx
     d01:	0f b6 50 01          	movzbl 0x1(%rax),%edx
     d05:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
     d09:	8a 40 02             	mov    0x2(%rax),%al
     d0c:	c0 e8 06             	shr    $0x6,%al
     d0f:	b2 01                	mov    $0x1,%dl
     d11:	e9 e6 10 00 00       	jmp    1dfc <balancer_ingress+0x1dfc>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     d16:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     d1d:	00 11 ff 
     d20:	48 8b a8 58 11 00 00 	mov    0x1158(%rax),%rbp
     d27:	65 48 03 2c 25 28 10 	add    %gs:0xffffffffa4391028,%rbp
     d2e:	39 a4 
      if (!data_stats) {
     d30:	48 85 ed             	test   %rbp,%rbp
     d33:	0f 84 9d 0e 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
      data_stats->v1 += 1;
     d39:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     d3e:	8a 43 23             	mov    0x23(%rbx),%al
     d41:	24 fd                	and    $0xfd,%al
     d43:	3c 01                	cmp    $0x1,%al
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     d45:	75 09                	jne    d50 <balancer_ingress+0xd50>
        data_stats->v2 += 1;
     d47:	48 83 c5 08          	add    $0x8,%rbp
     d4b:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
  original_sport = pckt.flow.port16[0];
     d50:	44 0f b7 7c 24 28    	movzwl 0x28(%rsp),%r15d
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     d56:	f6 44 24 34 02       	testb  $0x2,0x34(%rsp)
     d5b:	75 50                	jne    dad <balancer_ingress+0xdad>
     d5d:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
        !(vip_info->flags & F_LRU_BYPASS)) {
     d62:	f6 00 02             	testb  $0x2,(%rax)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     d65:	75 46                	jne    dad <balancer_ingress+0xdad>
     d67:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
     d6c:	48 8b 07             	mov    (%rdi),%rax
     d6f:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
     d74:	ff 50 60             	call   *0x60(%rax)
  if (!dst_lru) {
     d77:	48 85 c0             	test   %rax,%rax
     d7a:	74 31                	je     dad <balancer_ingress+0xdad>
     d7c:	48 89 c5             	mov    %rax,%rbp
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
     d7f:	80 7c 24 2c 11       	cmpb   $0x11,0x2c(%rsp)
     d84:	0f 85 10 02 00 00    	jne    f9a <balancer_ingress+0xf9a>
     d8a:	48 c7 c0 50 0c 69 9e 	mov    $0xffffffff9e690c50,%rax
    cur_time = bpf_ktime_get_ns();
     d91:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
     d93:	48 89 c1             	mov    %rax,%rcx
     d96:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
     d9a:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
     da1:	00 00 00 
     da4:	48 39 d1             	cmp    %rdx,%rcx
     da7:	0f 86 e9 01 00 00    	jbe    f96 <balancer_ingress+0xf96>
     dad:	45 31 e4             	xor    %r12d,%r12d
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     db0:	80 7c 24 2c 11       	cmpb   $0x11,0x2c(%rsp)
     db5:	0f 85 14 02 00 00    	jne    fcf <balancer_ingress+0xfcf>
     dbb:	48 8b 44 24 38       	mov    0x38(%rsp),%rax
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
     dc0:	f6 40 01 02          	testb  $0x2,0x1(%rax)
     dc4:	0f 84 05 02 00 00    	je     fcf <balancer_ingress+0xfcf>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     dca:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     dd1:	00 11 ff 
     dd4:	48 8b 98 10 11 00 00 	mov    0x1110(%rax),%rbx
     ddb:	65 48 03 1c 25 28 10 	add    %gs:0xffffffffa4391028,%rbx
     de2:	39 a4 
  if (!conn_rate_stats) {
     de4:	48 85 db             	test   %rbx,%rbx
     de7:	0f 84 e2 01 00 00    	je     fcf <balancer_ingress+0xfcf>
     ded:	48 c7 c0 50 0c 69 9e 	mov    $0xffffffff9e690c50,%rax
  *cur_time = bpf_ktime_get_ns();
     df4:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     df6:	48 89 c1             	mov    %rax,%rcx
     df9:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
     dfd:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
     e04:	72 69                	jb     e6f <balancer_ingress+0xe6f>
    conn_rate_stats->v1 = 1;
     e06:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
     e0d:	48 89 43 08          	mov    %rax,0x8(%rbx)
     e11:	eb 72                	jmp    e85 <balancer_ingress+0xe85>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     e13:	48 8d 43 0e          	lea    0xe(%rbx),%rax
     e17:	4c 39 f8             	cmp    %r15,%rax
     e1a:	0f 87 c1 07 00 00    	ja     15e1 <balancer_ingress+0x15e1>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     e20:	f6 c1 20             	test   $0x20,%cl
     e23:	0f 85 14 01 00 00    	jne    f3d <balancer_ingress+0xf3d>
        quic_packets_stats->cid_initial += 1;
     e29:	48 83 45 08 01       	addq   $0x1,0x8(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     e2e:	81 7c 24 60 ff 01 00 	cmpl   $0x1ff,0x60(%rsp)
     e35:	00 
     e36:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
     e3b:	0f 87 aa 07 00 00    	ja     15eb <balancer_ingress+0x15eb>
     e41:	48 b8 00 c0 e6 53 01 	movabs $0xff11000153e6c000,%rax
     e48:	00 11 ff 
     e4b:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
     e50:	48 8b ac c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rbp
     e57:	00 
     e58:	65 48 03 2c 25 28 10 	add    %gs:0xffffffffa4391028,%rbp
     e5f:	39 a4 
  if (!per_vip_stats) {
     e61:	48 85 ed             	test   %rbp,%rbp
     e64:	0f 85 7c 07 00 00    	jne    15e6 <balancer_ingress+0x15e6>
     e6a:	e9 7c 07 00 00       	jmp    15eb <balancer_ingress+0x15eb>
    conn_rate_stats->v1 += 1;
     e6f:	48 8b 03             	mov    (%rbx),%rax
     e72:	48 83 c0 01          	add    $0x1,%rax
     e76:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
     e79:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
     e7f:	0f 87 4a 01 00 00    	ja     fcf <balancer_ingress+0xfcf>
     e85:	48 bf 00 c8 ad 08 01 	movabs $0xff11000108adc800,%rdi
     e8c:	00 11 ff 
     e8f:	48 8b 07             	mov    (%rdi),%rax
     e92:	48 8d 74 24 68       	lea    0x68(%rsp),%rsi
     e97:	ff 50 60             	call   *0x60(%rax)
    if (down_reals_map) {
     e9a:	48 85 c0             	test   %rax,%rax
     e9d:	0f 84 2c 01 00 00    	je     fcf <balancer_ingress+0xfcf>
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
     ea3:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
     ea8:	48 8b 08             	mov    (%rax),%rcx
     eab:	48 89 c7             	mov    %rax,%rdi
     eae:	ff 51 60             	call   *0x60(%rcx)
      if (down_real) {
     eb1:	48 85 c0             	test   %rax,%rax
     eb4:	0f 84 15 01 00 00    	je     fcf <balancer_ingress+0xfcf>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
     eba:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     ec1:	00 11 ff 
     ec4:	48 8b 80 78 11 00 00 	mov    0x1178(%rax),%rax
     ecb:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
     ed2:	39 a4 
        if (stats_data) {
     ed4:	48 85 c0             	test   %rax,%rax
     ed7:	0f 84 5a 02 00 00    	je     1137 <balancer_ingress+0x1137>
          stats_data->v1 += 1;
     edd:	48 83 00 01          	addq   $0x1,(%rax)
     ee1:	e9 51 02 00 00       	jmp    1137 <balancer_ingress+0x1137>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     ee6:	48 8d 43 0e          	lea    0xe(%rbx),%rax
     eea:	4c 39 f8             	cmp    %r15,%rax
     eed:	0f 87 58 fe ff ff    	ja     d4b <balancer_ingress+0xd4b>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     ef3:	f6 c1 20             	test   $0x20,%cl
     ef6:	0f 85 25 06 00 00    	jne    1521 <balancer_ingress+0x1521>
        quic_packets_stats->cid_initial += 1;
     efc:	48 83 45 08 01       	addq   $0x1,0x8(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     f01:	81 7c 24 60 ff 01 00 	cmpl   $0x1ff,0x60(%rsp)
     f08:	00 
     f09:	0f 87 41 fe ff ff    	ja     d50 <balancer_ingress+0xd50>
     f0f:	48 b8 00 c0 e6 53 01 	movabs $0xff11000153e6c000,%rax
     f16:	00 11 ff 
     f19:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
     f1e:	48 8b ac c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rbp
     f25:	00 
     f26:	65 48 03 2c 25 28 10 	add    %gs:0xffffffffa4391028,%rbp
     f2d:	39 a4 
  if (!per_vip_stats) {
     f2f:	48 85 ed             	test   %rbp,%rbp
     f32:	0f 85 13 fe ff ff    	jne    d4b <balancer_ingress+0xd4b>
     f38:	e9 13 fe ff ff       	jmp    d50 <balancer_ingress+0xd50>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
     f3d:	80 7b 05 08          	cmpb   $0x8,0x5(%rbx)
     f41:	0f 82 9a 06 00 00    	jb     15e1 <balancer_ingress+0x15e1>
     f47:	48 83 c3 06          	add    $0x6,%rbx
     f4b:	48 89 d8             	mov    %rbx,%rax
  if (!connId) {
     f4e:	48 85 c0             	test   %rax,%rax
     f51:	0f 84 8a 06 00 00    	je     15e1 <balancer_ingress+0x15e1>
  __u8 connIdVersion = (connId[0] >> 6);
     f57:	0f b6 08             	movzbl (%rax),%ecx
     f5a:	89 ca                	mov    %ecx,%edx
     f5c:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     f5f:	80 fa 03             	cmp    $0x3,%dl
     f62:	0f 84 8b 04 00 00    	je     13f3 <balancer_ingress+0x13f3>
     f68:	80 fa 02             	cmp    $0x2,%dl
     f6b:	0f 84 a7 04 00 00    	je     1418 <balancer_ingress+0x1418>
     f71:	80 fa 01             	cmp    $0x1,%dl
     f74:	0f 85 67 06 00 00    	jne    15e1 <balancer_ingress+0x15e1>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     f7a:	83 e1 3f             	and    $0x3f,%ecx
     f7d:	48 c1 e1 0a          	shl    $0xa,%rcx
     f81:	0f b6 50 01          	movzbl 0x1(%rax),%edx
     f85:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
     f89:	8a 40 02             	mov    0x2(%rax),%al
     f8c:	c0 e8 06             	shr    $0x6,%al
     f8f:	b2 01                	mov    $0x1,%dl
     f91:	e9 9a 04 00 00       	jmp    1430 <balancer_ingress+0x1430>
    dst_lru->atime = cur_time;
     f96:	48 89 45 08          	mov    %rax,0x8(%rbp)
  key = dst_lru->pos;
     f9a:	8b 45 00             	mov    0x0(%rbp),%eax
     f9d:	45 31 e4             	xor    %r12d,%r12d
     fa0:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
     fa6:	89 44 24 30          	mov    %eax,0x30(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
     faa:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
     fae:	48 b9 00 d0 1f 79 01 	movabs $0xffa00001791fd000,%rcx
     fb5:	00 a0 ff 
     fb8:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
     fbf:	00 
     fc0:	4c 0f 42 e0          	cmovb  %rax,%r12
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     fc4:	80 7c 24 2c 11       	cmpb   $0x11,0x2c(%rsp)
     fc9:	0f 84 ec fd ff ff    	je     dbb <balancer_ingress+0xdbb>
    if (!dst) {
     fcf:	4d 85 e4             	test   %r12,%r12
     fd2:	0f 84 5f 01 00 00    	je     1137 <balancer_ingress+0x1137>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
     fd8:	81 7c 24 60 ff 03 00 	cmpl   $0x3ff,0x60(%rsp)
     fdf:	00 
     fe0:	0f 87 f0 0b 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
     fe6:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
     fed:	00 11 ff 
     ff0:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
     ff5:	48 8b 8c c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rcx
     ffc:	00 
     ffd:	65 48 03 0c 25 28 10 	add    %gs:0xffffffffa4391028,%rcx
    1004:	39 a4 
  if (!data_stats) {
    1006:	48 85 c9             	test   %rcx,%rcx
    1009:	0f 84 c7 0b 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
    100f:	0f b7 44 24 5c       	movzwl 0x5c(%rsp),%eax
    1014:	89 c3                	mov    %eax,%ebx
    1016:	66 c1 c3 08          	rol    $0x8,%bx
  data_stats->v1 += 1;
    101a:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    101e:	0f b7 c3             	movzwl %bx,%eax
    1021:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1025:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
    1029:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    1030:	0f 87 a0 0b 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    1036:	48 ba 00 70 21 79 01 	movabs $0xffa0000179217000,%rdx
    103d:	00 a0 ff 
    1040:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
    1047:	00 
    1048:	65 48 03 0c 25 28 10 	add    %gs:0xffffffffa4391028,%rcx
    104f:	39 a4 
  if (!data_stats) {
    1051:	48 85 c9             	test   %rcx,%rcx
    1054:	0f 84 7c 0b 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
  data_stats->v1 += 1;
    105a:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    105e:	48 01 41 08          	add    %rax,0x8(%rcx)
  pckt.flow.port16[0] = original_sport;
    1062:	66 44 89 7c 24 28    	mov    %r15w,0x28(%rsp)
  if (dst->flags & F_IPV6) {
    1068:	41 f6 44 24 10 01    	testb  $0x1,0x10(%r12)
    106e:	0f 85 bb 02 00 00    	jne    132f <balancer_ingress+0x132f>
  void* data;
  void* data_end;
  struct iphdr* iph;
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1074:	44 0f b7 74 24 0a    	movzwl 0xa(%rsp),%r14d
    107a:	48 c7 c0 60 92 82 a0 	mov    $0xffffffffa0829260,%rax
  __u64 csum = 0;
  // ipip encap
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1081:	4c 89 ef             	mov    %r13,%rdi
    1084:	be ec ff ff ff       	mov    $0xffffffec,%esi
    1089:	ff d0                	call   *%rax
    108b:	85 c0                	test   %eax,%eax
    108d:	0f 85 43 0b 00 00    	jne    1bd6 <balancer_ingress+0x1bd6>
    return false;
  }
  data = (void*)(long)xdp->data;
    1093:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1097:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  new_eth = data;
  iph = data + sizeof(struct ethhdr);
    109b:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  old_eth = data + sizeof(struct iphdr);
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    109f:	48 39 ca             	cmp    %rcx,%rdx
    10a2:	0f 87 2e 0b 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    10a8:	48 8d 50 22          	lea    0x22(%rax),%rdx
    10ac:	bd 01 00 00 00       	mov    $0x1,%ebp
    10b1:	48 39 ca             	cmp    %rcx,%rdx
    10b4:	0f 87 21 0b 00 00    	ja     1bdb <balancer_ingress+0x1bdb>
    10ba:	66 41 c1 c7 08       	rol    $0x8,%r15w
    10bf:	45 31 fe             	xor    %r15d,%r14d
    10c2:	41 c1 e6 10          	shl    $0x10,%r14d
    10c6:	41 8d be ac 10 00 00 	lea    0x10ac(%r14),%edi
    10cd:	48 b9 00 a8 b4 07 01 	movabs $0xff11000107b4a800,%rcx
    10d4:	00 11 ff 
    return false;
  }
  memcpy(new_eth->h_dest, cval->mac, 6);
    10d7:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    10de:	66 89 70 04          	mov    %si,0x4(%rax)
    10e2:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    10e8:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    10ea:	8b 48 14             	mov    0x14(%rax),%ecx
    10ed:	89 48 06             	mov    %ecx,0x6(%rax)
    10f0:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    10f4:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    10f8:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)

  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    10fe:	8a 54 24 35          	mov    0x35(%rsp),%dl
    1102:	41 8b 0c 24          	mov    (%r12),%ecx
    __u32 daddr,
    __u16 pkt_bytes,
    __u8 proto) {
  __u64 csum = 0;
  iph->version = 4;
  iph->ihl = 5;
    1106:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->frag_off = 0;
  iph->protocol = proto;
  iph->check = 0;
#ifdef COPY_INNER_PACKET_TOS
  iph->tos = tos;
    110a:	88 50 0f             	mov    %dl,0xf(%rax)
#else
  iph->tos = DEFAULT_TOS;
#endif
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    110d:	83 c3 14             	add    $0x14,%ebx
    1110:	66 c1 c3 08          	rol    $0x8,%bx
    1114:	66 89 58 10          	mov    %bx,0x10(%rax)
  iph->id = 0;
    1118:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    111f:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    1122:	89 78 1a             	mov    %edi,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    1125:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    112b:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    112f:	0f b7 f3             	movzwl %bx,%esi
    1132:	e9 6b 07 00 00       	jmp    18a2 <balancer_ingress+0x18a2>
      if (pckt.flow.proto == IPPROTO_TCP) {
    1137:	80 7c 24 2c 06       	cmpb   $0x6,0x2c(%rsp)
    113c:	75 34                	jne    1172 <balancer_ingress+0x1172>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    113e:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    1145:	00 11 ff 
    1148:	48 8b 80 08 11 00 00 	mov    0x1108(%rax),%rax
    114f:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    1156:	39 a4 
        if (!lru_stats) {
    1158:	48 85 c0             	test   %rax,%rax
    115b:	0f 84 75 0a 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
        if (pckt.flags & F_SYN_SET) {
    1161:	8b 4c 24 34          	mov    0x34(%rsp),%ecx
    1165:	c1 e1 02             	shl    $0x2,%ecx
    1168:	f7 d1                	not    %ecx
    116a:	83 e1 08             	and    $0x8,%ecx
    116d:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
  struct real_pos_lru new_dst_lru = {};
    1172:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    1179:	00 00 
    117b:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    1182:	00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1184:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    118b:	00 11 ff 
    118e:	48 8b a8 10 11 00 00 	mov    0x1110(%rax),%rbp
    1195:	65 48 03 2c 25 28 10 	add    %gs:0xffffffffa4391028,%rbp
    119c:	39 a4 
    119e:	b3 01                	mov    $0x1,%bl
  if (!conn_rate_stats) {
    11a0:	48 85 ed             	test   %rbp,%rbp
    11a3:	74 27                	je     11cc <balancer_ingress+0x11cc>
    11a5:	48 c7 c0 50 0c 69 9e 	mov    $0xffffffff9e690c50,%rax
  *cur_time = bpf_ktime_get_ns();
    11ac:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    11ae:	48 89 c1             	mov    %rax,%rcx
    11b1:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    11b5:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    11bc:	72 12                	jb     11d0 <balancer_ingress+0x11d0>
    conn_rate_stats->v1 = 1;
    11be:	48 c7 45 00 01 00 00 	movq   $0x1,0x0(%rbp)
    11c5:	00 
    conn_rate_stats->v2 = *cur_time;
    11c6:	48 89 45 08          	mov    %rax,0x8(%rbp)
    11ca:	eb 19                	jmp    11e5 <balancer_ingress+0x11e5>
    11cc:	31 c0                	xor    %eax,%eax
    11ce:	eb 17                	jmp    11e7 <balancer_ingress+0x11e7>
    conn_rate_stats->v1 += 1;
    11d0:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
    11d4:	48 83 c1 01          	add    $0x1,%rcx
    11d8:	48 89 4d 00          	mov    %rcx,0x0(%rbp)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    11dc:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    11e3:	77 02                	ja     11e7 <balancer_ingress+0x11e7>
    11e5:	31 db                	xor    %ebx,%ebx
    11e7:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    11ec:	f6 01 08             	testb  $0x8,(%rcx)
    11ef:	75 06                	jne    11f7 <balancer_ingress+0x11f7>
    11f1:	8b 54 24 08          	mov    0x8(%rsp),%edx
    11f5:	eb 1e                	jmp    1215 <balancer_ingress+0x1215>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    11f7:	0f b7 4c 24 2a       	movzwl 0x2a(%rsp),%ecx
    11fc:	66 89 4c 24 28       	mov    %cx,0x28(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    1201:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    1208:	00 00 
    120a:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    1211:	00 00 
    1213:	31 d2                	xor    %edx,%edx
    1215:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  return c;
}

static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval) {
  a += initval;
  b += initval;
    121a:	03 74 24 28          	add    0x28(%rsp),%esi
  a += initval;
    121e:	81 c2 f7 c0 ad e0    	add    $0xe0adc0f7,%edx
  c += initval;
  __jhash_final(a, b, c);
    1224:	89 f1                	mov    %esi,%ecx
    1226:	81 f1 f7 c0 ad e0    	xor    $0xe0adc0f7,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    122c:	89 f7                	mov    %esi,%edi
    122e:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    1231:	29 f9                	sub    %edi,%ecx
    1233:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1235:	89 cf                	mov    %ecx,%edi
    1237:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    123a:	29 fa                	sub    %edi,%edx
    123c:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    123e:	89 d7                	mov    %edx,%edi
    1240:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    1243:	29 fe                	sub    %edi,%esi
    1245:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1247:	89 f7                	mov    %esi,%edi
    1249:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    124c:	29 f9                	sub    %edi,%ecx
    124e:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1250:	89 cf                	mov    %ecx,%edi
    1252:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1255:	29 fa                	sub    %edi,%edx
    1257:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1259:	c1 c2 0e             	rol    $0xe,%edx
  __jhash_final(a, b, c);
    125c:	29 d6                	sub    %edx,%esi
    125e:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1260:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    1263:	29 f1                	sub    %esi,%ecx
    1265:	ba 01 00 ff ff       	mov    $0xffff0001,%edx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    126a:	48 0f af d1          	imul   %rcx,%rdx
    126e:	48 c1 ea 30          	shr    $0x30,%rdx
    1272:	89 d6                	mov    %edx,%esi
    1274:	c1 e6 10             	shl    $0x10,%esi
    1277:	09 d6                	or     %edx,%esi
    1279:	29 f1                	sub    %esi,%ecx
    127b:	48 8b 54 24 38       	mov    0x38(%rsp),%rdx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1280:	8b 72 04             	mov    0x4(%rdx),%esi
    1283:	89 f2                	mov    %esi,%edx
    1285:	c1 e2 10             	shl    $0x10,%edx
    1288:	01 f2                	add    %esi,%edx
    128a:	01 ca                	add    %ecx,%edx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    128c:	81 fa ff 01 00 02    	cmp    $0x20001ff,%edx
    if (!real_pos) {
    1292:	0f 87 3e 09 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1298:	89 d1                	mov    %edx,%ecx
    129a:	48 ba 00 a0 1f 69 01 	movabs $0xffa00001691fa000,%rdx
    12a1:	00 a0 ff 
    key = *real_pos;
    12a4:	8b ac ca 00 01 00 00 	mov    0x100(%rdx,%rcx,8),%ebp
    12ab:	48 85 ed             	test   %rbp,%rbp
    if (key == 0) {
    12ae:	74 34                	je     12e4 <balancer_ingress+0x12e4>
  pckt->real_index = key;
    12b0:	89 6c 24 30          	mov    %ebp,0x30(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    12b4:	81 fd 00 10 00 00    	cmp    $0x1000,%ebp
  if (!(*real)) {
    12ba:	72 50                	jb     130c <balancer_ingress+0x130c>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    12bc:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    12c3:	00 11 ff 
    12c6:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    12cd:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    12d4:	39 a4 
  if (!ch_drop_stats) {
    12d6:	48 85 c0             	test   %rax,%rax
    12d9:	0f 85 f3 08 00 00    	jne    1bd2 <balancer_ingress+0x1bd2>
    12df:	e9 f2 08 00 00       	jmp    1bd6 <balancer_ingress+0x1bd6>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    12e4:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    12eb:	00 11 ff 
    12ee:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    12f5:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    12fc:	39 a4 
  if (!ch_drop_stats) {
    12fe:	48 85 c0             	test   %rax,%rax
    1301:	0f 85 c7 08 00 00    	jne    1bce <balancer_ingress+0x1bce>
    1307:	e9 ca 08 00 00       	jmp    1bd6 <balancer_ingress+0x1bd6>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    130c:	48 83 7c 24 50 00    	cmpq   $0x0,0x50(%rsp)
    1312:	74 14                	je     1328 <balancer_ingress+0x1328>
    1314:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    1319:	8a 09                	mov    (%rcx),%cl
    131b:	80 e1 02             	and    $0x2,%cl
    131e:	d0 e9                	shr    %cl
    1320:	08 cb                	or     %cl,%bl
    1322:	0f 84 3b 01 00 00    	je     1463 <balancer_ingress+0x1463>
    1328:	89 e8                	mov    %ebp,%eax
    132a:	e9 5f 01 00 00       	jmp    148e <balancer_ingress+0x148e>
    132f:	48 c7 c0 60 92 82 a0 	mov    $0xffffffffa0829260,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1336:	4c 89 ef             	mov    %r13,%rdi
    1339:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    133e:	ff d0                	call   *%rax
    1340:	85 c0                	test   %eax,%eax
    1342:	0f 85 8e 08 00 00    	jne    1bd6 <balancer_ingress+0x1bd6>
  data = (void*)(long)xdp->data;
    1348:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    134c:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1350:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1354:	48 39 ca             	cmp    %rcx,%rdx
    1357:	0f 87 79 08 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    135d:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1361:	bd 01 00 00 00       	mov    $0x1,%ebp
    1366:	48 39 ca             	cmp    %rcx,%rdx
    1369:	0f b7 74 24 5c       	movzwl 0x5c(%rsp),%esi
    136e:	0f 87 67 08 00 00    	ja     1bdb <balancer_ingress+0x1bdb>
    1374:	48 b9 00 a8 b4 07 01 	movabs $0xff11000107b4a800,%rcx
    137b:	00 11 ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    137e:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1385:	66 89 50 04          	mov    %dx,0x4(%rax)
    1389:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    138f:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1391:	8b 48 28             	mov    0x28(%rax),%ecx
    1394:	89 48 06             	mov    %ecx,0x6(%rax)
    1397:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    139b:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    139f:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    13a5:	0f b7 4c 24 28       	movzwl 0x28(%rsp),%ecx
  saddr[3] = src ^ port;
    13aa:	33 4c 24 08          	xor    0x8(%rsp),%ecx
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    13ae:	8a 5c 24 35          	mov    0x35(%rsp),%bl
    __u32* saddr,
    __u32* daddr,
    __u16 payload_len,
    __u8 proto) {
  ip6h->version = 6;
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    13b2:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#ifdef COPY_INNER_PACKET_TOS
  ip6h->priority = (tc & 0xF0) >> 4;
    13b8:	89 da                	mov    %ebx,%edx
    13ba:	c0 ea 04             	shr    $0x4,%dl
    13bd:	80 ca 60             	or     $0x60,%dl
    13c0:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    13c3:	c0 e3 04             	shl    $0x4,%bl
    13c6:	88 58 0f             	mov    %bl,0xf(%rax)
#else
  ip6h->priority = DEFAULT_TOS;
#endif
  ip6h->nexthdr = proto;
    13c9:	66 c7 40 14 04 40    	movw   $0x4004,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    13cf:	66 89 70 12          	mov    %si,0x12(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    13d3:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    13da:	00 
    13db:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    13e2:	89 48 22             	mov    %ecx,0x22(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    13e5:	49 8b 0c 24          	mov    (%r12),%rcx
    13e9:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
    13ee:	e9 d6 08 00 00       	jmp    1cc9 <balancer_ingress+0x1cc9>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    13f3:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    13f7:	48 c1 e1 18          	shl    $0x18,%rcx
    13fb:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    13ff:	48 c1 e2 10          	shl    $0x10,%rdx
    1403:	48 09 ca             	or     %rcx,%rdx
    1406:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    140a:	48 c1 e1 08          	shl    $0x8,%rcx
    140e:	48 09 d1             	or     %rdx,%rcx
    1411:	8a 40 04             	mov    0x4(%rax),%al
    1414:	b2 03                	mov    $0x3,%dl
    1416:	eb 18                	jmp    1430 <balancer_ingress+0x1430>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1418:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    141c:	48 c1 e2 10          	shl    $0x10,%rdx
    1420:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    1424:	48 c1 e1 08          	shl    $0x8,%rcx
    1428:	48 09 d1             	or     %rdx,%rcx
    142b:	8a 40 03             	mov    0x3(%rax),%al
    142e:	b2 02                	mov    $0x2,%dl
    1430:	0f b6 c0             	movzbl %al,%eax
    1433:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    1436:	85 c0                	test   %eax,%eax
    1438:	0f 8e a3 01 00 00    	jle    15e1 <balancer_ingress+0x15e1>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    143e:	80 fa 01             	cmp    $0x1,%dl
    1441:	0f 84 f9 00 00 00    	je     1540 <balancer_ingress+0x1540>
    1447:	80 fa 03             	cmp    $0x3,%dl
    144a:	0f 84 f7 00 00 00    	je     1547 <balancer_ingress+0x1547>
    1450:	80 fa 02             	cmp    $0x2,%dl
    1453:	0f 85 f5 00 00 00    	jne    154e <balancer_ingress+0x154e>
    1459:	b9 40 00 00 00       	mov    $0x40,%ecx
    145e:	e9 f0 00 00 00       	jmp    1553 <balancer_ingress+0x1553>
    if (pckt->flow.proto == IPPROTO_UDP) {
    1463:	80 7c 24 2c 11       	cmpb   $0x11,0x2c(%rsp)
    1468:	75 05                	jne    146f <balancer_ingress+0x146f>
      new_dst_lru.atime = cur_time;
    146a:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    new_dst_lru.pos = key;
    146f:	89 6c 24 40          	mov    %ebp,0x40(%rsp)
    1473:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
		void*,
		(void* map, void* key),
		(void*, void*),
		(map, key))
BPF_MAP_OPS_INLINE(map_update_elem,,
    1478:	48 8b 07             	mov    (%rdi),%rax
    147b:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    1480:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    1485:	31 c9                	xor    %ecx,%ecx
    1487:	ff 50 68             	call   *0x68(%rax)
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    148a:	8b 44 24 30          	mov    0x30(%rsp),%eax
    148e:	48 bf 00 b8 b4 07 01 	movabs $0xff11000107b4b800,%rdi
    1495:	00 11 ff 
    1498:	8b 9f 00 01 00 00    	mov    0x100(%rdi),%ebx
  bool port_match = lru_miss_stat_vip->port == vip->port;
    149e:	0f b7 97 10 01 00 00 	movzwl 0x110(%rdi),%edx
    14a5:	0f b7 74 24 78       	movzwl 0x78(%rsp),%esi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    14aa:	8a 4c 24 7a          	mov    0x7a(%rsp),%cl
    14ae:	88 8f 12 01 00 00    	mov    %cl,0x112(%rdi)
    14b4:	3b 5c 24 68          	cmp    0x68(%rsp),%ebx
  bool vip_match = address_match && port_match && proto_match;
    14b8:	75 3d                	jne    14f7 <balancer_ingress+0x14f7>
    14ba:	66 39 f2             	cmp    %si,%dx
    14bd:	75 38                	jne    14f7 <balancer_ingress+0x14f7>
    14bf:	84 c9                	test   %cl,%cl
    14c1:	74 34                	je     14f7 <balancer_ingress+0x14f7>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    14c3:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    14c8:	0f 87 08 07 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    14ce:	89 c0                	mov    %eax,%eax
    14d0:	48 b9 00 10 22 79 01 	movabs $0xffa0000179221000,%rcx
    14d7:	00 a0 ff 
    14da:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    14e1:	00 
    14e2:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    14e9:	39 a4 
    if (!lru_miss_stat) {
    14eb:	48 85 c0             	test   %rax,%rax
    14ee:	0f 84 e2 06 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
    *lru_miss_stat += 1;
    14f4:	83 00 01             	addl   $0x1,(%rax)
    14f7:	48 8d 04 6d 00 00 00 	lea    0x0(,%rbp,2),%rax
    14fe:	00 
    14ff:	48 01 e8             	add    %rbp,%rax
    1502:	48 b9 00 d0 1f 79 01 	movabs $0xffa00001791fd000,%rcx
    1509:	00 a0 ff 
    150c:	4c 8d 24 c1          	lea    (%rcx,%rax,8),%r12
    1510:	49 81 c4 00 01 00 00 	add    $0x100,%r12
      data_stats->v2 += 1;
    1517:	49 83 46 08 01       	addq   $0x1,0x8(%r14)
    151c:	e9 b7 fa ff ff       	jmp    fd8 <balancer_ingress+0xfd8>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1521:	80 7b 05 08          	cmpb   $0x8,0x5(%rbx)
    1525:	0f 82 20 f8 ff ff    	jb     d4b <balancer_ingress+0xd4b>
    152b:	48 83 c3 06          	add    $0x6,%rbx
    152f:	48 89 d8             	mov    %rbx,%rax
  if (!connId) {
    1532:	48 85 c0             	test   %rax,%rax
    1535:	0f 85 a0 f7 ff ff    	jne    cdb <balancer_ingress+0xcdb>
    153b:	e9 0b f8 ff ff       	jmp    d4b <balancer_ingress+0xd4b>
    1540:	b9 38 00 00 00       	mov    $0x38,%ecx
    1545:	eb 0c                	jmp    1553 <balancer_ingress+0x1553>
    1547:	b9 48 00 00 00       	mov    $0x48,%ecx
    154c:	eb 05                	jmp    1553 <balancer_ingress+0x1553>
    154e:	b9 30 00 00 00       	mov    $0x30,%ecx
    1553:	48 83 44 0d 00 01    	addq   $0x1,0x0(%rbp,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1559:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    155e:	77 76                	ja     15d6 <balancer_ingress+0x15d6>
    1560:	48 b9 00 b0 22 79 01 	movabs $0xffa000017922b000,%rcx
    1567:	00 a0 ff 
          key = *real_pos;
    156a:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    1571:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    1574:	74 60                	je     15d6 <balancer_ingress+0x15d6>
            pckt.real_index = key;
    1576:	89 4c 24 30          	mov    %ecx,0x30(%rsp)
    157a:	31 db                	xor    %ebx,%ebx
            dst = bpf_map_lookup_elem(&reals, &key);
    157c:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    1582:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    1586:	48 b9 00 d0 1f 79 01 	movabs $0xffa00001791fd000,%rcx
    158d:	00 a0 ff 
    1590:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    1597:	00 
    1598:	48 0f 42 d8          	cmovb  %rax,%rbx
            if (!dst) {
    159c:	48 85 db             	test   %rbx,%rbx
    159f:	0f 84 6e 09 00 00    	je     1f13 <balancer_ingress+0x1f13>
    15a5:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    15aa:	48 8b 07             	mov    (%rdi),%rax
    15ad:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    15b2:	ff 50 60             	call   *0x60(%rax)
  if (dst_lru) {
    15b5:	48 85 c0             	test   %rax,%rax
    15b8:	0f 84 62 08 00 00    	je     1e20 <balancer_ingress+0x1e20>
    if (dst_lru->pos == pckt->real_index) {
    15be:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
    15c2:	39 08                	cmp    %ecx,(%rax)
    15c4:	0f 85 53 09 00 00    	jne    1f1d <balancer_ingress+0x1f1d>
              quic_packets_stats->dst_match_in_lru += 1;
    15ca:	48 89 e8             	mov    %rbp,%rax
    15cd:	48 83 c0 50          	add    $0x50,%rax
    15d1:	e9 cd 09 00 00       	jmp    1fa3 <balancer_ingress+0x1fa3>
    15d6:	48 83 45 10 01       	addq   $0x1,0x10(%rbp)
    15db:	48 98                	cltq
    15dd:	48 89 45 18          	mov    %rax,0x18(%rbp)
    15e1:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
    15e6:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
  original_sport = pckt.flow.port16[0];
    15eb:	44 0f b7 7c 24 28    	movzwl 0x28(%rsp),%r15d
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    15f1:	f6 44 24 34 02       	testb  $0x2,0x34(%rsp)
    15f6:	75 47                	jne    163f <balancer_ingress+0x163f>
        !(vip_info->flags & F_LRU_BYPASS)) {
    15f8:	f6 07 02             	testb  $0x2,(%rdi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    15fb:	75 3e                	jne    163b <balancer_ingress+0x163b>
    15fd:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    1602:	48 8b 07             	mov    (%rdi),%rax
    1605:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    160a:	ff 50 60             	call   *0x60(%rax)
  if (!dst_lru) {
    160d:	48 85 c0             	test   %rax,%rax
    1610:	74 29                	je     163b <balancer_ingress+0x163b>
    1612:	48 89 c5             	mov    %rax,%rbp
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1615:	80 7c 24 2c 11       	cmpb   $0x11,0x2c(%rsp)
    161a:	75 2b                	jne    1647 <balancer_ingress+0x1647>
    161c:	48 c7 c0 50 0c 69 9e 	mov    $0xffffffff9e690c50,%rax
    cur_time = bpf_ktime_get_ns();
    1623:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1625:	48 89 c1             	mov    %rax,%rcx
    1628:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    162c:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    1633:	00 00 00 
    1636:	48 39 d1             	cmp    %rdx,%rcx
    1639:	76 08                	jbe    1643 <balancer_ingress+0x1643>
    163b:	31 db                	xor    %ebx,%ebx
    163d:	eb 31                	jmp    1670 <balancer_ingress+0x1670>
    163f:	31 db                	xor    %ebx,%ebx
    1641:	eb 32                	jmp    1675 <balancer_ingress+0x1675>
    dst_lru->atime = cur_time;
    1643:	48 89 45 08          	mov    %rax,0x8(%rbp)
  key = dst_lru->pos;
    1647:	8b 45 00             	mov    0x0(%rbp),%eax
    164a:	31 db                	xor    %ebx,%ebx
    164c:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    1652:	89 44 24 30          	mov    %eax,0x30(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1656:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    165a:	48 b9 00 d0 1f 79 01 	movabs $0xffa00001791fd000,%rcx
    1661:	00 a0 ff 
    1664:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    166b:	00 
    166c:	48 0f 42 d8          	cmovb  %rax,%rbx
    1670:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1675:	80 7c 24 2c 11       	cmpb   $0x11,0x2c(%rsp)
    167a:	0f 85 c1 00 00 00    	jne    1741 <balancer_ingress+0x1741>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1680:	f6 47 01 02          	testb  $0x2,0x1(%rdi)
    1684:	0f 84 b7 00 00 00    	je     1741 <balancer_ingress+0x1741>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    168a:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    1691:	00 11 ff 
    1694:	48 8b a8 10 11 00 00 	mov    0x1110(%rax),%rbp
    169b:	65 48 03 2c 25 28 10 	add    %gs:0xffffffffa4391028,%rbp
    16a2:	39 a4 
  if (!conn_rate_stats) {
    16a4:	48 85 ed             	test   %rbp,%rbp
    16a7:	0f 84 94 00 00 00    	je     1741 <balancer_ingress+0x1741>
    16ad:	48 c7 c0 50 0c 69 9e 	mov    $0xffffffff9e690c50,%rax
  *cur_time = bpf_ktime_get_ns();
    16b4:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    16b6:	48 89 c1             	mov    %rax,%rcx
    16b9:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    16bd:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    16c4:	72 0e                	jb     16d4 <balancer_ingress+0x16d4>
    conn_rate_stats->v1 = 1;
    16c6:	48 c7 45 00 01 00 00 	movq   $0x1,0x0(%rbp)
    16cd:	00 
    conn_rate_stats->v2 = *cur_time;
    16ce:	48 89 45 08          	mov    %rax,0x8(%rbp)
    16d2:	eb 14                	jmp    16e8 <balancer_ingress+0x16e8>
    conn_rate_stats->v1 += 1;
    16d4:	48 8b 45 00          	mov    0x0(%rbp),%rax
    16d8:	48 83 c0 01          	add    $0x1,%rax
    16dc:	48 89 45 00          	mov    %rax,0x0(%rbp)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    16e0:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    16e6:	77 59                	ja     1741 <balancer_ingress+0x1741>
    16e8:	48 bf 00 c8 ad 08 01 	movabs $0xff11000108adc800,%rdi
    16ef:	00 11 ff 
    16f2:	48 8b 07             	mov    (%rdi),%rax
    16f5:	48 8d 74 24 68       	lea    0x68(%rsp),%rsi
    16fa:	ff 50 60             	call   *0x60(%rax)
    if (down_reals_map) {
    16fd:	48 85 c0             	test   %rax,%rax
    1700:	74 3f                	je     1741 <balancer_ingress+0x1741>
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1702:	48 8d 74 24 30       	lea    0x30(%rsp),%rsi
    1707:	48 8b 08             	mov    (%rax),%rcx
    170a:	48 89 c7             	mov    %rax,%rdi
    170d:	ff 51 60             	call   *0x60(%rcx)
      if (down_real) {
    1710:	48 85 c0             	test   %rax,%rax
    1713:	74 2c                	je     1741 <balancer_ingress+0x1741>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1715:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    171c:	00 11 ff 
    171f:	48 8b 80 78 11 00 00 	mov    0x1178(%rax),%rax
    1726:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    172d:	39 a4 
        if (stats_data) {
    172f:	48 85 c0             	test   %rax,%rax
    1732:	0f 84 f8 01 00 00    	je     1930 <balancer_ingress+0x1930>
          stats_data->v1 += 1;
    1738:	48 83 00 01          	addq   $0x1,(%rax)
    173c:	e9 ef 01 00 00       	jmp    1930 <balancer_ingress+0x1930>
    if (!dst) {
    1741:	48 85 db             	test   %rbx,%rbx
    1744:	0f 84 e6 01 00 00    	je     1930 <balancer_ingress+0x1930>
    174a:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    174f:	81 f9 ff 03 00 00    	cmp    $0x3ff,%ecx
    1755:	0f 87 7b 04 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    175b:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    1762:	00 11 ff 
    1765:	48 8b 8c c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rcx
    176c:	00 
    176d:	65 48 03 0c 25 28 10 	add    %gs:0xffffffffa4391028,%rcx
    1774:	39 a4 
  if (!data_stats) {
    1776:	48 85 c9             	test   %rcx,%rcx
    1779:	0f 84 57 04 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
    177f:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
    1783:	66 c1 c0 08          	rol    $0x8,%ax
  data_stats->v1 += 1;
    1787:	48 83 01 01          	addq   $0x1,(%rcx)
    178b:	41 89 c4             	mov    %eax,%r12d
  data_stats->v2 += pkt_bytes;
    178e:	0f b7 c0             	movzwl %ax,%eax
    1791:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1795:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
    1799:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    17a0:	0f 87 30 04 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    17a6:	48 ba 00 70 21 79 01 	movabs $0xffa0000179217000,%rdx
    17ad:	00 a0 ff 
    17b0:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
    17b7:	00 
    17b8:	65 48 03 0c 25 28 10 	add    %gs:0xffffffffa4391028,%rcx
    17bf:	39 a4 
  if (!data_stats) {
    17c1:	48 85 c9             	test   %rcx,%rcx
    17c4:	0f 84 0c 04 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
  data_stats->v1 += 1;
    17ca:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    17ce:	48 01 41 08          	add    %rax,0x8(%rcx)
  pckt.flow.port16[0] = original_sport;
    17d2:	66 44 89 7c 24 28    	mov    %r15w,0x28(%rsp)
  if (dst->flags & F_IPV6) {
    17d8:	f6 43 10 01          	testb  $0x1,0x10(%rbx)
    17dc:	0f 85 31 04 00 00    	jne    1c13 <balancer_ingress+0x1c13>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    17e2:	44 0f b7 74 24 0a    	movzwl 0xa(%rsp),%r14d
    17e8:	48 c7 c0 60 92 82 a0 	mov    $0xffffffffa0829260,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    17ef:	4c 89 ef             	mov    %r13,%rdi
    17f2:	be ec ff ff ff       	mov    $0xffffffec,%esi
    17f7:	ff d0                	call   *%rax
    17f9:	85 c0                	test   %eax,%eax
    17fb:	0f 85 d5 03 00 00    	jne    1bd6 <balancer_ingress+0x1bd6>
  data = (void*)(long)xdp->data;
    1801:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1805:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  iph = data + sizeof(struct ethhdr);
    1809:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    180d:	48 39 ca             	cmp    %rcx,%rdx
    1810:	0f 87 c0 03 00 00    	ja     1bd6 <balancer_ingress+0x1bd6>
    1816:	48 8d 50 22          	lea    0x22(%rax),%rdx
    181a:	bd 01 00 00 00       	mov    $0x1,%ebp
    181f:	48 39 ca             	cmp    %rcx,%rdx
    1822:	0f 87 b3 03 00 00    	ja     1bdb <balancer_ingress+0x1bdb>
    1828:	66 41 c1 c7 08       	rol    $0x8,%r15w
    182d:	45 31 fe             	xor    %r15d,%r14d
    1830:	41 c1 e6 10          	shl    $0x10,%r14d
    1834:	41 8d be ac 10 00 00 	lea    0x10ac(%r14),%edi
    183b:	48 b9 00 a8 b4 07 01 	movabs $0xff11000107b4a800,%rcx
    1842:	00 11 ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1845:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    184c:	66 89 70 04          	mov    %si,0x4(%rax)
    1850:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1856:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1858:	8b 48 14             	mov    0x14(%rax),%ecx
    185b:	89 48 06             	mov    %ecx,0x6(%rax)
    185e:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    1862:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    1866:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    186c:	8a 54 24 35          	mov    0x35(%rsp),%dl
    1870:	8b 0b                	mov    (%rbx),%ecx
  iph->ihl = 5;
    1872:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->tos = tos;
    1876:	88 50 0f             	mov    %dl,0xf(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1879:	41 83 c4 14          	add    $0x14,%r12d
    187d:	66 41 c1 c4 08       	rol    $0x8,%r12w
    1882:	66 44 89 60 10       	mov    %r12w,0x10(%rax)
  iph->id = 0;
    1887:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    188e:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    1891:	89 78 1a             	mov    %edi,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    1894:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    189a:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    189e:	41 0f b7 f4          	movzwl %r12w,%esi
    18a2:	0f b7 78 16          	movzwl 0x16(%rax),%edi
    18a6:	41 c1 ee 10          	shr    $0x10,%r14d
    18aa:	49 01 f6             	add    %rsi,%r14
    18ad:	0f b7 f1             	movzwl %cx,%esi
    18b0:	4c 01 f6             	add    %r14,%rsi
    18b3:	48 c1 e9 10          	shr    $0x10,%rcx
    18b7:	48 01 f1             	add    %rsi,%rcx
    18ba:	48 01 d1             	add    %rdx,%rcx
    18bd:	48 01 f9             	add    %rdi,%rcx
    18c0:	48 81 c1 ac 10 00 00 	add    $0x10ac,%rcx
    18c7:	48 89 ca             	mov    %rcx,%rdx
    18ca:	48 c1 ea 10          	shr    $0x10,%rdx
    18ce:	0f b7 f1             	movzwl %cx,%esi
    18d1:	48 01 d6             	add    %rdx,%rsi
    18d4:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
    18db:	48 0f 42 f1          	cmovb  %rcx,%rsi
    18df:	48 89 f1             	mov    %rsi,%rcx
    18e2:	48 c1 e9 10          	shr    $0x10,%rcx
    18e6:	0f b7 d6             	movzwl %si,%edx
    18e9:	48 01 ca             	add    %rcx,%rdx
    18ec:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    18f3:	48 0f 42 d6          	cmovb  %rsi,%rdx
    18f7:	48 89 d1             	mov    %rdx,%rcx
    18fa:	48 c1 e9 10          	shr    $0x10,%rcx
    18fe:	0f b7 f2             	movzwl %dx,%esi
    1901:	48 01 ce             	add    %rcx,%rsi
    1904:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
    190b:	48 0f 42 f2          	cmovb  %rdx,%rsi
    190f:	89 f1                	mov    %esi,%ecx
    1911:	c1 e9 10             	shr    $0x10,%ecx
    1914:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    191b:	ba 00 00 01 00       	mov    $0x10000,%edx
    1920:	0f 43 d1             	cmovae %ecx,%edx
    1923:	01 f2                	add    %esi,%edx
    1925:	f7 d2                	not    %edx
    1927:	66 89 50 18          	mov    %dx,0x18(%rax)
    192b:	e9 f6 ea ff ff       	jmp    426 <balancer_ingress+0x426>
      if (pckt.flow.proto == IPPROTO_TCP) {
    1930:	80 7c 24 2c 06       	cmpb   $0x6,0x2c(%rsp)
    1935:	75 34                	jne    196b <balancer_ingress+0x196b>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1937:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    193e:	00 11 ff 
    1941:	48 8b 80 08 11 00 00 	mov    0x1108(%rax),%rax
    1948:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    194f:	39 a4 
        if (!lru_stats) {
    1951:	48 85 c0             	test   %rax,%rax
    1954:	0f 84 7c 02 00 00    	je     1bd6 <balancer_ingress+0x1bd6>
        if (pckt.flags & F_SYN_SET) {
    195a:	8b 4c 24 34          	mov    0x34(%rsp),%ecx
    195e:	c1 e1 02             	shl    $0x2,%ecx
    1961:	f7 d1                	not    %ecx
    1963:	83 e1 08             	and    $0x8,%ecx
    1966:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
  struct real_pos_lru new_dst_lru = {};
    196b:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    1972:	00 00 
    1974:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    197b:	00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    197d:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    1984:	00 11 ff 
    1987:	48 8b 98 10 11 00 00 	mov    0x1110(%rax),%rbx
    198e:	65 48 03 1c 25 28 10 	add    %gs:0xffffffffa4391028,%rbx
    1995:	39 a4 
    1997:	41 b4 01             	mov    $0x1,%r12b
  if (!conn_rate_stats) {
    199a:	48 85 db             	test   %rbx,%rbx
    199d:	74 26                	je     19c5 <balancer_ingress+0x19c5>
    199f:	48 c7 c0 50 0c 69 9e 	mov    $0xffffffff9e690c50,%rax
  *cur_time = bpf_ktime_get_ns();
    19a6:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    19a8:	48 89 c1             	mov    %rax,%rcx
    19ab:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    19af:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    19b6:	72 11                	jb     19c9 <balancer_ingress+0x19c9>
    conn_rate_stats->v1 = 1;
    19b8:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    19bf:	48 89 43 08          	mov    %rax,0x8(%rbx)
    19c3:	eb 17                	jmp    19dc <balancer_ingress+0x19dc>
    19c5:	31 c0                	xor    %eax,%eax
    19c7:	eb 16                	jmp    19df <balancer_ingress+0x19df>
    conn_rate_stats->v1 += 1;
    19c9:	48 8b 0b             	mov    (%rbx),%rcx
    19cc:	48 83 c1 01          	add    $0x1,%rcx
    19d0:	48 89 0b             	mov    %rcx,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    19d3:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    19da:	77 03                	ja     19df <balancer_ingress+0x19df>
    19dc:	45 31 e4             	xor    %r12d,%r12d
    19df:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    19e4:	f6 01 08             	testb  $0x8,(%rcx)
    19e7:	75 22                	jne    1a0b <balancer_ingress+0x1a0b>
    19e9:	8b 54 24 08          	mov    0x8(%rsp),%edx
    b += *(u32*)(k + 4);
    19ed:	8b 4c 24 0c          	mov    0xc(%rsp),%ecx
    c += *(u32*)(k + 8);
    19f1:	8b 74 24 10          	mov    0x10(%rsp),%esi
      a += (u32)k[3] << 24;
    19f5:	40 8a 6c 24 17       	mov    0x17(%rsp),%bpl
      a += (u32)k[2] << 16;
    19fa:	44 8a 54 24 16       	mov    0x16(%rsp),%r10b
      a += (u32)k[1] << 8;
    19ff:	44 8a 4c 24 15       	mov    0x15(%rsp),%r9b
      a += k[0];
    1a04:	44 8a 44 24 14       	mov    0x14(%rsp),%r8b
    1a09:	eb 2d                	jmp    1a38 <balancer_ingress+0x1a38>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1a0b:	0f b7 4c 24 2a       	movzwl 0x2a(%rsp),%ecx
    1a10:	66 89 4c 24 28       	mov    %cx,0x28(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    1a15:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    1a1c:	00 00 
    1a1e:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    1a25:	00 00 
    1a27:	45 31 c0             	xor    %r8d,%r8d
    1a2a:	45 31 c9             	xor    %r9d,%r9d
    1a2d:	45 31 d2             	xor    %r10d,%r10d
    1a30:	31 ed                	xor    %ebp,%ebp
    1a32:	31 f6                	xor    %esi,%esi
    1a34:	31 c9                	xor    %ecx,%ecx
    1a36:	31 d2                	xor    %edx,%edx
    c += *(u32*)(k + 8);
    1a38:	8d 9e ff c0 ad de    	lea    -0x21523f01(%rsi),%ebx
    __jhash_mix(a, b, c);
    1a3e:	29 f2                	sub    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1a40:	c1 c3 04             	rol    $0x4,%ebx
    __jhash_mix(a, b, c);
    1a43:	31 d3                	xor    %edx,%ebx
    b += *(u32*)(k + 4);
    1a45:	89 ca                	mov    %ecx,%edx
    1a47:	81 c2 ff c0 ad de    	add    $0xdeadc0ff,%edx
    __jhash_mix(a, b, c);
    1a4d:	01 ce                	add    %ecx,%esi
    1a4f:	81 c6 fe 81 5b bd    	add    $0xbd5b81fe,%esi
    1a55:	29 da                	sub    %ebx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1a57:	89 df                	mov    %ebx,%edi
    1a59:	c1 c7 06             	rol    $0x6,%edi
    __jhash_mix(a, b, c);
    1a5c:	31 d7                	xor    %edx,%edi
    1a5e:	01 f3                	add    %esi,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1a60:	89 f9                	mov    %edi,%ecx
    1a62:	c1 c1 08             	rol    $0x8,%ecx
    __jhash_mix(a, b, c);
    1a65:	29 fe                	sub    %edi,%esi
    1a67:	31 f1                	xor    %esi,%ecx
    1a69:	01 df                	add    %ebx,%edi
    1a6b:	29 cb                	sub    %ecx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1a6d:	89 ce                	mov    %ecx,%esi
    1a6f:	c1 c6 10             	rol    $0x10,%esi
    __jhash_mix(a, b, c);
    1a72:	31 de                	xor    %ebx,%esi
    1a74:	01 f9                	add    %edi,%ecx
    1a76:	29 f7                	sub    %esi,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    1a78:	89 f3                	mov    %esi,%ebx
    1a7a:	c1 c3 13             	rol    $0x13,%ebx
    __jhash_mix(a, b, c);
    1a7d:	31 fb                	xor    %edi,%ebx
    1a7f:	01 ce                	add    %ecx,%esi
    1a81:	29 d9                	sub    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1a83:	41 89 db             	mov    %ebx,%r11d
    1a86:	41 c1 c3 04          	rol    $0x4,%r11d
    __jhash_mix(a, b, c);
    1a8a:	01 f3                	add    %esi,%ebx
      a += (u32)k[3] << 24;
    1a8c:	40 0f b6 d5          	movzbl %bpl,%edx
    1a90:	c1 e2 18             	shl    $0x18,%edx
      a += (u32)k[2] << 16;
    1a93:	41 0f b6 ea          	movzbl %r10b,%ebp
    1a97:	c1 e5 10             	shl    $0x10,%ebp
      a += (u32)k[3] << 24;
    1a9a:	09 d5                	or     %edx,%ebp
      a += (u32)k[1] << 8;
    1a9c:	41 0f b6 f9          	movzbl %r9b,%edi
    1aa0:	c1 e7 08             	shl    $0x8,%edi
      a += (u32)k[2] << 16;
    1aa3:	09 ef                	or     %ebp,%edi
      a += k[0];
    1aa5:	41 0f b6 d0          	movzbl %r8b,%edx
      a += (u32)k[1] << 8;
    1aa9:	09 fa                	or     %edi,%edx
      a += k[0];
    1aab:	01 f2                	add    %esi,%edx
    __jhash_mix(a, b, c);
    1aad:	31 d9                	xor    %ebx,%ecx
      __jhash_final(a, b, c);
    1aaf:	44 31 d9             	xor    %r11d,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1ab2:	89 de                	mov    %ebx,%esi
    1ab4:	c1 c6 0e             	rol    $0xe,%esi
      __jhash_final(a, b, c);
    1ab7:	29 f1                	sub    %esi,%ecx
    1ab9:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1abb:	89 ce                	mov    %ecx,%esi
    1abd:	c1 c6 0b             	rol    $0xb,%esi
      __jhash_final(a, b, c);
    1ac0:	29 f2                	sub    %esi,%edx
    1ac2:	31 d3                	xor    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1ac4:	89 d6                	mov    %edx,%esi
    1ac6:	c1 c6 19             	rol    $0x19,%esi
      __jhash_final(a, b, c);
    1ac9:	29 f3                	sub    %esi,%ebx
    1acb:	31 d9                	xor    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1acd:	89 de                	mov    %ebx,%esi
    1acf:	c1 c6 10             	rol    $0x10,%esi
      __jhash_final(a, b, c);
    1ad2:	29 f1                	sub    %esi,%ecx
    1ad4:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1ad6:	89 ce                	mov    %ecx,%esi
    1ad8:	c1 c6 04             	rol    $0x4,%esi
      __jhash_final(a, b, c);
    1adb:	29 f2                	sub    %esi,%edx
    1add:	31 d3                	xor    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1adf:	c1 c2 0e             	rol    $0xe,%edx
      __jhash_final(a, b, c);
    1ae2:	29 d3                	sub    %edx,%ebx
    1ae4:	31 d9                	xor    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1ae6:	c1 c3 18             	rol    $0x18,%ebx
  a += initval;
    1ae9:	29 d9                	sub    %ebx,%ecx
    1aeb:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  b += initval;
    1af0:	03 74 24 28          	add    0x28(%rsp),%esi
  a += initval;
    1af4:	81 c1 f7 c0 ad e0    	add    $0xe0adc0f7,%ecx
  __jhash_final(a, b, c);
    1afa:	89 f2                	mov    %esi,%edx
    1afc:	81 f2 f7 c0 ad e0    	xor    $0xe0adc0f7,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1b02:	89 f7                	mov    %esi,%edi
    1b04:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    1b07:	29 fa                	sub    %edi,%edx
    1b09:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1b0b:	89 d7                	mov    %edx,%edi
    1b0d:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    1b10:	29 f9                	sub    %edi,%ecx
    1b12:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1b14:	89 cf                	mov    %ecx,%edi
    1b16:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    1b19:	29 fe                	sub    %edi,%esi
    1b1b:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1b1d:	89 f7                	mov    %esi,%edi
    1b1f:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    1b22:	29 fa                	sub    %edi,%edx
    1b24:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1b26:	89 d7                	mov    %edx,%edi
    1b28:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1b2b:	29 f9                	sub    %edi,%ecx
    1b2d:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1b2f:	c1 c1 0e             	rol    $0xe,%ecx
  __jhash_final(a, b, c);
    1b32:	29 ce                	sub    %ecx,%esi
    1b34:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1b36:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    1b39:	29 f2                	sub    %esi,%edx
    1b3b:	b9 01 00 ff ff       	mov    $0xffff0001,%ecx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1b40:	48 0f af ca          	imul   %rdx,%rcx
    1b44:	48 c1 e9 30          	shr    $0x30,%rcx
    1b48:	89 ce                	mov    %ecx,%esi
    1b4a:	c1 e6 10             	shl    $0x10,%esi
    1b4d:	09 ce                	or     %ecx,%esi
    1b4f:	29 f2                	sub    %esi,%edx
    1b51:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1b56:	8b 71 04             	mov    0x4(%rcx),%esi
    1b59:	89 f1                	mov    %esi,%ecx
    1b5b:	c1 e1 10             	shl    $0x10,%ecx
    1b5e:	01 f1                	add    %esi,%ecx
    1b60:	01 d1                	add    %edx,%ecx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1b62:	81 f9 ff 01 00 02    	cmp    $0x20001ff,%ecx
    if (!real_pos) {
    1b68:	77 6c                	ja     1bd6 <balancer_ingress+0x1bd6>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1b6a:	89 c9                	mov    %ecx,%ecx
    1b6c:	48 ba 00 a0 1f 69 01 	movabs $0xffa00001691fa000,%rdx
    1b73:	00 a0 ff 
    key = *real_pos;
    1b76:	8b ac ca 00 01 00 00 	mov    0x100(%rdx,%rcx,8),%ebp
    1b7d:	48 85 ed             	test   %rbp,%rbp
    if (key == 0) {
    1b80:	74 2d                	je     1baf <balancer_ingress+0x1baf>
  pckt->real_index = key;
    1b82:	89 6c 24 30          	mov    %ebp,0x30(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1b86:	81 fd 00 10 00 00    	cmp    $0x1000,%ebp
  if (!(*real)) {
    1b8c:	72 61                	jb     1bef <balancer_ingress+0x1bef>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1b8e:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    1b95:	00 11 ff 
    1b98:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1b9f:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    1ba6:	39 a4 
  if (!ch_drop_stats) {
    1ba8:	48 85 c0             	test   %rax,%rax
    1bab:	75 25                	jne    1bd2 <balancer_ingress+0x1bd2>
    1bad:	eb 27                	jmp    1bd6 <balancer_ingress+0x1bd6>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1baf:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    1bb6:	00 11 ff 
    1bb9:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1bc0:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    1bc7:	39 a4 
  if (!ch_drop_stats) {
    1bc9:	48 85 c0             	test   %rax,%rax
    1bcc:	74 08                	je     1bd6 <balancer_ingress+0x1bd6>
    1bce:	48 83 c0 08          	add    $0x8,%rax
    1bd2:	48 83 00 01          	addq   $0x1,(%rax)
    1bd6:	bd 01 00 00 00       	mov    $0x1,%ebp
    return process_packet(ctx, nh_off, true);
  } else {
    // pass to tcp/ip stack
    return XDP_PASS;
  }
}
    1bdb:	89 e8                	mov    %ebp,%eax
    1bdd:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    1be4:	5b                   	pop    %rbx
    1be5:	41 5c                	pop    %r12
    1be7:	41 5d                	pop    %r13
    1be9:	41 5e                	pop    %r14
    1beb:	41 5f                	pop    %r15
    1bed:	5d                   	pop    %rbp
    1bee:	c3                   	ret
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1bef:	48 83 7c 24 50 00    	cmpq   $0x0,0x50(%rsp)
    1bf5:	74 15                	je     1c0c <balancer_ingress+0x1c0c>
    1bf7:	48 8b 4c 24 38       	mov    0x38(%rsp),%rcx
    1bfc:	8a 09                	mov    (%rcx),%cl
    1bfe:	80 e1 02             	and    $0x2,%cl
    1c01:	d0 e9                	shr    %cl
    1c03:	41 08 cc             	or     %cl,%r12b
    1c06:	0f 84 ca 00 00 00    	je     1cd6 <balancer_ingress+0x1cd6>
    1c0c:	89 e8                	mov    %ebp,%eax
    1c0e:	e9 ee 00 00 00       	jmp    1d01 <balancer_ingress+0x1d01>
    1c13:	48 c7 c0 60 92 82 a0 	mov    $0xffffffffa0829260,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1c1a:	4c 89 ef             	mov    %r13,%rdi
    1c1d:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1c22:	ff d0                	call   *%rax
    1c24:	85 c0                	test   %eax,%eax
    1c26:	75 ae                	jne    1bd6 <balancer_ingress+0x1bd6>
  data = (void*)(long)xdp->data;
    1c28:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1c2c:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1c30:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1c34:	48 39 ca             	cmp    %rcx,%rdx
    1c37:	77 9d                	ja     1bd6 <balancer_ingress+0x1bd6>
    1c39:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1c3d:	bd 01 00 00 00       	mov    $0x1,%ebp
    1c42:	48 39 ca             	cmp    %rcx,%rdx
    1c45:	77 94                	ja     1bdb <balancer_ingress+0x1bdb>
    1c47:	48 b9 00 a8 b4 07 01 	movabs $0xff11000107b4a800,%rcx
    1c4e:	00 11 ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1c51:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1c58:	66 89 50 04          	mov    %dx,0x4(%rax)
    1c5c:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1c62:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1c64:	8b 48 28             	mov    0x28(%rax),%ecx
    1c67:	89 48 06             	mov    %ecx,0x6(%rax)
    1c6a:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    1c6e:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    1c72:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    1c78:	0f b7 74 24 28       	movzwl 0x28(%rsp),%esi
  saddr[3] = src ^ port;
    1c7d:	33 74 24 14          	xor    0x14(%rsp),%esi
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    1c81:	41 83 c4 28          	add    $0x28,%r12d
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1c85:	8a 4c 24 35          	mov    0x35(%rsp),%cl
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1c89:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    1c8f:	89 ca                	mov    %ecx,%edx
    1c91:	c0 ea 04             	shr    $0x4,%dl
    1c94:	80 ca 60             	or     $0x60,%dl
    1c97:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1c9a:	c0 e1 04             	shl    $0x4,%cl
    1c9d:	88 48 0f             	mov    %cl,0xf(%rax)
  ip6h->nexthdr = proto;
    1ca0:	66 c7 40 14 29 40    	movw   $0x4029,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    1ca6:	66 41 c1 c4 08       	rol    $0x8,%r12w
    1cab:	66 44 89 60 12       	mov    %r12w,0x12(%rax)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    1cb0:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    1cb7:	00 
    1cb8:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    1cbf:	89 70 22             	mov    %esi,0x22(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    1cc2:	48 8b 0b             	mov    (%rbx),%rcx
    1cc5:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    1cc9:	48 89 48 26          	mov    %rcx,0x26(%rax)
    1ccd:	48 89 50 2e          	mov    %rdx,0x2e(%rax)
    1cd1:	e9 50 e7 ff ff       	jmp    426 <balancer_ingress+0x426>
    if (pckt->flow.proto == IPPROTO_UDP) {
    1cd6:	80 7c 24 2c 11       	cmpb   $0x11,0x2c(%rsp)
    1cdb:	75 05                	jne    1ce2 <balancer_ingress+0x1ce2>
      new_dst_lru.atime = cur_time;
    1cdd:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    new_dst_lru.pos = key;
    1ce2:	89 6c 24 40          	mov    %ebp,0x40(%rsp)
    1ce6:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_update_elem,,
    1ceb:	48 8b 07             	mov    (%rdi),%rax
    1cee:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    1cf3:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    1cf8:	31 c9                	xor    %ecx,%ecx
    1cfa:	ff 50 68             	call   *0x68(%rax)
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    1cfd:	8b 44 24 30          	mov    0x30(%rsp),%eax
    1d01:	48 b9 00 b8 b4 07 01 	movabs $0xff11000107b4b800,%rcx
    1d08:	00 11 ff 
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    1d0b:	8b b1 00 01 00 00    	mov    0x100(%rcx),%esi
    1d11:	b2 01                	mov    $0x1,%dl
    1d13:	3b 74 24 68          	cmp    0x68(%rsp),%esi
    1d17:	75 25                	jne    1d3e <balancer_ingress+0x1d3e>
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    1d19:	8b b1 04 01 00 00    	mov    0x104(%rcx),%esi
    1d1f:	3b 74 24 6c          	cmp    0x6c(%rsp),%esi
    1d23:	75 19                	jne    1d3e <balancer_ingress+0x1d3e>
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    1d25:	8b b1 08 01 00 00    	mov    0x108(%rcx),%esi
    1d2b:	3b 74 24 70          	cmp    0x70(%rsp),%esi
    1d2f:	75 0d                	jne    1d3e <balancer_ingress+0x1d3e>
    1d31:	8b 91 0c 01 00 00    	mov    0x10c(%rcx),%edx
    1d37:	3b 54 24 74          	cmp    0x74(%rsp),%edx
    1d3b:	0f 95 c2             	setne  %dl
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1d3e:	0f b7 b1 10 01 00 00 	movzwl 0x110(%rcx),%esi
    1d45:	0f b7 7c 24 78       	movzwl 0x78(%rsp),%edi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1d4a:	8a 5c 24 7a          	mov    0x7a(%rsp),%bl
    1d4e:	88 99 12 01 00 00    	mov    %bl,0x112(%rcx)
  bool vip_match = address_match && port_match && proto_match;
    1d54:	84 d2                	test   %dl,%dl
    1d56:	75 3d                	jne    1d95 <balancer_ingress+0x1d95>
    1d58:	66 39 fe             	cmp    %di,%si
    1d5b:	75 38                	jne    1d95 <balancer_ingress+0x1d95>
    1d5d:	84 db                	test   %bl,%bl
    1d5f:	74 34                	je     1d95 <balancer_ingress+0x1d95>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1d61:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    1d66:	0f 87 6a fe ff ff    	ja     1bd6 <balancer_ingress+0x1bd6>
    1d6c:	89 c0                	mov    %eax,%eax
    1d6e:	48 b9 00 10 22 79 01 	movabs $0xffa0000179221000,%rcx
    1d75:	00 a0 ff 
    1d78:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    1d7f:	00 
    1d80:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    1d87:	39 a4 
    if (!lru_miss_stat) {
    1d89:	48 85 c0             	test   %rax,%rax
    1d8c:	0f 84 44 fe ff ff    	je     1bd6 <balancer_ingress+0x1bd6>
    *lru_miss_stat += 1;
    1d92:	83 00 01             	addl   $0x1,(%rax)
    1d95:	48 8d 04 6d 00 00 00 	lea    0x0(,%rbp,2),%rax
    1d9c:	00 
    1d9d:	48 01 e8             	add    %rbp,%rax
    1da0:	48 b9 00 d0 1f 79 01 	movabs $0xffa00001791fd000,%rcx
    1da7:	00 a0 ff 
    1daa:	48 8d 1c c1          	lea    (%rcx,%rax,8),%rbx
    1dae:	48 81 c3 00 01 00 00 	add    $0x100,%rbx
      data_stats->v2 += 1;
    1db5:	49 83 46 08 01       	addq   $0x1,0x8(%r14)
    1dba:	e9 8b f9 ff ff       	jmp    174a <balancer_ingress+0x174a>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1dbf:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    1dc3:	48 c1 e1 18          	shl    $0x18,%rcx
    1dc7:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    1dcb:	48 c1 e2 10          	shl    $0x10,%rdx
    1dcf:	48 09 ca             	or     %rcx,%rdx
    1dd2:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    1dd6:	48 c1 e1 08          	shl    $0x8,%rcx
    1dda:	48 09 d1             	or     %rdx,%rcx
    1ddd:	8a 40 04             	mov    0x4(%rax),%al
    1de0:	b2 03                	mov    $0x3,%dl
    1de2:	eb 18                	jmp    1dfc <balancer_ingress+0x1dfc>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1de4:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    1de8:	48 c1 e2 10          	shl    $0x10,%rdx
    1dec:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    1df0:	48 c1 e1 08          	shl    $0x8,%rcx
    1df4:	48 09 d1             	or     %rdx,%rcx
    1df7:	8a 40 03             	mov    0x3(%rax),%al
    1dfa:	b2 02                	mov    $0x2,%dl
    1dfc:	0f b6 c0             	movzbl %al,%eax
    1dff:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    1e02:	85 c0                	test   %eax,%eax
    1e04:	0f 8e 41 ef ff ff    	jle    d4b <balancer_ingress+0xd4b>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1e0a:	80 fa 01             	cmp    $0x1,%dl
    1e0d:	74 61                	je     1e70 <balancer_ingress+0x1e70>
    1e0f:	80 fa 03             	cmp    $0x3,%dl
    1e12:	74 63                	je     1e77 <balancer_ingress+0x1e77>
    1e14:	80 fa 02             	cmp    $0x2,%dl
    1e17:	75 65                	jne    1e7e <balancer_ingress+0x1e7e>
    1e19:	b9 40 00 00 00       	mov    $0x40,%ecx
    1e1e:	eb 63                	jmp    1e83 <balancer_ingress+0x1e83>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1e20:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    1e27:	00 11 ff 
    1e2a:	4c 8b b0 10 11 00 00 	mov    0x1110(%rax),%r14
    1e31:	65 4c 03 34 25 28 10 	add    %gs:0xffffffffa4391028,%r14
    1e38:	39 a4 
  if (!conn_rate_stats) {
    1e3a:	4d 85 f6             	test   %r14,%r14
    1e3d:	0f 84 59 01 00 00    	je     1f9c <balancer_ingress+0x1f9c>
    1e43:	48 c7 c0 50 0c 69 9e 	mov    $0xffffffff9e690c50,%rax
  *cur_time = bpf_ktime_get_ns();
    1e4a:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1e4c:	48 89 c1             	mov    %rax,%rcx
    1e4f:	49 2b 4e 08          	sub    0x8(%r14),%rcx
    1e53:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1e5a:	0f 82 f9 00 00 00    	jb     1f59 <balancer_ingress+0x1f59>
    conn_rate_stats->v1 = 1;
    1e60:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    conn_rate_stats->v2 = *cur_time;
    1e67:	49 89 46 08          	mov    %rax,0x8(%r14)
    1e6b:	e9 fb 00 00 00       	jmp    1f6b <balancer_ingress+0x1f6b>
    1e70:	b9 38 00 00 00       	mov    $0x38,%ecx
    1e75:	eb 0c                	jmp    1e83 <balancer_ingress+0x1e83>
    1e77:	b9 48 00 00 00       	mov    $0x48,%ecx
    1e7c:	eb 05                	jmp    1e83 <balancer_ingress+0x1e83>
    1e7e:	b9 30 00 00 00       	mov    $0x30,%ecx
    1e83:	48 83 44 0d 00 01    	addq   $0x1,0x0(%rbp,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1e89:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    1e8e:	77 73                	ja     1f03 <balancer_ingress+0x1f03>
    1e90:	48 b9 00 b0 22 79 01 	movabs $0xffa000017922b000,%rcx
    1e97:	00 a0 ff 
          key = *real_pos;
    1e9a:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    1ea1:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    1ea4:	74 5d                	je     1f03 <balancer_ingress+0x1f03>
            pckt.real_index = key;
    1ea6:	89 4c 24 30          	mov    %ecx,0x30(%rsp)
    1eaa:	45 31 e4             	xor    %r12d,%r12d
            dst = bpf_map_lookup_elem(&reals, &key);
    1ead:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    1eb3:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    1eb7:	48 b9 00 d0 1f 79 01 	movabs $0xffa00001791fd000,%rcx
    1ebe:	00 a0 ff 
    1ec1:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    1ec8:	00 
    1ec9:	4c 0f 42 e0          	cmovb  %rax,%r12
            if (!dst) {
    1ecd:	4d 85 e4             	test   %r12,%r12
    1ed0:	74 41                	je     1f13 <balancer_ingress+0x1f13>
    1ed2:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    1ed7:	48 8b 07             	mov    (%rdi),%rax
    1eda:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    1edf:	ff 50 60             	call   *0x60(%rax)
  if (dst_lru) {
    1ee2:	48 85 c0             	test   %rax,%rax
    1ee5:	0f 84 cc 00 00 00    	je     1fb7 <balancer_ingress+0x1fb7>
    if (dst_lru->pos == pckt->real_index) {
    1eeb:	8b 4c 24 30          	mov    0x30(%rsp),%ecx
    1eef:	39 08                	cmp    %ecx,(%rax)
    1ef1:	0f 85 09 01 00 00    	jne    2000 <balancer_ingress+0x2000>
              quic_packets_stats->dst_match_in_lru += 1;
    1ef7:	48 89 e8             	mov    %rbp,%rax
    1efa:	48 83 c0 50          	add    $0x50,%rax
    1efe:	e9 83 01 00 00       	jmp    2086 <balancer_ingress+0x2086>
    1f03:	48 83 45 10 01       	addq   $0x1,0x10(%rbp)
    1f08:	48 98                	cltq
    1f0a:	48 89 45 18          	mov    %rax,0x18(%rbp)
    1f0e:	e9 38 ee ff ff       	jmp    d4b <balancer_ingress+0xd4b>
    1f13:	48 83 45 28 01       	addq   $0x1,0x28(%rbp)
    1f18:	e9 b9 fc ff ff       	jmp    1bd6 <balancer_ingress+0x1bd6>
      dst_lru->pos = pckt->real_index;
    1f1d:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1f1f:	48 83 45 58 01       	addq   $0x1,0x58(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1f24:	81 7c 24 60 ff 01 00 	cmpl   $0x1ff,0x60(%rsp)
    1f2b:	00 
    1f2c:	77 79                	ja     1fa7 <balancer_ingress+0x1fa7>
    1f2e:	48 b8 00 c0 e6 53 01 	movabs $0xff11000153e6c000,%rax
    1f35:	00 11 ff 
    1f38:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
    1f3d:	48 8b 84 c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rax
    1f44:	00 
    1f45:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    1f4c:	39 a4 
  if (!per_vip_stats) {
    1f4e:	48 85 c0             	test   %rax,%rax
    1f51:	74 54                	je     1fa7 <balancer_ingress+0x1fa7>
    per_vip_stats->v2 += 1;
    1f53:	48 83 c0 08          	add    $0x8,%rax
    1f57:	eb 4a                	jmp    1fa3 <balancer_ingress+0x1fa3>
    conn_rate_stats->v1 += 1;
    1f59:	49 8b 06             	mov    (%r14),%rax
    1f5c:	48 83 c0 01          	add    $0x1,%rax
    1f60:	49 89 06             	mov    %rax,(%r14)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1f63:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    1f69:	77 31                	ja     1f9c <balancer_ingress+0x1f9c>
  struct real_pos_lru new_dst_lru = {};
    1f6b:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    1f72:	00 00 
    1f74:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    1f7b:	00 00 
  new_dst_lru.pos = pckt->real_index;
    1f7d:	8b 44 24 30          	mov    0x30(%rsp),%eax
    1f81:	89 44 24 40          	mov    %eax,0x40(%rsp)
    1f85:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_update_elem,,
    1f8a:	48 8b 07             	mov    (%rdi),%rax
    1f8d:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    1f92:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    1f97:	31 c9                	xor    %ecx,%ecx
    1f99:	ff 50 68             	call   *0x68(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    1f9c:	48 89 e8             	mov    %rbp,%rax
    1f9f:	48 83 c0 60          	add    $0x60,%rax
    1fa3:	48 83 00 01          	addq   $0x1,(%rax)
            quic_packets_stats->cid_routed += 1;
    1fa7:	48 83 45 20 01       	addq   $0x1,0x20(%rbp)
  original_sport = pckt.flow.port16[0];
    1fac:	44 0f b7 7c 24 28    	movzwl 0x28(%rsp),%r15d
    1fb2:	e9 93 f7 ff ff       	jmp    174a <balancer_ingress+0x174a>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1fb7:	48 b8 00 c0 96 2e 01 	movabs $0xff1100012e96c000,%rax
    1fbe:	00 11 ff 
    1fc1:	48 8b 98 10 11 00 00 	mov    0x1110(%rax),%rbx
    1fc8:	65 48 03 1c 25 28 10 	add    %gs:0xffffffffa4391028,%rbx
    1fcf:	39 a4 
  if (!conn_rate_stats) {
    1fd1:	48 85 db             	test   %rbx,%rbx
    1fd4:	0f 84 a5 00 00 00    	je     207f <balancer_ingress+0x207f>
    1fda:	48 c7 c0 50 0c 69 9e 	mov    $0xffffffff9e690c50,%rax
  *cur_time = bpf_ktime_get_ns();
    1fe1:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1fe3:	48 89 c1             	mov    %rax,%rcx
    1fe6:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1fea:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1ff1:	72 49                	jb     203c <balancer_ingress+0x203c>
    conn_rate_stats->v1 = 1;
    1ff3:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1ffa:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1ffe:	eb 4e                	jmp    204e <balancer_ingress+0x204e>
      dst_lru->pos = pckt->real_index;
    2000:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    2002:	48 83 45 58 01       	addq   $0x1,0x58(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2007:	81 7c 24 60 ff 01 00 	cmpl   $0x1ff,0x60(%rsp)
    200e:	00 
    200f:	77 79                	ja     208a <balancer_ingress+0x208a>
    2011:	48 b8 00 c0 e6 53 01 	movabs $0xff11000153e6c000,%rax
    2018:	00 11 ff 
    201b:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
    2020:	48 8b 84 c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rax
    2027:	00 
    2028:	65 48 03 04 25 28 10 	add    %gs:0xffffffffa4391028,%rax
    202f:	39 a4 
  if (!per_vip_stats) {
    2031:	48 85 c0             	test   %rax,%rax
    2034:	74 54                	je     208a <balancer_ingress+0x208a>
    per_vip_stats->v2 += 1;
    2036:	48 83 c0 08          	add    $0x8,%rax
    203a:	eb 4a                	jmp    2086 <balancer_ingress+0x2086>
    conn_rate_stats->v1 += 1;
    203c:	48 8b 03             	mov    (%rbx),%rax
    203f:	48 83 c0 01          	add    $0x1,%rax
    2043:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2046:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    204c:	77 31                	ja     207f <balancer_ingress+0x207f>
  struct real_pos_lru new_dst_lru = {};
    204e:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    2055:	00 00 
    2057:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    205e:	00 00 
  new_dst_lru.pos = pckt->real_index;
    2060:	8b 44 24 30          	mov    0x30(%rsp),%eax
    2064:	89 44 24 40          	mov    %eax,0x40(%rsp)
    2068:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    206d:	48 8b 07             	mov    (%rdi),%rax
    2070:	48 8d 74 24 08       	lea    0x8(%rsp),%rsi
    2075:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    207a:	31 c9                	xor    %ecx,%ecx
    207c:	ff 50 68             	call   *0x68(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    207f:	48 89 e8             	mov    %rbp,%rax
    2082:	48 83 c0 60          	add    $0x60,%rax
    2086:	48 83 00 01          	addq   $0x1,(%rax)
            quic_packets_stats->cid_routed += 1;
    208a:	48 83 45 20 01       	addq   $0x1,0x20(%rbp)
  original_sport = pckt.flow.port16[0];
    208f:	44 0f b7 7c 24 28    	movzwl 0x28(%rsp),%r15d
    2095:	e9 3e ef ff ff       	jmp    fd8 <balancer_ingress+0xfd8>

Disassembly of section license:

000000000000209a <_license>:
    209a:	47 50                	rex.RXB push %r8
    209c:	4c                   	rex.WR
	...

Disassembly of section .maps:

00000000000020a0 <.maps>:
	...

Disassembly of section .debug_loclists:

0000000000000000 <.debug_loclists>:
  void* data = (void*)(long)ctx->data;
       0:	69 2c 00 00 05 00 08 	imul   $0x8000500,(%rax,%rax,1),%ebp
       7:	00 78 01             	add    %bh,0x1(%rax)
       a:	00 00                	add    %al,(%rax)
       c:	e0 05                	loopne 13 <balancer_ingress+0x13>
       e:	00 00                	add    %al,(%rax)
      10:	fd                   	std
      11:	05 00 00 19 06       	add    $0x6190000,%eax
      16:	00 00                	add    %al,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
      18:	51                   	push   %rcx
      19:	06                   	(bad)
      1a:	00 00                	add    %al,(%rax)
  if (data + nh_off > data_end) {
      1c:	6d                   	insl   (%dx),%es:(%rdi)
      1d:	06                   	(bad)
      1e:	00 00                	add    %al,(%rax)
      20:	75 06                	jne    28 <balancer_ingress+0x28>
      22:	00 00                	add    %al,(%rax)
      24:	bd 06 00 00 1f       	mov    $0x1f000006,%ebp
      29:	07                   	(bad)
      2a:	00 00                	add    %al,(%rax)
      2c:	8f 07                	pop    (%rdi)
      2e:	00 00                	add    %al,(%rax)
      30:	ff 07                	incl   (%rdi)
  eth_proto = eth->h_proto;
      32:	00 00                	add    %al,(%rax)
      34:	3e 08 00             	ds or  %al,(%rax)
  if (eth_proto == BE_ETH_P_IP) {
      37:	00 99 08 00 00 25    	add    %bl,0x25000008(%rcx)
      3d:	09 00                	or     %eax,(%rax)
      3f:	00 2d 09 00 00 a5    	add    %ch,-0x5afffff7(%rip)        # ffffffffa500004e <server_id_map+0x5ffffe2bdd504e>
      45:	09 00                	or     %eax,(%rax)
      47:	00 2e                	add    %ch,(%rsi)
      49:	0a 00                	or     (%rax),%al
      4b:	00 b7 0a 00 00 f0    	add    %dh,-0xffffff6(%rdi)
  struct packet_description pckt = {};
      51:	0a 00                	or     (%rax),%al
      53:	00 53 0b             	add    %dl,0xb(%rbx)
      56:	00 00                	add    %al,(%rax)
      58:	e6 0b                	out    %al,$0xb
      5a:	00 00                	add    %al,(%rax)
      5c:	ee                   	out    %al,(%dx)
      5d:	0b 00                	or     (%rax),%eax
      5f:	00 57 0c             	add    %dl,0xc(%rdi)
      62:	00 00                	add    %al,(%rax)
      64:	82                   	(bad)
      65:	0c 00                	or     $0x0,%al
      67:	00 95 0c 00 00 a6    	add    %dl,-0x59fffff4(%rbp)
      6d:	0c 00                	or     $0x0,%al
      6f:	00 b5 0c 00 00 c4    	add    %dh,-0x3bfffff4(%rbp)
      75:	0c 00                	or     $0x0,%al
      77:	00 d5                	add    %dl,%ch
      79:	0c 00                	or     $0x0,%al
      7b:	00 e6                	add    %ah,%dh
      7d:	0c 00                	or     $0x0,%al
      7f:	00 f5                	add    %dh,%ch
      81:	0c 00                	or     $0x0,%al
      83:	00 04 0d 00 00 20 0d 	add    %al,0xd200000(,%rcx,1)
      8a:	00 00                	add    %al,(%rax)
  bpf_tail_call(xdp, &subprograms, 0);
      8c:	33 0d 00 00 42 0d    	xor    0xd420000(%rip),%ecx        # d420092 <_license+0xd41dff8>
      92:	00 00                	add    %al,(%rax)
      94:	52                   	push   %rdx
      95:	0d 00 00 92 0d       	or     $0xd920000,%eax
      9a:	00 00                	add    %al,(%rax)
      9c:	cb                   	lret
      9d:	0d 00 00 4c 0e       	or     $0xe4c0000,%eax
      a2:	00 00                	add    %al,(%rax)
      a4:	80 0e 00             	orb    $0x0,(%rsi)
  struct packet_description pckt = {};
      a7:	00 93 0e 00 00 a4    	add    %dl,-0x5bfffff2(%rbx)
      ad:	0e                   	(bad)
      ae:	00 00                	add    %al,(%rax)
      b0:	b3 0e                	mov    $0xe,%bl
      b2:	00 00                	add    %al,(%rax)
      b4:	c2 0e 00             	ret    $0xe
      b7:	00 d3                	add    %dl,%bl
      b9:	0e                   	(bad)
      ba:	00 00                	add    %al,(%rax)
      bc:	dd 0e                	fisttpll (%rsi)
      be:	00 00                	add    %al,(%rax)
      c0:	f0 0e                	lock (bad)
      c2:	00 00                	add    %al,(%rax)
      c4:	ff 0e                	decl   (%rsi)
      c6:	00 00                	add    %al,(%rax)
      c8:	0e                   	(bad)
      c9:	0f 00 00             	sldt   (%rax)
      cc:	21 0f                	and    %ecx,(%rdi)
      ce:	00 00                	add    %al,(%rax)
      d0:	30 0f                	xor    %cl,(%rdi)
      d2:	00 00                	add    %al,(%rax)
      d4:	b8 0f 00 00 dc       	mov    $0xdc00000f,%eax
      d9:	0f 00 00             	sldt   (%rax)
      dc:	eb 0f                	jmp    ed <balancer_ingress+0xed>
      de:	00 00                	add    %al,(%rax)
      e0:	fa                   	cli
      e1:	0f 00 00             	sldt   (%rax)
      e4:	0d 10 00 00 20       	or     $0x20000010,%eax
  bpf_tail_call(xdp, &subprograms, 0);
      e9:	10 00                	adc    %al,(%rax)
      eb:	00 28                	add    %ch,(%rax)
      ed:	10 00                	adc    %al,(%rax)
      ef:	00 37                	add    %dh,(%rdi)
      f1:	10 00                	adc    %al,(%rax)
      f3:	00 46 10             	add    %al,0x10(%rsi)
      f6:	00 00                	add    %al,(%rax)
      f8:	62                   	(bad)
      f9:	10 00                	adc    %al,(%rax)
      fb:	00 75 10             	add    %dh,0x10(%rbp)
      fe:	00 00                	add    %al,(%rax)
     100:	84 10                	test   %dl,(%rax)
  struct vip_definition vip = {};
     102:	00 00                	add    %al,(%rax)
     104:	94                   	xchg   %eax,%esp
     105:	10 00                	adc    %al,(%rax)
     107:	00 a6 10 00 00 b0    	add    %ah,-0x4ffffff0(%rsi)
     10d:	10 00                	adc    %al,(%rax)
     10f:	00 02                	add    %al,(%rdx)
     111:	11 00                	adc    %eax,(%rax)
     113:	00 4d 11             	add    %cl,0x11(%rbp)
     116:	00 00                	add    %al,(%rax)
     118:	55                   	push   %rbp
     119:	11 00                	adc    %eax,(%rax)
     11b:	00 5d 11             	add    %bl,0x11(%rbp)
    if (iph + 1 > data_end) {
     11e:	00 00                	add    %al,(%rax)
     120:	ca 11 00             	lret   $0x11
     123:	00 ee                	add    %ch,%dh
     125:	11 00                	adc    %eax,(%rax)
     127:	00 fd                	add    %bh,%ch
    if (iph->ihl != 5) {
     129:	11 00                	adc    %eax,(%rax)
     12b:	00 0c 12             	add    %cl,(%rdx,%rdx,1)
     12e:	00 00                	add    %al,(%rax)
     130:	1f                   	(bad)
     131:	12 00                	adc    (%rax),%al
     133:	00 32                	add    %dh,(%rdx)
    pckt->tos = iph->tos;
     135:	12 00                	adc    (%rax),%al
     137:	00 3a                	add    %bh,(%rdx)
     139:	12 00                	adc    (%rax),%al
     13b:	00 49 12             	add    %cl,0x12(%rcx)
    *protocol = iph->protocol;
     13e:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
     140:	58                   	pop    %rax
     141:	12 00                	adc    (%rax),%al
    if (iph->frag_off & PCKT_FRAGMENTED) {
     143:	00 74 12 00          	add    %dh,0x0(%rdx,%rdx,1)
     147:	00 87 12 00 00 96    	add    %al,-0x69ffffee(%rdi)
     14d:	12 00                	adc    (%rax),%al
     14f:	00 9e 12 00 00 ae    	add    %bl,-0x51ffffee(%rsi)
     155:	12 00                	adc    (%rax),%al
    if (*protocol == IPPROTO_ICMP) {
     157:	00 b6 12 00 00 be    	add    %dh,-0x41ffffee(%rsi)
     15d:	12 00                	adc    (%rax),%al
  if (icmp_hdr + 1 > data_end) {
     15f:	00 c8                	add    %cl,%al
     161:	12 00                	adc    (%rax),%al
     163:	00 d2                	add    %dl,%dl
     165:	12 00                	adc    (%rax),%al
     167:	00 e2                	add    %ah,%dl
     169:	12 00                	adc    (%rax),%al
     16b:	00 ea                	add    %ch,%dl
  if (icmp_hdr->type == ICMP_ECHO) {
     16d:	12 00                	adc    (%rax),%al
     16f:	00 f5                	add    %dh,%ch
     171:	12 00                	adc    (%rax),%al
     173:	00 fd                	add    %bh,%ch
     175:	12 00                	adc    (%rax),%al
     177:	00 0d 13 00 00 15    	add    %cl,0x15000013(%rip)        # 15000190 <_license+0x14ffe0f6>
     17d:	13 00                	adc    (%rax),%eax
     17f:	00 25 13 00 00 2d    	add    %ah,0x2d000013(%rip)        # 2d000198 <_license+0x2cffe0fe>
     185:	13 00                	adc    (%rax),%eax
     187:	00 38                	add    %bh,(%rax)
     189:	13 00                	adc    (%rax),%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
     18b:	00 40 13             	add    %al,0x13(%rax)
     18e:	00 00                	add    %al,(%rax)
  icmp_hdr->checksum += 0x0008;
     190:	50                   	push   %rax
     191:	13 00                	adc    (%rax),%eax
     193:	00 58 13             	add    %bl,0x13(%rax)
  iph->ttl = DEFAULT_TTL;
     196:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
     198:	60                   	(bad)
     199:	13 00                	adc    (%rax),%eax
  tmp_addr = iph->daddr;
     19b:	00 70 13             	add    %dh,0x13(%rax)
  iph->daddr = iph->saddr;
     19e:	00 00                	add    %al,(%rax)
     1a0:	78 13                	js     1b5 <balancer_ingress+0x1b5>
  iph->saddr = tmp_addr;
     1a2:	00 00                	add    %al,(%rax)
     1a4:	89 13                	mov    %edx,(%rbx)
     1a6:	00 00                	add    %al,(%rax)
     1a8:	99                   	cltd
     1a9:	13 00                	adc    (%rax),%eax
     1ab:	00 a1 13 00 00 9e    	add    %ah,-0x61ffffed(%rcx)
     1b1:	14 00                	adc    $0x0,%al
     1b3:	00 17                	add    %dl,(%rdi)
     1b5:	15 00 00 27 15       	adc    $0x15270000,%eax
     1ba:	00 00                	add    %al,(%rax)
     1bc:	91                   	xchg   %eax,%ecx
     1bd:	15 00 00 ab 15       	adc    $0x15ab0000,%eax
     1c2:	00 00                	add    %al,(%rax)
     1c4:	d2 15 00 00 f9 15    	rclb   %cl,0x15f90000(%rip)        # 15f901ca <_license+0x15f8e130>
     1ca:	00 00                	add    %al,(%rax)
     1cc:	1a 16                	sbb    (%rsi),%dl
     1ce:	00 00                	add    %al,(%rax)
     1d0:	2b 16                	sub    (%rsi),%edx
     1d2:	00 00                	add    %al,(%rax)
     1d4:	40 16                	rex (bad)
     1d6:	00 00                	add    %al,(%rax)
     1d8:	51                   	push   %rcx
     1d9:	16                   	(bad)
     1da:	00 00                	add    %al,(%rax)
     1dc:	61                   	(bad)
     1dd:	16                   	(bad)
     1de:	00 00                	add    %al,(%rax)
     1e0:	69 16 00 00 14 17    	imul   $0x17140000,(%rsi),%edx
     1e6:	00 00                	add    %al,(%rax)
     1e8:	24 17                	and    $0x17,%al
     1ea:	00 00                	add    %al,(%rax)
     1ec:	2c 17                	sub    $0x17,%al
     1ee:	00 00                	add    %al,(%rax)
     1f0:	3d 17 00 00 4d       	cmp    $0x4d000017,%eax
     1f5:	17                   	(bad)
    if (ip6h + 1 > data_end) {
     1f6:	00 00                	add    %al,(%rax)
     1f8:	5d                   	pop    %rbp
     1f9:	17                   	(bad)
     1fa:	00 00                	add    %al,(%rax)
     1fc:	65 17                	gs (bad)
     1fe:	00 00                	add    %al,(%rax)
     200:	70 17                	jo     219 <balancer_ingress+0x219>
     202:	00 00                	add    %al,(%rax)
    *protocol = ip6h->nexthdr;
     204:	78 17                	js     21d <balancer_ingress+0x21d>
    pckt->flow.proto = *protocol;
     206:	00 00                	add    %al,(%rax)
     208:	88 17                	mov    %dl,(%rdi)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     20a:	00 00                	add    %al,(%rax)
     20c:	90                   	nop
     20d:	17                   	(bad)
     20e:	00 00                	add    %al,(%rax)
     210:	a0 17 00 00 a8 17 00 	movabs 0xb0000017a8000017,%al
     217:	00 b0 
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     219:	17                   	(bad)
     21a:	00 00                	add    %al,(%rax)
     21c:	ba 17 00 00 ca       	mov    $0xca000017,%edx
    if (*protocol == IPPROTO_FRAGMENT) {
     221:	17                   	(bad)
     222:	00 00                	add    %al,(%rax)
     224:	d2 17                	rclb   %cl,(%rdi)
     226:	00 00                	add    %al,(%rax)
     228:	dd 17                	fstl   (%rdi)
     22a:	00 00                	add    %al,(%rax)
     22c:	e5 17                	in     $0x17,%eax
     22e:	00 00                	add    %al,(%rax)
     230:	f5                   	cmc
     231:	17                   	(bad)
     232:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
     234:	fd                   	std
     235:	17                   	(bad)
     236:	00 00                	add    %al,(%rax)
     238:	05 18 00 00 15       	add    $0x15000018,%eax
     23d:	18 00                	sbb    %al,(%rax)
     23f:	00 1d 18 00 00 f7    	add    %bl,-0x8ffffe8(%rip)        # fffffffff700025d <server_id_map+0x5ffffe7ddd525d>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     245:	18 00                	sbb    %al,(%rax)
     247:	00 48 19             	add    %cl,0x19(%rax)
     24a:	00 00                	add    %al,(%rax)
     24c:	58                   	pop    %rax
     24d:	19 00                	sbb    %eax,(%rax)
     24f:	00 ad 19 00 00 c7    	add    %ch,-0x38ffffe7(%rbp)
     255:	19 00                	sbb    %eax,(%rax)
     257:	00 ee                	add    %ch,%dh
     259:	19 00                	sbb    %eax,(%rax)
     25b:	00 15 1a 00 00 36    	add    %dl,0x3600001a(%rip)        # 3600027b <_license+0x35ffe1e1>
     261:	1a 00                	sbb    (%rax),%al
     263:	00 47 1a             	add    %al,0x1a(%rdi)
     266:	00 00                	add    %al,(%rax)
     268:	5c                   	pop    %rsp
     269:	1a 00                	sbb    (%rax),%al
     26b:	00 6d 1a             	add    %ch,0x1a(%rbp)
     26e:	00 00                	add    %al,(%rax)
     270:	7d 1a                	jge    28c <balancer_ingress+0x28c>
     272:	00 00                	add    %al,(%rax)
     274:	85 1a                	test   %ebx,(%rdx)
     276:	00 00                	add    %al,(%rax)
     278:	0c 1b                	or     $0x1b,%al
     27a:	00 00                	add    %al,(%rax)
     27c:	45 1b 00             	sbb    (%r8),%r8d
     27f:	00 55 1b             	add    %dl,0x1b(%rbp)
     282:	00 00                	add    %al,(%rax)
     284:	87 1b                	xchg   %ebx,(%rbx)
     286:	00 00                	add    %al,(%rax)
     288:	8f                   	(bad)
     289:	1b 00                	sbb    (%rax),%eax
     28b:	00 ac 1b 00 00 cd 1b 	add    %ch,0x1bcd0000(%rbx,%rbx,1)
     292:	00 00                	add    %al,(%rax)
     294:	d1 1c 00             	rcrl   (%rax,%rax,1)
     297:	00 e7                	add    %ah,%bh
     299:	1c 00                	sbb    $0x0,%al
     29b:	00 fd                	add    %bh,%ch
     29d:	1c 00                	sbb    $0x0,%al
     29f:	00 2b                	add    %ch,(%rbx)
     2a1:	1d 00 00 3b 1d       	sbb    $0x1d3b0000,%eax
     2a6:	00 00                	add    %al,(%rax)
     2a8:	4b 1d 00 00 53 1d    	rex.WXB sbb $0x1d530000,%rax
     2ae:	00 00                	add    %al,(%rax)
     2b0:	84 1d 00 00 94 1d    	test   %bl,0x1d940000(%rip)        # 1d9402b6 <_license+0x1d93e21c>
     2b6:	00 00                	add    %al,(%rax)
     2b8:	bf 1d 00 00 c7       	mov    $0xc700001d,%edi
     2bd:	1d 00 00 e4 1d       	sbb    $0x1de40000,%eax
     2c2:	00 00                	add    %al,(%rax)
     2c4:	05 1e 00 00 09       	add    $0x900001e,%eax
     2c9:	1f                   	(bad)
     2ca:	00 00                	add    %al,(%rax)
     2cc:	1f                   	(bad)
     2cd:	1f                   	(bad)
     2ce:	00 00                	add    %al,(%rax)
     2d0:	35 1f 00 00 6a       	xor    $0x6a00001f,%eax
     2d5:	1f                   	(bad)
     2d6:	00 00                	add    %al,(%rax)
     2d8:	80 1f 00             	sbbb   $0x0,(%rdi)
     2db:	00 90 1f 00 00 98    	add    %dl,-0x67ffffe1(%rax)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     2e1:	1f                   	(bad)
     2e2:	00 00                	add    %al,(%rax)
     2e4:	ab                   	stos   %eax,%es:(%rdi)
     2e5:	1f                   	(bad)
     2e6:	00 00                	add    %al,(%rax)
     2e8:	c5 1f 00             	(bad)
     2eb:	00 d6                	add    %dl,%dh
     2ed:	1f                   	(bad)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2ee:	00 00                	add    %al,(%rax)
     2f0:	ec                   	in     (%dx),%al
     2f1:	1f                   	(bad)
     2f2:	00 00                	add    %al,(%rax)
     2f4:	fb                   	sti
     2f5:	1f                   	(bad)
     2f6:	00 00                	add    %al,(%rax)
     2f8:	17                   	(bad)
     2f9:	20 00                	and    %al,(%rax)
     2fb:	00 3f                	add    %bh,(%rdi)
     2fd:	20 00                	and    %al,(%rax)
     2ff:	00 5e 20             	add    %bl,0x20(%rsi)
  if (protocol == IPPROTO_ICMPV6) {
     302:	00 00                	add    %al,(%rax)
     304:	73 20                	jae    326 <balancer_ingress+0x326>
     306:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
     308:	83 20 00             	andl   $0x0,(%rax)
     30b:	00 92 20 00 00 a2    	add    %dl,-0x5dffffe0(%rdx)
     311:	20 00                	and    %al,(%rax)
     313:	00 aa 20 00 00 ba    	add    %ch,-0x45ffffe0(%rdx)
  if (icmp_hdr->type == ICMP_ECHO) {
     319:	20 00                	and    %al,(%rax)
     31b:	00 c2                	add    %al,%dl
     31d:	20 00                	and    %al,(%rax)
     31f:	00 ca                	add    %cl,%dl
     321:	20 00                	and    %al,(%rax)
     323:	00 d2                	add    %dl,%dl
     325:	20 00                	and    %al,(%rax)
     327:	00 e2                	add    %ah,%dl
     329:	20 00                	and    %al,(%rax)
     32b:	00 ea                	add    %ch,%dl
     32d:	20 00                	and    %al,(%rax)
     32f:	00 fa                	add    %bh,%dl
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     331:	20 00                	and    %al,(%rax)
     333:	00 02                	add    %al,(%rdx)
     335:	21 00                	and    %eax,(%rax)
     337:	00 0a                	add    %cl,(%rdx)
       sizeof(struct icmphdr)) > data_end) {
     339:	21 00                	and    %eax,(%rax)
     33b:	00 20                	add    %ah,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     33d:	21 00                	and    %eax,(%rax)
     33f:	00 28                	add    %ch,(%rax)
     341:	21 00                	and    %eax,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
     343:	00 30                	add    %dh,(%rax)
     345:	21 00                	and    %eax,(%rax)
  icmp_hdr->checksum += 0x0008;
     347:	00 39                	add    %bh,(%rcx)
     349:	21 00                	and    %eax,(%rax)
  iph->ttl = DEFAULT_TTL;
     34b:	00 49 21             	add    %cl,0x21(%rcx)
     34e:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
     350:	58                   	pop    %rax
     351:	21 00                	and    %eax,(%rax)
  tmp_addr = iph->daddr;
     353:	00 68 21             	add    %ch,0x21(%rax)
  iph->daddr = iph->saddr;
     356:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
     358:	73 21                	jae    37b <balancer_ingress+0x37b>
     35a:	00 00                	add    %al,(%rax)
     35c:	7c 21                	jl     37f <balancer_ingress+0x37f>
     35e:	00 00                	add    %al,(%rax)
     360:	95                   	xchg   %eax,%ebp
     361:	21 00                	and    %eax,(%rax)
     363:	00 aa 21 00 00 b3    	add    %ch,-0x4cffffdf(%rdx)
     369:	21 00                	and    %eax,(%rax)
     36b:	00 bb 21 00 00 c3    	add    %bh,-0x3cffffdf(%rbx)
     371:	21 00                	and    %eax,(%rax)
     373:	00 cb                	add    %cl,%bl
     375:	21 00                	and    %eax,(%rax)
     377:	00 d3                	add    %dl,%bl
     379:	21 00                	and    %eax,(%rax)
     37b:	00 dd                	add    %bl,%ch
     37d:	21 00                	and    %eax,(%rax)
     37f:	00 e5                	add    %ah,%ch
     381:	21 00                	and    %eax,(%rax)
     383:	00 ed                	add    %ch,%ch
     385:	21 00                	and    %eax,(%rax)
     387:	00 09                	add    %cl,(%rcx)
     389:	22 00                	and    (%rax),%al
     38b:	00 2b                	add    %ch,(%rbx)
     38d:	22 00                	and    (%rax),%al
     38f:	00 3b                	add    %bh,(%rbx)
     391:	22 00                	and    (%rax),%al
     393:	00 43 22             	add    %al,0x22(%rbx)
     396:	00 00                	add    %al,(%rax)
     398:	56                   	push   %rsi
     399:	22 00                	and    (%rax),%al
     39b:	00 94 22 00 00 a5 22 	add    %dl,0x22a50000(%rdx,%riz,1)
     3a2:	00 00                	add    %al,(%rax)
     3a4:	bf 22 00 00 df       	mov    $0xdf000022,%edi
     3a9:	22 00                	and    (%rax),%al
     3ab:	00 f0                	add    %dh,%al
     3ad:	22 00                	and    (%rax),%al
     3af:	00 08                	add    %cl,(%rax)
     3b1:	23 00                	and    (%rax),%eax
     3b3:	00 18                	add    %bl,(%rax)
     3b5:	23 00                	and    (%rax),%eax
     3b7:	00 20                	add    %ah,(%rax)
     3b9:	23 00                	and    (%rax),%eax
     3bb:	00 31                	add    %dh,(%rcx)
     3bd:	23 00                	and    (%rax),%eax
     3bf:	00 3b                	add    %bh,(%rbx)
     3c1:	23 00                	and    (%rax),%eax
     3c3:	00 44 23 00          	add    %al,0x0(%rbx,%riz,1)
     3c7:	00 4c 23 00          	add    %cl,0x0(%rbx,%riz,1)
     3cb:	00 54 23 00          	add    %dl,0x0(%rbx,%riz,1)
     3cf:	00 5c 23 00          	add    %bl,0x0(%rbx,%riz,1)
     3d3:	00 7e 23             	add    %bh,0x23(%rsi)
     3d6:	00 00                	add    %al,(%rax)
     3d8:	86 23                	xchg   %ah,(%rbx)
     3da:	00 00                	add    %al,(%rax)
     3dc:	a3 23 00 00 ac 23 00 	movabs %eax,0xb5000023ac000023
     3e3:	00 b5 
     3e5:	23 00                	and    (%rax),%eax
     3e7:	00 c5                	add    %al,%ch
     3e9:	23 00                	and    (%rax),%eax
     3eb:	00 cd                	add    %cl,%ch
     3ed:	23 00                	and    (%rax),%eax
     3ef:	00 dd                	add    %bl,%ch
     3f1:	23 00                	and    (%rax),%eax
     3f3:	00 e5                	add    %ah,%ch
     3f5:	23 00                	and    (%rax),%eax
     3f7:	00 fe                	add    %bh,%dh
     3f9:	23 00                	and    (%rax),%eax
     3fb:	00 06                	add    %al,(%rsi)
     3fd:	24 00                	and    $0x0,%al
     3ff:	00 0e                	add    %cl,(%rsi)
     401:	24 00                	and    $0x0,%al
     403:	00 16                	add    %dl,(%rsi)
     405:	24 00                	and    $0x0,%al
     407:	00 1e                	add    %bl,(%rsi)
     409:	24 00                	and    $0x0,%al
     40b:	00 28                	add    %ch,(%rax)
     40d:	24 00                	and    $0x0,%al
     40f:	00 31                	add    %dh,(%rcx)
     411:	24 00                	and    $0x0,%al
     413:	00 6b 24             	add    %ch,0x24(%rbx)
     416:	00 00                	add    %al,(%rax)
     418:	73 24                	jae    43e <balancer_ingress+0x43e>
     41a:	00 00                	add    %al,(%rax)
     41c:	7b 24                	jnp    442 <balancer_ingress+0x442>
     41e:	00 00                	add    %al,(%rax)
     420:	bf 24 00 00 ce       	mov    $0xce000024,%edi
     425:	24 00                	and    $0x0,%al
     427:	00 dd                	add    %bl,%ch
     429:	24 00                	and    $0x0,%al
     42b:	00 e5                	add    %ah,%ch
     42d:	24 00                	and    $0x0,%al
     42f:	00 f5                	add    %dh,%ch
     431:	24 00                	and    $0x0,%al
     433:	00 fd                	add    %bh,%ch
     435:	24 00                	and    $0x0,%al
     437:	00 05 25 00 00 0d    	add    %al,0xd000025(%rip)        # d000462 <_license+0xcffe3c8>
  if (protocol == IPPROTO_IPIP) {
     43d:	25 00 00 1c 25       	and    $0x251c0000,%eax
     442:	00 00                	add    %al,(%rax)
     444:	25 25 00 00 35       	and    $0x35000025,%eax
     449:	25 00 00 3d 25       	and    $0x253d0000,%eax
     44e:	00 00                	add    %al,(%rax)
     450:	62 25                	(bad)
  tcp = data + off;
     452:	00 00                	add    %al,(%rax)
     454:	95                   	xchg   %eax,%ebp
  if (is_ipv6) {
     455:	25 00 00 ab 25       	and    $0x25ab0000,%eax
  tcp = data + off;
     45a:	00 00                	add    %al,(%rax)
  if (tcp + 1 > data_end) {
     45c:	c7                   	(bad)
     45d:	25 00 00 da 25       	and    $0x25da0000,%eax
     462:	00 00                	add    %al,(%rax)
     464:	f4                   	hlt
     465:	25 00 00 05 26       	and    $0x26050000,%eax
  if (tcp->syn) {
     46a:	00 00                	add    %al,(%rax)
     46c:	1b 26                	sbb    (%rsi),%esp
     46e:	00 00                	add    %al,(%rax)
     470:	2a 26                	sub    (%rsi),%ah
    pckt->flags |= F_SYN_SET;
     472:	00 00                	add    %al,(%rax)
     474:	32 26                	xor    (%rsi),%ah
     476:	00 00                	add    %al,(%rax)
     478:	3a 26                	cmp    (%rsi),%ah
     47a:	00 00                	add    %al,(%rax)
      pckt->flow.src = iph->saddr;
     47c:	43                   	rex.XB
     47d:	26 00 00             	es add %al,(%rax)
     480:	5b                   	pop    %rbx
     481:	26 00 00             	es add %al,(%rax)
      pckt->flow.dst = iph->daddr;
     484:	6b 26 00             	imul   $0x0,(%rsi),%esp
     487:	00 73 26             	add    %dh,0x26(%rbx)
  if (protocol == IPPROTO_ICMPV6) {
     48a:	00 00                	add    %al,(%rax)
     48c:	83 26 00             	andl   $0x0,(%rsi)
  if (icmp_hdr + 1 > data_end) {
     48f:	00 8b 26 00 00 93    	add    %cl,-0x6cffffda(%rbx)
     495:	26 00 00             	es add %al,(%rax)
     498:	9b                   	fwait
     499:	26 00 00             	es add %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     49c:	ab                   	stos   %eax,%es:(%rdi)
     49d:	26 00 00             	es add %al,(%rax)
     4a0:	b3 26                	mov    $0x26,%bl
     4a2:	00 00                	add    %al,(%rax)
     4a4:	c3                   	ret
     4a5:	26 00 00             	es add %al,(%rax)
     4a8:	d3 26                	shll   %cl,(%rsi)
     4aa:	00 00                	add    %al,(%rax)
     4ac:	de 26                	fisubs (%rsi)
     4ae:	00 00                	add    %al,(%rax)
     4b0:	e7 26                	out    %eax,$0x26
     4b2:	00 00                	add    %al,(%rax)
     4b4:	fc                   	cld
     4b5:	26 00 00             	es add %al,(%rax)
     4b8:	05 27 00 00 0d       	add    $0xd000027,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4bd:	27                   	(bad)
     4be:	00 00                	add    %al,(%rax)
     4c0:	15 27 00 00 1d       	adc    $0x1d000027,%eax
       sizeof(struct icmp6hdr)) > data_end) {
     4c5:	27                   	(bad)
     4c6:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4c8:	27                   	(bad)
     4c9:	27                   	(bad)
     4ca:	00 00                	add    %al,(%rax)
     4cc:	2f                   	(bad)
     4cd:	27                   	(bad)
     4ce:	00 00                	add    %al,(%rax)
     4d0:	42 27                	rex.X (bad)
     4d2:	00 00                	add    %al,(%rax)
     4d4:	59                   	pop    %rcx
     4d5:	27                   	(bad)
     4d6:	00 00                	add    %al,(%rax)
     4d8:	69 27 00 00 71 27    	imul   $0x27710000,(%rdi),%esp
     4de:	00 00                	add    %al,(%rax)
     4e0:	8d 27                	lea    (%rdi),%esp
     4e2:	00 00                	add    %al,(%rax)
     4e4:	e2 27                	loop   50d <balancer_ingress+0x50d>
     4e6:	00 00                	add    %al,(%rax)
     4e8:	fb                   	sti
     4e9:	27                   	(bad)
     4ea:	00 00                	add    %al,(%rax)
     4ec:	1e                   	(bad)
     4ed:	28 00                	sub    %al,(%rax)
     4ef:	00 55 28             	add    %dl,0x28(%rbp)
     4f2:	00 00                	add    %al,(%rax)
  tcp = data + off;
     4f4:	6e                   	outsb  %ds:(%rsi),(%dx)
     4f5:	28 00                	sub    %al,(%rax)
  if (is_ipv6) {
     4f7:	00 8e 28 00 00 9e    	add    %cl,-0x61ffffd8(%rsi)
  if (tcp + 1 > data_end) {
     4fd:	28 00                	sub    %al,(%rax)
     4ff:	00 a6 28 00 00 b7    	add    %ah,-0x48ffffd8(%rsi)
     505:	28 00                	sub    %al,(%rax)
     507:	00 ed                	add    %ch,%ch
     509:	28 00                	sub    %al,(%rax)
  if (tcp->syn) {
     50b:	00 0a                	add    %cl,(%rdx)
     50d:	29 00                	sub    %eax,(%rax)
     50f:	00 14 29             	add    %dl,(%rcx,%rbp,1)
     512:	00 00                	add    %al,(%rax)
    pckt->flags |= F_SYN_SET;
     514:	1d 29 00 00 28       	sbb    $0x28000029,%eax
     519:	29 00                	sub    %eax,(%rax)
     51b:	00 50 29             	add    %dl,0x29(%rax)
     51e:	00 00                	add    %al,(%rax)
     520:	5c                   	pop    %rsp
     521:	29 00                	sub    %eax,(%rax)
     523:	00 64 29 00          	add    %ah,0x0(%rcx,%rbp,1)
        bpf_map_lookup_elem(&stats, &stats_key);
     527:	00 6c 29 00          	add    %ch,0x0(%rcx,%rbp,1)
     52b:	00 8e 29 00 00 96    	add    %cl,-0x69ffffd7(%rsi)
     531:	29 00                	sub    %eax,(%rax)
     533:	00 b3 29 00 00 bb    	add    %dh,-0x44ffffd7(%rbx)
    if (!icmp_ptb_v6_stats) {
     539:	29 00                	sub    %eax,(%rax)
     53b:	00 c4                	add    %al,%ah
     53d:	29 00                	sub    %eax,(%rax)
     53f:	00 cd                	add    %cl,%ch
    icmp_ptb_v6_stats->v1 += 1;
     541:	29 00                	sub    %eax,(%rax)
     543:	00 dd                	add    %bl,%ch
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     545:	29 00                	sub    %eax,(%rax)
     547:	00 e5                	add    %ah,%ch
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     549:	29 00                	sub    %eax,(%rax)
     54b:	00 f5                	add    %dh,%ch
     54d:	29 00                	sub    %eax,(%rax)
     54f:	00 fd                	add    %bh,%ch
      icmp_ptb_v6_stats->v2 += 1;
     551:	29 00                	sub    %eax,(%rax)
     553:	00 05 2a 00 00 0d    	add    %al,0xd00002a(%rip)        # d000583 <_license+0xcffe4e9>
  if (ip6h + 1 > data_end) {
     559:	2a 00                	sub    (%rax),%al
     55b:	00 15 2a 00 00 1d    	add    %dl,0x1d00002a(%rip)        # 1d00058b <_license+0x1cffe4f1>
     561:	2a 00                	sub    (%rax),%al
  pckt->flow.proto = ip6h->nexthdr;
     563:	00 27                	add    %ah,(%rdi)
     565:	2a 00                	sub    (%rax),%al
     567:	00 31                	add    %dh,(%rcx)
     569:	2a 00                	sub    (%rax),%al
  pckt->flags |= F_ICMP;
     56b:	00 59 2a             	add    %bl,0x2a(%rcx)
     56e:	00 00                	add    %al,(%rax)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     570:	61                   	(bad)
     571:	2a 00                	sub    (%rax),%al
     573:	00 69 2a             	add    %ch,0x2a(%rcx)
     576:	00 00                	add    %al,(%rax)
     578:	71 2a                	jno    5a4 <balancer_ingress+0x5a4>
     57a:	00 00                	add    %al,(%rax)
     57c:	79 2a                	jns    5a8 <balancer_ingress+0x5a8>
     57e:	00 00                	add    %al,(%rax)
     580:	89 2a                	mov    %ebp,(%rdx)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     582:	00 00                	add    %al,(%rax)
     584:	91                   	xchg   %eax,%ecx
     585:	2a 00                	sub    (%rax),%al
     587:	00 99 2a 00 00 dd    	add    %bl,-0x22ffffd6(%rcx)
     58d:	2a 00                	sub    (%rax),%al
     58f:	00 ec                	add    %ch,%ah
     591:	2a 00                	sub    (%rax),%al
     593:	00 fb                	add    %bh,%bl
     595:	2a 00                	sub    (%rax),%al
     597:	00 10                	add    %dl,(%rax)
     599:	2b 00                	sub    (%rax),%eax
     59b:	00 20                	add    %ah,(%rax)
     59d:	2b 00                	sub    (%rax),%eax
     59f:	00 2f                	add    %ch,(%rdi)
     5a1:	2b 00                	sub    (%rax),%eax
     5a3:	00 3e                	add    %bh,(%rsi)
     5a5:	2b 00                	sub    (%rax),%eax
     5a7:	00 47 2b             	add    %al,0x2b(%rdi)
     5aa:	00 00                	add    %al,(%rax)
     5ac:	57                   	push   %rdi
     5ad:	2b 00                	sub    (%rax),%eax
     5af:	00 5f 2b             	add    %bl,0x2b(%rdi)
     5b2:	00 00                	add    %al,(%rax)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     5b4:	7b 2b                	jnp    5e1 <balancer_ingress+0x5e1>
     5b6:	00 00                	add    %al,(%rax)
     5b8:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     5b9:	2b 00                	sub    (%rax),%eax
     5bb:	00 bb 2b 00 00 d7    	add    %bh,-0x28ffffd5(%rbx)
     5c1:	2b 00                	sub    (%rax),%eax
     5c3:	00 e7                	add    %ah,%bh
     5c5:	2b 00                	sub    (%rax),%eax
     5c7:	00 ef                	add    %ch,%bh
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
     5c9:	2b 00                	sub    (%rax),%eax
     5cb:	00 fa                	add    %bh,%dl
     5cd:	2b 00                	sub    (%rax),%eax
     5cf:	00 02                	add    %al,(%rdx)
     5d1:	2c 00                	sub    $0x0,%al
     5d3:	00 17                	add    %dl,(%rdi)
     5d5:	2c 00                	sub    $0x0,%al
     5d7:	00 27                	add    %ah,(%rdi)
     5d9:	2c 00                	sub    $0x0,%al
     5db:	00 36                	add    %dh,(%rsi)
  if (decap_dst_flags) {
     5dd:	2c 00                	sub    $0x0,%al
     5df:	00 46 2c             	add    %al,0x2c(%rsi)
     5e2:	00 00                	add    %al,(%rax)
     5e4:	4e 2c 00             	rex.WRX sub $0x0,%al
     5e7:	00 59 2c             	add    %bl,0x2c(%rcx)
     5ea:	00 00                	add    %al,(%rax)
     5ec:	04 04                	add    $0x4,%al
     5ee:	3d 01 55 04 3d       	cmp    $0x3d045501,%eax
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     5f3:	db 37                	(bad)  (%rdi)
     5f5:	01 5d 04             	add    %ebx,0x4(%rbp)
     5f8:	db 37                	(bad)  (%rdi)
     5fa:	ef                   	out    %eax,(%dx)
     5fb:	37                   	(bad)
     5fc:	04 a3                	add    $0xa3,%al
     5fe:	01 55 9f             	add    %edx,-0x61(%rbp)
    if (!data_stats) {
     601:	04 ef                	add    $0xef,%al
     603:	37                   	(bad)
     604:	9a                   	(bad)
     605:	41 01 5d 00          	add    %ebx,0x0(%r13)
     609:	04 18                	add    $0x18,%al
     60b:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     60c:	08 01                	or     %al,(%rcx)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     60e:	53                   	push   %rbx
     60f:	04 b0                	add    $0xb0,%al
     611:	08 94 17 01 53 04 cc 	or     %dl,-0x33fbacff(%rdi,%rdx,1)
     618:	17                   	(bad)
     619:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     61a:	19 01                	sbb    %eax,(%rcx)
     61c:	53                   	push   %rbx
     61d:	04 96                	add    $0x96,%al
     61f:	1a cb                	sbb    %bl,%cl
     621:	1a 01                	sbb    (%rcx),%al
     623:	53                   	push   %rbx
     624:	00 04 1c             	add    %al,(%rsp,%rbx,1)
     627:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     628:	08 01                	or     %al,(%rcx)
     62a:	5f                   	pop    %rdi
     62b:	04 b0                	add    $0xb0,%al
     62d:	08 d6                	or     %dl,%dh
     62f:	1a 01                	sbb    (%rcx),%al
     631:	5f                   	pop    %rdi
     632:	04 93                	add    $0x93,%al
     634:	1c ef                	sbb    $0xef,%al
     636:	1c 01                	sbb    $0x1,%al
  if (decap_dst_flags) {
     638:	5f                   	pop    %rdi
     639:	04 e6                	add    $0xe6,%al
     63b:	1d 96 1f 01 5f       	sbb    $0x5f011f96,%eax
     640:	04 f3                	add    $0xf3,%al
     642:	27                   	(bad)
     643:	e3 28                	jrcxz  66d <balancer_ingress+0x66d>
     645:	01 5f 04             	add    %ebx,0x4(%rdi)
     648:	a1 2a f1 2b 01 5f 04 	movabs 0x3bbf045f012bf12a,%eax
     64f:	bf 3b 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     651:	b2 3f                	mov    $0x3f,%dl
     653:	01 5f 04             	add    %ebx,0x4(%rdi)
     656:	b7 3f                	mov    $0x3f,%bh
     658:	95                   	xchg   %eax,%ebp
     659:	41 01 5f 00          	add    %ebx,0x0(%r15)
    if (!data_stats) {
     65d:	04 1c                	add    $0x1c,%al
     65f:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     660:	08 01                	or     %al,(%rcx)
     662:	53                   	push   %rbx
     663:	04 b0                	add    $0xb0,%al
     665:	08 94 17 01 53 04 cc 	or     %dl,-0x33fbacff(%rdi,%rdx,1)
  if (is_ipv6) {
     66c:	17                   	(bad)
     66d:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
  udp = data + off;
     66e:	19 01                	sbb    %eax,(%rcx)
     670:	53                   	push   %rbx
     671:	04 96                	add    $0x96,%al
  if (udp + 1 > data_end) {
     673:	1a cb                	sbb    %bl,%cl
     675:	1a 01                	sbb    (%rcx),%al
     677:	53                   	push   %rbx
     678:	00 04 1c             	add    %al,(%rsp,%rbx,1)
     67b:	9a                   	(bad)
     67c:	41 02 3e             	add    (%r14),%dil
     67f:	9f                   	lahf
     680:	00 04 35 8c 01 12 72 	add    %al,0x7212018c(,%rsi,1)
     687:	00 10                	add    %dl,(%rax)
     689:	ff                   	(bad)
     68a:	ff 03                	incl   (%rbx)
     68c:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
     692:	a8 b0                	test   $0xb0,%al
     694:	80 80 00 9f 04 a5 01 	addb   $0x1,-0x5afb6100(%rax)
     69b:	fb                   	sti
     69c:	01 12                	add    %edx,(%rdx)
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     69e:	72 00                	jb     6a0 <balancer_ingress+0x6a0>
     6a0:	10 ff                	adc    %bh,%bh
     6a2:	ff 03                	incl   (%rbx)
     6a4:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
     6aa:	a8 b0                	test   $0xb0,%al
     6ac:	80 80 00 9f 04 dc 03 	addb   $0x3,-0x23fb6100(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
     6b3:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
     6b6:	72 00                	jb     6b8 <balancer_ingress+0x6b8>
     6b8:	10 ff                	adc    %bh,%bh
     6ba:	ff 03                	incl   (%rbx)
     6bc:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
    if (!icmp_ptb_v4_stats) {
     6c2:	a8 b0                	test   $0xb0,%al
     6c4:	80 80 00 9f 00 04 4c 	addb   $0x4c,0x4009f00(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     6cb:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     6cc:	01 01                	add    %eax,(%rcx)
     6ce:	5d                   	pop    %rbp
     6cf:	04 82                	add    $0x82,%al
      icmp_ptb_v4_stats->v2 += 1;
     6d1:	02 dc                	add    %ah,%bl
     6d3:	03 01                	add    (%rcx),%eax
     6d5:	5d                   	pop    %rbp
  if (iph + 1 > data_end) {
     6d6:	04 fb                	add    $0xfb,%al
     6d8:	08 9d 0a 01 5d 04    	or     %bl,0x45d010a(%rbp)
     6de:	84 10                	test   %dl,(%rax)
     6e0:	f4                   	hlt
     6e1:	10 01                	adc    %al,(%rcx)
  if (iph->ihl != 5) {
     6e3:	5d                   	pop    %rbp
     6e4:	04 aa                	add    $0xaa,%al
     6e6:	11 f8                	adc    %edi,%eax
     6e8:	13 01                	adc    (%rcx),%eax
     6ea:	5d                   	pop    %rbp
     6eb:	04 81                	add    $0x81,%al
     6ed:	14 ad                	adc    $0xad,%al
  pckt->flow.proto = iph->protocol;
     6ef:	16                   	(bad)
     6f0:	01 5d 04             	add    %ebx,0x4(%rbp)
     6f3:	cc                   	int3
     6f4:	17                   	(bad)
     6f5:	82                   	(bad)
  pckt->flags |= F_ICMP;
     6f6:	18 01                	sbb    %al,(%rcx)
     6f8:	5d                   	pop    %rbp
     6f9:	04 c5                	add    $0xc5,%al
  pckt->flow.src = iph->daddr;
     6fb:	18 93 1c 01 5d 04    	sbb    %dl,0x45d011c(%rbx)
     701:	ef                   	out    %eax,(%dx)
  pckt->flow.dst = iph->saddr;
     702:	1c bd                	sbb    $0xbd,%al
     704:	1e                   	(bad)
     705:	01 5d 04             	add    %ebx,0x4(%rbp)
     708:	96                   	xchg   %eax,%esi
     709:	1f                   	(bad)
     70a:	f3 27                	repz (bad)
     70c:	01 5d 04             	add    %ebx,0x4(%rbp)
     70f:	e3 28                	jrcxz  739 <balancer_ingress+0x739>
     711:	c0 2a 01             	shrb   $0x1,(%rdx)
     714:	5d                   	pop    %rbp
     715:	04 bf                	add    $0xbf,%al
     717:	3b 99 3c 01 5d 04    	cmp    0x45d013c(%rcx),%ebx
     71d:	83 3d 93 3e 01 5d 04 	cmpl   $0x4,0x5d013e93(%rip)        # 5d0145b7 <_license+0x5d01251d>
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     724:	b7 3f                	mov    $0x3f,%bh
     726:	9a                   	(bad)
     727:	41 01 5d 00          	add    %ebx,0x0(%r13)
     72b:	04 4c                	add    $0x4c,%al
     72d:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     72e:	01 02                	add    %eax,(%rdx)
     730:	3e 9f                	ds lahf
     732:	04 82                	add    $0x82,%al
     734:	02 dc                	add    %ah,%bl
     736:	03 02                	add    (%rdx),%eax
  vip.port = pckt.flow.port16[1];
     738:	3e 9f                	ds lahf
     73a:	04 fb                	add    $0xfb,%al
     73c:	08 9d 0a 02 3e 9f    	or     %bl,-0x60c1fdf6(%rbp)
  vip.proto = pckt.flow.proto;
     742:	04 84                	add    $0x84,%al
     744:	10 f4                	adc    %dh,%ah
     746:	10 02                	adc    %al,(%rdx)
     748:	3e 9f                	ds lahf
     74a:	04 aa                	add    $0xaa,%al
     74c:	11 f8                	adc    %edi,%eax
     74e:	13 02                	adc    (%rdx),%eax
     750:	3e 9f                	ds lahf
     752:	04 81                	add    $0x81,%al
     754:	14 ad                	adc    $0xad,%al
     756:	16                   	(bad)
     757:	02 3e                	add    (%rsi),%bh
     759:	9f                   	lahf
     75a:	04 cc                	add    $0xcc,%al
     75c:	17                   	(bad)
     75d:	82                   	(bad)
     75e:	18 02                	sbb    %al,(%rdx)
     760:	3e 9f                	ds lahf
     762:	04 c5                	add    $0xc5,%al
  if (!vip_info) {
     764:	18 93 1c 02 3e 9f    	sbb    %dl,-0x60c1fde4(%rbx)
     76a:	04 ef                	add    $0xef,%al
     76c:	1c bd                	sbb    $0xbd,%al
  if (data_end - data > MAX_PCKT_SIZE) {
     76e:	1e                   	(bad)
     76f:	02 3e                	add    (%rsi),%bh
     771:	9f                   	lahf
     772:	04 96                	add    $0x96,%al
     774:	1f                   	(bad)
     775:	f3 27                	repz (bad)
     777:	02 3e                	add    (%rsi),%bh
     779:	9f                   	lahf
     77a:	04 e3                	add    $0xe3,%al
     77c:	28 c0                	sub    %al,%al
     77e:	2a 02                	sub    (%rdx),%al
     780:	3e 9f                	ds lahf
     782:	04 bf                	add    $0xbf,%al
     784:	3b 99 3c 02 3e 9f    	cmp    -0x60c1fdc4(%rcx),%ebx
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     78a:	04 83                	add    $0x83,%al
     78c:	3d 93 3e 02 3e       	cmp    $0x3e023e93,%eax
     791:	9f                   	lahf
     792:	04 b7                	add    $0xb7,%al
     794:	3f                   	(bad)
     795:	9a                   	(bad)
     796:	41 02 3e             	add    (%r14),%dil
  if (!data_stats) {
     799:	9f                   	lahf
     79a:	00 04 4c             	add    %al,(%rsp,%rcx,2)
     79d:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     79e:	01 02                	add    %eax,(%rdx)
     7a0:	30 9f 04 82 02 dc    	xor    %bl,-0x23fd7dfc(%rdi)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     7a6:	03 02                	add    (%rdx),%eax
     7a8:	30 9f 04 fb 08 9d    	xor    %bl,-0x62f704fc(%rdi)
    pckt.flow.port16[0] = 0;
     7ae:	0a 02                	or     (%rdx),%al
     7b0:	30 9f 04 84 10 f4    	xor    %bl,-0xbef7bfc(%rdi)
  vip_num = vip_info->vip_num;
     7b6:	10 02                	adc    %al,(%rdx)
     7b8:	30 9f 04 aa 11 f8    	xor    %bl,-0x7ee55fc(%rdi)
  __u32 cpu_num = bpf_get_smp_processor_id();
     7be:	13 02                	adc    (%rdx),%eax
     7c0:	30 9f 04 81 14 ad    	xor    %bl,-0x52eb7efc(%rdi)
     7c6:	16                   	(bad)
     7c7:	02 30                	add    (%rax),%dh
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     7c9:	9f                   	lahf
     7ca:	04 cc                	add    $0xcc,%al
     7cc:	17                   	(bad)
     7cd:	82                   	(bad)
     7ce:	18 02                	sbb    %al,(%rdx)
     7d0:	30 9f 04 c5 18 93    	xor    %bl,-0x6ce73afc(%rdi)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     7d6:	1c 02                	sbb    $0x2,%al
     7d8:	30 9f 04 ef 1c bd    	xor    %bl,-0x42e310fc(%rdi)
     7de:	1e                   	(bad)
     7df:	02 30                	add    (%rax),%dh
     7e1:	9f                   	lahf
     7e2:	04 96                	add    $0x96,%al
    if (!lru_stats) {
     7e4:	1f                   	(bad)
     7e5:	f3 27                	repz (bad)
     7e7:	02 30                	add    (%rax),%dh
     7e9:	9f                   	lahf
     7ea:	04 e3                	add    $0xe3,%al
    lru_stats->v1 += 1;
     7ec:	28 c0                	sub    %al,%al
     7ee:	2a 02                	sub    (%rdx),%al
     7f0:	30 9f 04 bf 3b 99    	xor    %bl,-0x66c440fc(%rdi)
     7f6:	3c 02                	cmp    $0x2,%al
     7f8:	30 9f 04 83 3d 93    	xor    %bl,-0x6cc27cfc(%rdi)
     7fe:	3e 02 30             	ds add (%rax),%dh
     801:	9f                   	lahf
     802:	04 b7                	add    $0xb7,%al
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     804:	3f                   	(bad)
     805:	9a                   	(bad)
     806:	41 02 30             	add    (%r8),%sil
     809:	9f                   	lahf
     80a:	00 04 4c             	add    %al,(%rsp,%rcx,2)
     80d:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     80e:	01 01                	add    %eax,(%rcx)
     810:	53                   	push   %rbx
     811:	04 82                	add    $0x82,%al
     813:	02 dc                	add    %ah,%bl
        bpf_map_lookup_elem(&stats, &stats_key);
     815:	03 01                	add    (%rcx),%eax
     817:	53                   	push   %rbx
     818:	04 fb                	add    $0xfb,%al
     81a:	08 9d 0a 01 53 04    	or     %bl,0x453010a(%rbp)
     820:	84 10                	test   %dl,(%rax)
     822:	f4                   	hlt
     823:	10 01                	adc    %al,(%rcx)
    if (!icmp_ptb_v4_stats) {
     825:	53                   	push   %rbx
     826:	04 aa                	add    $0xaa,%al
     828:	11 f8                	adc    %edi,%eax
     82a:	13 01                	adc    (%rcx),%eax
     82c:	53                   	push   %rbx
    icmp_ptb_v4_stats->v1 += 1;
     82d:	04 81                	add    $0x81,%al
     82f:	14 ad                	adc    $0xad,%al
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     831:	16                   	(bad)
     832:	01 53 04             	add    %edx,0x4(%rbx)
     835:	cc                   	int3
     836:	17                   	(bad)
      icmp_ptb_v4_stats->v2 += 1;
     837:	82                   	(bad)
     838:	18 01                	sbb    %al,(%rcx)
     83a:	53                   	push   %rbx
     83b:	04 c5                	add    $0xc5,%al
  if (iph + 1 > data_end) {
     83d:	18 a7 19 01 53 04    	sbb    %ah,0x4530119(%rdi)
     843:	96                   	xchg   %eax,%esi
     844:	1a cb                	sbb    %bl,%cl
     846:	1a 01                	sbb    (%rcx),%al
     848:	53                   	push   %rbx
  if (iph->ihl != 5) {
     849:	00 04 4c             	add    %al,(%rsp,%rcx,2)
     84c:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     84d:	01 01                	add    %eax,(%rcx)
     84f:	5f                   	pop    %rdi
     850:	04 82                	add    $0x82,%al
     852:	02 dc                	add    %ah,%bl
     854:	03 01                	add    (%rcx),%eax
  pckt->flow.proto = iph->protocol;
     856:	5f                   	pop    %rdi
     857:	04 fb                	add    $0xfb,%al
     859:	08 9d 0a 01 5f 04    	or     %bl,0x45f010a(%rbp)
  pckt->flags |= F_ICMP;
     85f:	84 10                	test   %dl,(%rax)
  pckt->flow.src = iph->daddr;
     861:	f4                   	hlt
     862:	10 01                	adc    %al,(%rcx)
     864:	5f                   	pop    %rdi
     865:	04 aa                	add    $0xaa,%al
     867:	11 f8                	adc    %edi,%eax
  pckt->flow.dst = iph->saddr;
     869:	13 01                	adc    (%rcx),%eax
     86b:	5f                   	pop    %rdi
     86c:	04 81                	add    $0x81,%al
     86e:	14 ad                	adc    $0xad,%al
     870:	16                   	(bad)
     871:	01 5f 04             	add    %ebx,0x4(%rdi)
    vip.port = 0;
     874:	cc                   	int3
     875:	17                   	(bad)
     876:	82                   	(bad)
     877:	18 01                	sbb    %al,(%rcx)
     879:	5f                   	pop    %rdi
     87a:	04 c5                	add    $0xc5,%al
     87c:	18 d6                	sbb    %dl,%dh
     87e:	1a 01                	sbb    (%rcx),%al
     880:	5f                   	pop    %rdi
     881:	04 e6                	add    $0xe6,%al
     883:	1d bd 1e 01 5f       	sbb    $0x5f011ebd,%eax
     888:	04 a1                	add    $0xa1,%al
    if (!vip_info) {
     88a:	2a c0                	sub    %al,%al
     88c:	2a 01                	sub    (%rcx),%al
     88e:	5f                   	pop    %rdi
     88f:	04 bf                	add    $0xbf,%al
     891:	3b 99 3c 01 5f 04    	cmp    0x45f013c(%rcx),%ebx
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     897:	83 3d 93 3e 01 5f 04 	cmpl   $0x4,0x5f013e93(%rip)        # 5f014731 <_license+0x5f012697>
      pckt.flow.port16[1] = 0;
     89e:	b7 3f                	mov    $0x3f,%bh
     8a0:	95                   	xchg   %eax,%ebp
     8a1:	41 01 5f 00          	add    %ebx,0x0(%r15)
     8a5:	04 4c                	add    $0x4c,%al
     8a7:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     8a8:	01 02                	add    %eax,(%rdx)
  struct address dst_addr = {};
     8aa:	30 9f 04 82 02 dc    	xor    %bl,-0x23fd7dfc(%rdi)
     8b0:	03 02                	add    (%rdx),%eax
     8b2:	30 9f 04 fb 08 9d    	xor    %bl,-0x62f704fc(%rdi)
     8b8:	0a 02                	or     (%rdx),%al
     8ba:	30 9f 04 84 10 f4    	xor    %bl,-0xbef7bfc(%rdi)
    dst_addr.addr = pckt->flow.dst;
     8c0:	10 02                	adc    %al,(%rdx)
     8c2:	30 9f 04 aa 11 f8    	xor    %bl,-0x7ee55fc(%rdi)
     8c8:	13 02                	adc    (%rdx),%eax
     8ca:	30 9f 04 81 14 ad    	xor    %bl,-0x52eb7efc(%rdi)
     8d0:	16                   	(bad)
     8d1:	02 30                	add    (%rax),%dh
     8d3:	9f                   	lahf
     8d4:	04 cc                	add    $0xcc,%al
     8d6:	17                   	(bad)
     8d7:	82                   	(bad)
  if (decap_dst_flags) {
     8d8:	18 02                	sbb    %al,(%rdx)
     8da:	30 9f 04 c5 18 93    	xor    %bl,-0x6ce73afc(%rdi)
     8e0:	1c 02                	sbb    $0x2,%al
     8e2:	30 9f 04 ef 1c bd    	xor    %bl,-0x42e310fc(%rdi)
     8e8:	1e                   	(bad)
     8e9:	02 30                	add    (%rax),%dh
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8eb:	9f                   	lahf
     8ec:	04 96                	add    $0x96,%al
     8ee:	1f                   	(bad)
     8ef:	cf                   	iret
     8f0:	1f                   	(bad)
     8f1:	02 30                	add    (%rax),%dh
     8f3:	9f                   	lahf
     8f4:	04 e8                	add    $0xe8,%al
     8f6:	20 b7 22 01 5c 04    	and    %dh,0x45c0122(%rdi)
    if (!data_stats) {
     8fc:	af                   	scas   %es:(%rdi),%eax
     8fd:	26 f3 27             	es repz (bad)
     900:	01 5c 04 a1          	add    %ebx,-0x5f(%rsp,%rax,1)
     904:	2a c0                	sub    %al,%al
     906:	2a 02                	sub    (%rdx),%al
     908:	30 9f 04 bf 3b 99    	xor    %bl,-0x66c440fc(%rdi)
     90e:	3c 02                	cmp    $0x2,%al
     910:	30 9f 04 83 3d cd    	xor    %bl,-0x32c27cfc(%rdi)
        bpf_map_lookup_elem(&stats, &stats_key);
     916:	3d 02 30 9f 04       	cmp    $0x49f3002,%eax
     91b:	cd 3d                	int    $0x3d
     91d:	83 3e 01             	cmpl   $0x1,(%rsi)
     920:	5c                   	pop    %rsp
     921:	04 83                	add    $0x83,%al
    if (!icmp_ptb_v6_stats) {
     923:	3e 93                	ds xchg %eax,%ebx
     925:	3e 02 30             	ds add (%rax),%dh
     928:	9f                   	lahf
     929:	04 b7                	add    $0xb7,%al
     92b:	3f                   	(bad)
    icmp_ptb_v6_stats->v1 += 1;
     92c:	9a                   	(bad)
     92d:	41 01 5c 00 04       	add    %ebx,0x4(%r8,%rax,1)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     932:	93                   	xchg   %eax,%ebx
     933:	01 9e 01 01 52 00    	add    %ebx,0x520101(%rsi)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     939:	04 a5                	add    $0xa5,%al
     93b:	01 82 02 01 5d 04    	add    %eax,0x45d0102(%rdx)
      icmp_ptb_v6_stats->v2 += 1;
     941:	dc 03                	faddl  (%rbx)
  if (ip6h + 1 > data_end) {
     943:	e2 04                	loop   949 <balancer_ingress+0x949>
     945:	01 5d 04             	add    %ebx,0x4(%rbp)
     948:	dc 05 97 07 01 5d    	faddl  0x5d010797(%rip)        # 5d0110e5 <_license+0x5d00f04b>
     94e:	04 b0                	add    $0xb0,%al
     950:	08 fb                	or     %bh,%bl
     952:	08 01                	or     %al,(%rcx)
  pckt->flow.proto = ip6h->nexthdr;
     954:	5d                   	pop    %rbp
     955:	04 9d                	add    $0x9d,%al
     957:	0a 84 10 01 5d 04 f4 	or     -0xbfba2ff(%rax,%rdx,1),%al
  pckt->flags |= F_ICMP;
     95e:	10 aa 11 01 5d 04    	adc    %ch,0x45d0111(%rdx)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     964:	ad                   	lods   %ds:(%rsi),%eax
     965:	16                   	(bad)
     966:	cc                   	int3
     967:	17                   	(bad)
     968:	01 5d 04             	add    %ebx,0x4(%rbp)
     96b:	82                   	(bad)
     96c:	18 c5                	sbb    %al,%ch
     96e:	18 01                	sbb    %al,(%rcx)
     970:	5d                   	pop    %rbp
     971:	04 93                	add    $0x93,%al
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     973:	1c ef                	sbb    $0xef,%al
     975:	1c 01                	sbb    $0x1,%al
     977:	5d                   	pop    %rbp
     978:	04 bd                	add    $0xbd,%al
     97a:	1e                   	(bad)
     97b:	96                   	xchg   %eax,%esi
     97c:	1f                   	(bad)
     97d:	01 5d 04             	add    %ebx,0x4(%rbp)
     980:	f3 27                	repz (bad)
     982:	d9 28                	fldcw  (%rax)
     984:	01 5d 04             	add    %ebx,0x4(%rbp)
     987:	d3 2a                	shrl   %cl,(%rdx)
     989:	a2 31 01 5d 04 b0 32 	movabs %al,0x37ce32b0045d0131
     990:	ce 37 
  if (protocol == IPPROTO_IPIP) {
     992:	01 5d 04             	add    %ebx,0x4(%rbp)
     995:	ef                   	out    %eax,(%dx)
     996:	37                   	(bad)
     997:	c9                   	leave
     998:	39 01                	cmp    %eax,(%rcx)
     99a:	5d                   	pop    %rbp
     99b:	04 d6                	add    $0xd6,%al
     99d:	39 bf 3b 01 5d 04    	cmp    %edi,0x45d013b(%rdi)
  struct address dst_addr = {};
     9a3:	a0 3c f0 3c 01 5d 04 	movabs 0x3e9d045d013cf03c,%al
     9aa:	9d 3e 
     9ac:	b7 3f                	mov    $0x3f,%bh
     9ae:	01 5d 00             	add    %ebx,0x0(%rbp)
    dst_addr.addr = pckt->flow.dst;
     9b1:	04 a5                	add    $0xa5,%al
     9b3:	01 82 02 02 3e 9f    	add    %eax,-0x60c1fdfe(%rdx)
     9b9:	04 dc                	add    $0xdc,%al
     9bb:	03 e2                	add    %edx,%esp
     9bd:	04 02                	add    $0x2,%al
     9bf:	3e 9f                	ds lahf
     9c1:	04 dc                	add    $0xdc,%al
     9c3:	05 97 07 02 3e       	add    $0x3e020797,%eax
     9c8:	9f                   	lahf
     9c9:	04 b0                	add    $0xb0,%al
     9cb:	08 fb                	or     %bh,%bl
  if (decap_dst_flags) {
     9cd:	08 02                	or     %al,(%rdx)
     9cf:	3e 9f                	ds lahf
     9d1:	04 9d                	add    $0x9d,%al
     9d3:	0a 84 10 02 3e 9f 04 	or     0x49f3e02(%rax,%rdx,1),%al
     9da:	f4                   	hlt
     9db:	10 aa 11 02 3e 9f    	adc    %ch,-0x60c1fdef(%rdx)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     9e1:	04 ad                	add    $0xad,%al
     9e3:	16                   	(bad)
     9e4:	cc                   	int3
     9e5:	17                   	(bad)
     9e6:	02 3e                	add    (%rsi),%bh
     9e8:	9f                   	lahf
     9e9:	04 82                	add    $0x82,%al
     9eb:	18 c5                	sbb    %al,%ch
     9ed:	18 02                	sbb    %al,(%rdx)
    if (!data_stats) {
     9ef:	3e 9f                	ds lahf
     9f1:	04 93                	add    $0x93,%al
     9f3:	1c ef                	sbb    $0xef,%al
     9f5:	1c 02                	sbb    $0x2,%al
     9f7:	3e 9f                	ds lahf
     9f9:	04 bd                	add    $0xbd,%al
     9fb:	1e                   	(bad)
     9fc:	96                   	xchg   %eax,%esi
     9fd:	1f                   	(bad)
     9fe:	02 3e                	add    (%rsi),%bh
     a00:	9f                   	lahf
  udp = data + off;
     a01:	04 f3                	add    $0xf3,%al
     a03:	27                   	(bad)
     a04:	d9 28                	fldcw  (%rax)
  if (is_ipv6) {
     a06:	02 3e                	add    (%rsi),%bh
  udp = data + off;
     a08:	9f                   	lahf
     a09:	04 d3                	add    $0xd3,%al
  if (udp + 1 > data_end) {
     a0b:	2a a2 31 02 3e 9f    	sub    -0x60c1fdcf(%rdx),%ah
     a11:	04 b0                	add    $0xb0,%al
     a13:	32 ce                	xor    %dh,%cl
     a15:	37                   	(bad)
     a16:	02 3e                	add    (%rsi),%bh
     a18:	9f                   	lahf
     a19:	04 ef                	add    $0xef,%al
     a1b:	37                   	(bad)
     a1c:	c9                   	leave
     a1d:	39 02                	cmp    %eax,(%rdx)
     a1f:	3e 9f                	ds lahf
     a21:	04 d6                	add    $0xd6,%al
     a23:	39 bf 3b 02 3e 9f    	cmp    %edi,-0x60c1fdc5(%rdi)
     a29:	04 a0                	add    $0xa0,%al
     a2b:	3c f0                	cmp    $0xf0,%al
     a2d:	3c 02                	cmp    $0x2,%al
     a2f:	3e 9f                	ds lahf
     a31:	04 9d                	add    $0x9d,%al
     a33:	3e b7 3f             	ds mov $0x3f,%bh
     a36:	02 3e                	add    (%rsi),%bh
     a38:	9f                   	lahf
     a39:	00 04 a5 01 82 02 02 	add    %al,0x2028201(,%riz,4)
     a40:	31 9f 04 dc 03 e2    	xor    %ebx,-0x1dfc23fc(%rdi)
     a46:	04 02                	add    $0x2,%al
     a48:	31 9f 04 dc 05 97    	xor    %ebx,-0x68fa23fc(%rdi)
    vip.vip = pckt.flow.dst;
     a4e:	07                   	(bad)
     a4f:	02 31                	add    (%rcx),%dh
  vip.port = pckt.flow.port16[1];
     a51:	9f                   	lahf
     a52:	04 b0                	add    $0xb0,%al
     a54:	08 fb                	or     %bh,%bl
     a56:	08 02                	or     %al,(%rdx)
     a58:	31 9f 04 9d 0a 84    	xor    %ebx,-0x7bf562fc(%rdi)
  vip.proto = pckt.flow.proto;
     a5e:	10 02                	adc    %al,(%rdx)
     a60:	31 9f 04 f4 10 aa    	xor    %ebx,-0x55ef0bfc(%rdi)
     a66:	11 02                	adc    %eax,(%rdx)
     a68:	31 9f 04 ad 16 cc    	xor    %ebx,-0x33e952fc(%rdi)
     a6e:	17                   	(bad)
     a6f:	02 31                	add    (%rcx),%dh
     a71:	9f                   	lahf
     a72:	04 82                	add    $0x82,%al
     a74:	18 c5                	sbb    %al,%ch
     a76:	18 02                	sbb    %al,(%rdx)
     a78:	31 9f 04 93 1c ef    	xor    %ebx,-0x10e36cfc(%rdi)
  if (!vip_info) {
     a7e:	1c 02                	sbb    $0x2,%al
     a80:	31 9f 04 bd 1e 96    	xor    %ebx,-0x69e142fc(%rdi)
     a86:	1f                   	(bad)
  if (data_end - data > MAX_PCKT_SIZE) {
     a87:	02 31                	add    (%rcx),%dh
     a89:	9f                   	lahf
     a8a:	04 f3                	add    $0xf3,%al
     a8c:	27                   	(bad)
     a8d:	d9 28                	fldcw  (%rax)
     a8f:	02 31                	add    (%rcx),%dh
     a91:	9f                   	lahf
     a92:	04 d3                	add    $0xd3,%al
     a94:	2a a2 31 02 31 9f    	sub    -0x60cefdcf(%rdx),%ah
     a9a:	04 b0                	add    $0xb0,%al
     a9c:	32 ce                	xor    %dh,%cl
     a9e:	37                   	(bad)
     a9f:	02 31                	add    (%rcx),%dh
     aa1:	9f                   	lahf
     aa2:	04 ef                	add    $0xef,%al
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     aa4:	37                   	(bad)
     aa5:	c9                   	leave
     aa6:	39 02                	cmp    %eax,(%rdx)
     aa8:	31 9f 04 d6 39 bf    	xor    %ebx,-0x40c629fc(%rdi)
     aae:	3b 02                	cmp    (%rdx),%eax
     ab0:	31 9f 04 a0 3c f0    	xor    %ebx,-0xfc35ffc(%rdi)
  if (!data_stats) {
     ab6:	3c 02                	cmp    $0x2,%al
     ab8:	31 9f 04 9d 3e b7    	xor    %ebx,-0x48c162fc(%rdi)
  data_stats->v1 += 1;
     abe:	3f                   	(bad)
     abf:	02 31                	add    (%rcx),%dh
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     ac1:	9f                   	lahf
     ac2:	00 04 a5 01 82 02 01 	add    %al,0x1028201(,%riz,4)
    pckt.flow.port16[0] = 0;
     ac9:	53                   	push   %rbx
     aca:	04 dc                	add    $0xdc,%al
  vip_num = vip_info->vip_num;
     acc:	03 e2                	add    %edx,%esp
     ace:	04 01                	add    $0x1,%al
     ad0:	53                   	push   %rbx
     ad1:	04 dc                	add    $0xdc,%al
     ad3:	05 97 07 01 53       	add    $0x53010797,%eax
     ad8:	04 b0                	add    $0xb0,%al
     ada:	08 fb                	or     %bh,%bl
  __u32 cpu_num = bpf_get_smp_processor_id();
     adc:	08 01                	or     %al,(%rcx)
     ade:	53                   	push   %rbx
     adf:	04 9d                	add    $0x9d,%al
     ae1:	0a 84 10 01 53 04 f4 	or     -0xbfbacff(%rax,%rdx,1),%al
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     ae8:	10 aa 11 01 53 04    	adc    %ch,0x4530111(%rdx)
     aee:	ad                   	lods   %ds:(%rsi),%eax
     aef:	16                   	(bad)
     af0:	94                   	xchg   %eax,%esp
     af1:	17                   	(bad)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     af2:	01 53 04             	add    %edx,0x4(%rbx)
     af5:	82                   	(bad)
     af6:	18 c5                	sbb    %al,%ch
     af8:	18 01                	sbb    %al,(%rcx)
     afa:	53                   	push   %rbx
     afb:	00 04 a5 01 82 02 01 	add    %al,0x1028201(,%riz,4)
     b02:	5f                   	pop    %rdi
     b03:	04 dc                	add    $0xdc,%al
     b05:	03 e2                	add    %edx,%esp
     b07:	04 01                	add    $0x1,%al
     b09:	5f                   	pop    %rdi
     b0a:	04 dc                	add    $0xdc,%al
    if (!lru_stats) {
     b0c:	05 97 07 01 5f       	add    $0x5f010797,%eax
     b11:	04 b0                	add    $0xb0,%al
     b13:	08 fb                	or     %bh,%bl
    lru_stats->v1 += 1;
     b15:	08 01                	or     %al,(%rcx)
     b17:	5f                   	pop    %rdi
     b18:	04 9d                	add    $0x9d,%al
     b1a:	0a 84 10 01 5f 04 f4 	or     -0xbfba0ff(%rax,%rdx,1),%al
     b21:	10 aa 11 01 5f 04    	adc    %ch,0x45f0111(%rdx)
     b27:	ad                   	lods   %ds:(%rsi),%eax
     b28:	16                   	(bad)
     b29:	cc                   	int3
     b2a:	17                   	(bad)
     b2b:	01 5f 04             	add    %ebx,0x4(%rdi)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     b2e:	82                   	(bad)
     b2f:	18 c5                	sbb    %al,%ch
     b31:	18 01                	sbb    %al,(%rcx)
     b33:	5f                   	pop    %rdi
     b34:	04 93                	add    $0x93,%al
     b36:	1c ef                	sbb    $0xef,%al
     b38:	1c 01                	sbb    $0x1,%al
     b3a:	5f                   	pop    %rdi
     b3b:	04 bd                	add    $0xbd,%al
     b3d:	1e                   	(bad)
     b3e:	96                   	xchg   %eax,%esi
     b3f:	1f                   	(bad)
     b40:	01 5f 04             	add    %ebx,0x4(%rdi)
     b43:	f3 27                	repz (bad)
     b45:	d9 28                	fldcw  (%rax)
  if (!lru_map) {
     b47:	01 5f 04             	add    %ebx,0x4(%rdi)
     b4a:	d3 2a                	shrl   %cl,(%rdx)
     b4c:	f1                   	int1
     b4d:	2b 01                	sub    (%rcx),%eax
     b4f:	5f                   	pop    %rdi
     b50:	04 a0                	add    $0xa0,%al
     b52:	3c f0                	cmp    $0xf0,%al
  if ((vip_info->flags & F_QUIC_VIP)) {
     b54:	3c 01                	cmp    $0x1,%al
     b56:	5f                   	pop    %rdi
     b57:	04 9d                	add    $0x9d,%al
     b59:	3e b2 3f             	ds mov $0x3f,%dl
     b5c:	01 5f 00             	add    %ebx,0x0(%rdi)
     b5f:	04 a5                	add    $0xa5,%al
     b61:	01 82 02 02 30 9f    	add    %eax,-0x60cffdfe(%rdx)
    if (is_icmp) {
     b67:	04 dc                	add    $0xdc,%al
     b69:	03 e2                	add    %edx,%esp
     b6b:	04 02                	add    $0x2,%al
     b6d:	30 9f 04 dc 05 97    	xor    %bl,-0x68fa23fc(%rdi)
     b73:	07                   	(bad)
     b74:	02 30                	add    (%rax),%dh
     b76:	9f                   	lahf
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     b77:	04 b0                	add    $0xb0,%al
     b79:	08 fb                	or     %bh,%bl
     b7b:	08 02                	or     %al,(%rdx)
     b7d:	30 9f 04 9d 0a 84    	xor    %bl,-0x7bf562fc(%rdi)
     b83:	10 02                	adc    %al,(%rdx)
     b85:	30 9f 04 f4 10 aa    	xor    %bl,-0x55ef0bfc(%rdi)
      if (!quic_packets_stats) {
     b8b:	11 02                	adc    %eax,(%rdx)
     b8d:	30 9f 04 ad 16 cc    	xor    %bl,-0x33e952fc(%rdi)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b93:	17                   	(bad)
  bool is_icmp = (pckt->flags & F_ICMP);
     b94:	02 30                	add    (%rax),%dh
     b96:	9f                   	lahf
     b97:	04 82                	add    $0x82,%al
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b99:	18 c5                	sbb    %al,%ch
     b9b:	18 02                	sbb    %al,(%rdx)
     b9d:	30 9f 04 93 1c ef    	xor    %bl,-0x10e36cfc(%rdi)
     ba3:	1c 02                	sbb    $0x2,%al
     ba5:	30 9f 04 bd 1e 96    	xor    %bl,-0x69e142fc(%rdi)
     bab:	1f                   	(bad)
     bac:	02 30                	add    (%rax),%dh
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     bae:	9f                   	lahf
     baf:	04 f3                	add    $0xf3,%al
     bb1:	27                   	(bad)
     bb2:	d9 28                	fldcw  (%rax)
     bb4:	02 30                	add    (%rax),%dh
     bb6:	9f                   	lahf
     bb7:	04 d3                	add    $0xd3,%al
     bb9:	2a 9c 2b 02 30 9f 04 	sub    0x49f3002(%rbx,%rbp,1),%bl
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     bc0:	9c                   	pushf
     bc1:	2b d6                	sub    %esi,%edx
     bc3:	2b 01                	sub    (%rcx),%eax
     bc5:	53                   	push   %rbx
     bc6:	04 d6                	add    $0xd6,%al
     bc8:	2b c1                	sub    %ecx,%eax
     bca:	2e 02 30             	cs add (%rax),%dh
    vip.port = 0;
     bcd:	9f                   	lahf
     bce:	04 c1                	add    $0xc1,%al
     bd0:	2e ca 2e 01          	cs lret $0x12e
     bd4:	53                   	push   %rbx
     bd5:	04 d8                	add    $0xd8,%al
     bd7:	2f                   	(bad)
     bd8:	a2 31 01 53 04 93 38 	movabs %al,0x39c9389304530131
     bdf:	c9 39 
    if (!vip_info) {
     be1:	01 53 04             	add    %edx,0x4(%rbx)
     be4:	a0 3c f0 3c 01 53 04 	movabs 0x3e9d0453013cf03c,%al
     beb:	9d 3e 
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     bed:	b7 3f                	mov    $0x3f,%bh
     bef:	01 53 00             	add    %edx,0x0(%rbx)
     bf2:	04 ec                	add    $0xec,%al
     bf4:	01 fb                	add    %edi,%ebx
      pckt.flow.port16[1] = 0;
     bf6:	01 01                	add    %eax,(%rcx)
     bf8:	50                   	push   %rax
     bf9:	00 04 9c             	add    %al,(%rsp,%rbx,4)
     bfc:	02 dc                	add    %ah,%bl
     bfe:	03 02                	add    (%rdx),%eax
     c00:	30 9f 04 fb 08 9d    	xor    %bl,-0x62f704fc(%rdi)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c06:	0a 02                	or     (%rdx),%al
     c08:	30 9f 04 84 10 f4    	xor    %bl,-0xbef7bfc(%rdi)
     c0e:	10 02                	adc    %al,(%rdx)
     c10:	30 9f 04 aa 11 f8    	xor    %bl,-0x7ee55fc(%rdi)
     c16:	13 02                	adc    (%rdx),%eax
     c18:	30 9f 04 81 14 ad    	xor    %bl,-0x52eb7efc(%rdi)
      if (!data_stats) {
     c1e:	16                   	(bad)
     c1f:	02 30                	add    (%rax),%dh
     c21:	9f                   	lahf
     c22:	04 cc                	add    $0xcc,%al
     c24:	17                   	(bad)
      data_stats->v1 += 1;
     c25:	82                   	(bad)
     c26:	18 02                	sbb    %al,(%rdx)
     c28:	30 9f 04 c5 18 93    	xor    %bl,-0x6ce73afc(%rdi)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     c2e:	1c 02                	sbb    $0x2,%al
     c30:	30 9f 04 ef 1c bd    	xor    %bl,-0x42e310fc(%rdi)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     c36:	1e                   	(bad)
     c37:	02 30                	add    (%rax),%dh
     c39:	9f                   	lahf
     c3a:	04 96                	add    $0x96,%al
        data_stats->v2 += 1;
     c3c:	1f                   	(bad)
     c3d:	f3 27                	repz (bad)
     c3f:	02 30                	add    (%rax),%dh
     c41:	9f                   	lahf
     c42:	04 e3                	add    $0xe3,%al
     c44:	28 c0                	sub    %al,%al
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     c46:	2a 02                	sub    (%rdx),%al
     c48:	30 9f 04 bf 3b 99    	xor    %bl,-0x66c440fc(%rdi)
     c4e:	3c 02                	cmp    $0x2,%al
     c50:	30 9f 04 83 3d 93    	xor    %bl,-0x6cc27cfc(%rdi)
     c56:	3e 02 30             	ds add (%rax),%dh
     c59:	9f                   	lahf
     c5a:	04 b7                	add    $0xb7,%al
     c5c:	3f                   	(bad)
     c5d:	9a                   	(bad)
  if (!lru_map) {
     c5e:	41 02 30             	add    (%r8),%sil
     c61:	9f                   	lahf
     c62:	00 04 9c             	add    %al,(%rsp,%rbx,4)
     c65:	02 dc                	add    %ah,%bl
     c67:	03 02                	add    (%rdx),%eax
     c69:	30 9f 04 fb 08 89    	xor    %bl,-0x76f704fc(%rdi)
  if ((vip_info->flags & F_QUIC_VIP)) {
     c6f:	09 02                	or     %eax,(%rdx)
     c71:	30 9f 04 89 09 e3    	xor    %bl,-0x1cf676fc(%rdi)
    bool is_icmp = (pckt.flags & F_ICMP);
     c77:	09 03                	or     %eax,(%rbx)
     c79:	10 22                	adc    %ah,(%rdx)
    if (is_icmp) {
     c7b:	9f                   	lahf
     c7c:	04 84                	add    $0x84,%al
     c7e:	10 f4                	adc    %dh,%ah
     c80:	10 02                	adc    %al,(%rdx)
     c82:	30 9f 04 89 12 81    	xor    %bl,-0x7eed76fc(%rdi)
     c88:	13 03                	adc    (%rbx),%eax
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     c8a:	10 22                	adc    %ah,(%rdx)
     c8c:	9f                   	lahf
     c8d:	00 04 9c             	add    %al,(%rsp,%rbx,4)
     c90:	02 df                	add    %bh,%bl
     c92:	02 03                	add    (%rbx),%al
     c94:	77 08                	ja     c9e <balancer_ingress+0xc9e>
     c96:	9f                   	lahf
     c97:	04 fb                	add    $0xfb,%al
     c99:	08 8d 09 03 77 08    	or     %cl,0x8770309(%rbp)
      if (!quic_packets_stats) {
     c9f:	9f                   	lahf
     ca0:	00 04 9c             	add    %al,(%rsp,%rbx,4)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     ca3:	02 df                	add    %bh,%bl
     ca5:	02 02                	add    (%rdx),%al
  bool is_icmp = (pckt->flags & F_ICMP);
     ca7:	3e 9f                	ds lahf
     ca9:	04 fb                	add    $0xfb,%al
     cab:	08 8d 09 02 3e 9f    	or     %cl,-0x60c1fdf7(%rbp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     cb1:	00 04 9c             	add    %al,(%rsp,%rbx,4)
     cb4:	02 df                	add    %bh,%bl
     cb6:	02 01                	add    (%rcx),%al
     cb8:	53                   	push   %rbx
     cb9:	04 fb                	add    $0xfb,%al
     cbb:	08 8d 09 01 53 00    	or     %cl,0x530109(%rbp)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     cc1:	04 9c                	add    $0x9c,%al
     cc3:	02 df                	add    %bh,%bl
     cc5:	02 01                	add    (%rcx),%al
     cc7:	5f                   	pop    %rdi
     cc8:	04 fb                	add    $0xfb,%al
     cca:	08 8d 09 01 5f 00    	or     %cl,0x5f0109(%rbp)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     cd0:	04 9c                	add    $0x9c,%al
     cd2:	02 df                	add    %bh,%bl
     cd4:	02 02                	add    (%rdx),%al
  if (!connId) {
     cd6:	30 9f 04 fb 08 8d    	xor    %bl,-0x72f704fc(%rdi)
  __u8 connIdVersion = (connId[0] >> 6);
     cdc:	09 02                	or     %eax,(%rdx)
     cde:	30 9f 00 04 9c 02    	xor    %bl,0x29c0400(%rdi)
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     ce4:	a9 02 03 73 0e       	test   $0xe730302,%eax
     ce9:	9f                   	lahf
     cea:	04 a9                	add    $0xa9,%al
     cec:	02 ab 02 01 50 00    	add    0x500102(%rbx),%ch
     cf2:	04 df                	add    $0xdf,%al
     cf4:	02 dc                	add    %ah,%bl
     cf6:	03 01                	add    (%rcx),%eax
     cf8:	53                   	push   %rbx
     cf9:	04 84                	add    $0x84,%al
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     cfb:	10 f4                	adc    %dh,%ah
     cfd:	10 01                	adc    %al,(%rcx)
     cff:	53                   	push   %rbx
     d00:	00 04 df             	add    %al,(%rdi,%rbx,8)
     d03:	02 dc                	add    %ah,%bl
     d05:	03 01                	add    (%rcx),%eax
     d07:	5f                   	pop    %rdi
     d08:	04 84                	add    $0x84,%al
     d0a:	10 f4                	adc    %dh,%ah
     d0c:	10 01                	adc    %al,(%rcx)
     d0e:	5f                   	pop    %rdi
     d0f:	00 04 df             	add    %al,(%rdi,%rbx,8)
     d12:	02 dc                	add    %ah,%bl
     d14:	03 03                	add    (%rbx),%eax
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     d16:	10 22                	adc    %ah,(%rdx)
     d18:	9f                   	lahf
     d19:	04 84                	add    $0x84,%al
     d1b:	10 bc 10 03 10 22 9f 	adc    %bh,-0x60ddeffd(%rax,%rdx,1)
     d22:	04 bc                	add    $0xbc,%al
     d24:	10 f4                	adc    %dh,%ah
     d26:	10 03                	adc    %al,(%rbx)
     d28:	10 2a                	adc    %ch,(%rdx)
     d2a:	9f                   	lahf
     d2b:	00 04 df             	add    %al,(%rdi,%rbx,8)
     d2e:	02 dc                	add    %ah,%bl
      if (!data_stats) {
     d30:	03 03                	add    (%rbx),%eax
     d32:	77 08                	ja     d3c <balancer_ingress+0xd3c>
     d34:	9f                   	lahf
     d35:	04 84                	add    $0x84,%al
     d37:	10 f4                	adc    %dh,%ah
      data_stats->v1 += 1;
     d39:	10 03                	adc    %al,(%rbx)
     d3b:	77 08                	ja     d45 <balancer_ingress+0xd45>
     d3d:	9f                   	lahf
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     d3e:	00 04 df             	add    %al,(%rdi,%rbx,8)
     d41:	02 dc                	add    %ah,%bl
     d43:	03 01                	add    (%rcx),%eax
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     d45:	5c                   	pop    %rsp
     d46:	04 84                	add    $0x84,%al
        data_stats->v2 += 1;
     d48:	10 f4                	adc    %dh,%ah
     d4a:	10 01                	adc    %al,(%rcx)
     d4c:	5c                   	pop    %rsp
     d4d:	00 04 8b             	add    %al,(%rbx,%rcx,4)
  original_sport = pckt.flow.port16[0];
     d50:	03 9e 03 02 30 9f    	add    -0x60cffdfd(%rsi),%ebx
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     d56:	04 9e                	add    $0x9e,%al
     d58:	03 b8 03 01 54 00    	add    0x540103(%rax),%edi
     d5e:	04 a4                	add    $0xa4,%al
     d60:	03 a8 03 03 11 00    	add    0x110303(%rax),%ebp
     d66:	9f                   	lahf
     d67:	04 a8                	add    $0xa8,%al
     d69:	03 ac 03 03 11 02 9f 	add    -0x60fdeefd(%rbx,%rax,1),%ebp
     d70:	04 ac                	add    $0xac,%al
     d72:	03 b1 03 03 11 04    	add    0x4110303(%rcx),%esi
  if (!dst_lru) {
     d78:	9f                   	lahf
     d79:	04 b1                	add    $0xb1,%al
     d7b:	03 b4 03 03 11 06 9f 	add    -0x60f9eefd(%rbx,%rax,1),%esi
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
     d82:	04 b4                	add    $0xb4,%al
     d84:	03 b8 03 03 11 07    	add    0x7110303(%rax),%edi
     d8a:	9f                   	lahf
     d8b:	04 b8                	add    $0xb8,%al
     d8d:	03 be 03 03 11 08    	add    0x8110303(%rsi),%edi
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
     d93:	9f                   	lahf
     d94:	04 be                	add    $0xbe,%al
     d96:	03 dc                	add    %esp,%ebx
     d98:	03 03                	add    (%rbx),%eax
     d9a:	11 09                	adc    %ecx,(%rcx)
     d9c:	9f                   	lahf
     d9d:	00 04 a8             	add    %al,(%rax,%rbp,4)
     da0:	03 ac 03 03 73 12 9f 	add    -0x60ed8cfd(%rbx,%rax,1),%ebp
     da7:	04 ac                	add    $0xac,%al
     da9:	03 b1 03 03 73 16    	add    0x16730303(%rcx),%esi
     daf:	9f                   	lahf
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     db0:	04 b1                	add    $0xb1,%al
     db2:	03 b4 03 03 73 1c 9f 	add    -0x60e38cfd(%rbx,%rax,1),%esi
     db9:	04 b4                	add    $0xb4,%al
     dbb:	03 b8 03 03 73 1e    	add    0x1e730303(%rax),%edi
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
     dc1:	9f                   	lahf
     dc2:	04 b8                	add    $0xb8,%al
     dc4:	03 be 03 03 73 20    	add    0x20730303(%rsi),%edi
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     dca:	9f                   	lahf
     dcb:	04 be                	add    $0xbe,%al
     dcd:	03 dc                	add    %esp,%ebx
     dcf:	03 05 73 20 23 02    	add    0x2232073(%rip),%eax        # 2232e48 <_license+0x2230dae>
     dd5:	9f                   	lahf
     dd6:	00 04 f6             	add    %al,(%rsi,%rsi,8)
     dd9:	03 e2                	add    %edx,%esp
     ddb:	04 02                	add    $0x2,%al
     ddd:	30 9f 04 dc 05 97    	xor    %bl,-0x68fa23fc(%rdi)
     de3:	07                   	(bad)
  if (!conn_rate_stats) {
     de4:	02 30                	add    (%rax),%dh
     de6:	9f                   	lahf
     de7:	04 b0                	add    $0xb0,%al
     de9:	08 fb                	or     %bh,%bl
     deb:	08 02                	or     %al,(%rdx)
     ded:	30 9f 04 9d 0a 84    	xor    %bl,-0x7bf562fc(%rdi)
     df3:	10 02                	adc    %al,(%rdx)
  *cur_time = bpf_ktime_get_ns();
     df5:	30 9f 04 f4 10 aa    	xor    %bl,-0x55ef0bfc(%rdi)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     dfb:	11 02                	adc    %eax,(%rdx)
     dfd:	30 9f 04 ad 16 cc    	xor    %bl,-0x33e952fc(%rdi)
     e03:	17                   	(bad)
     e04:	02 30                	add    (%rax),%dh
    conn_rate_stats->v1 = 1;
     e06:	9f                   	lahf
     e07:	04 82                	add    $0x82,%al
     e09:	18 c5                	sbb    %al,%ch
     e0b:	18 02                	sbb    %al,(%rdx)
    conn_rate_stats->v2 = *cur_time;
     e0d:	30 9f 04 93 1c ef    	xor    %bl,-0x10e36cfc(%rdi)
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     e13:	1c 02                	sbb    $0x2,%al
     e15:	30 9f 04 bd 1e 96    	xor    %bl,-0x69e142fc(%rdi)
     e1b:	1f                   	(bad)
     e1c:	02 30                	add    (%rax),%dh
     e1e:	9f                   	lahf
     e1f:	04 f3                	add    $0xf3,%al
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     e21:	27                   	(bad)
     e22:	d9 28                	fldcw  (%rax)
     e24:	02 30                	add    (%rax),%dh
     e26:	9f                   	lahf
     e27:	04 d3                	add    $0xd3,%al
        quic_packets_stats->cid_initial += 1;
     e29:	2a a2 31 02 30 9f    	sub    -0x60cffdcf(%rdx),%ah
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     e2f:	04 b0                	add    $0xb0,%al
     e31:	32 ce                	xor    %dh,%cl
     e33:	37                   	(bad)
     e34:	02 30                	add    (%rax),%dh
     e36:	9f                   	lahf
     e37:	04 ef                	add    $0xef,%al
     e39:	37                   	(bad)
     e3a:	c9                   	leave
     e3b:	39 02                	cmp    %eax,(%rdx)
     e3d:	30 9f 04 d6 39 bf    	xor    %bl,-0x40c629fc(%rdi)
     e43:	3b 02                	cmp    (%rdx),%eax
     e45:	30 9f 04 a0 3c f0    	xor    %bl,-0xfc35ffc(%rdi)
     e4b:	3c 02                	cmp    $0x2,%al
     e4d:	30 9f 04 9d 3e b7    	xor    %bl,-0x48c162fc(%rdi)
     e53:	3f                   	(bad)
     e54:	02 30                	add    (%rax),%dh
     e56:	9f                   	lahf
     e57:	00 04 f6             	add    %al,(%rsi,%rsi,8)
     e5a:	03 e2                	add    %edx,%esp
     e5c:	04 02                	add    $0x2,%al
     e5e:	30 9f 04 dc 05 80    	xor    %bl,-0x7ffa23fc(%rdi)
  if (!per_vip_stats) {
     e64:	06                   	(bad)
     e65:	02 30                	add    (%rax),%dh
     e67:	9f                   	lahf
     e68:	04 80                	add    $0x80,%al
     e6a:	06                   	(bad)
     e6b:	97                   	xchg   %eax,%edi
     e6c:	07                   	(bad)
     e6d:	03 10                	add    (%rax),%edx
    conn_rate_stats->v1 += 1;
     e6f:	36 9f                	ss lahf
     e71:	04 b0                	add    $0xb0,%al
     e73:	08 c1                	or     %al,%cl
     e75:	08 03                	or     %al,(%rbx)
     e77:	10 36                	adc    %dh,(%rsi)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
     e79:	9f                   	lahf
     e7a:	04 9d                	add    $0x9d,%al
     e7c:	0a 93 0b 02 30 9f    	or     -0x60cffdf5(%rbx),%dl
     e82:	04 9e                	add    $0x9e,%al
     e84:	0d 8e 0e 03 10       	or     $0x10030e8e,%eax
     e89:	36 9f                	ss lahf
     e8b:	00 04 f6             	add    %al,(%rsi,%rsi,8)
     e8e:	03 b4 04 03 77 08 9f 	add    -0x60f788fd(%rsp,%rax,1),%esi
     e95:	04 dc                	add    $0xdc,%al
     e97:	05 88 06 03 77       	add    $0x77030688,%eax
    if (down_reals_map) {
     e9c:	08 9f 00 04 f6 03    	or     %bl,0x3f60400(%rdi)
     ea2:	b4 04                	mov    $0x4,%ah
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
     ea4:	02 3e                	add    (%rsi),%bh
     ea6:	9f                   	lahf
     ea7:	04 dc                	add    $0xdc,%al
     ea9:	05 88 06 02 3e       	add    $0x3e020688,%eax
     eae:	9f                   	lahf
     eaf:	00 04 f6             	add    %al,(%rsi,%rsi,8)
      if (down_real) {
     eb2:	03 b4 04 01 53 04 dc 	add    -0x23fbacff(%rsp,%rax,1),%esi
     eb9:	05 88 06 01 53       	add    $0x53010688,%eax
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
     ebe:	00 04 f6             	add    %al,(%rsi,%rsi,8)
     ec1:	03 b4 04 01 5f 04 dc 	add    -0x23fba0ff(%rsp,%rax,1),%esi
     ec8:	05 88 06 01 5f       	add    $0x5f010688,%eax
     ecd:	00 04 f6             	add    %al,(%rsi,%rsi,8)
     ed0:	03 b4 04 02 31 9f 04 	add    0x49f3102(%rsp,%rax,1),%esi
        if (stats_data) {
     ed7:	dc 05 88 06 02 31    	faddl  0x31020688(%rip)        # 31021565 <_license+0x3101f4cb>
          stats_data->v1 += 1;
     edd:	9f                   	lahf
     ede:	00 04 f6             	add    %al,(%rsi,%rsi,8)
     ee1:	03 83 04 03 73 0e    	add    0xe730304(%rbx),%eax
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     ee7:	9f                   	lahf
     ee8:	00 04 83             	add    %al,(%rbx,%rax,4)
     eeb:	04 b4                	add    $0xb4,%al
     eed:	04 03                	add    $0x3,%al
     eef:	10 28                	adc    %ch,(%rax)
     ef1:	9f                   	lahf
     ef2:	04 dc                	add    $0xdc,%al
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     ef4:	05 88 06 03 10       	add    $0x10030688,%eax
     ef9:	28 9f 00 04 b4 04    	sub    %bl,0x4b40400(%rdi)
        quic_packets_stats->cid_initial += 1;
     eff:	e2 04                	loop   f05 <balancer_ingress+0xf05>
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     f01:	01 53 04             	add    %edx,0x4(%rbx)
     f04:	9d                   	popf
     f05:	0a 93 0b 01 53 00    	or     0x53010b(%rbx),%dl
     f0b:	04 b4                	add    $0xb4,%al
     f0d:	04 e2                	add    $0xe2,%al
     f0f:	04 01                	add    $0x1,%al
     f11:	5f                   	pop    %rdi
     f12:	04 9d                	add    $0x9d,%al
     f14:	0a 93 0b 01 5f 00    	or     0x5f010b(%rbx),%dl
     f1a:	04 b4                	add    $0xb4,%al
     f1c:	04 e2                	add    $0xe2,%al
     f1e:	04 03                	add    $0x3,%al
     f20:	77 08                	ja     f2a <balancer_ingress+0xf2a>
     f22:	9f                   	lahf
     f23:	04 9d                	add    $0x9d,%al
     f25:	0a 93 0b 03 77 08    	or     0x877030b(%rbx),%dl
     f2b:	9f                   	lahf
     f2c:	00 04 b4             	add    %al,(%rsp,%rsi,4)
  if (!per_vip_stats) {
     f2f:	04 e2                	add    $0xe2,%al
     f31:	04 01                	add    $0x1,%al
     f33:	5c                   	pop    %rsp
     f34:	04 9d                	add    $0x9d,%al
     f36:	0a 93 0b 01 5c 00    	or     0x5c010b(%rbx),%dl
     f3c:	04 80                	add    $0x80,%al
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
     f3e:	06                   	(bad)
     f3f:	97                   	xchg   %eax,%edi
     f40:	07                   	(bad)
     f41:	03 11                	add    (%rcx),%edx
     f43:	7f 9f                	jg     ee4 <balancer_ingress+0xee4>
     f45:	04 b0                	add    $0xb0,%al
     f47:	08 fb                	or     %bh,%bl
     f49:	08 03                	or     %al,(%rbx)
     f4b:	11 7f 9f             	adc    %edi,-0x61(%rdi)
  if (!connId) {
     f4e:	04 97                	add    $0x97,%al
     f50:	0b 84 10 03 11 7f 9f 	or     -0x6080eefd(%rax,%rdx,1),%eax
  __u8 connIdVersion = (connId[0] >> 6);
     f57:	04 f4                	add    $0xf4,%al
     f59:	10 aa 11 03 11 7f    	adc    %ch,0x7f110311(%rdx)
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     f5f:	9f                   	lahf
     f60:	04 ad                	add    $0xad,%al
     f62:	16                   	(bad)
     f63:	cc                   	int3
     f64:	17                   	(bad)
     f65:	03 11                	add    (%rcx),%edx
     f67:	7f 9f                	jg     f08 <balancer_ingress+0xf08>
     f69:	04 82                	add    $0x82,%al
     f6b:	18 c5                	sbb    %al,%ch
     f6d:	18 03                	sbb    %al,(%rbx)
     f6f:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     f72:	04 93                	add    $0x93,%al
     f74:	1c ef                	sbb    $0xef,%al
     f76:	1c 03                	sbb    $0x3,%al
     f78:	11 7f 9f             	adc    %edi,-0x61(%rdi)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     f7b:	04 bd                	add    $0xbd,%al
     f7d:	1e                   	(bad)
     f7e:	96                   	xchg   %eax,%esi
     f7f:	1f                   	(bad)
     f80:	03 11                	add    (%rcx),%edx
     f82:	7f 9f                	jg     f23 <balancer_ingress+0xf23>
     f84:	04 f3                	add    $0xf3,%al
     f86:	27                   	(bad)
     f87:	d9 28                	fldcw  (%rax)
     f89:	03 11                	add    (%rcx),%edx
     f8b:	7f 9f                	jg     f2c <balancer_ingress+0xf2c>
     f8d:	04 d3                	add    $0xd3,%al
     f8f:	2a a2 31 03 11 7f    	sub    0x7f110331(%rdx),%ah
     f95:	9f                   	lahf
    dst_lru->atime = cur_time;
     f96:	04 b0                	add    $0xb0,%al
     f98:	32 ce                	xor    %dh,%cl
  key = dst_lru->pos;
     f9a:	37                   	(bad)
     f9b:	03 11                	add    (%rcx),%edx
     f9d:	7f 9f                	jg     f3e <balancer_ingress+0xf3e>
     f9f:	04 ef                	add    $0xef,%al
     fa1:	37                   	(bad)
     fa2:	c9                   	leave
     fa3:	39 03                	cmp    %eax,(%rbx)
     fa5:	11 7f 9f             	adc    %edi,-0x61(%rdi)
  pckt->real_index = key;
     fa8:	04 d6                	add    $0xd6,%al
  *real = bpf_map_lookup_elem(&reals, &key);
     faa:	39 bf 3b 03 11 7f    	cmp    %edi,0x7f11033b(%rdi)
     fb0:	9f                   	lahf
     fb1:	04 a0                	add    $0xa0,%al
     fb3:	3c f0                	cmp    $0xf0,%al
     fb5:	3c 03                	cmp    $0x3,%al
     fb7:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     fba:	04 9d                	add    $0x9d,%al
     fbc:	3e b7 3f             	ds mov $0x3f,%bh
     fbf:	03 11                	add    (%rcx),%edx
     fc1:	7f 9f                	jg     f62 <balancer_ingress+0xf62>
     fc3:	00 04 80             	add    %al,(%rax,%rax,4)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     fc6:	06                   	(bad)
     fc7:	8c 06                	mov    %es,(%rsi)
     fc9:	01 50 04             	add    %edx,0x4(%rax)
     fcc:	b0 08                	mov    $0x8,%al
     fce:	d5                   	(bad)
    if (!dst) {
     fcf:	08 01                	or     %al,(%rcx)
     fd1:	50                   	push   %rax
     fd2:	04 97                	add    $0x97,%al
     fd4:	0b b9 0b 01 50 04    	or     0x450010b(%rcx),%edi
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
     fda:	8e 0c 93             	mov    (%rbx,%rdx,4),%cs
     fdd:	0c 01                	or     $0x1,%al
     fdf:	50                   	push   %rax
     fe0:	04 e8                	add    $0xe8,%al
     fe2:	0c ec                	or     $0xec,%al
     fe4:	0c 01                	or     $0x1,%al
     fe6:	50                   	push   %rax
     fe7:	00 04 80             	add    %al,(%rax,%rax,4)
     fea:	06                   	(bad)
     feb:	97                   	xchg   %eax,%edi
     fec:	07                   	(bad)
     fed:	01 53 04             	add    %edx,0x4(%rbx)
     ff0:	9e                   	sahf
     ff1:	0d 8e 0e 01 53       	or     $0x53010e8e,%eax
     ff6:	00 04 80             	add    %al,(%rax,%rax,4)
     ff9:	06                   	(bad)
     ffa:	97                   	xchg   %eax,%edi
     ffb:	07                   	(bad)
     ffc:	01 5f 04             	add    %ebx,0x4(%rdi)
     fff:	9e                   	sahf
    1000:	0d 8e 0e 01 5f       	or     $0x5f010e8e,%eax
    1005:	00 04 80             	add    %al,(%rax,%rax,4)
  if (!data_stats) {
    1008:	06                   	(bad)
    1009:	97                   	xchg   %eax,%edi
    100a:	07                   	(bad)
    100b:	03 10                	add    (%rax),%edx
    100d:	36 9f                	ss lahf
    100f:	04 9e                	add    $0x9e,%al
    1011:	0d 8e 0e 03 10       	or     $0x10030e8e,%eax
    1016:	36 9f                	ss lahf
    1018:	00 04 80             	add    %al,(%rax,%rax,4)
  data_stats->v1 += 1;
    101b:	06                   	(bad)
    101c:	97                   	xchg   %eax,%edi
    101d:	07                   	(bad)
  data_stats->v2 += pkt_bytes;
    101e:	03 77 08             	add    0x8(%rdi),%esi
    1021:	9f                   	lahf
    1022:	04 9e                	add    $0x9e,%al
    1024:	0d 8e 0e 03 77       	or     $0x77030e8e,%eax
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1029:	08 9f 00 04 80 06    	or     %bl,0x6800400(%rdi)
    102f:	8c 06                	mov    %es,(%rsi)
    1031:	01 50 00             	add    %edx,0x0(%rax)
    1034:	04 88                	add    $0x88,%al
    1036:	06                   	(bad)
    1037:	97                   	xchg   %eax,%edi
    1038:	07                   	(bad)
    1039:	01 53 04             	add    %edx,0x4(%rbx)
    103c:	9e                   	sahf
    103d:	0d 8e 0e 01 53       	or     $0x53010e8e,%eax
    1042:	00 04 88             	add    %al,(%rax,%rcx,4)
    1045:	06                   	(bad)
    1046:	97                   	xchg   %eax,%edi
    1047:	07                   	(bad)
    1048:	01 5f 04             	add    %ebx,0x4(%rdi)
    104b:	9e                   	sahf
    104c:	0d 8e 0e 01 5f       	or     $0x5f010e8e,%eax
  if (!data_stats) {
    1051:	00 04 88             	add    %al,(%rax,%rcx,4)
    1054:	06                   	(bad)
    1055:	97                   	xchg   %eax,%edi
    1056:	07                   	(bad)
    1057:	03 10                	add    (%rax),%edx
    1059:	36 9f                	ss lahf
  data_stats->v1 += 1;
    105b:	04 9e                	add    $0x9e,%al
    105d:	0d d6 0d 03 10       	or     $0x10030dd6,%eax
  pckt.flow.port16[0] = original_sport;
    1062:	36 9f                	ss lahf
    1064:	04 d6                	add    $0xd6,%al
    1066:	0d 8e 0e 03 10       	or     $0x10030e8e,%eax
  if (dst->flags & F_IPV6) {
    106b:	3e 9f                	ds lahf
    106d:	00 04 88             	add    %al,(%rax,%rcx,4)
    1070:	06                   	(bad)
    1071:	97                   	xchg   %eax,%edi
    1072:	07                   	(bad)
    1073:	03 77 08             	add    0x8(%rdi),%esi
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1076:	9f                   	lahf
    1077:	04 9e                	add    $0x9e,%al
    1079:	0d 8e 0e 03 77       	or     $0x77030e8e,%eax
    107e:	08 9f 00 04 88 06    	or     %bl,0x6880400(%rdi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1084:	97                   	xchg   %eax,%edi
    1085:	07                   	(bad)
    1086:	01 5c 04 9e          	add    %ebx,-0x62(%rsp,%rax,1)
    108a:	0d 8e 0e 01 5c       	or     $0x5c010e8e,%eax
    108f:	00 04 b0             	add    %al,(%rax,%rsi,4)
    1092:	06                   	(bad)
  data = (void*)(long)xdp->data;
    1093:	d5                   	(bad)
    1094:	06                   	(bad)
    1095:	02 30                	add    (%rax),%dh
  data_end = (void*)(long)xdp->data_end;
    1097:	9f                   	lahf
    1098:	04 d5                	add    $0xd5,%al
    109a:	06                   	(bad)
  iph = data + sizeof(struct ethhdr);
    109b:	f8                   	clc
    109c:	06                   	(bad)
    109d:	01 52 00             	add    %edx,0x0(%rdx)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    10a0:	04 b0                	add    $0xb0,%al
    10a2:	06                   	(bad)
    10a3:	c2 06 02             	ret    $0x206
    10a6:	30 9f 04 c2 06 97    	xor    %bl,-0x68f93dfc(%rdi)
    10ac:	07                   	(bad)
    10ad:	03 10                	add    (%rax),%edx
    10af:	22 9f 00 04 c2 06    	and    0x6c20400(%rdi),%bl
    10b5:	97                   	xchg   %eax,%edi
    10b6:	07                   	(bad)
    10b7:	03 73 22             	add    0x22(%rbx),%esi
    10ba:	9f                   	lahf
    10bb:	00 04 db             	add    %al,(%rbx,%rbx,8)
    10be:	06                   	(bad)
    10bf:	e0 06                	loopne 10c7 <balancer_ingress+0x10c7>
    10c1:	03 11                	add    (%rcx),%edx
    10c3:	00 9f 04 e0 06 e4    	add    %bl,-0x1bf91ffc(%rdi)
    10c9:	06                   	(bad)
    10ca:	03 11                	add    (%rcx),%edx
    10cc:	01 9f 04 e4 06 e8    	add    %ebx,-0x17f91bfc(%rdi)
    10d2:	06                   	(bad)
    10d3:	03 11                	add    (%rcx),%edx
    10d5:	02 9f 04 e8 06 ec    	add    -0x13f917fc(%rdi),%bl
  memcpy(new_eth->h_dest, cval->mac, 6);
    10db:	06                   	(bad)
    10dc:	03 11                	add    (%rcx),%edx
    10de:	03 9f 04 ec 06 f1    	add    -0xef913fc(%rdi),%ebx
    10e4:	06                   	(bad)
    10e5:	03 11                	add    (%rcx),%edx
    10e7:	04 9f                	add    $0x9f,%al
    10e9:	04 f1                	add    $0xf1,%al
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    10eb:	06                   	(bad)
    10ec:	f4                   	hlt
    10ed:	06                   	(bad)
    10ee:	03 11                	add    (%rcx),%edx
    10f0:	06                   	(bad)
    10f1:	9f                   	lahf
    10f2:	04 f4                	add    $0xf4,%al
    10f4:	06                   	(bad)
    10f5:	f8                   	clc
    10f6:	06                   	(bad)
    10f7:	03 11                	add    (%rcx),%edx
  new_eth->h_proto = BE_ETH_P_IP;
    10f9:	07                   	(bad)
    10fa:	9f                   	lahf
    10fb:	04 f8                	add    $0xf8,%al
    10fd:	06                   	(bad)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    10fe:	fe 06                	incb   (%rsi)
    1100:	03 11                	add    (%rcx),%edx
    1102:	08 9f 04 fe 06 97    	or     %bl,-0x68f901fc(%rdi)
  iph->ihl = 5;
    1108:	07                   	(bad)
    1109:	03 11                	add    (%rcx),%edx
  iph->tos = tos;
    110b:	09 9f 00 04 db 06    	or     %ebx,0x6db0400(%rdi)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1111:	e4 06                	in     $0x6,%al
    1113:	03 73 10             	add    0x10(%rbx),%esi
    1116:	9f                   	lahf
    1117:	04 e4                	add    $0xe4,%al
  iph->id = 0;
    1119:	06                   	(bad)
    111a:	e8 06 03 73 12       	call   12731425 <_license+0x1272f38b>
  iph->daddr = daddr;
    111f:	9f                   	lahf
    1120:	04 e8                	add    $0xe8,%al
  iph->saddr = saddr;
    1122:	06                   	(bad)
    1123:	ec                   	in     (%dx),%al
    1124:	06                   	(bad)
  iph->ttl = DEFAULT_TTL;
    1125:	03 73 14             	add    0x14(%rbx),%esi
    1128:	9f                   	lahf
    1129:	04 ec                	add    $0xec,%al
    112b:	06                   	(bad)
    112c:	f1                   	int1
    112d:	06                   	(bad)
    112e:	03 73 18             	add    0x18(%rbx),%esi
    1131:	9f                   	lahf
    1132:	04 f1                	add    $0xf1,%al
    1134:	06                   	(bad)
    1135:	f4                   	hlt
    1136:	06                   	(bad)
      if (pckt.flow.proto == IPPROTO_TCP) {
    1137:	03 73 1c             	add    0x1c(%rbx),%esi
    113a:	9f                   	lahf
    113b:	04 f4                	add    $0xf4,%al
    113d:	06                   	(bad)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    113e:	f8                   	clc
    113f:	06                   	(bad)
    1140:	03 73 1e             	add    0x1e(%rbx),%esi
    1143:	9f                   	lahf
    1144:	04 f8                	add    $0xf8,%al
    1146:	06                   	(bad)
    1147:	fe 06                	incb   (%rsi)
    1149:	03 73 20             	add    0x20(%rbx),%esi
    114c:	9f                   	lahf
    114d:	04 fe                	add    $0xfe,%al
    114f:	06                   	(bad)
    1150:	97                   	xchg   %eax,%edi
    1151:	07                   	(bad)
    1152:	05 73 20 23 02       	add    $0x2232073,%eax
    1157:	9f                   	lahf
        if (!lru_stats) {
    1158:	00 04 8d 30 9a 30 01 	add    %al,0x1309a30(,%rcx,4)
    115f:	51                   	push   %rcx
    1160:	00 04 db             	add    %al,(%rbx,%rbx,8)
        if (pckt.flags & F_SYN_SET) {
    1163:	08 fb                	or     %bh,%bl
    1165:	08 01                	or     %al,(%rcx)
    1167:	50                   	push   %rax
    1168:	00 04 89             	add    %al,(%rcx,%rcx,4)
    116b:	09 9d 0a 03 11 7f    	or     %ebx,0x7f11030a(%rbp)
    1171:	9f                   	lahf
  struct real_pos_lru new_dst_lru = {};
    1172:	04 aa                	add    $0xaa,%al
    1174:	11 81 13 03 11 7f    	adc    %eax,0x7f110313(%rcx)
    117a:	9f                   	lahf
    117b:	04 85                	add    $0x85,%al
    117d:	13 f8                	adc    %eax,%edi
    117f:	13 03                	adc    (%rbx),%eax
    1181:	11 7f 9f             	adc    %edi,-0x61(%rdi)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1184:	04 81                	add    $0x81,%al
    1186:	14 ad                	adc    $0xad,%al
    1188:	16                   	(bad)
    1189:	03 11                	add    (%rcx),%edx
    118b:	7f 9f                	jg     112c <balancer_ingress+0x112c>
    118d:	04 cc                	add    $0xcc,%al
    118f:	17                   	(bad)
    1190:	82                   	(bad)
    1191:	18 03                	sbb    %al,(%rbx)
    1193:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    1196:	04 c5                	add    $0xc5,%al
    1198:	18 93 1c 03 11 7f    	sbb    %dl,0x7f11031c(%rbx)
    119e:	9f                   	lahf
    119f:	04 ef                	add    $0xef,%al
  if (!conn_rate_stats) {
    11a1:	1c bd                	sbb    $0xbd,%al
    11a3:	1e                   	(bad)
    11a4:	03 11                	add    (%rcx),%edx
    11a6:	7f 9f                	jg     1147 <balancer_ingress+0x1147>
    11a8:	04 96                	add    $0x96,%al
    11aa:	1f                   	(bad)
    11ab:	f3 27                	repz (bad)
  *cur_time = bpf_ktime_get_ns();
    11ad:	03 11                	add    (%rcx),%edx
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    11af:	7f 9f                	jg     1150 <balancer_ingress+0x1150>
    11b1:	04 e3                	add    $0xe3,%al
    11b3:	28 c0                	sub    %al,%al
    11b5:	2a 03                	sub    (%rbx),%al
    11b7:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    11ba:	04 bf                	add    $0xbf,%al
    11bc:	3b 99 3c 03 11 7f    	cmp    0x7f11033c(%rcx),%ebx
    conn_rate_stats->v1 = 1;
    11c2:	9f                   	lahf
    11c3:	04 83                	add    $0x83,%al
    11c5:	3d 93 3e 03 11       	cmp    $0x11033e93,%eax
    conn_rate_stats->v2 = *cur_time;
    11ca:	7f 9f                	jg     116b <balancer_ingress+0x116b>
    11cc:	04 b7                	add    $0xb7,%al
    11ce:	3f                   	(bad)
    11cf:	9a                   	(bad)
    conn_rate_stats->v1 += 1;
    11d0:	41 03 11             	add    (%r9),%edx
    11d3:	7f 9f                	jg     1174 <balancer_ingress+0x1174>
    11d5:	00 04 89             	add    %al,(%rcx,%rcx,4)
    11d8:	09 91 09 01 50 04    	or     %edx,0x4500109(%rcx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    11de:	d2 09                	rorb   %cl,(%rcx)
    11e0:	f7 09 01 50 04 aa    	testl  $0xaa045001,(%rcx)
    11e6:	11 bf 11 01 50 04    	adc    %edi,0x4500111(%rdi)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    11ec:	85 13                	test   %edx,(%rbx)
    11ee:	b3 13                	mov    $0x13,%bl
    11f0:	01 50 04             	add    %edx,0x4(%rax)
    11f3:	81 14 85 14 01 50 00 	adcl   $0xd2098904,0x500114(,%rax,4)
    11fa:	04 89 09 d2 
      pckt->flow.port16[0] = pckt->flow.port16[1];
    11fe:	09 01                	or     %eax,(%rcx)
    1200:	53                   	push   %rbx
      memset(pckt->flow.srcv6, 0, 16);
    1201:	04 89                	add    $0x89,%al
    1203:	12 81 13 01 53 00    	adc    0x530113(%rcx),%al
    1209:	04 89                	add    $0x89,%al
    120b:	09 d2                	or     %edx,%edx
    120d:	09 01                	or     %eax,(%rcx)
    120f:	5f                   	pop    %rdi
    1210:	04 89                	add    $0x89,%al
    1212:	12 81 13 01 5f 00    	adc    0x5f0113(%rcx),%al
    1218:	04 89                	add    $0x89,%al
  b += initval;
    121a:	09 d2                	or     %edx,%edx
    121c:	09 03                	or     %eax,(%rbx)
  a += initval;
    121e:	10 22                	adc    %ah,(%rdx)
    1220:	9f                   	lahf
    1221:	04 89                	add    $0x89,%al
    1223:	12 81 13 03 10 22    	adc    0x22100313(%rcx),%al
  __jhash_final(a, b, c);
    1229:	9f                   	lahf
    122a:	00 04 89             	add    %al,(%rcx,%rcx,4)
  return (word << shift) | (word >> ((-shift) & 31));
    122d:	09 d2                	or     %edx,%edx
    122f:	09 03                	or     %eax,(%rbx)
  __jhash_final(a, b, c);
    1231:	77 08                	ja     123b <balancer_ingress+0x123b>
    1233:	9f                   	lahf
    1234:	04 89                	add    $0x89,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1236:	12 81 13 03 77 08    	adc    0x8770313(%rcx),%al
  __jhash_final(a, b, c);
    123c:	9f                   	lahf
    123d:	00 04 89             	add    %al,(%rcx,%rcx,4)
  return (word << shift) | (word >> ((-shift) & 31));
    1240:	09 91 09 01 50 00    	or     %edx,0x500109(%rcx)
  __jhash_final(a, b, c);
    1246:	04 8d                	add    $0x8d,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1248:	09 d2                	or     %edx,%edx
    124a:	09 01                	or     %eax,(%rcx)
  __jhash_final(a, b, c);
    124c:	53                   	push   %rbx
    124d:	04 89                	add    $0x89,%al
    124f:	12 81 13 01 53 00    	adc    0x530113(%rcx),%al
    1255:	04 8d                	add    $0x8d,%al
    1257:	09 d2                	or     %edx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1259:	09 01                	or     %eax,(%rcx)
    125b:	5f                   	pop    %rdi
  __jhash_final(a, b, c);
    125c:	04 89                	add    $0x89,%al
    125e:	12 81 13 01 5f 00    	adc    0x5f0113(%rcx),%al
    1264:	04 8d                	add    $0x8d,%al
    1266:	09 d2                	or     %edx,%edx
    1268:	09 03                	or     %eax,(%rbx)
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    126a:	10 22                	adc    %ah,(%rdx)
    126c:	9f                   	lahf
    126d:	04 89                	add    $0x89,%al
    126f:	12 c2                	adc    %dl,%al
    1271:	12 03                	adc    (%rbx),%al
    1273:	10 22                	adc    %ah,(%rdx)
    1275:	9f                   	lahf
    1276:	04 c2                	add    $0xc2,%al
    1278:	12 81 13 03 10 2a    	adc    0x2a100313(%rcx),%al
    127e:	9f                   	lahf
    127f:	00 04 8d 09 d2 09 03 	add    %al,0x309d209(,%rcx,4)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1286:	77 08                	ja     1290 <balancer_ingress+0x1290>
    1288:	9f                   	lahf
    1289:	04 89                	add    $0x89,%al
    128b:	12 81 13 03 77 08    	adc    0x8770313(%rcx),%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1291:	9f                   	lahf
    if (!real_pos) {
    1292:	00 04 8d 09 d2 09 01 	add    %al,0x109d209(,%rcx,4)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1299:	5c                   	pop    %rsp
    129a:	04 89                	add    $0x89,%al
    129c:	12 81 13 01 5c 00    	adc    0x5c0113(%rcx),%al
    12a2:	04 fd                	add    $0xfd,%al
    key = *real_pos;
    12a4:	09 9d 0a 01 50 00    	or     %ebx,0x50010a(%rbp)
    12aa:	04 9d                	add    $0x9d,%al
    12ac:	0a ae 0a 02 30 9f    	or     -0x60cffdf6(%rsi),%ch
  pckt->real_index = key;
    12b2:	04 ae                	add    $0xae,%al
  *real = bpf_map_lookup_elem(&reals, &key);
    12b4:	0a b7 0a 01 50 00    	or     0x50010a(%rdi),%dh
  if (!(*real)) {
    12ba:	04 b7                	add    $0xb7,%al
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    12bc:	0a d6                	or     %dh,%dl
    12be:	0a 01                	or     (%rcx),%al
    12c0:	50                   	push   %rax
    12c1:	00 04 c9             	add    %al,(%rcx,%rcx,8)
    12c4:	0a d6                	or     %dh,%dl
    12c6:	0a 01                	or     (%rcx),%al
    12c8:	52                   	push   %rdx
    12c9:	00 04 d6             	add    %al,(%rsi,%rdx,8)
    12cc:	0a 93 0b 03 10 3e    	or     0x3e10030b(%rbx),%dl
    12d2:	9f                   	lahf
    12d3:	00 04 d6             	add    %al,(%rsi,%rdx,8)
  if (!ch_drop_stats) {
    12d6:	0a 93 0b 03 73 3e    	or     0x3e73030b(%rbx),%dl
    12dc:	9f                   	lahf
    12dd:	00 04 c8             	add    %al,(%rax,%rcx,8)
    12e0:	0b dd                	or     %ebp,%ebx
    12e2:	0b 02                	or     (%rdx),%eax
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    12e4:	30 9f 04 dd 0b e6    	xor    %bl,-0x19f422fc(%rdi)
    12ea:	0b 01                	or     (%rcx),%eax
    12ec:	50                   	push   %rax
    12ed:	00 04 d2             	add    %al,(%rdx,%rdx,8)
    12f0:	0b dd                	or     %ebp,%ebx
    12f2:	0b 01                	or     (%rcx),%eax
    12f4:	55                   	push   %rbp
    12f5:	00 04 da             	add    %al,(%rdx,%rbx,8)
    12f8:	0b e6                	or     %esi,%esp
    12fa:	0b 04 77             	or     (%rdi,%rsi,2),%eax
    12fd:	c0 00 9f             	rolb   $0x9f,(%rax)
  if (!ch_drop_stats) {
    1300:	00 04 dd 0b f0 0b 01 	add    %al,0x10bf00b(,%rbx,8)
    1307:	50                   	push   %rax
    1308:	00 04 e6             	add    %al,(%rsi,%riz,8)
    130b:	0b f7                	or     %edi,%esi
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    130d:	0b 02                	or     (%rdx),%eax
    130f:	30 9f 04 f7 0b 80    	xor    %bl,-0x7ff408fc(%rdi)
    1315:	0c 01                	or     $0x1,%al
    1317:	50                   	push   %rax
    1318:	00 04 80             	add    %al,(%rax,%rax,4)
    131b:	0c 8e                	or     $0x8e,%al
    131d:	0c 01                	or     $0x1,%al
    131f:	50                   	push   %rax
    1320:	00 04 a2             	add    %al,(%rdx,%riz,4)
    1323:	0c b7                	or     $0xb7,%al
    1325:	0c 02                	or     $0x2,%al
    1327:	30 9f 04 b7 0c c0    	xor    %bl,-0x3ff348fc(%rdi)
    132d:	0c 01                	or     $0x1,%al
    132f:	50                   	push   %rax
    1330:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    1333:	0c b7                	or     $0xb7,%al
    1335:	0c 01                	or     $0x1,%al
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1337:	55                   	push   %rbp
    1338:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    133b:	0c c0                	or     $0xc0,%al
    133d:	0c 04                	or     $0x4,%al
    133f:	77 c0                	ja     1301 <balancer_ingress+0x1301>
    1341:	00 9f 00 04 b7 0c    	add    %bl,0xcb70400(%rdi)
    1347:	ca 0c 01             	lret   $0x10c
  data = (void*)(long)xdp->data;
    134a:	50                   	push   %rax
    134b:	00 04 c0             	add    %al,(%rax,%rax,8)
  data_end = (void*)(long)xdp->data_end;
    134e:	0c d1                	or     $0xd1,%al
  ip6h = data + sizeof(struct ethhdr);
    1350:	0c 02                	or     $0x2,%al
    1352:	30 9f 04 d1 0c da    	xor    %bl,-0x25f32efc(%rdi)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1358:	0c 01                	or     $0x1,%al
    135a:	50                   	push   %rax
    135b:	00 04 da             	add    %al,(%rdx,%rbx,8)
    135e:	0c e8                	or     $0xe8,%al
    1360:	0c 01                	or     $0x1,%al
    1362:	50                   	push   %rax
    1363:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    1366:	0c ff                	or     $0xff,%al
    1368:	0c 01                	or     $0x1,%al
    136a:	50                   	push   %rax
    136b:	00 04 a4             	add    %al,(%rsp,%riz,4)
    136e:	0d b5 0d 02 30       	or     $0x30020db5,%eax
    1373:	9f                   	lahf
    1374:	04 b5                	add    $0xb5,%al
    1376:	0d be 0d 01 52       	or     $0x52010dbe,%eax
    137b:	00 04 be             	add    %al,(%rsi,%rdi,4)
  memcpy(new_eth->h_dest, cval->mac, 6);
    137e:	0d d6 0d 01 52       	or     $0x52010dd6,%eax
    1383:	00 04 d6             	add    %al,(%rsi,%rdx,8)
    1386:	0d e3 0d 03 73       	or     $0x73030de3,%eax
    138b:	3e 9f                	ds lahf
    138d:	04 e3                	add    $0xe3,%al
    138f:	0d e5 0d 01 50       	or     $0x50010de5,%eax
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1394:	00 04 c9             	add    %al,(%rcx,%rcx,8)
    1397:	0e                   	(bad)
    1398:	e4 0e                	in     $0xe,%al
    139a:	02 30                	add    (%rax),%dh
    139c:	9f                   	lahf
    139d:	04 e4                	add    $0xe4,%al
  new_eth->h_proto = BE_ETH_P_IPV6;
    139f:	0e                   	(bad)
    13a0:	ed                   	in     (%dx),%eax
    13a1:	0e                   	(bad)
    13a2:	01 55 00             	add    %edx,0x0(%rbp)
    13a5:	04 d3                	add    $0xd3,%al
    13a7:	0e                   	(bad)
    13a8:	ed                   	in     (%dx),%eax
    13a9:	0e                   	(bad)
  saddr[3] = src ^ port;
    13aa:	01 5e 00             	add    %ebx,0x0(%rsi)
    13ad:	04 e4                	add    $0xe4,%al
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    13af:	0e                   	(bad)
    13b0:	84 10                	test   %dl,(%rax)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    13b2:	01 55 04             	add    %edx,0x4(%rbp)
    13b5:	f4                   	hlt
    13b6:	10 86 11 01 55 04    	adc    %al,0x4550111(%rsi)
  ip6h->priority = (tc & 0xF0) >> 4;
    13bc:	89 11                	mov    %edx,(%rcx)
    13be:	9e                   	sahf
    13bf:	11 01                	adc    %eax,(%rcx)
    13c1:	50                   	push   %rax
    13c2:	04 9e                	add    $0x9e,%al
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    13c4:	11 aa 11 01 55 04    	adc    %ebp,0x4550111(%rdx)
  ip6h->nexthdr = proto;
    13ca:	ad                   	lods   %ds:(%rsi),%eax
    13cb:	16                   	(bad)
    13cc:	dc 16                	fcoml  (%rsi)
    13ce:	01 55 04             	add    %edx,0x4(%rbp)
  ip6h->payload_len = bpf_htons(payload_len);
    13d1:	dc 16                	fcoml  (%rsi)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    13d3:	e2 16                	loop   13eb <balancer_ingress+0x13eb>
    13d5:	02 77 38             	add    0x38(%rdi),%dh
    13d8:	04 e2                	add    $0xe2,%al
    13da:	16                   	(bad)
    13db:	cc                   	int3
    13dc:	17                   	(bad)
    13dd:	01 55 04             	add    %edx,0x4(%rbp)
    13e0:	82                   	(bad)
    13e1:	18 b6 18 01 55 04    	sbb    %dh,0x4550118(%rsi)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    13e7:	bc 18 c5 18 01       	mov    $0x118c518,%esp
    13ec:	55                   	push   %rbp
    13ed:	04 93                	add    $0x93,%al
    13ef:	1c bb                	sbb    $0xbb,%al
    13f1:	1c 01                	sbb    $0x1,%al
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    13f3:	55                   	push   %rbp
    13f4:	04 c1                	add    $0xc1,%al
    13f6:	1c ef                	sbb    $0xef,%al
    13f8:	1c 01                	sbb    $0x1,%al
    13fa:	55                   	push   %rbp
    13fb:	04 bd                	add    $0xbd,%al
    13fd:	1e                   	(bad)
    13fe:	96                   	xchg   %eax,%esi
    13ff:	1f                   	(bad)
    1400:	01 55 04             	add    %edx,0x4(%rbp)
    1403:	f3 27                	repz (bad)
    1405:	d9 28                	fldcw  (%rax)
    1407:	01 55 04             	add    %edx,0x4(%rbp)
    140a:	d3 2a                	shrl   %cl,(%rdx)
    140c:	aa                   	stos   %al,%es:(%rdi)
    140d:	2b 01                	sub    (%rcx),%eax
    140f:	55                   	push   %rbp
    1410:	04 be                	add    $0xbe,%al
    1412:	2b d6                	sub    %esi,%edx
    1414:	2b 02                	sub    (%rdx),%eax
    1416:	77 38                	ja     1450 <balancer_ingress+0x1450>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1418:	04 d6                	add    $0xd6,%al
    141a:	2b 82 2c 01 55 04    	sub    0x455012c(%rdx),%eax
    1420:	92                   	xchg   %eax,%edx
    1421:	2c bf                	sub    $0xbf,%al
    1423:	2c 02                	sub    $0x2,%al
    1425:	77 38                	ja     145f <balancer_ingress+0x145f>
    1427:	04 bf                	add    $0xbf,%al
    1429:	2c c3                	sub    $0xc3,%al
    142b:	2c 01                	sub    $0x1,%al
    142d:	55                   	push   %rbp
    142e:	04 c3                	add    $0xc3,%al
    1430:	2c f5                	sub    $0xf5,%al
    1432:	2c 02                	sub    $0x2,%al
    1434:	77 38                	ja     146e <balancer_ingress+0x146e>
      if (qpr.server_id > 0) {
    1436:	04 f5                	add    $0xf5,%al
    1438:	2c b6                	sub    $0xb6,%al
    143a:	2d 01 55 04 b6       	sub    $0xb6045501,%eax
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    143f:	2d a2 31 02 77       	sub    $0x770231a2,%eax
    1444:	38 04 b0             	cmp    %al,(%rax,%rsi,4)
    1447:	32 e4                	xor    %ah,%ah
    1449:	33 02                	xor    (%rdx),%eax
    144b:	77 38                	ja     1485 <balancer_ingress+0x1485>
    144d:	04 e4                	add    $0xe4,%al
    144f:	33 f1                	xor    %ecx,%esi
    1451:	33 01                	xor    (%rcx),%eax
    1453:	52                   	push   %rdx
    1454:	04 f1                	add    $0xf1,%al
    1456:	33 8b 34 02 77 38    	xor    0x38770234(%rbx),%ecx
    145c:	04 8b                	add    $0x8b,%al
    145e:	34 90                	xor    $0x90,%al
    1460:	34 01                	xor    $0x1,%al
    1462:	52                   	push   %rdx
    if (pckt->flow.proto == IPPROTO_UDP) {
    1463:	04 90                	add    $0x90,%al
    1465:	34 d6                	xor    $0xd6,%al
    1467:	36 02 77 38          	ss add 0x38(%rdi),%dh
      new_dst_lru.atime = cur_time;
    146b:	04 d6                	add    $0xd6,%al
    146d:	36 db 36             	ss (bad) (%rsi)
    new_dst_lru.pos = key;
    1470:	01 52 04             	add    %edx,0x4(%rdx)
    1473:	db 36                	(bad)  (%rsi)
    1475:	ce                   	(bad)
    1476:	37                   	(bad)
    1477:	02 77 38             	add    0x38(%rdi),%dh
BPF_MAP_OPS_INLINE(map_update_elem,,
    147a:	04 ef                	add    $0xef,%al
    147c:	37                   	(bad)
    147d:	fc                   	cld
    147e:	37                   	(bad)
    147f:	02 77 38             	add    0x38(%rdi),%dh
    1482:	04 fc                	add    $0xfc,%al
    1484:	37                   	(bad)
    1485:	fe                   	(bad)
    1486:	37                   	(bad)
    1487:	01 52 04             	add    %edx,0x4(%rdx)
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    148a:	fe                   	(bad)
    148b:	37                   	(bad)
    148c:	c9                   	leave
    148d:	39 02                	cmp    %eax,(%rdx)
    148f:	77 38                	ja     14c9 <balancer_ingress+0x14c9>
    1491:	04 d6                	add    $0xd6,%al
    1493:	39 bf 3b 02 77 38    	cmp    %edi,0x3877023b(%rdi)
    1499:	04 a0                	add    $0xa0,%al
    149b:	3c f0                	cmp    $0xf0,%al
    149d:	3c 02                	cmp    $0x2,%al
  bool port_match = lru_miss_stat_vip->port == vip->port;
    149f:	77 38                	ja     14d9 <balancer_ingress+0x14d9>
    14a1:	04 9d                	add    $0x9d,%al
    14a3:	3e b7 3f             	ds mov $0x3f,%bh
    14a6:	02 77 38             	add    0x38(%rdi),%dh
    14a9:	00 04 ff             	add    %al,(%rdi,%rdi,8)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    14ac:	0e                   	(bad)
    14ad:	84 10                	test   %dl,(%rax)
    14af:	04 10                	add    $0x10,%al
    14b1:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    14b5:	ad                   	lods   %ds:(%rsi),%eax
    14b6:	16                   	(bad)
    14b7:	cc                   	int3
  bool vip_match = address_match && port_match && proto_match;
    14b8:	17                   	(bad)
    14b9:	04 10                	add    $0x10,%al
    14bb:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    14bf:	82                   	(bad)
    14c0:	18 c5                	sbb    %al,%ch
    14c2:	18 04 10             	sbb    %al,(%rax,%rdx,1)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    14c5:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    14c9:	93                   	xchg   %eax,%ebx
    14ca:	1c ef                	sbb    $0xef,%al
    14cc:	1c 04                	sbb    $0x4,%al
    14ce:	10 80 04 9f 04 bd    	adc    %al,-0x42fb60fc(%rax)
    14d4:	1e                   	(bad)
    14d5:	96                   	xchg   %eax,%esi
    14d6:	1f                   	(bad)
    14d7:	04 10                	add    $0x10,%al
    14d9:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    14dd:	f3 27                	repz (bad)
    14df:	d9 28                	fldcw  (%rax)
    14e1:	04 10                	add    $0x10,%al
    14e3:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    14e7:	d3 2a                	shrl   %cl,(%rdx)
    14e9:	a2 31 04 10 80 04 9f 	movabs %al,0xb0049f0480100431
    14f0:	04 b0 
    if (!lru_miss_stat) {
    14f2:	32 ce                	xor    %dh,%cl
    *lru_miss_stat += 1;
    14f4:	37                   	(bad)
    14f5:	04 10                	add    $0x10,%al
    14f7:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    14fb:	ef                   	out    %eax,(%dx)
    14fc:	37                   	(bad)
    14fd:	c9                   	leave
    14fe:	39 04 10             	cmp    %eax,(%rax,%rdx,1)
    1501:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1505:	d6                   	(bad)
    1506:	39 bf 3b 04 10 80    	cmp    %edi,-0x7feffbc5(%rdi)
    150c:	04 9f                	add    $0x9f,%al
    150e:	04 a0                	add    $0xa0,%al
    1510:	3c f0                	cmp    $0xf0,%al
    1512:	3c 04                	cmp    $0x4,%al
    1514:	10 80 04 9f 04 9d    	adc    %al,-0x62fb60fc(%rax)
      data_stats->v2 += 1;
    151a:	3e b7 3f             	ds mov $0x3f,%bh
    151d:	04 10                	add    $0x10,%al
    151f:	80 04 9f 00          	addb   $0x0,(%rdi,%rbx,4)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1523:	04 ff                	add    $0xff,%al
    1525:	0e                   	(bad)
    1526:	90                   	nop
    1527:	0f 02 30             	lar    (%rax),%esi
    152a:	9f                   	lahf
    152b:	04 90                	add    $0x90,%al
    152d:	0f 99 0f             	setns  (%rdi)
    1530:	01 5e 00             	add    %ebx,0x0(%rsi)
  if (!connId) {
    1533:	04 99                	add    $0x99,%al
    1535:	0f 84 10 01 5e 04    	je     45e164b <_license+0x45df5b1>
    153b:	ad                   	lods   %ds:(%rsi),%eax
    153c:	16                   	(bad)
    153d:	cc                   	int3
    153e:	17                   	(bad)
    153f:	01 5e 04             	add    %ebx,0x4(%rsi)
    1542:	82                   	(bad)
    1543:	18 c5                	sbb    %al,%ch
    1545:	18 01                	sbb    %al,(%rcx)
    1547:	5e                   	pop    %rsi
    1548:	04 93                	add    $0x93,%al
    154a:	1c ef                	sbb    $0xef,%al
    154c:	1c 01                	sbb    $0x1,%al
    154e:	5e                   	pop    %rsi
    154f:	04 bd                	add    $0xbd,%al
    1551:	1e                   	(bad)
    1552:	96                   	xchg   %eax,%esi
    1553:	1f                   	(bad)
    1554:	01 5e 04             	add    %ebx,0x4(%rsi)
    1557:	f3 27                	repz (bad)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1559:	d9 28                	fldcw  (%rax)
    155b:	01 5e 04             	add    %ebx,0x4(%rsi)
        if (real_pos) {
    155e:	d3 2a                	shrl   %cl,(%rdx)
    1560:	ca 2e 01             	lret   $0x12e
    1563:	5e                   	pop    %rsi
    1564:	04 f6                	add    $0xf6,%al
    1566:	2e 99                	cs cltd
    1568:	2f                   	(bad)
    1569:	01 52 04             	add    %edx,0x4(%rdx)
          key = *real_pos;
    156c:	c1 2f f9             	shrl   $0xf9,(%rdi)
    156f:	2f                   	(bad)
    1570:	01 52 04             	add    %edx,0x4(%rdx)
    1573:	b0 32                	mov    $0x32,%al
          if (key == 0) {
    1575:	ce                   	(bad)
            pckt.real_index = key;
    1576:	37                   	(bad)
    1577:	01 5e 04             	add    %ebx,0x4(%rsi)
    157a:	ef                   	out    %eax,(%dx)
    157b:	37                   	(bad)
            dst = bpf_map_lookup_elem(&reals, &key);
    157c:	93                   	xchg   %eax,%ebx
    157d:	38 01                	cmp    %al,(%rcx)
    157f:	5e                   	pop    %rsi
    1580:	04 93                	add    $0x93,%al
    1582:	38 a4 38 01 52 04 d6 	cmp    %ah,-0x29fbadff(%rax,%rdi,1)
    1589:	39 bf 3b 01 5e 04    	cmp    %edi,0x45e013b(%rdi)
    158f:	a0 3c b1 3c 01 5e 04 	movabs 0x3e9d045e013cb13c,%al
    1596:	9d 3e 
    1598:	d9 3e                	fnstcw (%rsi)
    159a:	01 5e 00             	add    %ebx,0x0(%rsi)
            if (!dst) {
    159d:	04 bc                	add    $0xbc,%al
    159f:	0f c5                	pextrw $0xc5,(bad),%ecx
    15a1:	0f 0c                	(bad)
    15a3:	10 b4 a0 e4 a1 fa ff 	adc    %dh,-0x55e1c(%rax,%riz,4)
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    15aa:	ff                   	(bad)
    15ab:	ff                   	(bad)
    15ac:	ff 01                	incl   (%rcx)
    15ae:	9f                   	lahf
    15af:	04 c5                	add    $0xc5,%al
    15b1:	0f c8                	bswap  %eax
    15b3:	0f 01 50 00          	lgdt   0x0(%rax)
  if (dst_lru) {
    15b7:	04 c8                	add    $0xc8,%al
    15b9:	0f d3 0f             	psrlq  (%rdi),%mm1
    15bc:	0d 70 00 a8 b5       	or     $0xb5a80070,%eax
    if (dst_lru->pos == pckt->real_index) {
    15c1:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
    15c8:	00 9f 04 ad 16 af    	add    %bl,-0x50e952fc(%rdi)
              quic_packets_stats->dst_match_in_lru += 1;
    15ce:	16                   	(bad)
    15cf:	0d 70 00 a8 b5       	or     $0xb5a80070,%eax
    15d4:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
    15db:	00 9f 00 04 c8 0f    	add    %bl,0xfc80400(%rdi)
    15e1:	d3 0f                	rorl   %cl,(%rdi)
    15e3:	0d 70 00 a8 b5       	or     $0xb5a80070,%eax
    15e8:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
  original_sport = pckt.flow.port16[0];
    15ef:	00 9f 04 ad 16 af    	add    %bl,-0x50e952fc(%rdi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    15f5:	16                   	(bad)
    15f6:	0d 70 00 a8 b5       	or     $0xb5a80070,%eax
    15fb:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
    1602:	00 9f 00 04 c8 0f    	add    %bl,0xfc80400(%rdi)
    1608:	d3 0f                	rorl   %cl,(%rdi)
    160a:	02 30                	add    (%rax),%dh
    160c:	9f                   	lahf
  if (!dst_lru) {
    160d:	04 ad                	add    $0xad,%al
    160f:	16                   	(bad)
    1610:	c1 16 02             	rcll   $0x2,(%rsi)
    1613:	30 9f 04 c1 16 c6    	xor    %bl,-0x39e93efc(%rdi)
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1619:	16                   	(bad)
    161a:	01 50 04             	add    %edx,0x4(%rax)
    161d:	c6                   	(bad)
    161e:	16                   	(bad)
    161f:	cf                   	iret
    1620:	16                   	(bad)
    1621:	03 77 d0             	add    -0x30(%rdi),%esi
    cur_time = bpf_ktime_get_ns();
    1624:	00 00                	add    %al,(%rax)
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1626:	04 c8                	add    $0xc8,%al
    1628:	0f d3 0f             	psrlq  (%rdi),%mm1
    162b:	02 3c 9f             	add    (%rdi,%rbx,4),%bh
    162e:	04 ad                	add    $0xad,%al
    1630:	16                   	(bad)
    1631:	cf                   	iret
    1632:	16                   	(bad)
    1633:	02 3c 9f             	add    (%rdi,%rbx,4),%bh
    1636:	00 04 c8             	add    %al,(%rax,%rcx,8)
    1639:	0f d3 0f             	psrlq  (%rdi),%mm1
    163c:	04 10                	add    $0x10,%al
    163e:	80 01 9f             	addb   $0x9f,(%rcx)
    1641:	04 ad                	add    $0xad,%al
    dst_lru->atime = cur_time;
    1643:	16                   	(bad)
    1644:	cf                   	iret
    1645:	16                   	(bad)
    1646:	04 10                	add    $0x10,%al
  key = dst_lru->pos;
    1648:	80 01 9f             	addb   $0x9f,(%rcx)
    164b:	00 04 c8             	add    %al,(%rax,%rcx,8)
    164e:	0f d3 0f             	psrlq  (%rdi),%mm1
    1651:	02 38                	add    (%rax),%bh
  pckt->real_index = key;
    1653:	9f                   	lahf
    1654:	04 ad                	add    $0xad,%al
  *real = bpf_map_lookup_elem(&reals, &key);
    1656:	16                   	(bad)
    1657:	cf                   	iret
    1658:	16                   	(bad)
    1659:	02 38                	add    (%rax),%bh
    165b:	9f                   	lahf
    165c:	00 04 d3             	add    %al,(%rbx,%rdx,8)
    165f:	0f da 0f             	pminub (%rdi),%mm1
    1662:	02 30                	add    (%rax),%dh
    1664:	9f                   	lahf
    1665:	04 da                	add    $0xda,%al
    1667:	0f e3 0f             	pavgw  (%rdi),%mm1
    166a:	01 50 00             	add    %edx,0x0(%rax)
    166d:	04 e3                	add    $0xe3,%al
    166f:	0f fa 0f             	psubd  (%rdi),%mm1
    1672:	01 50 00             	add    %edx,0x0(%rax)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1675:	04 c1                	add    $0xc1,%al
    1677:	16                   	(bad)
    1678:	c6                   	(bad)
    1679:	16                   	(bad)
    167a:	01 50 04             	add    %edx,0x4(%rax)
    167d:	c6                   	(bad)
    167e:	16                   	(bad)
    167f:	cc                   	int3
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1680:	17                   	(bad)
    1681:	03 77 d0             	add    -0x30(%rdi),%esi
    1684:	00 04 82             	add    %al,(%rdx,%rax,4)
    1687:	18 c5                	sbb    %al,%ch
    1689:	18 03                	sbb    %al,(%rbx)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    168b:	77 d0                	ja     165d <balancer_ingress+0x165d>
    168d:	00 04 93             	add    %al,(%rbx,%rdx,4)
    1690:	1c ef                	sbb    $0xef,%al
    1692:	1c 03                	sbb    $0x3,%al
    1694:	77 d0                	ja     1666 <balancer_ingress+0x1666>
    1696:	00 04 bd 1e 96 1f 03 	add    %al,0x31f961e(,%rdi,4)
    169d:	77 d0                	ja     166f <balancer_ingress+0x166f>
    169f:	00 04 f3             	add    %al,(%rbx,%rsi,8)
    16a2:	27                   	(bad)
    16a3:	d9 28                	fldcw  (%rax)
  if (!conn_rate_stats) {
    16a5:	03 77 d0             	add    -0x30(%rdi),%esi
    16a8:	00 04 d3             	add    %al,(%rbx,%rdx,8)
    16ab:	2a aa 2b 03 77 d0    	sub    -0x2f88fcd5(%rdx),%ch
    16b1:	00 04 aa             	add    %al,(%rdx,%rbp,4)
  *cur_time = bpf_ktime_get_ns();
    16b4:	2b b5 2b 01 55 04    	sub    0x455012b(%rbp),%esi
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    16ba:	b5 2b                	mov    $0x2b,%ch
    16bc:	82                   	(bad)
    16bd:	2c 03                	sub    $0x3,%al
    16bf:	77 d0                	ja     1691 <balancer_ingress+0x1691>
    16c1:	00 04 82             	add    %al,(%rdx,%rax,4)
    16c4:	2c 8d                	sub    $0x8d,%al
    conn_rate_stats->v1 = 1;
    16c6:	2c 01                	sub    $0x1,%al
    16c8:	55                   	push   %rbp
    16c9:	04 8d                	add    $0x8d,%al
    16cb:	2c a2                	sub    $0xa2,%al
    16cd:	31 03                	xor    %eax,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    16cf:	77 d0                	ja     16a1 <balancer_ingress+0x16a1>
    16d1:	00 04 b0             	add    %al,(%rax,%rsi,4)
    conn_rate_stats->v1 += 1;
    16d4:	32 ce                	xor    %dh,%cl
    16d6:	37                   	(bad)
    16d7:	03 77 d0             	add    -0x30(%rdi),%esi
    16da:	00 04 ef             	add    %al,(%rdi,%rbp,8)
    16dd:	37                   	(bad)
    16de:	c9                   	leave
    16df:	39 03                	cmp    %eax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    16e1:	77 d0                	ja     16b3 <balancer_ingress+0x16b3>
    16e3:	00 04 d6             	add    %al,(%rsi,%rdx,8)
    16e6:	39 eb                	cmp    %ebp,%ebx
    16e8:	39 03                	cmp    %eax,(%rbx)
    16ea:	77 d0                	ja     16bc <balancer_ingress+0x16bc>
    16ec:	00 04 eb             	add    %al,(%rbx,%rbp,8)
    16ef:	39 fd                	cmp    %edi,%ebp
    16f1:	39 01                	cmp    %eax,(%rcx)
    16f3:	55                   	push   %rbp
    16f4:	04 fd                	add    $0xfd,%al
    16f6:	39 bf 3b 03 77 d0    	cmp    %edi,-0x2f88fcc5(%rdi)
    16fc:	00 04 a0             	add    %al,(%rax,%riz,4)
    if (down_reals_map) {
    16ff:	3c f0                	cmp    $0xf0,%al
    1701:	3c 03                	cmp    $0x3,%al
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1703:	77 d0                	ja     16d5 <balancer_ingress+0x16d5>
    1705:	00 04 9d 3e 8a 3f 03 	add    %al,0x33f8a3e(,%rbx,4)
    170c:	77 d0                	ja     16de <balancer_ingress+0x16de>
    170e:	00 04 8a             	add    %al,(%rdx,%rcx,4)
      if (down_real) {
    1711:	3f                   	(bad)
    1712:	9c                   	pushf
    1713:	3f                   	(bad)
    1714:	01 55 04             	add    %edx,0x4(%rbp)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1717:	9c                   	pushf
    1718:	3f                   	(bad)
    1719:	b7 3f                	mov    $0x3f,%bh
    171b:	03 77 d0             	add    -0x30(%rdi),%esi
    171e:	00 00                	add    %al,(%rax)
    1720:	04 8a                	add    $0x8a,%al
    1722:	10 9b 10 02 30 9f    	adc    %bl,-0x60cffdf0(%rbx)
    1728:	04 9b                	add    $0x9b,%al
    172a:	10 a4 10 01 52 00 04 	adc    %ah,0x4005201(%rax,%rdx,1)
        if (stats_data) {
    1731:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    1732:	10 bc 10 01 52 00 04 	adc    %bh,0x4005201(%rax,%rdx,1)
          stats_data->v1 += 1;
    1739:	bc 10 c9 10 03       	mov    $0x310c910,%esp
    173e:	73 2a                	jae    176a <balancer_ingress+0x176a>
    1740:	9f                   	lahf
    if (!dst) {
    1741:	04 c9                	add    $0xc9,%al
    1743:	10 cb                	adc    %cl,%bl
    1745:	10 01                	adc    %al,(%rcx)
    1747:	50                   	push   %rax
    1748:	00 04 fb             	add    %al,(%rbx,%rdi,8)
    174b:	10 89 11 02 30 9f    	adc    %cl,-0x60cffdef(%rcx)
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1751:	04 89                	add    $0x89,%al
    1753:	11 92 11 01 50 00    	adc    %edx,0x500111(%rdx)
    1759:	04 c3                	add    $0xc3,%al
    175b:	11 d8                	adc    %ebx,%eax
    175d:	11 02                	adc    %eax,(%rdx)
    175f:	30 9f 04 d8 11 e1    	xor    %bl,-0x1eee27fc(%rdi)
    1765:	11 01                	adc    %eax,(%rcx)
    1767:	50                   	push   %rax
    1768:	00 04 cd 11 d8 11 01 	add    %al,0x111d811(,%rcx,8)
    176f:	55                   	push   %rbp
    1770:	00 04 d5 11 e1 11 04 	add    %al,0x411e111(,%rdx,8)
  if (!data_stats) {
    1777:	77 c0                	ja     1739 <balancer_ingress+0x1739>
    1779:	00 9f 00 04 d8 11    	add    %bl,0x11d80400(%rdi)
    177f:	eb 11                	jmp    1792 <balancer_ingress+0x1792>
    1781:	01 50 00             	add    %edx,0x0(%rax)
    1784:	04 e1                	add    $0xe1,%al
    1786:	11 f2                	adc    %esi,%edx
  data_stats->v1 += 1;
    1788:	11 02                	adc    %eax,(%rdx)
    178a:	30 9f 04 f2 11 fb    	xor    %bl,-0x4ee0dfc(%rdi)
  data_stats->v2 += pkt_bytes;
    1790:	11 01                	adc    %eax,(%rcx)
    1792:	50                   	push   %rax
    1793:	00 04 fb             	add    %al,(%rbx,%rdi,8)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1796:	11 89 12 01 50 00    	adc    %ecx,0x500112(%rcx)
    179c:	04 89                	add    $0x89,%al
    179e:	12 9a 12 02 30 9f    	adc    -0x60cffdee(%rdx),%bl
    17a4:	04 9a                	add    $0x9a,%al
    17a6:	12 a3 12 01 50 00    	adc    0x500112(%rbx),%ah
    17ac:	04 a3                	add    $0xa3,%al
    17ae:	12 c2                	adc    %dl,%al
    17b0:	12 01                	adc    (%rcx),%al
    17b2:	50                   	push   %rax
    17b3:	00 04 b5 12 c2 12 01 	add    %al,0x112c212(,%rsi,4)
    17ba:	52                   	push   %rdx
    17bb:	00 04 c2             	add    %al,(%rdx,%rax,8)
    17be:	12 81 13 03 73 2a    	adc    0x2a730313(%rcx),%al
  if (!data_stats) {
    17c4:	9f                   	lahf
    17c5:	00 04 b7             	add    %al,(%rdi,%rsi,4)
    17c8:	13 cc                	adc    %esp,%ecx
  data_stats->v1 += 1;
    17ca:	13 02                	adc    (%rdx),%eax
    17cc:	30 9f 04 cc 13 d5    	xor    %bl,-0x2aec33fc(%rdi)
  pckt.flow.port16[0] = original_sport;
    17d2:	13 01                	adc    (%rcx),%eax
    17d4:	50                   	push   %rax
    17d5:	00 04 c1             	add    %al,(%rcx,%rax,8)
  if (dst->flags & F_IPV6) {
    17d8:	13 cc                	adc    %esp,%ecx
    17da:	13 01                	adc    (%rcx),%eax
    17dc:	55                   	push   %rbp
    17dd:	00 04 c9             	add    %al,(%rcx,%rcx,8)
    17e0:	13 d5                	adc    %ebp,%edx
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    17e2:	13 04 77             	adc    (%rdi,%rsi,2),%eax
    17e5:	c0 00 9f             	rolb   $0x9f,(%rax)
    17e8:	00 04 cc             	add    %al,(%rsp,%rcx,8)
    17eb:	13 df                	adc    %edi,%ebx
    17ed:	13 01                	adc    (%rcx),%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    17ef:	50                   	push   %rax
    17f0:	00 04 d5 13 e6 13 02 	add    %al,0x213e613(,%rdx,8)
    17f7:	30 9f 04 e6 13 ef    	xor    %bl,-0x10ec19fc(%rdi)
    17fd:	13 01                	adc    (%rcx),%eax
    17ff:	50                   	push   %rax
    1800:	00 04 ef             	add    %al,(%rdi,%rbp,8)
  data = (void*)(long)xdp->data;
    1803:	13 f8                	adc    %eax,%edi
  data_end = (void*)(long)xdp->data_end;
    1805:	13 01                	adc    (%rcx),%eax
    1807:	50                   	push   %rax
    1808:	00 04 8b             	add    %al,(%rbx,%rcx,4)
  iph = data + sizeof(struct ethhdr);
    180b:	14 98                	adc    $0x98,%al
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    180d:	14 01                	adc    $0x1,%al
    180f:	50                   	push   %rax
    1810:	00 04 e3             	add    %al,(%rbx,%riz,8)
    1813:	14 fe                	adc    $0xfe,%al
    1815:	14 02                	adc    $0x2,%al
    1817:	30 9f 04 fe 14 87    	xor    %bl,-0x78eb01fc(%rdi)
    181d:	15 01 50 00 04       	adc    $0x4005001,%eax
    1822:	ed                   	in     (%dx),%eax
    1823:	14 87                	adc    $0x87,%al
    1825:	15 01 5e 00 04       	adc    $0x4005e01,%eax
    182a:	fe                   	(bad)
    182b:	14 87                	adc    $0x87,%al
    182d:	15 01 50 04 87       	adc    $0x87045001,%eax
    1832:	15 ad 16 01 51       	adc    $0x510116ad,%eax
    1837:	04 cc                	add    $0xcc,%al
    1839:	17                   	(bad)
    183a:	d6                   	(bad)
    183b:	17                   	(bad)
    183c:	01 50 04             	add    %edx,0x4(%rax)
    183f:	d6                   	(bad)
    1840:	17                   	(bad)
    1841:	e1 17                	loope  185a <balancer_ingress+0x185a>
    1843:	01 51 04             	add    %edx,0x4(%rcx)
  memcpy(new_eth->h_dest, cval->mac, 6);
    1846:	e1 17                	loope  185f <balancer_ingress+0x185f>
    1848:	82                   	(bad)
    1849:	18 01                	sbb    %al,(%rcx)
    184b:	50                   	push   %rax
    184c:	04 c5                	add    $0xc5,%al
    184e:	18 ec                	sbb    %ch,%ah
    1850:	18 01                	sbb    %al,(%rcx)
    1852:	51                   	push   %rcx
    1853:	04 ec                	add    $0xec,%al
    1855:	18 f5                	sbb    %dh,%ch
    1857:	18 02                	sbb    %al,(%rdx)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1859:	77 38                	ja     1893 <balancer_ingress+0x1893>
    185b:	04 f5                	add    $0xf5,%al
    185d:	18 e0                	sbb    %ah,%al
    185f:	19 01                	sbb    %eax,(%rcx)
    1861:	51                   	push   %rcx
    1862:	04 e0                	add    $0xe0,%al
    1864:	19 96 1a 02 77 38    	sbb    %edx,0x3877021a(%rsi)
  new_eth->h_proto = BE_ETH_P_IP;
    186a:	04 96                	add    $0x96,%al
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    186c:	1a cb                	sbb    %bl,%cl
    186e:	1a 01                	sbb    (%rcx),%al
    1870:	51                   	push   %rcx
    1871:	04 cb                	add    $0xcb,%al
  iph->ihl = 5;
    1873:	1a e2                	sbb    %dl,%ah
    1875:	1a 02                	sbb    (%rdx),%al
  iph->tos = tos;
    1877:	77 38                	ja     18b1 <balancer_ingress+0x18b1>
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1879:	04 e2                	add    $0xe2,%al
    187b:	1a ef                	sbb    %bh,%ch
    187d:	1a 01                	sbb    (%rcx),%al
    187f:	50                   	push   %rax
    1880:	04 ef                	add    $0xef,%al
    1882:	1a c0                	sbb    %al,%al
    1884:	1b 02                	sbb    (%rdx),%eax
    1886:	77 38                	ja     18c0 <balancer_ingress+0x18c0>
  iph->id = 0;
    1888:	04 c0                	add    $0xc0,%al
    188a:	1b d4                	sbb    %esp,%edx
    188c:	1b 01                	sbb    (%rcx),%eax
  iph->daddr = daddr;
    188e:	50                   	push   %rax
    188f:	04 d4                	add    $0xd4,%al
  iph->saddr = saddr;
    1891:	1b 93 1c 02 77 38    	sbb    0x3877021c(%rbx),%edx
  iph->ttl = DEFAULT_TTL;
    1897:	04 ef                	add    $0xef,%al
    1899:	1c e6                	sbb    $0xe6,%al
    189b:	1d 02 77 38 04       	sbb    $0x4387702,%eax
    18a0:	e6 1d                	out    %al,$0x1d
    18a2:	bd 1e 01 51 04       	mov    $0x451011e,%ebp
    18a7:	96                   	xchg   %eax,%esi
    18a8:	1f                   	(bad)
    18a9:	ec                   	in     (%dx),%al
    18aa:	23 02                	and    (%rdx),%eax
    18ac:	77 38                	ja     18e6 <balancer_ingress+0x18e6>
    18ae:	04 ec                	add    $0xec,%al
    18b0:	23 fc                	and    %esp,%edi
    18b2:	23 01                	and    (%rcx),%eax
    18b4:	52                   	push   %rdx
    18b5:	04 fc                	add    $0xfc,%al
    18b7:	23 80 25 02 77 38    	and    0x38770225(%rax),%eax
    18bd:	04 80                	add    $0x80,%al
    18bf:	25 85 25 01 51       	and    $0x51012585,%eax
    18c4:	04 85                	add    $0x85,%al
    18c6:	25 99 26 02 77       	and    $0x77022699,%eax
    18cb:	38 04 99             	cmp    %al,(%rcx,%rbx,4)
    18ce:	26 9b                	es fwait
    18d0:	26 01 52 04          	es add %edx,0x4(%rdx)
    18d4:	9b                   	fwait
    18d5:	26 f3 27             	es repz (bad)
    18d8:	02 77 38             	add    0x38(%rdi),%dh
    18db:	04 e3                	add    $0xe3,%al
    18dd:	28 a1 2a 02 77 38    	sub    %ah,0x3877022a(%rcx)
    18e3:	04 a1                	add    $0xa1,%al
    18e5:	2a c0                	sub    %al,%al
    18e7:	2a 01                	sub    (%rcx),%al
    18e9:	51                   	push   %rcx
    18ea:	04 bf                	add    $0xbf,%al
    18ec:	3b 99 3c 02 77 38    	cmp    0x3877023c(%rcx),%ebx
    18f2:	04 83                	add    $0x83,%al
    18f4:	3d 93 3e 02 77       	cmp    $0x77023e93,%eax
    18f9:	38 04 b7             	cmp    %al,(%rdi,%rsi,4)
    18fc:	3f                   	(bad)
    18fd:	9a                   	(bad)
    18fe:	41 02 77 38          	add    0x38(%r15),%sil
    1902:	00 04 99             	add    %al,(%rcx,%rbx,4)
    1905:	15 ad 16 04 10       	adc    $0x100416ad,%eax
    190a:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    190e:	c5 18 93             	(bad)
    1911:	1c 04                	sbb    $0x4,%al
    1913:	10 80 04 9f 04 ef    	adc    %al,-0x10fb60fc(%rax)
    1919:	1c bd                	sbb    $0xbd,%al
    191b:	1e                   	(bad)
    191c:	04 10                	add    $0x10,%al
    191e:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1922:	96                   	xchg   %eax,%esi
    1923:	1f                   	(bad)
    1924:	f3 27                	repz (bad)
    1926:	04 10                	add    $0x10,%al
    1928:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    192c:	e3 28                	jrcxz  1956 <balancer_ingress+0x1956>
    192e:	c0 2a 04             	shrb   $0x4,(%rdx)
      if (pckt.flow.proto == IPPROTO_TCP) {
    1931:	10 80 04 9f 04 bf    	adc    %al,-0x40fb60fc(%rax)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1937:	3b 99 3c 04 10 80    	cmp    -0x7feffbc4(%rcx),%ebx
    193d:	04 9f                	add    $0x9f,%al
    193f:	04 83                	add    $0x83,%al
    1941:	3d 93 3e 04 10       	cmp    $0x10043e93,%eax
    1946:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    194a:	b7 3f                	mov    $0x3f,%bh
    194c:	9a                   	(bad)
    194d:	41 04 10             	rex.B add $0x10,%al
    1950:	80 04 9f 00          	addb   $0x0,(%rdi,%rbx,4)
        if (!lru_stats) {
    1954:	04 99                	add    $0x99,%al
    1956:	15 aa 15 02 30       	adc    $0x300215aa,%eax
        if (pckt.flags & F_SYN_SET) {
    195b:	9f                   	lahf
    195c:	04 aa                	add    $0xaa,%al
    195e:	15 b3 15 01 5e       	adc    $0x5e0115b3,%eax
    1963:	00 04 b3             	add    %al,(%rbx,%rsi,4)
    1966:	15 ad 16 01 5e       	adc    $0x5e0116ad,%eax
  struct real_pos_lru new_dst_lru = {};
    196b:	04 c5                	add    $0xc5,%al
    196d:	18 93 1c 01 5e 04    	sbb    %dl,0x45e011c(%rbx)
    1973:	ef                   	out    %eax,(%dx)
    1974:	1c bd                	sbb    $0xbd,%al
    1976:	1e                   	(bad)
    1977:	01 5e 04             	add    %ebx,0x4(%rsi)
    197a:	96                   	xchg   %eax,%esi
    197b:	1f                   	(bad)
    197c:	86 20                	xchg   %ah,(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    197e:	01 5e 04             	add    %ebx,0x4(%rsi)
    1981:	86 20                	xchg   %ah,(%rax)
    1983:	a9 20 01 52 04       	test   $0x4520120,%eax
    1988:	d1 20                	shll   (%rax)
    198a:	8b 21                	mov    (%rcx),%esp
    198c:	01 52 04             	add    %edx,0x4(%rdx)
    198f:	b7 22                	mov    $0x22,%bh
    1991:	af                   	scas   %es:(%rdi),%eax
    1992:	26 01 5e 04          	es add %ebx,0x4(%rsi)
    1996:	af                   	scas   %es:(%rdi),%eax
    1997:	26 c0 26 01          	es shlb $0x1,(%rsi)
  if (!conn_rate_stats) {
    199b:	52                   	push   %rdx
    199c:	04 e3                	add    $0xe3,%al
    199e:	28 c0                	sub    %al,%al
    19a0:	2a 01                	sub    (%rcx),%al
    19a2:	5e                   	pop    %rsi
    19a3:	04 bf                	add    $0xbf,%al
    19a5:	3b 99 3c 01 5e 04    	cmp    0x45e013c(%rcx),%ebx
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    19ab:	83 3d 93 3e 01 5e 04 	cmpl   $0x4,0x5e013e93(%rip)        # 5e015845 <_license+0x5e0137ab>
    19b2:	b7 3f                	mov    $0x3f,%bh
    19b4:	9a                   	(bad)
    19b5:	41 01 5e 00          	add    %ebx,0x0(%r14)
    conn_rate_stats->v1 = 1;
    19b9:	04 db                	add    $0xdb,%al
    19bb:	15 e4 15 0c 10       	adc    $0x100c15e4,%eax
    conn_rate_stats->v2 = *cur_time;
    19c0:	b4 a0                	mov    $0xa0,%ah
    19c2:	e4 a1                	in     $0xa1,%al
    19c4:	fa                   	cli
    19c5:	ff                   	(bad)
    19c6:	ff                   	(bad)
    19c7:	ff                   	(bad)
    19c8:	ff 01                	incl   (%rcx)
    conn_rate_stats->v1 += 1;
    19ca:	9f                   	lahf
    19cb:	04 e4                	add    $0xe4,%al
    19cd:	15 e7 15 01 50       	adc    $0x500115e7,%eax
    19d2:	00 04 e7             	add    %al,(%rdi,%riz,8)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    19d5:	15 f2 15 0d 70       	adc    $0x700d15f2,%eax
    19da:	00 a8 b5 80 80 00    	add    %ch,0x8080b5(%rax)
    19e0:	a8 b0                	test   $0xb0,%al
    19e2:	80 80 00 9f 04 c5 18 	addb   $0x18,-0x3afb6100(%rax)
    19e9:	c7                   	(bad)
    19ea:	18 0d 70 00 a8 b5    	sbb    %cl,-0x4a57ff90(%rip)        # ffffffffb5a81a60 <server_id_map+0x5ffffe3c856a60>
    b += *(u32*)(k + 4);
    19f0:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
      a += (u32)k[3] << 24;
    19f7:	00 9f 00 04 e7 15    	add    %bl,0x15e70400(%rdi)
      a += (u32)k[2] << 16;
    19fd:	f2 15 0d 70 00 a8    	repnz adc $0xa800700d,%eax
      a += (u32)k[1] << 8;
    1a03:	b5 80                	mov    $0x80,%ch
      a += k[0];
    1a05:	80 00 a8             	addb   $0xa8,(%rax)
    1a08:	b0 80                	mov    $0x80,%al
    1a0a:	80 00 9f             	addb   $0x9f,(%rax)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1a0d:	04 c5                	add    $0xc5,%al
    1a0f:	18 c7                	sbb    %al,%bh
    1a11:	18 0d 70 00 a8 b5    	sbb    %cl,-0x4a57ff90(%rip)        # ffffffffb5a81a87 <server_id_map+0x5ffffe3c856a87>
      memset(pckt->flow.srcv6, 0, 16);
    1a17:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
    1a1e:	00 9f 00 04 e7 15    	add    %bl,0x15e70400(%rdi)
    1a24:	f2 15 02 30 9f 04    	repnz adc $0x49f3002,%eax
    1a2a:	c5 18 d9             	(bad)
    1a2d:	18 02                	sbb    %al,(%rdx)
    1a2f:	30 9f 04 d9 18 de    	xor    %bl,-0x21e726fc(%rdi)
    1a35:	18 01                	sbb    %al,(%rcx)
    1a37:	50                   	push   %rax
    c += *(u32*)(k + 8);
    1a38:	04 de                	add    $0xde,%al
    1a3a:	18 e7                	sbb    %ah,%bh
    1a3c:	18 03                	sbb    %al,(%rbx)
    __jhash_mix(a, b, c);
    1a3e:	77 d0                	ja     1a10 <balancer_ingress+0x1a10>
  return (word << shift) | (word >> ((-shift) & 31));
    1a40:	00 00                	add    %al,(%rax)
    1a42:	04 e7                	add    $0xe7,%al
    __jhash_mix(a, b, c);
    1a44:	15 f2 15 02 3c       	adc    $0x3c0215f2,%eax
    b += *(u32*)(k + 4);
    1a49:	9f                   	lahf
    1a4a:	04 c5                	add    $0xc5,%al
    1a4c:	18 e7                	sbb    %ah,%bh
    __jhash_mix(a, b, c);
    1a4e:	18 02                	sbb    %al,(%rdx)
    1a50:	3c 9f                	cmp    $0x9f,%al
    1a52:	00 04 e7             	add    %al,(%rdi,%riz,8)
    1a55:	15 f2 15 04 10       	adc    $0x100415f2,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1a5a:	80 01 9f             	addb   $0x9f,(%rcx)
    __jhash_mix(a, b, c);
    1a5d:	04 c5                	add    $0xc5,%al
    1a5f:	18 e7                	sbb    %ah,%bh
  return (word << shift) | (word >> ((-shift) & 31));
    1a61:	18 04 10             	sbb    %al,(%rax,%rdx,1)
    1a64:	80 01 9f             	addb   $0x9f,(%rcx)
    __jhash_mix(a, b, c);
    1a67:	00 04 e7             	add    %al,(%rdi,%riz,8)
    1a6a:	15 f2 15 02 38       	adc    $0x380215f2,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1a6f:	9f                   	lahf
    1a70:	04 c5                	add    $0xc5,%al
    __jhash_mix(a, b, c);
    1a72:	18 e7                	sbb    %ah,%bh
    1a74:	18 02                	sbb    %al,(%rdx)
    1a76:	38 9f 00 04 f2 15    	cmp    %bl,0x15f20400(%rdi)
  return (word << shift) | (word >> ((-shift) & 31));
    1a7c:	83 16 02             	adcl   $0x2,(%rsi)
    __jhash_mix(a, b, c);
    1a7f:	30 9f 04 83 16 8c    	xor    %bl,-0x73e97cfc(%rdi)
  return (word << shift) | (word >> ((-shift) & 31));
    1a85:	16                   	(bad)
    1a86:	01 50 00             	add    %edx,0x0(%rax)
    1a89:	04 8c                	add    $0x8c,%al
    __jhash_mix(a, b, c);
    1a8b:	16                   	(bad)
      a += (u32)k[3] << 24;
    1a8c:	a3 16 01 50 00 04 d9 	movabs %eax,0xde18d90400500116
    1a93:	18 de 
      a += (u32)k[2] << 16;
    1a95:	18 01                	sbb    %al,(%rcx)
    1a97:	50                   	push   %rax
    1a98:	04 de                	add    $0xde,%al
      a += (u32)k[3] << 24;
    1a9a:	18 ec                	sbb    %ch,%ah
      a += (u32)k[1] << 8;
    1a9c:	1a 03                	sbb    (%rbx),%al
    1a9e:	77 d0                	ja     1a70 <balancer_ingress+0x1a70>
    1aa0:	00 04 ec             	add    %al,(%rsp,%rbp,8)
      a += (u32)k[2] << 16;
    1aa3:	1a f7                	sbb    %bh,%dh
      a += k[0];
    1aa5:	1a 01                	sbb    (%rcx),%al
    1aa7:	55                   	push   %rbp
    1aa8:	04 f7                	add    $0xf7,%al
      a += (u32)k[1] << 8;
    1aaa:	1a 93 1c 03 77 d0    	sbb    -0x2f88fce4(%rbx),%dl
      __jhash_final(a, b, c);
    1ab0:	00 04 ef             	add    %al,(%rdi,%rbp,8)
  return (word << shift) | (word >> ((-shift) & 31));
    1ab3:	1c bd                	sbb    $0xbd,%al
    1ab5:	1e                   	(bad)
    1ab6:	03 77 d0             	add    -0x30(%rdi),%esi
      __jhash_final(a, b, c);
    1ab9:	00 04 96             	add    %al,(%rsi,%rdx,4)
  return (word << shift) | (word >> ((-shift) & 31));
    1abc:	1f                   	(bad)
    1abd:	f3 27                	repz (bad)
    1abf:	03 77 d0             	add    -0x30(%rdi),%esi
      __jhash_final(a, b, c);
    1ac2:	00 04 e3             	add    %al,(%rbx,%riz,8)
  return (word << shift) | (word >> ((-shift) & 31));
    1ac5:	28 f8                	sub    %bh,%al
    1ac7:	28 03                	sub    %al,(%rbx)
      __jhash_final(a, b, c);
    1ac9:	77 d0                	ja     1a9b <balancer_ingress+0x1a9b>
    1acb:	00 04 f8             	add    %al,(%rax,%rdi,8)
  return (word << shift) | (word >> ((-shift) & 31));
    1ace:	28 8a 29 01 55 04    	sub    %cl,0x4550129(%rdx)
      __jhash_final(a, b, c);
    1ad4:	8a 29                	mov    (%rcx),%ch
  return (word << shift) | (word >> ((-shift) & 31));
    1ad6:	c0 2a 03             	shrb   $0x3,(%rdx)
    1ad9:	77 d0                	ja     1aab <balancer_ingress+0x1aab>
      __jhash_final(a, b, c);
    1adb:	00 04 bf             	add    %al,(%rdi,%rdi,4)
    1ade:	3b 99 3c 03 77 d0    	cmp    -0x2f88fcc4(%rcx),%ebx
    1ae4:	00 04 83             	add    %al,(%rbx,%rax,4)
  return (word << shift) | (word >> ((-shift) & 31));
    1ae7:	3d d7 3d 03 77       	cmp    $0x77033dd7,%eax
  a += initval;
    1aec:	d0 00                	rolb   (%rax)
    1aee:	04 d7                	add    $0xd7,%al
  b += initval;
    1af0:	3d e2 3d 01 55       	cmp    $0x55013de2,%eax
  a += initval;
    1af5:	04 e2                	add    $0xe2,%al
    1af7:	3d 93 3e 03 77       	cmp    $0x77033e93,%eax
  __jhash_final(a, b, c);
    1afc:	d0 00                	rolb   (%rax)
    1afe:	04 b7                	add    $0xb7,%al
    1b00:	3f                   	(bad)
    1b01:	ed                   	in     (%dx),%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1b02:	40 03 77 d0          	rex add -0x30(%rdi),%esi
    1b06:	00 04 ed 40 ff 40 01 	add    %al,0x140ff40(,%rbp,8)
    1b0d:	55                   	push   %rbp
    1b0e:	04 ff                	add    $0xff,%al
  __jhash_final(a, b, c);
    1b10:	40 9a                	rex (bad)
    1b12:	41 03 77 d0          	add    -0x30(%r15),%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1b16:	00 00                	add    %al,(%rax)
    1b18:	04 ed                	add    $0xed,%al
  __jhash_final(a, b, c);
    1b1a:	16                   	(bad)
    1b1b:	cc                   	int3
    1b1c:	17                   	(bad)
  return (word << shift) | (word >> ((-shift) & 31));
    1b1d:	02 30                	add    (%rax),%dh
    1b1f:	9f                   	lahf
    1b20:	04 93                	add    $0x93,%al
  __jhash_final(a, b, c);
    1b22:	1c ef                	sbb    $0xef,%al
    1b24:	1c 02                	sbb    $0x2,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1b26:	30 9f 04 bd 1e 96    	xor    %bl,-0x69e142fc(%rdi)
  __jhash_final(a, b, c);
    1b2c:	1f                   	(bad)
    1b2d:	02 30                	add    (%rax),%dh
  return (word << shift) | (word >> ((-shift) & 31));
    1b2f:	9f                   	lahf
    1b30:	04 f3                	add    $0xf3,%al
  __jhash_final(a, b, c);
    1b32:	27                   	(bad)
    1b33:	d9 28                	fldcw  (%rax)
    1b35:	02 30                	add    (%rax),%dh
  return (word << shift) | (word >> ((-shift) & 31));
    1b37:	9f                   	lahf
    1b38:	04 d3                	add    $0xd3,%al
  __jhash_final(a, b, c);
    1b3a:	2a e1                	sub    %cl,%ah
    1b3c:	2b 02                	sub    (%rdx),%eax
    1b3e:	30 9f 04 a0 3c f0    	xor    %bl,-0xfc35ffc(%rdi)
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1b44:	3c 02                	cmp    $0x2,%al
    1b46:	30 9f 04 9d 3e b7    	xor    %bl,-0x48c162fc(%rdi)
    1b4c:	3f                   	(bad)
    1b4d:	02 30                	add    (%rax),%dh
    1b4f:	9f                   	lahf
    1b50:	00 04 ed 16 fe 16 02 	add    %al,0x216fe16(,%rbp,8)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1b57:	30 9f 04 fe 16 87    	xor    %bl,-0x78e901fc(%rdi)
    1b5d:	17                   	(bad)
    1b5e:	01 56 00             	add    %edx,0x0(%rsi)
    1b61:	04 87                	add    $0x87,%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1b63:	17                   	(bad)
    1b64:	cc                   	int3
    1b65:	17                   	(bad)
    1b66:	01 56 04             	add    %edx,0x4(%rsi)
    if (!real_pos) {
    1b69:	93                   	xchg   %eax,%ebx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1b6a:	1c d8                	sbb    $0xd8,%al
    1b6c:	1c 01                	sbb    $0x1,%al
    1b6e:	56                   	push   %rsi
    1b6f:	04 bd                	add    $0xbd,%al
    1b71:	1e                   	(bad)
    1b72:	96                   	xchg   %eax,%esi
    1b73:	1f                   	(bad)
    1b74:	01 56 04             	add    %edx,0x4(%rsi)
    key = *real_pos;
    1b77:	f3 27                	repz (bad)
    1b79:	d9 28                	fldcw  (%rax)
    1b7b:	01 56 04             	add    %edx,0x4(%rsi)
    1b7e:	d3 2a                	shrl   %cl,(%rdx)
    if (key == 0) {
    1b80:	e1 2b                	loope  1bad <balancer_ingress+0x1bad>
  pckt->real_index = key;
    1b82:	01 56 04             	add    %edx,0x4(%rsi)
    1b85:	a0 3c f0 3c 01 56 04 	movabs 0x3e9d0456013cf03c,%al
    1b8c:	9d 3e 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1b8e:	b7 3f                	mov    $0x3f,%bh
    1b90:	01 56 00             	add    %edx,0x0(%rsi)
    1b93:	04 90                	add    $0x90,%al
    1b95:	17                   	(bad)
    1b96:	94                   	xchg   %eax,%esp
    1b97:	17                   	(bad)
    1b98:	01 53 00             	add    %edx,0x0(%rbx)
    1b9b:	04 90                	add    $0x90,%al
    1b9d:	17                   	(bad)
    1b9e:	cc                   	int3
    1b9f:	17                   	(bad)
    1ba0:	01 5f 04             	add    %ebx,0x4(%rdi)
    1ba3:	93                   	xchg   %eax,%ebx
    1ba4:	1c a9                	sbb    $0xa9,%al
    1ba6:	1c 01                	sbb    $0x1,%al
  if (!ch_drop_stats) {
    1ba8:	5f                   	pop    %rdi
    1ba9:	04 bd                	add    $0xbd,%al
    1bab:	1e                   	(bad)
    1bac:	96                   	xchg   %eax,%esi
    1bad:	1f                   	(bad)
    1bae:	01 5f 04             	add    %ebx,0x4(%rdi)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1bb1:	f3 27                	repz (bad)
    1bb3:	be 28 01 5f 00       	mov    $0x5f0128,%esi
    1bb8:	04 90                	add    $0x90,%al
    1bba:	17                   	(bad)
    1bbb:	cc                   	int3
    1bbc:	17                   	(bad)
    1bbd:	02 31                	add    (%rcx),%dh
    1bbf:	9f                   	lahf
    1bc0:	04 93                	add    $0x93,%al
    1bc2:	1c a9                	sbb    $0xa9,%al
    1bc4:	1c 02                	sbb    $0x2,%al
    1bc6:	31 9f 04 bd 1e 96    	xor    %ebx,-0x69e142fc(%rdi)
  if (!ch_drop_stats) {
    1bcc:	1f                   	(bad)
    1bcd:	02 31                	add    (%rcx),%dh
    1bcf:	9f                   	lahf
    1bd0:	04 f3                	add    $0xf3,%al
    1bd2:	27                   	(bad)
    1bd3:	be 28 02 31 9f       	mov    $0x9f310228,%esi
    1bd8:	00 04 90             	add    %al,(%rax,%rdx,4)
}
    1bdb:	17                   	(bad)
    1bdc:	cc                   	int3
    1bdd:	17                   	(bad)
    1bde:	12 30                	adc    (%rax),%dh
    1be0:	20 9f 93 04 30 20    	and    %bl,0x20300493(%rdi)
    1be6:	9f                   	lahf
    1be7:	93                   	xchg   %eax,%ebx
    1be8:	01 30                	add    %esi,(%rax)
    1bea:	9f                   	lahf
    1beb:	93                   	xchg   %eax,%ebx
    1bec:	01 30                	add    %esi,(%rax)
    1bee:	9f                   	lahf
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1bef:	93                   	xchg   %eax,%ebx
    1bf0:	02 04 93             	add    (%rbx,%rdx,4),%al
    1bf3:	1c a9                	sbb    $0xa9,%al
    1bf5:	1c 12                	sbb    $0x12,%al
    1bf7:	30 20                	xor    %ah,(%rax)
    1bf9:	9f                   	lahf
    1bfa:	93                   	xchg   %eax,%ebx
    1bfb:	04 30                	add    $0x30,%al
    1bfd:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    1c03:	93                   	xchg   %eax,%ebx
    1c04:	01 30                	add    %esi,(%rax)
    1c06:	9f                   	lahf
    1c07:	93                   	xchg   %eax,%ebx
    1c08:	02 04 bd 1e df 1e 12 	add    0x121edf1e(,%rdi,4),%al
    1c0f:	30 20                	xor    %ah,(%rax)
    1c11:	9f                   	lahf
    1c12:	93                   	xchg   %eax,%ebx
    1c13:	04 30                	add    $0x30,%al
    1c15:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1c1b:	93                   	xchg   %eax,%ebx
    1c1c:	01 30                	add    %esi,(%rax)
    1c1e:	9f                   	lahf
    1c1f:	93                   	xchg   %eax,%ebx
    1c20:	02 04 df             	add    (%rdi,%rbx,8),%al
    1c23:	1e                   	(bad)
    1c24:	fd                   	std
    1c25:	1e                   	(bad)
    1c26:	10 30                	adc    %dh,(%rax)
  data = (void*)(long)xdp->data;
    1c28:	20 9f 93 04 51 93    	and    %bl,-0x6caefb6d(%rdi)
  data_end = (void*)(long)xdp->data_end;
    1c2e:	01 30                	add    %esi,(%rax)
  ip6h = data + sizeof(struct ethhdr);
    1c30:	9f                   	lahf
    1c31:	93                   	xchg   %eax,%ebx
    1c32:	01 30                	add    %esi,(%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1c34:	9f                   	lahf
    1c35:	93                   	xchg   %eax,%ebx
    1c36:	02 04 fd 1e 85 1f 0d 	add    0xd1f851e(,%rdi,8),%al
    1c3d:	93                   	xchg   %eax,%ebx
    1c3e:	04 51                	add    $0x51,%al
    1c40:	93                   	xchg   %eax,%ebx
    1c41:	01 30                	add    %esi,(%rax)
    1c43:	9f                   	lahf
    1c44:	93                   	xchg   %eax,%ebx
    1c45:	01 30                	add    %esi,(%rax)
    1c47:	9f                   	lahf
    1c48:	93                   	xchg   %eax,%ebx
    1c49:	02 04 85 1f 96 1f 0a 	add    0xa1f961f(,%rax,4),%al
    1c50:	93                   	xchg   %eax,%ebx
  memcpy(new_eth->h_dest, cval->mac, 6);
    1c51:	05 30 9f 93 01       	add    $0x1939f30,%eax
    1c56:	30 9f 93 02 04 f3    	xor    %bl,-0xcfbfd6d(%rdi)
    1c5c:	27                   	(bad)
    1c5d:	ff 27                	jmp    *(%rdi)
    1c5f:	10 30                	adc    %dh,(%rax)
    1c61:	20 9f 93 04 51 93    	and    %bl,-0x6caefb6d(%rdi)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1c67:	01 30                	add    %esi,(%rax)
    1c69:	9f                   	lahf
    1c6a:	93                   	xchg   %eax,%ebx
    1c6b:	01 30                	add    %esi,(%rax)
    1c6d:	9f                   	lahf
    1c6e:	93                   	xchg   %eax,%ebx
    1c6f:	02 04 ff             	add    (%rdi,%rdi,8),%al
  new_eth->h_proto = BE_ETH_P_IPV6;
    1c72:	27                   	(bad)
    1c73:	94                   	xchg   %eax,%esp
    1c74:	28 0f                	sub    %cl,(%rdi)
    1c76:	30 20                	xor    %ah,(%rax)
    1c78:	9f                   	lahf
    1c79:	93                   	xchg   %eax,%ebx
    1c7a:	04 93                	add    $0x93,%al
    1c7c:	01 30                	add    %esi,(%rax)
  saddr[3] = src ^ port;
    1c7e:	9f                   	lahf
    1c7f:	93                   	xchg   %eax,%ebx
    1c80:	01 30                	add    %esi,(%rax)
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    1c82:	9f                   	lahf
    1c83:	93                   	xchg   %eax,%ebx
    1c84:	02 04 94             	add    (%rsp,%rdx,4),%al
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1c87:	28 98 28 0a 93 05    	sub    %bl,0x5930a28(%rax)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1c8d:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
  ip6h->priority = (tc & 0xF0) >> 4;
    1c93:	93                   	xchg   %eax,%ebx
    1c94:	02 04 98             	add    (%rax,%rbx,4),%al
    1c97:	28 9c 28 10 30 20 9f 	sub    %bl,-0x60dfcff0(%rax,%rbp,1)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1c9e:	93                   	xchg   %eax,%ebx
    1c9f:	04 51                	add    $0x51,%al
  ip6h->nexthdr = proto;
    1ca1:	93                   	xchg   %eax,%ebx
    1ca2:	01 30                	add    %esi,(%rax)
    1ca4:	9f                   	lahf
    1ca5:	93                   	xchg   %eax,%ebx
  ip6h->payload_len = bpf_htons(payload_len);
    1ca6:	01 30                	add    %esi,(%rax)
    1ca8:	9f                   	lahf
    1ca9:	93                   	xchg   %eax,%ebx
    1caa:	02 04 9c             	add    (%rsp,%rbx,4),%al
    1cad:	28 ae 28 0f 30 20    	sub    %ch,0x20300f28(%rsi)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    1cb3:	9f                   	lahf
    1cb4:	93                   	xchg   %eax,%ebx
    1cb5:	04 93                	add    $0x93,%al
    1cb7:	01 30                	add    %esi,(%rax)
    1cb9:	9f                   	lahf
    1cba:	93                   	xchg   %eax,%ebx
    1cbb:	01 30                	add    %esi,(%rax)
    1cbd:	9f                   	lahf
    1cbe:	93                   	xchg   %eax,%ebx
    1cbf:	02 04 ae             	add    (%rsi,%rbp,4),%al
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    1cc2:	28 b6 28 0a 93 05    	sub    %dh,0x5930a28(%rsi)
    1cc8:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    1cce:	93                   	xchg   %eax,%ebx
    1ccf:	02 04 b6             	add    (%rsi,%rsi,4),%al
    1cd2:	28 be 28 06 93 06    	sub    %bh,0x6930628(%rsi)
    if (pckt->flow.proto == IPPROTO_UDP) {
    1cd8:	30 9f 93 02 00 04    	xor    %bl,0x4000293(%rdi)
      new_dst_lru.atime = cur_time;
    1cde:	ae                   	scas   %es:(%rdi),%al
    1cdf:	17                   	(bad)
    1ce0:	be 17 01 53 04       	mov    $0x4530117,%esi
    new_dst_lru.pos = key;
    1ce5:	93                   	xchg   %eax,%ebx
    1ce6:	1c a9                	sbb    $0xa9,%al
    1ce8:	1c 01                	sbb    $0x1,%al
    1cea:	53                   	push   %rbx
BPF_MAP_OPS_INLINE(map_update_elem,,
    1ceb:	04 bd                	add    $0xbd,%al
    1ced:	1e                   	(bad)
    1cee:	cb                   	lret
    1cef:	1e                   	(bad)
    1cf0:	01 53 00             	add    %edx,0x0(%rbx)
    1cf3:	04 ae                	add    $0xae,%al
    1cf5:	17                   	(bad)
    1cf6:	be 17 01 53 04       	mov    $0x4530117,%esi
    1cfb:	93                   	xchg   %eax,%ebx
    1cfc:	1c a9                	sbb    $0xa9,%al
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    1cfe:	1c 01                	sbb    $0x1,%al
    1d00:	53                   	push   %rbx
    1d01:	04 bd                	add    $0xbd,%al
    1d03:	1e                   	(bad)
    1d04:	cb                   	lret
    1d05:	1e                   	(bad)
    1d06:	01 53 00             	add    %edx,0x0(%rbx)
    1d09:	04 ae                	add    $0xae,%al
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    1d0b:	17                   	(bad)
    1d0c:	cc                   	int3
    1d0d:	17                   	(bad)
    1d0e:	02 30                	add    (%rax),%dh
    1d10:	9f                   	lahf
    1d11:	04 93                	add    $0x93,%al
    1d13:	1c a9                	sbb    $0xa9,%al
    1d15:	1c 02                	sbb    $0x2,%al
    1d17:	30 9f 04 bd 1e c1    	xor    %bl,-0x3ee142fc(%rdi)
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    1d1d:	1e                   	(bad)
    1d1e:	02 30                	add    (%rax),%dh
    1d20:	9f                   	lahf
    1d21:	04 ce                	add    $0xce,%al
    1d23:	1e                   	(bad)
    1d24:	8c 1f                	mov    %ds,(%rdi)
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    1d26:	01 50 04             	add    %edx,0x4(%rax)
    1d29:	f3 27                	repz (bad)
    1d2b:	94                   	xchg   %eax,%esp
    1d2c:	28 01                	sub    %al,(%rcx)
    1d2e:	50                   	push   %rax
    1d2f:	04 98                	add    $0x98,%al
    1d31:	28 ae 28 01 50 00    	sub    %ch,0x500128(%rsi)
    1d37:	04 d3                	add    $0xd3,%al
    1d39:	17                   	(bad)
    1d3a:	e1 17                	loope  1d53 <balancer_ingress+0x1d53>
    1d3c:	02 30                	add    (%rax),%dh
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1d3e:	9f                   	lahf
    1d3f:	04 e1                	add    $0xe1,%al
    1d41:	17                   	(bad)
    1d42:	ea                   	(bad)
    1d43:	17                   	(bad)
    1d44:	01 50 00             	add    %edx,0x0(%rax)
    1d47:	04 82                	add    $0x82,%al
    1d49:	18 93 18 02 30 9f    	sbb    %dl,-0x60cffde8(%rbx)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1d4f:	04 93                	add    $0x93,%al
    1d51:	18 9c 18 01 56 00 04 	sbb    %bl,0x4005601(%rax,%rbx,1)
  bool vip_match = address_match && port_match && proto_match;
    1d58:	9c                   	pushf
    1d59:	18 c0                	sbb    %al,%al
    1d5b:	18 01                	sbb    %al,(%rcx)
    1d5d:	56                   	push   %rsi
    1d5e:	00 04 80             	add    %al,(%rax,%rax,4)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1d61:	19 96 1a 02 30 9f    	sbb    %edx,-0x60cffde6(%rsi)
    1d67:	04 e6                	add    $0xe6,%al
    1d69:	1d bd 1e 02 30       	sbb    $0x30021ebd,%eax
    1d6e:	9f                   	lahf
    1d6f:	04 a1                	add    $0xa1,%al
    1d71:	2a c0                	sub    %al,%al
    1d73:	2a 02                	sub    (%rdx),%al
    1d75:	30 9f 04 bf 3b 99    	xor    %bl,-0x66c440fc(%rdi)
    1d7b:	3c 02                	cmp    $0x2,%al
    1d7d:	30 9f 04 83 3d 93    	xor    %bl,-0x6cc27cfc(%rdi)
    1d83:	3e 02 30             	ds add (%rax),%dh
    1d86:	9f                   	lahf
    1d87:	04 b7                	add    $0xb7,%al
    if (!lru_miss_stat) {
    1d89:	3f                   	(bad)
    1d8a:	9a                   	(bad)
    1d8b:	41 02 30             	add    (%r8),%sil
    1d8e:	9f                   	lahf
    1d8f:	00 04 80             	add    %al,(%rax,%rax,4)
    *lru_miss_stat += 1;
    1d92:	19 91 19 02 30 9f    	sbb    %edx,-0x60cffde7(%rcx)
    1d98:	04 91                	add    $0x91,%al
    1d9a:	19 9a 19 01 56 00    	sbb    %ebx,0x560119(%rdx)
    1da0:	04 9a                	add    $0x9a,%al
    1da2:	19 96 1a 01 56 04    	sbb    %edx,0x456011a(%rsi)
    1da8:	e6 1d                	out    %al,$0x1d
    1daa:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1dab:	1e                   	(bad)
    1dac:	01 56 04             	add    %edx,0x4(%rsi)
    1daf:	a1 2a c0 2a 01 56 04 	movabs 0x3bbf0456012ac02a,%eax
    1db6:	bf 3b 
      data_stats->v2 += 1;
    1db8:	99                   	cltd
    1db9:	3c 01                	cmp    $0x1,%al
    1dbb:	56                   	push   %rsi
    1dbc:	04 83                	add    $0x83,%al
    1dbe:	3d 93 3e 01 56       	cmp    $0x56013e93,%eax
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1dc3:	04 b7                	add    $0xb7,%al
    1dc5:	3f                   	(bad)
    1dc6:	9a                   	(bad)
    1dc7:	41 01 56 00          	add    %edx,0x0(%r14)
    1dcb:	04 a3                	add    $0xa3,%al
    1dcd:	19 a7 19 01 53 00    	sbb    %esp,0x530119(%rdi)
    1dd3:	04 a3                	add    $0xa3,%al
    1dd5:	19 96 1a 01 5f 04    	sbb    %edx,0x45f011a(%rsi)
    1ddb:	e6 1d                	out    %al,$0x1d
    1ddd:	fc                   	cld
    1dde:	1d 01 5f 04 a1       	sbb    $0xa1045f01,%eax
    1de3:	2a c0                	sub    %al,%al
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1de5:	2a 01                	sub    (%rcx),%al
    1de7:	5f                   	pop    %rdi
    1de8:	04 bf                	add    $0xbf,%al
    1dea:	3b 8a 3c 01 5f 00    	cmp    0x5f013c(%rdx),%ecx
    1df0:	04 a3                	add    $0xa3,%al
    1df2:	19 96 1a 02 30 9f    	sbb    %edx,-0x60cffde6(%rsi)
    1df8:	04 e6                	add    $0xe6,%al
    1dfa:	1d fc 1d 02 30       	sbb    $0x30021dfc,%eax
    1dff:	9f                   	lahf
    1e00:	04 a1                	add    $0xa1,%al
      if (qpr.server_id > 0) {
    1e02:	2a c0                	sub    %al,%al
    1e04:	2a 02                	sub    (%rdx),%al
    1e06:	30 9f 04 bf 3b 8a    	xor    %bl,-0x75c440fc(%rdi)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1e0c:	3c 02                	cmp    $0x2,%al
    1e0e:	30 9f 00 04 a3 19    	xor    %bl,0x19a30400(%rdi)
    1e14:	e3 19                	jrcxz  1e2f <balancer_ingress+0x1e2f>
    1e16:	12 30                	adc    (%rax),%dh
    1e18:	20 9f 93 04 30 20    	and    %bl,0x20300493(%rdi)
    1e1e:	9f                   	lahf
    1e1f:	93                   	xchg   %eax,%ebx
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1e20:	01 30                	add    %esi,(%rax)
    1e22:	9f                   	lahf
    1e23:	93                   	xchg   %eax,%ebx
    1e24:	01 30                	add    %esi,(%rax)
    1e26:	9f                   	lahf
    1e27:	93                   	xchg   %eax,%ebx
    1e28:	02 04 e3             	add    (%rbx,%riz,8),%al
    1e2b:	19 fd                	sbb    %edi,%ebp
    1e2d:	19 10                	sbb    %edx,(%rax)
    1e2f:	30 20                	xor    %ah,(%rax)
    1e31:	9f                   	lahf
    1e32:	93                   	xchg   %eax,%ebx
    1e33:	04 51                	add    $0x51,%al
    1e35:	93                   	xchg   %eax,%ebx
    1e36:	01 30                	add    %esi,(%rax)
    1e38:	9f                   	lahf
    1e39:	93                   	xchg   %eax,%ebx
  if (!conn_rate_stats) {
    1e3a:	01 30                	add    %esi,(%rax)
    1e3c:	9f                   	lahf
    1e3d:	93                   	xchg   %eax,%ebx
    1e3e:	02 04 fd 19 85 1a 0d 	add    0xd1a8519(,%rdi,8),%al
    1e45:	93                   	xchg   %eax,%ebx
    1e46:	04 51                	add    $0x51,%al
    1e48:	93                   	xchg   %eax,%ebx
    1e49:	01 30                	add    %esi,(%rax)
  *cur_time = bpf_ktime_get_ns();
    1e4b:	9f                   	lahf
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1e4c:	93                   	xchg   %eax,%ebx
    1e4d:	01 30                	add    %esi,(%rax)
    1e4f:	9f                   	lahf
    1e50:	93                   	xchg   %eax,%ebx
    1e51:	02 04 85 1a 96 1a 0a 	add    0xa1a961a(,%rax,4),%al
    1e58:	93                   	xchg   %eax,%ebx
    1e59:	05 30 9f 93 01       	add    $0x1939f30,%eax
    1e5e:	30 9f 93 02 04 e6    	xor    %bl,-0x19fbfd6d(%rdi)
    conn_rate_stats->v1 = 1;
    1e64:	1d fc 1d 12 30       	sbb    $0x30121dfc,%eax
    conn_rate_stats->v2 = *cur_time;
    1e69:	20 9f 93 04 30 20    	and    %bl,0x20300493(%rdi)
    1e6f:	9f                   	lahf
    1e70:	93                   	xchg   %eax,%ebx
    1e71:	01 30                	add    %esi,(%rax)
    1e73:	9f                   	lahf
    1e74:	93                   	xchg   %eax,%ebx
    1e75:	01 30                	add    %esi,(%rax)
    1e77:	9f                   	lahf
    1e78:	93                   	xchg   %eax,%ebx
    1e79:	02 04 a1             	add    (%rcx,%riz,4),%al
    1e7c:	2a c0                	sub    %al,%al
    1e7e:	2a 12                	sub    (%rdx),%dl
    1e80:	30 20                	xor    %ah,(%rax)
    1e82:	9f                   	lahf
    1e83:	93                   	xchg   %eax,%ebx
    1e84:	04 30                	add    $0x30,%al
    1e86:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1e8c:	93                   	xchg   %eax,%ebx
    1e8d:	01 30                	add    %esi,(%rax)
        if (real_pos) {
    1e8f:	9f                   	lahf
    1e90:	93                   	xchg   %eax,%ebx
    1e91:	02 04 bf             	add    (%rdi,%rdi,4),%al
    1e94:	3b cb                	cmp    %ebx,%ecx
    1e96:	3b 10                	cmp    (%rax),%edx
    1e98:	30 20                	xor    %ah,(%rax)
          key = *real_pos;
    1e9a:	9f                   	lahf
    1e9b:	93                   	xchg   %eax,%ebx
    1e9c:	04 51                	add    $0x51,%al
    1e9e:	93                   	xchg   %eax,%ebx
    1e9f:	01 30                	add    %esi,(%rax)
    1ea1:	9f                   	lahf
    1ea2:	93                   	xchg   %eax,%ebx
    1ea3:	01 30                	add    %esi,(%rax)
          if (key == 0) {
    1ea5:	9f                   	lahf
            pckt.real_index = key;
    1ea6:	93                   	xchg   %eax,%ebx
    1ea7:	02 04 cb             	add    (%rbx,%rcx,8),%al
    1eaa:	3b e0                	cmp    %eax,%esp
    1eac:	3b 0f                	cmp    (%rdi),%ecx
            dst = bpf_map_lookup_elem(&reals, &key);
    1eae:	30 20                	xor    %ah,(%rax)
    1eb0:	9f                   	lahf
    1eb1:	93                   	xchg   %eax,%ebx
    1eb2:	04 93                	add    $0x93,%al
    1eb4:	01 30                	add    %esi,(%rax)
    1eb6:	9f                   	lahf
    1eb7:	93                   	xchg   %eax,%ebx
    1eb8:	01 30                	add    %esi,(%rax)
    1eba:	9f                   	lahf
    1ebb:	93                   	xchg   %eax,%ebx
    1ebc:	02 04 e0             	add    (%rax,%riz,8),%al
    1ebf:	3b e4                	cmp    %esp,%esp
    1ec1:	3b 0a                	cmp    (%rdx),%ecx
    1ec3:	93                   	xchg   %eax,%ebx
    1ec4:	05 30 9f 93 01       	add    $0x1939f30,%eax
    1ec9:	30 9f 93 02 04 e4    	xor    %bl,-0x1bfbfd6d(%rdi)
            if (!dst) {
    1ecf:	3b e8                	cmp    %eax,%ebp
    1ed1:	3b 10                	cmp    (%rax),%edx
    1ed3:	30 20                	xor    %ah,(%rax)
    1ed5:	9f                   	lahf
    1ed6:	93                   	xchg   %eax,%ebx
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    1ed7:	04 51                	add    $0x51,%al
    1ed9:	93                   	xchg   %eax,%ebx
    1eda:	01 30                	add    %esi,(%rax)
    1edc:	9f                   	lahf
    1edd:	93                   	xchg   %eax,%ebx
    1ede:	01 30                	add    %esi,(%rax)
    1ee0:	9f                   	lahf
    1ee1:	93                   	xchg   %eax,%ebx
  if (dst_lru) {
    1ee2:	02 04 e8             	add    (%rax,%rbp,8),%al
    1ee5:	3b fa                	cmp    %edx,%edi
    1ee7:	3b 0f                	cmp    (%rdi),%ecx
    1ee9:	30 20                	xor    %ah,(%rax)
    if (dst_lru->pos == pckt->real_index) {
    1eeb:	9f                   	lahf
    1eec:	93                   	xchg   %eax,%ebx
    1eed:	04 93                	add    $0x93,%al
    1eef:	01 30                	add    %esi,(%rax)
    1ef1:	9f                   	lahf
    1ef2:	93                   	xchg   %eax,%ebx
    1ef3:	01 30                	add    %esi,(%rax)
    1ef5:	9f                   	lahf
    1ef6:	93                   	xchg   %eax,%ebx
              quic_packets_stats->dst_match_in_lru += 1;
    1ef7:	02 04 fa             	add    (%rdx,%rdi,8),%al
    1efa:	3b 82 3c 0a 93 05    	cmp    0x5930a3c(%rdx),%eax
    1f00:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    1f06:	93                   	xchg   %eax,%ebx
    1f07:	02 04 82             	add    (%rdx,%rax,4),%al
    1f0a:	3c 8a                	cmp    $0x8a,%al
    1f0c:	3c 06                	cmp    $0x6,%al
    1f0e:	93                   	xchg   %eax,%ebx
    1f0f:	06                   	(bad)
    1f10:	30 9f 93 02 00 04    	xor    %bl,0x4000293(%rdi)
    1f16:	c1 19 d1             	rcrl   $0xd1,(%rcx)
    1f19:	19 01                	sbb    %eax,(%rcx)
    1f1b:	53                   	push   %rbx
    1f1c:	04 e6                	add    $0xe6,%al
      dst_lru->pos = pckt->real_index;
    1f1e:	1d fc 1d 01 53       	sbb    $0x53011dfc,%eax
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1f23:	04 a1                	add    $0xa1,%al
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1f25:	2a af 2a 01 53 00    	sub    0x53012a(%rdi),%ch
    1f2b:	04 c1                	add    $0xc1,%al
    1f2d:	19 d1                	sbb    %edx,%ecx
    1f2f:	19 01                	sbb    %eax,(%rcx)
    1f31:	53                   	push   %rbx
    1f32:	04 e6                	add    $0xe6,%al
    1f34:	1d fc 1d 01 53       	sbb    $0x53011dfc,%eax
    1f39:	04 a1                	add    $0xa1,%al
    1f3b:	2a af 2a 01 53 00    	sub    0x53012a(%rdi),%ch
    1f41:	04 c1                	add    $0xc1,%al
    1f43:	19 d6                	sbb    %edx,%esi
    1f45:	19 02                	sbb    %eax,(%rdx)
    1f47:	30 9f 04 d6 19 8c    	xor    %bl,-0x73e629fc(%rdi)
    1f4d:	1a 01                	sbb    (%rcx),%al
  if (!per_vip_stats) {
    1f4f:	50                   	push   %rax
    1f50:	04 e6                	add    $0xe6,%al
    1f52:	1d fc 1d 02 30       	sbb    $0x30021dfc,%eax
    1f57:	9f                   	lahf
    1f58:	04 a1                	add    $0xa1,%al
    conn_rate_stats->v1 += 1;
    1f5a:	2a a5 2a 02 30 9f    	sub    -0x60cffdd6(%rbp),%ah
    1f60:	04 b2                	add    $0xb2,%al
    1f62:	2a c0                	sub    %al,%al
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1f64:	2a 01                	sub    (%rcx),%al
    1f66:	53                   	push   %rbx
    1f67:	04 bf                	add    $0xbf,%al
    1f69:	3b e0                	cmp    %eax,%esp
  struct real_pos_lru new_dst_lru = {};
    1f6b:	3b 01                	cmp    (%rcx),%eax
    1f6d:	50                   	push   %rax
    1f6e:	04 e4                	add    $0xe4,%al
    1f70:	3b fa                	cmp    %edx,%edi
    1f72:	3b 01                	cmp    (%rcx),%eax
    1f74:	50                   	push   %rax
    1f75:	00 04 e3             	add    %al,(%rbx,%riz,8)
    1f78:	19 85 1a 01 51 04    	sbb    %eax,0x451011a(%rbp)
  new_dst_lru.pos = pckt->real_index;
    1f7e:	bf 3b cb 3b 01       	mov    $0x13bcb3b,%edi
    1f83:	51                   	push   %rcx
    1f84:	04 e4                	add    $0xe4,%al
    1f86:	3b e8                	cmp    %eax,%ebp
    1f88:	3b 01                	cmp    (%rcx),%eax
BPF_MAP_OPS_INLINE(map_update_elem,,
    1f8a:	51                   	push   %rcx
    1f8b:	00 04 96             	add    %al,(%rsi,%rdx,4)
    1f8e:	1a a7 1a 02 30 9f    	sbb    -0x60cffde6(%rdi),%ah
    1f94:	04 a7                	add    $0xa7,%al
    1f96:	1a b0 1a 01 56 00    	sbb    0x56011a(%rax),%dh
              quic_packets_stats->dst_not_found_in_lru += 1;
    1f9c:	04 b0                	add    $0xb0,%al
    1f9e:	1a cb                	sbb    %bl,%cl
    1fa0:	1a 01                	sbb    (%rcx),%al
    1fa2:	56                   	push   %rsi
    1fa3:	00 04 e7             	add    %al,(%rdi,%riz,8)
    1fa6:	1a ad 1b 03 77 08    	sbb    0x877031b(%rbp),%ch
  original_sport = pckt.flow.port16[0];
    1fac:	9f                   	lahf
    1fad:	04 96                	add    $0x96,%al
    1faf:	1f                   	(bad)
    1fb0:	cf                   	iret
    1fb1:	1f                   	(bad)
    1fb2:	03 77 08             	add    0x8(%rdi),%esi
    1fb5:	9f                   	lahf
    1fb6:	00 04 ec             	add    %al,(%rsp,%rbp,8)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1fb9:	1a f7                	sbb    %bh,%dh
    1fbb:	1a 01                	sbb    (%rcx),%al
    1fbd:	55                   	push   %rbp
    1fbe:	04 f7                	add    $0xf7,%al
    1fc0:	1a ad 1b 03 77 d0    	sbb    -0x2f88fce5(%rbp),%ch
    1fc6:	00 04 96             	add    %al,(%rsi,%rdx,4)
    1fc9:	1f                   	(bad)
    1fca:	cf                   	iret
    1fcb:	1f                   	(bad)
    1fcc:	03 77 d0             	add    -0x30(%rdi),%esi
    1fcf:	00 00                	add    %al,(%rax)
  if (!conn_rate_stats) {
    1fd1:	04 e7                	add    $0xe7,%al
    1fd3:	1a ad 1b 02 30 9f    	sbb    -0x60cffde5(%rbp),%ch
    1fd9:	04 96                	add    $0x96,%al
    1fdb:	1f                   	(bad)
    1fdc:	cf                   	iret
    1fdd:	1f                   	(bad)
    1fde:	02 30                	add    (%rax),%dh
    1fe0:	9f                   	lahf
  *cur_time = bpf_ktime_get_ns();
    1fe1:	00 04 f7             	add    %al,(%rdi,%rsi,8)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1fe4:	1a 8a 1b 01 50 04    	sbb    0x450011b(%rdx),%cl
    1fea:	8a 1b                	mov    (%rbx),%bl
    1fec:	ad                   	lods   %ds:(%rsi),%eax
    1fed:	1b 01                	sbb    (%rcx),%eax
    1fef:	56                   	push   %rsi
    1ff0:	04 96                	add    $0x96,%al
    1ff2:	1f                   	(bad)
    conn_rate_stats->v1 = 1;
    1ff3:	cf                   	iret
    1ff4:	1f                   	(bad)
    1ff5:	01 56 00             	add    %edx,0x0(%rsi)
    1ff8:	04 93                	add    $0x93,%al
    conn_rate_stats->v2 = *cur_time;
    1ffa:	1b ad 1b 01 50 04    	sbb    0x450011b(%rbp),%ebp
      dst_lru->pos = pckt->real_index;
    2000:	96                   	xchg   %eax,%esi
    2001:	1f                   	(bad)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    2002:	9a                   	(bad)
    2003:	1f                   	(bad)
    2004:	01 50 00             	add    %edx,0x0(%rax)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2007:	04 b0                	add    $0xb0,%al
    2009:	1b 93 1c 03 77 08    	sbb    0x877031c(%rbx),%edx
    200f:	9f                   	lahf
    2010:	04 ef                	add    $0xef,%al
    2012:	1c e6                	sbb    $0xe6,%al
    2014:	1d 03 77 08 9f       	sbb    $0x9f087703,%eax
    2019:	04 c4                	add    $0xc4,%al
    201b:	1f                   	(bad)
    201c:	cf                   	iret
    201d:	1f                   	(bad)
    201e:	03 77 08             	add    0x8(%rdi),%esi
    2021:	9f                   	lahf
    2022:	00 04 b0             	add    %al,(%rax,%rsi,4)
    2025:	1b c0                	sbb    %eax,%eax
    2027:	1b 02                	sbb    (%rdx),%eax
    2029:	77 38                	ja     2063 <balancer_ingress+0x2063>
    202b:	04 c0                	add    $0xc0,%al
    202d:	1b d4                	sbb    %esp,%edx
    202f:	1b 01                	sbb    (%rcx),%eax
  if (!per_vip_stats) {
    2031:	50                   	push   %rax
    2032:	04 d4                	add    $0xd4,%al
    2034:	1b 93 1c 02 77 38    	sbb    0x3877021c(%rbx),%edx
    203a:	04 ef                	add    $0xef,%al
    conn_rate_stats->v1 += 1;
    203c:	1c e6                	sbb    $0xe6,%al
    203e:	1d 02 77 38 04       	sbb    $0x4387702,%eax
    2043:	c4                   	(bad)
    2044:	1f                   	(bad)
    2045:	cf                   	iret
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2046:	1f                   	(bad)
    2047:	02 77 38             	add    0x38(%rdi),%dh
    204a:	00 04 b0             	add    %al,(%rax,%rsi,4)
    204d:	1b 93 1c 04 77 e8    	sbb    -0x1788fbe4(%rbx),%edx
  struct real_pos_lru new_dst_lru = {};
    2053:	00 9f 04 ef 1c e6    	add    %bl,-0x19e310fc(%rdi)
    2059:	1d 04 77 e8 00       	sbb    $0xe87704,%eax
    205e:	9f                   	lahf
    205f:	04 c4                	add    $0xc4,%al
  new_dst_lru.pos = pckt->real_index;
    2061:	1f                   	(bad)
    2062:	cf                   	iret
    2063:	1f                   	(bad)
    2064:	04 77                	add    $0x77,%al
    2066:	e8 00 9f 00 04       	call   400bf6b <_license+0x4009ed1>
    206b:	ca 1b 93             	lret   $0x931b
    206e:	1c 04                	sbb    $0x4,%al
    2070:	10 82 04 9f 04 ef    	adc    %al,-0x10fb60fc(%rdx)
    2076:	1c 85                	sbb    $0x85,%al
    2078:	1d 04 10 82 04       	sbb    $0x4821004,%eax
    207d:	9f                   	lahf
    207e:	00 04 ca             	add    %al,(%rdx,%rcx,8)
              quic_packets_stats->dst_not_found_in_lru += 1;
    2081:	1b db                	sbb    %ebx,%ebx
    2083:	1b 02                	sbb    (%rdx),%eax
    2085:	30 9f 04 db 1b e4    	xor    %bl,-0x1be424fc(%rdi)
            quic_packets_stats->cid_routed += 1;
    208b:	1b 01                	sbb    (%rcx),%eax
    208d:	53                   	push   %rbx
    208e:	00 04 e4             	add    %al,(%rsp,%riz,8)
  original_sport = pckt.flow.port16[0];
    2091:	1b 93 1c 01 53 04    	sbb    0x453011c(%rbx),%edx
    2097:	ef                   	out    %eax,(%dx)
    2098:	1c 85                	sbb    $0x85,%al
    209a:	1d 01 53 00 04       	sbb    $0x4005301,%eax
    209f:	ae                   	scas   %es:(%rdi),%al
    20a0:	1c d8                	sbb    $0xd8,%al
    20a2:	1c 02                	sbb    $0x2,%al
    20a4:	30 9f 04 d8 1c e1    	xor    %bl,-0x1ee327fc(%rdi)
    20aa:	1c 01                	sbb    $0x1,%al
    20ac:	56                   	push   %rsi
    20ad:	00 04 e1             	add    %al,(%rcx,%riz,8)
    20b0:	1c ef                	sbb    $0xef,%al
    20b2:	1c 01                	sbb    $0x1,%al
    20b4:	56                   	push   %rsi
    20b5:	00 04 85 1d 9a 1d 02 	add    %al,0x21d9a1d(,%rax,4)
    20bc:	30 9f 04 9a 1d a3    	xor    %bl,-0x5ce265fc(%rdi)
    20c2:	1d 01 50 00 04       	sbb    $0x4005001,%eax
    20c7:	8f                   	(bad)
    20c8:	1d 9a 1d 01 55       	sbb    $0x55011d9a,%eax
    20cd:	00 04 9a             	add    %al,(%rdx,%rbx,4)
    20d0:	1d b1 1d 01 50       	sbb    $0x50011db1,%eax
    20d5:	00 04 b1             	add    %al,(%rcx,%rsi,4)
    20d8:	1d c4 1d 01 50       	sbb    $0x50011dc4,%eax
    20dd:	00 04 ba             	add    %al,(%rdx,%rdi,4)
    20e0:	1d cb 1d 02 30       	sbb    $0x30021dcb,%eax
    20e5:	9f                   	lahf
    20e6:	04 cb                	add    $0xcb,%al
    20e8:	1d d4 1d 01 50       	sbb    $0x50011dd4,%eax
    20ed:	00 04 d4             	add    %al,(%rsp,%rdx,8)
    20f0:	1d e6 1d 01 50       	sbb    $0x50011de6,%eax
    20f5:	00 04 81             	add    %al,(%rcx,%rax,4)
    20f8:	1e                   	(bad)
    20f9:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    20fa:	1e                   	(bad)
    20fb:	02 30                	add    (%rax),%dh
    20fd:	9f                   	lahf
    20fe:	04 a6                	add    $0xa6,%al
    2100:	1e                   	(bad)
    2101:	af                   	scas   %es:(%rdi),%eax
    2102:	1e                   	(bad)
    2103:	01 56 00             	add    %edx,0x0(%rsi)
    2106:	04 af                	add    $0xaf,%al
    2108:	1e                   	(bad)
    2109:	bd 1e 01 56 00       	mov    $0x56011e,%ebp
    210e:	04 bd                	add    $0xbd,%al
    2110:	1e                   	(bad)
    2111:	c7                   	(bad)
    2112:	1e                   	(bad)
    2113:	01 53 00             	add    %edx,0x0(%rbx)
    2116:	04 df                	add    $0xdf,%al
    2118:	1e                   	(bad)
    2119:	85 1f                	test   %ebx,(%rdi)
    211b:	01 51 04             	add    %edx,0x4(%rcx)
    211e:	f3 27                	repz (bad)
    2120:	ff 27                	jmp    *(%rdi)
    2122:	01 51 04             	add    %edx,0x4(%rcx)
    2125:	98                   	cwtl
    2126:	28 9c 28 01 51 00 04 	sub    %bl,0x4005101(%rax,%rbp,1)
    212d:	9d                   	popf
    212e:	1f                   	(bad)
    212f:	ae                   	scas   %es:(%rdi),%al
    2130:	1f                   	(bad)
    2131:	01 50 00             	add    %edx,0x0(%rax)
    2134:	04 9d                	add    $0x9d,%al
    2136:	1f                   	(bad)
    2137:	ae                   	scas   %es:(%rdi),%al
    2138:	1f                   	(bad)
    2139:	01 50 00             	add    %edx,0x0(%rax)
    213c:	04 aa                	add    $0xaa,%al
    213e:	1f                   	(bad)
    213f:	c4                   	(bad)
    2140:	1f                   	(bad)
    2141:	02 30                	add    (%rax),%dh
    2143:	9f                   	lahf
    2144:	00 04 d8             	add    %al,(%rax,%rbx,8)
    2147:	1f                   	(bad)
    2148:	fd                   	std
    2149:	1f                   	(bad)
    214a:	02 30                	add    (%rax),%dh
    214c:	9f                   	lahf
    214d:	04 fd                	add    $0xfd,%al
    214f:	1f                   	(bad)
    2150:	86 20                	xchg   %ah,(%rax)
    2152:	01 52 00             	add    %edx,0x0(%rdx)
    2155:	04 9e                	add    $0x9e,%al
    2157:	20 90 22 01 53 04    	and    %dl,0x4530122(%rax)
    215d:	af                   	scas   %es:(%rdi),%eax
    215e:	26 b2 27             	es mov $0x27,%dl
    2161:	01 53 00             	add    %edx,0x0(%rbx)
    2164:	04 a5                	add    $0xa5,%al
    2166:	20 c8                	and    %cl,%al
    2168:	20 02                	and    %al,(%rdx)
    216a:	30 9f 04 c8 20 d1    	xor    %bl,-0x2edf37fc(%rdi)
    2170:	20 01                	and    %al,(%rcx)
    2172:	52                   	push   %rdx
    2173:	00 04 b0             	add    %al,(%rax,%rsi,4)
    2176:	20 da                	and    %bl,%dl
    2178:	20 04 10             	and    %al,(%rax,%rdx,1)
    217b:	80 20 9f             	andb   $0x9f,(%rax)
    217e:	00 04 b0             	add    %al,(%rax,%rsi,4)
    2181:	20 da                	and    %bl,%dl
    2183:	20 02                	and    %al,(%rdx)
    2185:	38 9f 00 04 f4 20    	cmp    %bl,0x20f40400(%rdi)
    218b:	90                   	nop
    218c:	22 12                	and    (%rdx),%dl
    218e:	73 00                	jae    2190 <_license+0xf6>
    2190:	10 ff                	adc    %bh,%bh
    2192:	ff 03                	incl   (%rbx)
    2194:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
    219a:	a8 b0                	test   $0xb0,%al
    219c:	80 80 00 9f 00 04 c6 	addb   $0xc6,0x4009f00(%rax)
    21a3:	21 b7 22 0e 7e 00    	and    %esi,0x7e0e22(%rdi)
    21a9:	10 ff                	adc    %bh,%bh
    21ab:	ff                   	(bad)
    21ac:	ff                   	(bad)
    21ad:	ff 0f                	decl   (%rdi)
    21af:	1a 10                	sbb    (%rax),%dl
    21b1:	ac                   	lods   %ds:(%rsi),%al
    21b2:	21 21                	and    %esp,(%rcx)
    21b4:	9f                   	lahf
    21b5:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    21b8:	20 b7 22 02 30 9f    	and    %dh,-0x60cffdde(%rdi)
    21be:	00 04 97             	add    %al,(%rdi,%rdx,4)
    21c1:	21 b7 22 01 50 00    	and    %esi,0x500122(%rdi)
    21c7:	04 9b                	add    $0x9b,%al
    21c9:	21 d7                	and    %edx,%edi
    21cb:	21 01                	and    %eax,(%rcx)
    21cd:	52                   	push   %rdx
    21ce:	00 04 9b             	add    %al,(%rbx,%rbx,4)
    21d1:	21 b7 22 01 50 00    	and    %esi,0x500122(%rdi)
    21d7:	04 9f                	add    $0x9f,%al
    21d9:	21 ac 21 01 51 00 04 	and    %ebp,0x4005101(%rcx,%riz,1)
    21e0:	9f                   	lahf
    21e1:	21 b7 22 03 70 14    	and    %esi,0x14700322(%rdi)
    21e7:	9f                   	lahf
    21e8:	00 04 86             	add    %al,(%rsi,%rax,4)
    21eb:	22 90 22 01 53 00    	and    0x530122(%rax),%dl
    21f1:	04 86                	add    $0x86,%al
    21f3:	22 af 22 01 51 00    	and    0x510122(%rdi),%ch
    21f9:	04 ab                	add    $0xab,%al
    21fb:	22 af 22 03 11 00    	and    0x110322(%rdi),%ch
    2201:	9f                   	lahf
    2202:	04 af                	add    $0xaf,%al
    2204:	22 b2 22 03 11 01    	and    0x1110322(%rdx),%dh
    220a:	9f                   	lahf
    220b:	04 b2                	add    $0xb2,%al
    220d:	22 b7 22 03 11 04    	and    0x4110322(%rdi),%dh
    2213:	9f                   	lahf
    2214:	00 04 ab             	add    %al,(%rbx,%rbp,4)
    2217:	22 af 22 05 70 0e    	and    0xe700522(%rdi),%ch
    221d:	23 02                	and    (%rdx),%eax
    221f:	9f                   	lahf
    2220:	04 af                	add    $0xaf,%al
    2222:	22 b2 22 05 70 0e    	and    0xe700522(%rdx),%dh
    2228:	23 04 9f             	and    (%rdi,%rbx,4),%eax
    222b:	04 b2                	add    $0xb2,%al
    222d:	22 b7 22 05 70 0e    	and    0xe700522(%rdi),%dh
    2233:	23 0a                	and    (%rdx),%ecx
    2235:	9f                   	lahf
    2236:	00 04 be             	add    %al,(%rsi,%rdi,4)
    2239:	22 cf                	and    %bh,%cl
    223b:	22 02                	and    (%rdx),%al
    223d:	30 9f 04 cf 22 d8    	xor    %bl,-0x27dd30fc(%rdi)
    2243:	22 01                	and    (%rcx),%al
    2245:	50                   	push   %rax
    2246:	00 04 d8             	add    %al,(%rax,%rbx,8)
    2249:	22 f2                	and    %dl,%dh
    224b:	22 01                	and    (%rcx),%al
    224d:	50                   	push   %rax
    224e:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    2251:	22 a8 26 03 77 08    	and    0x8770326(%rax),%ch
    2257:	9f                   	lahf
    2258:	04 e3                	add    $0xe3,%al
    225a:	28 8e 29 03 77 08    	sub    %cl,0x8770329(%rsi)
    2260:	9f                   	lahf
    2261:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    2264:	22 ec                	and    %ah,%ch
    2266:	23 02                	and    (%rdx),%eax
    2268:	77 38                	ja     22a2 <_license+0x208>
    226a:	04 ec                	add    $0xec,%al
    226c:	23 fc                	and    %esp,%edi
    226e:	23 01                	and    (%rcx),%eax
    2270:	52                   	push   %rdx
    2271:	04 fc                	add    $0xfc,%al
    2273:	23 80 25 02 77 38    	and    0x38770225(%rax),%eax
    2279:	04 80                	add    $0x80,%al
    227b:	25 85 25 01 51       	and    $0x51012585,%eax
    2280:	04 85                	add    $0x85,%al
    2282:	25 99 26 02 77       	and    $0x77022699,%eax
    2287:	38 04 99             	cmp    %al,(%rcx,%rbx,4)
    228a:	26 9b                	es fwait
    228c:	26 01 52 04          	es add %edx,0x4(%rdx)
    2290:	9b                   	fwait
    2291:	26 a8 26             	es test $0x26,%al
    2294:	02 77 38             	add    0x38(%rdi),%dh
    2297:	04 e3                	add    $0xe3,%al
    2299:	28 8e 29 02 77 38    	sub    %cl,0x38770229(%rsi)
    229f:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    22a2:	22 a8 26 02 30 9f    	and    -0x60cffdda(%rax),%ch
    22a8:	04 e3                	add    $0xe3,%al
    22aa:	28 8e 29 02 30 9f    	sub    %cl,-0x60cffdd7(%rsi)
    22b0:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    22b3:	22 a8 26 03 77 d0    	and    -0x2f88fcda(%rax),%ch
    22b9:	00 04 e3             	add    %al,(%rbx,%riz,8)
    22bc:	28 f8                	sub    %bh,%al
    22be:	28 03                	sub    %al,(%rbx)
    22c0:	77 d0                	ja     2292 <_license+0x1f8>
    22c2:	00 04 f8             	add    %al,(%rax,%rdi,8)
    22c5:	28 8a 29 01 55 00    	sub    %cl,0x550129(%rdx)
    22cb:	04 84                	add    $0x84,%al
    22cd:	23 e7                	and    %edi,%esp
    22cf:	23 02                	and    (%rdx),%eax
    22d1:	30 9f 04 e7 23 a2    	xor    %bl,-0x5ddc18fc(%rdi)
    22d7:	26 11 73 00          	es adc %esi,0x0(%rbx)
    22db:	10 ff                	adc    %bh,%bh
    22dd:	01 1a                	add    %ebx,(%rdx)
    22df:	a8 ba                	test   $0xba,%al
    22e1:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    22e8:	00 9f 00 04 84 23    	add    %bl,0x23840400(%rdi)
    22ee:	a8 26                	test   $0x26,%al
    22f0:	02 30                	add    (%rax),%dh
    22f2:	9f                   	lahf
    22f3:	04 e3                	add    $0xe3,%al
    22f5:	28 8e 29 02 30 9f    	sub    %cl,-0x60cffdd7(%rsi)
    22fb:	00 04 84             	add    %al,(%rsp,%rax,4)
    22fe:	23 a8 26 02 30 9f    	and    -0x60cffdda(%rax),%ebp
    2304:	04 e3                	add    $0xe3,%al
    2306:	28 ea                	sub    %ch,%dl
    2308:	28 02                	sub    %al,(%rdx)
    230a:	30 9f 04 ea 28 ef    	xor    %bl,-0x10d715fc(%rdi)
    2310:	28 01                	sub    %al,(%rcx)
    2312:	50                   	push   %rax
    2313:	00 04 84             	add    %al,(%rsp,%rax,4)
    2316:	23 95 23 02 30 9f    	and    -0x60cffddd(%rbp),%edx
    231c:	04 95                	add    $0x95,%al
    231e:	23 a5 23 01 56 00    	and    0x560123(%rbp),%esp
    2324:	04 9e                	add    $0x9e,%al
    2326:	23 e5                	and    %ebp,%esp
    2328:	23 01                	and    (%rcx),%eax
    232a:	56                   	push   %rsi
    232b:	00 04 e7             	add    %al,(%rdi,%riz,8)
    232e:	23 b0 25 02 30 9f    	and    -0x60cffddb(%rax),%esi
    2334:	04 e4                	add    $0xe4,%al
    2336:	25 8c 26 02 30       	and    $0x3002268c,%eax
    233b:	9f                   	lahf
    233c:	00 04 95 24 98 25 03 	add    %al,0x3259824(,%rdx,4)
    2343:	77 08                	ja     234d <_license+0x2b3>
    2345:	9f                   	lahf
    2346:	00 04 95 24 98 25 02 	add    %al,0x2259824(,%rdx,4)
    234d:	30 9f 00 04 95 24    	xor    %bl,0x24950400(%rdi)
    2353:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    2354:	24 01                	and    $0x1,%al
    2356:	51                   	push   %rcx
    2357:	00 04 a4             	add    %al,(%rsp,%riz,4)
    235a:	24 dc                	and    $0xdc,%al
    235c:	24 01                	and    $0x1,%al
    235e:	51                   	push   %rcx
    235f:	00 04 9e             	add    %al,(%rsi,%rbx,4)
    2362:	24 e3                	and    $0xe3,%al
    2364:	24 01                	and    $0x1,%al
    2366:	54                   	push   %rsp
    2367:	00 04 95 24 9e 24 02 	add    %al,0x2249e24(,%rdx,4)
    236e:	30 9f 04 9e 24 ac    	xor    %bl,-0x53db61fc(%rdi)
    2374:	24 0c                	and    $0xc,%al
    2376:	10 f7                	adc    %dh,%bh
    2378:	81 b7 85 fe ff ff ff 	xorl   $0x9f01ffff,-0x17b(%rdi)
    237f:	ff 01 9f 
    2382:	04 ac                	add    $0xac,%al
    2384:	24 fb                	and    $0xfb,%al
    2386:	24 01                	and    $0x1,%al
    2388:	52                   	push   %rdx
    2389:	00 04 fb             	add    %al,(%rbx,%rdi,8)
    238c:	24 9a                	and    $0x9a,%al
    238e:	25 01 52 00 04       	and    $0x4005201,%eax
    2393:	8c 25 a4 25 01 51    	mov    %fs,0x510125a4(%rip)        # 5101493d <_license+0x510128a3>
    2399:	04 a4                	add    $0xa4,%al
    239b:	25 ab 25 01 52       	and    $0x520125ab,%eax
    23a0:	04 ab                	add    $0xab,%al
    23a2:	25 a8 26 01 56       	and    $0x560126a8,%eax
    23a7:	04 e3                	add    $0xe3,%al
    23a9:	28 8e 29 01 56 00    	sub    %cl,0x560129(%rsi)
    23af:	04 8c                	add    $0x8c,%al
    23b1:	25 92 25 02 30       	and    $0x30022592,%eax
    23b6:	9f                   	lahf
    23b7:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    23ba:	25 ba 25 02 30       	and    $0x300225ba,%eax
    23bf:	9f                   	lahf
    23c0:	00 04 bc             	add    %al,(%rsp,%rdi,4)
    23c3:	25 cd 25 02 30       	and    $0x300225cd,%eax
    23c8:	9f                   	lahf
    23c9:	04 cd                	add    $0xcd,%al
    23cb:	25 d6 25 01 50       	and    $0x500125d6,%eax
    23d0:	00 04 d6             	add    %al,(%rsi,%rdx,8)
    23d3:	25 e4 25 01 50       	and    $0x500125e4,%eax
    23d8:	00 04 e4             	add    %al,(%rsp,%riz,8)
    23db:	25 f5 25 02 30       	and    $0x300225f5,%eax
    23e0:	9f                   	lahf
    23e1:	04 f5                	add    $0xf5,%al
    23e3:	25 fe 25 01 50       	and    $0x500125fe,%eax
    23e8:	00 04 fe             	add    %al,(%rsi,%rdi,8)
    23eb:	25 8c 26 01 50       	and    $0x5001268c,%eax
    23f0:	00 04 af             	add    %al,(%rdi,%rbp,4)
    23f3:	26 b2 27             	es mov $0x27,%dl
    23f6:	12 73 00             	adc    0x0(%rbx),%dh
    23f9:	10 ff                	adc    %bh,%bh
    23fb:	ff 03                	incl   (%rbx)
    23fd:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
    2403:	a8 b0                	test   $0xb0,%al
    2405:	80 80 00 9f 00 04 cc 	addb   $0xcc,0x4009f00(%rax)
    240c:	26 f3 27             	es repz (bad)
    240f:	01 50 00             	add    %edx,0x0(%rax)
    2412:	04 d0                	add    $0xd0,%al
    2414:	26 fe                	es (bad)
    2416:	26 01 52 00          	es add %edx,0x0(%rdx)
    241a:	04 d0                	add    $0xd0,%al
    241c:	26 f3 27             	es repz (bad)
    241f:	01 50 00             	add    %edx,0x0(%rax)
    2422:	04 d4                	add    $0xd4,%al
    2424:	26 e1 26             	es loope 244d <_license+0x3b3>
    2427:	01 51 00             	add    %edx,0x0(%rcx)
    242a:	04 d4                	add    $0xd4,%al
    242c:	26 f3 27             	es repz (bad)
    242f:	03 70 28             	add    0x28(%rax),%esi
    2432:	9f                   	lahf
    2433:	00 04 aa             	add    %al,(%rdx,%rbp,4)
    2436:	27                   	(bad)
    2437:	f3 27                	repz (bad)
    2439:	02 34 9f             	add    (%rdi,%rbx,4),%dh
    243c:	00 04 aa             	add    %al,(%rdx,%rbp,4)
    243f:	27                   	(bad)
    2440:	ae                   	scas   %es:(%rdi),%al
    2441:	27                   	(bad)
    2442:	0c 31                	or     $0x31,%al
    2444:	9f                   	lahf
    2445:	93                   	xchg   %eax,%ebx
    2446:	04 30                	add    $0x30,%al
    2448:	9f                   	lahf
    2449:	93                   	xchg   %eax,%ebx
    244a:	04 30                	add    $0x30,%al
    244c:	9f                   	lahf
    244d:	93                   	xchg   %eax,%ebx
    244e:	04 04                	add    $0x4,%al
    2450:	ae                   	scas   %es:(%rdi),%al
    2451:	27                   	(bad)
    2452:	e9 27 0f 31 9f       	jmp    ffffffff9f31337e <server_id_map+0x5ffffe260e837e>
    2457:	93                   	xchg   %eax,%ebx
    2458:	04 30                	add    $0x30,%al
    245a:	9f                   	lahf
    245b:	93                   	xchg   %eax,%ebx
    245c:	04 30                	add    $0x30,%al
    245e:	9f                   	lahf
    245f:	93                   	xchg   %eax,%ebx
    2460:	04 52                	add    $0x52,%al
    2462:	93                   	xchg   %eax,%ebx
    2463:	04 04                	add    $0x4,%al
    2465:	e9 27 f3 27 0c       	jmp    c281791 <_license+0xc27f6f7>
    246a:	31 9f 93 04 30 9f    	xor    %ebx,-0x60cffb6d(%rdi)
    2470:	93                   	xchg   %eax,%ebx
    2471:	04 30                	add    $0x30,%al
    2473:	9f                   	lahf
    2474:	93                   	xchg   %eax,%ebx
    2475:	04 00                	add    $0x0,%al
    2477:	04 ae                	add    $0xae,%al
    2479:	27                   	(bad)
    247a:	b2 27                	mov    $0x27,%dl
    247c:	01 53 00             	add    %edx,0x0(%rbx)
    247f:	04 b2                	add    $0xb2,%al
    2481:	27                   	(bad)
    2482:	c6                   	(bad)
    2483:	27                   	(bad)
    2484:	01 53 00             	add    %edx,0x0(%rbx)
    2487:	04 b6                	add    $0xb6,%al
    2489:	28 be 28 03 50 93    	sub    %bh,-0x6caffcd8(%rsi)
    248f:	04 04                	add    $0x4,%al
    2491:	be 28 d9 28 06       	mov    $0x628d928,%esi
    2496:	50                   	push   %rax
    2497:	93                   	xchg   %eax,%ebx
    2498:	04 51                	add    $0x51,%al
    249a:	93                   	xchg   %eax,%ebx
    249b:	01 04 d3             	add    %eax,(%rbx,%rdx,8)
    249e:	2a 86 2b 06 50 93    	sub    -0x6caff9d5(%rsi),%al
    24a4:	04 51                	add    $0x51,%al
    24a6:	93                   	xchg   %eax,%ebx
    24a7:	01 04 86             	add    %eax,(%rsi,%rax,4)
    24aa:	2b b5 2b 05 93 04    	sub    0x493052b(%rbp),%esi
    24b0:	51                   	push   %rcx
    24b1:	93                   	xchg   %eax,%ebx
    24b2:	01 04 d6             	add    %eax,(%rsi,%rdx,8)
    24b5:	2b dd                	sub    %ebp,%ebx
    24b7:	2b 06                	sub    (%rsi),%eax
    24b9:	50                   	push   %rax
    24ba:	93                   	xchg   %eax,%ebx
    24bb:	04 51                	add    $0x51,%al
    24bd:	93                   	xchg   %eax,%ebx
    24be:	01 04 dd 2b e1 2b 05 	add    %eax,0x52be12b(,%rbx,8)
    24c5:	93                   	xchg   %eax,%ebx
    24c6:	04 51                	add    $0x51,%al
    24c8:	93                   	xchg   %eax,%ebx
    24c9:	01 00                	add    %eax,(%rax)
    24cb:	04 be                	add    $0xbe,%al
    24cd:	28 d9                	sub    %bl,%cl
    24cf:	28 01                	sub    %al,(%rcx)
    24d1:	56                   	push   %rsi
    24d2:	04 d3                	add    $0xd3,%al
    24d4:	2a e0                	sub    %al,%ah
    24d6:	2a 01                	sub    (%rcx),%al
    24d8:	56                   	push   %rsi
    24d9:	00 04 be             	add    %al,(%rsi,%rdi,4)
    24dc:	28 d9                	sub    %bl,%cl
    24de:	28 01                	sub    %al,(%rcx)
    24e0:	51                   	push   %rcx
    24e1:	04 d3                	add    $0xd3,%al
    24e3:	2a e0                	sub    %al,%ah
    24e5:	2a 01                	sub    (%rcx),%al
    24e7:	51                   	push   %rcx
    24e8:	00 04 c3             	add    %al,(%rbx,%rax,8)
    24eb:	29 d0                	sub    %edx,%eax
    24ed:	29 01                	sub    %eax,(%rcx)
    24ef:	50                   	push   %rax
    24f0:	00 04 c3             	add    %al,(%rbx,%rax,8)
    24f3:	29 e2                	sub    %esp,%edx
    24f5:	29 02                	sub    %eax,(%rdx)
    24f7:	30 9f 04 e2 29 eb    	xor    %bl,-0x14d61dfc(%rdi)
    24fd:	29 01                	sub    %eax,(%rcx)
    24ff:	50                   	push   %rax
    2500:	00 04 c3             	add    %al,(%rbx,%rax,8)
    2503:	29 d0                	sub    %edx,%eax
    2505:	29 01                	sub    %eax,(%rcx)
    2507:	50                   	push   %rax
    2508:	00 04 eb             	add    %al,(%rbx,%rbp,8)
    250b:	29 f7                	sub    %esi,%edi
    250d:	29 01                	sub    %eax,(%rcx)
    250f:	50                   	push   %rax
    2510:	00 04 a1             	add    %al,(%rcx,%riz,4)
    2513:	2a ab 2a 01 53 00    	sub    0x53012a(%rbx),%ch
    2519:	04 d9                	add    $0xd9,%al
    251b:	2a f1                	sub    %cl,%dh
    251d:	2a 01                	sub    (%rcx),%al
    251f:	50                   	push   %rax
    2520:	04 f1                	add    $0xf1,%al
    2522:	2a 90 2b 01 52 00    	sub    0x52012b(%rax),%dl
    2528:	04 d9                	add    $0xd9,%al
    252a:	2a de                	sub    %dh,%bl
    252c:	2a 02                	sub    (%rdx),%al
    252e:	30 9f 00 04 fc 2a    	xor    %bl,0x2afc0400(%rdi)
    2534:	9c                   	pushf
    2535:	2b 02                	sub    (%rdx),%eax
    2537:	30 9f 04 9c 2b a5    	xor    %bl,-0x5ad463fc(%rdi)
    253d:	2b 01                	sub    (%rcx),%eax
    253f:	53                   	push   %rbx
    2540:	00 04 fc             	add    %al,(%rsp,%rdi,8)
    2543:	2a 90 2b 01 52 00    	sub    0x52012b(%rax),%dl
    2549:	04 a5                	add    $0xa5,%al
    254b:	2b ca                	sub    %edx,%ecx
    254d:	2b 03                	sub    (%rbx),%eax
    254f:	77 08                	ja     2559 <_license+0x4bf>
    2551:	9f                   	lahf
    2552:	04 a0                	add    $0xa0,%al
    2554:	3c f0                	cmp    $0xf0,%al
    2556:	3c 03                	cmp    $0x3,%al
    2558:	77 08                	ja     2562 <_license+0x4c8>
    255a:	9f                   	lahf
    255b:	04 9d                	add    $0x9d,%al
    255d:	3e ae                	ds scas %es:(%rdi),%al
    255f:	3e 03 77 08          	ds add 0x8(%rdi),%esi
    2563:	9f                   	lahf
    2564:	04 d9                	add    $0xd9,%al
    2566:	3e 9c                	ds pushf
    2568:	3f                   	(bad)
    2569:	03 77 08             	add    0x8(%rdi),%esi
    256c:	9f                   	lahf
    256d:	00 04 aa             	add    %al,(%rdx,%rbp,4)
    2570:	2b b5 2b 01 55 04    	sub    0x455012b(%rbp),%esi
    2576:	b5 2b                	mov    $0x2b,%ch
    2578:	ca 2b 03             	lret   $0x32b
    257b:	77 d0                	ja     254d <_license+0x4b3>
    257d:	00 04 a0             	add    %al,(%rax,%riz,4)
    2580:	3c f0                	cmp    $0xf0,%al
    2582:	3c 03                	cmp    $0x3,%al
    2584:	77 d0                	ja     2556 <_license+0x4bc>
    2586:	00 04 9d 3e ae 3e 03 	add    %al,0x33eae3e(,%rbx,4)
    258d:	77 d0                	ja     255f <_license+0x4c5>
    258f:	00 04 d9             	add    %al,(%rcx,%rbx,8)
    2592:	3e 8a 3f             	ds mov (%rdi),%bh
    2595:	03 77 d0             	add    -0x30(%rdi),%esi
    2598:	00 04 8a             	add    %al,(%rdx,%rcx,4)
    259b:	3f                   	(bad)
    259c:	9c                   	pushf
    259d:	3f                   	(bad)
    259e:	01 55 00             	add    %edx,0x0(%rbp)
    25a1:	04 b5                	add    $0xb5,%al
    25a3:	2b ca                	sub    %edx,%ecx
    25a5:	2b 01                	sub    (%rcx),%eax
    25a7:	50                   	push   %rax
    25a8:	04 a0                	add    $0xa0,%al
    25aa:	3c aa                	cmp    $0xaa,%al
    25ac:	3c 01                	cmp    $0x1,%al
    25ae:	50                   	push   %rax
    25af:	04 9d                	add    $0x9d,%al
    25b1:	3e ae                	ds scas %es:(%rdi),%al
    25b3:	3e 01 50 00          	ds add %edx,0x0(%rax)
    25b7:	04 ca                	add    $0xca,%al
    25b9:	2b d6                	sub    %esi,%edx
    25bb:	2b 03                	sub    (%rbx),%eax
    25bd:	11 01                	adc    %eax,(%rcx)
    25bf:	9f                   	lahf
    25c0:	04 9f                	add    $0x9f,%al
    25c2:	3e d9 3e             	ds fnstcw (%rsi)
    25c5:	03 11                	add    (%rcx),%edx
    25c7:	01 9f 04 9c 3f b7    	add    %ebx,-0x48c063fc(%rdi)
    25cd:	3f                   	(bad)
    25ce:	03 11                	add    (%rcx),%edx
    25d0:	01 9f 00 04 fd 2b    	add    %ebx,0x2bfd0400(%rdi)
    25d6:	bb 2c 03 77 08       	mov    $0x877032c,%ebx
    25db:	9f                   	lahf
    25dc:	04 c3                	add    $0xc3,%al
    25de:	2c f0                	sub    $0xf0,%al
    25e0:	2c 03                	sub    $0x3,%al
    25e2:	77 08                	ja     25ec <_license+0x552>
    25e4:	9f                   	lahf
    25e5:	00 04 82             	add    %al,(%rdx,%rax,4)
    25e8:	2c 8d                	sub    $0x8d,%al
    25ea:	2c 01                	sub    $0x1,%al
    25ec:	55                   	push   %rbp
    25ed:	04 8d                	add    $0x8d,%al
    25ef:	2c bb                	sub    $0xbb,%al
    25f1:	2c 03                	sub    $0x3,%al
    25f3:	77 d0                	ja     25c5 <_license+0x52b>
    25f5:	00 04 c3             	add    %al,(%rbx,%rax,8)
    25f8:	2c f0                	sub    $0xf0,%al
    25fa:	2c 03                	sub    $0x3,%al
    25fc:	77 d0                	ja     25ce <_license+0x534>
    25fe:	00 00                	add    %al,(%rax)
    2600:	04 fd                	add    $0xfd,%al
    2602:	2b bb 2c 02 30 9f    	sub    -0x60cffdd4(%rbx),%edi
    2608:	04 c3                	add    $0xc3,%al
    260a:	2c f0                	sub    $0xf0,%al
    260c:	2c 02                	sub    $0x2,%al
    260e:	30 9f 00 04 8d 2c    	xor    %bl,0x2c8d0400(%rdi)
    2614:	9c                   	pushf
    2615:	2c 01                	sub    $0x1,%al
    2617:	50                   	push   %rax
    2618:	04 9c                	add    $0x9c,%al
    261a:	2c bb                	sub    $0xbb,%al
    261c:	2c 01                	sub    $0x1,%al
    261e:	56                   	push   %rsi
    261f:	04 c3                	add    $0xc3,%al
    2621:	2c f0                	sub    $0xf0,%al
    2623:	2c 01                	sub    $0x1,%al
    2625:	56                   	push   %rsi
    2626:	00 04 a5 2c bb 2c 01 	add    %al,0x12cbb2c(,%riz,4)
    262d:	50                   	push   %rax
    262e:	04 c3                	add    $0xc3,%al
    2630:	2c c7                	sub    $0xc7,%al
    2632:	2c 01                	sub    $0x1,%al
    2634:	50                   	push   %rax
    2635:	00 04 ca             	add    %al,(%rdx,%rcx,8)
    2638:	2c da                	sub    $0xda,%al
    263a:	2c 01                	sub    $0x1,%al
    263c:	50                   	push   %rax
    263d:	00 04 ca             	add    %al,(%rdx,%rcx,8)
    2640:	2c da                	sub    $0xda,%al
    2642:	2c 01                	sub    $0x1,%al
    2644:	50                   	push   %rax
    2645:	00 04 d6             	add    %al,(%rsi,%rdx,8)
    2648:	2c f0                	sub    $0xf0,%al
    264a:	2c 02                	sub    $0x2,%al
    264c:	30 9f 00 04 f5 2c    	xor    %bl,0x2cf50400(%rdi)
    2652:	80 2d 02 77 38 04 80 	subb   $0x80,0x4387702(%rip)        # 4389d5b <_license+0x4387cc1>
    2659:	2d b6 2d 01 55       	sub    $0x55012db6,%eax
    265e:	04 b6                	add    $0xb6,%al
    2660:	2d c1 2e 02 77       	sub    $0x77022ec1,%eax
    2665:	38 00                	cmp    %al,(%rax)
    2667:	04 8a                	add    $0x8a,%al
    2669:	2d 9b 2d 02 30       	sub    $0x30022d9b,%eax
    266e:	9f                   	lahf
    266f:	04 9b                	add    $0x9b,%al
    2671:	2d a4 2d 01 56       	sub    $0x56012da4,%eax
    2676:	00 04 a4             	add    %al,(%rsp,%riz,4)
    2679:	2d e8 2d 01 56       	sub    $0x56012de8,%eax
    267e:	00 04 e8             	add    %al,(%rax,%rbp,8)
    2681:	2d fd 2d 02 30       	sub    $0x30022dfd,%eax
    2686:	9f                   	lahf
    2687:	04 fd                	add    $0xfd,%al
    2689:	2d 82 2e 01 50       	sub    $0x50012e82,%eax
    268e:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    2691:	2d fd 2d 01 55       	sub    $0x55012dfd,%eax
    2696:	00 04 fd 2d 90 2e 01 	add    %al,0x12e902d(,%rdi,8)
    269d:	50                   	push   %rax
    269e:	00 04 90             	add    %al,(%rax,%rdx,4)
    26a1:	2e 9f                	cs lahf
    26a3:	2e 01 50 00          	cs add %edx,0x0(%rax)
    26a7:	04 95                	add    $0x95,%al
    26a9:	2e a6                	cmpsb  %es:(%rdi),%ds:(%rsi)
    26ab:	2e 02 30             	cs add (%rax),%dh
    26ae:	9f                   	lahf
    26af:	04 a6                	add    $0xa6,%al
    26b1:	2e af                	cs scas %es:(%rdi),%eax
    26b3:	2e 01 50 00          	cs add %edx,0x0(%rax)
    26b7:	04 af                	add    $0xaf,%al
    26b9:	2e c1 2e 01          	cs shrl $0x1,(%rsi)
    26bd:	50                   	push   %rax
    26be:	00 04 ca             	add    %al,(%rdx,%rcx,8)
    26c1:	2e ed                	cs in  (%dx),%eax
    26c3:	2e 02 30             	cs add (%rax),%dh
    26c6:	9f                   	lahf
    26c7:	04 ed                	add    $0xed,%al
    26c9:	2e f6 2e             	cs imulb (%rsi)
    26cc:	01 52 00             	add    %edx,0x0(%rdx)
    26cf:	04 95                	add    $0x95,%al
    26d1:	2f                   	(bad)
    26d2:	b8 2f 02 30 9f       	mov    $0x9f30022f,%eax
    26d7:	04 b8                	add    $0xb8,%al
    26d9:	2f                   	(bad)
    26da:	c1 2f 01             	shrl   $0x1,(%rdi)
    26dd:	52                   	push   %rdx
    26de:	00 04 a0             	add    %al,(%rax,%riz,4)
    26e1:	2f                   	(bad)
    26e2:	ca 2f 04             	lret   $0x42f
    26e5:	10 80 20 9f 00 04    	adc    %al,0x4009f20(%rax)
    26eb:	a0 2f ca 2f 02 38 9f 	movabs 0x4009f38022fca2f,%al
    26f2:	00 04 
    26f4:	b4 30                	mov    $0x30,%ah
    26f6:	a2 31 0e 7e 00 10 ff 	movabs %al,0xffffff10007e0e31
    26fd:	ff ff 
    26ff:	ff 0f                	decl   (%rdi)
    2701:	1a 10                	sbb    (%rax),%dl
    2703:	ac                   	lods   %ds:(%rsi),%al
    2704:	21 21                	and    %esp,(%rcx)
    2706:	9f                   	lahf
    2707:	00 04 e8             	add    %al,(%rax,%rbp,8)
    270a:	2f                   	(bad)
    270b:	a2 31 02 30 9f 00 04 	movabs %al,0x308504009f300231
    2712:	85 30 
    2714:	a2 31 01 50 00 04 89 	movabs %al,0xc530890400500131
    271b:	30 c5 
    271d:	30 01                	xor    %al,(%rcx)
    271f:	52                   	push   %rdx
    2720:	00 04 89             	add    %al,(%rcx,%rcx,4)
    2723:	30 a2 31 01 50 00    	xor    %ah,0x500131(%rdx)
    2729:	04 8d                	add    $0x8d,%al
    272b:	30 a2 31 03 70 14    	xor    %ah,0x14700331(%rdx)
    2731:	9f                   	lahf
    2732:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    2735:	30 9e 31 01 51 00    	xor    %bl,0x510131(%rsi)
    273b:	04 9a                	add    $0x9a,%al
    273d:	31 9e 31 03 11 00    	xor    %ebx,0x110331(%rsi)
    2743:	9f                   	lahf
    2744:	04 9e                	add    $0x9e,%al
    2746:	31 a2 31 03 11 01    	xor    %esp,0x1110331(%rdx)
    274c:	9f                   	lahf
    274d:	00 04 9a             	add    %al,(%rdx,%rbx,4)
    2750:	31 9e 31 05 70 0e    	xor    %ebx,0xe700531(%rsi)
    2756:	23 02                	and    (%rdx),%eax
    2758:	9f                   	lahf
    2759:	04 9e                	add    $0x9e,%al
    275b:	31 a2 31 05 70 0e    	xor    %esp,0xe700531(%rdx)
    2761:	23 04 9f             	and    (%rdi,%rbx,4),%eax
    2764:	00 04 b7             	add    %al,(%rdi,%rsi,4)
    2767:	32 c8                	xor    %al,%cl
    2769:	32 02                	xor    (%rdx),%al
    276b:	30 9f 04 c8 32 d1    	xor    %bl,-0x2ecd37fc(%rdi)
    2771:	32 01                	xor    (%rcx),%al
    2773:	50                   	push   %rax
    2774:	00 04 d1             	add    %al,(%rcx,%rdx,8)
    2777:	32 eb                	xor    %bl,%ch
    2779:	32 01                	xor    (%rcx),%al
    277b:	50                   	push   %rax
    277c:	00 04 eb             	add    %al,(%rbx,%rbp,8)
    277f:	32 ce                	xor    %dh,%cl
    2781:	37                   	(bad)
    2782:	03 77 08             	add    0x8(%rdi),%esi
    2785:	9f                   	lahf
    2786:	04 ef                	add    $0xef,%al
    2788:	37                   	(bad)
    2789:	8c 38                	mov    %?,(%rax)
    278b:	03 77 08             	add    0x8(%rdi),%esi
    278e:	9f                   	lahf
    278f:	04 d6                	add    $0xd6,%al
    2791:	39 81 3a 03 77 08    	cmp    %eax,0x877033a(%rcx)
    2797:	9f                   	lahf
    2798:	00 04 eb             	add    %al,(%rbx,%rbp,8)
    279b:	32 e4                	xor    %ah,%ah
    279d:	33 02                	xor    (%rdx),%eax
    279f:	77 38                	ja     27d9 <_license+0x73f>
    27a1:	04 e4                	add    $0xe4,%al
    27a3:	33 f1                	xor    %ecx,%esi
    27a5:	33 01                	xor    (%rcx),%eax
    27a7:	52                   	push   %rdx
    27a8:	04 f1                	add    $0xf1,%al
    27aa:	33 8b 34 02 77 38    	xor    0x38770234(%rbx),%ecx
    27b0:	04 8b                	add    $0x8b,%al
    27b2:	34 90                	xor    $0x90,%al
    27b4:	34 01                	xor    $0x1,%al
    27b6:	52                   	push   %rdx
    27b7:	04 90                	add    $0x90,%al
    27b9:	34 d6                	xor    $0xd6,%al
    27bb:	36 02 77 38          	ss add 0x38(%rdi),%dh
    27bf:	04 d6                	add    $0xd6,%al
    27c1:	36 db 36             	ss (bad) (%rsi)
    27c4:	01 52 04             	add    %edx,0x4(%rdx)
    27c7:	db 36                	(bad)  (%rsi)
    27c9:	ce                   	(bad)
    27ca:	37                   	(bad)
    27cb:	02 77 38             	add    0x38(%rdi),%dh
    27ce:	04 ef                	add    $0xef,%al
    27d0:	37                   	(bad)
    27d1:	fc                   	cld
    27d2:	37                   	(bad)
    27d3:	02 77 38             	add    0x38(%rdi),%dh
    27d6:	04 fc                	add    $0xfc,%al
    27d8:	37                   	(bad)
    27d9:	fe                   	(bad)
    27da:	37                   	(bad)
    27db:	01 52 04             	add    %edx,0x4(%rdx)
    27de:	fe                   	(bad)
    27df:	37                   	(bad)
    27e0:	8c 38                	mov    %?,(%rax)
    27e2:	02 77 38             	add    0x38(%rdi),%dh
    27e5:	04 d6                	add    $0xd6,%al
    27e7:	39 81 3a 02 77 38    	cmp    %eax,0x3877023a(%rcx)
    27ed:	00 04 eb             	add    %al,(%rbx,%rbp,8)
    27f0:	32 ce                	xor    %dh,%cl
    27f2:	37                   	(bad)
    27f3:	02 31                	add    (%rcx),%dh
    27f5:	9f                   	lahf
    27f6:	04 ef                	add    $0xef,%al
    27f8:	37                   	(bad)
    27f9:	8c 38                	mov    %?,(%rax)
    27fb:	02 31                	add    (%rcx),%dh
    27fd:	9f                   	lahf
    27fe:	04 d6                	add    $0xd6,%al
    2800:	39 81 3a 02 31 9f    	cmp    %eax,-0x60cefdc6(%rcx)
    2806:	00 04 eb             	add    %al,(%rbx,%rbp,8)
    2809:	32 ce                	xor    %dh,%cl
    280b:	37                   	(bad)
    280c:	03 77 d0             	add    -0x30(%rdi),%esi
    280f:	00 04 ef             	add    %al,(%rdi,%rbp,8)
    2812:	37                   	(bad)
    2813:	8c 38                	mov    %?,(%rax)
    2815:	03 77 d0             	add    -0x30(%rdi),%esi
    2818:	00 04 d6             	add    %al,(%rsi,%rdx,8)
    281b:	39 eb                	cmp    %ebp,%ebx
    281d:	39 03                	cmp    %eax,(%rbx)
    281f:	77 d0                	ja     27f1 <_license+0x757>
    2821:	00 04 eb             	add    %al,(%rbx,%rbp,8)
    2824:	39 fd                	cmp    %edi,%ebp
    2826:	39 01                	cmp    %eax,(%rcx)
    2828:	55                   	push   %rbp
    2829:	00 04 fd 32 df 33 02 	add    %al,0x233df32(,%rdi,8)
    2830:	30 9f 04 df 33 ce    	xor    %bl,-0x31cc20fc(%rdi)
    2836:	37                   	(bad)
    2837:	11 7c 00 10          	adc    %edi,0x10(%rax,%rax,1)
    283b:	ff 01                	incl   (%rcx)
    283d:	1a a8 ba 80 80 00    	sbb    0x8080ba(%rax),%ch
    2843:	a8 bf                	test   $0xbf,%al
    2845:	80 80 00 9f 04 ef 37 	addb   $0x37,-0x10fb6100(%rax)
    284c:	86 38                	xchg   %bh,(%rax)
    284e:	11 7c 00 10          	adc    %edi,0x10(%rax,%rax,1)
    2852:	ff 01                	incl   (%rcx)
    2854:	1a a8 ba 80 80 00    	sbb    0x8080ba(%rax),%ch
    285a:	a8 bf                	test   $0xbf,%al
    285c:	80 80 00 9f 00 04 fd 	addb   $0xfd,0x4009f00(%rax)
    2863:	32 ce                	xor    %dh,%cl
    2865:	37                   	(bad)
    2866:	02 30                	add    (%rax),%dh
    2868:	9f                   	lahf
    2869:	04 ef                	add    $0xef,%al
    286b:	37                   	(bad)
    286c:	8c 38                	mov    %?,(%rax)
    286e:	02 30                	add    (%rax),%dh
    2870:	9f                   	lahf
    2871:	04 d6                	add    $0xd6,%al
    2873:	39 81 3a 02 30 9f    	cmp    %eax,-0x60cffdc6(%rcx)
    2879:	00 04 fd 32 ce 37 02 	add    %al,0x237ce32(,%rdi,8)
    2880:	30 9f 04 ef 37 8c    	xor    %bl,-0x73c810fc(%rdi)
    2886:	38 02                	cmp    %al,(%rdx)
    2888:	30 9f 04 d6 39 dd    	xor    %bl,-0x22c629fc(%rdi)
    288e:	39 02                	cmp    %eax,(%rdx)
    2890:	30 9f 04 dd 39 e2    	xor    %bl,-0x1dc622fc(%rdi)
    2896:	39 01                	cmp    %eax,(%rcx)
    2898:	50                   	push   %rax
    2899:	00 04 fd 32 8e 33 02 	add    %al,0x2338e32(,%rdi,8)
    28a0:	30 9f 04 8e 33 9f    	xor    %bl,-0x60cc71fc(%rdi)
    28a6:	33 01                	xor    (%rcx),%eax
    28a8:	53                   	push   %rbx
    28a9:	00 04 97             	add    %al,(%rdi,%rdx,4)
    28ac:	33 dc                	xor    %esp,%ebx
    28ae:	33 01                	xor    (%rcx),%eax
    28b0:	53                   	push   %rbx
    28b1:	00 04 df             	add    %al,(%rdi,%rbx,8)
    28b4:	33 82 37 02 31 9f    	xor    -0x60cefdc9(%rdx),%eax
    28ba:	04 af                	add    $0xaf,%al
    28bc:	37                   	(bad)
    28bd:	ce                   	(bad)
    28be:	37                   	(bad)
    28bf:	02 31                	add    (%rcx),%dh
    28c1:	9f                   	lahf
    28c2:	00 04 be             	add    %al,(%rsi,%rdi,4)
    28c5:	34 c3                	xor    $0xc3,%al
    28c7:	34 01                	xor    $0x1,%al
    28c9:	53                   	push   %rbx
    28ca:	04 c5                	add    $0xc5,%al
    28cc:	34 d5                	xor    $0xd5,%al
    28ce:	34 0c                	xor    $0xc,%al
    28d0:	10 ff                	adc    %bh,%bh
    28d2:	81 b7 f5 fd ff ff ff 	xorl   $0x9f01ffff,-0x20b(%rdi)
    28d9:	ff 01 9f 
    28dc:	04 d5                	add    $0xd5,%al
    28de:	34 e0                	xor    $0xe0,%al
    28e0:	34 01                	xor    $0x1,%al
    28e2:	54                   	push   %rsp
    28e3:	04 e7                	add    $0xe7,%al
    28e5:	34 e9                	xor    $0xe9,%al
    28e7:	34 01                	xor    $0x1,%al
    28e9:	54                   	push   %rsp
    28ea:	04 e9                	add    $0xe9,%al
    28ec:	34 8a                	xor    $0x8a,%al
    28ee:	35 01 52 04 b9       	xor    $0xb9045201,%eax
    28f3:	35 e9 35 01 52       	xor    $0x520135e9,%eax
    28f8:	00 04 c0             	add    %al,(%rax,%rax,8)
    28fb:	34 c5                	xor    $0xc5,%al
    28fd:	34 01                	xor    $0x1,%al
    28ff:	51                   	push   %rcx
    2900:	04 e0                	add    $0xe0,%al
    2902:	34 f4                	xor    $0xf4,%al
    2904:	34 01                	xor    $0x1,%al
    2906:	53                   	push   %rbx
    2907:	04 f4                	add    $0xf4,%al
    2909:	34 93                	xor    $0x93,%al
    290b:	35 01 54 04 ad       	xor    $0xad045401,%eax
    2910:	35 e2 35 01 51       	xor    $0x510135e2,%eax
    2915:	00 04 c5 34 ea 36 03 	add    %al,0x336ea34(,%rax,8)
    291c:	77 08                	ja     2926 <_license+0x88c>
    291e:	9f                   	lahf
    291f:	00 04 c5 34 ea 36 02 	add    %al,0x236ea34(,%rax,8)
    2926:	31 9f 00 04 c5 34    	xor    %ebx,0x34c50400(%rdi)
    292c:	ea                   	(bad)
    292d:	36 04 10             	ss add $0x10,%al
    2930:	80 04 9f 00          	addb   $0x0,(%rdi,%rbx,4)
    2934:	04 c5                	add    $0xc5,%al
    2936:	34 cd                	xor    $0xcd,%al
    2938:	34 0c                	xor    $0xc,%al
    293a:	10 ff                	adc    %bh,%bh
    293c:	81 b7 f5 fd ff ff ff 	xorl   $0x9f01ffff,-0x20b(%rdi)
    2943:	ff 01 9f 
    2946:	04 cd                	add    $0xcd,%al
    2948:	34 de                	xor    $0xde,%al
    294a:	34 01                	xor    $0x1,%al
    294c:	51                   	push   %rcx
    294d:	04 de                	add    $0xde,%al
    294f:	34 ff                	xor    $0xff,%al
    2951:	34 01                	xor    $0x1,%al
    2953:	55                   	push   %rbp
    2954:	04 ff                	add    $0xff,%al
    2956:	34 e9                	xor    $0xe9,%al
    2958:	35 01 53 00 04       	xor    $0x4005301,%eax
    295d:	8c 35 ea 36 05 77    	mov    %?,0x770536ea(%rip)        # 7705604d <_license+0x77053fb3>
    2963:	08 23                	or     %ah,(%rbx)
    2965:	0c 9f                	or     $0x9f,%al
    2967:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    296a:	35 b2 36 01 52       	xor    $0x520136b2,%eax
    296f:	00 04 f4             	add    %al,(%rsp,%rsi,8)
    2972:	35 b9 36 01 54       	xor    $0x540136b9,%eax
    2977:	00 04 e9             	add    %al,(%rcx,%rbp,8)
    297a:	35 f4 35 02 30       	xor    $0x300235f4,%eax
    297f:	9f                   	lahf
    2980:	04 f4                	add    $0xf4,%al
    2982:	35 82 36 0c 10       	xor    $0x100c3682,%eax
    2987:	f7 81 b7 85 fe ff ff 	testl  $0x1ffffff,-0x17a49(%rcx)
    298e:	ff ff 01 
    2991:	9f                   	lahf
    2992:	04 82                	add    $0x82,%al
    2994:	36 d1 36             	ss shll (%rsi)
    2997:	01 51 00             	add    %edx,0x0(%rcx)
    299a:	04 d1                	add    $0xd1,%al
    299c:	36 f6 36             	ss divb (%rsi)
    299f:	01 51 00             	add    %edx,0x0(%rcx)
    29a2:	04 e2                	add    $0xe2,%al
    29a4:	36 ec                	ss in  (%dx),%al
    29a6:	36 01 52 04          	ss add %edx,0x4(%rdx)
    29aa:	fd                   	std
    29ab:	36 ce                	ss (bad)
    29ad:	37                   	(bad)
    29ae:	01 56 04             	add    %edx,0x4(%rsi)
    29b1:	ef                   	out    %eax,(%dx)
    29b2:	37                   	(bad)
    29b3:	8c 38                	mov    %?,(%rax)
    29b5:	01 56 04             	add    %edx,0x4(%rsi)
    29b8:	d6                   	(bad)
    29b9:	39 81 3a 01 56 00    	cmp    %eax,0x56013a(%rcx)
    29bf:	04 e2                	add    $0xe2,%al
    29c1:	36 ec                	ss in  (%dx),%al
    29c3:	36 01 52 00          	ss add %edx,0x0(%rdx)
    29c7:	04 e2                	add    $0xe2,%al
    29c9:	36 e8 36 02 30 9f    	ss call ffffffff9f302c05 <server_id_map+0x5ffffe260d7c05>
    29cf:	00 04 86             	add    %al,(%rsi,%rax,4)
    29d2:	37                   	(bad)
    29d3:	8c 37                	mov    %?,(%rdi)
    29d5:	02 30                	add    (%rax),%dh
    29d7:	9f                   	lahf
    29d8:	00 04 8e             	add    %al,(%rsi,%rcx,4)
    29db:	37                   	(bad)
    29dc:	9f                   	lahf
    29dd:	37                   	(bad)
    29de:	02 30                	add    (%rax),%dh
    29e0:	9f                   	lahf
    29e1:	04 9f                	add    $0x9f,%al
    29e3:	37                   	(bad)
    29e4:	a8 37                	test   $0x37,%al
    29e6:	01 50 00             	add    %edx,0x0(%rax)
    29e9:	04 a8                	add    $0xa8,%al
    29eb:	37                   	(bad)
    29ec:	af                   	scas   %es:(%rdi),%eax
    29ed:	37                   	(bad)
    29ee:	01 50 00             	add    %edx,0x0(%rax)
    29f1:	04 af                	add    $0xaf,%al
    29f3:	37                   	(bad)
    29f4:	c0 37 02             	shlb   $0x2,(%rdi)
    29f7:	30 9f 04 c0 37 c9    	xor    %bl,-0x36c83ffc(%rdi)
    29fd:	37                   	(bad)
    29fe:	01 50 00             	add    %edx,0x0(%rax)
    2a01:	04 c9                	add    $0xc9,%al
    2a03:	37                   	(bad)
    2a04:	ce                   	(bad)
    2a05:	37                   	(bad)
    2a06:	01 50 00             	add    %edx,0x0(%rax)
    2a09:	04 ac                	add    $0xac,%al
    2a0b:	38 c9                	cmp    %cl,%cl
    2a0d:	39 01                	cmp    %eax,(%rcx)
    2a0f:	50                   	push   %rax
    2a10:	00 04 b0             	add    %al,(%rax,%rsi,4)
    2a13:	38 d1                	cmp    %dl,%cl
    2a15:	38 01                	cmp    %al,(%rcx)
    2a17:	52                   	push   %rdx
    2a18:	00 04 b0             	add    %al,(%rax,%rsi,4)
    2a1b:	38 c9                	cmp    %cl,%cl
    2a1d:	39 01                	cmp    %eax,(%rcx)
    2a1f:	50                   	push   %rax
    2a20:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    2a23:	38 bd 38 01 51 00    	cmp    %bh,0x510138(%rbp)
    2a29:	04 b4                	add    $0xb4,%al
    2a2b:	38 c9                	cmp    %cl,%cl
    2a2d:	39 03                	cmp    %eax,(%rbx)
    2a2f:	70 28                	jo     2a59 <_license+0x9bf>
    2a31:	9f                   	lahf
    2a32:	00 04 fd 38 c9 39 03 	add    %al,0x339c938(,%rdi,8)
    2a39:	10 29                	adc    %ch,(%rcx)
    2a3b:	9f                   	lahf
    2a3c:	00 04 fd 38 81 39 0c 	add    %al,0xc398138(,%rdi,8)
    2a43:	31 9f 93 04 30 9f    	xor    %ebx,-0x60cffb6d(%rdi)
    2a49:	93                   	xchg   %eax,%ebx
    2a4a:	04 30                	add    $0x30,%al
    2a4c:	9f                   	lahf
    2a4d:	93                   	xchg   %eax,%ebx
    2a4e:	04 04                	add    $0x4,%al
    2a50:	81 39 c9 39 0f 31    	cmpl   $0x310f39c9,(%rcx)
    2a56:	9f                   	lahf
    2a57:	93                   	xchg   %eax,%ebx
    2a58:	04 30                	add    $0x30,%al
    2a5a:	9f                   	lahf
    2a5b:	93                   	xchg   %eax,%ebx
    2a5c:	04 30                	add    $0x30,%al
    2a5e:	9f                   	lahf
    2a5f:	93                   	xchg   %eax,%ebx
    2a60:	04 54                	add    $0x54,%al
    2a62:	93                   	xchg   %eax,%ebx
    2a63:	04 00                	add    $0x0,%al
    2a65:	04 85                	add    $0x85,%al
    2a67:	39 ab 39 01 5c 00    	cmp    %ebp,0x5c0139(%rbx)
    2a6d:	04 85                	add    $0x85,%al
    2a6f:	39 ab 39 01 5c 00    	cmp    %ebp,0x5c0139(%rbx)
    2a75:	04 89                	add    $0x89,%al
    2a77:	39 9d 39 01 52 00    	cmp    %ebx,0x520139(%rbp)
    2a7d:	04 e1                	add    $0xe1,%al
    2a7f:	3a ee                	cmp    %dh,%ch
    2a81:	3a 01                	cmp    (%rcx),%al
    2a83:	50                   	push   %rax
    2a84:	00 04 e1             	add    %al,(%rcx,%riz,8)
    2a87:	3a 80 3b 02 30 9f    	cmp    -0x60cffdc5(%rax),%al
    2a8d:	04 80                	add    $0x80,%al
    2a8f:	3b 89 3b 01 50 00    	cmp    0x50013b(%rcx),%ecx
    2a95:	04 e1                	add    $0xe1,%al
    2a97:	3a ee                	cmp    %dh,%ch
    2a99:	3a 01                	cmp    (%rcx),%al
    2a9b:	50                   	push   %rax
    2a9c:	00 04 89             	add    %al,(%rcx,%rcx,4)
    2a9f:	3b 95 3b 01 50 00    	cmp    0x50013b(%rbp),%edx
    2aa5:	04 82                	add    $0x82,%al
    2aa7:	3c 8a                	cmp    $0x8a,%al
    2aa9:	3c 03                	cmp    $0x3,%al
    2aab:	50                   	push   %rax
    2aac:	93                   	xchg   %eax,%ebx
    2aad:	04 04                	add    $0x4,%al
    2aaf:	8a 3c 99             	mov    (%rcx,%rbx,4),%bh
    2ab2:	3c 06                	cmp    $0x6,%al
    2ab4:	50                   	push   %rax
    2ab5:	93                   	xchg   %eax,%ebx
    2ab6:	04 51                	add    $0x51,%al
    2ab8:	93                   	xchg   %eax,%ebx
    2ab9:	01 04 83             	add    %eax,(%rbx,%rax,4)
    2abc:	3d b7 3d 06 50       	cmp    $0x50063db7,%eax
    2ac1:	93                   	xchg   %eax,%ebx
    2ac2:	04 51                	add    $0x51,%al
    2ac4:	93                   	xchg   %eax,%ebx
    2ac5:	01 04 b7             	add    %eax,(%rdi,%rsi,4)
    2ac8:	3d e2 3d 05 93       	cmp    $0x93053de2,%eax
    2acd:	04 51                	add    $0x51,%al
    2acf:	93                   	xchg   %eax,%ebx
    2ad0:	01 04 83             	add    %eax,(%rbx,%rax,4)
    2ad3:	3e 8a 3e             	ds mov (%rsi),%bh
    2ad6:	06                   	(bad)
    2ad7:	50                   	push   %rax
    2ad8:	93                   	xchg   %eax,%ebx
    2ad9:	04 51                	add    $0x51,%al
    2adb:	93                   	xchg   %eax,%ebx
    2adc:	01 04 8a             	add    %eax,(%rdx,%rcx,4)
    2adf:	3e 93                	ds xchg %eax,%ebx
    2ae1:	3e 05 93 04 51 93    	ds add $0x93510493,%eax
    2ae7:	01 00                	add    %eax,(%rax)
    2ae9:	04 8a                	add    $0x8a,%al
    2aeb:	3c 99                	cmp    $0x99,%al
    2aed:	3c 01                	cmp    $0x1,%al
    2aef:	56                   	push   %rsi
    2af0:	04 83                	add    $0x83,%al
    2af2:	3d 90 3d 01 56       	cmp    $0x56013d90,%eax
    2af7:	00 04 8a             	add    %al,(%rdx,%rcx,4)
    2afa:	3c 99                	cmp    $0x99,%al
    2afc:	3c 01                	cmp    $0x1,%al
    2afe:	51                   	push   %rcx
    2aff:	04 83                	add    $0x83,%al
    2b01:	3d 90 3d 01 51       	cmp    $0x51013d90,%eax
    2b06:	00 04 a0             	add    %al,(%rax,%riz,4)
    2b09:	3c f0                	cmp    $0xf0,%al
    2b0b:	3c 04                	cmp    $0x4,%al
    2b0d:	10 82 04 9f 04 d9    	adc    %al,-0x26fb60fc(%rdx)
    2b13:	3e eb 3e             	ds jmp 2b54 <_license+0xaba>
    2b16:	04 10                	add    $0x10,%al
    2b18:	82                   	(bad)
    2b19:	04 9f                	add    $0x9f,%al
    2b1b:	00 04 a0             	add    %al,(%rax,%riz,4)
    2b1e:	3c b1                	cmp    $0xb1,%al
    2b20:	3c 02                	cmp    $0x2,%al
    2b22:	30 9f 04 b1 3c ba    	xor    %bl,-0x45c34efc(%rdi)
    2b28:	3c 01                	cmp    $0x1,%al
    2b2a:	5e                   	pop    %rsi
    2b2b:	00 04 ba             	add    %al,(%rdx,%rdi,4)
    2b2e:	3c f0                	cmp    $0xf0,%al
    2b30:	3c 01                	cmp    $0x1,%al
    2b32:	5e                   	pop    %rsi
    2b33:	04 d9                	add    $0xd9,%al
    2b35:	3e eb 3e             	ds jmp 2b76 <_license+0xadc>
    2b38:	01 5e 00             	add    %ebx,0x0(%rsi)
    2b3b:	04 89                	add    $0x89,%al
    2b3d:	3d a1 3d 01 50       	cmp    $0x50013da1,%eax
    2b42:	04 a1                	add    $0xa1,%al
    2b44:	3d c1 3d 01 52       	cmp    $0x52013dc1,%eax
    2b49:	00 04 89             	add    %al,(%rcx,%rcx,4)
    2b4c:	3d 8e 3d 02 30       	cmp    $0x30023d8e,%eax
    2b51:	9f                   	lahf
    2b52:	00 04 ad 3d cd 3d 02 	add    %al,0x23dcd3d(,%rbp,4)
    2b59:	30 9f 04 cd 3d d2    	xor    %bl,-0x2dc232fc(%rdi)
    2b5f:	3d 01 5c 00 04       	cmp    $0x4005c01,%eax
    2b64:	ad                   	lods   %ds:(%rsi),%eax
    2b65:	3d c1 3d 01 52       	cmp    $0x52013dc1,%eax
    2b6a:	00 04 d2             	add    %al,(%rdx,%rdx,8)
    2b6d:	3d f7 3d 03 77       	cmp    $0x77033df7,%eax
    2b72:	08 9f 04 b7 3f 91    	or     %bl,-0x6ec048fc(%rdi)
    2b78:	40 03 77 08          	rex add 0x8(%rdi),%esi
    2b7c:	9f                   	lahf
    2b7d:	04 bc                	add    $0xbc,%al
    2b7f:	40 ff 40 03          	rex incl 0x3(%rax)
    2b83:	77 08                	ja     2b8d <_license+0xaf3>
    2b85:	9f                   	lahf
    2b86:	00 04 d7             	add    %al,(%rdi,%rdx,8)
    2b89:	3d e2 3d 01 55       	cmp    $0x55013de2,%eax
    2b8e:	04 e2                	add    $0xe2,%al
    2b90:	3d f7 3d 03 77       	cmp    $0x77033df7,%eax
    2b95:	d0 00                	rolb   (%rax)
    2b97:	04 b7                	add    $0xb7,%al
    2b99:	3f                   	(bad)
    2b9a:	91                   	xchg   %eax,%ecx
    2b9b:	40 03 77 d0          	rex add -0x30(%rdi),%esi
    2b9f:	00 04 bc             	add    %al,(%rsp,%rdi,4)
    2ba2:	40 ed                	rex in (%dx),%eax
    2ba4:	40 03 77 d0          	rex add -0x30(%rdi),%esi
    2ba8:	00 04 ed 40 ff 40 01 	add    %al,0x140ff40(,%rbp,8)
    2baf:	55                   	push   %rbp
    2bb0:	00 04 e2             	add    %al,(%rdx,%riz,8)
    2bb3:	3d f7 3d 01 50       	cmp    $0x50013df7,%eax
    2bb8:	04 b7                	add    $0xb7,%al
    2bba:	3f                   	(bad)
    2bbb:	c1 3f 01             	sarl   $0x1,(%rdi)
    2bbe:	50                   	push   %rax
    2bbf:	04 80                	add    $0x80,%al
    2bc1:	40 91                	rex xchg %eax,%ecx
    2bc3:	40 01 50 00          	rex add %edx,0x0(%rax)
    2bc7:	04 f7                	add    $0xf7,%al
    2bc9:	3d 83 3e 03 11       	cmp    $0x11033e83,%eax
    2bce:	01 9f 04 82 40 bc    	add    %ebx,-0x43bf7dfc(%rdi)
    2bd4:	40 03 11             	rex add (%rcx),%edx
    2bd7:	01 9f 04 ff 40 9a    	add    %ebx,-0x65bf00fc(%rdi)
    2bdd:	41 03 11             	add    (%r9),%edx
    2be0:	01 9f 00 04 a4 3e    	add    %ebx,0x3ea40400(%rdi)
    2be6:	c5 3e 02             	(bad)
    2be9:	30 9f 04 c5 3e ce    	xor    %bl,-0x31c13afc(%rdi)
    2bef:	3e 01 50 00          	ds add %edx,0x0(%rax)
    2bf3:	04 ce                	add    $0xce,%al
    2bf5:	3e d7                	xlat   %ds:(%rbx)
    2bf7:	3e 01 50 00          	ds add %edx,0x0(%rax)
    2bfb:	04 97                	add    $0x97,%al
    2bfd:	3f                   	(bad)
    2bfe:	9c                   	pushf
    2bff:	3f                   	(bad)
    2c00:	04 77                	add    $0x77,%al
    2c02:	c0 00 9f             	rolb   $0x9f,(%rax)
    2c05:	00 04 b2             	add    %al,(%rdx,%rsi,4)
    2c08:	3f                   	(bad)
    2c09:	b7 3f                	mov    $0x3f,%bh
    2c0b:	01 5f 00             	add    %ebx,0x0(%rdi)
    2c0e:	04 b7                	add    $0xb7,%al
    2c10:	3f                   	(bad)
    2c11:	80 40 04 10          	addb   $0x10,0x4(%rax)
    2c15:	82                   	(bad)
    2c16:	04 9f                	add    $0x9f,%al
    2c18:	04 bc                	add    $0xbc,%al
    2c1a:	40 ce                	rex (bad)
    2c1c:	40 04 10             	rex add $0x10,%al
    2c1f:	82                   	(bad)
    2c20:	04 9f                	add    $0x9f,%al
    2c22:	00 04 b7             	add    %al,(%rdi,%rsi,4)
    2c25:	3f                   	(bad)
    2c26:	c8 3f 02 30          	enter  $0x23f,$0x30
    2c2a:	9f                   	lahf
    2c2b:	04 c8                	add    $0xc8,%al
    2c2d:	3f                   	(bad)
    2c2e:	d1 3f                	sarl   (%rdi)
    2c30:	01 53 00             	add    %edx,0x0(%rbx)
    2c33:	04 d1                	add    $0xd1,%al
    2c35:	3f                   	(bad)
    2c36:	80 40 01 53          	addb   $0x53,0x1(%rax)
    2c3a:	04 bc                	add    $0xbc,%al
    2c3c:	40 ce                	rex (bad)
    2c3e:	40 01 53 00          	rex add %edx,0x0(%rbx)
    2c42:	04 87                	add    $0x87,%al
    2c44:	40 a8 40             	rex test $0x40,%al
    2c47:	02 30                	add    (%rax),%dh
    2c49:	9f                   	lahf
    2c4a:	04 a8                	add    $0xa8,%al
    2c4c:	40 b1 40             	rex mov $0x40,%cl
    2c4f:	01 50 00             	add    %edx,0x0(%rax)
    2c52:	04 b1                	add    $0xb1,%al
    2c54:	40 ba 40 01 50 00    	rex mov $0x500140,%edx
    2c5a:	04 fa                	add    $0xfa,%al
    2c5c:	40 ff 40 04          	rex incl 0x4(%rax)
    2c60:	77 c0                	ja     2c22 <_license+0xb88>
    2c62:	00 9f 00 04 95 41    	add    %bl,0x41950400(%rdi)
    2c68:	9a                   	(bad)
    2c69:	41 01 5f 00          	add    %ebx,0x0(%r15)

Disassembly of section .debug_abbrev:

0000000000000000 <.debug_abbrev>:
  void* data = (void*)(long)ctx->data;
   0:	01 11                	add    %edx,(%rcx)
   2:	01 25 25 13 05 03    	add    %esp,0x3051325(%rip)        # 305132d <_license+0x304f293>
   8:	25 72 17 10 17       	and    $0x17101772,%eax
   d:	1b 25 11 1b 12 06    	sbb    0x6121b11(%rip),%esp        # 6121b24 <_license+0x611fa8a>
  13:	73 17                	jae    2c <balancer_ingress+0x2c>
  15:	74 17                	je     2e <balancer_ingress+0x2e>
  17:	8c 01                	mov    %es,(%rcx)
  void* data_end = (void*)(long)ctx->data_end;
  19:	17                   	(bad)
  1a:	00 00                	add    %al,(%rax)
  if (data + nh_off > data_end) {
  1c:	02 24 00             	add    (%rax,%rax,1),%ah
  1f:	03 26                	add    (%rsi),%esp
  21:	3e 0b 0b             	ds or  (%rbx),%ecx
  24:	0b 00                	or     (%rax),%eax
  26:	00 03                	add    %al,(%rbx)
  28:	34 00                	xor    $0x0,%al
  2a:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f1379 <_license+0x193ef2df>
  30:	3a 0b                	cmp    (%rbx),%cl
  eth_proto = eth->h_proto;
  32:	3b 05 02 18 00 00    	cmp    0x1802(%rip),%eax        # 183a <balancer_ingress+0x183a>
  if (eth_proto == BE_ETH_P_IP) {
  38:	04 01                	add    $0x1,%al
  3a:	01 49 13             	add    %ecx,0x13(%rcx)
  3d:	00 00                	add    %al,(%rax)
  3f:	05 21 00 49 13       	add    $0x13490021,%eax
  44:	37                   	(bad)
  45:	0b 00                	or     (%rax),%eax
  47:	00 06                	add    %al,(%rsi)
  49:	24 00                	and    $0x0,%al
  4b:	03 25 3e 0b 0b 0b    	add    0xb0b0b3e(%rip),%esp        # b0b0b8f <_license+0xb0aeaf5>
  struct packet_description pckt = {};
  51:	00 00                	add    %al,(%rax)
  53:	07                   	(bad)
  54:	24 00                	and    $0x0,%al
  56:	03 25 0b 0b 3e 0b    	add    0xb3e0b0b(%rip),%esp        # b3e0b67 <_license+0xb3deacd>
  5c:	00 00                	add    %al,(%rax)
  5e:	08 34 00             	or     %dh,(%rax,%rax,1)
  61:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f13b0 <_license+0x193ef316>
  67:	3a 0b                	cmp    (%rbx),%cl
  69:	3b 0b                	cmp    (%rbx),%ecx
  6b:	02 18                	add    (%rax),%bl
  6d:	00 00                	add    %al,(%rax)
  6f:	09 13                	or     %edx,(%rbx)
  71:	01 0b                	add    %ecx,(%rbx)
  73:	0b 3a                	or     (%rdx),%edi
  75:	0b 3b                	or     (%rbx),%edi
  77:	0b 00                	or     (%rax),%eax
  79:	00 0a                	add    %cl,(%rdx)
  7b:	0d 00 03 25 49       	or     $0x49250300,%eax
  80:	13 3a                	adc    (%rdx),%edi
  82:	0b 3b                	or     (%rbx),%edi
  84:	0b 38                	or     (%rax),%edi
  86:	0b 00                	or     (%rax),%eax
  88:	00 0b                	add    %cl,(%rbx)
  8a:	0f 00 49 13          	str    0x13(%rcx)
  bpf_tail_call(xdp, &subprograms, 0);
  8e:	00 00                	add    %al,(%rax)
  90:	0c 16                	or     $0x16,%al
  92:	00 49 13             	add    %cl,0x13(%rcx)
  95:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0bd5 <_license+0xb3aeb3b>
  9b:	00 00                	add    %al,(%rax)
  9d:	0d 13 01 03 25       	or     $0x25030113,%eax
  a2:	0b 0b                	or     (%rbx),%ecx
  a4:	3a 0b                	cmp    (%rbx),%cl
  struct packet_description pckt = {};
  a6:	3b 0b                	cmp    (%rbx),%ecx
  a8:	00 00                	add    %al,(%rax)
  aa:	0e                   	(bad)
  ab:	0d 00 49 13 3a       	or     $0x3a134900,%eax
  b0:	0b 3b                	or     (%rbx),%edi
  b2:	0b 38                	or     (%rax),%edi
  b4:	0b 00                	or     (%rax),%eax
  b6:	00 0f                	add    %cl,(%rdi)
  b8:	17                   	(bad)
  b9:	01 0b                	add    %ecx,(%rbx)
  bb:	0b 3a                	or     (%rdx),%edi
  bd:	0b 3b                	or     (%rbx),%edi
  bf:	0b 00                	or     (%rax),%eax
  c1:	00 10                	add    %dl,(%rax)
  c3:	21 00                	and    %eax,(%rax)
  c5:	49 13 37             	adc    (%r15),%rsi
  c8:	05 00 00 11 21       	add    $0x21110000,%eax
  cd:	00 49 13             	add    %cl,0x13(%rcx)
  d0:	00 00                	add    %al,(%rax)
  d2:	12 21                	adc    (%rcx),%ah
  d4:	00 49 13             	add    %cl,0x13(%rcx)
  d7:	37                   	(bad)
  d8:	06                   	(bad)
  d9:	00 00                	add    %al,(%rax)
  db:	13 34 00             	adc    (%rax,%rax,1),%esi
  de:	03 25 49 13 3a 0b    	add    0xb3a1349(%rip),%esp        # b3a142d <_license+0xb39f393>
  e4:	3b 0b                	cmp    (%rbx),%ecx
  bpf_tail_call(xdp, &subprograms, 0);
  e6:	00 00                	add    %al,(%rax)
  e8:	14 15                	adc    $0x15,%al
  ea:	00 49 13             	add    %cl,0x13(%rcx)
  ed:	27                   	(bad)
  ee:	19 00                	sbb    %eax,(%rax)
  f0:	00 15 15 01 49 13    	add    %dl,0x13490115(%rip)        # 1349020b <_license+0x1348e171>
  f6:	27                   	(bad)
  f7:	19 00                	sbb    %eax,(%rax)
  f9:	00 16                	add    %dl,(%rsi)
  fb:	05 00 49 13 00       	add    $0x134900,%eax
 100:	00 17                	add    %dl,(%rdi)
  struct vip_definition vip = {};
 102:	0f 00 00             	sldt   (%rax)
 105:	00 18                	add    %bl,(%rax)
 107:	04 01                	add    $0x1,%al
 109:	49 13 03             	adc    (%r11),%rax
 10c:	25 0b 0b 3a 0b       	and    $0xb3a0b0b,%eax
 111:	3b 05 00 00 19 28    	cmp    0x28190000(%rip),%eax        # 28190117 <_license+0x2818e07d>
 117:	00 03                	add    %al,(%rbx)
 119:	25 1c 0f 00 00       	and    $0xf1c,%eax
    if (iph + 1 > data_end) {
 11e:	1a 04 01             	sbb    (%rcx,%rax,1),%al
 121:	49 13 0b             	adc    (%r11),%rcx
 124:	0b 3a                	or     (%rdx),%edi
 126:	0b 3b                	or     (%rbx),%edi
 128:	0b 00                	or     (%rax),%eax
    if (iph->ihl != 5) {
 12a:	00 1b                	add    %bl,(%rbx)
 12c:	13 01                	adc    (%rcx),%eax
 12e:	03 25 0b 0b 3a 0b    	add    0xb3a0b0b(%rip),%esp        # b3a0c3f <_license+0xb39eba5>
 134:	3b 05 00 00 1c 0d    	cmp    0xd1c0000(%rip),%eax        # d1c013a <_license+0xd1be0a0>
    pckt->tos = iph->tos;
 13a:	00 03                	add    %al,(%rbx)
    *protocol = iph->protocol;
 13c:	25 49 13 3a 0b       	and    $0xb3a1349,%eax
    pckt->flow.proto = *protocol;
 141:	3b 05 38 0b 00 00    	cmp    0xb38(%rip),%eax        # c7f <balancer_ingress+0xc7f>
    if (iph->frag_off & PCKT_FRAGMENTED) {
 147:	1d 13 00 03 25       	sbb    $0x25030013,%eax
 14c:	3c 19                	cmp    $0x19,%al
 14e:	00 00                	add    %al,(%rax)
 150:	1e                   	(bad)
 151:	2e 01 03             	cs add %eax,(%rbx)
 154:	25 3a 0b 3b 05       	and    $0x53b0b3a,%eax
    if (*protocol == IPPROTO_ICMP) {
 159:	27                   	(bad)
 15a:	19 49 13             	sbb    %ecx,0x13(%rcx)
 15d:	20 21                	and    %ah,(%rcx)
  if (icmp_hdr + 1 > data_end) {
 15f:	01 00                	add    %eax,(%rax)
 161:	00 1f                	add    %bl,(%rdi)
 163:	05 00 03 25 3a       	add    $0x3a250300,%eax
 168:	0b 3b                	or     (%rbx),%edi
 16a:	05 49 13 00 00       	add    $0x1349,%eax
  if (icmp_hdr->type == ICMP_ECHO) {
 16f:	20 34 00             	and    %dh,(%rax,%rax,1)
 172:	03 25 3a 0b 3b 05    	add    0x53b0b3a(%rip),%esp        # 53b0cb2 <_license+0x53aec18>
 178:	49 13 00             	adc    (%r8),%rax
 17b:	00 21                	add    %ah,(%rcx)
 17d:	0b 01                	or     (%rcx),%eax
 17f:	00 00                	add    %al,(%rax)
 181:	22 26                	and    (%rsi),%ah
 183:	00 49 13             	add    %cl,0x13(%rcx)
 186:	00 00                	add    %al,(%rax)
 188:	23 0d 00 03 25 49    	and    0x49250300(%rip),%ecx        # 4925048e <_license+0x4924e3f4>
  icmp_hdr->type = ICMP_ECHOREPLY;
 18e:	13 3a                	adc    (%rdx),%edi
  icmp_hdr->checksum += 0x0008;
 190:	0b 3b                	or     (%rbx),%edi
 192:	0b 0b                	or     (%rbx),%ecx
  iph->ttl = DEFAULT_TTL;
 194:	0b 0d 0b 0c 0b 38    	or     0x380b0c0b(%rip),%ecx        # 380b0da5 <_license+0x380aed0b>
  iph->daddr = iph->saddr;
 19a:	0b 00                	or     (%rax),%eax
  tmp_addr = iph->daddr;
 19c:	00 24 2e             	add    %ah,(%rsi,%rbp,1)
  iph->daddr = iph->saddr;
 19f:	01 03                	add    %eax,(%rbx)
  iph->saddr = tmp_addr;
 1a1:	25 3a 0b 3b 0b       	and    $0xb3b0b3a,%eax
 1a6:	27                   	(bad)
 1a7:	19 49 13             	sbb    %ecx,0x13(%rcx)
 1aa:	20 21                	and    %ah,(%rcx)
 1ac:	01 00                	add    %eax,(%rax)
 1ae:	00 25 05 00 03 25    	add    %ah,0x25030005(%rip)        # 250301b9 <_license+0x2502e11f>
 1b4:	3a 0b                	cmp    (%rbx),%cl
 1b6:	3b 0b                	cmp    (%rbx),%ecx
 1b8:	49 13 00             	adc    (%r8),%rax
 1bb:	00 26                	add    %ah,(%rsi)
 1bd:	34 00                	xor    $0x0,%al
 1bf:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0cff <_license+0xb3aec65>
 1c5:	49 13 00             	adc    (%r8),%rax
 1c8:	00 27                	add    %ah,(%rdi)
 1ca:	2e 01 03             	cs add %eax,(%rbx)
 1cd:	25 3a 0b 3b 0b       	and    $0xb3b0b3a,%eax
 1d2:	27                   	(bad)
 1d3:	19 20                	sbb    %esp,(%rax)
 1d5:	21 01                	and    %eax,(%rcx)
 1d7:	00 00                	add    %al,(%rax)
 1d9:	28 34 00             	sub    %dh,(%rax,%rax,1)
 1dc:	03 26                	add    (%rsi),%esp
 1de:	3a 0b                	cmp    (%rbx),%cl
 1e0:	3b 0b                	cmp    (%rbx),%ecx
 1e2:	49 13 00             	adc    (%r8),%rax
 1e5:	00 29                	add    %ch,(%rcx)
 1e7:	13 01                	adc    (%rcx),%eax
 1e9:	03 26                	add    (%rsi),%esp
 1eb:	0b 0b                	or     (%rbx),%ecx
 1ed:	3a 0b                	cmp    (%rbx),%cl
 1ef:	3b 0b                	cmp    (%rbx),%ecx
 1f1:	00 00                	add    %al,(%rax)
 1f3:	2a 0d 00 03 26 49    	sub    0x49260300(%rip),%cl        # 492604f9 <_license+0x4925e45f>
    if (ip6h + 1 > data_end) {
 1f9:	13 3a                	adc    (%rdx),%edi
 1fb:	0b 3b                	or     (%rbx),%edi
 1fd:	0b 0b                	or     (%rbx),%ecx
 1ff:	0b 0d 0b 0c 0b 38    	or     0x380b0c0b(%rip),%ecx        # 380b0e10 <_license+0x380aed76>
    *protocol = ip6h->nexthdr;
 205:	0b 00                	or     (%rax),%eax
    pckt->flow.proto = *protocol;
 207:	00 2b                	add    %ch,(%rbx)
 209:	0d 00 03 26 49       	or     $0x49260300,%eax
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 20e:	13 3a                	adc    (%rdx),%edi
 210:	0b 3b                	or     (%rbx),%edi
 212:	0b 38                	or     (%rax),%edi
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 214:	0b 00                	or     (%rax),%eax
 216:	00 2c 2e             	add    %ch,(%rsi,%rbp,1)
 219:	01 03                	add    %eax,(%rbx)
 21b:	26 3a 0b             	es cmp (%rbx),%cl
 21e:	3b 0b                	cmp    (%rbx),%ecx
    if (*protocol == IPPROTO_FRAGMENT) {
 220:	27                   	(bad)
 221:	19 49 13             	sbb    %ecx,0x13(%rcx)
 224:	20 21                	and    %ah,(%rcx)
 226:	01 00                	add    %eax,(%rax)
 228:	00 2d 2e 01 03 26    	add    %ch,0x2603012e(%rip)        # 2603035c <_license+0x2602e2c2>
 22e:	3a 0b                	cmp    (%rbx),%cl
 230:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491b5d <_license+0x1348fac3>
  if (icmp_hdr + 1 > data_end) {
 236:	20 21                	and    %ah,(%rcx)
 238:	01 00                	add    %eax,(%rax)
 23a:	00 2e                	add    %ch,(%rsi)
 23c:	05 00 03 26 3a       	add    $0x3a260300,%eax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 241:	0b 3b                	or     (%rbx),%edi
 243:	05 49 13 00 00       	add    $0x1349,%eax
 248:	2f                   	(bad)
 249:	34 00                	xor    $0x0,%al
 24b:	03 26                	add    (%rsi),%esp
 24d:	3a 0b                	cmp    (%rbx),%cl
 24f:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 159e <balancer_ingress+0x159e>
 255:	30 2e                	xor    %ch,(%rsi)
 257:	01 03                	add    %eax,(%rbx)
 259:	26 3a 0b             	es cmp (%rbx),%cl
 25c:	3b 0b                	cmp    (%rbx),%ecx
 25e:	27                   	(bad)
 25f:	19 20                	sbb    %esp,(%rax)
 261:	21 01                	and    %eax,(%rcx)
 263:	00 00                	add    %al,(%rax)
 265:	31 05 00 03 26 3a    	xor    %eax,0x3a260300(%rip)        # 3a26056b <_license+0x3a25e4d1>
 26b:	0b 3b                	or     (%rbx),%edi
 26d:	0b 49 13             	or     0x13(%rcx),%ecx
 270:	00 00                	add    %al,(%rax)
 272:	32 2e                	xor    (%rsi),%ch
 274:	01 03                	add    %eax,(%rbx)
 276:	26 3a 0b             	es cmp (%rbx),%cl
 279:	3b 05 27 19 20 21    	cmp    0x21201927(%rip),%eax        # 21201ba6 <_license+0x211ffb0c>
 27f:	01 00                	add    %eax,(%rax)
 281:	00 33                	add    %dh,(%rbx)
 283:	2e 01 03             	cs add %eax,(%rbx)
 286:	26 3a 0b             	es cmp (%rbx),%cl
 289:	3b 0b                	cmp    (%rbx),%ecx
 28b:	20 21                	and    %ah,(%rcx)
 28d:	01 00                	add    %eax,(%rax)
 28f:	00 34 26             	add    %dh,(%rsi,%riz,1)
 292:	00 00                	add    %al,(%rax)
 294:	00 35 2e 01 11 1b    	add    %dh,0x1b11012e(%rip)        # 1b1103c8 <_license+0x1b10e32e>
 29a:	12 06                	adc    (%rsi),%al
 29c:	40 18 7a 19          	sbb    %dil,0x19(%rdx)
 2a0:	03 26                	add    (%rsi),%esp
 2a2:	3a 0b                	cmp    (%rbx),%cl
 2a4:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491bd1 <_license+0x1348fb37>
 2aa:	3f                   	(bad)
 2ab:	19 00                	sbb    %eax,(%rax)
 2ad:	00 36                	add    %dh,(%rsi)
 2af:	05 00 02 22 03       	add    $0x3220200,%eax
 2b4:	26 3a 0b             	es cmp (%rbx),%cl
 2b7:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 1606 <balancer_ingress+0x1606>
 2bd:	37                   	(bad)
 2be:	34 00                	xor    $0x0,%al
 2c0:	02 22                	add    (%rdx),%ah
 2c2:	03 25 3a 0b 3b 05    	add    0x53b0b3a(%rip),%esp        # 53b0e02 <_license+0x53aed68>
 2c8:	49 13 00             	adc    (%r8),%rax
 2cb:	00 38                	add    %bh,(%rax)
 2cd:	34 00                	xor    $0x0,%al
 2cf:	02 22                	add    (%rdx),%ah
 2d1:	03 26                	add    (%rsi),%esp
 2d3:	3a 0b                	cmp    (%rbx),%cl
 2d5:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 1624 <balancer_ingress+0x1624>
 2db:	39 1d 01 31 13 55    	cmp    %ebx,0x55133101(%rip)        # 551333e2 <_license+0x55131348>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2e1:	23 58 0b             	and    0xb(%rax),%ebx
 2e4:	59                   	pop    %rcx
 2e5:	05 57 0b 00 00       	add    $0xb57,%eax
 2ea:	3a 05 00 02 22 31    	cmp    0x31220200(%rip),%al        # 312204f0 <_license+0x3121e456>
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2f0:	13 00                	adc    (%rax),%eax
 2f2:	00 3b                	add    %bh,(%rbx)
 2f4:	34 00                	xor    $0x0,%al
 2f6:	02 18                	add    (%rax),%bl
 2f8:	31 13                	xor    %edx,(%rbx)
 2fa:	00 00                	add    %al,(%rax)
 2fc:	3c 34                	cmp    $0x34,%al
 2fe:	00 02                	add    %al,(%rdx)
  if (protocol == IPPROTO_ICMPV6) {
 300:	22 31                	and    (%rcx),%dh
 302:	13 00                	adc    (%rax),%eax
 304:	00 3d 0b 01 11 1b    	add    %bh,0x1b11010b(%rip)        # 1b110415 <_license+0x1b10e37b>
  if (icmp_hdr + 1 > data_end) {
 30a:	12 06                	adc    (%rsi),%al
 30c:	00 00                	add    %al,(%rax)
 30e:	3e 1d 01 31 13 11    	ds sbb $0x11133101,%eax
 314:	1b 12                	sbb    (%rdx),%edx
  if (icmp_hdr->type == ICMP_ECHO) {
 316:	06                   	(bad)
 317:	58                   	pop    %rax
 318:	0b 59 05             	or     0x5(%rcx),%ebx
 31b:	57                   	push   %rdi
 31c:	0b 00                	or     (%rax),%eax
 31e:	00 3f                	add    %bh,(%rdi)
 320:	05 00 02 18 31       	add    $0x31180200,%eax
 325:	13 00                	adc    (%rax),%eax
 327:	00 40 34             	add    %al,0x34(%rax)
 32a:	00 1c 0f             	add    %bl,(%rdi,%rcx,1)
 32d:	31 13                	xor    %edx,(%rbx)
 32f:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 331:	41 1d 01 31 13 11    	rex.B sbb $0x11133101,%eax
 337:	1b 12                	sbb    (%rdx),%edx
       sizeof(struct icmphdr)) > data_end) {
 339:	06                   	(bad)
 33a:	58                   	pop    %rax
 33b:	0b 59 0b             	or     0xb(%rcx),%ebx
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 33e:	57                   	push   %rdi
 33f:	0b 00                	or     (%rax),%eax
 341:	00 42 34             	add    %al,0x34(%rdx)
  icmp_hdr->type = ICMP_ECHOREPLY;
 344:	00 1c 0d 31 13 00 00 	add    %bl,0x1331(,%rcx,1)
  iph->ttl = DEFAULT_TTL;
 34b:	43 1d 00 31 13 11    	rex.XB sbb $0x11133100,%eax
  iph->daddr = iph->saddr;
 351:	1b 12                	sbb    (%rdx),%edx
  tmp_addr = iph->daddr;
 353:	06                   	(bad)
 354:	58                   	pop    %rax
  iph->daddr = iph->saddr;
 355:	0b 59 05             	or     0x5(%rcx),%ebx
  iph->saddr = tmp_addr;
 358:	57                   	push   %rdi
 359:	0b 00                	or     (%rax),%eax
 35b:	00 44 0b 01          	add    %al,0x1(%rbx,%rcx,1)
 35f:	55                   	push   %rbp
 360:	23 00                	and    (%rax),%eax
 362:	00 45 05             	add    %al,0x5(%rbp)
 365:	00 31                	add    %dh,(%rcx)
 367:	13 00                	adc    (%rax),%eax
 369:	00 46 05             	add    %al,0x5(%rsi)
 36c:	00 1c 0f             	add    %bl,(%rdi,%rcx,1)
 36f:	31 13                	xor    %edx,(%rbx)
 371:	00 00                	add    %al,(%rax)
 373:	47 1d 01 31 13 55    	rex.RXB sbb $0x55133101,%eax
 379:	23 58 0b             	and    0xb(%rax),%ebx
 37c:	59                   	pop    %rcx
 37d:	0b 57 0b             	or     0xb(%rdi),%edx
 380:	00 00                	add    %al,(%rax)
 382:	48 1d 00 31 13 11    	sbb    $0x11133100,%rax
 388:	1b 12                	sbb    (%rdx),%edx
 38a:	06                   	(bad)
 38b:	58                   	pop    %rax
 38c:	0b 59 0b             	or     0xb(%rcx),%ebx
 38f:	57                   	push   %rdi
 390:	0b 00                	or     (%rax),%eax
 392:	00 49 48             	add    %cl,0x48(%rcx)
 395:	01 83 01 18 7d 1b    	add    %eax,0x1b7d1801(%rbx)
 39b:	00 00                	add    %al,(%rax)
 39d:	4a                   	rex.WX
 39e:	49 00 02             	rex.WB add %al,(%r10)
 3a1:	18 7e 18             	sbb    %bh,0x18(%rsi)
 3a4:	00 00                	add    %al,(%rax)
 3a6:	4b                   	rex.WXB
 3a7:	48 00 83 01 18 7d 1b 	rex.W add %al,0x1b7d1801(%rbx)
 3ae:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_info:

0000000000000000 <.debug_info>:
  void* data = (void*)(long)ctx->data;
       0:	0e                   	(bad)
       1:	42 00 00             	rex.X add %al,(%rax)
       4:	05 00 01 08 00       	add    $0x80100,%eax
       9:	00 00                	add    %al,(%rax)
       b:	00 01                	add    %al,(%rcx)
       d:	00 0c 00             	add    %cl,(%rax,%rax,1)
      10:	01 08                	add    %ecx,(%rax)
      12:	00 00                	add    %al,(%rax)
      14:	00 00                	add    %al,(%rax)
      16:	00 00                	add    %al,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
      18:	00 02                	add    %al,(%rdx)
      1a:	14 9a                	adc    $0x9a,%al
  if (data + nh_off > data_end) {
      1c:	20 00                	and    %al,(%rax)
      1e:	00 08                	add    %cl,(%rax)
      20:	00 00                	add    %al,(%rax)
      22:	00 0c 00             	add    %cl,(%rax,%rax,1)
      25:	00 00                	add    %al,(%rax)
      27:	0c 00                	or     $0x0,%al
      29:	00 00                	add    %al,(%rax)
      2b:	02 6f 01             	add    0x1(%rdi),%ch
      2e:	07                   	(bad)
      2f:	02 02                	add    (%rdx),%al
  eth_proto = eth->h_proto;
      31:	6e                   	outsb  %ds:(%rsi),(%dx)
      32:	01 07                	add    %eax,(%rdi)
      34:	04 02                	add    $0x2,%al
  if (eth_proto == BE_ETH_P_IP) {
      36:	6d                   	insl   (%dx),%es:(%rdi)
      37:	01 07                	add    %eax,(%rdi)
      39:	08 02                	or     %al,(%rdx)
      3b:	6c                   	insb   (%dx),%es:(%rdi)
      3c:	01 07                	add    %eax,(%rdi)
      3e:	01 02                	add    %eax,(%rdx)
      40:	6b 01 07             	imul   $0x7,(%rcx),%eax
      43:	01 03                	add    %eax,(%rbx)
      45:	03 50 00             	add    0x0(%rax),%edx
      48:	00 00                	add    %al,(%rax)
      4a:	00 4f 04             	add    %cl,0x4(%rdi)
  struct packet_description pckt = {};
      4d:	02 a1 00 04 5c 00    	add    0x5c0400(%rcx),%ah
      53:	00 00                	add    %al,(%rax)
      55:	05 60 00 00 00       	add    $0x60,%eax
      5a:	04 00                	add    $0x0,%al
      5c:	06                   	(bad)
      5d:	04 06                	add    $0x6,%al
      5f:	01 07                	add    %eax,(%rdi)
      61:	05 08 07 08 06       	add    $0x6080708,%eax
      66:	6f                   	outsl  %ds:(%rsi),(%dx)
      67:	00 00                	add    %al,(%rax)
      69:	00 01                	add    %al,(%rcx)
      6b:	29 02                	sub    %eax,(%rdx)
      6d:	a1 01 09 28 01 23 0a 	movabs 0xa1070a2301280901,%eax
      74:	07 a1 
      76:	00 00                	add    %al,(%rax)
      78:	00 01                	add    %al,(%rcx)
      7a:	24 00                	and    $0x0,%al
      7c:	0a 09                	or     (%rcx),%cl
      7e:	b6 00                	mov    $0x0,%dh
      80:	00 00                	add    %al,(%rax)
      82:	01 25 08 0a 0c c7    	add    %esp,-0x38f3f5f8(%rip)        # ffffffffc70c0a90 <server_id_map+0x5ffffe4de95a90>
      88:	00 00                	add    %al,(%rax)
      8a:	00 01                	add    %al,(%rcx)
  bpf_tail_call(xdp, &subprograms, 0);
      8c:	26 10 0a             	es adc %cl,(%rdx)
      8f:	14 1e                	adc    $0x1e,%al
      91:	01 00                	add    %eax,(%rax)
      93:	00 01                	add    %al,(%rcx)
      95:	27                   	(bad)
      96:	18 0a                	sbb    %cl,(%rdx)
      98:	15 2f 01 00 00       	adc    $0x12f,%eax
      9d:	01 28                	add    %ebp,(%rax)
      9f:	20 00                	and    %al,(%rax)
      a1:	0b a6 00 00 00 04    	or     0x4000000(%rsi),%esp
  struct packet_description pckt = {};
      a7:	b2 00                	mov    $0x0,%dl
      a9:	00 00                	add    %al,(%rax)
      ab:	05 60 00 00 00       	add    $0x60,%eax
      b0:	02 00                	add    (%rax),%al
      b2:	06                   	(bad)
      b3:	08 05 04 0b bb 00    	or     %al,0xbb0b04(%rip)        # bb0bbd <_license+0xbaeb23>
      b9:	00 00                	add    %al,(%rax)
      bb:	0c c3                	or     $0xc3,%al
      bd:	00 00                	add    %al,(%rax)
      bf:	00 0b                	add    %cl,(%rbx)
      c1:	02 1b                	add    (%rbx),%bl
      c3:	06                   	(bad)
      c4:	0a 07                	or     (%rdi),%al
      c6:	04 0b                	add    $0xb,%al
      c8:	cc                   	int3
      c9:	00 00                	add    %al,(%rax)
      cb:	00 0d 13 08 03 35    	add    %cl,0x35030813(%rip)        # 350308e4 <_license+0x3502e84a>
      d1:	0e                   	(bad)
      d2:	d9 00                	flds   (%rax)
      d4:	00 00                	add    %al,(%rax)
      d6:	03 36                	add    (%rsi),%esi
      d8:	00 0f                	add    %cl,(%rdi)
      da:	08 03                	or     %al,(%rbx)
      dc:	36 0a 0c fa          	ss or  (%rdx,%rdi,8),%cl
      e0:	00 00                	add    %al,(%rax)
      e2:	00 03                	add    %al,(%rbx)
      e4:	37                   	(bad)
  bpf_tail_call(xdp, &subprograms, 0);
      e5:	00 0a                	add    %cl,(%rdx)
      e7:	0f bb 00             	btc    %eax,(%rax)
      ea:	00 00                	add    %al,(%rax)
      ec:	03 38                	add    (%rax),%edi
      ee:	00 0a                	add    %cl,(%rdx)
      f0:	10 06                	adc    %al,(%rsi)
      f2:	01 00                	add    %eax,(%rax)
      f4:	00 03                	add    %al,(%rbx)
      f6:	39 00                	cmp    %eax,(%rax)
      f8:	00 00                	add    %al,(%rax)
      fa:	0c 02                	or     $0x2,%al
      fc:	01 00                	add    %eax,(%rax)
      fe:	00 0e                	add    %cl,(%rsi)
     100:	02 1f                	add    (%rdi),%bl
  struct vip_definition vip = {};
     102:	06                   	(bad)
     103:	0d 07 08 04 12       	or     $0x12040807,%eax
     108:	01 00                	add    %eax,(%rax)
     10a:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 170 <balancer_ingress+0x170>
     110:	06                   	(bad)
     111:	00 0c 1a             	add    %cl,(%rdx,%rbx,1)
     114:	01 00                	add    %eax,(%rax)
     116:	00 12                	add    %dl,(%rdx)
     118:	02 15 06 11 08 01    	add    0x1081106(%rip),%dl        # 1081224 <_license+0x107f18a>
    if (iph + 1 > data_end) {
     11e:	0b 23                	or     (%rbx),%esp
     120:	01 00                	add    %eax,(%rax)
     122:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     125:	00 00                	add    %al,(%rax)
     127:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 18d <balancer_ingress+0x18d>
    if (iph->ihl != 5) {
     12d:	10 00                	adc    %al,(%rax)
     12f:	0b 34 01             	or     (%rcx,%rax,1),%esi
     132:	00 00                	add    %al,(%rax)
     134:	04 b2                	add    $0xb2,%al
    pckt->tos = iph->tos;
     136:	00 00                	add    %al,(%rax)
     138:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 19e <balancer_ingress+0x19e>
    *protocol = iph->protocol;
     13e:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
     140:	08 16                	or     %dl,(%rsi)
     142:	4b 01 00             	rex.WXB add %rax,(%r8)
    if (iph->frag_off & PCKT_FRAGMENTED) {
     145:	00 01                	add    %al,(%rcx)
     147:	3e 02 a1 02 09 28 01 	ds add 0x1280902(%rcx),%ah
     14e:	38 0a                	cmp    %cl,(%rdx)
     150:	07                   	(bad)
     151:	7d 01                	jge    154 <balancer_ingress+0x154>
     153:	00 00                	add    %al,(%rax)
     155:	01 39                	add    %edi,(%rcx)
    if (*protocol == IPPROTO_ICMP) {
     157:	00 0a                	add    %cl,(%rdx)
     159:	09 8e 01 00 00 01    	or     %ecx,0x1000001(%rsi)
  if (icmp_hdr + 1 > data_end) {
     15f:	3a 08                	cmp    (%rax),%cl
     161:	0a 0c b6             	or     (%rsi,%rsi,4),%cl
     164:	00 00                	add    %al,(%rax)
     166:	00 01                	add    %al,(%rcx)
     168:	3b 10                	cmp    (%rax),%edx
     16a:	0a 14 cc             	or     (%rsp,%rcx,8),%dl
  if (icmp_hdr->type == ICMP_ECHO) {
     16d:	01 00                	add    %eax,(%rax)
     16f:	00 01                	add    %al,(%rcx)
     171:	3c 18                	cmp    $0x18,%al
     173:	0a 15 2f 01 00 00    	or     0x12f(%rip),%dl        # 2a8 <balancer_ingress+0x2a8>
     179:	01 3d 20 00 0b 82    	add    %edi,-0x7df4ffe0(%rip)        # ffffffff820b019f <server_id_map+0x5ffffe08e8519f>
     17f:	01 00                	add    %eax,(%rax)
     181:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     184:	00 00                	add    %al,(%rax)
     186:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 1ec <balancer_ingress+0x1ec>
  icmp_hdr->type = ICMP_ECHOREPLY;
     18c:	01 00                	add    %eax,(%rax)
     18e:	0b 93 01 00 00 0d    	or     0xd000001(%rbx),%edx
  iph->ttl = DEFAULT_TTL;
     194:	1a 10                	sbb    (%rax),%dl
     196:	03 6e 0e             	add    0xe(%rsi),%ebp
  iph->daddr = iph->saddr;
     199:	a0 01 00 00 03 6f 00 	movabs 0x100f006f03000001,%al
     1a0:	0f 10 
  iph->saddr = tmp_addr;
     1a2:	03 6f 0a             	add    0xa(%rdi),%ebp
     1a5:	17                   	(bad)
     1a6:	b8 01 00 00 03       	mov    $0x3000001,%eax
     1ab:	70 00                	jo     1ad <balancer_ingress+0x1ad>
     1ad:	0a 19                	or     (%rcx),%bl
     1af:	c0 01 00             	rolb   $0x0,(%rcx)
     1b2:	00 03                	add    %al,(%rbx)
     1b4:	71 00                	jno    1b6 <balancer_ingress+0x1b6>
     1b6:	00 00                	add    %al,(%rax)
     1b8:	0c bb                	or     $0xbb,%al
     1ba:	00 00                	add    %al,(%rax)
     1bc:	00 18                	add    %bl,(%rax)
     1be:	04 22                	add    $0x22,%al
     1c0:	04 b8                	add    $0xb8,%al
     1c2:	01 00                	add    %eax,(%rax)
     1c4:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 22a <balancer_ingress+0x22a>
     1ca:	04 00                	add    $0x0,%al
     1cc:	0b d1                	or     %ecx,%edx
     1ce:	01 00                	add    %eax,(%rax)
     1d0:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     1d3:	00 00                	add    %al,(%rax)
     1d5:	00 10                	add    %dl,(%rax)
     1d7:	60                   	(bad)
     1d8:	00 00                	add    %al,(%rax)
     1da:	00 00                	add    %al,(%rax)
     1dc:	02 00                	add    (%rax),%al
     1de:	08 1b                	or     %bl,(%rbx)
     1e0:	e9 01 00 00 01       	jmp    10001e6 <_license+0xffe14c>
     1e5:	45 02 a1 03 09 20 01 	add    0x1200903(%r9),%r12b
     1ec:	40 0a 07             	rex or (%rdi),%al
     1ef:	12 02                	adc    (%rdx),%al
     1f1:	00 00                	add    %al,(%rax)
     1f3:	01 41 00             	add    %eax,0x0(%rcx)
    if (ip6h + 1 > data_end) {
     1f6:	0a 09                	or     (%rcx),%cl
     1f8:	b6 00                	mov    $0x0,%dh
     1fa:	00 00                	add    %al,(%rax)
     1fc:	01 42 08             	add    %eax,0x8(%rdx)
     1ff:	0a 0c b6             	or     (%rsi,%rsi,4),%cl
     202:	00 00                	add    %al,(%rax)
    *protocol = ip6h->nexthdr;
     204:	00 01                	add    %al,(%rcx)
    pckt->flow.proto = *protocol;
     206:	43 10 0a             	rex.XB adc %cl,(%r10)
     209:	14 7d                	adc    $0x7d,%al
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     20b:	01 00                	add    %eax,(%rax)
     20d:	00 01                	add    %al,(%rcx)
     20f:	44 18 00             	sbb    %r8b,(%rax)
     212:	0b 17                	or     (%rdi),%edx
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     214:	02 00                	add    (%rax),%al
     216:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     219:	00 00                	add    %al,(%rax)
     21b:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 281 <balancer_ingress+0x281>
    if (*protocol == IPPROTO_FRAGMENT) {
     221:	03 00                	add    (%rax),%eax
     223:	08 1c 2e             	or     %bl,(%rsi,%rbp,1)
     226:	02 00                	add    (%rax),%al
     228:	00 05 26 02 a1 04    	add    %al,0x4a10226(%rip)        # 4a10454 <_license+0x4a0e3ba>
     22e:	09 28                	or     %ebp,(%rax)
     230:	05 20 0a 07 7d       	add    $0x7d070a20,%eax
  if (icmp_hdr + 1 > data_end) {
     235:	01 00                	add    %eax,(%rax)
     237:	00 05 21 00 0a 09    	add    %al,0x90a0021(%rip)        # 90a025e <_license+0x909e1c4>
     23d:	60                   	(bad)
     23e:	02 00                	add    (%rax),%al
     240:	00 05 22 08 0a 0c    	add    %al,0xc0a0822(%rip)        # c0a0a68 <_license+0xc09e9ce>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     246:	a8 02                	test   $0x2,%al
     248:	00 00                	add    %al,(%rax)
     24a:	05 23 10 0a 14       	add    $0x140a1023,%eax
     24f:	cc                   	int3
     250:	01 00                	add    %eax,(%rax)
     252:	00 05 24 18 0a 15    	add    %al,0x150a1824(%rip)        # 150a1a7c <_license+0x1509f9e2>
     258:	2f                   	(bad)
     259:	01 00                	add    %eax,(%rax)
     25b:	00 05 25 20 00 0b    	add    %al,0xb002025(%rip)        # b002286 <_license+0xb0001ec>
     261:	65 02 00             	add    %gs:(%rax),%al
     264:	00 0d 23 14 03 3e    	add    %cl,0x3e031423(%rip)        # 3e03168d <_license+0x3e02f5f3>
     26a:	0e                   	(bad)
     26b:	72 02                	jb     26f <balancer_ingress+0x26f>
     26d:	00 00                	add    %al,(%rax)
     26f:	03 3f                	add    (%rdi),%edi
     271:	00 0f                	add    %cl,(%rdi)
     273:	10 03                	adc    %al,(%rbx)
     275:	3f                   	(bad)
     276:	0a 1d b8 01 00 00    	or     0x1b8(%rip),%bl        # 434 <balancer_ingress+0x434>
     27c:	03 40 00             	add    0x0(%rax),%eax
     27f:	0a 1e                	or     (%rsi),%bl
     281:	c0 01 00             	rolb   $0x0,(%rcx)
     284:	00 03                	add    %al,(%rbx)
     286:	41 00 00             	add    %al,(%r8)
     289:	0a 1f                	or     (%rdi),%bl
     28b:	9c                   	pushf
     28c:	02 00                	add    (%rax),%al
     28e:	00 03                	add    %al,(%rbx)
     290:	43 10 0a             	rex.XB adc %cl,(%r10)
     293:	22 12                	and    (%rdx),%dl
     295:	01 00                	add    %eax,(%rax)
     297:	00 03                	add    %al,(%rbx)
     299:	44 12 00             	adc    (%rax),%r8b
     29c:	0c a4                	or     $0xa4,%al
     29e:	02 00                	add    (%rax),%al
     2a0:	00 21                	add    %ah,(%rcx)
     2a2:	02 18                	add    (%rax),%bl
     2a4:	06                   	(bad)
     2a5:	20 07                	and    %al,(%rdi)
     2a7:	02 0b                	add    (%rbx),%cl
     2a9:	ad                   	lods   %ds:(%rsi),%eax
     2aa:	02 00                	add    (%rax),%al
     2ac:	00 0d 26 08 03 48    	add    %cl,0x48030826(%rip)        # 48030ad8 <_license+0x4802ea3e>
     2b2:	0a 24 bb             	or     (%rbx,%rdi,4),%ah
     2b5:	00 00                	add    %al,(%rax)
     2b7:	00 03                	add    %al,(%rbx)
     2b9:	49 00 0a             	rex.WB add %cl,(%r10)
     2bc:	25 bb 00 00 00       	and    $0xbb,%eax
     2c1:	03 4a 04             	add    0x4(%rdx),%ecx
     2c4:	00 08                	add    %cl,(%rax)
     2c6:	27                   	(bad)
     2c7:	d0 02                	rolb   (%rdx)
     2c9:	00 00                	add    %al,(%rax)
     2cb:	05 2f 02 a1 05       	add    $0x5a1022f,%eax
     2d0:	09 28                	or     %ebp,(%rax)
     2d2:	05 29 0a 07 02       	add    $0x2070a29,%eax
     2d7:	03 00                	add    (%rax),%eax
     2d9:	00 05 2a 00 0a 09    	add    %al,0x90a002a(%rip)        # 90a0309 <_license+0x909e26f>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     2df:	13 03                	adc    (%rbx),%eax
     2e1:	00 00                	add    %al,(%rax)
     2e3:	05 2b 08 0a 0c       	add    $0xc0a082b,%eax
     2e8:	90                   	nop
     2e9:	03 00                	add    (%rax),%eax
     2eb:	00 05 2c 10 0a 14    	add    %al,0x140a102c(%rip)        # 140a131d <_license+0x1409f283>
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2f1:	ad                   	lods   %ds:(%rsi),%eax
     2f2:	03 00                	add    (%rax),%eax
     2f4:	00 05 2d 18 0a 15    	add    %al,0x150a182d(%rip)        # 150a1b27 <_license+0x1509fa8d>
     2fa:	2f                   	(bad)
     2fb:	01 00                	add    %eax,(%rax)
     2fd:	00 05 2e 20 00 0b    	add    %al,0xb00202e(%rip)        # b002331 <_license+0xb000297>
  if (protocol == IPPROTO_ICMPV6) {
     303:	07                   	(bad)
     304:	03 00                	add    (%rax),%eax
     306:	00 04 b2             	add    %al,(%rdx,%rsi,4)
  if (icmp_hdr + 1 > data_end) {
     309:	00 00                	add    %al,(%rax)
     30b:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 371 <balancer_ingress+0x371>
     311:	09 00                	or     %eax,(%rax)
     313:	0b 18                	or     (%rax),%ebx
  if (icmp_hdr->type == ICMP_ECHO) {
     315:	03 00                	add    (%rax),%eax
     317:	00 0d 2e 28 03 1a    	add    %cl,0x1a03282e(%rip)        # 1a032b4b <_license+0x1a030ab1>
     31d:	0e                   	(bad)
     31e:	25 03 00 00 03       	and    $0x3000003,%eax
     323:	1b 00                	sbb    (%rax),%eax
     325:	0f 10 03             	movups (%rbx),%xmm0
     328:	1b 0a                	sbb    (%rdx),%ecx
     32a:	28 b8 01 00 00 03    	sub    %bh,0x3000001(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     330:	1c 00                	sbb    $0x0,%al
     332:	0a 29                	or     (%rcx),%ch
     334:	c0 01 00             	rolb   $0x0,(%rcx)
     337:	00 03                	add    %al,(%rbx)
       sizeof(struct icmphdr)) > data_end) {
     339:	1d 00 00 0e 44       	sbb    $0x440e0000,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     33e:	03 00                	add    (%rax),%eax
     340:	00 03                	add    %al,(%rbx)
  icmp_hdr->type = ICMP_ECHOREPLY;
     342:	1f                   	(bad)
     343:	10 0f                	adc    %cl,(%rdi)
     345:	10 03                	adc    %al,(%rbx)
  icmp_hdr->checksum += 0x0008;
     347:	1f                   	(bad)
     348:	0a 2a                	or     (%rdx),%ch
     34a:	b8 01 00 00 03       	mov    $0x3000001,%eax
  iph->daddr = iph->saddr;
     34f:	20 00                	and    %al,(%rax)
     351:	0a 2b                	or     (%rbx),%ch
  tmp_addr = iph->daddr;
     353:	c0 01 00             	rolb   $0x0,(%rcx)
  iph->daddr = iph->saddr;
     356:	00 03                	add    %al,(%rbx)
  iph->saddr = tmp_addr;
     358:	21 00                	and    %eax,(%rax)
     35a:	00 0e                	add    %cl,(%rsi)
     35c:	63 03                	movsxd (%rbx),%eax
     35e:	00 00                	add    %al,(%rax)
     360:	03 23                	add    (%rbx),%esp
     362:	20 0f                	and    %cl,(%rdi)
     364:	04 03                	add    $0x3,%al
     366:	23 0a                	and    (%rdx),%ecx
     368:	2c bb                	sub    $0xbb,%al
     36a:	00 00                	add    %al,(%rax)
     36c:	00 03                	add    %al,(%rbx)
     36e:	24 00                	and    $0x0,%al
     370:	0a 2d 84 03 00 00    	or     0x384(%rip),%ch        # 6fa <balancer_ingress+0x6fa>
     376:	03 25 00 00 0a 22    	add    0x220a0000(%rip),%esp        # 220a037c <_license+0x2209e2e2>
     37c:	12 01                	adc    (%rcx),%al
     37e:	00 00                	add    %al,(%rax)
     380:	03 27                	add    (%rdi),%esp
     382:	24 00                	and    $0x0,%al
     384:	04 9c                	add    $0x9c,%al
     386:	02 00                	add    (%rax),%al
     388:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 3ee <balancer_ingress+0x3ee>
     38e:	02 00                	add    (%rax),%al
     390:	0b 95 03 00 00 0d    	or     0xd000003(%rbp),%edx
     396:	31 10                	xor    %edx,(%rax)
     398:	03 4e 0a             	add    0xa(%rsi),%ecx
     39b:	2f                   	(bad)
     39c:	bb 00 00 00 03       	mov    $0x3000000,%ebx
     3a1:	4f 00 0a             	rex.WRXB add %r9b,(%r10)
     3a4:	30 fa                	xor    %bh,%dl
     3a6:	00 00                	add    %al,(%rax)
     3a8:	00 03                	add    %al,(%rbx)
     3aa:	50                   	push   %rax
     3ab:	08 00                	or     %al,(%rax)
     3ad:	0b b2 03 00 00 04    	or     0x4000003(%rdx),%esi
     3b3:	b2 00                	mov    $0x0,%dl
     3b5:	00 00                	add    %al,(%rax)
     3b7:	10 60 00             	adc    %ah,0x0(%rax)
     3ba:	00 00                	add    %al,(%rax)
     3bc:	e8 03 00 08 32       	call   320803c4 <_license+0x3207e32a>
     3c1:	ca 03 00             	lret   $0x3
     3c4:	00 05 40 02 a1 06    	add    %al,0x6a10240(%rip)        # 6a1060a <_license+0x6a0e570>
     3ca:	09 28                	or     %ebp,(%rax)
     3cc:	05 32 0a 07 2e       	add    $0x2e070a32,%eax
     3d1:	04 00                	add    $0x0,%al
     3d3:	00 05 33 00 0a 09    	add    %al,0x90a0033(%rip)        # 90a040c <_license+0x909e372>
     3d9:	b6 00                	mov    $0x0,%dh
     3db:	00 00                	add    %al,(%rax)
     3dd:	05 34 08 0a 0c       	add    $0xc0a0834,%eax
     3e2:	b6 00                	mov    $0x0,%dh
     3e4:	00 00                	add    %al,(%rax)
     3e6:	05 35 10 0a 14       	add    $0x140a1035,%eax
     3eb:	3f                   	(bad)
     3ec:	04 00                	add    $0x0,%al
     3ee:	00 05 36 18 0a 15    	add    %al,0x150a1836(%rip)        # 150a1c2a <_license+0x1509fb90>
     3f4:	2f                   	(bad)
     3f5:	01 00                	add    %eax,(%rax)
     3f7:	00 05 37 20 0a 33    	add    %al,0x330a2037(%rip)        # 330a2434 <_license+0x330a039a>
     3fd:	50                   	push   %rax
     3fe:	04 00                	add    $0x0,%al
     400:	00 05 38 28 09 20    	add    %al,0x20092838(%rip)        # 20092c3e <_license+0x20090ba4>
     406:	05 38 0a 07 02       	add    $0x2070a38,%eax
     40b:	03 00                	add    (%rax),%eax
     40d:	00 05 38 00 0a 09    	add    %al,0x90a0038(%rip)        # 90a044b <_license+0x909e3b1>
     413:	13 03                	adc    (%rbx),%eax
     415:	00 00                	add    %al,(%rax)
     417:	05 38 08 0a 0c       	add    $0xc0a0838,%eax
     41c:	90                   	nop
     41d:	03 00                	add    (%rax),%eax
     41f:	00 05 38 10 0a 14    	add    %al,0x140a1038(%rip)        # 140a145d <_license+0x1409f3c3>
     425:	ad                   	lods   %ds:(%rsi),%eax
     426:	03 00                	add    (%rax),%eax
     428:	00 05 38 18 00 00    	add    %al,0x1838(%rip)        # 1c66 <balancer_ingress+0x1c66>
     42e:	0b 33                	or     (%rbx),%esi
     430:	04 00                	add    $0x0,%al
     432:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     435:	00 00                	add    %al,(%rax)
     437:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 49d <balancer_ingress+0x49d>
  if (protocol == IPPROTO_IPIP) {
     43d:	0c 00                	or     $0x0,%al
     43f:	0b 44 04 00          	or     0x0(%rsp,%rax,1),%eax
     443:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     446:	00 00                	add    %al,(%rax)
     448:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 4ae <balancer_ingress+0x4ae>
     44e:	80 00 04             	addb   $0x4,(%rax)
  tcp = data + off;
     451:	5b                   	pop    %rbx
     452:	04 00                	add    $0x0,%al
     454:	00 11                	add    %dl,(%rcx)
  if (is_ipv6) {
     456:	60                   	(bad)
  tcp = data + off;
     457:	00 00                	add    %al,(%rax)
     459:	00 00                	add    %al,(%rax)
  if (tcp + 1 > data_end) {
     45b:	0b 04 04             	or     (%rsp,%rax,1),%eax
     45e:	00 00                	add    %al,(%rax)
     460:	08 34 6b             	or     %dh,(%rbx,%rbp,2)
     463:	04 00                	add    $0x0,%al
     465:	00 05 49 02 a1 07    	add    %al,0x7a10249(%rip)        # 7a106b4 <_license+0x7a0e61a>
  if (tcp->syn) {
     46b:	09 28                	or     %ebp,(%rax)
     46d:	05 43 0a 07 a1       	add    $0xa1070a43,%eax
    pckt->flags |= F_SYN_SET;
     472:	00 00                	add    %al,(%rax)
     474:	00 05 44 00 0a 09    	add    %al,0x90a0044(%rip)        # 90a04be <_license+0x909e424>
     47a:	b6 00                	mov    $0x0,%dh
      pckt->flow.src = iph->saddr;
     47c:	00 00                	add    %al,(%rax)
     47e:	05 45 08 0a 0c       	add    $0xc0a0845,%eax
      pckt->flow.dst = iph->daddr;
     483:	b6 00                	mov    $0x0,%dh
     485:	00 00                	add    %al,(%rax)
     487:	05 46 10 0a 14       	add    $0x140a1046,%eax
  if (protocol == IPPROTO_ICMPV6) {
     48c:	9d                   	popf
  if (icmp_hdr + 1 > data_end) {
     48d:	04 00                	add    $0x0,%al
     48f:	00 05 47 18 0a 15    	add    %al,0x150a1847(%rip)        # 150a1cdc <_license+0x1509fc42>
     495:	2f                   	(bad)
     496:	01 00                	add    %eax,(%rax)
     498:	00 05 48 20 00 0b    	add    %al,0xb002048(%rip)        # b0024e6 <_license+0xb00044c>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     49e:	a2 04 00 00 04 b2 00 	movabs %al,0xb204000004
     4a5:	00 00 
     4a7:	12 60 00             	adc    0x0(%rax),%ah
     4aa:	00 00                	add    %al,(%rax)
     4ac:	00 02                	add    %al,(%rdx)
     4ae:	00 02                	add    %al,(%rdx)
     4b0:	00 08                	add    %cl,(%rax)
     4b2:	35 bc 04 00 00       	xor    $0x4bc,%eax
     4b7:	05 52 02 a1 08       	add    $0x8a10252,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4bc:	09 28                	or     %ebp,(%rax)
     4be:	05 4c 0a 07 a1       	add    $0xa1070a4c,%eax
     4c3:	00 00                	add    %al,(%rax)
       sizeof(struct icmp6hdr)) > data_end) {
     4c5:	00 05 4d 00 0a 09    	add    %al,0x90a004d(%rip)        # 90a0518 <_license+0x909e47e>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4cb:	b6 00                	mov    $0x0,%dh
     4cd:	00 00                	add    %al,(%rax)
     4cf:	05 4e 08 0a 0c       	add    $0xc0a084e,%eax
     4d4:	ee                   	out    %al,(%dx)
     4d5:	04 00                	add    $0x0,%al
     4d7:	00 05 4f 10 0a 14    	add    %al,0x140a104f(%rip)        # 140a152c <_license+0x1409f492>
     4dd:	21 05 00 00 05 50    	and    %eax,0x50050000(%rip)        # 500504e3 <_license+0x5004e449>
     4e3:	18 0a                	sbb    %cl,(%rdx)
     4e5:	15 2f 01 00 00       	adc    $0x12f,%eax
     4ea:	05 51 20 00 0b       	add    $0xb002051,%eax
     4ef:	f3 04 00             	repz add $0x0,%al
     4f2:	00 0d 36 14 03 54    	add    %cl,0x54031436(%rip)        # 5403192e <_license+0x5402f894>
  if (is_ipv6) {
     4f8:	0e                   	(bad)
  tcp = data + off;
     4f9:	00 05 00 00 03 55    	add    %al,0x55030000(%rip)        # 550304ff <_license+0x5502e465>
  if (tcp + 1 > data_end) {
     4ff:	00 0f                	add    %cl,(%rdi)
     501:	10 03                	adc    %al,(%rbx)
     503:	55                   	push   %rbp
     504:	0a 2a                	or     (%rdx),%ch
     506:	b8 01 00 00 03       	mov    $0x3000001,%eax
  if (tcp->syn) {
     50b:	56                   	push   %rsi
     50c:	00 0a                	add    %cl,(%rdx)
     50e:	2b c0                	sub    %eax,%eax
     510:	01 00                	add    %eax,(%rax)
     512:	00 03                	add    %al,(%rbx)
    pckt->flags |= F_SYN_SET;
     514:	57                   	push   %rdi
     515:	00 00                	add    %al,(%rax)
     517:	0a 24 12             	or     (%rdx,%rdx,1),%ah
     51a:	01 00                	add    %eax,(%rax)
     51c:	00 03                	add    %al,(%rbx)
     51e:	59                   	pop    %rcx
     51f:	10 00                	adc    %al,(%rax)
     521:	0b 26                	or     (%rsi),%esp
     523:	05 00 00 04 b2       	add    $0xb2040000,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     528:	00 00                	add    %al,(%rax)
     52a:	00 10                	add    %dl,(%rax)
     52c:	60                   	(bad)
     52d:	00 00                	add    %al,(%rax)
     52f:	00 00                	add    %al,(%rax)
     531:	10 00                	adc    %al,(%rax)
     533:	08 37                	or     %dh,(%rdi)
     535:	3e 05 00 00 05 5b    	ds add $0x5b050000,%eax
    if (!icmp_ptb_v6_stats) {
     53b:	02 a1 09 09 28 05    	add    0x5280909(%rcx),%ah
    icmp_ptb_v6_stats->v1 += 1;
     541:	55                   	push   %rbp
     542:	0a 07                	or     (%rdi),%al
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     544:	70 05                	jo     54b <balancer_ingress+0x54b>
     546:	00 00                	add    %al,(%rax)
     548:	05 56 00 0a 09       	add    $0x90a0056,%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     54d:	b6 00                	mov    $0x0,%dh
     54f:	00 00                	add    %al,(%rax)
      icmp_ptb_v6_stats->v2 += 1;
     551:	05 57 08 0a 0c       	add    $0xc0a0857,%eax
  if (ip6h + 1 > data_end) {
     556:	81 05 00 00 05 58 10 	addl   $0x21140a10,0x58050000(%rip)        # 58050560 <_license+0x5804e4c6>
     55d:	0a 14 21 
     560:	05 00 00 05 59       	add    $0x59050000,%eax
  pckt->flow.proto = ip6h->nexthdr;
     565:	18 0a                	sbb    %cl,(%rdx)
     567:	15 2f 01 00 00       	adc    $0x12f,%eax
  pckt->flags |= F_ICMP;
     56c:	05 5a 20 00 0b       	add    $0xb00205a,%eax
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     571:	75 05                	jne    578 <balancer_ingress+0x578>
     573:	00 00                	add    %al,(%rax)
     575:	04 b2                	add    $0xb2,%al
     577:	00 00                	add    %al,(%rax)
     579:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 5df <balancer_ingress+0x5df>
     57f:	06                   	(bad)
     580:	00 0b                	add    %cl,(%rbx)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     582:	86 05 00 00 0d 3a    	xchg   %al,0x3a0d0000(%rip)        # 3a0d0588 <_license+0x3a0ce4ee>
     588:	10 03                	adc    %al,(%rbx)
     58a:	5d                   	pop    %rbp
     58b:	0a 38                	or     (%rax),%bh
     58d:	fa                   	cli
     58e:	00 00                	add    %al,(%rax)
     590:	00 03                	add    %al,(%rbx)
     592:	5e                   	pop    %rsi
     593:	00 0a                	add    %cl,(%rdx)
     595:	39 fa                	cmp    %edi,%edx
     597:	00 00                	add    %al,(%rax)
     599:	00 03                	add    %al,(%rbx)
     59b:	5f                   	pop    %rdi
     59c:	08 00                	or     %al,(%rax)
     59e:	08 3b                	or     %bh,(%rbx)
     5a0:	a9 05 00 00 05       	test   $0x5000005,%eax
     5a5:	64 02 a1 0a 09 28 05 	add    %fs:0x528090a(%rcx),%ah
     5ac:	5e                   	pop    %rsi
     5ad:	0a 07                	or     (%rdi),%al
     5af:	70 05                	jo     5b6 <balancer_ingress+0x5b6>
     5b1:	00 00                	add    %al,(%rax)
     5b3:	05 5f 00 0a 09       	add    $0x90a005f,%eax
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     5b8:	b6 00                	mov    $0x0,%dh
     5ba:	00 00                	add    %al,(%rax)
     5bc:	05 60 08 0a 0c       	add    $0xc0a0860,%eax
     5c1:	b6 00                	mov    $0x0,%dh
     5c3:	00 00                	add    %al,(%rax)
     5c5:	05 61 10 0a 14       	add    $0x140a1061,%eax
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
     5ca:	21 05 00 00 05 62    	and    %eax,0x62050000(%rip)        # 620505d0 <_license+0x6204e536>
     5d0:	18 0a                	sbb    %cl,(%rdx)
     5d2:	15 2f 01 00 00       	adc    $0x12f,%eax
     5d7:	05 63 20 00 08       	add    $0x8002063,%eax
     5dc:	3c e6                	cmp    $0xe6,%al
  if (decap_dst_flags) {
     5de:	05 00 00 05 6c       	add    $0x6c050000,%eax
     5e3:	02 a1 0b 09 28 05    	add    0x528090b(%rcx),%ah
     5e9:	66 0a 07             	data16 or (%rdi),%al
     5ec:	a1 00 00 00 05 67 00 	movabs 0x90a006705000000,%eax
     5f3:	0a 09 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     5f5:	b6 00                	mov    $0x0,%dh
     5f7:	00 00                	add    %al,(%rax)
     5f9:	05 68 08 0a 0c       	add    $0xc0a0868,%eax
     5fe:	60                   	(bad)
     5ff:	02 00                	add    (%rax),%al
    if (!data_stats) {
     601:	00 05 69 10 0a 14    	add    %al,0x140a1069(%rip)        # 140a1670 <_license+0x1409f5d6>
     607:	7d 01                	jge    60a <balancer_ingress+0x60a>
     609:	00 00                	add    %al,(%rax)
     60b:	05 6a 18 0a 15       	add    $0x150a186a,%eax
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     610:	2f                   	(bad)
     611:	01 00                	add    %eax,(%rax)
     613:	00 05 6b 20 00 08    	add    %al,0x800206b(%rip)        # 8002684 <_license+0x80005ea>
     619:	3d 23 06 00 00       	cmp    $0x623,%eax
     61e:	05 75 02 a1 0c       	add    $0xca10275,%eax
     623:	09 28                	or     %ebp,(%rax)
     625:	05 6f 0a 07 70       	add    $0x70070a6f,%eax
     62a:	05 00 00 05 70       	add    $0x70050000,%eax
     62f:	00 0a                	add    %cl,(%rdx)
     631:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
  if (decap_dst_flags) {
     637:	71 08                	jno    641 <balancer_ingress+0x641>
     639:	0a 0c 81             	or     (%rcx,%rax,4),%cl
     63c:	05 00 00 05 72       	add    $0x72050000,%eax
     641:	10 0a                	adc    %cl,(%rdx)
     643:	14 55                	adc    $0x55,%al
     645:	06                   	(bad)
     646:	00 00                	add    %al,(%rax)
     648:	05 73 18 0a 15       	add    $0x150a1873,%eax
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     64d:	2f                   	(bad)
     64e:	01 00                	add    %eax,(%rax)
     650:	00 05 74 20 00 0b    	add    %al,0xb002074(%rip)        # b0026ca <_license+0xb000630>
     656:	5a                   	pop    %rdx
     657:	06                   	(bad)
     658:	00 00                	add    %al,(%rax)
    if (!data_stats) {
     65a:	04 b2                	add    $0xb2,%al
     65c:	00 00                	add    %al,(%rax)
     65e:	00 10                	add    %dl,(%rax)
     660:	60                   	(bad)
     661:	00 00                	add    %al,(%rax)
     663:	00 00                	add    %al,(%rax)
     665:	04 00                	add    $0x0,%al
     667:	08 3e                	or     %bh,(%rsi)
  udp = data + off;
     669:	72 06                	jb     671 <balancer_ingress+0x671>
     66b:	00 00                	add    %al,(%rax)
  if (is_ipv6) {
     66d:	05 7e 02 a1 0d       	add    $0xda1027e,%eax
  if (udp + 1 > data_end) {
     672:	09 28                	or     %ebp,(%rax)
     674:	05 78 0a 07 70       	add    $0x70070a78,%eax
     679:	05 00 00 05 79       	add    $0x79050000,%eax
     67e:	00 0a                	add    %cl,(%rdx)
     680:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
     686:	7a 08                	jp     690 <balancer_ingress+0x690>
     688:	0a 0c a4             	or     (%rsp,%riz,4),%cl
     68b:	06                   	(bad)
     68c:	00 00                	add    %al,(%rax)
     68e:	05 7b 10 0a 14       	add    $0x140a107b,%eax
     693:	7d 01                	jge    696 <balancer_ingress+0x696>
     695:	00 00                	add    %al,(%rax)
     697:	05 7c 18 0a 15       	add    $0x150a187c,%eax
     69c:	2f                   	(bad)
     69d:	01 00                	add    %eax,(%rax)
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     69f:	00 05 7d 20 00 0b    	add    %al,0xb00207d(%rip)        # b002722 <_license+0xb000688>
     6a5:	a9 06 00 00 0d       	test   $0xd000006,%eax
     6aa:	4c 68 03 8e 0a 3f    	rex.WR push $0x3f0a8e03
        bpf_map_lookup_elem(&stats, &stats_key);
     6b0:	fa                   	cli
     6b1:	00 00                	add    %al,(%rax)
     6b3:	00 03                	add    %al,(%rbx)
     6b5:	8f 00                	pop    (%rax)
     6b7:	0a 40 fa             	or     -0x6(%rax),%al
     6ba:	00 00                	add    %al,(%rax)
     6bc:	00 03                	add    %al,(%rbx)
    if (!icmp_ptb_v4_stats) {
     6be:	90                   	nop
     6bf:	08 0a                	or     %cl,(%rdx)
     6c1:	41 fa                	rex.B cli
     6c3:	00 00                	add    %al,(%rax)
     6c5:	00 03                	add    %al,(%rbx)
    icmp_ptb_v4_stats->v1 += 1;
     6c7:	91                   	xchg   %eax,%ecx
     6c8:	10 0a                	adc    %cl,(%rdx)
     6ca:	42 fa                	rex.X cli
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     6cc:	00 00                	add    %al,(%rax)
     6ce:	00 03                	add    %al,(%rbx)
     6d0:	92                   	xchg   %eax,%edx
      icmp_ptb_v4_stats->v2 += 1;
     6d1:	18 0a                	sbb    %cl,(%rdx)
     6d3:	43 fa                	rex.XB cli
     6d5:	00 00                	add    %al,(%rax)
  if (iph + 1 > data_end) {
     6d7:	00 03                	add    %al,(%rbx)
     6d9:	93                   	xchg   %eax,%ebx
     6da:	20 0a                	and    %cl,(%rdx)
     6dc:	44 fa                	rex.R cli
     6de:	00 00                	add    %al,(%rax)
     6e0:	00 03                	add    %al,(%rbx)
     6e2:	94                   	xchg   %eax,%esp
  if (iph->ihl != 5) {
     6e3:	28 0a                	sub    %cl,(%rdx)
     6e5:	45 fa                	rex.RB cli
     6e7:	00 00                	add    %al,(%rax)
     6e9:	00 03                	add    %al,(%rbx)
     6eb:	95                   	xchg   %eax,%ebp
     6ec:	30 0a                	xor    %cl,(%rdx)
     6ee:	46 fa                	rex.RX cli
  pckt->flow.proto = iph->protocol;
     6f0:	00 00                	add    %al,(%rax)
     6f2:	00 03                	add    %al,(%rbx)
     6f4:	96                   	xchg   %eax,%esi
     6f5:	38 0a                	cmp    %cl,(%rdx)
  pckt->flags |= F_ICMP;
     6f7:	47 fa                	rex.RXB cli
     6f9:	00 00                	add    %al,(%rax)
  pckt->flow.src = iph->daddr;
     6fb:	00 03                	add    %al,(%rbx)
     6fd:	97                   	xchg   %eax,%edi
     6fe:	40 0a 48 fa          	rex or -0x6(%rax),%cl
  pckt->flow.dst = iph->saddr;
     702:	00 00                	add    %al,(%rax)
     704:	00 03                	add    %al,(%rbx)
     706:	98                   	cwtl
     707:	48 0a 49 fa          	rex.W or -0x6(%rcx),%cl
     70b:	00 00                	add    %al,(%rax)
     70d:	00 03                	add    %al,(%rbx)
     70f:	99                   	cltd
     710:	50                   	push   %rax
     711:	0a 4a fa             	or     -0x6(%rdx),%cl
     714:	00 00                	add    %al,(%rax)
     716:	00 03                	add    %al,(%rbx)
     718:	9a                   	(bad)
     719:	58                   	pop    %rax
     71a:	0a 4b fa             	or     -0x6(%rbx),%cl
     71d:	00 00                	add    %al,(%rax)
     71f:	00 03                	add    %al,(%rbx)
     721:	9b                   	fwait
     722:	60                   	(bad)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     723:	00 08                	add    %cl,(%rax)
     725:	4d 2f                	rex.WRB (bad)
     727:	07                   	(bad)
     728:	00 00                	add    %al,(%rax)
     72a:	05 87 02 a1 0e       	add    $0xea10287,%eax
     72f:	09 28                	or     %ebp,(%rax)
     731:	05 81 0a 07 70       	add    $0x70070a81,%eax
     736:	05 00 00 05 82       	add    $0x82050000,%eax
  vip.port = pckt.flow.port16[1];
     73b:	00 0a                	add    %cl,(%rdx)
     73d:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
  vip.proto = pckt.flow.proto;
     743:	83 08 0a             	orl    $0xa,(%rax)
     746:	0c 61                	or     $0x61,%al
     748:	07                   	(bad)
     749:	00 00                	add    %al,(%rax)
     74b:	05 84 10 0a 14       	add    $0x140a1084,%eax
     750:	7d 01                	jge    753 <balancer_ingress+0x753>
     752:	00 00                	add    %al,(%rax)
     754:	05 85 18 0a 15       	add    $0x150a1885,%eax
     759:	2f                   	(bad)
     75a:	01 00                	add    %eax,(%rax)
     75c:	00 05 86 20 00 0b    	add    %al,0xb002086(%rip)        # b0027e8 <_license+0xb00074e>
     762:	66 07                	data16 (bad)
  if (!vip_info) {
     764:	00 00                	add    %al,(%rax)
     766:	0d 4f 28 03 a7       	or     $0xa703284f,%eax
     76b:	0a 3f                	or     (%rdi),%bh
  if (data_end - data > MAX_PCKT_SIZE) {
     76d:	fa                   	cli
     76e:	00 00                	add    %al,(%rax)
     770:	00 03                	add    %al,(%rbx)
     772:	a8 00                	test   $0x0,%al
     774:	0a 43 fa             	or     -0x6(%rbx),%al
     777:	00 00                	add    %al,(%rax)
     779:	00 03                	add    %al,(%rbx)
     77b:	a9 08 0a 41 fa       	test   $0xfa410a08,%eax
     780:	00 00                	add    %al,(%rax)
     782:	00 03                	add    %al,(%rbx)
     784:	aa                   	stos   %al,%es:(%rdi)
     785:	10 0a                	adc    %cl,(%rdx)
     787:	44 fa                	rex.R cli
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     789:	00 00                	add    %al,(%rax)
     78b:	00 03                	add    %al,(%rbx)
     78d:	ab                   	stos   %eax,%es:(%rdi)
     78e:	18 0a                	sbb    %cl,(%rdx)
     790:	4e fa                	rex.WRX cli
     792:	00 00                	add    %al,(%rax)
     794:	00 03                	add    %al,(%rbx)
     796:	ac                   	lods   %ds:(%rsi),%al
     797:	20 00                	and    %al,(%rax)
  if (!data_stats) {
     799:	08 50 a4             	or     %dl,-0x5c(%rax)
     79c:	07                   	(bad)
     79d:	00 00                	add    %al,(%rax)
     79f:	05 90 02 a1 0f       	add    $0xfa10290,%eax
  data_stats->v1 += 1;
     7a4:	09 28                	or     %ebp,(%rax)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     7a6:	05 8a 0a 07 70       	add    $0x70070a8a,%eax
    pckt.flow.port16[0] = 0;
     7ab:	05 00 00 05 8b       	add    $0x8b050000,%eax
     7b0:	00 0a                	add    %cl,(%rdx)
  vip_num = vip_info->vip_num;
     7b2:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
     7b8:	8c 08                	mov    %cs,(%rax)
     7ba:	0a 0c 81             	or     (%rcx,%rax,4),%cl
  __u32 cpu_num = bpf_get_smp_processor_id();
     7bd:	05 00 00 05 8d       	add    $0x8d050000,%eax
     7c2:	10 0a                	adc    %cl,(%rdx)
     7c4:	14 cc                	adc    $0xcc,%al
     7c6:	01 00                	add    %eax,(%rax)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     7c8:	00 05 8e 18 0a 15    	add    %al,0x150a188e(%rip)        # 150a205c <_license+0x1509ffc2>
     7ce:	2f                   	(bad)
     7cf:	01 00                	add    %eax,(%rax)
     7d1:	00 05 8f 20 00 08    	add    %al,0x800208f(%rip)        # 8002866 <_license+0x80007cc>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     7d7:	51                   	push   %rcx
     7d8:	e1 07                	loope  7e1 <balancer_ingress+0x7e1>
     7da:	00 00                	add    %al,(%rax)
     7dc:	05 a3 02 a1 10       	add    $0x10a102a3,%eax
     7e1:	09 28                	or     %ebp,(%rax)
    if (!lru_stats) {
     7e3:	05 9d 0a 07 a1       	add    $0xa1070a9d,%eax
     7e8:	00 00                	add    %al,(%rax)
     7ea:	00 05 9e 00 0a 09    	add    %al,0x90a009e(%rip)        # 90a088e <_license+0x909e7f4>
    lru_stats->v1 += 1;
     7f0:	b6 00                	mov    $0x0,%dh
     7f2:	00 00                	add    %al,(%rax)
     7f4:	05 9f 08 0a 0c       	add    $0xc0a089f,%eax
     7f9:	b6 00                	mov    $0x0,%dh
     7fb:	00 00                	add    %al,(%rax)
     7fd:	05 a0 10 0a 14       	add    $0x140a10a0,%eax
     802:	13 08                	adc    (%rax),%ecx
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     804:	00 00                	add    %al,(%rax)
     806:	05 a1 18 0a 15       	add    $0x150a18a1,%eax
     80b:	2f                   	(bad)
     80c:	01 00                	add    %eax,(%rax)
     80e:	00 05 a2 20 00 0b    	add    %al,0xb0020a2(%rip)        # b0028b6 <_license+0xb00081c>
        bpf_map_lookup_elem(&stats, &stats_key);
     814:	18 08                	sbb    %cl,(%rax)
     816:	00 00                	add    %al,(%rax)
     818:	04 b2                	add    $0xb2,%al
     81a:	00 00                	add    %al,(%rax)
     81c:	00 12                	add    %dl,(%rdx)
     81e:	60                   	(bad)
     81f:	00 00                	add    %al,(%rax)
     821:	00 fe                	add    %bh,%dh
     823:	ff                   	(bad)
    if (!icmp_ptb_v4_stats) {
     824:	ff 00                	incl   (%rax)
     826:	00 08                	add    %cl,(%rax)
     828:	52                   	push   %rdx
     829:	32 08                	xor    (%rax),%cl
     82b:	00 00                	add    %al,(%rax)
    icmp_ptb_v4_stats->v1 += 1;
     82d:	05 dc 02 a1 11       	add    $0x11a102dc,%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     832:	09 28                	or     %ebp,(%rax)
     834:	05 d6 0a 07 70       	add    $0x70070ad6,%eax
      icmp_ptb_v4_stats->v2 += 1;
     839:	05 00 00 05 d7       	add    $0xd7050000,%eax
  if (iph + 1 > data_end) {
     83e:	00 0a                	add    %cl,(%rdx)
     840:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
     846:	d8 08                	fmuls  (%rax)
     848:	0a 0c 64             	or     (%rsp,%riz,2),%cl
  if (iph->ihl != 5) {
     84b:	08 00                	or     %al,(%rax)
     84d:	00 05 d9 10 0a 14    	add    %al,0x140a10d9(%rip)        # 140a192c <_license+0x1409f892>
     853:	7d 01                	jge    856 <balancer_ingress+0x856>
  pckt->flow.proto = iph->protocol;
     855:	00 00                	add    %al,(%rax)
     857:	05 da 18 0a 15       	add    $0x150a18da,%eax
  pckt->flags |= F_ICMP;
     85c:	2f                   	(bad)
     85d:	01 00                	add    %eax,(%rax)
     85f:	00 05 db 20 00 0b    	add    %al,0xb0020db(%rip)        # b002940 <_license+0xb0008a6>
  pckt->flow.src = iph->daddr;
     865:	69 08 00 00 0d 55    	imul   $0x550d0000,(%rax),%ecx
  pckt->flow.dst = iph->saddr;
     86b:	20 03                	and    %al,(%rbx)
     86d:	9f                   	lahf
     86e:	0a 3f                	or     (%rdi),%bh
     870:	fa                   	cli
     871:	00 00                	add    %al,(%rax)
     873:	00 03                	add    %al,(%rbx)
    vip.port = 0;
     875:	a0 00 0a 4a fa 00 00 	movabs 0x3000000fa4a0a00,%al
     87c:	00 03 
     87e:	a1 08 0a 53 fa 00 00 	movabs 0x3000000fa530a08,%eax
     885:	00 03 
     887:	a2 10 0a 54 fa 00 00 	movabs %al,0x3000000fa540a10
     88e:	00 03 
    if (!vip_info) {
     890:	a3 18 00 08 56 9e 08 	movabs %eax,0x89e56080018
     897:	00 00 
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     899:	05 e4 02 a1 12       	add    $0x12a102e4,%eax
      pckt.flow.port16[1] = 0;
     89e:	09 28                	or     %ebp,(%rax)
     8a0:	05 de 0a 07 70       	add    $0x70070ade,%eax
     8a5:	05 00 00 05 df       	add    $0xdf050000,%eax
  struct address dst_addr = {};
     8aa:	00 0a                	add    %cl,(%rdx)
     8ac:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
     8b2:	e0 08                	loopne 8bc <balancer_ingress+0x8bc>
     8b4:	0a 0c 81             	or     (%rcx,%rax,4),%cl
     8b7:	05 00 00 05 e1       	add    $0xe1050000,%eax
    dst_addr.addr = pckt->flow.dst;
     8bc:	10 0a                	adc    %cl,(%rdx)
     8be:	14 cc                	adc    $0xcc,%al
     8c0:	01 00                	add    %eax,(%rax)
     8c2:	00 05 e2 18 0a 15    	add    %al,0x150a18e2(%rip)        # 150a21aa <_license+0x150a0110>
     8c8:	2f                   	(bad)
     8c9:	01 00                	add    %eax,(%rax)
     8cb:	00 05 e3 20 00 08    	add    %al,0x80020e3(%rip)        # 80029b4 <_license+0x800091a>
     8d1:	57                   	push   %rdi
     8d2:	db 08                	fisttpl (%rax)
     8d4:	00 00                	add    %al,(%rax)
     8d6:	05 f8 02 a1 13       	add    $0x13a102f8,%eax
  if (decap_dst_flags) {
     8db:	09 28                	or     %ebp,(%rax)
     8dd:	05 e7 0a 07 48       	add    $0x48070ae7,%eax
     8e2:	09 00                	or     %eax,(%rax)
     8e4:	00 05 e8 00 0a 09    	add    %al,0x90a00e8(%rip)        # 90a09d2 <_license+0x909e938>
     8ea:	60                   	(bad)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8eb:	02 00                	add    (%rax),%al
     8ed:	00 05 e9 08 0a 0c    	add    %al,0xc0a08e9(%rip)        # c0a11dc <_license+0xc09f142>
     8f3:	b6 00                	mov    $0x0,%dh
     8f5:	00 00                	add    %al,(%rax)
     8f7:	05 ea 10 0a 14       	add    $0x140a10ea,%eax
    if (!data_stats) {
     8fc:	cc                   	int3
     8fd:	01 00                	add    %eax,(%rax)
     8ff:	00 05 eb 18 0a 15    	add    %al,0x150a18eb(%rip)        # 150a21f0 <_license+0x150a0156>
     905:	7d 01                	jge    908 <balancer_ingress+0x908>
     907:	00 00                	add    %al,(%rax)
     909:	05 ec 20 0a 33       	add    $0x330a20ec,%eax
     90e:	59                   	pop    %rcx
     90f:	09 00                	or     %eax,(%rax)
     911:	00 05 ed 28 09 28    	add    %al,0x280928ed(%rip)        # 28093204 <_license+0x2809116a>
        bpf_map_lookup_elem(&stats, &stats_key);
     917:	05 ed 0a 07 7d       	add    $0x7d070aed,%eax
     91c:	01 00                	add    %eax,(%rax)
     91e:	00 05 ed 00 0a 09    	add    %al,0x90a00ed(%rip)        # 90a0a11 <_license+0x909e977>
    if (!icmp_ptb_v6_stats) {
     924:	b6 00                	mov    $0x0,%dh
     926:	00 00                	add    %al,(%rax)
     928:	05 ed 08 0a 0c       	add    $0xc0a08ed,%eax
    icmp_ptb_v6_stats->v1 += 1;
     92d:	69 09 00 00 05 ed    	imul   $0xed050000,(%rcx),%ecx
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     933:	10 0a                	adc    %cl,(%rdx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     935:	14 21                	adc    $0x21,%al
     937:	05 00 00 05 ed       	add    $0xed050000,%eax
     93c:	18 0a                	sbb    %cl,(%rdx)
      icmp_ptb_v6_stats->v2 += 1;
     93e:	15 7d 01 00 00       	adc    $0x17d,%eax
  if (ip6h + 1 > data_end) {
     943:	05 ed 20 00 00       	add    $0x20ed,%eax
     948:	0b 4d 09             	or     0x9(%rbp),%ecx
     94b:	00 00                	add    %al,(%rax)
     94d:	04 b2                	add    $0xb2,%al
     94f:	00 00                	add    %al,(%rax)
     951:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 9b7 <balancer_ingress+0x9b7>
  pckt->flow.proto = ip6h->nexthdr;
     957:	0d 00 04 64 09       	or     $0x9640400,%eax
  pckt->flags |= F_ICMP;
     95c:	00 00                	add    %al,(%rax)
     95e:	11 60 00             	adc    %esp,0x0(%rax)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     961:	00 00                	add    %al,(%rax)
     963:	00 0b                	add    %cl,(%rbx)
     965:	15 09 00 00 0b       	adc    $0xb000009,%eax
     96a:	12 01                	adc    (%rcx),%al
     96c:	00 00                	add    %al,(%rax)
     96e:	13 58 76             	adc    0x76(%rax),%ebx
     971:	09 00                	or     %eax,(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     973:	00 06                	add    %al,(%rsi)
     975:	38 0b                	cmp    %cl,(%rbx)
     977:	7b 09                	jnp    982 <balancer_ingress+0x982>
     979:	00 00                	add    %al,(%rax)
     97b:	14 02                	adc    $0x2,%al
     97d:	01 00                	add    %eax,(%rax)
     97f:	00 13                	add    %dl,(%rbx)
     981:	59                   	pop    %rcx
     982:	88 09                	mov    %cl,(%rcx)
     984:	00 00                	add    %al,(%rax)
     986:	06                   	(bad)
     987:	6c                   	insb   (%dx),%es:(%rdi)
     988:	0b 8d 09 00 00 15    	or     0x15000009(%rbp),%ecx
  if (protocol == IPPROTO_IPIP) {
     98e:	b2 00                	mov    $0x0,%dl
     990:	00 00                	add    %al,(%rax)
     992:	16                   	(bad)
     993:	9d                   	popf
     994:	09 00                	or     %eax,(%rax)
     996:	00 16                	add    %dl,(%rsi)
     998:	b2 00                	mov    $0x0,%dl
     99a:	00 00                	add    %al,(%rax)
     99c:	00 17                	add    %dl,(%rdi)
  struct address dst_addr = {};
     99e:	18 c3                	sbb    %al,%bl
     9a0:	00 00                	add    %al,(%rax)
     9a2:	00 5f 04             	add    %bl,0x4(%rdi)
     9a5:	07                   	(bad)
     9a6:	28 0c 19             	sub    %cl,(%rcx,%rbx,1)
     9a9:	5a                   	pop    %rdx
     9aa:	00 19                	add    %bl,(%rcx)
     9ac:	5b                   	pop    %rbx
     9ad:	01 19                	add    %ebx,(%rcx)
    dst_addr.addr = pckt->flow.dst;
     9af:	5c                   	pop    %rsp
     9b0:	02 19                	add    (%rcx),%bl
     9b2:	5d                   	pop    %rbp
     9b3:	03 19                	add    (%rcx),%ebx
     9b5:	5e                   	pop    %rsi
     9b6:	04 00                	add    $0x0,%al
     9b8:	1a c3                	sbb    %bl,%al
     9ba:	00 00                	add    %al,(%rax)
     9bc:	00 04 08             	add    %al,(%rax,%rcx,1)
     9bf:	1d 19 60 00 19       	sbb    $0x19006019,%eax
     9c4:	61                   	(bad)
     9c5:	01 19                	add    %ebx,(%rcx)
     9c7:	62 02                	(bad)
     9c9:	19 63 04             	sbb    %esp,0x4(%rbx)
  if (decap_dst_flags) {
     9cc:	19 64 06 19          	sbb    %esp,0x19(%rsi,%rax,1)
     9d0:	65 08 19             	or     %bl,%gs:(%rcx)
     9d3:	66 0c 19             	data16 or $0x19,%al
     9d6:	67 11 19             	adc    %ebx,(%ecx)
     9d9:	68 16 19 69 1d       	push   $0x1d691916
     9de:	19 6a 21             	sbb    %ebp,0x21(%rdx)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     9e1:	19 6b 29             	sbb    %ebp,0x29(%rbx)
     9e4:	19 6c 2e 19          	sbb    %ebp,0x19(%rsi,%rbp,1)
     9e8:	6d                   	insl   (%dx),%es:(%rdi)
     9e9:	2f                   	(bad)
     9ea:	19 6e 32             	sbb    %ebp,0x32(%rsi)
     9ed:	19 6f 33             	sbb    %ebp,0x33(%rdi)
    if (!data_stats) {
     9f0:	19 70 5c             	sbb    %esi,0x5c(%rax)
     9f3:	19 71 5e             	sbb    %esi,0x5e(%rcx)
     9f6:	19 72 62             	sbb    %esi,0x62(%rdx)
     9f9:	19 73 67             	sbb    %esi,0x67(%rbx)
     9fc:	19 74 6c 19          	sbb    %esi,0x19(%rsp,%rbp,2)
     a00:	75 73                	jne    a75 <balancer_ingress+0xa75>
  udp = data + off;
     a02:	19 76 84             	sbb    %esi,-0x7c(%rsi)
  if (is_ipv6) {
     a05:	01 19                	add    %ebx,(%rcx)
  udp = data + off;
     a07:	77 88                	ja     991 <balancer_ingress+0x991>
     a09:	01 19                	add    %ebx,(%rcx)
  if (udp + 1 > data_end) {
     a0b:	78 89                	js     996 <balancer_ingress+0x996>
     a0d:	01 19                	add    %ebx,(%rcx)
     a0f:	79 8f                	jns    9a0 <balancer_ingress+0x9a0>
     a11:	01 19                	add    %ebx,(%rcx)
     a13:	7a 90                	jp     9a5 <balancer_ingress+0x9a5>
     a15:	01 19                	add    %ebx,(%rcx)
     a17:	7b ff                	jnp    a18 <balancer_ingress+0xa18>
     a19:	01 19                	add    %ebx,(%rcx)
     a1b:	7c 80                	jl     99d <balancer_ingress+0x99d>
     a1d:	02 19                	add    (%rcx),%bl
     a1f:	7d 86                	jge    9a7 <balancer_ingress+0x9a7>
     a21:	02 19                	add    (%rcx),%bl
     a23:	7e 87                	jle    9ac <balancer_ingress+0x9ac>
     a25:	02 00                	add    (%rax),%al
     a27:	06                   	(bad)
     a28:	7f 05                	jg     a2f <balancer_ingress+0xa2f>
     a2a:	08 0b                	or     %cl,(%rbx)
     a2c:	fa                   	cli
     a2d:	00 00                	add    %al,(%rax)
     a2f:	00 0b                	add    %cl,(%rbx)
     a31:	5c                   	pop    %rsp
     a32:	00 00                	add    %al,(%rax)
     a34:	00 0b                	add    %cl,(%rbx)
     a36:	3a 0a                	cmp    (%rdx),%cl
     a38:	00 00                	add    %al,(%rax)
     a3a:	15 b2 00 00 00       	adc    $0xb2,%eax
     a3f:	16                   	(bad)
     a40:	45 0a 00             	or     (%r8),%r8b
     a43:	00 00                	add    %al,(%rax)
     a45:	0b 4a 0a             	or     0xa(%rdx),%ecx
     a48:	00 00                	add    %al,(%rax)
    vip.vip = pckt.flow.dst;
     a4a:	1b 89 38 07 3f 0c    	sbb    0xc3f0738(%rcx),%ecx
     a50:	1c 80                	sbb    $0x80,%al
  vip.port = pckt.flow.port16[1];
     a52:	9d                   	popf
     a53:	09 00                	or     %eax,(%rax)
     a55:	00 07                	add    %al,(%rdi)
     a57:	40 0c 00             	rex or $0x0,%al
     a5a:	1c 81                	sbb    $0x81,%al
  vip.proto = pckt.flow.proto;
     a5c:	9d                   	popf
     a5d:	09 00                	or     %eax,(%rax)
     a5f:	00 07                	add    %al,(%rdi)
     a61:	41 0c 08             	rex.B or $0x8,%al
     a64:	1c 82                	sbb    $0x82,%al
     a66:	9d                   	popf
     a67:	09 00                	or     %eax,(%rax)
     a69:	00 07                	add    %al,(%rdi)
     a6b:	42 0c 10             	rex.X or $0x10,%al
     a6e:	1c 83                	sbb    $0x83,%al
     a70:	9d                   	popf
     a71:	09 00                	or     %eax,(%rax)
     a73:	00 07                	add    %al,(%rdi)
     a75:	43 0c 18             	rex.XB or $0x18,%al
     a78:	1c 84                	sbb    $0x84,%al
     a7a:	a1 0a 00 00 07 44 0c 	movabs 0x1c200c440700000a,%eax
     a81:	20 1c 
  if (!vip_info) {
     a83:	86 a8 0a 00 00 07    	xchg   %ch,0x700000a(%rax)
  if (data_end - data > MAX_PCKT_SIZE) {
     a89:	45 0c 28             	rex.RB or $0x28,%al
     a8c:	1c 88                	sbb    $0x88,%al
     a8e:	bb 00 00 00 07       	mov    $0x7000000,%ebx
     a93:	46 0c 30             	rex.RX or $0x30,%al
     a96:	1c 24                	sbb    $0x24,%al
     a98:	bb 00 00 00 07       	mov    $0x7000000,%ebx
     a9d:	47 0c 34             	rex.RXB or $0x34,%al
     aa0:	00 0b                	add    %cl,(%rbx)
     aa2:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     aa3:	0a 00                	or     (%rax),%al
     aa5:	00 1d 85 0b ad 0a    	add    %bl,0xaad0b85(%rip)        # aad1630 <_license+0xaacf596>
     aab:	00 00                	add    %al,(%rax)
     aad:	1d 87 0b 9c 02       	sbb    $0x29c0b87,%eax
     ab2:	00 00                	add    %al,(%rax)
  if (!data_stats) {
     ab4:	0b b9 0a 00 00 15    	or     0x1500000a(%rcx),%edi
     aba:	9d                   	popf
     abb:	09 00                	or     %eax,(%rax)
  data_stats->v1 += 1;
     abd:	00 16                	add    %dl,(%rsi)
     abf:	9d                   	popf
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     ac0:	09 00                	or     %eax,(%rax)
     ac2:	00 16                	add    %dl,(%rsi)
     ac4:	9d                   	popf
    pckt.flow.port16[0] = 0;
     ac5:	09 00                	or     %eax,(%rax)
     ac7:	00 00                	add    %al,(%rax)
     ac9:	0b ce                	or     %esi,%ecx
     acb:	0a 00                	or     (%rax),%al
  vip_num = vip_info->vip_num;
     acd:	00 0d 8d 0e 09 29    	add    %cl,0x29090e8d(%rip)        # 29091960 <_license+0x2908f8c6>
     ad3:	0a 24 12             	or     (%rdx,%rdx,1),%ah
     ad6:	01 00                	add    %eax,(%rax)
     ad8:	00 09                	add    %cl,(%rcx)
     ada:	2a 00                	sub    (%rax),%al
  __u32 cpu_num = bpf_get_smp_processor_id();
     adc:	0a 8a bb 00 00 00    	or     0xbb(%rdx),%cl
     ae2:	09 2b                	or     %ebp,(%rbx)
     ae4:	01 0a                	add    %ecx,(%rdx)
     ae6:	8b 12                	mov    (%rdx),%edx
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     ae8:	01 00                	add    %eax,(%rax)
     aea:	00 09                	add    %cl,(%rcx)
     aec:	2e 05 0a 8c f8 0a    	cs add $0xaf88c0a,%eax
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     af2:	00 00                	add    %al,(%rax)
     af4:	09 32                	or     %esi,(%rdx)
     af6:	06                   	(bad)
     af7:	00 04 12             	add    %al,(%rdx,%rdx,1)
     afa:	01 00                	add    %eax,(%rax)
     afc:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # b62 <balancer_ingress+0xb62>
     b02:	08 00                	or     %al,(%rax)
     b04:	0b 09                	or     (%rcx),%ecx
     b06:	0b 00                	or     (%rax),%eax
     b08:	00 0d 8f 09 09 35    	add    %cl,0x3509098f(%rip)        # 3509149d <_license+0x3508f403>
    if (!lru_stats) {
     b0e:	0a 24 12             	or     (%rdx,%rdx,1),%ah
     b11:	01 00                	add    %eax,(%rax)
     b13:	00 09                	add    %cl,(%rcx)
    lru_stats->v1 += 1;
     b15:	36 00 0a             	ss add %cl,(%rdx)
     b18:	8e f8                	mov    %eax,%?
     b1a:	0a 00                	or     (%rax),%al
     b1c:	00 09                	add    %cl,(%rcx)
     b1e:	37                   	(bad)
     b1f:	01 00                	add    %eax,(%rax)
     b21:	0b 26                	or     (%rsi),%esp
     b23:	0b 00                	or     (%rax),%eax
     b25:	00 15 b2 00 00 00    	add    %dl,0xb2(%rip)        # bdd <balancer_ingress+0xbdd>
     b2b:	16                   	(bad)
     b2c:	9d                   	popf
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     b2d:	09 00                	or     %eax,(%rax)
     b2f:	00 16                	add    %dl,(%rsi)
     b31:	9d                   	popf
     b32:	09 00                	or     %eax,(%rax)
     b34:	00 16                	add    %dl,(%rsi)
     b36:	9d                   	popf
     b37:	09 00                	or     %eax,(%rax)
     b39:	00 16                	add    %dl,(%rsi)
     b3b:	02 01                	add    (%rcx),%al
     b3d:	00 00                	add    %al,(%rax)
     b3f:	00 0b                	add    %cl,(%rbx)
     b41:	45 0b 00             	or     (%r8),%r8d
     b44:	00 0c c3             	add    %cl,(%rbx,%rax,8)
  if (!lru_map) {
     b47:	00 00                	add    %al,(%rax)
     b49:	00 90 0a 35 1e 91    	add    %dl,-0x6ee1caf6(%rax)
     b4f:	00 a8 02 b2 00 00    	add    %ch,0xb202(%rax)
  if ((vip_info->flags & F_QUIC_VIP)) {
     b55:	00 1f                	add    %bl,(%rdi)
     b57:	92                   	xchg   %eax,%edx
     b58:	00 a8 02 45 0a 00    	add    %ch,0xa4502(%rax)
     b5e:	00 1f                	add    %bl,(%rdi)
     b60:	93                   	xchg   %eax,%ebx
     b61:	00 a8 02 fa 00 00    	add    %ch,0xfa02(%rax)
    if (is_icmp) {
     b67:	00 1f                	add    %bl,(%rdi)
     b69:	94                   	xchg   %eax,%esp
     b6a:	00 a8 02 18 0f 00    	add    %ch,0xf1802(%rax)
     b70:	00 20                	add    %ah,(%rax)
     b72:	96                   	xchg   %eax,%esi
     b73:	00 ad 02 1c 0f 00    	add    %ch,0xf1c02(%rbp)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     b79:	00 20                	add    %ah,(%rax)
     b7b:	1d 00 b1 02 65       	sbb    $0x6502b100,%eax
     b80:	02 00                	add    (%rax),%al
     b82:	00 20                	add    %ah,(%rax)
     b84:	80 00 a9             	addb   $0xa9,(%rax)
      if (!quic_packets_stats) {
     b87:	02 9d 09 00 00 20    	add    0x20000009(%rbp),%bl
     b8d:	81 00 aa 02 9d 09    	addl   $0x99d02aa,(%rax)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b93:	00 00                	add    %al,(%rax)
  bool is_icmp = (pckt->flags & F_ICMP);
     b95:	20 2a                	and    %ch,(%rdx)
     b97:	00 ac 02 ee 04 00 00 	add    %ch,0x4ee(%rdx,%rax,1)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b9e:	20 9b 00 ba 02 bb    	and    %bl,-0x44fd4600(%rbx)
     ba4:	00 00                	add    %al,(%rax)
     ba6:	00 20                	add    %ah,(%rax)
     ba8:	9c                   	pushf
     ba9:	00 bc 02 fa 00 00 00 	add    %bh,0xfa(%rdx,%rax,1)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     bb0:	20 9d 00 b8 02 b2    	and    %bl,-0x4dfd4800(%rbp)
     bb6:	00 00                	add    %al,(%rax)
     bb8:	00 20                	add    %ah,(%rax)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     bba:	9e                   	sahf
     bbb:	00 b5 02 12 01 00    	add    %dh,0x11202(%rbp)
     bc1:	00 20                	add    %ah,(%rax)
     bc3:	9f                   	lahf
     bc4:	00 b2 02 a8 02 00    	add    %dh,0x2a802(%rdx)
     bca:	00 20                	add    %ah,(%rax)
    vip.port = 0;
     bcc:	a0 00 3a 03 bb 00 00 	movabs 0x20000000bb033a00,%al
     bd3:	00 20 
     bd5:	a1 00 b3 02 81 05 00 	movabs 0x200000058102b300,%eax
     bdc:	00 20 
     bde:	a2 00 4a 03 bb 00 00 	movabs %al,0x20000000bb034a00
     be5:	00 20 
    if (!vip_info) {
     be7:	a3 00 4b 03 9d 09 00 	movabs %eax,0x200000099d034b00
     bee:	00 20 
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     bf0:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     bf1:	00 bb 02 9c 02 00    	add    %bh,0x29c02(%rbx)
      pckt.flow.port16[1] = 0;
     bf7:	00 20                	add    %ah,(%rax)
     bf9:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     bfa:	00 b6 02 9c 02 00    	add    %dh,0x29c02(%rsi)
     c00:	00 20                	add    %ah,(%rax)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c02:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     c03:	00 ab 02 c7 00 00    	add    %ch,0xc702(%rbx)
     c09:	00 20                	add    %ah,(%rax)
     c0b:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     c0c:	00 b4 02 fa 00 00 00 	add    %dh,0xfa(%rdx,%rax,1)
     c13:	20 25 00 b9 02 bb    	and    %ah,-0x44fd4700(%rip)        # ffffffffbb02c519 <server_id_map+0x5ffffe41e01519>
     c19:	00 00                	add    %al,(%rax)
     c1b:	00 21                	add    %ah,(%rcx)
      if (!data_stats) {
     c1d:	20 a8 00 af 02 9d    	and    %ch,-0x62fd5100(%rax)
     c23:	09 00                	or     %eax,(%rax)
      data_stats->v1 += 1;
     c25:	00 20                	add    %ah,(%rax)
     c27:	a9 00 af 02 35       	test   $0x3502af00,%eax
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     c2c:	0a 00                	or     (%rax),%al
     c2e:	00 00                	add    %al,(%rax)
     c30:	21 20                	and    %esp,(%rax)
     c32:	aa                   	stos   %al,%es:(%rdi)
     c33:	00 ec                	add    %ch,%ah
     c35:	02 18                	add    (%rax),%bl
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     c37:	0f 00 00             	sldt   (%rax)
     c3a:	00 21                	add    %ah,(%rcx)
        data_stats->v2 += 1;
     c3c:	20 aa 00 e3 02 18    	and    %ch,0x1802e300(%rdx)
     c42:	0f 00 00             	sldt   (%rax)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     c45:	00 21                	add    %ah,(%rcx)
     c47:	20 ab 00 17 03 9d    	and    %ch,-0x62fce900(%rbx)
     c4d:	09 00                	or     %eax,(%rax)
     c4f:	00 20                	add    %ah,(%rax)
     c51:	07                   	(bad)
     c52:	00 17                	add    %dl,(%rdi)
     c54:	03 46 0f             	add    0xf(%rsi),%eax
     c57:	00 00                	add    %al,(%rax)
     c59:	00 21                	add    %ah,(%rcx)
     c5b:	20 ab 00 1a 03 9d    	and    %ch,-0x62fce600(%rbx)
  if (!lru_map) {
     c61:	09 00                	or     %eax,(%rax)
     c63:	00 20                	add    %ah,(%rax)
     c65:	07                   	(bad)
     c66:	00 1a                	add    %bl,(%rdx)
     c68:	03 46 0f             	add    0xf(%rsi),%eax
     c6b:	00 00                	add    %al,(%rax)
  if ((vip_info->flags & F_QUIC_VIP)) {
     c6d:	00 21                	add    %ah,(%rcx)
     c6f:	20 ab 00 3b 03 9d    	and    %ch,-0x62fcc500(%rbx)
    bool is_icmp = (pckt.flags & F_ICMP);
     c75:	09 00                	or     %eax,(%rax)
     c77:	00 20                	add    %ah,(%rax)
     c79:	07                   	(bad)
    if (is_icmp) {
     c7a:	00 3b                	add    %bh,(%rbx)
     c7c:	03 46 0f             	add    0xf(%rsi),%eax
     c7f:	00 00                	add    %al,(%rax)
     c81:	21 20                	and    %esp,(%rax)
     c83:	ac                   	lods   %ds:(%rsi),%al
     c84:	00 3b                	add    %bh,(%rbx)
     c86:	03 bb 00 00 00 20    	add    0x20000000(%rbx),%edi
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     c8c:	14 00                	adc    $0x0,%al
     c8e:	3b 03                	cmp    (%rbx),%eax
     c90:	4b 0f 00 00          	rex.WXB sldt (%r8)
     c94:	20 ad 00 3b 03 4b    	and    %ch,0x4b033b00(%rbp)
      if (!quic_packets_stats) {
     c9a:	0f 00 00             	sldt   (%rax)
     c9d:	00 00                	add    %al,(%rax)
     c9f:	21 20                	and    %esp,(%rax)
     ca1:	ae                   	scas   %es:(%rdi),%al
     ca2:	00 4a 03             	add    %cl,0x3(%rdx)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     ca5:	fa                   	cli
     ca6:	00 00                	add    %al,(%rax)
  bool is_icmp = (pckt->flags & F_ICMP);
     ca8:	00 00                	add    %al,(%rax)
     caa:	21 20                	and    %esp,(%rax)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     cac:	ab                   	stos   %eax,%es:(%rdi)
     cad:	00 4b 03             	add    %cl,0x3(%rbx)
     cb0:	9d                   	popf
     cb1:	09 00                	or     %eax,(%rax)
     cb3:	00 20                	add    %ah,(%rax)
     cb5:	07                   	(bad)
     cb6:	00 4b 03             	add    %cl,0x3(%rbx)
     cb9:	46 0f 00 00          	rex.RX sldt (%rax)
     cbd:	21 20                	and    %esp,(%rax)
     cbf:	ac                   	lods   %ds:(%rsi),%al
     cc0:	00 4b 03             	add    %cl,0x3(%rbx)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     cc3:	bb 00 00 00 20       	mov    $0x20000000,%ebx
     cc8:	14 00                	adc    $0x0,%al
     cca:	4b 03 4b 0f          	rex.WXB add 0xf(%r11),%rcx
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     cce:	00 00                	add    %al,(%rax)
     cd0:	20 ad 00 4b 03 4b    	and    %ch,0x4b034b00(%rbp)
  if (!connId) {
     cd6:	0f 00 00             	sldt   (%rax)
     cd9:	00 00                	add    %al,(%rax)
  __u8 connIdVersion = (connId[0] >> 6);
     cdb:	21 20                	and    %esp,(%rax)
     cdd:	af                   	scas   %es:(%rdi),%eax
     cde:	00 4e 03             	add    %cl,0x3(%rsi)
     ce1:	bb 00 00 00 20       	mov    $0x20000000,%ebx
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     ce6:	b0 00                	mov    $0x0,%al
     ce8:	4f 03 81 05 00 00 21 	rex.WRXB add 0x21000005(%r9),%r8
     cef:	20 ab 00 4f 03 9d    	and    %ch,-0x62fcb100(%rbx)
     cf5:	09 00                	or     %eax,(%rax)
     cf7:	00 20                	add    %ah,(%rax)
     cf9:	07                   	(bad)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     cfa:	00 4f 03             	add    %cl,0x3(%rdi)
     cfd:	46 0f 00 00          	rex.RX sldt (%rax)
     d01:	21 20                	and    %esp,(%rax)
     d03:	ac                   	lods   %ds:(%rsi),%al
     d04:	00 4f 03             	add    %cl,0x3(%rdi)
     d07:	bb 00 00 00 20       	mov    $0x20000000,%ebx
     d0c:	14 00                	adc    $0x0,%al
     d0e:	4f 03 4b 0f          	rex.WRXB add 0xf(%r11),%r9
     d12:	00 00                	add    %al,(%rax)
     d14:	20 ad 00 4f 03 4b    	and    %ch,0x4b034f00(%rbp)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     d1a:	0f 00 00             	sldt   (%rax)
     d1d:	00 00                	add    %al,(%rax)
     d1f:	00 21                	add    %ah,(%rcx)
     d21:	20 b1 00 5b 03 18    	and    %dh,0x18035b00(%rcx)
     d27:	0f 00 00             	sldt   (%rax)
     d2a:	21 20                	and    %esp,(%rax)
     d2c:	b2 00                	mov    $0x0,%dl
     d2e:	6e                   	outsb  %ds:(%rsi),(%dx)
     d2f:	03 bb 00 00 00 20    	add    0x20000000(%rbx),%edi
      if (!data_stats) {
     d35:	b3 00                	mov    $0x0,%bl
     d37:	6f                   	outsl  %ds:(%rsi),(%dx)
     d38:	03 a4 06 00 00 20 b4 	add    -0x4be00000(%rsi,%rax,1),%esp
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     d3f:	00 74 03 50          	add    %dh,0x50(%rbx,%rax,1)
     d43:	0f 00 00             	sldt   (%rax)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     d46:	21 20                	and    %esp,(%rax)
        data_stats->v2 += 1;
     d48:	ab                   	stos   %eax,%es:(%rdi)
     d49:	00 70 03             	add    %dh,0x3(%rax)
     d4c:	9d                   	popf
     d4d:	09 00                	or     %eax,(%rax)
     d4f:	00 20                	add    %ah,(%rax)
  original_sport = pckt.flow.port16[0];
     d51:	07                   	(bad)
     d52:	00 70 03             	add    %dh,0x3(%rax)
     d55:	46 0f 00 00          	rex.RX sldt (%rax)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     d59:	21 20                	and    %esp,(%rax)
     d5b:	ac                   	lods   %ds:(%rsi),%al
     d5c:	00 70 03             	add    %dh,0x3(%rax)
     d5f:	bb 00 00 00 20       	mov    $0x20000000,%ebx
        !(vip_info->flags & F_LRU_BYPASS)) {
     d64:	14 00                	adc    $0x0,%al
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     d66:	70 03                	jo     d6b <balancer_ingress+0xd6b>
     d68:	4b 0f 00 00          	rex.WXB sldt (%r8)
     d6c:	20 ad 00 70 03 4b    	and    %ch,0x4b037000(%rbp)
     d72:	0f 00 00             	sldt   (%rax)
     d75:	00 00                	add    %al,(%rax)
  if (!dst_lru) {
     d77:	21 20                	and    %esp,(%rax)
     d79:	09 00                	or     %eax,(%rax)
     d7b:	79 03                	jns    d80 <balancer_ingress+0xd80>
     d7d:	bb 00 00 00 20       	mov    $0x20000000,%ebx
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
     d82:	b9 00 7a 03 b6       	mov    $0xb6037a00,%ecx
     d87:	00 00                	add    %al,(%rax)
     d89:	00 21                	add    %ah,(%rcx)
     d8b:	20 ab 00 7a 03 9d    	and    %ch,-0x62fc8600(%rbx)
    cur_time = bpf_ktime_get_ns();
     d91:	09 00                	or     %eax,(%rax)
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
     d93:	00 20                	add    %ah,(%rax)
     d95:	07                   	(bad)
     d96:	00 7a 03             	add    %bh,0x3(%rdx)
     d99:	46 0f 00 00          	rex.RX sldt (%rax)
     d9d:	21 20                	and    %esp,(%rax)
     d9f:	ac                   	lods   %ds:(%rsi),%al
     da0:	00 7a 03             	add    %bh,0x3(%rdx)
     da3:	bb 00 00 00 20       	mov    $0x20000000,%ebx
     da8:	14 00                	adc    $0x0,%al
     daa:	7a 03                	jp     daf <balancer_ingress+0xdaf>
     dac:	4b 0f 00 00          	rex.WXB sldt (%r8)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     db0:	20 ad 00 7a 03 4b    	and    %ch,0x4b037a00(%rbp)
     db6:	0f 00 00             	sldt   (%rax)
     db9:	00 00                	add    %al,(%rax)
     dbb:	21 20                	and    %esp,(%rax)
     dbd:	ba 00 8e 03 b2       	mov    $0xb2038e00,%edx
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
     dc2:	00 00                	add    %al,(%rax)
     dc4:	00 21                	add    %ah,(%rcx)
     dc6:	20 ab 00 86 03 9d    	and    %ch,-0x62fc7a00(%rbx)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     dcc:	09 00                	or     %eax,(%rax)
     dce:	00 20                	add    %ah,(%rax)
     dd0:	07                   	(bad)
     dd1:	00 86 03 46 0f 00    	add    %al,0xf4603(%rsi)
     dd7:	00 21                	add    %ah,(%rcx)
     dd9:	20 ac 00 86 03 bb 00 	and    %ch,0xbb0386(%rax,%rax,1)
     de0:	00 00                	add    %al,(%rax)
     de2:	20 14 00             	and    %dl,(%rax,%rax,1)
  if (!conn_rate_stats) {
     de5:	86 03                	xchg   %al,(%rbx)
     de7:	4b 0f 00 00          	rex.WXB sldt (%r8)
     deb:	20 ad 00 86 03 4b    	and    %ch,0x4b038600(%rbp)
     df1:	0f 00 00             	sldt   (%rax)
  *cur_time = bpf_ktime_get_ns();
     df4:	00 00                	add    %al,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     df6:	00 00                	add    %al,(%rax)
     df8:	00 21                	add    %ah,(%rcx)
     dfa:	20 a0 00 63 03 bb    	and    %ah,-0x44fc9d00(%rax)
     e00:	00 00                	add    %al,(%rax)
     e02:	00 20                	add    %ah,(%rax)
     e04:	a1 00 64 03 81 05 00 	movabs 0x2100000581036400,%eax
     e0b:	00 21 
    conn_rate_stats->v2 = *cur_time;
     e0d:	20 ab 00 64 03 9d    	and    %ch,-0x62fc9c00(%rbx)
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     e13:	09 00                	or     %eax,(%rax)
     e15:	00 20                	add    %ah,(%rax)
     e17:	07                   	(bad)
     e18:	00 64 03 46          	add    %ah,0x46(%rbx,%rax,1)
     e1c:	0f 00 00             	sldt   (%rax)
     e1f:	21 20                	and    %esp,(%rax)
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     e21:	ac                   	lods   %ds:(%rsi),%al
     e22:	00 64 03 bb          	add    %ah,-0x45(%rbx,%rax,1)
     e26:	00 00                	add    %al,(%rax)
     e28:	00 20                	add    %ah,(%rax)
        quic_packets_stats->cid_initial += 1;
     e2a:	14 00                	adc    $0x0,%al
     e2c:	64 03 4b 0f          	add    %fs:0xf(%rbx),%ecx
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     e30:	00 00                	add    %al,(%rax)
     e32:	20 ad 00 64 03 4b    	and    %ch,0x4b036400(%rbp)
     e38:	0f 00 00             	sldt   (%rax)
     e3b:	00 00                	add    %al,(%rax)
     e3d:	00 00                	add    %al,(%rax)
     e3f:	21 20                	and    %esp,(%rax)
     e41:	af                   	scas   %es:(%rdi),%eax
     e42:	00 ee                	add    %ch,%dh
     e44:	03 bb 00 00 00 20    	add    0x20000000(%rbx),%edi
     e4a:	b0 00                	mov    $0x0,%al
     e4c:	ef                   	out    %eax,(%dx)
     e4d:	03 81 05 00 00 21    	add    0x21000005(%rcx),%eax
     e53:	20 ab 00 f0 03 9d    	and    %ch,-0x62fc1000(%rbx)
     e59:	09 00                	or     %eax,(%rax)
     e5b:	00 20                	add    %ah,(%rax)
     e5d:	07                   	(bad)
     e5e:	00 f0                	add    %dh,%al
     e60:	03 46 0f             	add    0xf(%rsi),%eax
  if (!per_vip_stats) {
     e63:	00 00                	add    %al,(%rax)
     e65:	21 20                	and    %esp,(%rax)
     e67:	ac                   	lods   %ds:(%rsi),%al
     e68:	00 f0                	add    %dh,%al
     e6a:	03 bb 00 00 00 20    	add    0x20000000(%rbx),%edi
    conn_rate_stats->v1 += 1;
     e70:	14 00                	adc    $0x0,%al
     e72:	f0 03 4b 0f          	lock add 0xf(%rbx),%ecx
     e76:	00 00                	add    %al,(%rax)
     e78:	20 ad 00 f0 03 4b    	and    %ch,0x4b03f000(%rbp)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
     e7e:	0f 00 00             	sldt   (%rax)
     e81:	00 00                	add    %al,(%rax)
     e83:	00 21                	add    %ah,(%rcx)
     e85:	20 ab 00 13 04 9d    	and    %ch,-0x62fbed00(%rbx)
     e8b:	09 00                	or     %eax,(%rax)
     e8d:	00 20                	add    %ah,(%rax)
     e8f:	07                   	(bad)
     e90:	00 13                	add    %dl,(%rbx)
     e92:	04 46                	add    $0x46,%al
     e94:	0f 00 00             	sldt   (%rax)
     e97:	21 20                	and    %esp,(%rax)
     e99:	14 00                	adc    $0x0,%al
    if (down_reals_map) {
     e9b:	13 04 4b             	adc    (%rbx,%rcx,2),%eax
     e9e:	0f 00 00             	sldt   (%rax)
     ea1:	20 ad 00 13 04 4b    	and    %ch,0x4b041300(%rbp)
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
     ea7:	0f 00 00             	sldt   (%rax)
     eaa:	20 ac 00 13 04 bb 00 	and    %ch,0xbb0413(%rax,%rax,1)
      if (down_real) {
     eb1:	00 00                	add    %al,(%rax)
     eb3:	00 00                	add    %al,(%rax)
     eb5:	21 20                	and    %esp,(%rax)
     eb7:	ab                   	stos   %eax,%es:(%rdi)
     eb8:	00 1b                	add    %bl,(%rbx)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
     eba:	04 9d                	add    $0x9d,%al
     ebc:	09 00                	or     %eax,(%rax)
     ebe:	00 20                	add    %ah,(%rax)
     ec0:	07                   	(bad)
     ec1:	00 1b                	add    %bl,(%rbx)
     ec3:	04 46                	add    $0x46,%al
     ec5:	0f 00 00             	sldt   (%rax)
     ec8:	21 20                	and    %esp,(%rax)
     eca:	14 00                	adc    $0x0,%al
     ecc:	1b 04 4b             	sbb    (%rbx,%rcx,2),%eax
     ecf:	0f 00 00             	sldt   (%rax)
     ed2:	20 ad 00 1b 04 4b    	and    %ch,0x4b041b00(%rbp)
        if (stats_data) {
     ed8:	0f 00 00             	sldt   (%rax)
     edb:	20 ac 00 1b 04 bb 00 	and    %ch,0xbb041b(%rax,%rax,1)
          stats_data->v1 += 1;
     ee2:	00 00                	add    %al,(%rax)
     ee4:	00 00                	add    %al,(%rax)
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     ee6:	21 20                	and    %esp,(%rax)
     ee8:	ab                   	stos   %eax,%es:(%rdi)
     ee9:	00 0d 04 9d 09 00    	add    %cl,0x99d04(%rip)        # 9abf3 <_license+0x98b59>
     eef:	00 20                	add    %ah,(%rax)
     ef1:	07                   	(bad)
     ef2:	00 0d 04 46 0f 00    	add    %cl,0xf4604(%rip)        # f54fc <_license+0xf3462>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     ef8:	00 21                	add    %ah,(%rcx)
     efa:	20 ac 00 0d 04 bb 00 	and    %ch,0xbb040d(%rax,%rax,1)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     f01:	00 00                	add    %al,(%rax)
     f03:	20 14 00             	and    %dl,(%rax,%rax,1)
     f06:	0d 04 4b 0f 00       	or     $0xf4b04,%eax
     f0b:	00 20                	add    %ah,(%rax)
     f0d:	ad                   	lods   %ds:(%rsi),%eax
     f0e:	00 0d 04 4b 0f 00    	add    %cl,0xf4b04(%rip)        # f5a18 <_license+0xf397e>
     f14:	00 00                	add    %al,(%rax)
     f16:	00 00                	add    %al,(%rax)
     f18:	06                   	(bad)
     f19:	95                   	xchg   %eax,%ebp
     f1a:	02 01                	add    (%rcx),%al
     f1c:	0d 9a 30 03 2b       	or     $0x2b03309a,%eax
     f21:	0a 97 18 03 00 00    	or     0x318(%rdi),%dl
     f27:	03 2c 00             	add    (%rax,%rax,1),%ebp
     f2a:	0a 98 bb 00 00 00    	or     0xbb(%rax),%bl
  if (!per_vip_stats) {
     f30:	03 2d 28 0a 24 12    	add    0x12240a28(%rip),%ebp        # 1224195e <_license+0x1223f8c4>
     f36:	01 00                	add    %eax,(%rax)
     f38:	00 03                	add    %al,(%rbx)
     f3a:	2e 2c 0a             	cs sub $0xa,%al
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
     f3d:	99                   	cltd
     f3e:	12 01                	adc    (%rcx),%al
     f40:	00 00                	add    %al,(%rax)
     f42:	03 30                	add    (%rax),%esi
     f44:	2d 00 22 b2 00       	sub    $0xb22200,%eax
     f49:	00 00                	add    %al,(%rax)
     f4b:	22 bb 00 00 00 0d    	and    0xd000000(%rbx),%bh
  if (!connId) {
     f51:	b8 08 09 3a 0a       	mov    $0xa3a0908,%eax
     f56:	b5 b2                	mov    $0xb2,%ch
  __u8 connIdVersion = (connId[0] >> 6);
     f58:	00 00                	add    %al,(%rax)
     f5a:	00 09                	add    %cl,(%rcx)
     f5c:	3b 00                	cmp    (%rax),%eax
     f5e:	0a b6 12 01 00 00    	or     0x112(%rsi),%dh
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     f64:	09 3c 04             	or     %edi,(%rsp,%rax,1)
     f67:	0a b7 18 0f 00 00    	or     0xf18(%rdi),%dh
     f6d:	09 3d 05 00 1e bb    	or     %edi,-0x44e1fffb(%rip)        # ffffffffbb1e0f78 <server_id_map+0x5ffffe41fb5f78>
     f73:	09 c3                	or     %eax,%ebx
     f75:	01 b2 00 00 00 1f    	add    %esi,0x1f000000(%rdx)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     f7b:	96                   	xchg   %eax,%esi
     f7c:	09 c4                	or     %eax,%esp
     f7e:	01 de                	add    %ebx,%esi
     f80:	0f 00 00             	sldt   (%rax)
     f83:	1f                   	(bad)
     f84:	9e                   	sahf
     f85:	09 c5                	or     %eax,%ebp
     f87:	01 69 09             	add    %ebp,0x9(%rcx)
     f8a:	00 00                	add    %al,(%rax)
     f8c:	1f                   	(bad)
     f8d:	93                   	xchg   %eax,%ebx
     f8e:	09 c6                	or     %eax,%esi
     f90:	01 fa                	add    %edi,%edx
     f92:	00 00                	add    %al,(%rax)
     f94:	00 1f                	add    %bl,(%rdi)
    dst_lru->atime = cur_time;
     f96:	9c                   	pushf
     f97:	09 c7                	or     %eax,%edi
     f99:	01 2b                	add    %ebp,(%rbx)
  key = dst_lru->pos;
     f9b:	0a 00                	or     (%rax),%al
     f9d:	00 1f                	add    %bl,(%rdi)
     f9f:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     fa0:	09 c8                	or     %ecx,%eax
     fa2:	01 af 0a 00 00 1f    	add    %ebp,0x1f00000a(%rdi)
  pckt->real_index = key;
     fa8:	80 09 c9             	orb    $0xc9,(%rcx)
  *real = bpf_map_lookup_elem(&reals, &key);
     fab:	01 9d 09 00 00 1f    	add    %ebx,0x1f000009(%rbp)
     fb1:	81 09 ca 01 9d 09    	orl    $0x99d01ca,(%rcx)
     fb7:	00 00                	add    %al,(%rax)
     fb9:	1f                   	(bad)
     fba:	94                   	xchg   %eax,%esp
     fbb:	09 cb                	or     %ecx,%ebx
     fbd:	01 18                	add    %ebx,(%rax)
     fbf:	0f 00 00             	sldt   (%rax)
     fc2:	20 bc 09 cd 01 e3 0f 	and    %bh,0xfe301cd(%rcx,%rcx,1)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     fc9:	00 00                	add    %al,(%rax)
     fcb:	20 c9                	and    %cl,%cl
     fcd:	09 ce                	or     %ecx,%esi
    if (!dst) {
     fcf:	01 a1 10 00 00 20    	add    %esp,0x20000010(%rcx)
     fd5:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     fd6:	09 cc                	or     %ecx,%esp
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
     fd8:	01 fa                	add    %edi,%edx
     fda:	00 00                	add    %al,(%rax)
     fdc:	00 00                	add    %al,(%rax)
     fde:	0b 1c 0f             	or     (%rdi,%rcx,1),%ebx
     fe1:	00 00                	add    %al,(%rax)
     fe3:	0b e8                	or     %eax,%ebp
     fe5:	0f 00 00             	sldt   (%rax)
     fe8:	0d c8 14 0f 57       	or     $0x570f14c8,%eax
     fed:	23 bd 12 01 00 00    	and    0x112(%rbp),%edi
     ff3:	0f 59 01             	mulps  (%rcx),%xmm0
     ff6:	04 04                	add    $0x4,%al
     ff8:	00 23                	add    %ah,(%rbx)
     ffa:	8a 12                	mov    (%rdx),%dl
     ffc:	01 00                	add    %eax,(%rax)
     ffe:	00 0f                	add    %cl,(%rdi)
    1000:	5a                   	pop    %rdx
    1001:	01 04 00             	add    %eax,(%rax,%rax,1)
    1004:	00 0a                	add    %cl,(%rdx)
  if (!data_stats) {
    1006:	99                   	cltd
    1007:	12 01                	adc    (%rcx),%al
    1009:	00 00                	add    %al,(%rax)
    100b:	0f 61 01             	punpcklwd (%rcx),%mm0
    100e:	0a be 91 10 00 00    	or     0x1091(%rsi),%bh
    1014:	0f 62 02             	punpckldq (%rdx),%mm0
    1017:	0a c0                	or     %al,%al
    1019:	91                   	xchg   %eax,%ecx
  data_stats->v1 += 1;
    101a:	10 00                	adc    %al,(%rax)
    101c:	00 0f                	add    %cl,(%rdi)
  data_stats->v2 += pkt_bytes;
    101e:	63 04 0a             	movsxd (%rdx,%rcx,1),%eax
    1021:	c1 91 10 00 00 0f 64 	rcll   $0x64,0xf000010(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1028:	06                   	(bad)
    1029:	0a c2                	or     %dl,%al
    102b:	12 01                	adc    (%rcx),%al
    102d:	00 00                	add    %al,(%rax)
    102f:	0f 65 08             	pcmpgtw (%rax),%mm1
    1032:	0a 9e 12 01 00 00    	or     0x112(%rsi),%bl
    1038:	0f 66 09             	pcmpgtd (%rcx),%mm1
    103b:	0a c3                	or     %bl,%al
    103d:	99                   	cltd
    103e:	10 00                	adc    %al,(%rax)
    1040:	00 0f                	add    %cl,(%rdi)
    1042:	67 0a 0e             	or     (%esi),%cl
    1045:	4c 10 00             	rex.WR adc %r8b,(%rax)
    1048:	00 0f                	add    %cl,(%rdi)
    104a:	68 0c 0f 08 0f       	push   $0xf080f0c
    104f:	68 0e 58 10 00       	push   $0x10580e
  if (!data_stats) {
    1054:	00 0f                	add    %cl,(%rdi)
    1056:	68 00 09 08 0f       	push   $0xf080900
  data_stats->v1 += 1;
    105b:	68 0a c5 b8 01       	push   $0x1b8c50a
  data_stats->v2 += pkt_bytes;
    1060:	00 00                	add    %al,(%rax)
  pckt.flow.port16[0] = original_sport;
    1062:	0f 68 00             	punpckhbw (%rax),%mm0
    1065:	0a c6                	or     %dh,%al
    1067:	b8 01 00 00 0f       	mov    $0xf000001,%eax
  if (dst->flags & F_IPV6) {
    106c:	68 04 00 0a c7       	push   $0xffffffffc70a0004
    1071:	78 10                	js     1083 <balancer_ingress+0x1083>
    1073:	00 00                	add    %al,(%rax)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1075:	0f 68 00             	punpckhbw (%rax),%mm0
    1078:	09 08                	or     %ecx,(%rax)
    107a:	0f 68 0a             	punpckhbw (%rdx),%mm1
    107d:	c5 b8 01             	(bad)
    1080:	00 00                	add    %al,(%rax)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1082:	0f 68 00             	punpckhbw (%rax),%mm0
    1085:	0a c6                	or     %dh,%al
    1087:	b8 01 00 00 0f       	mov    $0xf000001,%eax
    108c:	68 04 00 00 00       	push   $0x4
    1091:	0c 9c                	or     $0x9c,%al
  data = (void*)(long)xdp->data;
    1093:	02 00                	add    (%rax),%al
    1095:	00 bf 04 20 0c 9c    	add    %bh,-0x63f3dffc(%rdi)
  iph = data + sizeof(struct ethhdr);
    109b:	02 00                	add    (%rax),%al
    109d:	00 c4                	add    %al,%ah
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    109f:	04 26                	add    $0x26,%al
    10a1:	0b a6 10 00 00 0d    	or     0xd000010(%rsi),%esp
    10a7:	d4                   	(bad)
    10a8:	28 10                	sub    %dl,(%rax)
    10aa:	76 23                	jbe    10cf <balancer_ingress+0x10cf>
    10ac:	ca 12 01             	lret   $0x112
    10af:	00 00                	add    %al,(%rax)
    10b1:	10 78 01             	adc    %bh,0x1(%rax)
    10b4:	04 04                	add    $0x4,%al
    10b6:	00 23                	add    %ah,(%rbx)
    10b8:	8a 12                	mov    (%rdx),%dl
    10ba:	01 00                	add    %eax,(%rax)
    10bc:	00 10                	add    %dl,(%rax)
    10be:	79 01                	jns    10c1 <balancer_ingress+0x10c1>
    10c0:	04 00                	add    $0x0,%al
    10c2:	00 0a                	add    %cl,(%rdx)
    10c4:	cb                   	lret
    10c5:	34 11                	xor    $0x11,%al
    10c7:	00 00                	add    %al,(%rax)
    10c9:	10 80 01 0a cc 91    	adc    %al,-0x6e33f5ff(%rax)
    10cf:	10 00                	adc    %al,(%rax)
    10d1:	00 10                	add    %dl,(%rax)
    10d3:	82                   	(bad)
    10d4:	04 0a                	add    $0xa,%al
    10d6:	cd 12                	int    $0x12
  memcpy(new_eth->h_dest, cval->mac, 6);
    10d8:	01 00                	add    %eax,(%rax)
    10da:	00 10                	add    %dl,(%rax)
    10dc:	83 06 0a             	addl   $0xa,(%rsi)
    10df:	ce                   	(bad)
    10e0:	12 01                	adc    (%rcx),%al
    10e2:	00 00                	add    %al,(%rax)
    10e4:	10 84 07 0e ef 10 00 	adc    %al,0x10ef0e(%rdi,%rax,1)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    10eb:	00 10                	add    %dl,(%rax)
    10ed:	86 08                	xchg   %cl,(%rax)
    10ef:	0f 20 10             	mov    %cr2,%rax
    10f2:	86 0e                	xchg   %cl,(%rsi)
    10f4:	fb                   	sti
    10f5:	10 00                	adc    %al,(%rax)
    10f7:	00 10                	add    %dl,(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    10f9:	86 00                	xchg   %al,(%rax)
    10fb:	09 20                	or     %esp,(%rax)
    10fd:	10 86 0a c5 40 11    	adc    %al,0x1140c50a(%rsi)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1103:	00 00                	add    %al,(%rax)
    1105:	10 86 00 0a c6 40    	adc    %al,0x40c60a00(%rsi)
  iph->tos = tos;
    110b:	11 00                	adc    %eax,(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    110d:	00 10                	add    %dl,(%rax)
    110f:	86 10                	xchg   %dl,(%rax)
    1111:	00 0a                	add    %cl,(%rdx)
    1113:	c7                   	(bad)
    1114:	1b 11                	sbb    (%rcx),%edx
    1116:	00 00                	add    %al,(%rax)
  iph->id = 0;
    1118:	10 86 00 09 20 10    	adc    %al,0x10200900(%rsi)
    111e:	86 0a                	xchg   %cl,(%rdx)
  iph->daddr = daddr;
    1120:	c5 40 11             	(bad)
  iph->saddr = saddr;
    1123:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
    1125:	10 86 00 0a c6 40    	adc    %al,0x40c60a00(%rsi)
    112b:	11 00                	adc    %eax,(%rax)
    112d:	00 10                	add    %dl,(%rax)
    112f:	86 10                	xchg   %dl,(%rax)
    1131:	00 00                	add    %al,(%rax)
    1133:	00 04 12             	add    %al,(%rdx,%rdx,1)
    1136:	01 00                	add    %eax,(%rax)
      if (pckt.flow.proto == IPPROTO_TCP) {
    1138:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 119e <balancer_ingress+0x119e>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    113e:	03 00                	add    (%rax),%eax
    1140:	0d d3 10 11 21       	or     $0x211110d3,%eax
    1145:	0a cf                	or     %bh,%cl
    1147:	4e 11 00             	rex.WRX adc %r8,(%rax)
    114a:	00 11                	add    %dl,(%rcx)
    114c:	28 00                	sub    %al,(%rax)
    114e:	0f 10 11             	movups (%rcx),%xmm2
    1151:	22 0a                	and    (%rdx),%cl
    1153:	d0 6f 11             	shrb   0x11(%rdi)
    1156:	00 00                	add    %al,(%rax)
        if (!lru_stats) {
    1158:	11 23                	adc    %esp,(%rbx)
    115a:	00 0a                	add    %cl,(%rdx)
    115c:	d1 7b 11             	sarl   0x11(%rbx)
    115f:	00 00                	add    %al,(%rax)
        if (pckt.flags & F_SYN_SET) {
    1161:	11 25 00 0a d2 c0    	adc    %esp,-0x3f2df600(%rip)        # ffffffffc0d21b67 <server_id_map+0x5ffffe47af6b67>
    1167:	01 00                	add    %eax,(%rax)
    1169:	00 11                	add    %dl,(%rcx)
    116b:	26 00 00             	es add %al,(%rax)
    116e:	00 04 12             	add    %al,(%rdx,%rdx,1)
    1171:	01 00                	add    %eax,(%rax)
  struct real_pos_lru new_dst_lru = {};
    1173:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 11d9 <balancer_ingress+0x11d9>
    1179:	10 00                	adc    %al,(%rax)
    117b:	04 91                	add    $0x91,%al
    117d:	10 00                	adc    %al,(%rax)
    117f:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 11e5 <balancer_ingress+0x11e5>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1185:	08 00                	or     %al,(%rax)
    1187:	1e                   	(bad)
    1188:	d5                   	(bad)
    1189:	0b 13                	or     (%rbx),%edx
    118b:	01 b2 00 00 00 1f    	add    %esi,0x1f000000(%rdx)
    1191:	80 0b 14             	orb    $0x14,(%rbx)
    1194:	01 9d 09 00 00 1f    	add    %ebx,0x1f000009(%rbp)
    119a:	81 0b 15 01 9d 09    	orl    $0x99d0115,(%rbx)
  if (!conn_rate_stats) {
    11a0:	00 00                	add    %al,(%rax)
    11a2:	1f                   	(bad)
    11a3:	d6                   	(bad)
    11a4:	0b 16                	or     (%rsi),%edx
    11a6:	01 fa                	add    %edi,%edx
    11a8:	00 00                	add    %al,(%rax)
    11aa:	00 1f                	add    %bl,(%rdi)
  *cur_time = bpf_ktime_get_ns();
    11ac:	96                   	xchg   %eax,%esi
    11ad:	0b 17                	or     (%rdi),%edx
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    11af:	01 de                	add    %ebx,%esi
    11b1:	0f 00 00             	sldt   (%rax)
    11b4:	20 d7                	and    %dl,%bh
    11b6:	0b 18                	or     (%rax),%ebx
    11b8:	01 15 12 00 00 20    	add    %edx,0x20000012(%rip)        # 200011d0 <_license+0x1ffff136>
    conn_rate_stats->v1 = 1;
    11be:	bc 0b 19 01 e3       	mov    $0xe301190b,%esp
    11c3:	0f 00 00             	sldt   (%rax)
    conn_rate_stats->v2 = *cur_time;
    11c6:	21 20                	and    %esp,(%rax)
    11c8:	a0 0b 26 01 bb 00 00 	movabs 0x20000000bb01260b,%al
    11cf:	00 20 
    conn_rate_stats->v1 += 1;
    11d1:	e3 0b                	jrcxz  11de <balancer_ingress+0x11de>
    11d3:	27                   	(bad)
    11d4:	01 81 05 00 00 20    	add    %eax,0x20000005(%rcx)
    11da:	e0 0b                	loopne 11e7 <balancer_ingress+0x11e7>
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    11dc:	2d 01 9c 02 00       	sub    $0x29c01,%eax
    11e1:	00 21                	add    %ah,(%rcx)
    11e3:	20 ab 0b 28 01 9d    	and    %ch,-0x62fed7f5(%rbx)
    11e9:	09 00                	or     %eax,(%rax)
    11eb:	00 20                	add    %ah,(%rax)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    11ed:	07                   	(bad)
    11ee:	0b 28                	or     (%rax),%ebp
    11f0:	01 46 0f             	add    %eax,0xf(%rsi)
    11f3:	00 00                	add    %al,(%rax)
    11f5:	21 20                	and    %esp,(%rax)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    11f7:	ac                   	lods   %ds:(%rsi),%al
    11f8:	0b 28                	or     (%rax),%ebp
    11fa:	01 bb 00 00 00 20    	add    %edi,0x20000000(%rbx)
    1200:	14 0b                	adc    $0xb,%al
      memset(pckt->flow.srcv6, 0, 16);
    1202:	28 01                	sub    %al,(%rcx)
    1204:	4b 0f 00 00          	rex.WXB sldt (%r8)
    1208:	20 ad 0b 28 01 4b    	and    %ch,0x4b01280b(%rbp)
    120e:	0f 00 00             	sldt   (%rax)
    1211:	00 00                	add    %al,(%rax)
    1213:	00 00                	add    %al,(%rax)
    1215:	0b 1a                	or     (%rdx),%ebx
    1217:	12 00                	adc    (%rax),%al
    1219:	00 0d e2 08 12 59    	add    %cl,0x591208e2(%rip)        # 59121b01 <_license+0x5911fa67>
  a += initval;
    121f:	0a 07                	or     (%rdi),%al
    1221:	12 01                	adc    (%rcx),%al
    1223:	00 00                	add    %al,(%rax)
  __jhash_final(a, b, c);
    1225:	12 5a 00             	adc    0x0(%rdx),%bl
    1228:	0a d8                	or     %al,%bl
    122a:	12 01                	adc    (%rcx),%al
  return (word << shift) | (word >> ((-shift) & 31));
    122c:	00 00                	add    %al,(%rax)
    122e:	12 5b 01             	adc    0x1(%rbx),%bl
  __jhash_final(a, b, c);
    1231:	0a d9                	or     %cl,%bl
    1233:	99                   	cltd
    1234:	10 00                	adc    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1236:	00 12                	add    %dl,(%rdx)
    1238:	5c                   	pop    %rsp
    1239:	02 0a                	add    (%rdx),%cl
  __jhash_final(a, b, c);
    123b:	da 43 12             	fiaddl 0x12(%rbx)
  return (word << shift) | (word >> ((-shift) & 31));
    123e:	00 00                	add    %al,(%rax)
    1240:	12 68 04             	adc    0x4(%rax),%ch
  __jhash_final(a, b, c);
    1243:	0f 04                	(bad)
    1245:	12 5d 0a             	adc    0xa(%rbp),%bl
  return (word << shift) | (word >> ((-shift) & 31));
    1248:	db 50 12             	fistl  0x12(%rax)
    124b:	00 00                	add    %al,(%rax)
  __jhash_final(a, b, c);
    124d:	12 61 00             	adc    0x0(%rcx),%ah
  return (word << shift) | (word >> ((-shift) & 31));
    1250:	09 04 12             	or     %eax,(%rdx,%rdx,1)
    1253:	5e                   	pop    %rsi
    1254:	0a c0                	or     %al,%al
  __jhash_final(a, b, c);
    1256:	91                   	xchg   %eax,%ecx
    1257:	10 00                	adc    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1259:	00 12                	add    %dl,(%rdx)
    125b:	5f                   	pop    %rdi
  __jhash_final(a, b, c);
    125c:	00 0a                	add    %cl,(%rdx)
    125e:	dc 91 10 00 00 12    	fcoml  0x12000010(%rcx)
    1264:	60                   	(bad)
    1265:	02 00                	add    (%rax),%al
    1267:	0a dd                	or     %ch,%bl
    1269:	b8 01 00 00 12       	mov    $0x12000001,%eax
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    126e:	62                   	(bad)
    126f:	00 0a                	add    %cl,(%rdx)
    1271:	de 79 12             	fidivrs 0x12(%rcx)
    1274:	00 00                	add    %al,(%rax)
    1276:	12 66 00             	adc    0x0(%rsi),%ah
    1279:	09 04 12             	or     %eax,(%rdx,%rdx,1)
    127c:	63 0a                	movsxd (%rdx),%ecx
    127e:	df 91 10 00 00 12    	fists  0x12000010(%rcx)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1284:	64 00 0a             	add    %cl,%fs:(%rdx)
    1287:	e0 91                	loopne 121a <balancer_ingress+0x121a>
    1289:	10 00                	adc    %al,(%rax)
    128b:	00 12                	add    %dl,(%rdx)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    128d:	65 02 00             	add    %gs:(%rax),%al
    1290:	0a e1                	or     %cl,%ah
    if (!real_pos) {
    1292:	9b                   	fwait
    1293:	12 00                	adc    (%rax),%al
    1295:	00 12                	add    %dl,(%rdx)
    1297:	67 00 00             	add    %al,(%eax)
    129a:	00 04 12             	add    %al,(%rdx,%rdx,1)
    129d:	01 00                	add    %eax,(%rax)
    129f:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 1305 <balancer_ingress+0x1305>
    key = *real_pos;
    12a5:	04 00                	add    $0x0,%al
    12a7:	1e                   	(bad)
    12a8:	e4 0b                	in     $0xb,%al
    12aa:	53                   	push   %rbx
    12ab:	01 b2 00 00 00 1f    	add    %esi,0x1f000000(%rdx)
  pckt->real_index = key;
    12b1:	80 0b 54             	orb    $0x54,(%rbx)
  *real = bpf_map_lookup_elem(&reals, &key);
    12b4:	01 9d 09 00 00 1f    	add    %ebx,0x1f000009(%rbp)
  if (!(*real)) {
    12ba:	81 0b 55 01 9d 09    	orl    $0x99d0155,(%rbx)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    12c0:	00 00                	add    %al,(%rax)
    12c2:	1f                   	(bad)
    12c3:	d6                   	(bad)
    12c4:	0b 56 01             	or     0x1(%rsi),%edx
    12c7:	fa                   	cli
    12c8:	00 00                	add    %al,(%rax)
    12ca:	00 1f                	add    %bl,(%rdi)
    12cc:	96                   	xchg   %eax,%esi
    12cd:	0b 57 01             	or     0x1(%rdi),%edx
    12d0:	de 0f                	fimuls (%rdi)
    12d2:	00 00                	add    %al,(%rax)
    12d4:	1f                   	(bad)
    12d5:	9e                   	sahf
  if (!ch_drop_stats) {
    12d6:	0b 58 01             	or     0x1(%rax),%ebx
    12d9:	12 01                	adc    (%rcx),%al
    12db:	00 00                	add    %al,(%rax)
    12dd:	00 24 e5 0b 3e b2 00 	add    %ah,0xb23e0b(,%riz,8)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    12e4:	00 00                	add    %al,(%rax)
    12e6:	25 80 0b 3f 9d       	and    $0x9d3f0b80,%eax
    12eb:	09 00                	or     %eax,(%rax)
    12ed:	00 25 81 0b 40 9d    	add    %ah,-0x62bff47f(%rip)        # ffffffff9d401e74 <server_id_map+0x5ffffe241d6e74>
    12f3:	09 00                	or     %eax,(%rax)
    12f5:	00 26                	add    %ah,(%rsi)
    12f7:	e6 0b                	out    %al,$0xb
    12f9:	43 bb 00 00 00 26    	rex.XB mov $0x26000000,%r11d
  if (!ch_drop_stats) {
    12ff:	e7 0b                	out    %eax,$0xb
    1301:	44 fa                	rex.R cli
    1303:	00 00                	add    %al,(%rax)
    1305:	00 26                	add    %ah,(%rsi)
    1307:	d6                   	(bad)
    1308:	0b 45 fa             	or     -0x6(%rbp),%eax
    130b:	00 00                	add    %al,(%rax)
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    130d:	00 26                	add    %ah,(%rsi)
    130f:	d7                   	xlat   %ds:(%rbx)
    1310:	0b 42 15             	or     0x15(%rdx),%eax
    1313:	12 00                	adc    (%rax),%al
    1315:	00 26                	add    %ah,(%rsi)
    1317:	bc 0b 41 e3 0f       	mov    $0xfe3410b,%esp
    131c:	00 00                	add    %al,(%rax)
    131e:	00 27                	add    %ah,(%rdi)
    1320:	e8 0c 32 25 bc       	call   ffffffffbc254531 <server_id_map+0x5ffffe43029531>
    1325:	0c 33                	or     $0x33,%al
    1327:	9d                   	popf
    1328:	09 00                	or     %eax,(%rax)
    132a:	00 25 e7 0c 34 2b    	add    %ah,0x2b340ce7(%rip)        # 2b342017 <_license+0x2b33ff7d>
    1330:	0a 00                	or     (%rax),%al
    1332:	00 26                	add    %ah,(%rsi)
    1334:	e9 0c 35 af 0a       	jmp    aaf4845 <_license+0xaaf27ab>
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1339:	00 00                	add    %al,(%rax)
    133b:	21 26                	and    %esp,(%rsi)
    133d:	ea                   	(bad)
    133e:	0c 37                	or     $0x37,%al
    1340:	b2 00                	mov    $0x0,%dl
    1342:	00 00                	add    %al,(%rax)
    1344:	00 00                	add    %al,(%rax)
    1346:	24 eb                	and    $0xeb,%al
  data = (void*)(long)xdp->data;
    1348:	0b e4                	or     %esp,%esp
    134a:	b2 00                	mov    $0x0,%dl
  data_end = (void*)(long)xdp->data_end;
    134c:	00 00                	add    %al,(%rax)
    134e:	25 80 0b e5 9d       	and    $0x9de50b80,%eax
  ip6h = data + sizeof(struct ethhdr);
    1353:	09 00                	or     %eax,(%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1355:	00 25 81 0b e6 9d    	add    %ah,-0x6219f47f(%rip)        # ffffffff9de61edc <server_id_map+0x5ffffe24c36edc>
    135b:	09 00                	or     %eax,(%rax)
    135d:	00 25 d6 0b e7 fa    	add    %ah,-0x518f42a(%rip)        # fffffffffae71f39 <server_id_map+0x5ffffe81c46f39>
    1363:	00 00                	add    %al,(%rax)
    1365:	00 25 96 0b e8 de    	add    %ah,-0x2117f46a(%rip)        # ffffffffdee81f01 <server_id_map+0x5ffffe65c56f01>
    136b:	0f 00 00             	sldt   (%rax)
    136e:	26 d7                	xlat   %ds:(%rbx)
    1370:	0b e9                	or     %ecx,%ebp
    1372:	c6                   	(bad)
    1373:	13 00                	adc    (%rax),%eax
    1375:	00 26                	add    %ah,(%rsi)
    1377:	c9                   	leave
    1378:	0b ea                	or     %edx,%ebp
    137a:	a1 10 00 00 21 26 a0 	movabs 0xf80ba02621000010,%eax
    1381:	0b f8 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1383:	bb 00 00 00 28       	mov    $0x28000000,%ebx
    1388:	04 01                	add    $0x1,%al
    138a:	0b f9                	or     %ecx,%edi
    138c:	81 05 00 00 26 e0 0b 	addl   $0xbbff0b,-0x1fda0000(%rip)        # ffffffffe0261396 <server_id_map+0x5ffffe67036396>
    1393:	ff bb 00 
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1396:	00 00                	add    %al,(%rax)
    1398:	21 26                	and    %esp,(%rsi)
    139a:	ab                   	stos   %eax,%es:(%rdi)
    139b:	0b fa                	or     %edx,%edi
    139d:	9d                   	popf
    139e:	09 00                	or     %eax,(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    13a0:	00 26                	add    %ah,(%rsi)
    13a2:	07                   	(bad)
    13a3:	0b fa                	or     %edx,%edi
    13a5:	46 0f 00 00          	rex.RX sldt (%rax)
    13a9:	21 26                	and    %esp,(%rsi)
  saddr[3] = src ^ port;
    13ab:	ac                   	lods   %ds:(%rsi),%al
    13ac:	0b fa                	or     %edx,%edi
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    13ae:	bb 00 00 00 26       	mov    $0x26000000,%ebx
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    13b3:	14 0b                	adc    $0xb,%al
    13b5:	fa                   	cli
    13b6:	4b 0f 00 00          	rex.WXB sldt (%r8)
  ip6h->priority = (tc & 0xF0) >> 4;
    13ba:	26 ad                	lods   %ds:(%rsi),%eax
    13bc:	0b fa                	or     %edx,%edi
    13be:	4b 0f 00 00          	rex.WXB sldt (%r8)
    13c2:	00 00                	add    %al,(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    13c4:	00 00                	add    %al,(%rax)
    13c6:	0b cb                	or     %ebx,%ecx
    13c8:	13 00                	adc    (%rax),%eax
  ip6h->nexthdr = proto;
    13ca:	00 29                	add    %ch,(%rcx)
    13cc:	03 01                	add    (%rcx),%eax
    13ce:	08 13                	or     %dl,(%rbx)
  ip6h->payload_len = bpf_htons(payload_len);
    13d0:	08 0a                	or     %cl,(%rdx)
    13d2:	ec                   	in     (%dx),%al
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    13d3:	12 01                	adc    (%rcx),%al
    13d5:	00 00                	add    %al,(%rax)
    13d7:	13 0a                	adc    (%rdx),%ecx
    13d9:	00 0a                	add    %cl,(%rdx)
    13db:	ed                   	in     (%dx),%eax
    13dc:	12 01                	adc    (%rcx),%al
    13de:	00 00                	add    %al,(%rax)
    13e0:	13 0b                	adc    (%rbx),%ecx
    13e2:	01 0a                	add    %ecx,(%rdx)
    13e4:	ee                   	out    %al,(%dx)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    13e5:	99                   	cltd
    13e6:	10 00                	adc    %al,(%rax)
    13e8:	00 13                	add    %dl,(%rbx)
    13ea:	0c 02                	or     $0x2,%al
    13ec:	0a ef                	or     %bh,%ch
    13ee:	f5                   	cmc
    13ef:	13 00                	adc    (%rax),%eax
    13f1:	00 13                	add    %dl,(%rbx)
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    13f3:	3f                   	(bad)
    13f4:	04 0f                	add    $0xf,%al
    13f6:	04 13                	add    $0x13,%al
    13f8:	0f 0a                	(bad)
    13fa:	f0 31 14 00          	lock xor %edx,(%rax,%rax,1)
    13fe:	00 13                	add    %dl,(%rbx)
    1400:	10 00                	adc    %al,(%rax)
    1402:	0a f1                	or     %cl,%dh
    1404:	3d 14 00 00 13       	cmp    $0x13000014,%eax
    1409:	11 00                	adc    %eax,(%rax)
    140b:	0a f2                	or     %dl,%dh
    140d:	9b                   	fwait
    140e:	12 00                	adc    (%rax),%al
    1410:	00 13                	add    %dl,(%rbx)
    1412:	12 00                	adc    (%rax),%al
    1414:	0a f3                	or     %bl,%dh
    1416:	49 14 00             	rex.WB adc $0x0,%al
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1419:	00 13                	add    %dl,(%rbx)
    141b:	17                   	(bad)
    141c:	00 0a                	add    %cl,(%rdx)
    141e:	f6 61 14             	mulb   0x14(%rcx)
    1421:	00 00                	add    %al,(%rax)
    1423:	13 28                	adc    (%rax),%ebp
    1425:	00 0a                	add    %cl,(%rdx)
    1427:	fc                   	cld
    1428:	a3 14 00 00 13 3d 00 	movabs %eax,0x3d13000014
    142f:	00 00 
    1431:	04 b8                	add    $0xb8,%al
    1433:	01 00                	add    %eax,(%rax)
    1435:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 149b <balancer_ingress+0x149b>
      if (qpr.server_id > 0) {
    143b:	01 00                	add    %eax,(%rax)
    143d:	04 91                	add    $0x91,%al
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    143f:	10 00                	adc    %al,(%rax)
    1441:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 14a7 <balancer_ingress+0x14a7>
    1447:	02 00                	add    (%rax),%al
    1449:	0d f5 04 13 14       	or     $0x141304f5,%eax
    144e:	0a f4                	or     %ah,%dh
    1450:	91                   	xchg   %eax,%ecx
    1451:	10 00                	adc    %al,(%rax)
    1453:	00 13                	add    %dl,(%rbx)
    1455:	15 00 0a dc 91       	adc    $0x91dc0a00,%eax
    145a:	10 00                	adc    %al,(%rax)
    145c:	00 13                	add    %dl,(%rbx)
    145e:	16                   	(bad)
    145f:	02 00                	add    (%rax),%al
    1461:	0d fb 04 13 19       	or     $0x191304fb,%eax
    if (pckt->flow.proto == IPPROTO_UDP) {
    1466:	23 e1                	and    %ecx,%esp
    1468:	bb 00 00 00 13       	mov    $0x13000000,%ebx
      new_dst_lru.atime = cur_time;
    146d:	1b 04 05 1b 00 23 f7 	sbb    -0x8dcffe5(,%rax,1),%eax
    1474:	bb 00 00 00 13       	mov    $0x13000000,%ebx
BPF_MAP_OPS_INLINE(map_update_elem,,
    1479:	1c 04                	sbb    $0x4,%al
    147b:	01 1a                	add    %ebx,(%rdx)
    147d:	00 23                	add    %ah,(%rbx)
    147f:	f8                   	clc
    1480:	bb 00 00 00 13       	mov    $0x13000000,%ebx
    1485:	1d 04 01 19 00       	sbb    $0x190104,%eax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    148a:	23 f9                	and    %ecx,%edi
    148c:	bb 00 00 00 13       	mov    $0x13000000,%ebx
    1491:	1e                   	(bad)
    1492:	04 01                	add    $0x1,%al
    1494:	18 00                	sbb    %al,(%rax)
    1496:	23 fa                	and    %edx,%edi
    1498:	bb 00 00 00 13       	mov    $0x13000000,%ebx
    149d:	1f                   	(bad)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    149e:	04 18                	add    $0x18,%al
    14a0:	00 00                	add    %al,(%rax)
    14a2:	00 29                	add    %ch,(%rcx)
    14a4:	02 01                	add    (%rcx),%al
    14a6:	04 13                	add    $0x13,%al
    14a8:	2a 0a                	sub    (%rdx),%cl
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    14aa:	ce                   	(bad)
    14ab:	12 01                	adc    (%rcx),%al
    14ad:	00 00                	add    %al,(%rax)
    14af:	13 2b                	adc    (%rbx),%ebp
    14b1:	00 23                	add    %ah,(%rbx)
    14b3:	e1 12                	loope  14c7 <balancer_ingress+0x14c7>
    14b5:	01 00                	add    %eax,(%rax)
    14b7:	00 13                	add    %dl,(%rbx)
  bool vip_match = address_match && port_match && proto_match;
    14b9:	2d 01 03 05 01       	sub    $0x1050301,%eax
    14be:	23 fd                	and    %ebp,%edi
    14c0:	12 01                	adc    (%rcx),%al
    14c2:	00 00                	add    %al,(%rax)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    14c4:	13 2e                	adc    (%rsi),%ebp
    14c6:	01 02                	add    %eax,(%rdx)
    14c8:	03 01                	add    (%rcx),%eax
    14ca:	23 fe                	and    %esi,%edi
    14cc:	12 01                	adc    (%rcx),%al
    14ce:	00 00                	add    %al,(%rax)
    14d0:	13 2f                	adc    (%rdi),%ebp
    14d2:	01 01                	add    %eax,(%rcx)
    14d4:	02 01                	add    (%rcx),%al
    14d6:	23 ff                	and    %edi,%edi
    14d8:	12 01                	adc    (%rcx),%al
    14da:	00 00                	add    %al,(%rax)
    14dc:	13 30                	adc    (%rax),%esi
    14de:	01 01                	add    %eax,(%rcx)
    14e0:	01 01                	add    %eax,(%rcx)
    14e2:	2a 00                	sub    (%rax),%al
    14e4:	01 12                	add    %edx,(%rdx)
    14e6:	01 00                	add    %eax,(%rax)
    14e8:	00 13                	add    %dl,(%rbx)
    14ea:	31 01                	xor    %eax,(%rcx)
    if (!lru_miss_stat) {
    14ec:	01 00                	add    %eax,(%rax)
    14ee:	01 2b                	add    %ebp,(%rbx)
    14f0:	01 01                	add    %eax,(%rcx)
    14f2:	91                   	xchg   %eax,%ecx
    14f3:	10 00                	adc    %al,(%rax)
    *lru_miss_stat += 1;
    14f5:	00 13                	add    %dl,(%rbx)
    14f7:	3c 02                	cmp    $0x2,%al
    14f9:	00 2c 05 01 09 75 18 	add    %ch,0x18750901(,%rax,1)
    1500:	0f 00 00             	sldt   (%rax)
    1503:	25 80 09 76 9d       	and    $0x9d760980,%eax
    1508:	09 00                	or     %eax,(%rax)
    150a:	00 25 81 09 77 9d    	add    %ah,-0x6288f67f(%rip)        # ffffffff9d771e91 <server_id_map+0x5ffffe24546e91>
    1510:	09 00                	or     %eax,(%rax)
    1512:	00 25 94 09 78 18    	add    %ah,0x18780994(%rip)        # 18781eac <_license+0x1877fe12>
      data_stats->v2 += 1;
    1518:	0f 00 00             	sldt   (%rax)
    151b:	25 96 09 79 de       	and    $0xde790996,%eax
    1520:	0f 00 00             	sldt   (%rax)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1523:	26 b1 09             	es mov $0x9,%cl
    1526:	7a 18                	jp     1540 <balancer_ingress+0x1540>
    1528:	0f 00 00             	sldt   (%rax)
    152b:	28 06                	sub    %al,(%rsi)
    152d:	01 09                	add    %ecx,(%rcx)
    152f:	7c 3d                	jl     156e <balancer_ingress+0x156e>
    1531:	15 00 00 26 d6       	adc    $0xd6260000,%eax
  if (!connId) {
    1536:	09 7b fa             	or     %edi,-0x6(%rbx)
    1539:	00 00                	add    %al,(%rax)
    153b:	00 00                	add    %al,(%rax)
    153d:	0b 42 15             	or     0x15(%rdx),%eax
    1540:	00 00                	add    %al,(%rax)
    1542:	29 18                	sub    %ebx,(%rax)
    1544:	01 14 14             	add    %edx,(%rsp,%rdx,1)
    1547:	19 2b                	sbb    %ebp,(%rbx)
    1549:	07                   	(bad)
    154a:	01 91 10 00 00 14    	add    %edx,0x14000010(%rcx)
    1550:	1a 00                	sbb    (%rax),%al
    1552:	2b 08                	sub    (%rax),%ecx
    1554:	01 91 10 00 00 14    	add    %edx,0x14000010(%rcx)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    155a:	1b 02                	sbb    (%rdx),%eax
    155c:	2b 09                	sub    (%rcx),%ecx
        if (real_pos) {
    155e:	01 b8 01 00 00 14    	add    %edi,0x14000001(%rax)
    1564:	1c 04                	sbb    $0x4,%al
    1566:	2b 0a                	sub    (%rdx),%ecx
    1568:	01 b8 01 00 00 14    	add    %edi,0x14000001(%rax)
          key = *real_pos;
    156e:	1d 08 2a 0b 01       	sbb    $0x10b2a08,%eax
    1573:	9c                   	pushf
          if (key == 0) {
    1574:	02 00                	add    (%rax),%al
            pckt.real_index = key;
    1576:	00 14 1f             	add    %dl,(%rdi,%rbx,1)
    1579:	02 01                	add    (%rcx),%al
    157b:	0f 0c                	(bad)
            dst = bpf_map_lookup_elem(&reals, &key);
    157d:	2a 0c 01             	sub    (%rcx,%rax,1),%cl
    1580:	9c                   	pushf
    1581:	02 00                	add    (%rax),%al
    1583:	00 14 20             	add    %dl,(%rax,%riz,1)
    1586:	02 03                	add    (%rbx),%al
    1588:	0c 0c                	or     $0xc,%al
    158a:	2a 0d 01 9c 02 00    	sub    0x29c01(%rip),%cl        # 2b191 <_license+0x290f7>
    1590:	00 14 21             	add    %dl,(%rcx,%riz,1)
    1593:	02 04 08             	add    (%rax,%rcx,1),%al
    1596:	0c 2a                	or     $0x2a,%al
    1598:	0e                   	(bad)
    1599:	01 9c 02 00 00 14 22 	add    %ebx,0x22140000(%rdx,%rax,1)
            if (!dst) {
    15a0:	02 01                	add    (%rcx),%al
    15a2:	07                   	(bad)
    15a3:	0c 2a                	or     $0x2a,%al
    15a5:	0f 01 9c 02 00 00 14 	lidt   0x23140000(%rdx,%rax,1)
    15ac:	23 
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    15ad:	02 01                	add    (%rcx),%al
    15af:	06                   	(bad)
    15b0:	0c 2a                	or     $0x2a,%al
    15b2:	10 01                	adc    %al,(%rcx)
    15b4:	9c                   	pushf
  if (dst_lru) {
    15b5:	02 00                	add    (%rax),%al
    15b7:	00 14 24             	add    %dl,(%rsp)
    15ba:	02 01                	add    (%rcx),%al
    15bc:	05 0c 2a 11 01       	add    $0x1112a0c,%eax
    if (dst_lru->pos == pckt->real_index) {
    15c1:	9c                   	pushf
    15c2:	02 00                	add    (%rax),%al
    15c4:	00 14 25 02 01 04 0c 	add    %dl,0xc040102
              quic_packets_stats->dst_match_in_lru += 1;
    15cb:	2a 12                	sub    (%rdx),%dl
    15cd:	01 9c 02 00 00 14 26 	add    %ebx,0x26140000(%rdx,%rax,1)
    15d4:	02 01                	add    (%rcx),%al
    15d6:	03 0c 2a             	add    (%rdx,%rbp,1),%ecx
    15d9:	13 01                	adc    (%rcx),%eax
    15db:	9c                   	pushf
    15dc:	02 00                	add    (%rax),%al
    15de:	00 14 27             	add    %dl,(%rdi,%riz,1)
    15e1:	02 01                	add    (%rcx),%al
    15e3:	02 0c 2a             	add    (%rdx,%rbp,1),%cl
    15e6:	14 01                	adc    $0x1,%al
    15e8:	9c                   	pushf
    15e9:	02 00                	add    (%rax),%al
  original_sport = pckt.flow.port16[0];
    15eb:	00 14 28             	add    %dl,(%rax,%rbp,1)
    15ee:	02 01                	add    (%rcx),%al
    15f0:	01 0c 2a             	add    %ecx,(%rdx,%rbp,1)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    15f3:	15 01 9c 02 00       	adc    $0x29c01,%eax
        !(vip_info->flags & F_LRU_BYPASS)) {
    15f8:	00 14 29             	add    %dl,(%rcx,%rbp,1)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    15fb:	02 01                	add    (%rcx),%al
    15fd:	00 0c 2b             	add    %cl,(%rbx,%rbp,1)
    1600:	16                   	(bad)
    1601:	01 91 10 00 00 14    	add    %edx,0x14000010(%rcx)
    1607:	39 0e                	cmp    %ecx,(%rsi)
    1609:	0a c3                	or     %bl,%al
    160b:	99                   	cltd
    160c:	10 00                	adc    %al,(%rax)
  if (!dst_lru) {
    160e:	00 14 3a             	add    %dl,(%rdx,%rdi,1)
    1611:	10 2b                	adc    %ch,(%rbx)
    1613:	17                   	(bad)
    1614:	01 91 10 00 00 14    	add    %edx,0x14000010(%rcx)
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    161a:	3b 12                	cmp    (%rdx),%edx
    161c:	00 2c 19             	add    %ch,(%rcx,%rbx,1)
    161f:	01 09                	add    %ecx,(%rcx)
    1621:	49 fa                	rex.WB cli
    cur_time = bpf_ktime_get_ns();
    1623:	00 00                	add    %al,(%rax)
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1625:	00 25 94 09 4a 18    	add    %ah,0x184a0994(%rip)        # 184a1fbf <_license+0x1849ff25>
    162b:	0f 00 00             	sldt   (%rax)
    162e:	25 b1 09 4b 18       	and    $0x184b09b1,%eax
    1633:	0f 00 00             	sldt   (%rax)
    1636:	26 d6                	es (bad)
    1638:	09 4c fa 00          	or     %ecx,0x0(%rdx,%rdi,8)
    163c:	00 00                	add    %al,(%rax)
    163e:	00 2c 1a             	add    %ch,(%rdx,%rbx,1)
    1641:	01 0b                	add    %ecx,(%rbx)
    dst_lru->atime = cur_time;
    1643:	5e                   	pop    %rsi
    1644:	b2 00                	mov    $0x0,%dl
    1646:	00 00                	add    %al,(%rax)
  key = dst_lru->pos;
    1648:	25 80 0b 5f 9d       	and    $0x9d5f0b80,%eax
    164d:	09 00                	or     %eax,(%rax)
    164f:	00 25 81 0b 60 9d    	add    %ah,-0x629ff47f(%rip)        # ffffffff9d6021d6 <server_id_map+0x5ffffe243d71d6>
  pckt->real_index = key;
    1655:	09 00                	or     %eax,(%rax)
  *real = bpf_map_lookup_elem(&reals, &key);
    1657:	00 26                	add    %ah,(%rsi)
    1659:	e6 0b                	out    %al,$0xb
    165b:	63 c0                	movsxd %eax,%eax
    165d:	01 00                	add    %eax,(%rax)
    165f:	00 26                	add    %ah,(%rsi)
    1661:	d6                   	(bad)
    1662:	0b 64 fa 00          	or     0x0(%rdx,%rdi,8),%esp
    1666:	00 00                	add    %al,(%rax)
    1668:	26 c9                	es leave
    166a:	0b 61 a1             	or     -0x5f(%rcx),%esp
    166d:	10 00                	adc    %al,(%rax)
    166f:	00 26                	add    %ah,(%rsi)
    1671:	d7                   	xlat   %ds:(%rbx)
    1672:	0b 62 c6             	or     -0x3a(%rdx),%esp
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1675:	13 00                	adc    (%rax),%eax
    1677:	00 00                	add    %al,(%rax)
    1679:	2c 1b                	sub    $0x1b,%al
    167b:	01 00                	add    %eax,(%rax)
    167d:	cb                   	lret
    167e:	b2 00                	mov    $0x0,%dl
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1680:	00 00                	add    %al,(%rax)
    1682:	25 96 00 cb de       	and    $0xdecb0096,%eax
    1687:	0f 00 00             	sldt   (%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    168a:	25 94 00 cb 18       	and    $0x18cb0094,%eax
    168f:	0f 00 00             	sldt   (%rax)
    1692:	25 aa 00 cb fd       	and    $0xfdcb00aa,%eax
    1697:	16                   	(bad)
    1698:	00 00                	add    %al,(%rax)
    169a:	28 1c 01             	sub    %bl,(%rcx,%rax,1)
    169d:	00 cc                	add    %cl,%ah
    169f:	93                   	xchg   %eax,%ebx
    16a0:	01 00                	add    %eax,(%rax)
    16a2:	00 28                	add    %ch,(%rax)
  if (!conn_rate_stats) {
    16a4:	1d 01 00 d5 b6       	sbb    $0xb6d50001,%eax
    16a9:	00 00                	add    %al,(%rax)
    16ab:	00 26                	add    %ah,(%rsi)
    16ad:	a1 00 cd 81 05 00 00 	movabs 0x262100000581cd00,%eax
    16b4:	21 26 
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    16b6:	ab                   	stos   %eax,%es:(%rdi)
    16b7:	00 d5                	add    %dl,%ch
    16b9:	9d                   	popf
    16ba:	09 00                	or     %eax,(%rax)
    16bc:	00 26                	add    %ah,(%rsi)
    16be:	07                   	(bad)
    16bf:	00 d5                	add    %dl,%ch
    16c1:	46 0f 00 00          	rex.RX sldt (%rax)
    16c5:	00 21                	add    %ah,(%rcx)
    conn_rate_stats->v1 = 1;
    16c7:	26 a0 00 d9 bb 00 00 	es movabs 0x2621000000bbd900,%al
    16ce:	00 21 26 
    conn_rate_stats->v2 = *cur_time;
    16d1:	ab                   	stos   %eax,%es:(%rdi)
    16d2:	00 da                	add    %bl,%dl
    conn_rate_stats->v1 += 1;
    16d4:	9d                   	popf
    16d5:	09 00                	or     %eax,(%rax)
    16d7:	00 26                	add    %ah,(%rsi)
    16d9:	07                   	(bad)
    16da:	00 da                	add    %bl,%dl
    16dc:	46 0f 00 00          	rex.RX sldt (%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    16e0:	21 26                	and    %esp,(%rsi)
    16e2:	ac                   	lods   %ds:(%rsi),%al
    16e3:	00 da                	add    %bl,%dl
    16e5:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    16ea:	14 00                	adc    $0x0,%al
    16ec:	da 4b 0f             	fimull 0xf(%rbx)
    16ef:	00 00                	add    %al,(%rax)
    16f1:	26 ad                	lods   %ds:(%rsi),%eax
    16f3:	00 da                	add    %bl,%dl
    16f5:	4b 0f 00 00          	rex.WXB sldt (%r8)
    16f9:	00 00                	add    %al,(%rax)
    16fb:	00 00                	add    %al,(%rax)
    if (down_reals_map) {
    16fd:	0b 18                	or     (%rax),%ebx
    16ff:	0f 00 00             	sldt   (%rax)
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1702:	2d 1e 01 06 98       	sub    $0x9806011e,%eax
    1707:	01 9d 09 00 00 2e    	add    %ebx,0x2e000009(%rbp)
    170d:	1f                   	(bad)
    170e:	01 06                	add    %eax,(%rsi)
      if (down_real) {
    1710:	98                   	cwtl
    1711:	01 9d 09 00 00 1f    	add    %ebx,0x1f000009(%rbp)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1717:	09 06                	or     %eax,(%rsi)
    1719:	98                   	cwtl
    171a:	01 9d 09 00 00 00    	add    %ebx,0x9(%rbp)
    1720:	2c 20                	sub    $0x20,%al
    1722:	01 09                	add    %ecx,(%rcx)
    1724:	5b                   	pop    %rbx
    1725:	18 0f                	sbb    %cl,(%rdi)
    1727:	00 00                	add    %al,(%rax)
    1729:	25 80 09 5c 9d       	and    $0x9d5c0980,%eax
    172e:	09 00                	or     %eax,(%rax)
        if (stats_data) {
    1730:	00 25 81 09 5d 9d    	add    %ah,-0x62a2f67f(%rip)        # ffffffff9d5d20b7 <server_id_map+0x5ffffe243a70b7>
    1736:	09 00                	or     %eax,(%rax)
          stats_data->v1 += 1;
    1738:	00 25 94 09 5e 18    	add    %ah,0x185e0994(%rip)        # 185e20d2 <_license+0x185e0038>
    173e:	0f 00 00             	sldt   (%rax)
    if (!dst) {
    1741:	25 96 09 5f de       	and    $0xde5f0996,%eax
    1746:	0f 00 00             	sldt   (%rax)
    1749:	26 b1 09             	es mov $0x9,%cl
    174c:	60                   	(bad)
    174d:	18 0f                	sbb    %cl,(%rdi)
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    174f:	00 00                	add    %al,(%rax)
    1751:	28 21                	sub    %ah,(%rcx)
    1753:	01 09                	add    %ecx,(%rcx)
    1755:	62 63 17 00 00       	(bad)
    175a:	26 d6                	es (bad)
    175c:	09 61 fa             	or     %esp,-0x6(%rcx)
    175f:	00 00                	add    %al,(%rax)
    1761:	00 00                	add    %al,(%rax)
    1763:	0b 68 17             	or     0x17(%rax),%ebp
    1766:	00 00                	add    %al,(%rax)
    1768:	29 23                	sub    %esp,(%rbx)
    176a:	01 08                	add    %ecx,(%rax)
    176c:	15 17 2b 07 01       	adc    $0x1072b17,%eax
    1771:	91                   	xchg   %eax,%ecx
    1772:	10 00                	adc    %al,(%rax)
    1774:	00 15 18 00 2b 08    	add    %dl,0x82b0018(%rip)        # 82b1792 <_license+0x82af6f8>
  if (!data_stats) {
    177a:	01 91 10 00 00 15    	add    %edx,0x15000010(%rcx)
    1780:	19 02                	sbb    %eax,(%rdx)
    1782:	2b 22                	sub    (%rdx),%esp
    1784:	01 91 10 00 00 15    	add    %edx,0x15000010(%rcx)
  data_stats->v1 += 1;
    178a:	1a 04 0a             	sbb    (%rdx,%rcx,1),%al
    178d:	c3                   	ret
  data_stats->v2 += pkt_bytes;
    178e:	99                   	cltd
    178f:	10 00                	adc    %al,(%rax)
    1791:	00 15 1b 06 00 2d    	add    %dl,0x2d00061b(%rip)        # 2d001db2 <_license+0x2cfffd18>
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1797:	24 01                	and    $0x1,%al
    1799:	09 53 01             	or     %edx,0x1(%rbx)
    179c:	50                   	push   %rax
    179d:	0f 00 00             	sldt   (%rax)
    17a0:	1f                   	(bad)
    17a1:	80 09 54             	orb    $0x54,(%rcx)
    17a4:	01 9d 09 00 00 1f    	add    %ebx,0x1f000009(%rbp)
    17aa:	81 09 55 01 9d 09    	orl    $0x99d0155,(%rcx)
    17b0:	00 00                	add    %al,(%rax)
    17b2:	1f                   	(bad)
    17b3:	94                   	xchg   %eax,%esp
    17b4:	09 56 01             	or     %edx,0x1(%rsi)
    17b7:	18 0f                	sbb    %cl,(%rdi)
    17b9:	00 00                	add    %al,(%rax)
    17bb:	1f                   	(bad)
    17bc:	96                   	xchg   %eax,%esi
    17bd:	09 57 01             	or     %edx,0x1(%rdi)
    17c0:	de 0f                	fimuls (%rdi)
  if (!data_stats) {
    17c2:	00 00                	add    %al,(%rax)
    17c4:	2f                   	(bad)
    17c5:	25 01 09 58 01       	and    $0x1580901,%eax
  data_stats->v1 += 1;
    17ca:	50                   	push   %rax
    17cb:	0f 00 00             	sldt   (%rax)
  data_stats->v2 += pkt_bytes;
    17ce:	2f                   	(bad)
    17cf:	26 01 09             	es add %ecx,(%rcx)
  pckt.flow.port16[0] = original_sport;
    17d2:	67 01 69 09          	add    %ebp,0x9(%ecx)
    17d6:	00 00                	add    %al,(%rax)
  if (dst->flags & F_IPV6) {
    17d8:	2f                   	(bad)
    17d9:	27                   	(bad)
    17da:	01 09                	add    %ecx,(%rcx)
    17dc:	68 01 69 09 00       	push   $0x96901
    17e1:	00 2f                	add    %ch,(%rdi)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    17e3:	28 01                	sub    %al,(%rcx)
    17e5:	09 69 01             	or     %ebp,0x1(%rcx)
    17e8:	69 09 00 00 2f 29    	imul   $0x292f0000,(%rcx),%ecx
    17ee:	01 09                	add    %ecx,(%rcx)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    17f0:	8c 01                	mov    %es,(%rcx)
    17f2:	12 01                	adc    (%rcx),%al
    17f4:	00 00                	add    %al,(%rax)
    17f6:	20 b1 09 5f 01 18    	and    %dh,0x18015f09(%rcx)
    17fc:	0f 00 00             	sldt   (%rax)
    17ff:	20 d6                	and    %dl,%dh
  data = (void*)(long)xdp->data;
    1801:	09 60 01             	or     %esp,0x1(%rax)
    1804:	fa                   	cli
  data_end = (void*)(long)xdp->data_end;
    1805:	00 00                	add    %al,(%rax)
    1807:	00 21                	add    %ah,(%rcx)
  iph = data + sizeof(struct ethhdr);
    1809:	2f                   	(bad)
    180a:	2a 01                	sub    (%rcx),%al
    180c:	09 7b 01             	or     %edi,0x1(%rbx)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    180f:	c9                   	leave
    1810:	0a 00                	or     (%rax),%al
    1812:	00 00                	add    %al,(%rax)
    1814:	00 2d 2b 01 0b 44    	add    %ch,0x440b012b(%rip)        # 440b1945 <_license+0x440af8ab>
    181a:	01 18                	add    %ebx,(%rax)
    181c:	0f 00 00             	sldt   (%rax)
    181f:	1f                   	(bad)
    1820:	80 0b 44             	orb    $0x44,(%rbx)
    1823:	01 9d 09 00 00 1f    	add    %ebx,0x1f000009(%rbp)
    1829:	81 0b 44 01 9d 09    	orl    $0x99d0144,(%rbx)
    182f:	00 00                	add    %al,(%rax)
    1831:	1f                   	(bad)
    1832:	94                   	xchg   %eax,%esp
    1833:	0b 44 01 18          	or     0x18(%rcx,%rax,1),%eax
    1837:	0f 00 00             	sldt   (%rax)
    183a:	20 d6                	and    %dl,%dh
    183c:	0b 45 01             	or     0x1(%rbp),%eax
    183f:	fa                   	cli
    1840:	00 00                	add    %al,(%rax)
    1842:	00 21                	add    %ah,(%rcx)
    1844:	20 d7                	and    %dl,%bh
  memcpy(new_eth->h_dest, cval->mac, 6);
    1846:	0b 47 01             	or     0x1(%rdi),%eax
    1849:	c6                   	(bad)
    184a:	13 00                	adc    (%rax),%eax
    184c:	00 00                	add    %al,(%rax)
    184e:	21 20                	and    %esp,(%rax)
    1850:	d7                   	xlat   %ds:(%rbx)
    1851:	0b 4c 01 15          	or     0x15(%rcx,%rax,1),%ecx
    1855:	12 00                	adc    (%rax),%al
    1857:	00 00                	add    %al,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1859:	00 30                	add    %dh,(%rax)
    185b:	2c 01                	sub    $0x1,%al
    185d:	00 b0 31 2d 01 00    	add    %dh,0x12d31(%rax)
    1863:	b1 c8                	mov    $0xc8,%cl
    1865:	18 00                	sbb    %al,(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    1867:	00 25 96 00 b2 de    	add    %ah,-0x214dff6a(%rip)        # ffffffffdeb21903 <server_id_map+0x5ffffe658f6903>
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    186d:	0f 00 00             	sldt   (%rax)
    1870:	25 a3 00 b3 9d       	and    $0x9db300a3,%eax
  iph->ihl = 5;
    1875:	09 00                	or     %eax,(%rax)
  iph->tos = tos;
    1877:	00 31                	add    %dh,(%rcx)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1879:	2e 01 00             	cs add %eax,(%rax)
    187c:	b4 18                	mov    $0x18,%ah
    187e:	0f 00 00             	sldt   (%rax)
    1881:	28 2f                	sub    %ch,(%rdi)
    1883:	01 00                	add    %eax,(%rax)
    1885:	b5 90                	mov    $0x90,%ch
  iph->id = 0;
    1887:	03 00                	add    (%rax),%eax
    1889:	00 28                	add    %ch,(%rax)
    188b:	30 01                	xor    %al,(%rcx)
    188d:	00 b6 fa 00 00 00    	add    %dh,0xfa(%rsi)
  iph->saddr = saddr;
    1893:	26 09 00             	es or  %eax,(%rax)
  iph->ttl = DEFAULT_TTL;
    1896:	b7 bb                	mov    $0xbb,%bh
    1898:	00 00                	add    %al,(%rax)
    189a:	00 21                	add    %ah,(%rcx)
    189c:	26 ab                	es stos %eax,%es:(%rdi)
    189e:	00 c5                	add    %al,%ch
    18a0:	9d                   	popf
    18a1:	09 00                	or     %eax,(%rax)
    18a3:	00 26                	add    %ah,(%rsi)
    18a5:	07                   	(bad)
    18a6:	00 c5                	add    %al,%ch
    18a8:	46 0f 00 00          	rex.RX sldt (%rax)
    18ac:	21 26                	and    %esp,(%rsi)
    18ae:	ac                   	lods   %ds:(%rsi),%al
    18af:	00 c5                	add    %al,%ch
    18b1:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    18b6:	14 00                	adc    $0x0,%al
    18b8:	c5 4b 0f             	(bad)
    18bb:	00 00                	add    %al,(%rax)
    18bd:	26 ad                	lods   %ds:(%rsi),%eax
    18bf:	00 c5                	add    %al,%ch
    18c1:	4b 0f 00 00          	rex.WXB sldt (%r8)
    18c5:	00 00                	add    %al,(%rax)
    18c7:	00 0b                	add    %cl,(%rbx)
    18c9:	ee                   	out    %al,(%dx)
    18ca:	04 00                	add    $0x0,%al
    18cc:	00 2d 31 01 00 8c    	add    %ch,-0x73fffecf(%rip)        # ffffffff8c001a03 <server_id_map+0x5ffffe12dd6a03>
    18d2:	02 b2 00 00 00 1f    	add    0x1f000000(%rdx),%dh
    18d8:	2a 00                	sub    (%rax),%al
    18da:	8d 02                	lea    (%rdx),%eax
    18dc:	c8 18 00 00          	enter  $0x18,$0x0
    18e0:	1f                   	(bad)
    18e1:	96                   	xchg   %eax,%esi
    18e2:	00 8e 02 de 0f 00    	add    %cl,0xfde02(%rsi)
    18e8:	00 1f                	add    %bl,(%rdi)
    18ea:	9f                   	lahf
    18eb:	00 8f 02 a8 02 00    	add    %cl,0x2a802(%rdi)
    18f1:	00 1f                	add    %bl,(%rdi)
    18f3:	1d 00 90 02 60       	sbb    $0x60029000,%eax
    18f8:	02 00                	add    (%rax),%al
    18fa:	00 2f                	add    %ch,(%rdi)
    18fc:	30 01                	xor    %al,(%rcx)
    18fe:	00 91 02 fa 00 00    	add    %dl,0xfa02(%rcx)
    1904:	00 21                	add    %ah,(%rcx)
    1906:	2f                   	(bad)
    1907:	32 01                	xor    (%rcx),%al
    1909:	00 95 02 9d 09 00    	add    %dl,0x99d02(%rbp)
    190f:	00 21                	add    %ah,(%rcx)
    1911:	20 ab 00 95 02 9d    	and    %ch,-0x62fd6b00(%rbx)
    1917:	09 00                	or     %eax,(%rax)
    1919:	00 20                	add    %ah,(%rax)
    191b:	07                   	(bad)
    191c:	00 95 02 46 0f 00    	add    %dl,0xf4602(%rbp)
    1922:	00 00                	add    %al,(%rax)
    1924:	21 2f                	and    %ebp,(%rdi)
    1926:	33 01                	xor    (%rcx),%eax
    1928:	00 97 02 9d 09 00    	add    %dl,0x99d02(%rdi)
    192e:	00 21                	add    %ah,(%rcx)
      if (pckt.flow.proto == IPPROTO_TCP) {
    1930:	20 a0 00 9c 02 bb    	and    %ah,-0x44fd6400(%rax)
    1936:	00 00                	add    %al,(%rax)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1938:	00 2f                	add    %ch,(%rdi)
    193a:	34 01                	xor    $0x1,%al
    193c:	00 9d 02 81 05 00    	add    %bl,0x58102(%rbp)
    1942:	00 21                	add    %ah,(%rcx)
    1944:	20 ab 00 9d 02 9d    	and    %ch,-0x62fd6300(%rbx)
    194a:	09 00                	or     %eax,(%rax)
    194c:	00 20                	add    %ah,(%rax)
    194e:	07                   	(bad)
    194f:	00 9d 02 46 0f 00    	add    %bl,0xf4602(%rbp)
        if (!lru_stats) {
    1955:	00 21                	add    %ah,(%rcx)
    1957:	20 ac 00 9d 02 bb 00 	and    %ch,0xbb029d(%rax,%rax,1)
        if (pckt.flags & F_SYN_SET) {
    195e:	00 00                	add    %al,(%rax)
    1960:	20 14 00             	and    %dl,(%rax,%rax,1)
    1963:	9d                   	popf
    1964:	02 4b 0f             	add    0xf(%rbx),%cl
    1967:	00 00                	add    %al,(%rax)
    1969:	20 ad 00 9d 02 4b    	and    %ch,0x4b029d00(%rbp)
  struct real_pos_lru new_dst_lru = {};
    196f:	0f 00 00             	sldt   (%rax)
    1972:	00 00                	add    %al,(%rax)
    1974:	00 00                	add    %al,(%rax)
    1976:	00 00                	add    %al,(%rax)
    1978:	2c 35                	sub    $0x35,%al
    197a:	01 00                	add    %eax,(%rax)
    197c:	26 18 0f             	es sbb %cl,(%rdi)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    197f:	00 00                	add    %al,(%rax)
    1981:	31 30                	xor    %esi,(%rax)
    1983:	01 00                	add    %eax,(%rax)
    1985:	27                   	(bad)
    1986:	2b 0a                	sub    (%rdx),%ecx
    1988:	00 00                	add    %al,(%rax)
    198a:	28 36                	sub    %dh,(%rsi)
    198c:	01 00                	add    %eax,(%rax)
    198e:	28 bb 00 00 00 28    	sub    %bh,0x28000000(%rbx)
    1994:	37                   	(bad)
    1995:	01 00                	add    %eax,(%rax)
    1997:	29 81 05 00 00 21    	sub    %eax,0x21000005(%rcx)
  if (!conn_rate_stats) {
    199d:	26 ab                	es stos %eax,%es:(%rdi)
    199f:	00 2a                	add    %ch,(%rdx)
    19a1:	9d                   	popf
    19a2:	09 00                	or     %eax,(%rax)
    19a4:	00 26                	add    %ah,(%rsi)
  *cur_time = bpf_ktime_get_ns();
    19a6:	07                   	(bad)
    19a7:	00 2a                	add    %ch,(%rdx)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    19a9:	46 0f 00 00          	rex.RX sldt (%rax)
    19ad:	21 26                	and    %esp,(%rsi)
    19af:	ac                   	lods   %ds:(%rsi),%al
    19b0:	00 2a                	add    %ch,(%rdx)
    19b2:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    19b7:	14 00                	adc    $0x0,%al
    conn_rate_stats->v1 = 1;
    19b9:	2a 4b 0f             	sub    0xf(%rbx),%cl
    19bc:	00 00                	add    %al,(%rax)
    19be:	26 ad                	lods   %ds:(%rsi),%eax
    conn_rate_stats->v2 = *cur_time;
    19c0:	00 2a                	add    %ch,(%rdx)
    19c2:	4b 0f 00 00          	rex.WXB sldt (%r8)
    19c6:	00 00                	add    %al,(%rax)
    19c8:	00 32                	add    %dh,(%rdx)
    conn_rate_stats->v1 += 1;
    19ca:	38 01                	cmp    %al,(%rcx)
    19cc:	00 7e 02             	add    %bh,0x2(%rsi)
    19cf:	1f                   	(bad)
    19d0:	25 00 7e 02 bb       	and    $0xbb027e00,%eax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    19d5:	00 00                	add    %al,(%rax)
    19d7:	00 2e                	add    %ch,(%rsi)
    19d9:	39 01                	cmp    %eax,(%rcx)
    19db:	00 7e 02             	add    %bh,0x2(%rsi)
    19de:	18 0f                	sbb    %cl,(%rdi)
    19e0:	00 00                	add    %al,(%rax)
    19e2:	2e 3a 01             	cs cmp (%rcx),%al
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    19e5:	00 7e 02             	add    %bh,0x2(%rsi)
    19e8:	18 0f                	sbb    %cl,(%rdi)
    19ea:	00 00                	add    %al,(%rax)
    19ec:	2f                   	(bad)
    b += *(u32*)(k + 4);
    19ed:	3b 01                	cmp    (%rcx),%eax
    19ef:	00 7f 02             	add    %bh,0x2(%rdi)
    c += *(u32*)(k + 8);
    19f2:	81 05 00 00 21 20 ab 	addl   $0x28000ab,0x20210000(%rip)        # 202119fc <_license+0x2020f962>
    19f9:	00 80 02 
      a += (u32)k[2] << 16;
    19fc:	9d                   	popf
    19fd:	09 00                	or     %eax,(%rax)
      a += (u32)k[1] << 8;
    19ff:	00 20                	add    %ah,(%rax)
    1a01:	07                   	(bad)
    1a02:	00 80 02 46 0f 00    	add    %al,0xf4602(%rax)
      a += k[0];
    1a08:	00 21                	add    %ah,(%rcx)
    1a0a:	20 14 00             	and    %dl,(%rax,%rax,1)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1a0d:	80 02 4b             	addb   $0x4b,(%rdx)
    1a10:	0f 00 00             	sldt   (%rax)
    1a13:	20 ad 00 80 02 4b    	and    %ch,0x4b028000(%rbp)
      memset(pckt->flow.srcv6, 0, 16);
    1a19:	0f 00 00             	sldt   (%rax)
    1a1c:	20 ac 00 80 02 bb 00 	and    %ch,0xbb0280(%rax,%rax,1)
    1a23:	00 00                	add    %al,(%rax)
    1a25:	00 00                	add    %al,(%rax)
    1a27:	00 2c 3c             	add    %ch,(%rsp,%rdi,1)
    1a2a:	01 0d 58 18 0f 00    	add    %ecx,0xf1858(%rip)        # f3288 <_license+0xf11ee>
    1a30:	00 25 92 0d 59 45    	add    %ah,0x45590d92(%rip)        # 455927c8 <_license+0x4559072e>
    1a36:	0a 00                	or     (%rax),%al
    c += *(u32*)(k + 8);
    1a38:	00 25 a6 0d 5a c7    	add    %ah,-0x38a5f25a(%rip)        # ffffffffc75a27e4 <server_id_map+0x5ffffe4e3777e4>
    __jhash_mix(a, b, c);
    1a3e:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1a40:	00 25 96 0d 5b de    	add    %ah,-0x21a4f26a(%rip)        # ffffffffde5b27dc <server_id_map+0x5ffffe653877dc>
    b += *(u32*)(k + 4);
    1a46:	0f 00 00             	sldt   (%rax)
    1a49:	25 2a 0d 5c ee       	and    $0xee5c0d2a,%eax
    __jhash_mix(a, b, c);
    1a4e:	04 00                	add    $0x0,%al
    1a50:	00 25 a4 0d 5d bb    	add    %ah,-0x44a2f25c(%rip)        # ffffffffbb5d27fa <server_id_map+0x5ffffe423a77fa>
    1a56:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1a58:	00 26                	add    %ah,(%rsi)
    1a5a:	bc 0d 60 e3 0f       	mov    $0xfe3600d,%esp
    __jhash_mix(a, b, c);
    1a5f:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1a61:	28 3d 01 0d 63 bb    	sub    %bh,-0x449cf2ff(%rip)        # ffffffffbb632768 <server_id_map+0x5ffffe42407768>
    __jhash_mix(a, b, c);
    1a67:	00 00                	add    %al,(%rax)
    1a69:	00 26                	add    %ah,(%rsi)
    1a6b:	e7 0d                	out    %eax,$0xd
  return (word << shift) | (word >> ((-shift) & 31));
    1a6d:	64 fa                	fs cli
    1a6f:	00 00                	add    %al,(%rax)
    1a71:	00 26                	add    %ah,(%rsi)
    __jhash_mix(a, b, c);
    1a73:	80 0d 5e 9d 09 00 00 	orb    $0x0,0x99d5e(%rip)        # 9b7d8 <_license+0x9973e>
  return (word << shift) | (word >> ((-shift) & 31));
    1a7a:	26 81 0d 5f 9d 09 00 	es orl $0x13e2800,0x99d5f(%rip)        # 9b7e4 <_license+0x9974a>
    1a81:	00 28 3e 01 
    1a85:	0d 61 95 1a 00       	or     $0x1a9561,%eax
    __jhash_mix(a, b, c);
    1a8a:	00 28                	add    %ch,(%rax)
      a += (u32)k[3] << 24;
    1a8c:	43 01 0d 62 95 1a 00 	rex.XB add %ecx,0x1a9562(%rip)        # 1aaff5 <_license+0x1a8f5b>
      a += (u32)k[2] << 16;
    1a93:	00 00                	add    %al,(%rax)
    1a95:	0b 9a 1a 00 00 29    	or     0x2900001a(%rdx),%ebx
      a += (u32)k[3] << 24;
    1a9b:	42 01 0e             	rex.X add %ecx,(%rsi)
      a += (u32)k[1] << 8;
    1a9e:	16                   	(bad)
    1a9f:	ad                   	lods   %ds:(%rsi),%eax
    1aa0:	2b 3f                	sub    (%rdi),%edi
    1aa2:	01 bf 1a 00 00 16    	add    %edi,0x1600001a(%rdi)
      a += k[0];
    1aa8:	ae                   	scas   %es:(%rdi),%al
      a += (u32)k[1] << 8;
    1aa9:	00 2b                	add    %ch,(%rbx)
      a += k[0];
    1aab:	40 01 bf 1a 00 00 16 	rex add %edi,0x1600001a(%rdi)
  return (word << shift) | (word >> ((-shift) & 31));
    1ab2:	af                   	scas   %es:(%rdi),%eax
    1ab3:	06                   	(bad)
    1ab4:	2b 41 01             	sub    0x1(%rcx),%eax
      __jhash_final(a, b, c);
    1ab7:	91                   	xchg   %eax,%ecx
    1ab8:	10 00                	adc    %al,(%rax)
    1aba:	00 16                	add    %dl,(%rsi)
  return (word << shift) | (word >> ((-shift) & 31));
    1abc:	b0 0c                	mov    $0xc,%al
    1abe:	00 04 1a             	add    %al,(%rdx,%rbx,1)
      __jhash_final(a, b, c);
    1ac1:	01 00                	add    %eax,(%rax)
    1ac3:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 1b29 <balancer_ingress+0x1b29>
    1ac9:	06                   	(bad)
    1aca:	00 30                	add    %dh,(%rax)
    1acc:	44 01 0e             	add    %r9d,(%rsi)
  return (word << shift) | (word >> ((-shift) & 31));
    1acf:	31 25 bc 0e 32 e3    	xor    %esp,-0x1ccdf144(%rip)        # ffffffffe3322991 <server_id_map+0x5ffffe6a0f7991>
      __jhash_final(a, b, c);
    1ad5:	0f 00 00             	sldt   (%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1ad8:	25 99 0e 33 12       	and    $0x12330e99,%eax
      __jhash_final(a, b, c);
    1add:	01 00                	add    %eax,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1adf:	00 25 c5 0e 34 bb    	add    %ah,-0x44cbf13b(%rip)        # ffffffffbb3429aa <server_id_map+0x5ffffe421179aa>
      __jhash_final(a, b, c);
    1ae5:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1ae7:	00 25 c6 0e 35 bb    	add    %ah,-0x44caf13a(%rip)        # ffffffffbb3529b3 <server_id_map+0x5ffffe421279b3>
  a += initval;
    1aed:	00 00                	add    %al,(%rax)
    1aef:	00 25 a4 0e 36 9c    	add    %ah,-0x63c9f15c(%rip)        # ffffffff9c362999 <server_id_map+0x5ffffe23137999>
    1af5:	02 00                	add    (%rax),%al
    1af7:	00 25 22 0e 37 12    	add    %ah,0x12370e22(%rip)        # 1237291f <_license+0x12370885>
  __jhash_final(a, b, c);
    1afd:	01 00                	add    %eax,(%rax)
    1aff:	00 26                	add    %ah,(%rsi)
    1b01:	e7 0e                	out    %eax,$0xe
  return (word << shift) | (word >> ((-shift) & 31));
    1b03:	38 fa                	cmp    %bh,%dl
    1b05:	00 00                	add    %al,(%rax)
  __jhash_final(a, b, c);
    1b07:	00 00                	add    %al,(%rax)
    1b09:	2c 45                	sub    $0x45,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1b0b:	01 00                	add    %eax,(%rax)
    1b0d:	57                   	push   %rdi
    1b0e:	18 0f                	sbb    %cl,(%rdi)
  __jhash_final(a, b, c);
    1b10:	00 00                	add    %al,(%rax)
    1b12:	31 2d 01 00 58 c8    	xor    %ebp,-0x37a7ffff(%rip)        # ffffffffc8581b19 <server_id_map+0x5ffffe4f356b19>
  return (word << shift) | (word >> ((-shift) & 31));
    1b18:	18 00                	sbb    %al,(%rax)
  __jhash_final(a, b, c);
    1b1a:	00 25 96 00 59 de    	add    %ah,-0x21a6ff6a(%rip)        # ffffffffde591bb6 <server_id_map+0x5ffffe65366bb6>
  return (word << shift) | (word >> ((-shift) & 31));
    1b20:	0f 00 00             	sldt   (%rax)
  __jhash_final(a, b, c);
    1b23:	25 9f 00 5a a8       	and    $0xa85a009f,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1b28:	02 00                	add    (%rax),%al
    1b2a:	00 25 94 00 5b 18    	add    %ah,0x185b0094(%rip)        # 185b1bc4 <_license+0x185afb2a>
    1b30:	0f 00 00             	sldt   (%rax)
  __jhash_final(a, b, c);
    1b33:	25 a3 00 5c 9d       	and    $0x9d5c00a3,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1b38:	09 00                	or     %eax,(%rax)
  __jhash_final(a, b, c);
    1b3a:	00 28                	add    %ch,(%rax)
    1b3c:	46 01 00             	rex.RX add %r8d,(%rax)
    1b3f:	5e                   	pop    %rsi
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1b40:	95                   	xchg   %eax,%ebp
    1b41:	03 00                	add    (%rax),%eax
    1b43:	00 28                	add    %ch,(%rax)
    1b45:	47 01 00             	rex.RXB add %r8d,(%r8)
    1b48:	5f                   	pop    %rdi
    1b49:	18 0f                	sbb    %cl,(%rdi)
    1b4b:	00 00                	add    %al,(%rax)
    1b4d:	28 48 01             	sub    %cl,0x1(%rax)
    1b50:	00 60 18             	add    %ah,0x18(%rax)
    1b53:	0f 00 00             	sldt   (%rax)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1b56:	28 30                	sub    %dh,(%rax)
    1b58:	01 00                	add    %eax,(%rax)
    1b5a:	62                   	(bad)
    1b5b:	fa                   	cli
    1b5c:	00 00                	add    %al,(%rax)
    1b5e:	00 28                	add    %ch,(%rax)
    1b60:	49 01 00             	add    %rax,(%r8)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1b63:	63 bb 00 00 00 26    	movsxd 0x26000000(%rbx),%edi
    if (!real_pos) {
    1b69:	09 00                	or     %eax,(%rax)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1b6b:	64 bb 00 00 00 26    	fs mov $0x26000000,%ebx
    1b71:	b9 00 61 b6 00       	mov    $0xb66100,%ecx
    key = *real_pos;
    1b76:	00 00                	add    %al,(%rax)
    1b78:	21 28                	and    %ebp,(%rax)
    1b7a:	4a 01 00             	rex.WX add %rax,(%rax)
    1b7d:	86 18                	xchg   %bl,(%rax)
    1b7f:	0f 00 00             	sldt   (%rax)
  pckt->real_index = key;
    1b82:	21 26                	and    %esp,(%rsi)
    1b84:	ab                   	stos   %eax,%es:(%rdi)
    1b85:	00 92 9d 09 00 00    	add    %dl,0x99d(%rdx)
  *real = bpf_map_lookup_elem(&reals, &key);
    1b8b:	26 07                	es (bad)
  if (!(*real)) {
    1b8d:	00 92 46 0f 00 00    	add    %dl,0xf46(%rdx)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1b93:	21 26                	and    %esp,(%rsi)
    1b95:	ac                   	lods   %ds:(%rsi),%al
    1b96:	00 92 bb 00 00 00    	add    %dl,0xbb(%rdx)
    1b9c:	26 14 00             	es adc $0x0,%al
    1b9f:	92                   	xchg   %eax,%edx
    1ba0:	4b 0f 00 00          	rex.WXB sldt (%r8)
    1ba4:	26 ad                	lods   %ds:(%rsi),%eax
    1ba6:	00 92 4b 0f 00 00    	add    %dl,0xf4b(%rdx)
  if (!ch_drop_stats) {
    1bac:	00 00                	add    %al,(%rax)
    1bae:	00 21                	add    %ah,(%rcx)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1bb0:	26 ab                	es stos %eax,%es:(%rdi)
    1bb2:	00 9f 9d 09 00 00    	add    %bl,0x99d(%rdi)
    1bb8:	26 07                	es (bad)
    1bba:	00 9f 46 0f 00 00    	add    %bl,0xf46(%rdi)
    1bc0:	21 26                	and    %esp,(%rsi)
    1bc2:	ac                   	lods   %ds:(%rsi),%al
    1bc3:	00 9f bb 00 00 00    	add    %bl,0xbb(%rdi)
  if (!ch_drop_stats) {
    1bc9:	26 14 00             	es adc $0x0,%al
    1bcc:	9f                   	lahf
    1bcd:	4b 0f 00 00          	rex.WXB sldt (%r8)
    1bd1:	26 ad                	lods   %ds:(%rsi),%eax
    1bd3:	00 9f 4b 0f 00 00    	add    %bl,0xf4b(%rdi)
    1bd9:	00 00                	add    %al,(%rax)
}
    1bdb:	00 2c 4b             	add    %ch,(%rbx,%rcx,2)
    1bde:	01 00                	add    %eax,(%rax)
    1be0:	19 bb 00 00 00 25    	sbb    %edi,0x25000000(%rbx)
    1be6:	96                   	xchg   %eax,%esi
    1be7:	00 1a                	add    %bl,(%rdx)
    1be9:	de 0f                	fimuls (%rdi)
    1beb:	00 00                	add    %al,(%rax)
    1bed:	31 4a 01             	xor    %ecx,0x1(%rdx)
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1bf0:	00 1b                	add    %bl,(%rbx)
    1bf2:	18 0f                	sbb    %cl,(%rdi)
    1bf4:	00 00                	add    %al,(%rax)
    1bf6:	00 2c 4c             	add    %ch,(%rsp,%rcx,2)
    1bf9:	01 0a                	add    %ecx,(%rdx)
    1bfb:	66 45 0b 00          	or     (%r8),%r8w
    1bff:	00 31                	add    %dh,(%rcx)
    1c01:	4d 01 0a             	add    %r9,(%r10)
    1c04:	66 45 0b 00          	or     (%r8),%r8w
    1c08:	00 31                	add    %dh,(%rcx)
    1c0a:	4e 01 0a             	rex.WRX add %r9,(%rdx)
    1c0d:	66 45 0b 00          	or     (%r8),%r8w
    1c11:	00 31                	add    %dh,(%rcx)
    1c13:	4f 01 0a             	rex.WRXB add %r9,(%r10)
    1c16:	66 45 0b 00          	or     (%r8),%r8w
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1c1a:	00 31                	add    %dh,(%rcx)
    1c1c:	50                   	push   %rax
    1c1d:	01 0a                	add    %ecx,(%rdx)
    1c1f:	66 45 0b 00          	or     (%r8),%r8w
    1c23:	00 00                	add    %al,(%rax)
    1c25:	2c 51                	sub    $0x51,%al
    1c27:	01 0a                	add    %ecx,(%rdx)
  data = (void*)(long)xdp->data;
    1c29:	6e                   	outsb  %ds:(%rsi),(%dx)
    1c2a:	45 0b 00             	or     (%r8),%r8d
  data_end = (void*)(long)xdp->data_end;
    1c2d:	00 31                	add    %dh,(%rcx)
    1c2f:	4d 01 0a             	add    %r9,(%r10)
  ip6h = data + sizeof(struct ethhdr);
    1c32:	6e                   	outsb  %ds:(%rsi),(%dx)
    1c33:	45 0b 00             	or     (%r8),%r8d
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1c36:	00 31                	add    %dh,(%rcx)
    1c38:	4e 01 0a             	rex.WRX add %r9,(%rdx)
    1c3b:	6e                   	outsb  %ds:(%rsi),(%dx)
    1c3c:	45 0b 00             	or     (%r8),%r8d
    1c3f:	00 31                	add    %dh,(%rcx)
    1c41:	50                   	push   %rax
    1c42:	01 0a                	add    %ecx,(%rdx)
    1c44:	6e                   	outsb  %ds:(%rsi),(%dx)
    1c45:	45 0b 00             	or     (%r8),%r8d
    1c48:	00 00                	add    %al,(%rax)
    1c4a:	2c 52                	sub    $0x52,%al
    1c4c:	01 0a                	add    %ecx,(%rdx)
    1c4e:	07                   	(bad)
    1c4f:	bb 00 00 00 31       	mov    $0x31000000,%ebx
  memcpy(new_eth->h_dest, cval->mac, 6);
    1c54:	53                   	push   %rbx
    1c55:	01 0a                	add    %ecx,(%rdx)
    1c57:	07                   	(bad)
    1c58:	bb 00 00 00 31       	mov    $0x31000000,%ebx
    1c5d:	54                   	push   %rsp
    1c5e:	01 0a                	add    %ecx,(%rdx)
    1c60:	07                   	(bad)
    1c61:	c3                   	ret
    1c62:	00 00                	add    %al,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1c64:	00 00                	add    %al,(%rax)
    1c66:	33 55 01             	xor    0x1(%rbp),%edx
    1c69:	00 42 28             	add    %al,0x28(%rdx)
    1c6c:	56                   	push   %rsi
    1c6d:	01 00                	add    %eax,(%rax)
    1c6f:	43 bb 00 00 00 28    	rex.XB mov $0x28000000,%r11d
  new_eth->h_proto = BE_ETH_P_IPV6;
    1c75:	57                   	push   %rdi
    1c76:	01 00                	add    %eax,(%rax)
    1c78:	44 81 05 00 00 21 26 	rex.R addl $0x9d4500ab,0x26210000(%rip)        # 26211c83 <_license+0x2620fbe9>
    1c7f:	ab 00 45 9d 
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    1c83:	09 00                	or     %eax,(%rax)
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1c85:	00 26                	add    %ah,(%rsi)
    1c87:	07                   	(bad)
    1c88:	00 45 46             	add    %al,0x46(%rbp)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1c8b:	0f 00 00             	sldt   (%rax)
    1c8e:	21 26                	and    %esp,(%rsi)
  ip6h->priority = (tc & 0xF0) >> 4;
    1c90:	ac                   	lods   %ds:(%rsi),%al
    1c91:	00 45 bb             	add    %al,-0x45(%rbp)
    1c94:	00 00                	add    %al,(%rax)
    1c96:	00 26                	add    %ah,(%rsi)
    1c98:	14 00                	adc    $0x0,%al
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1c9a:	45                   	rex.RB
    1c9b:	4b 0f 00 00          	rex.WXB sldt (%r8)
    1c9f:	26 ad                	lods   %ds:(%rsi),%eax
  ip6h->nexthdr = proto;
    1ca1:	00 45 4b             	add    %al,0x4b(%rbp)
    1ca4:	0f 00 00             	sldt   (%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    1ca7:	00 00                	add    %al,(%rax)
    1ca9:	00 33                	add    %dh,(%rbx)
    1cab:	58                   	pop    %rax
    1cac:	01 00                	add    %eax,(%rax)
    1cae:	4d 28 56 01          	rex.WRB sub %r10b,0x1(%r14)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    1cb2:	00 4e bb             	add    %cl,-0x45(%rsi)
    1cb5:	00 00                	add    %al,(%rax)
    1cb7:	00 28                	add    %ch,(%rax)
    1cb9:	57                   	push   %rdi
    1cba:	01 00                	add    %eax,(%rax)
    1cbc:	4f 81 05 00 00 21 26 	rex.WRXB addq $0xffffffff9d5000ab,0x26210000(%rip)        # 26211cc7 <_license+0x2620fc2d>
    1cc3:	ab 00 50 9d 
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    1cc7:	09 00                	or     %eax,(%rax)
    1cc9:	00 26                	add    %ah,(%rsi)
    1ccb:	07                   	(bad)
    1ccc:	00 50 46             	add    %dl,0x46(%rax)
    1ccf:	0f 00 00             	sldt   (%rax)
    1cd2:	21 26                	and    %esp,(%rsi)
    1cd4:	ac                   	lods   %ds:(%rsi),%al
    1cd5:	00 50 bb             	add    %dl,-0x45(%rax)
    if (pckt->flow.proto == IPPROTO_UDP) {
    1cd8:	00 00                	add    %al,(%rax)
    1cda:	00 26                	add    %ah,(%rsi)
    1cdc:	14 00                	adc    $0x0,%al
      new_dst_lru.atime = cur_time;
    1cde:	50                   	push   %rax
    1cdf:	4b 0f 00 00          	rex.WXB sldt (%r8)
    new_dst_lru.pos = key;
    1ce3:	26 ad                	lods   %ds:(%rsi),%eax
    1ce5:	00 50 4b             	add    %dl,0x4b(%rax)
    1ce8:	0f 00 00             	sldt   (%rax)
BPF_MAP_OPS_INLINE(map_update_elem,,
    1ceb:	00 00                	add    %al,(%rax)
    1ced:	00 2c 59             	add    %ch,(%rcx,%rbx,2)
    1cf0:	01 0d 2a 18 0f 00    	add    %ecx,0xf182a(%rip)        # f3520 <_license+0xf1486>
    1cf6:	00 25 92 0d 2b 45    	add    %ah,0x452b0d92(%rip)        # 452b2a8e <_license+0x452b09f4>
    1cfc:	0a 00                	or     (%rax),%al
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    1cfe:	00 25 a6 0d 2c c7    	add    %ah,-0x38d3f25a(%rip)        # ffffffffc72c2aaa <server_id_map+0x5ffffe4e097aaa>
    1d04:	00 00                	add    %al,(%rax)
    1d06:	00 25 94 0d 2d 18    	add    %ah,0x182d0d94(%rip)        # 182d2aa0 <_license+0x182d0a06>
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    1d0c:	0f 00 00             	sldt   (%rax)
    1d0f:	25 96 0d 2e de       	and    $0xde2e0d96,%eax
    1d14:	0f 00 00             	sldt   (%rax)
    1d17:	25 2a 0d 2f ee       	and    $0xee2f0d2a,%eax
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    1d1c:	04 00                	add    $0x0,%al
    1d1e:	00 25 a4 0d 30 bb    	add    %ah,-0x44cff25c(%rip)        # ffffffffbb302ac8 <server_id_map+0x5ffffe420d7ac8>
    1d24:	00 00                	add    %al,(%rax)
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    1d26:	00 26                	add    %ah,(%rsi)
    1d28:	80 0d 31 9d 09 00 00 	orb    $0x0,0x99d31(%rip)        # 9ba60 <_license+0x999c6>
    1d2f:	26 81 0d 32 9d 09 00 	es orl $0x13e2800,0x99d32(%rip)        # 9ba6c <_license+0x999d2>
    1d36:	00 28 3e 01 
    1d3a:	0d 34 95 1a 00       	or     $0x1a9534,%eax
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1d3f:	00 26                	add    %ah,(%rsi)
    1d41:	c9                   	leave
    1d42:	0d 33 a1 10 00       	or     $0x10a133,%eax
    1d47:	00 28                	add    %ch,(%rax)
    1d49:	43 01 0d 35 95 1a 00 	rex.XB add %ecx,0x1a9535(%rip)        # 1ab285 <_license+0x1a91eb>
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1d50:	00 26                	add    %ah,(%rsi)
    1d52:	22 0d 38 12 01 00    	and    0x11238(%rip),%cl        # 12f90 <_license+0x10ef6>
  bool vip_match = address_match && port_match && proto_match;
    1d58:	00 26                	add    %ah,(%rsi)
    1d5a:	c5 0d 37             	(bad)
    1d5d:	6a 1d                	push   $0x1d
    1d5f:	00 00                	add    %al,(%rax)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1d61:	26 cc                	es int3
    1d63:	0d 36 9c 02 00       	or     $0x29c36,%eax
    1d68:	00 00                	add    %al,(%rax)
    1d6a:	04 bb                	add    $0xbb,%al
    1d6c:	00 00                	add    %al,(%rax)
    1d6e:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 1dd4 <balancer_ingress+0x1dd4>
    1d74:	04 00                	add    $0x0,%al
    1d76:	30 5a 01             	xor    %bl,0x1(%rdx)
    1d79:	0e                   	(bad)
    1d7a:	21 25 1f 0e 21 9c    	and    %esp,-0x63def1e1(%rip)        # ffffffff9c212b9f <server_id_map+0x5ffffe22fe7b9f>
    1d80:	02 00                	add    (%rax),%al
    1d82:	00 25 28 0e 21 b8    	add    %ah,-0x47def1d8(%rip)        # ffffffffb8212bb0 <server_id_map+0x5ffffe3efe7bb0>
    1d88:	01 00                	add    %eax,(%rax)
    if (!lru_miss_stat) {
    1d8a:	00 25 c5 0e 21 b6    	add    %ah,-0x49def13b(%rip)        # ffffffffb6212c55 <server_id_map+0x5ffffe3cfe7c55>
    1d90:	00 00                	add    %al,(%rax)
    *lru_miss_stat += 1;
    1d92:	00 00                	add    %al,(%rax)
    1d94:	30 5b 01             	xor    %bl,0x1(%rbx)
    1d97:	0e                   	(bad)
    1d98:	4c 25 c9 0e 4d a1    	rex.WR and $0xffffffffa14d0ec9,%rax
    1d9e:	10 00                	adc    %al,(%rax)
    1da0:	00 31                	add    %dh,(%rcx)
    1da2:	5c                   	pop    %rsp
    1da3:	01 0e                	add    %ecx,(%rsi)
    1da5:	4e 12 01             	rex.WRX adc (%rcx),%r8b
    1da8:	00 00                	add    %al,(%rax)
    1daa:	25 c5 0e 4f b6       	and    $0xb64f0ec5,%eax
    1daf:	00 00                	add    %al,(%rax)
    1db1:	00 25 c6 0e 50 b6    	add    %ah,-0x49aff13a(%rip)        # ffffffffb6502c7d <server_id_map+0x5ffffe3d2d7c7d>
      data_stats->v2 += 1;
    1db7:	00 00                	add    %al,(%rax)
    1db9:	00 25 cc 0e 51 9c    	add    %ah,-0x63aef134(%rip)        # ffffffff9c512c8b <server_id_map+0x5ffffe232e7c8b>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1dbf:	02 00                	add    (%rax),%al
    1dc1:	00 25 22 0e 52 12    	add    %ah,0x12520e22(%rip)        # 12522be9 <_license+0x12520b4f>
    1dc7:	01 00                	add    %eax,(%rax)
    1dc9:	00 00                	add    %al,(%rax)
    1dcb:	32 5d 01             	xor    0x1(%rbp),%bl
    1dce:	00 35 02 1f b3 00    	add    %dh,0xb31f02(%rip)        # b33cd6 <_license+0xb31c3c>
    1dd4:	36 02 a4 06 00 00 1f 	ss add -0x49e10000(%rsi,%rax,1),%ah
    1ddb:	b6 
    1ddc:	00 37                	add    %dh,(%rdi)
    1dde:	02 12                	add    (%rdx),%dl
    1de0:	01 00                	add    %eax,(%rax)
    1de2:	00 00                	add    %al,(%rax)
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1de4:	2d 5e 01 06 9d       	sub    $0x9d06015e,%eax
    1de9:	01 b2 00 00 00 2e    	add    %esi,0x2e000000(%rdx)
    1def:	1f                   	(bad)
    1df0:	01 06                	add    %eax,(%rsi)
    1df2:	9d                   	popf
    1df3:	01 9d 09 00 00 1f    	add    %ebx,0x1f000009(%rbp)
    1df9:	09 06                	or     %eax,(%rsi)
    1dfb:	9d                   	popf
    1dfc:	01 9d 09 00 00 1f    	add    %ebx,0x1f000009(%rbp)
      if (qpr.server_id > 0) {
    1e02:	0c 06                	or     $0x6,%al
    1e04:	9d                   	popf
    1e05:	01 9d 09 00 00 1f    	add    %ebx,0x1f000009(%rbp)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1e0b:	24 06                	and    $0x6,%al
    1e0d:	9d                   	popf
    1e0e:	01 02                	add    %eax,(%rdx)
    1e10:	01 00                	add    %eax,(%rax)
    1e12:	00 00                	add    %al,(%rax)
    1e14:	2d 5f 01 00 43       	sub    $0x4300015f,%eax
    1e19:	02 b2 00 00 00 1f    	add    0x1f000000(%rdx),%dh
    1e1f:	1d 00 44 02 60       	sbb    $0x60024400,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1e24:	02 00                	add    (%rax),%al
    1e26:	00 1f                	add    %bl,(%rdi)
    1e28:	96                   	xchg   %eax,%esi
    1e29:	00 45 02             	add    %al,0x2(%rbp)
    1e2c:	de 0f                	fimuls (%rdi)
    1e2e:	00 00                	add    %al,(%rax)
    1e30:	1f                   	(bad)
    1e31:	9f                   	lahf
    1e32:	00 46 02             	add    %al,0x2(%rsi)
    1e35:	a8 02                	test   $0x2,%al
    1e37:	00 00                	add    %al,(%rax)
    1e39:	1f                   	(bad)
  if (!conn_rate_stats) {
    1e3a:	94                   	xchg   %eax,%esp
    1e3b:	00 47 02             	add    %al,0x2(%rdi)
    1e3e:	18 0f                	sbb    %cl,(%rdi)
    1e40:	00 00                	add    %al,(%rax)
    1e42:	2f                   	(bad)
    1e43:	60                   	(bad)
    1e44:	01 00                	add    %eax,(%rax)
    1e46:	4a 02 60 02          	rex.WX add 0x2(%rax),%spl
  *cur_time = bpf_ktime_get_ns();
    1e4a:	00 00                	add    %al,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1e4c:	2f                   	(bad)
    1e4d:	61                   	(bad)
    1e4e:	01 00                	add    %eax,(%rax)
    1e50:	49 02 bb 00 00 00 2f 	rex.WB add 0x2f000000(%r11),%dil
    1e57:	62 01                	(bad)
    1e59:	00 4f 02             	add    %cl,0x2(%rdi)
    1e5c:	18 0f                	sbb    %cl,(%rdi)
    1e5e:	00 00                	add    %al,(%rax)
    conn_rate_stats->v1 = 1;
    1e60:	2f                   	(bad)
    1e61:	63 01                	movsxd (%rcx),%eax
    1e63:	00 55 02             	add    %dl,0x2(%rbp)
    1e66:	18 0f                	sbb    %cl,(%rdi)
    conn_rate_stats->v2 = *cur_time;
    1e68:	00 00                	add    %al,(%rax)
    1e6a:	2f                   	(bad)
    1e6b:	64 01 00             	add    %eax,%fs:(%rax)
    1e6e:	56                   	push   %rsi
    1e6f:	02 18                	add    (%rax),%bl
    1e71:	0f 00 00             	sldt   (%rax)
    1e74:	2f                   	(bad)
    1e75:	65 01 00             	add    %eax,%gs:(%rax)
    1e78:	57                   	push   %rdi
    1e79:	02 18                	add    (%rax),%bl
    1e7b:	0f 00 00             	sldt   (%rax)
    1e7e:	21 20                	and    %esp,(%rax)
    1e80:	af                   	scas   %es:(%rdi),%eax
    1e81:	00 59 02             	add    %bl,0x2(%rcx)
    1e84:	bb 00 00 00 2f       	mov    $0x2f000000,%ebx
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1e89:	66 01 00             	add    %ax,(%rax)
    1e8c:	5a                   	pop    %rdx
    1e8d:	02 b6 00 00 00 21    	add    0x21000000(%rsi),%dh
    1e93:	20 ab 00 5a 02 9d    	and    %ch,-0x62fda600(%rbx)
    1e99:	09 00                	or     %eax,(%rax)
          key = *real_pos;
    1e9b:	00 20                	add    %ah,(%rax)
    1e9d:	07                   	(bad)
    1e9e:	00 5a 02             	add    %bl,0x2(%rdx)
    1ea1:	46 0f 00 00          	rex.RX sldt (%rax)
          if (key == 0) {
    1ea5:	21 20                	and    %esp,(%rax)
            pckt.real_index = key;
    1ea7:	ac                   	lods   %ds:(%rsi),%al
    1ea8:	00 5a 02             	add    %bl,0x2(%rdx)
    1eab:	bb 00 00 00 20       	mov    $0x20000000,%ebx
            dst = bpf_map_lookup_elem(&reals, &key);
    1eb0:	14 00                	adc    $0x0,%al
    1eb2:	5a                   	pop    %rdx
    1eb3:	02 4b 0f             	add    0xf(%rbx),%cl
    1eb6:	00 00                	add    %al,(%rax)
    1eb8:	20 ad 00 5a 02 4b    	and    %ch,0x4b025a00(%rbp)
    1ebe:	0f 00 00             	sldt   (%rax)
    1ec1:	00 00                	add    %al,(%rax)
    1ec3:	00 21                	add    %ah,(%rcx)
    1ec5:	20 ab 00 4b 02 9d    	and    %ch,-0x62fdb500(%rbx)
    1ecb:	09 00                	or     %eax,(%rax)
            if (!dst) {
    1ecd:	00 20                	add    %ah,(%rax)
    1ecf:	07                   	(bad)
    1ed0:	00 4b 02             	add    %cl,0x2(%rbx)
    1ed3:	46 0f 00 00          	rex.RX sldt (%rax)
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    1ed7:	21 20                	and    %esp,(%rax)
    1ed9:	ac                   	lods   %ds:(%rsi),%al
    1eda:	00 4b 02             	add    %cl,0x2(%rbx)
    1edd:	bb 00 00 00 20       	mov    $0x20000000,%ebx
  if (dst_lru) {
    1ee2:	14 00                	adc    $0x0,%al
    1ee4:	4b 02 4b 0f          	rex.WXB add 0xf(%r11),%cl
    1ee8:	00 00                	add    %al,(%rax)
    1eea:	20 ad 00 4b 02 4b    	and    %ch,0x4b024b00(%rbp)
    if (dst_lru->pos == pckt->real_index) {
    1ef0:	0f 00 00             	sldt   (%rax)
    1ef3:	00 00                	add    %al,(%rax)
    1ef5:	00 2d 67 01 00 67    	add    %ch,0x67000167(%rip)        # 67002062 <_license+0x66ffffc8>
              quic_packets_stats->dst_match_in_lru += 1;
    1efb:	02 b2 00 00 00 1f    	add    0x1f000000(%rdx),%dh
    1f01:	96                   	xchg   %eax,%esi
    1f02:	00 68 02             	add    %ch,0x2(%rax)
    1f05:	de 0f                	fimuls (%rdi)
    1f07:	00 00                	add    %al,(%rax)
    1f09:	1f                   	(bad)
    1f0a:	a3 00 69 02 9d 09 00 	movabs %eax,0x2f0000099d026900
    1f11:	00 2f 
    1f13:	46 01 00             	rex.RX add %r8d,(%rax)
    1f16:	77 02                	ja     1f1a <balancer_ingress+0x1f1a>
    1f18:	95                   	xchg   %eax,%ebp
    1f19:	03 00                	add    (%rax),%eax
    1f1b:	00 2f                	add    %ch,(%rdi)
      dst_lru->pos = pckt->real_index;
    1f1d:	2f                   	(bad)
    1f1e:	01 00                	add    %eax,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1f20:	6a 02                	push   $0x2
    1f22:	90                   	nop
    1f23:	03 00                	add    (%rax),%eax
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1f25:	00 2f                	add    %ch,(%rdi)
    1f27:	30 01                	xor    %al,(%rcx)
    1f29:	00 73 02             	add    %dh,0x2(%rbx)
    1f2c:	fa                   	cli
    1f2d:	00 00                	add    %al,(%rax)
    1f2f:	00 00                	add    %al,(%rax)
    1f31:	2c 68                	sub    $0x68,%al
    1f33:	01 0a                	add    %ecx,(%rdx)
    1f35:	37                   	(bad)
    1f36:	45 0b 00             	or     (%r8),%r8d
    1f39:	00 25 09 0a 37 79    	add    %ah,0x79370a09(%rip)        # 79372948 <_license+0x793708ae>
    1f3f:	1f                   	(bad)
    1f40:	00 00                	add    %al,(%rax)
    1f42:	31 69 01             	xor    %ebp,0x1(%rcx)
    1f45:	0a 37                	or     (%rdi),%dh
    1f47:	45 0b 00             	or     (%r8),%r8d
    1f4a:	00 31                	add    %dh,(%rcx)
    1f4c:	50                   	push   %rax
    1f4d:	01 0a                	add    %ecx,(%rdx)
  if (!per_vip_stats) {
    1f4f:	37                   	(bad)
    1f50:	45 0b 00             	or     (%r8),%r8d
    per_vip_stats->v2 += 1;
    1f53:	00 28                	add    %ch,(%rax)
    1f55:	4f 01 0a             	rex.WRXB add %r9,(%r10)
    1f58:	38 45 0b             	cmp    %al,0xb(%rbp)
    conn_rate_stats->v1 += 1;
    1f5b:	00 00                	add    %al,(%rax)
    1f5d:	28 4d 01             	sub    %cl,0x1(%rbp)
    1f60:	0a 38                	or     (%rax),%bh
    1f62:	45 0b 00             	or     (%r8),%r8d
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1f65:	00 28                	add    %ch,(%rax)
    1f67:	4e 01 0a             	rex.WRX add %r9,(%rdx)
    1f6a:	38 45 0b             	cmp    %al,0xb(%rbp)
  struct real_pos_lru new_dst_lru = {};
    1f6d:	00 00                	add    %al,(%rax)
    1f6f:	28 6a 01             	sub    %ch,0x1(%rdx)
    1f72:	0a 39                	or     (%rcx),%bh
    1f74:	7f 1f                	jg     1f95 <balancer_ingress+0x1f95>
    1f76:	00 00                	add    %al,(%rax)
    1f78:	00 0b                	add    %cl,(%rbx)
    1f7a:	7e 1f                	jle    1f9b <balancer_ingress+0x1f9b>
    1f7c:	00 00                	add    %al,(%rax)
  new_dst_lru.pos = pckt->real_index;
    1f7e:	34 0b                	xor    $0xb,%al
    1f80:	84 1f                	test   %bl,(%rdi)
    1f82:	00 00                	add    %al,(%rax)
    1f84:	22 1a                	and    (%rdx),%bl
    1f86:	01 00                	add    %eax,(%rax)
    1f88:	00 35 14 9a 20 00    	add    %dh,0x209a14(%rip)        # 20b9a2 <_license+0x209908>
BPF_MAP_OPS_INLINE(map_update_elem,,
    1f8e:	00 01                	add    %al,(%rcx)
    1f90:	57                   	push   %rdi
    1f91:	70 01                	jo     1f94 <balancer_ingress+0x1f94>
    1f93:	00 36                	add    %dh,(%rsi)
    1f95:	04 b2                	add    $0xb2,%al
    1f97:	00 00                	add    %al,(%rax)
    1f99:	00 36                	add    %dh,(%rsi)
    1f9b:	00 71 01             	add    %dh,0x1(%rcx)
              quic_packets_stats->dst_not_found_in_lru += 1;
    1f9e:	00 36                	add    %dh,(%rsi)
    1fa0:	04 45                	add    $0x45,%al
    1fa2:	0a 00                	or     (%rax),%al
    1fa4:	00 37                	add    %dh,(%rdi)
    1fa6:	01 80 00 37 04 9d    	add    %eax,-0x62fbc900(%rax)
  original_sport = pckt.flow.port16[0];
    1fac:	09 00                	or     %eax,(%rax)
    1fae:	00 37                	add    %dh,(%rdi)
    1fb0:	02 81 00 38 04 9d    	add    -0x62fbc800(%rcx),%al
    1fb6:	09 00                	or     %eax,(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1fb8:	00 38                	add    %bh,(%rax)
    1fba:	03 72 01             	add    0x1(%rdx),%esi
    1fbd:	00 39                	add    %bh,(%rcx)
    1fbf:	04 95                	add    $0x95,%al
    1fc1:	1a 00                	sbb    (%rax),%al
    1fc3:	00 37                	add    %dh,(%rdi)
    1fc5:	04 93                	add    $0x93,%al
    1fc7:	00 3b                	add    %bh,(%rbx)
    1fc9:	04 bb                	add    $0xbb,%al
    1fcb:	00 00                	add    %al,(%rax)
    1fcd:	00 38                	add    %bh,(%rax)
    1fcf:	05 73 01 00 3a       	add    $0x3a000173,%eax
  if (!conn_rate_stats) {
    1fd4:	04 bb                	add    $0xbb,%al
    1fd6:	00 00                	add    %al,(%rax)
    1fd8:	00 39                	add    %bh,(%rcx)
    1fda:	4d 0b 00             	or     (%r8),%r8
    1fdd:	00 00                	add    %al,(%rax)
    1fdf:	00 46 04             	add    %al,0x4(%rsi)
  *cur_time = bpf_ktime_get_ns();
    1fe2:	0c 3a                	or     $0x3a,%al
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1fe4:	06                   	(bad)
    1fe5:	56                   	push   %rsi
    1fe6:	0b 00                	or     (%rax),%eax
    1fe8:	00 3a                	add    %bh,(%rdx)
    1fea:	07                   	(bad)
    1feb:	5f                   	pop    %rdi
    1fec:	0b 00                	or     (%rax),%eax
    1fee:	00 3a                	add    %bh,(%rdx)
    1ff0:	08 68 0b             	or     %ch,0xb(%rax)
    conn_rate_stats->v1 = 1;
    1ff3:	00 00                	add    %al,(%rax)
    1ff5:	3b 02                	cmp    (%rdx),%eax
    1ff7:	91                   	xchg   %eax,%ecx
    1ff8:	08 71 0b             	or     %dh,0xb(%rcx)
    conn_rate_stats->v2 = *cur_time;
    1ffb:	00 00                	add    %al,(%rax)
    1ffd:	3b 03                	cmp    (%rbx),%eax
    1fff:	91                   	xchg   %eax,%ecx
      dst_lru->pos = pckt->real_index;
    2000:	e8 00 7a 0b 00       	call   b9a05 <_license+0xb796b>
              quic_packets_stats->dst_mismatch_in_lru += 1;
    2005:	00 3c 09             	add    %bh,(%rcx,%rcx,1)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2008:	83 0b 00             	orl    $0x0,(%rbx)
    200b:	00 3c 0a             	add    %bh,(%rdx,%rcx,1)
    200e:	8c 0b                	mov    %cs,(%rbx)
    2010:	00 00                	add    %al,(%rax)
    2012:	3c 0b                	cmp    $0xb,%al
    2014:	95                   	xchg   %eax,%ebp
    2015:	0b 00                	or     (%rax),%eax
    2017:	00 3c 14             	add    %bh,(%rsp,%rdx,1)
    201a:	9e                   	sahf
    201b:	0b 00                	or     (%rax),%eax
    201d:	00 3c 15 a7 0b 00 00 	add    %bh,0xba7(,%rdx,1)
    2024:	3c 44                	cmp    $0x44,%al
    2026:	b0 0b                	mov    $0xb,%al
    2028:	00 00                	add    %al,(%rax)
    202a:	3c 45                	cmp    $0x45,%al
    202c:	b9 0b 00 00 3c       	mov    $0x3c00000b,%ecx
  if (!per_vip_stats) {
    2031:	8d 01                	lea    (%rcx),%eax
    2033:	c2 0b 00             	ret    $0xb
    per_vip_stats->v2 += 1;
    2036:	00 3c 8e             	add    %bh,(%rsi,%rcx,4)
    2039:	01 cb                	add    %ecx,%ebx
    203b:	0b 00                	or     (%rax),%eax
    conn_rate_stats->v1 += 1;
    203d:	00 3c 90             	add    %bh,(%rax,%rdx,4)
    2040:	01 d4                	add    %edx,%esp
    2042:	0b 00                	or     (%rax),%eax
    2044:	00 3c 92             	add    %bh,(%rdx,%rdx,4)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2047:	01 dd                	add    %ebx,%ebp
    2049:	0b 00                	or     (%rax),%eax
    204b:	00 3c 9a             	add    %bh,(%rdx,%rbx,4)
  struct real_pos_lru new_dst_lru = {};
    204e:	01 e6                	add    %esp,%esi
    2050:	0b 00                	or     (%rax),%eax
    2052:	00 3c d0             	add    %bh,(%rax,%rdx,8)
    2055:	01 ef                	add    %ebp,%edi
    2057:	0b 00                	or     (%rax),%eax
    2059:	00 3c f7             	add    %bh,(%rdi,%rsi,8)
    205c:	02 f8                	add    %al,%bh
    205e:	0b 00                	or     (%rax),%eax
  new_dst_lru.pos = pckt->real_index;
    2060:	00 3d 15 19 00 00    	add    %bh,0x1915(%rip)        # 397b <_license+0x18e1>
    2066:	00 3c 0c             	add    %bh,(%rsp,%rcx,1)
    2069:	1d 0c 00 00 00       	sbb    $0xc,%eax
    206e:	39 71 0f             	cmp    %esi,0xf(%rcx)
    2071:	00 00                	add    %al,(%rax)
    2073:	01 00                	add    %eax,(%rax)
    2075:	bd 02 0c 3a 16       	mov    $0x163a0c02,%ebp
    207a:	7a 0f                	jp     208b <balancer_ingress+0x208b>
    207c:	00 00                	add    %al,(%rax)
    207e:	3a 17                	cmp    (%rdi),%dl
              quic_packets_stats->dst_not_found_in_lru += 1;
    2080:	8c 0f                	mov    %cs,(%rdi)
    2082:	00 00                	add    %al,(%rax)
    2084:	3a 18                	cmp    (%rax),%bl
    2086:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    2087:	0f 00 00             	sldt   (%rax)
            quic_packets_stats->cid_routed += 1;
    208a:	3a 19                	cmp    (%rcx),%bl
    208c:	b0 0f                	mov    $0xf,%al
    208e:	00 00                	add    %al,(%rax)
  original_sport = pckt.flow.port16[0];
    2090:	3a 1a                	cmp    (%rdx),%bl
    2092:	b9 0f 00 00 3c       	mov    $0x3c00000f,%ecx
    2097:	1b c2                	sbb    %edx,%eax
    2099:	0f 00 00             	sldt   (%rax)
    209c:	00 39                	add    %bh,(%rcx)
    209e:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    209f:	12 00                	adc    (%rax),%al
    20a1:	00 02                	add    %al,(%rdx)
    20a3:	00 c2                	add    %al,%dl
    20a5:	02 0c 3a             	add    (%rdx,%rdi,1),%cl
    20a8:	46 b0 12             	rex.RX mov $0x12,%al
    20ab:	00 00                	add    %al,(%rax)
    20ad:	3a 47 b9             	cmp    -0x47(%rdi),%al
    20b0:	12 00                	adc    (%rax),%al
    20b2:	00 3a                	add    %bh,(%rdx)
    20b4:	48 c2 12 00          	rex.W ret $0x12
    20b8:	00 3a                	add    %bh,(%rdx)
    20ba:	49 cb                	rex.WB lretq
    20bc:	12 00                	adc    (%rax),%al
    20be:	00 3a                	add    %bh,(%rdx)
    20c0:	4a d4                	rex.WX (bad)
    20c2:	12 00                	adc    (%rax),%al
    20c4:	00 39                	add    %bh,(%rcx)
    20c6:	87 11                	xchg   %edx,(%rcx)
    20c8:	00 00                	add    %al,(%rax)
    20ca:	03 0b                	add    (%rbx),%ecx
    20cc:	5c                   	pop    %rsp
    20cd:	01 0c 3a             	add    %ecx,(%rdx,%rdi,1)
    20d0:	1c 90                	sbb    $0x90,%al
    20d2:	11 00                	adc    %eax,(%rax)
    20d4:	00 3a                	add    %bh,(%rdx)
    20d6:	1d 99 11 00 00       	sbb    $0x1199,%eax
    20db:	3a 1e                	cmp    (%rsi),%bl
    20dd:	a2 11 00 00 3a 1f ab 	movabs %al,0x11ab1f3a000011
    20e4:	11 00 
    20e6:	00 3c 20             	add    %bh,(%rax,%riz,1)
    20e9:	b4 11                	mov    $0x11,%ah
    20eb:	00 00                	add    %al,(%rax)
    20ed:	3c 78                	cmp    $0x78,%al
    20ef:	bd 11 00 00 3e       	mov    $0x3e000011,%ebp
    20f4:	de 12                	ficoms (%rdx)
    20f6:	00 00                	add    %al,(%rax)
    20f8:	16                   	(bad)
    20f9:	51                   	push   %rcx
    20fa:	00 00                	add    %al,(%rax)
    20fc:	00 0b                	add    %cl,(%rbx)
    20fe:	1f                   	(bad)
    20ff:	01 0c 3f             	add    %ecx,(%rdi,%rdi,1)
    2102:	01 53 e6             	add    %edx,-0x1a(%rbx)
    2105:	12 00                	adc    (%rax),%al
    2107:	00 3f                	add    %bh,(%rdi)
    2109:	01 5f ee             	add    %ebx,-0x12(%rdi)
    210c:	12 00                	adc    (%rax),%al
    210e:	00 3c 21             	add    %bh,(%rcx,%riz,1)
    2111:	f6 12                	notb   (%rdx)
    2113:	00 00                	add    %al,(%rax)
    2115:	40 00 fe             	add    %dil,%sil
    2118:	12 00                	adc    (%rax),%al
    211a:	00 40 22             	add    %al,0x22(%rax)
    211d:	06                   	(bad)
    211e:	13 00                	adc    (%rax),%eax
    2120:	00 3b                	add    %bh,(%rbx)
    2122:	01 5c 0e 13          	add    %ebx,0x13(%rsi,%rcx,1)
    2126:	00 00                	add    %al,(%rax)
    2128:	41 1f                	rex.B (bad)
    212a:	13 00                	adc    (%rax),%eax
    212c:	00 17                	add    %dl,(%rdi)
    212e:	38 00                	cmp    %al,(%rax)
    2130:	00 00                	add    %al,(%rax)
    2132:	0b 59 03             	or     0x3(%rcx),%ebx
    2135:	3c 23                	cmp    $0x23,%al
    2137:	33 13                	xor    (%rbx),%edx
    2139:	00 00                	add    %al,(%rax)
    213b:	3d 17 38 00 00       	cmp    $0x3817,%eax
    2140:	00 3c 22             	add    %bh,(%rdx,%riz,1)
    2143:	3c 13                	cmp    $0x13,%al
    2145:	00 00                	add    %al,(%rax)
    2147:	00 00                	add    %al,(%rax)
    2149:	00 3d 18 28 00 00    	add    %bh,0x2818(%rip)        # 4967 <_license+0x28cd>
    214f:	00 40 8d             	add    %al,-0x73(%rax)
    2152:	04 c7                	add    $0xc7,%al
    2154:	11 00                	adc    %eax,(%rax)
    2156:	00 3c 77             	add    %bh,(%rdi,%rsi,2)
    2159:	d0 11                	rclb   (%rcx)
    215b:	00 00                	add    %al,(%rax)
    215d:	3d 18 10 00 00       	cmp    $0x1018,%eax
    2162:	00 3c 76             	add    %bh,(%rsi,%rsi,2)
    2165:	e3 11                	jrcxz  2178 <_license+0xde>
    2167:	00 00                	add    %al,(%rax)
    2169:	42 06                	rex.X (bad)
    216b:	ec                   	in     (%dx),%al
    216c:	11 00                	adc    %eax,(%rax)
    216e:	00 3d 18 10 00 00    	add    %bh,0x1018(%rip)        # 318c <_license+0x10f2>
    2174:	00 40 8d             	add    %al,-0x73(%rax)
    2177:	04 f6                	add    $0xf6,%al
    2179:	11 00                	adc    %eax,(%rax)
    217b:	00 40 80             	add    %al,-0x80(%rax)
    217e:	08 ff                	or     %bh,%bh
    2180:	11 00                	adc    %eax,(%rax)
    2182:	00 40 08             	add    %al,0x8(%rax)
    2185:	08 12                	or     %dl,(%rdx)
    2187:	00 00                	add    %al,(%rax)
    2189:	00 00                	add    %al,(%rax)
    218b:	00 00                	add    %al,(%rax)
    218d:	39 46 13             	cmp    %eax,0x13(%rsi)
    2190:	00 00                	add    %al,(%rax)
    2192:	04 0b                	add    $0xb,%al
    2194:	5a                   	pop    %rdx
    2195:	01 0c 3a             	add    %ecx,(%rdx,%rdi,1)
    2198:	4b                   	rex.WXB
    2199:	4e 13 00             	rex.WRX adc (%rax),%r8
    219c:	00 3a                	add    %bh,(%rdx)
    219e:	4c 56                	rex.WR push %rsi
    21a0:	13 00                	adc    (%rax),%eax
    21a2:	00 3a                	add    %bh,(%rdx)
    21a4:	4d 5e                	rex.WRB pop %r14
    21a6:	13 00                	adc    (%rax),%eax
    21a8:	00 3a                	add    %bh,(%rdx)
    21aa:	4e                   	rex.WRX
    21ab:	66 13 00             	adc    (%rax),%ax
    21ae:	00 3c 4f             	add    %bh,(%rdi,%rcx,2)
    21b1:	6e                   	outsb  %ds:(%rsi),(%dx)
    21b2:	13 00                	adc    (%rax),%eax
    21b4:	00 3c 83             	add    %bh,(%rbx,%rax,4)
    21b7:	01 76 13             	add    %esi,0x13(%rsi)
    21ba:	00 00                	add    %al,(%rax)
    21bc:	41 3f                	rex.B (bad)
    21be:	16                   	(bad)
    21bf:	00 00                	add    %al,(%rax)
    21c1:	19 17                	sbb    %edx,(%rdi)
    21c3:	00 00                	add    %al,(%rax)
    21c5:	00 0b                	add    %cl,(%rbx)
    21c7:	f0 0c 3f             	lock or $0x3f,%al
    21ca:	01 53 48             	add    %edx,0x48(%rbx)
    21cd:	16                   	(bad)
    21ce:	00 00                	add    %al,(%rax)
    21d0:	3f                   	(bad)
    21d1:	01 5f 50             	add    %ebx,0x50(%rdi)
    21d4:	16                   	(bad)
    21d5:	00 00                	add    %al,(%rax)
    21d7:	3b 03                	cmp    (%rbx),%eax
    21d9:	91                   	xchg   %eax,%ecx
    21da:	c0 00 58             	rolb   $0x58,(%rax)
    21dd:	16                   	(bad)
    21de:	00 00                	add    %al,(%rax)
    21e0:	40 00 60 16          	add    %spl,0x16(%rax)
    21e4:	00 00                	add    %al,(%rax)
    21e6:	00 3d 1a 2f 00 00    	add    %bh,0x2f1a(%rip)        # 5106 <_license+0x306c>
    21ec:	00 40 8c             	add    %al,-0x74(%rax)
    21ef:	04 7f                	add    $0x7f,%al
    21f1:	13 00                	adc    (%rax),%eax
    21f3:	00 3c 81             	add    %bh,(%rcx,%rax,4)
    21f6:	01 87 13 00 00 3c    	add    %eax,0x3c000013(%rdi)
    21fc:	82                   	(bad)
    21fd:	01 90 13 00 00 3d    	add    %edx,0x3d000013(%rax)
    2203:	1a 10                	sbb    (%rax),%dl
    2205:	00 00                	add    %al,(%rax)
    2207:	00 3c 80             	add    %bh,(%rax,%rax,4)
    220a:	01 99 13 00 00 42    	add    %ebx,0x42000013(%rcx)
    2210:	06                   	(bad)
    2211:	a1 13 00 00 3d 1a 10 	movabs 0x101a3d000013,%eax
    2218:	00 00 
    221a:	00 40 8c             	add    %al,-0x74(%rax)
    221d:	04 aa                	add    $0xaa,%al
    221f:	13 00                	adc    (%rax),%eax
    2221:	00 40 80             	add    %al,-0x80(%rax)
    2224:	08 b2 13 00 00 40    	or     %dh,0x40000013(%rdx)
    222a:	08 ba 13 00 00 00    	or     %bh,0x13(%rdx)
    2230:	00 00                	add    %al,(%rax)
    2232:	00 00                	add    %al,(%rax)
    2234:	3e fa                	ds cli
    2236:	14 00                	adc    $0x0,%al
    2238:	00 1b                	add    %bl,(%rbx)
    223a:	2a 00                	sub    (%rax),%al
    223c:	00 00                	add    %al,(%rax)
    223e:	00 f8                	add    %bh,%al
    2240:	02 0a                	add    (%rdx),%cl
    2242:	3f                   	(bad)
    2243:	01 53 03             	add    %edx,0x3(%rbx)
    2246:	15 00 00 3f 01       	adc    $0x13f0000,%eax
    224b:	5f                   	pop    %rdi
    224c:	0b 15 00 00 3f 02    	or     0x23f0000(%rip),%edx        # 23f2252 <_license+0x23f01b8>
    2252:	30 9f 13 15 00 00    	xor    %bl,0x1513(%rdi)
    2258:	3f                   	(bad)
    2259:	03 91 08 9f 1b 15    	add    0x151b9f08(%rcx),%edx
    225f:	00 00                	add    %al,(%rax)
    2261:	3b 11                	cmp    (%rcx),%edx
    2263:	72 00                	jb     2265 <_license+0x1cb>
    2265:	10 ff                	adc    %bh,%bh
    2267:	01 1a                	add    %ebx,(%rdx)
    2269:	a8 ba                	test   $0xba,%al
    226b:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    2272:	00 9f 23 15 00 00    	add    %bl,0x1523(%rdi)
    2278:	3c 50                	cmp    $0x50,%al
    227a:	2b 15 00 00 41 1d    	sub    0x1d410000(%rip),%edx        # 1d412280 <_license+0x1d4101e6>
    2280:	16                   	(bad)
    2281:	00 00                	add    %al,(%rax)
    2283:	1c 02                	sbb    $0x2,%al
    2285:	00 00                	add    %al,(%rax)
    2287:	00 09                	add    %cl,(%rcx)
    2289:	7b 0f                	jnp    229a <_license+0x200>
    228b:	3f                   	(bad)
    228c:	02 30                	add    (%rax),%dh
    228e:	9f                   	lahf
    228f:	26 16                	es (bad)
    2291:	00 00                	add    %al,(%rax)
    2293:	3f                   	(bad)
    2294:	11 72 00             	adc    %esi,0x0(%rdx)
    2297:	10 ff                	adc    %bh,%bh
    2299:	01 1a                	add    %ebx,(%rdx)
    229b:	a8 ba                	test   $0xba,%al
    229d:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    22a4:	00 9f 2e 16 00 00    	add    %bl,0x162e(%rdi)
    22aa:	00 00                	add    %al,(%rax)
    22ac:	3e 20 17             	ds and %dl,(%rdi)
    22af:	00 00                	add    %al,(%rax)
    22b1:	1d 17 00 00 00       	sbb    $0x17,%eax
    22b6:	00 fc                	add    %bh,%ah
    22b8:	02 0a                	add    (%rdx),%cl
    22ba:	3f                   	(bad)
    22bb:	01 53 29             	add    %edx,0x29(%rbx)
    22be:	17                   	(bad)
    22bf:	00 00                	add    %al,(%rax)
    22c1:	3f                   	(bad)
    22c2:	01 5f 31             	add    %ebx,0x31(%rdi)
    22c5:	17                   	(bad)
    22c6:	00 00                	add    %al,(%rax)
    22c8:	3f                   	(bad)
    22c9:	02 30                	add    (%rax),%dh
    22cb:	9f                   	lahf
    22cc:	39 17                	cmp    %edx,(%rdi)
    22ce:	00 00                	add    %al,(%rax)
    22d0:	3f                   	(bad)
    22d1:	03 91 08 9f 41 17    	add    0x17419f08(%rcx),%edx
    22d7:	00 00                	add    %al,(%rax)
    22d9:	3b 11                	cmp    (%rcx),%edx
    22db:	72 00                	jb     22dd <_license+0x243>
    22dd:	10 ff                	adc    %bh,%bh
    22df:	01 1a                	add    %ebx,(%rdx)
    22e1:	a8 ba                	test   $0xba,%al
    22e3:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    22ea:	00 9f 49 17 00 00    	add    %bl,0x1749(%rdi)
    22f0:	3c 8a                	cmp    $0x8a,%al
    22f2:	01 51 17             	add    %edx,0x17(%rcx)
    22f5:	00 00                	add    %al,(%rax)
    22f7:	41 1d 16 00 00 1e    	rex.B sbb $0x1e000016,%eax
    22fd:	02 00                	add    (%rax),%al
    22ff:	00 00                	add    %al,(%rax)
    2301:	09 61 0f             	or     %esp,0xf(%rcx)
    2304:	3f                   	(bad)
    2305:	02 30                	add    (%rax),%dh
    2307:	9f                   	lahf
    2308:	26 16                	es (bad)
    230a:	00 00                	add    %al,(%rax)
    230c:	3f                   	(bad)
    230d:	11 72 00             	adc    %esi,0x0(%rdx)
    2310:	10 ff                	adc    %bh,%bh
    2312:	01 1a                	add    %ebx,(%rdx)
    2314:	a8 ba                	test   $0xba,%al
    2316:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    231d:	00 9f 2e 16 00 00    	add    %bl,0x162e(%rdi)
    2323:	00 00                	add    %al,(%rax)
    2325:	3d 1f 5f 00 00       	cmp    $0x5f1f,%eax
    232a:	00 40 01             	add    %al,0x1(%rax)
    232d:	3c 0c                	cmp    $0xc,%al
    232f:	00 00                	add    %al,(%rax)
    2331:	3e 79 16             	jns,pt 234a <_license+0x2b0>
    2334:	00 00                	add    %al,(%rax)
    2336:	1f                   	(bad)
    2337:	5f                   	pop    %rdi
    2338:	00 00                	add    %al,(%rax)
    233a:	00 00                	add    %al,(%rax)
    233c:	e4 02                	in     $0x2,%al
    233e:	0e                   	(bad)
    233f:	3f                   	(bad)
    2340:	03 91 08 9f 82 16    	add    0x16829f08(%rcx),%edx
    2346:	00 00                	add    %al,(%rax)
    2348:	3f                   	(bad)
    2349:	02 30                	add    (%rax),%dh
    234b:	9f                   	lahf
    234c:	8a 16                	mov    (%rsi),%dl
    234e:	00 00                	add    %al,(%rax)
    2350:	3b 03                	cmp    (%rbx),%eax
    2352:	91                   	xchg   %eax,%ecx
    2353:	c0 00 9a             	rolb   $0x9a,(%rax)
    2356:	16                   	(bad)
    2357:	00 00                	add    %al,(%rax)
    2359:	3c 7d                	cmp    $0x7d,%al
    235b:	a3 16 00 00 3c 7f ac 	movabs %eax,0x16ac7f3c000016
    2362:	16 00 
    2364:	00 3d 20 15 00 00    	add    %bh,0x1520(%rip)        # 388a <_license+0x17f0>
    236a:	00 3c 7a             	add    %bh,(%rdx,%rdi,2)
    236d:	b5 16                	mov    $0x16,%ch
    236f:	00 00                	add    %al,(%rax)
    2371:	42 01 bd 16 00 00 41 	rex.X add %edi,0x41000016(%rbp)
    2378:	02 17                	add    (%rdi),%dl
    237a:	00 00                	add    %al,(%rax)
    237c:	20 15 00 00 00 00    	and    %dl,0x0(%rip)        # 2382 <_license+0x2e8>
    2382:	d5                   	(bad)
    2383:	1c 3a                	sbb    $0x3a,%al
    2385:	7b 0c                	jnp    2393 <_license+0x2f9>
    2387:	17                   	(bad)
    2388:	00 00                	add    %al,(%rax)
    238a:	3a 7c 16 17          	cmp    0x17(%rsi,%rdx,1),%bh
    238e:	00 00                	add    %al,(%rax)
    2390:	00 00                	add    %al,(%rax)
    2392:	3d 21 1e 00 00       	cmp    $0x1e21,%eax
    2397:	00 40 86             	add    %al,-0x7a(%rax)
    239a:	04 c7                	add    $0xc7,%al
    239c:	16                   	(bad)
    239d:	00 00                	add    %al,(%rax)
    239f:	3d 21 10 00 00       	cmp    $0x1021,%eax
    23a4:	00 3c 7e             	add    %bh,(%rsi,%rdi,2)
    23a7:	d0 16                	rclb   (%rsi)
    23a9:	00 00                	add    %al,(%rax)
    23ab:	42 06                	rex.X (bad)
    23ad:	d8 16                	fcoms  (%rsi)
    23af:	00 00                	add    %al,(%rax)
    23b1:	3d 21 10 00 00       	cmp    $0x1021,%eax
    23b6:	00 40 86             	add    %al,-0x7a(%rax)
    23b9:	04 e1                	add    $0xe1,%al
    23bb:	16                   	(bad)
    23bc:	00 00                	add    %al,(%rax)
    23be:	40 80 08 e9          	rex orb $0xe9,(%rax)
    23c2:	16                   	(bad)
    23c3:	00 00                	add    %al,(%rax)
    23c5:	40 08 f1             	or     %sil,%cl
    23c8:	16                   	(bad)
    23c9:	00 00                	add    %al,(%rax)
    23cb:	00 00                	add    %al,(%rax)
    23cd:	00 00                	add    %al,(%rax)
    23cf:	00 3d 22 5a 00 00    	add    %bh,0x5a22(%rip)        # 7df7 <_license+0x5d5d>
    23d5:	00 40 01             	add    %al,0x1(%rax)
    23d8:	31 0c 00             	xor    %ecx,(%rax,%rax,1)
    23db:	00 3e                	add    %bh,(%rsi)
    23dd:	79 16                	jns    23f5 <_license+0x35b>
    23df:	00 00                	add    %al,(%rax)
    23e1:	22 5a 00             	and    0x0(%rdx),%bl
    23e4:	00 00                	add    %al,(%rax)
    23e6:	00 ed                	add    %ch,%ch
    23e8:	02 0e                	add    (%rsi),%cl
    23ea:	3f                   	(bad)
    23eb:	03 91 08 9f 82 16    	add    0x16829f08(%rcx),%edx
    23f1:	00 00                	add    %al,(%rax)
    23f3:	3f                   	(bad)
    23f4:	02 30                	add    (%rax),%dh
    23f6:	9f                   	lahf
    23f7:	8a 16                	mov    (%rsi),%dl
    23f9:	00 00                	add    %al,(%rax)
    23fb:	3b 03                	cmp    (%rbx),%eax
    23fd:	91                   	xchg   %eax,%ecx
    23fe:	c0 00 9a             	rolb   $0x9a,(%rax)
    2401:	16                   	(bad)
    2402:	00 00                	add    %al,(%rax)
    2404:	3c 87                	cmp    $0x87,%al
    2406:	01 a3 16 00 00 3c    	add    %esp,0x3c000016(%rbx)
    240c:	89 01                	mov    %eax,(%rcx)
    240e:	ac                   	lods   %ds:(%rsi),%al
    240f:	16                   	(bad)
    2410:	00 00                	add    %al,(%rax)
    2412:	3d 23 15 00 00       	cmp    $0x1523,%eax
    2417:	00 3c 84             	add    %bh,(%rsp,%rax,4)
    241a:	01 b5 16 00 00 42    	add    %esi,0x42000016(%rbp)
    2420:	01 bd 16 00 00 41    	add    %edi,0x41000016(%rbp)
    2426:	02 17                	add    (%rdi),%dl
    2428:	00 00                	add    %al,(%rax)
    242a:	23 15 00 00 00 00    	and    0x0(%rip),%edx        # 2430 <_license+0x396>
    2430:	d5                   	(bad)
    2431:	1c 3a                	sbb    $0x3a,%al
    2433:	85 01                	test   %eax,(%rcx)
    2435:	0c 17                	or     $0x17,%al
    2437:	00 00                	add    %al,(%rax)
    2439:	3a 86 01 16 17 00    	cmp    0x171601(%rsi),%al
    243f:	00 00                	add    %al,(%rax)
    2441:	00 3d 24 19 00 00    	add    %bh,0x1924(%rip)        # 3d6b <_license+0x1cd1>
    2447:	00 40 86             	add    %al,-0x7a(%rax)
    244a:	04 c7                	add    $0xc7,%al
    244c:	16                   	(bad)
    244d:	00 00                	add    %al,(%rax)
    244f:	3d 24 10 00 00       	cmp    $0x1024,%eax
    2454:	00 3c 88             	add    %bh,(%rax,%rcx,4)
    2457:	01 d0                	add    %edx,%eax
    2459:	16                   	(bad)
    245a:	00 00                	add    %al,(%rax)
    245c:	42 06                	rex.X (bad)
    245e:	d8 16                	fcoms  (%rsi)
    2460:	00 00                	add    %al,(%rax)
    2462:	3d 24 10 00 00       	cmp    $0x1024,%eax
    2467:	00 40 86             	add    %al,-0x7a(%rax)
    246a:	04 e1                	add    $0xe1,%al
    246c:	16                   	(bad)
    246d:	00 00                	add    %al,(%rax)
    246f:	40 80 08 e9          	rex orb $0xe9,(%rax)
    2473:	16                   	(bad)
    2474:	00 00                	add    %al,(%rax)
    2476:	40 08 f1             	or     %sil,%cl
    2479:	16                   	(bad)
    247a:	00 00                	add    %al,(%rax)
    247c:	00 00                	add    %al,(%rax)
    247e:	00 00                	add    %al,(%rax)
    2480:	00 3d 25 1b 00 00    	add    %bh,0x1b25(%rip)        # 3fab <_license+0x1f11>
    2486:	00 3c 8b             	add    %bh,(%rbx,%rcx,4)
    2489:	01 47 0c             	add    %eax,0xc(%rdi)
    248c:	00 00                	add    %al,(%rax)
    248e:	42 01 50 0c          	rex.X add %edx,0xc(%rax)
    2492:	00 00                	add    %al,(%rax)
    2494:	3e 02 17             	ds add (%rdi),%dl
    2497:	00 00                	add    %al,(%rax)
    2499:	25 1b 00 00 00       	and    $0x1b,%eax
    249e:	00 17                	add    %dl,(%rdi)
    24a0:	03 0e                	add    (%rsi),%ecx
    24a2:	3a 8c 01 0c 17 00 00 	cmp    0x170c(%rcx,%rax,1),%cl
    24a9:	00 00                	add    %al,(%rax)
    24ab:	3d 26 0e 00 00       	cmp    $0xe26,%eax
    24b0:	00 3c a5 01 5b 0c 00 	add    %bh,0xc5b01(,%riz,4)
    24b7:	00 42 01             	add    %al,0x1(%rdx)
    24ba:	64 0c 00             	fs or  $0x0,%al
    24bd:	00 43 02             	add    %al,0x2(%rbx)
    24c0:	17                   	(bad)
    24c1:	00 00                	add    %al,(%rax)
    24c3:	26 0e                	es (bad)
    24c5:	00 00                	add    %al,(%rax)
    24c7:	00 00                	add    %al,(%rax)
    24c9:	1a 03                	sbb    (%rbx),%al
    24cb:	10 00                	adc    %al,(%rax)
    24cd:	3d 27 10 00 00       	cmp    $0x1027,%eax
    24d2:	00 3c 8f             	add    %bh,(%rdi,%rcx,4)
    24d5:	01 6f 0c             	add    %ebp,0xc(%rdi)
    24d8:	00 00                	add    %al,(%rax)
    24da:	42 06                	rex.X (bad)
    24dc:	78 0c                	js     24ea <_license+0x450>
    24de:	00 00                	add    %al,(%rax)
    24e0:	3d 27 10 00 00       	cmp    $0x1027,%eax
    24e5:	00 40 80             	add    %al,-0x80(%rax)
    24e8:	04 82                	add    $0x82,%al
    24ea:	0c 00                	or     $0x0,%al
    24ec:	00 40 80             	add    %al,-0x80(%rax)
    24ef:	08 8b 0c 00 00 40    	or     %cl,0x4000000c(%rbx)
    24f5:	08 94 0c 00 00 00 00 	or     %dl,0x0(%rsp,%rcx,1)
    24fc:	3d 28 0c 00 00       	cmp    $0xc28,%eax
    2501:	00 3c 91             	add    %bh,(%rcx,%rdx,4)
    2504:	01 a0 0c 00 00 00    	add    %esp,0xc(%rax)
    250a:	44 05 3c 94 01 ab    	rex.R add $0xab01943c,%eax
    2510:	0c 00                	or     $0x0,%al
    2512:	00 3c 95 01 b4 0c 00 	add    %bh,0xcb401(,%rdx,4)
    2519:	00 44 06 3c          	add    %al,0x3c(%rsi,%rax,1)
    251d:	93                   	xchg   %eax,%ebx
    251e:	01 be 0c 00 00 3c    	add    %edi,0x3c00000c(%rsi)
    2524:	96                   	xchg   %eax,%esi
    2525:	01 c7                	add    %eax,%edi
    2527:	0c 00                	or     $0x0,%al
    2529:	00 3c 97             	add    %bh,(%rdi,%rdx,4)
    252c:	01 d0                	add    %edx,%eax
    252e:	0c 00                	or     $0x0,%al
    2530:	00 00                	add    %al,(%rax)
    2532:	00 3d 29 3b 00 00    	add    %bh,0x3b29(%rip)        # 6061 <_license+0x3fc7>
    2538:	00 40 83             	add    %al,-0x7d(%rax)
    253b:	04 dc                	add    $0xdc,%al
    253d:	0c 00                	or     $0x0,%al
    253f:	00 3c 99             	add    %bh,(%rcx,%rbx,4)
    2542:	01 e5                	add    %esp,%ebp
    2544:	0c 00                	or     $0x0,%al
    2546:	00 3d 29 1a 00 00    	add    %bh,0x1a29(%rip)        # 3f75 <_license+0x1edb>
    254c:	00 3c 98             	add    %bh,(%rax,%rbx,4)
    254f:	01 ef                	add    %ebp,%edi
    2551:	0c 00                	or     $0x0,%al
    2553:	00 42 06             	add    %al,0x6(%rdx)
    2556:	f8                   	clc
    2557:	0c 00                	or     $0x0,%al
    2559:	00 3d 29 1a 00 00    	add    %bh,0x1a29(%rip)        # 3f88 <_license+0x1eee>
    255f:	00 40 83             	add    %al,-0x7d(%rax)
    2562:	04 02                	add    $0x2,%al
    2564:	0d 00 00 40 80       	or     $0x80400000,%eax
    2569:	08 0b                	or     %cl,(%rbx)
    256b:	0d 00 00 40 08       	or     $0x8400000,%eax
    2570:	14 0d                	adc    $0xd,%al
    2572:	00 00                	add    %al,(%rax)
    2574:	00 00                	add    %al,(%rax)
    2576:	00 44 07 3c          	add    %al,0x3c(%rdi,%rax,1)
    257a:	a8 01                	test   $0x1,%al
    257c:	2b 0d 00 00 3c aa    	sub    -0x55c40000(%rip),%ecx        # ffffffffaa3c2582 <server_id_map+0x5ffffe31197582>
    2582:	01 34 0d 00 00 3c df 	add    %esi,-0x20c40000(,%rcx,1)
    2589:	02 3d 0d 00 00 3d    	add    0x3d00000d(%rip),%bh        # 3d00259c <_license+0x3d000502>
    258f:	2a 10                	sub    (%rax),%dl
    2591:	00 00                	add    %al,(%rax)
    2593:	00 3c a9             	add    %bh,(%rcx,%rbp,4)
    2596:	01 47 0d             	add    %eax,0xd(%rdi)
    2599:	00 00                	add    %al,(%rax)
    259b:	42 06                	rex.X (bad)
    259d:	50                   	push   %rax
    259e:	0d 00 00 3d 2a       	or     $0x2a3d0000,%eax
    25a3:	10 00                	adc    %al,(%rax)
    25a5:	00 00                	add    %al,(%rax)
    25a7:	40 00 5a 0d          	rex add %bl,0xd(%rdx)
    25ab:	00 00                	add    %al,(%rax)
    25ad:	40 01 63 0d          	rex add %esp,0xd(%rbx)
    25b1:	00 00                	add    %al,(%rax)
    25b3:	40 08 6c 0d 00       	or     %bpl,0x0(%rbp,%rcx,1)
    25b8:	00 00                	add    %al,(%rax)
    25ba:	00 39                	add    %bh,(%rcx)
    25bc:	96                   	xchg   %eax,%esi
    25bd:	17                   	(bad)
    25be:	00 00                	add    %al,(%rax)
    25c0:	08 00                	or     %al,(%rax)
    25c2:	74 03                	je     25c7 <_license+0x52d>
    25c4:	26 3a ab 01 a0 17 00 	es cmp 0x17a001(%rbx),%ch
    25cb:	00 3a                	add    %bh,(%rdx)
    25cd:	ac                   	lods   %ds:(%rsi),%al
    25ce:	01 a9 17 00 00 3a    	add    %ebp,0x3a000017(%rcx)
    25d4:	ad                   	lods   %ds:(%rsi),%eax
    25d5:	01 b2 17 00 00 3c    	add    %esi,0x3c000017(%rdx)
    25db:	ae                   	scas   %es:(%rdi),%al
    25dc:	01 c4                	add    %eax,%esp
    25de:	17                   	(bad)
    25df:	00 00                	add    %al,(%rax)
    25e1:	3c af                	cmp    $0xaf,%al
    25e3:	01 ce                	add    %ecx,%esi
    25e5:	17                   	(bad)
    25e6:	00 00                	add    %al,(%rax)
    25e8:	3c b0                	cmp    $0xb0,%al
    25ea:	01 d8                	add    %ebx,%eax
    25ec:	17                   	(bad)
    25ed:	00 00                	add    %al,(%rax)
    25ef:	3c b1                	cmp    $0xb1,%al
    25f1:	01 e2                	add    %esp,%edx
    25f3:	17                   	(bad)
    25f4:	00 00                	add    %al,(%rax)
    25f6:	3c b2                	cmp    $0xb2,%al
    25f8:	01 ec                	add    %ebp,%esp
    25fa:	17                   	(bad)
    25fb:	00 00                	add    %al,(%rax)
    25fd:	44 09 3c 8b          	or     %r15d,(%rbx,%rcx,4)
    2601:	02 09                	add    (%rcx),%cl
    2603:	18 00                	sbb    %al,(%rax)
    2605:	00 00                	add    %al,(%rax)
    2607:	00 3e                	add    %bh,(%rsi)
    2609:	c9                   	leave
    260a:	19 00                	sbb    %eax,(%rax)
    260c:	00 2b                	add    %ch,(%rbx)
    260e:	3c 00                	cmp    $0x0,%al
    2610:	00 00                	add    %al,(%rax)
    2612:	00 a6 03 09 3f 02    	add    %ah,0x23f0903(%rsi)
    2618:	31 9f d8 19 00 00    	xor    %ebx,0x19d8(%rdi)
    261e:	3f                   	(bad)
    261f:	02 30                	add    (%rax),%dh
    2621:	9f                   	lahf
    2622:	e2 19                	loop   263d <_license+0x5a3>
    2624:	00 00                	add    %al,(%rax)
    2626:	3c c9                	cmp    $0xc9,%al
    2628:	01 ec                	add    %ebp,%esp
    262a:	19 00                	sbb    %eax,(%rax)
    262c:	00 3d 2b 2e 00 00    	add    %bh,0x2e2b(%rip)        # 545d <_license+0x33c3>
    2632:	00 3c c8             	add    %bh,(%rax,%rcx,8)
    2635:	01 f7                	add    %esi,%edi
    2637:	19 00                	sbb    %eax,(%rax)
    2639:	00 42 06             	add    %al,0x6(%rdx)
    263c:	00 1a                	add    %bl,(%rdx)
    263e:	00 00                	add    %al,(%rax)
    2640:	3d 2b 2e 00 00       	cmp    $0x2e2b,%eax
    2645:	00 40 80             	add    %al,-0x80(%rax)
    2648:	04 0a                	add    $0xa,%al
    264a:	1a 00                	sbb    (%rax),%al
    264c:	00 40 08             	add    %al,0x8(%rax)
    264f:	13 1a                	adc    (%rdx),%ebx
    2651:	00 00                	add    %al,(%rax)
    2653:	00 00                	add    %al,(%rax)
    2655:	00 44 0a 3c          	add    %al,0x3c(%rdx,%rcx,1)
    2659:	e5 02                	in     $0x2,%eax
    265b:	78 0d                	js     266a <_license+0x5d0>
    265d:	00 00                	add    %al,(%rax)
    265f:	39 cb                	cmp    %ecx,%ebx
    2661:	1d 00 00 0b 00       	sbb    $0xb0000,%eax
    2666:	78 03                	js     266b <_license+0x5d1>
    2668:	09 3a                	or     %edi,(%rdx)
    266a:	e0 02                	loopne 266e <_license+0x5d4>
    266c:	d1 1d 00 00 3a e1    	rcrl   -0x1ec60000(%rip)        # ffffffffe13a2672 <server_id_map+0x5ffffe68177672>
    2672:	02 da                	add    %dl,%bl
    2674:	1d 00 00 00 3d       	sbb    $0x3d000000,%eax
    2679:	2c 05                	sub    $0x5,%al
    267b:	00 00                	add    %al,(%rax)
    267d:	00 3c e6             	add    %bh,(%rsi,%riz,8)
    2680:	02 8b 0d 00 00 42    	add    0x4200000d(%rbx),%cl
    2686:	02 94 0d 00 00 3d 2c 	add    0x2c3d0000(%rbp,%rcx,1),%dl
    268d:	05 00 00 00 3b       	add    $0x3b000000,%eax
    2692:	01 50 9e             	add    %edx,-0x62(%rax)
    2695:	0d 00 00 40 fe       	or     $0xfe400000,%eax
    269a:	ff                   	(bad)
    269b:	ff 07                	incl   (%rdi)
    269d:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    269e:	0d 00 00 40 08       	or     $0x8400000,%eax
    26a3:	b0 0d                	mov    $0xd,%al
    26a5:	00 00                	add    %al,(%rax)
    26a7:	00 00                	add    %al,(%rax)
    26a9:	44 0c 3c             	rex.R or $0x3c,%al
    26ac:	ec                   	in     (%dx),%al
    26ad:	02 bc 0d 00 00 3d 2d 	add    0x2d3d0000(%rbp,%rcx,1),%bh
    26b4:	20 00                	and    %al,(%rax)
    26b6:	00 00                	add    %al,(%rax)
    26b8:	3c e7                	cmp    $0xe7,%al
    26ba:	02 c6                	add    %dh,%al
    26bc:	0d 00 00 42 02       	or     $0x2420000,%eax
    26c1:	cf                   	iret
    26c2:	0d 00 00 3d 2d       	or     $0x2d3d0000,%eax
    26c7:	20 00                	and    %al,(%rax)
    26c9:	00 00                	add    %al,(%rax)
    26cb:	3c e8                	cmp    $0xe8,%al
    26cd:	02 d9                	add    %cl,%bl
    26cf:	0d 00 00 40 80       	or     $0x80400000,%eax
    26d4:	20 e2                	and    %ah,%dl
    26d6:	0d 00 00 40 18       	or     $0x18400000,%eax
    26db:	eb 0d                	jmp    26ea <_license+0x650>
    26dd:	00 00                	add    %al,(%rax)
    26df:	00 00                	add    %al,(%rax)
    26e1:	39 f6                	cmp    %esi,%esi
    26e3:	1e                   	(bad)
    26e4:	00 00                	add    %al,(%rax)
    26e6:	0d 00 8e 03 17       	or     $0x17038e00,%eax
    26eb:	3a e9                	cmp    %cl,%ch
    26ed:	02 00                	add    (%rax),%al
    26ef:	1f                   	(bad)
    26f0:	00 00                	add    %al,(%rax)
    26f2:	3a ea                	cmp    %dl,%ch
    26f4:	02 09                	add    (%rcx),%cl
    26f6:	1f                   	(bad)
    26f7:	00 00                	add    %al,(%rax)
    26f9:	3b 03                	cmp    (%rbx),%eax
    26fb:	91                   	xchg   %eax,%ecx
    26fc:	c0 00 12             	rolb   $0x12,(%rax)
    26ff:	1f                   	(bad)
    2700:	00 00                	add    %al,(%rax)
    2702:	3c eb                	cmp    $0xeb,%al
    2704:	02 1c 1f             	add    (%rdi,%rbx,1),%bl
    2707:	00 00                	add    %al,(%rax)
    2709:	3e 02 17             	ds add (%rdi),%dl
    270c:	00 00                	add    %al,(%rax)
    270e:	2e 0b 00             	cs or  (%rax),%eax
    2711:	00 00                	add    %al,(%rax)
    2713:	00 6a 02             	add    %ch,0x2(%rdx)
    2716:	22 3f                	and    (%rdi),%bh
    2718:	01 55 0c             	add    %edx,0xc(%rbp)
    271b:	17                   	(bad)
    271c:	00 00                	add    %al,(%rax)
    271e:	00 39                	add    %bh,(%rcx)
    2720:	78 19                	js     273b <_license+0x6a1>
    2722:	00 00                	add    %al,(%rax)
    2724:	0e                   	(bad)
    2725:	00 74 02 07          	add    %dh,0x7(%rdx,%rax,1)
    2729:	3c f1                	cmp    $0xf1,%al
    272b:	02 8a 19 00 00 3c    	add    0x3c000019(%rdx),%cl
    2731:	f3 02 93 19 00 00 3d 	repz add 0x3d000019(%rbx),%dl
    2738:	2f                   	(bad)
    2739:	1a 00                	sbb    (%rax),%al
    273b:	00 00                	add    %al,(%rax)
    273d:	3c f2                	cmp    $0xf2,%al
    273f:	02 9d 19 00 00 42    	add    0x42000019(%rbp),%bl
    2745:	06                   	(bad)
    2746:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2747:	19 00                	sbb    %eax,(%rax)
    2749:	00 3d 2f 1a 00 00    	add    %bh,0x1a2f(%rip)        # 417e <_license+0x20e4>
    274f:	00 40 82             	add    %al,-0x7e(%rax)
    2752:	04 ae                	add    $0xae,%al
    2754:	19 00                	sbb    %eax,(%rax)
    2756:	00 40 80             	add    %al,-0x80(%rax)
    2759:	08 b6 19 00 00 40    	or     %dh,0x40000019(%rsi)
    275f:	08 be 19 00 00 00    	or     %bh,0x19(%rsi)
    2765:	00 00                	add    %al,(%rax)
    2767:	3e e4 1d             	ds in  $0x1d,%al
    276a:	00 00                	add    %al,(%rax)
    276c:	30 12                	xor    %dl,(%rdx)
    276e:	00 00                	add    %al,(%rax)
    2770:	00 00                	add    %al,(%rax)
    2772:	79 02                	jns    2776 <_license+0x6dc>
    2774:	03 3f                	add    (%rdi),%edi
    2776:	01 55 ee             	add    %edx,-0x12(%rbp)
    2779:	1d 00 00 45 f8       	sbb    $0xf8450000,%eax
    277e:	1d 00 00 3a f6       	sbb    $0xf63a0000,%eax
    2783:	02 01                	add    (%rcx),%al
    2785:	1e                   	(bad)
    2786:	00 00                	add    %al,(%rax)
    2788:	46 00 0a             	rex.RX add %r9b,(%rdx)
    278b:	1e                   	(bad)
    278c:	00 00                	add    %al,(%rax)
    278e:	00 00                	add    %al,(%rax)
    2790:	3e c9                	ds leave
    2792:	19 00                	sbb    %eax,(%rax)
    2794:	00 31                	add    %dh,(%rcx)
    2796:	35 00 00 00 00       	xor    $0x0,%eax
    279b:	93                   	xchg   %eax,%ebx
    279c:	03 0f                	add    (%rdi),%ecx
    279e:	3f                   	(bad)
    279f:	02 30                	add    (%rax),%dh
    27a1:	9f                   	lahf
    27a2:	d8 19                	fcomps (%rcx)
    27a4:	00 00                	add    %al,(%rax)
    27a6:	3f                   	(bad)
    27a7:	02 31                	add    (%rcx),%dh
    27a9:	9f                   	lahf
    27aa:	e2 19                	loop   27c5 <_license+0x72b>
    27ac:	00 00                	add    %al,(%rax)
    27ae:	3c f5                	cmp    $0xf5,%al
    27b0:	02 ec                	add    %ah,%ch
    27b2:	19 00                	sbb    %eax,(%rax)
    27b4:	00 3d 31 2a 00 00    	add    %bh,0x2a31(%rip)        # 51eb <_license+0x3151>
    27ba:	00 3c f4             	add    %bh,(%rsp,%rsi,8)
    27bd:	02 f7                	add    %bh,%dh
    27bf:	19 00                	sbb    %eax,(%rax)
    27c1:	00 42 06             	add    %al,0x6(%rdx)
    27c4:	00 1a                	add    %bl,(%rdx)
    27c6:	00 00                	add    %al,(%rax)
    27c8:	3d 31 2a 00 00       	cmp    $0x2a31,%eax
    27cd:	00 40 80             	add    %al,-0x80(%rax)
    27d0:	04 0a                	add    $0xa,%al
    27d2:	1a 00                	sbb    (%rax),%al
    27d4:	00 40 08             	add    %al,0x8(%rax)
    27d7:	13 1a                	adc    (%rdx),%ebx
	...
    27e1:	3d 32 35 00 00       	cmp    $0x3532,%eax
    27e6:	00 40 8b             	add    %al,-0x75(%rax)
    27e9:	04 fa                	add    $0xfa,%al
    27eb:	0d 00 00 3c b4       	or     $0xb43c0000,%eax
    27f0:	01 03                	add    %eax,(%rbx)
    27f2:	0e                   	(bad)
    27f3:	00 00                	add    %al,(%rax)
    27f5:	3d 32 1a 00 00       	cmp    $0x1a32,%eax
    27fa:	00 3c b3             	add    %bh,(%rbx,%rsi,4)
    27fd:	01 0d 0e 00 00 42    	add    %ecx,0x4200000e(%rip)        # 42002811 <_license+0x42000777>
    2803:	06                   	(bad)
    2804:	16                   	(bad)
    2805:	0e                   	(bad)
    2806:	00 00                	add    %al,(%rax)
    2808:	3d 32 1a 00 00       	cmp    $0x1a32,%eax
    280d:	00 40 8b             	add    %al,-0x75(%rax)
    2810:	04 20                	add    $0x20,%al
    2812:	0e                   	(bad)
    2813:	00 00                	add    %al,(%rax)
    2815:	40 80 08 29          	rex orb $0x29,(%rax)
    2819:	0e                   	(bad)
    281a:	00 00                	add    %al,(%rax)
    281c:	40 08 32             	or     %sil,(%rdx)
    281f:	0e                   	(bad)
    2820:	00 00                	add    %al,(%rax)
    2822:	00 00                	add    %al,(%rax)
    2824:	3e 15 18 00 00 33    	ds adc $0x33000018,%eax
    282a:	07                   	(bad)
    282b:	00 00                	add    %al,(%rax)
    282d:	00 00                	add    %al,(%rax)
    282f:	6a 03                	push   $0x3
    2831:	0b 3f                	or     (%rdi),%edi
    2833:	01 53 1f             	add    %edx,0x1f(%rbx)
    2836:	18 00                	sbb    %al,(%rax)
    2838:	00 3f                	add    %bh,(%rdi)
    283a:	02 30                	add    (%rax),%dh
    283c:	9f                   	lahf
    283d:	31 18                	xor    %ebx,(%rax)
    283f:	00 00                	add    %al,(%rax)
    2841:	40 0e                	rex (bad)
    2843:	3a 18                	cmp    (%rax),%bl
    2845:	00 00                	add    %al,(%rax)
    2847:	3d 33 07 00 00       	cmp    $0x733,%eax
    284c:	00 3b                	add    %bh,(%rbx)
    284e:	03 73 22             	add    0x22(%rbx),%esi
    2851:	9f                   	lahf
    2852:	4f 18 00             	rex.WRXB sbb %r8b,(%r8)
    2855:	00 00                	add    %al,(%rax)
    2857:	00 00                	add    %al,(%rax)
    2859:	39 5a 18             	cmp    %ebx,0x18(%rdx)
    285c:	00 00                	add    %al,(%rax)
    285e:	0f 00 dc             	ltr    %sp
    2861:	03 07                	add    (%rdi),%eax
    2863:	3a b5 01 68 18 00    	cmp    0x186801(%rbp),%dh
    2869:	00 3a                	add    %bh,(%rdx)
    286b:	b6 01                	mov    $0x1,%dh
    286d:	70 18                	jo     2887 <_license+0x7ed>
    286f:	00 00                	add    %al,(%rax)
    2871:	3a b7 01 78 18 00    	cmp    0x187801(%rdi),%dh
    2877:	00 3c b8             	add    %bh,(%rax,%rdi,4)
    287a:	01 81 18 00 00 3c    	add    %eax,0x3c000018(%rcx)
    2880:	b9 01 8a 18 00       	mov    $0x188a01,%ecx
    2885:	00 3c cc             	add    %bh,(%rsp,%rcx,8)
    2888:	01 93 18 00 00 41    	add    %edx,0x41000018(%rbx)
    288e:	02 17                	add    (%rdi),%dl
    2890:	00 00                	add    %al,(%rax)
    2892:	34 0b                	xor    $0xb,%al
    2894:	00 00                	add    %al,(%rax)
    2896:	00 00                	add    %al,(%rax)
    2898:	b8 0d 3f 01 55       	mov    $0x55013f0d,%eax
    289d:	0c 17                	or     $0x17,%al
    289f:	00 00                	add    %al,(%rax)
    28a1:	00 3d 35 1a 00 00    	add    %bh,0x1a35(%rip)        # 42dc <_license+0x2242>
    28a7:	00 3c ce             	add    %bh,(%rsi,%rcx,8)
    28aa:	01 9c 18 00 00 42 02 	add    %ebx,0x2420000(%rax,%rbx,1)
    28b1:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    28b2:	18 00                	sbb    %al,(%rax)
    28b4:	00 3d 35 1a 00 00    	add    %bh,0x1a35(%rip)        # 42ef <_license+0x2255>
    28ba:	00 3c cd 01 ad 18 00 	add    %bh,0x18ad01(,%rcx,8)
    28c1:	00 40 80             	add    %al,-0x80(%rax)
    28c4:	20 b5 18 00 00 40    	and    %dh,0x40000018(%rbp)
    28ca:	18 bd 18 00 00 00    	sbb    %bh,0x18(%rbp)
    28d0:	00 00                	add    %al,(%rax)
    28d2:	39 cd                	cmp    %ecx,%ebp
    28d4:	18 00                	sbb    %al,(%rax)
    28d6:	00 10                	add    %dl,(%rax)
    28d8:	00 e9                	add    %ch,%cl
    28da:	03 05 3a ba 01 e0    	add    -0x1ffe45c6(%rip),%eax        # ffffffffe001e31a <server_id_map+0x5ffffe66df331a>
    28e0:	18 00                	sbb    %al,(%rax)
    28e2:	00 3a                	add    %bh,(%rdx)
    28e4:	bb 01 e9 18 00       	mov    $0x18e901,%ebx
    28e9:	00 3a                	add    %bh,(%rdx)
    28eb:	bc 01 f2 18 00       	mov    $0x18f201,%esp
    28f0:	00 39                	add    %bh,(%rcx)
    28f2:	78 19                	js     290d <_license+0x873>
    28f4:	00 00                	add    %al,(%rax)
    28f6:	11 00                	adc    %eax,(%rax)
    28f8:	93                   	xchg   %eax,%ebx
    28f9:	02 32                	add    (%rdx),%dh
    28fb:	3c bd                	cmp    $0xbd,%al
    28fd:	01 8a 19 00 00 3c    	add    %ecx,0x3c000019(%rdx)
    2903:	bf 01 93 19 00       	mov    $0x199301,%edi
    2908:	00 3d 36 1a 00 00    	add    %bh,0x1a36(%rip)        # 4344 <_license+0x22aa>
    290e:	00 3c be             	add    %bh,(%rsi,%rdi,4)
    2911:	01 9d 19 00 00 42    	add    %ebx,0x42000019(%rbp)
    2917:	06                   	(bad)
    2918:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2919:	19 00                	sbb    %eax,(%rax)
    291b:	00 3d 36 1a 00 00    	add    %bh,0x1a36(%rip)        # 4357 <_license+0x22bd>
    2921:	00 40 82             	add    %al,-0x7e(%rax)
    2924:	04 ae                	add    $0xae,%al
    2926:	19 00                	sbb    %eax,(%rax)
    2928:	00 40 80             	add    %al,-0x80(%rax)
    292b:	08 b6 19 00 00 40    	or     %dh,0x40000019(%rsi)
    2931:	08 be 19 00 00 00    	or     %bh,0x19(%rsi)
    2937:	00 00                	add    %al,(%rax)
    2939:	3d 37 61 00 00       	cmp    $0x6137,%eax
    293e:	00 3c c4             	add    %bh,(%rsp,%rax,8)
    2941:	01 06                	add    %eax,(%rsi)
    2943:	19 00                	sbb    %eax,(%rax)
    2945:	00 3d 37 15 00 00    	add    %bh,0x1537(%rip)        # 3e82 <_license+0x1de8>
    294b:	00 3c c2             	add    %bh,(%rdx,%rax,8)
    294e:	01 11                	add    %edx,(%rcx)
    2950:	19 00                	sbb    %eax,(%rax)
    2952:	00 42 0d             	add    %al,0xd(%rdx)
    2955:	1a 19                	sbb    (%rcx),%bl
    2957:	00 00                	add    %al,(%rax)
    2959:	3e 02 17             	ds add (%rdi),%dl
    295c:	00 00                	add    %al,(%rax)
    295e:	37                   	(bad)
    295f:	15 00 00 00 00       	adc    $0x0,%eax
    2964:	95                   	xchg   %eax,%ebp
    2965:	02 1c 3a             	add    (%rdx,%rdi,1),%bl
    2968:	c3                   	ret
    2969:	01 0c 17             	add    %ecx,(%rdi,%rdx,1)
    296c:	00 00                	add    %al,(%rax)
    296e:	00 00                	add    %al,(%rax)
    2970:	3d 38 43 00 00       	cmp    $0x4338,%eax
    2975:	00 3c c5 01 25 19 00 	add    %bh,0x192501(,%rax,8)
    297c:	00 3e                	add    %bh,(%rsi)
    297e:	02 17                	add    (%rdi),%dl
    2980:	00 00                	add    %al,(%rax)
    2982:	39 09                	cmp    %ecx,(%rcx)
    2984:	00 00                	add    %al,(%rax)
    2986:	00 00                	add    %al,(%rax)
    2988:	97                   	xchg   %eax,%edi
    2989:	02 19                	add    (%rcx),%bl
    298b:	3f                   	(bad)
    298c:	01 50 0c             	add    %edx,0xc(%rax)
    298f:	17                   	(bad)
    2990:	00 00                	add    %al,(%rax)
    2992:	3f                   	(bad)
    2993:	01 54 16 17          	add    %edx,0x17(%rsi,%rdx,1)
    2997:	00 00                	add    %al,(%rax)
    2999:	00 3d 3a 2c 00 00    	add    %bh,0x2c3a(%rip)        # 55d9 <_license+0x353f>
    299f:	00 40 8f             	add    %al,-0x71(%rax)
    29a2:	04 30                	add    $0x30,%al
    29a4:	19 00                	sbb    %eax,(%rax)
    29a6:	00 3c c7             	add    %bh,(%rdi,%rax,8)
    29a9:	01 39                	add    %edi,(%rcx)
    29ab:	19 00                	sbb    %eax,(%rax)
    29ad:	00 3d 3a 1a 00 00    	add    %bh,0x1a3a(%rip)        # 43ed <_license+0x2353>
    29b3:	00 3c c6             	add    %bh,(%rsi,%rax,8)
    29b6:	01 44 19 00          	add    %eax,0x0(%rcx,%rbx,1)
    29ba:	00 42 06             	add    %al,0x6(%rdx)
    29bd:	4d 19 00             	sbb    %r8,(%r8)
    29c0:	00 3d 3a 1a 00 00    	add    %bh,0x1a3a(%rip)        # 4400 <_license+0x2366>
    29c6:	00 40 8f             	add    %al,-0x71(%rax)
    29c9:	04 57                	add    $0x57,%al
    29cb:	19 00                	sbb    %eax,(%rax)
    29cd:	00 40 80             	add    %al,-0x80(%rax)
    29d0:	08 60 19             	or     %ah,0x19(%rax)
    29d3:	00 00                	add    %al,(%rax)
    29d5:	40 08 69 19          	or     %bpl,0x19(%rcx)
	...
    29e1:	3d 3b 34 00 00       	cmp    $0x343b,%eax
    29e6:	00 40 81             	add    %al,-0x7f(%rax)
    29e9:	04 40                	add    $0x40,%al
    29eb:	0e                   	(bad)
    29ec:	00 00                	add    %al,(%rax)
    29ee:	3c e1                	cmp    $0xe1,%al
    29f0:	01 49 0e             	add    %ecx,0xe(%rcx)
    29f3:	00 00                	add    %al,(%rax)
    29f5:	3d 3b 1a 00 00       	cmp    $0x1a3b,%eax
    29fa:	00 3c e0             	add    %bh,(%rax,%riz,8)
    29fd:	01 53 0e             	add    %edx,0xe(%rbx)
    2a00:	00 00                	add    %al,(%rax)
    2a02:	42 06                	rex.X (bad)
    2a04:	5c                   	pop    %rsp
    2a05:	0e                   	(bad)
    2a06:	00 00                	add    %al,(%rax)
    2a08:	3d 3b 1a 00 00       	cmp    $0x1a3b,%eax
    2a0d:	00 40 81             	add    %al,-0x7f(%rax)
    2a10:	04 66                	add    $0x66,%al
    2a12:	0e                   	(bad)
    2a13:	00 00                	add    %al,(%rax)
    2a15:	40 80 08 6f          	rex orb $0x6f,(%rax)
    2a19:	0e                   	(bad)
    2a1a:	00 00                	add    %al,(%rax)
    2a1c:	40 08 78 0e          	or     %dil,0xe(%rax)
    2a20:	00 00                	add    %al,(%rax)
    2a22:	00 00                	add    %al,(%rax)
    2a24:	00 39                	add    %bh,(%rcx)
    2a26:	09 1b                	or     %ebx,(%rbx)
    2a28:	00 00                	add    %al,(%rax)
    2a2a:	12 00                	adc    (%rax),%al
    2a2c:	ff 03                	incl   (%rbx)
    2a2e:	0c 3a                	or     $0x3a,%al
    2a30:	e2 01                	loop   2a33 <_license+0x999>
    2a32:	1b 1b                	sbb    (%rbx),%ebx
    2a34:	00 00                	add    %al,(%rax)
    2a36:	3a e3                	cmp    %bl,%ah
    2a38:	01 23                	add    %esp,(%rbx)
    2a3a:	1b 00                	sbb    (%rax),%eax
    2a3c:	00 3a                	add    %bh,(%rdx)
    2a3e:	e4 01                	in     $0x1,%al
    2a40:	2b 1b                	sub    (%rbx),%ebx
    2a42:	00 00                	add    %al,(%rax)
    2a44:	3a e5                	cmp    %ch,%ah
    2a46:	01 33                	add    %esi,(%rbx)
    2a48:	1b 00                	sbb    (%rax),%eax
    2a4a:	00 3b                	add    %bh,(%rbx)
    2a4c:	03 91 c0 00 3b 1b    	add    0x1b3b00c0(%rcx),%edx
    2a52:	00 00                	add    %al,(%rax)
    2a54:	3c e6                	cmp    $0xe6,%al
    2a56:	01 44 1b 00          	add    %eax,0x0(%rbx,%rbx,1)
    2a5a:	00 3c e7             	add    %bh,(%rdi,%riz,8)
    2a5d:	01 4d 1b             	add    %ecx,0x1b(%rbp)
    2a60:	00 00                	add    %al,(%rax)
    2a62:	3c e8                	cmp    $0xe8,%al
    2a64:	01 56 1b             	add    %edx,0x1b(%rsi)
    2a67:	00 00                	add    %al,(%rax)
    2a69:	3c f2                	cmp    $0xf2,%al
    2a6b:	01 5f 1b             	add    %ebx,0x1b(%rdi)
    2a6e:	00 00                	add    %al,(%rax)
    2a70:	3c f3                	cmp    $0xf3,%al
    2a72:	01 68 1b             	add    %ebp,0x1b(%rax)
    2a75:	00 00                	add    %al,(%rax)
    2a77:	41 78 19             	rex.B js 2a93 <_license+0x9f9>
    2a7a:	00 00                	add    %al,(%rax)
    2a7c:	3c 61                	cmp    $0x61,%al
    2a7e:	00 00                	add    %al,(%rax)
    2a80:	00 00                	add    %al,(%rax)
    2a82:	66 11 40 82          	adc    %ax,-0x7e(%rax)
    2a86:	04 8a                	add    $0x8a,%al
    2a88:	19 00                	sbb    %eax,(%rax)
    2a8a:	00 3c ea             	add    %bh,(%rdx,%rbp,8)
    2a8d:	01 93 19 00 00 3d    	add    %edx,0x3d000019(%rbx)
    2a93:	3c 1c                	cmp    $0x1c,%al
    2a95:	00 00                	add    %al,(%rax)
    2a97:	00 3c e9             	add    %bh,(%rcx,%rbp,8)
    2a9a:	01 9d 19 00 00 42    	add    %ebx,0x42000019(%rbp)
    2aa0:	06                   	(bad)
    2aa1:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2aa2:	19 00                	sbb    %eax,(%rax)
    2aa4:	00 3d 3c 1c 00 00    	add    %bh,0x1c3c(%rip)        # 46e6 <_license+0x264c>
    2aaa:	00 40 82             	add    %al,-0x7e(%rax)
    2aad:	04 ae                	add    $0xae,%al
    2aaf:	19 00                	sbb    %eax,(%rax)
    2ab1:	00 40 80             	add    %al,-0x80(%rax)
    2ab4:	08 b6 19 00 00 40    	or     %dh,0x40000019(%rsi)
    2aba:	08 be 19 00 00 00    	or     %bh,0x19(%rsi)
    2ac0:	00 00                	add    %al,(%rax)
    2ac2:	44 13 3c eb          	adc    (%rbx,%rbp,8),%r15d
    2ac6:	01 79 1b             	add    %edi,0x1b(%rcx)
    2ac9:	00 00                	add    %al,(%rax)
    2acb:	47 dc 1b             	rex.RXB fcompl (%r11)
    2ace:	00 00                	add    %al,(%rax)
    2ad0:	14 00                	adc    $0x0,%al
    2ad2:	8f                   	(bad)
    2ad3:	0c 3a                	or     $0x3a,%al
    2ad5:	ec                   	in     (%dx),%al
    2ad6:	01 e5                	add    %esp,%ebp
    2ad8:	1b 00                	sbb    (%rax),%eax
    2ada:	00 3a                	add    %bh,(%rdx)
    2adc:	ed                   	in     (%dx),%eax
    2add:	01 ed                	add    %ebp,%ebp
    2adf:	1b 00                	sbb    (%rax),%eax
    2ae1:	00 41 25             	add    %al,0x25(%rcx)
    2ae4:	1c 00                	sbb    $0x0,%al
    2ae6:	00 3d 50 00 00 00    	add    %bh,0x50(%rip)        # 2b3c <_license+0xaa2>
    2aec:	00 22                	add    %ah,(%rdx)
    2aee:	0c 3a                	or     $0x3a,%al
    2af0:	ee                   	out    %al,(%dx)
    2af1:	01 2e                	add    %ebp,(%rsi)
    2af3:	1c 00                	sbb    $0x0,%al
    2af5:	00 46 80             	add    %al,-0x80(%rsi)
    2af8:	84 80 10 40 1c 00    	test   %al,0x1c4010(%rax)
    2afe:	00 41 f7             	add    %al,-0x9(%rcx)
    2b01:	1b 00                	sbb    (%rax),%eax
    2b03:	00 3d 50 00 00 00    	add    %bh,0x50(%rip)        # 2b59 <_license+0xabf>
    2b09:	0a 6f 0a             	or     0xa(%rdi),%ch
    2b0c:	3a ef                	cmp    %bh,%ch
    2b0e:	01 00                	add    %eax,(%rax)
    2b10:	1c 00                	sbb    $0x0,%al
    2b12:	00 3a                	add    %bh,(%rdx)
    2b14:	f0 01 09             	lock add %ecx,(%rcx)
    2b17:	1c 00                	sbb    $0x0,%al
    2b19:	00 3a                	add    %bh,(%rdx)
    2b1b:	f1                   	int1
    2b1c:	01 12                	add    %edx,(%rdx)
    2b1e:	1c 00                	sbb    $0x0,%al
    2b20:	00 46 f7             	add    %al,-0x9(%rsi)
    2b23:	81 b7 85 fe ff ff ff 	xorl   $0x1b01ffff,-0x17b(%rdi)
    2b2a:	ff 01 1b 
    2b2d:	1c 00                	sbb    $0x0,%al
    2b2f:	00 41 4a             	add    %al,0x4a(%rcx)
    2b32:	1c 00                	sbb    $0x0,%al
    2b34:	00 3e                	add    %bh,(%rsi)
    2b36:	05 00 00 00 0a       	add    $0xa000000,%eax
    2b3b:	6a 03                	push   $0x3
    2b3d:	3f                   	(bad)
    2b3e:	01 54 53 1c          	add    %edx,0x1c(%rbx,%rdx,2)
    2b42:	00 00                	add    %al,(%rax)
    2b44:	46 0e                	rex.RX (bad)
    2b46:	5c                   	pop    %rsp
    2b47:	1c 00                	sbb    $0x0,%al
    2b49:	00 00                	add    %al,(%rax)
    2b4b:	41                   	rex.B
    2b4c:	4a 1c 00             	rex.WX sbb $0x0,%al
    2b4f:	00 3f                	add    %bh,(%rdi)
    2b51:	05 00 00 00 0a       	add    $0xa000000,%eax
    2b56:	6a 03                	push   $0x3
    2b58:	3f                   	(bad)
    2b59:	01 52 53             	add    %edx,0x53(%rdx)
    2b5c:	1c 00                	sbb    $0x0,%al
    2b5e:	00 46 0b             	add    %al,0xb(%rsi)
    2b61:	5c                   	pop    %rsp
    2b62:	1c 00                	sbb    $0x0,%al
    2b64:	00 00                	add    %al,(%rax)
    2b66:	41                   	rex.B
    2b67:	4a 1c 00             	rex.WX sbb $0x0,%al
    2b6a:	00 40 05             	add    %al,0x5(%rax)
    2b6d:	00 00                	add    %al,(%rax)
    2b6f:	00 0a                	add    %cl,(%rdx)
    2b71:	6a 03                	push   $0x3
    2b73:	3f                   	(bad)
    2b74:	01 51 53             	add    %edx,0x53(%rcx)
    2b77:	1c 00                	sbb    $0x0,%al
    2b79:	00 46 19             	add    %al,0x19(%rsi)
    2b7c:	5c                   	pop    %rsp
    2b7d:	1c 00                	sbb    $0x0,%al
    2b7f:	00 00                	add    %al,(%rax)
    2b81:	41                   	rex.B
    2b82:	4a 1c 00             	rex.WX sbb $0x0,%al
    2b85:	00 41 05             	add    %al,0x5(%rcx)
    2b88:	00 00                	add    %al,(%rax)
    2b8a:	00 0a                	add    %cl,(%rdx)
    2b8c:	6a 03                	push   $0x3
    2b8e:	3f                   	(bad)
    2b8f:	01 54 53 1c          	add    %edx,0x1c(%rbx,%rdx,2)
    2b93:	00 00                	add    %al,(%rax)
    2b95:	46 10 5c 1c 00       	adc    %r11b,0x0(%rsp,%r11,1)
    2b9a:	00 00                	add    %al,(%rax)
    2b9c:	41                   	rex.B
    2b9d:	4a 1c 00             	rex.WX sbb $0x0,%al
    2ba0:	00 42 05             	add    %al,0x5(%rdx)
    2ba3:	00 00                	add    %al,(%rax)
    2ba5:	00 0a                	add    %cl,(%rdx)
    2ba7:	6a 03                	push   $0x3
    2ba9:	3f                   	(bad)
    2baa:	01 52 53             	add    %edx,0x53(%rdx)
    2bad:	1c 00                	sbb    $0x0,%al
    2baf:	00 46 04             	add    %al,0x4(%rsi)
    2bb2:	5c                   	pop    %rsp
    2bb3:	1c 00                	sbb    $0x0,%al
    2bb5:	00 00                	add    %al,(%rax)
    2bb7:	41                   	rex.B
    2bb8:	4a 1c 00             	rex.WX sbb $0x0,%al
    2bbb:	00 43 03             	add    %al,0x3(%rbx)
    2bbe:	00 00                	add    %al,(%rax)
    2bc0:	00 0a                	add    %cl,(%rdx)
    2bc2:	6a 03                	push   $0x3
    2bc4:	3f                   	(bad)
    2bc5:	01 51 53             	add    %edx,0x53(%rcx)
    2bc8:	1c 00                	sbb    $0x0,%al
    2bca:	00 46 0e             	add    %al,0xe(%rsi)
    2bcd:	5c                   	pop    %rsp
    2bce:	1c 00                	sbb    $0x0,%al
    2bd0:	00 00                	add    %al,(%rax)
    2bd2:	41                   	rex.B
    2bd3:	4a 1c 00             	rex.WX sbb $0x0,%al
    2bd6:	00 44 03 00          	add    %al,0x0(%rbx,%rax,1)
    2bda:	00 00                	add    %al,(%rax)
    2bdc:	0a 6a 03             	or     0x3(%rdx),%ch
    2bdf:	3f                   	(bad)
    2be0:	01 54 53 1c          	add    %edx,0x1c(%rbx,%rdx,2)
    2be4:	00 00                	add    %al,(%rax)
    2be6:	46 18 5c 1c 00       	sbb    %r11b,0x0(%rsp,%r11,1)
    2beb:	00 00                	add    %al,(%rax)
    2bed:	00 00                	add    %al,(%rax)
    2bef:	00 44 15 3c          	add    %al,0x3c(%rbp,%rdx,1)
    2bf3:	f4                   	hlt
    2bf4:	01 83 1b 00 00 42    	add    %eax,0x4200001b(%rbx)
    2bfa:	02 8b 1b 00 00 44    	add    0x4400001b(%rbx),%cl
    2c00:	16                   	(bad)
    2c01:	3b 01                	cmp    (%rcx),%eax
    2c03:	51                   	push   %rcx
    2c04:	94                   	xchg   %eax,%esp
    2c05:	1b 00                	sbb    (%rax),%eax
    2c07:	00 40 80             	add    %al,-0x80(%rax)
    2c0a:	84 80 10 9c 1b 00    	test   %al,0x1b9c10(%rax)
    2c10:	00 40 08             	add    %al,0x8(%rax)
    2c13:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    2c14:	1b 00                	sbb    (%rax),%eax
    2c16:	00 00                	add    %al,(%rax)
    2c18:	00 41 aa             	add    %al,-0x56(%rcx)
    2c1b:	1c 00                	sbb    $0x0,%al
    2c1d:	00 45 28             	add    %al,0x28(%rbp)
    2c20:	00 00                	add    %al,(%rax)
    2c22:	00 00                	add    %al,(%rax)
    2c24:	9a                   	(bad)
    2c25:	07                   	(bad)
    2c26:	40 89 04 af          	rex mov %eax,(%rdi,%rbp,4)
    2c2a:	1c 00                	sbb    $0x0,%al
    2c2c:	00 3c f9             	add    %bh,(%rcx,%rdi,8)
    2c2f:	01 b8 1c 00 00 3d    	add    %edi,0x3d00001c(%rax)
    2c35:	45 1a 00             	sbb    (%r8),%r8b
    2c38:	00 00                	add    %al,(%rax)
    2c3a:	3c f8                	cmp    $0xf8,%al
    2c3c:	01 c2                	add    %eax,%edx
    2c3e:	1c 00                	sbb    $0x0,%al
    2c40:	00 42 06             	add    %al,0x6(%rdx)
    2c43:	ca 1c 00             	lret   $0x1c
    2c46:	00 3d 45 1a 00 00    	add    %bh,0x1a45(%rip)        # 4691 <_license+0x25f7>
    2c4c:	00 40 89             	add    %al,-0x77(%rax)
    2c4f:	04 d3                	add    $0xd3,%al
    2c51:	1c 00                	sbb    $0x0,%al
    2c53:	00 40 80             	add    %al,-0x80(%rax)
    2c56:	08 db                	or     %bl,%bl
    2c58:	1c 00                	sbb    $0x0,%al
    2c5a:	00 40 08             	add    %al,0x8(%rax)
    2c5d:	e3 1c                	jrcxz  2c7b <_license+0xbe1>
    2c5f:	00 00                	add    %al,(%rax)
    2c61:	00 00                	add    %al,(%rax)
    2c63:	00 00                	add    %al,(%rax)
    2c65:	3d 46 06 00 00       	cmp    $0x646,%eax
    2c6a:	00 3c f5 01 b0 1b 00 	add    %bh,0x1bb001(,%rsi,8)
    2c71:	00 42 02             	add    %al,0x2(%rdx)
    2c74:	b8 1b 00 00 3d       	mov    $0x3d00001b,%eax
    2c79:	46 06                	rex.RX (bad)
    2c7b:	00 00                	add    %al,(%rax)
    2c7d:	00 3b                	add    %bh,(%rbx)
    2c7f:	01 56 c1             	add    %edx,-0x3f(%rsi)
    2c82:	1b 00                	sbb    (%rax),%eax
    2c84:	00 40 80             	add    %al,-0x80(%rax)
    2c87:	20 c9                	and    %cl,%cl
    2c89:	1b 00                	sbb    (%rax),%eax
    2c8b:	00 40 18             	add    %al,0x18(%rax)
    2c8e:	d1 1b                	rcrl   (%rbx)
    2c90:	00 00                	add    %al,(%rax)
    2c92:	00 00                	add    %al,(%rax)
    2c94:	41                   	rex.B
    2c95:	66 1c 00             	data16 sbb $0x0,%al
    2c98:	00 47 28             	add    %al,0x28(%rdi)
    2c9b:	00 00                	add    %al,(%rax)
    2c9d:	00 00                	add    %al,(%rax)
    2c9f:	a3 05 40 89 04 6b 1c 	movabs %eax,0x1c6b04894005
    2ca6:	00 00 
    2ca8:	3c f7                	cmp    $0xf7,%al
    2caa:	01 74 1c 00          	add    %esi,0x0(%rsp,%rbx,1)
    2cae:	00 3d 47 1a 00 00    	add    %bh,0x1a47(%rip)        # 46fb <_license+0x2661>
    2cb4:	00 3c f6             	add    %bh,(%rsi,%rsi,8)
    2cb7:	01 7e 1c             	add    %edi,0x1c(%rsi)
    2cba:	00 00                	add    %al,(%rax)
    2cbc:	42 06                	rex.X (bad)
    2cbe:	86 1c 00             	xchg   %bl,(%rax,%rax,1)
    2cc1:	00 3d 47 1a 00 00    	add    %bh,0x1a47(%rip)        # 470e <_license+0x2674>
    2cc7:	00 40 89             	add    %al,-0x77(%rax)
    2cca:	04 8f                	add    $0x8f,%al
    2ccc:	1c 00                	sbb    $0x0,%al
    2cce:	00 40 80             	add    %al,-0x80(%rax)
    2cd1:	08 97 1c 00 00 40    	or     %dl,0x4000001c(%rdi)
    2cd7:	08 9f 1c 00 00 00    	or     %bl,0x1c(%rdi)
    2cdd:	00 00                	add    %al,(%rax)
    2cdf:	41 e4 1d             	rex.B in $0x1d,%al
    2ce2:	00 00                	add    %al,(%rax)
    2ce4:	48 12 00             	rex.W adc (%rax),%al
    2ce7:	00 00                	add    %al,(%rax)
    2ce9:	00 ab 05 3f 01 55    	add    %ch,0x55013f05(%rbx)
    2cef:	ee                   	out    %al,(%dx)
    2cf0:	1d 00 00 46 00       	sbb    $0x460000,%eax
    2cf5:	0a 1e                	or     (%rsi),%bl
    2cf7:	00 00                	add    %al,(%rax)
    2cf9:	00 00                	add    %al,(%rax)
    2cfb:	3e 14 1e             	ds adc $0x1e,%al
    2cfe:	00 00                	add    %al,(%rax)
    2d00:	49 5f                	rex.WB pop %r15
    2d02:	00 00                	add    %al,(%rax)
    2d04:	00 00                	add    %al,(%rax)
    2d06:	04 04                	add    $0x4,%al
    2d08:	0b 3f                	or     (%rdi),%edi
    2d0a:	04 91                	add    $0x91,%al
    2d0c:	e8 00 9f 1e 1e       	call   1e1ecc11 <_license+0x1e1eab77>
    2d11:	00 00                	add    %al,(%rax)
    2d13:	3f                   	(bad)
    2d14:	02 30                	add    (%rax),%dh
    2d16:	9f                   	lahf
    2d17:	39 1e                	cmp    %ebx,(%rsi)
    2d19:	00 00                	add    %al,(%rax)
    2d1b:	3b 04 75 80 02 9f 42 	cmp    0x429f0280(,%rsi,2),%eax
    2d22:	1e                   	(bad)
    2d23:	00 00                	add    %al,(%rax)
    2d25:	40 00 4c 1e 00       	rex add %cl,0x0(%rsi,%rbx,1)
    2d2a:	00 3d 4a 34 00 00    	add    %bh,0x344a(%rip)        # 617a <_license+0x40e0>
    2d30:	00 3c 87             	add    %bh,(%rdi,%rax,4)
    2d33:	02 7f 1e             	add    0x1e(%rdi),%bh
    2d36:	00 00                	add    %al,(%rax)
    2d38:	3c 8a                	cmp    $0x8a,%al
    2d3a:	02 88 1e 00 00 3d    	add    0x3d00001e(%rax),%cl
    2d40:	4a 28 00             	rex.WX sub %al,(%rax)
    2d43:	00 00                	add    %al,(%rax)
    2d45:	3c 88                	cmp    $0x88,%al
    2d47:	02 93 1e 00 00 42    	add    0x4200001e(%rbx),%dl
    2d4d:	06                   	(bad)
    2d4e:	9c                   	pushf
    2d4f:	1e                   	(bad)
    2d50:	00 00                	add    %al,(%rax)
    2d52:	3d 4a 28 00 00       	cmp    $0x284a,%eax
    2d57:	00 3c 89             	add    %bh,(%rcx,%rcx,4)
    2d5a:	02 a6 1e 00 00 40    	add    0x4000001e(%rsi),%ah
    2d60:	80 20 af             	andb   $0xaf,(%rax)
    2d63:	1e                   	(bad)
    2d64:	00 00                	add    %al,(%rax)
    2d66:	40 08 b8 1e 00 00 00 	or     %dil,0x1e(%rax)
    2d6d:	00 00                	add    %al,(%rax)
    2d6f:	00 3d 4b 2e 00 00    	add    %bh,0x2e4b(%rip)        # 5bc0 <_license+0x3b26>
    2d75:	00 3c cf             	add    %bh,(%rdi,%rcx,8)
    2d78:	01 85 0e 00 00 42    	add    %eax,0x4200000e(%rbp)
    2d7e:	06                   	(bad)
    2d7f:	8e 0e                	mov    (%rsi),%cs
    2d81:	00 00                	add    %al,(%rax)
    2d83:	3d 4b 2e 00 00       	cmp    $0x2e4b,%eax
    2d88:	00 40 80             	add    %al,-0x80(%rax)
    2d8b:	08 98 0e 00 00 40    	or     %bl,0x4000000e(%rax)
    2d91:	08 a1 0e 00 00 00    	or     %ah,0xe(%rcx)
    2d97:	00 3d 4c 2c 00 00    	add    %bh,0x2c4c(%rip)        # 59e9 <_license+0x394f>
    2d9d:	00 3c d1             	add    %bh,(%rcx,%rdx,8)
    2da0:	01 b6 0e 00 00 42    	add    %esi,0x4200000e(%rsi)
    2da6:	06                   	(bad)
    2da7:	bf 0e 00 00 3d       	mov    $0x3d00000e,%edi
    2dac:	4c 2c 00             	rex.WR sub $0x0,%al
    2daf:	00 00                	add    %al,(%rax)
    2db1:	3c d2                	cmp    $0xd2,%al
    2db3:	01 c9                	add    %ecx,%ecx
    2db5:	0e                   	(bad)
    2db6:	00 00                	add    %al,(%rax)
    2db8:	3c d3                	cmp    $0xd3,%al
    2dba:	01 d2                	add    %edx,%edx
    2dbc:	0e                   	(bad)
    2dbd:	00 00                	add    %al,(%rax)
    2dbf:	00 00                	add    %al,(%rax)
    2dc1:	3e 28 1a             	ds sub %bl,(%rdx)
    2dc4:	00 00                	add    %al,(%rax)
    2dc6:	4d c3                	rex.WRB ret
    2dc8:	00 00                	add    %al,(%rax)
    2dca:	00 00                	add    %al,(%rax)
    2dcc:	2d 04 0a 3f 01       	sub    $0x13f0a04,%eax
    2dd1:	5d                   	pop    %rbp
    2dd2:	31 1a                	xor    %ebx,(%rdx)
    2dd4:	00 00                	add    %al,(%rax)
    2dd6:	3f                   	(bad)
    2dd7:	03 91 08 9f 41 1a    	add    0x1a419f08(%rcx),%edx
    2ddd:	00 00                	add    %al,(%rax)
    2ddf:	3f                   	(bad)
    2de0:	01 5c 49 1a          	add    %ebx,0x1a(%rcx,%rcx,2)
    2de4:	00 00                	add    %al,(%rax)
    2de6:	3a d4                	cmp    %ah,%dl
    2de8:	01 51 1a             	add    %edx,0x1a(%rcx)
    2deb:	00 00                	add    %al,(%rax)
    2ded:	3c d5                	cmp    $0xd5,%al
    2def:	01 61 1a             	add    %esp,0x1a(%rcx)
    2df2:	00 00                	add    %al,(%rax)
    2df4:	3c d6                	cmp    $0xd6,%al
    2df6:	01 6a 1a             	add    %ebp,0x1a(%rdx)
    2df9:	00 00                	add    %al,(%rax)
    2dfb:	3c d7                	cmp    $0xd7,%al
    2dfd:	01 72 1a             	add    %esi,0x1a(%rdx)
    2e00:	00 00                	add    %al,(%rax)
    2e02:	3c d8                	cmp    $0xd8,%al
    2e04:	01 7a 1a             	add    %edi,0x1a(%rdx)
    2e07:	00 00                	add    %al,(%rax)
    2e09:	3c d9                	cmp    $0xd9,%al
    2e0b:	01 82 1a 00 00 3c    	add    %eax,0x3c00001a(%rdx)
    2e11:	da 01                	fiaddl (%rcx)
    2e13:	59                   	pop    %rcx
    2e14:	1a 00                	sbb    (%rax),%al
    2e16:	00 3c db             	add    %bh,(%rbx,%rbx,8)
    2e19:	01 8b 1a 00 00 41    	add    %ecx,0x4100001a(%rbx)
    2e1f:	cb                   	lret
    2e20:	1a 00                	sbb    (%rax),%al
    2e22:	00 4e 31             	add    %cl,0x31(%rsi)
    2e25:	00 00                	add    %al,(%rax)
    2e27:	00 0d 75 03 3a dd    	add    %cl,-0x22c5fc8b(%rip)        # ffffffffdd3a31a2 <server_id_map+0x5ffffe641781a2>
    2e2d:	01 d8                	add    %ebx,%eax
    2e2f:	1a 00                	sbb    (%rax),%al
    2e31:	00 3f                	add    %bh,(%rdi)
    2e33:	0e                   	(bad)
    2e34:	7e 00                	jle    2e36 <_license+0xd9c>
    2e36:	10 ff                	adc    %bh,%bh
    2e38:	ff                   	(bad)
    2e39:	ff                   	(bad)
    2e3a:	ff 0f                	decl   (%rdi)
    2e3c:	1a 10                	sbb    (%rax),%dl
    2e3e:	ac                   	lods   %ds:(%rsi),%al
    2e3f:	21 21                	and    %esp,(%rcx)
    2e41:	9f                   	lahf
    2e42:	e0 1a                	loopne 2e5e <_license+0xdc4>
    2e44:	00 00                	add    %al,(%rax)
    2e46:	3f                   	(bad)
    2e47:	01 52 e8             	add    %edx,-0x18(%rdx)
    2e4a:	1a 00                	sbb    (%rax),%al
    2e4c:	00 3a                	add    %bh,(%rdx)
    2e4e:	dc 01                	faddl  (%rcx)
    2e50:	f0 1a 00             	lock sbb (%rax),%al
    2e53:	00 46 04             	add    %al,0x4(%rsi)
    2e56:	f8                   	clc
    2e57:	1a 00                	sbb    (%rax),%al
    2e59:	00 40 00             	add    %al,0x0(%rax)
    2e5c:	00 1b                	add    %bl,(%rbx)
    2e5e:	00 00                	add    %al,(%rax)
    2e60:	41 1f                	rex.B (bad)
    2e62:	13 00                	adc    (%rax),%eax
    2e64:	00 4f 0c             	add    %cl,0xc(%rdi)
    2e67:	00 00                	add    %al,(%rax)
    2e69:	00 0e                	add    %cl,(%rsi)
    2e6b:	48 03 3f             	add    (%rdi),%rdi
    2e6e:	03 70 0e             	add    0xe(%rax),%esi
    2e71:	9f                   	lahf
    2e72:	23 13                	and    (%rbx),%edx
    2e74:	00 00                	add    %al,(%rax)
    2e76:	3c df                	cmp    $0xdf,%al
    2e78:	01 33                	add    %esi,(%rbx)
    2e7a:	13 00                	adc    (%rax),%eax
    2e7c:	00 3d 4f 0c 00 00    	add    %bh,0xc4f(%rip)        # 3ad1 <_license+0x1a37>
    2e82:	00 3c de             	add    %bh,(%rsi,%rbx,8)
    2e85:	01 3c 13             	add    %edi,(%rbx,%rdx,1)
    2e88:	00 00                	add    %al,(%rax)
    2e8a:	00 00                	add    %al,(%rax)
    2e8c:	00 00                	add    %al,(%rax)
    2e8e:	3e ee                	ds out %al,(%dx)
    2e90:	1c 00                	sbb    $0x0,%al
    2e92:	00 50 bd             	add    %dl,-0x43(%rax)
    2e95:	00 00                	add    %al,(%rax)
    2e97:	00 00                	add    %al,(%rax)
    2e99:	29 04 0a             	sub    %eax,(%rdx,%rcx,1)
    2e9c:	3f                   	(bad)
    2e9d:	01 5d f7             	add    %ebx,-0x9(%rbp)
    2ea0:	1c 00                	sbb    $0x0,%al
    2ea2:	00 3f                	add    %bh,(%rdi)
    2ea4:	02 30                	add    (%rax),%dh
    2ea6:	9f                   	lahf
    2ea7:	07                   	(bad)
    2ea8:	1d 00 00 3f 03       	sbb    $0x33f0000,%eax
    2ead:	91                   	xchg   %eax,%ecx
    2eae:	08 9f 0f 1d 00 00    	or     %bl,0x1d0f(%rdi)
    2eb4:	3f                   	(bad)
    2eb5:	01 5c 17 1d          	add    %ebx,0x1d(%rdi,%rdx,1)
    2eb9:	00 00                	add    %al,(%rax)
    2ebb:	3a fa                	cmp    %dl,%bh
    2ebd:	01 1f                	add    %ebx,(%rdi)
    2ebf:	1d 00 00 3c fb       	sbb    $0xfb3c0000,%eax
    2ec4:	01 27                	add    %esp,(%rdi)
    2ec6:	1d 00 00 3c fc       	sbb    $0xfc3c0000,%eax
    2ecb:	01 2f                	add    %ebp,(%rdi)
    2ecd:	1d 00 00 3c fd       	sbb    $0xfd3c0000,%eax
    2ed2:	01 37                	add    %esi,(%rdi)
    2ed4:	1d 00 00 3c fe       	sbb    $0xfe3c0000,%eax
    2ed9:	01 40 1d             	add    %eax,0x1d(%rax)
    2edc:	00 00                	add    %al,(%rax)
    2ede:	3c ff                	cmp    $0xff,%al
    2ee0:	01 48 1d             	add    %ecx,0x1d(%rax)
    2ee3:	00 00                	add    %al,(%rax)
    2ee5:	3c 80                	cmp    $0x80,%al
    2ee7:	02 51 1d             	add    0x1d(%rcx),%dl
    2eea:	00 00                	add    %al,(%rax)
    2eec:	3c 81                	cmp    $0x81,%al
    2eee:	02 59 1d             	add    0x1d(%rcx),%bl
    2ef1:	00 00                	add    %al,(%rax)
    2ef3:	3c 82                	cmp    $0x82,%al
    2ef5:	02 61 1d             	add    0x1d(%rcx),%ah
    2ef8:	00 00                	add    %al,(%rax)
    2efa:	48 76 1d             	rex.W jbe 2f1a <_license+0xe80>
    2efd:	00 00                	add    %al,(%rax)
    2eff:	51                   	push   %rcx
    2f00:	04 00                	add    $0x0,%al
    2f02:	00 00                	add    %al,(%rax)
    2f04:	0d 4f 05 41 94       	or     $0x9441054f,%eax
    2f09:	1d 00 00 52 41       	sbb    $0x41520000,%eax
    2f0e:	00 00                	add    %al,(%rax)
    2f10:	00 0d 53 03 3a 83    	add    %cl,-0x7cc5fcad(%rip)        # ffffffff833a3269 <server_id_map+0x5ffffe0a178269>
    2f16:	02 a1 1d 00 00 3f    	add    0x3f00001d(%rcx),%ah
    2f1c:	01 5c b2 1d          	add    %ebx,0x1d(%rdx,%rsi,4)
    2f20:	00 00                	add    %al,(%rax)
    2f22:	46 04 c2             	rex.RX add $0xc2,%al
    2f25:	1d 00 00 00 00       	sbb    $0x0,%eax
    2f2a:	00 39                	add    %bh,(%rcx)
    2f2c:	4d 0b 00             	or     (%r8),%r8
    2f2f:	00 17                	add    %dl,(%rdi)
    2f31:	00 48 04             	add    %cl,0x4(%rax)
    2f34:	0c 3a                	or     $0x3a,%al
    2f36:	0d 56 0b 00 00       	or     $0xb56,%eax
    2f3b:	3a 0e                	cmp    (%rsi),%cl
    2f3d:	5f                   	pop    %rdi
    2f3e:	0b 00                	or     (%rax),%eax
    2f40:	00 3a                	add    %bh,(%rdx)
    2f42:	0f 68 0b             	punpckhbw (%rbx),%mm1
    2f45:	00 00                	add    %al,(%rax)
    2f47:	3b 02                	cmp    (%rdx),%eax
    2f49:	91                   	xchg   %eax,%ecx
    2f4a:	08 71 0b             	or     %dh,0xb(%rcx)
    2f4d:	00 00                	add    %al,(%rax)
    2f4f:	3b 03                	cmp    (%rbx),%eax
    2f51:	91                   	xchg   %eax,%ecx
    2f52:	e8 00 7a 0b 00       	call   ba957 <_license+0xb88bd>
    2f57:	00 3c 10             	add    %bh,(%rax,%rdx,1)
    2f5a:	83 0b 00             	orl    $0x0,(%rbx)
    2f5d:	00 3c 11             	add    %bh,(%rcx,%rdx,1)
    2f60:	8c 0b                	mov    %cs,(%rbx)
    2f62:	00 00                	add    %al,(%rax)
    2f64:	3c 12                	cmp    $0x12,%al
    2f66:	95                   	xchg   %eax,%ebp
    2f67:	0b 00                	or     (%rax),%eax
    2f69:	00 3c 24             	add    %bh,(%rsp)
    2f6c:	9e                   	sahf
    2f6d:	0b 00                	or     (%rax),%eax
    2f6f:	00 3c 25 a7 0b 00 00 	add    %bh,0xba7
    2f76:	3c 31                	cmp    $0x31,%al
    2f78:	b0 0b                	mov    $0xb,%al
    2f7a:	00 00                	add    %al,(%rax)
    2f7c:	3c 32                	cmp    $0x32,%al
    2f7e:	b9 0b 00 00 3c       	mov    $0x3c00000b,%ecx
    2f83:	68 c2 0b 00 00       	push   $0xbc2
    2f88:	3c 69                	cmp    $0x69,%al
    2f8a:	cb                   	lret
    2f8b:	0b 00                	or     (%rax),%eax
    2f8d:	00 3c 6b             	add    %bh,(%rbx,%rbp,2)
    2f90:	d4                   	(bad)
    2f91:	0b 00                	or     (%rax),%eax
    2f93:	00 3c 6d dd 0b 00 00 	add    %bh,0xbdd(,%rbp,2)
    2f9a:	3c 75                	cmp    $0x75,%al
    2f9c:	e6 0b                	out    %al,$0xb
    2f9e:	00 00                	add    %al,(%rax)
    2fa0:	3c f0                	cmp    $0xf0,%al
    2fa2:	02 f8                	add    %al,%bh
    2fa4:	0b 00                	or     (%rax),%eax
    2fa6:	00 3d 53 1d 00 00    	add    %bh,0x1d53(%rip)        # 4cff <_license+0x2c65>
    2fac:	00 3c 13             	add    %bh,(%rbx,%rdx,1)
    2faf:	1d 0c 00 00 00       	sbb    $0xc,%eax
    2fb4:	39 71 0f             	cmp    %esi,0xf(%rcx)
    2fb7:	00 00                	add    %al,(%rax)
    2fb9:	18 00                	sbb    %al,(%rax)
    2fbb:	bd 02 0c 3a 26       	mov    $0x263a0c02,%ebp
    2fc0:	7a 0f                	jp     2fd1 <_license+0xf37>
    2fc2:	00 00                	add    %al,(%rax)
    2fc4:	3a 27                	cmp    (%rdi),%ah
    2fc6:	8c 0f                	mov    %cs,(%rdi)
    2fc8:	00 00                	add    %al,(%rax)
    2fca:	3a 28                	cmp    (%rax),%ch
    2fcc:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    2fcd:	0f 00 00             	sldt   (%rax)
    2fd0:	3a 29                	cmp    (%rcx),%ch
    2fd2:	b0 0f                	mov    $0xf,%al
    2fd4:	00 00                	add    %al,(%rax)
    2fd6:	3a 2a                	cmp    (%rdx),%ch
    2fd8:	b9 0f 00 00 3c       	mov    $0x3c00000f,%ecx
    2fdd:	2b cb                	sub    %ebx,%ecx
    2fdf:	0f 00 00             	sldt   (%rax)
    2fe2:	3c 2c                	cmp    $0x2c,%al
    2fe4:	d4                   	(bad)
    2fe5:	0f 00 00             	sldt   (%rax)
    2fe8:	00 39                	add    %bh,(%rcx)
    2fea:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    2feb:	12 00                	adc    (%rax),%al
    2fed:	00 19                	add    %bl,(%rcx)
    2fef:	00 c2                	add    %al,%dl
    2ff1:	02 0c 3a             	add    (%rdx,%rdi,1),%cl
    2ff4:	33 b0 12 00 00 3a    	xor    0x3a000012(%rax),%esi
    2ffa:	34 b9                	xor    $0xb9,%al
    2ffc:	12 00                	adc    (%rax),%al
    2ffe:	00 3a                	add    %bh,(%rdx)
    3000:	35 c2 12 00 00       	xor    $0x12c2,%eax
    3005:	3a 36                	cmp    (%rsi),%dh
    3007:	cb                   	lret
    3008:	12 00                	adc    (%rax),%al
    300a:	00 3a                	add    %bh,(%rdx)
    300c:	37                   	(bad)
    300d:	d4                   	(bad)
    300e:	12 00                	adc    (%rax),%al
    3010:	00 39                	add    %bh,(%rcx)
    3012:	46 13 00             	rex.RX adc (%rax),%r8d
    3015:	00 1a                	add    %bl,(%rdx)
    3017:	0b 5a 01             	or     0x1(%rdx),%ebx
    301a:	0c 3a                	or     $0x3a,%al
    301c:	2d 4e 13 00 00       	sub    $0x134e,%eax
    3021:	3a 2e                	cmp    (%rsi),%ch
    3023:	56                   	push   %rsi
    3024:	13 00                	adc    (%rax),%eax
    3026:	00 3a                	add    %bh,(%rdx)
    3028:	54                   	push   %rsp
    3029:	5e                   	pop    %rsi
    302a:	13 00                	adc    (%rax),%eax
    302c:	00 3a                	add    %bh,(%rdx)
    302e:	2f                   	(bad)
    302f:	66 13 00             	adc    (%rax),%ax
    3032:	00 3c 30             	add    %bh,(%rax,%rsi,1)
    3035:	6e                   	outsb  %ds:(%rsi),(%dx)
    3036:	13 00                	adc    (%rax),%eax
    3038:	00 3c 55 76 13 00 00 	add    %bh,0x1376(,%rdx,2)
    303f:	3d 54 2f 00 00       	cmp    $0x2f54,%eax
    3044:	00 40 8c             	add    %al,-0x74(%rax)
    3047:	04 7f                	add    $0x7f,%al
    3049:	13 00                	adc    (%rax),%eax
    304b:	00 3c 52             	add    %bh,(%rdx,%rdx,2)
    304e:	87 13                	xchg   %edx,(%rbx)
    3050:	00 00                	add    %al,(%rax)
    3052:	3c 53                	cmp    $0x53,%al
    3054:	90                   	nop
    3055:	13 00                	adc    (%rax),%eax
    3057:	00 3d 54 10 00 00    	add    %bh,0x1054(%rip)        # 40b1 <_license+0x2017>
    305d:	00 3c 51             	add    %bh,(%rcx,%rdx,2)
    3060:	99                   	cltd
    3061:	13 00                	adc    (%rax),%eax
    3063:	00 42 06             	add    %al,0x6(%rdx)
    3066:	a1 13 00 00 3d 54 10 	movabs 0x10543d000013,%eax
    306d:	00 00 
    306f:	00 40 8c             	add    %al,-0x74(%rax)
    3072:	04 aa                	add    $0xaa,%al
    3074:	13 00                	adc    (%rax),%eax
    3076:	00 40 80             	add    %al,-0x80(%rax)
    3079:	08 b2 13 00 00 40    	or     %dh,0x40000013(%rdx)
    307f:	08 ba 13 00 00 00    	or     %bh,0x13(%rdx)
    3085:	00 00                	add    %al,(%rax)
    3087:	00 39                	add    %bh,(%rcx)
    3089:	87 11                	xchg   %edx,(%rcx)
    308b:	00 00                	add    %al,(%rax)
    308d:	1b 0b                	sbb    (%rbx),%ecx
    308f:	5c                   	pop    %rsp
    3090:	01 0c 3a             	add    %ecx,(%rdx,%rdi,1)
    3093:	38 90 11 00 00 3a    	cmp    %dl,0x3a000011(%rax)
    3099:	39 99 11 00 00 3a    	cmp    %ebx,0x3a000011(%rcx)
    309f:	3a a2 11 00 00 3a    	cmp    0x3a000011(%rdx),%ah
    30a5:	3b ab 11 00 00 3c    	cmp    0x3c000011(%rbx),%ebp
    30ab:	3c b4                	cmp    $0xb4,%al
    30ad:	11 00                	adc    %eax,(%rax)
    30af:	00 3c 65 bd 11 00 00 	add    %bh,0x11bd(,%riz,2)
    30b6:	3e de 12             	ds ficoms (%rdx)
    30b9:	00 00                	add    %al,(%rax)
    30bb:	55                   	push   %rbp
    30bc:	67 00 00             	add    %al,(%eax)
    30bf:	00 0b                	add    %cl,(%rbx)
    30c1:	1f                   	(bad)
    30c2:	01 0c 3f             	add    %ecx,(%rdi,%rdi,1)
    30c5:	01 53 e6             	add    %edx,-0x1a(%rbx)
    30c8:	12 00                	adc    (%rax),%al
    30ca:	00 3f                	add    %bh,(%rdi)
    30cc:	01 5f ee             	add    %ebx,-0x12(%rdi)
    30cf:	12 00                	adc    (%rax),%al
    30d1:	00 3c 3d f6 12 00 00 	add    %bh,0x12f6(,%rdi,1)
    30d8:	40 00 fe             	add    %dil,%sil
    30db:	12 00                	adc    (%rax),%al
    30dd:	00 3c 3e             	add    %bh,(%rsi,%rdi,1)
    30e0:	06                   	(bad)
    30e1:	13 00                	adc    (%rax),%eax
    30e3:	00 3c 3f             	add    %bh,(%rdi,%rdi,1)
    30e6:	0e                   	(bad)
    30e7:	13 00                	adc    (%rax),%eax
    30e9:	00 41 1f             	add    %al,0x1f(%rcx)
    30ec:	13 00                	adc    (%rax),%eax
    30ee:	00 56 3c             	add    %dl,0x3c(%rsi)
    30f1:	00 00                	add    %al,(%rax)
    30f3:	00 0b                	add    %cl,(%rbx)
    30f5:	59                   	pop    %rcx
    30f6:	03 3c 41             	add    (%rcx,%rax,2),%edi
    30f9:	33 13                	xor    (%rbx),%edx
    30fb:	00 00                	add    %al,(%rax)
    30fd:	3d 56 3c 00 00       	cmp    $0x3c56,%eax
    3102:	00 3c 40             	add    %bh,(%rax,%rax,2)
    3105:	3c 13                	cmp    $0x13,%al
    3107:	00 00                	add    %al,(%rax)
    3109:	00 00                	add    %al,(%rax)
    310b:	00 3d 57 28 00 00    	add    %bh,0x2857(%rip)        # 5968 <_license+0x38ce>
    3111:	00 40 8d             	add    %al,-0x73(%rax)
    3114:	04 c7                	add    $0xc7,%al
    3116:	11 00                	adc    %eax,(%rax)
    3118:	00 3c 64             	add    %bh,(%rsp,%riz,2)
    311b:	d0 11                	rclb   (%rcx)
    311d:	00 00                	add    %al,(%rax)
    311f:	3d 57 10 00 00       	cmp    $0x1057,%eax
    3124:	00 3c 63             	add    %bh,(%rbx,%riz,2)
    3127:	e3 11                	jrcxz  313a <_license+0x10a0>
    3129:	00 00                	add    %al,(%rax)
    312b:	42 06                	rex.X (bad)
    312d:	ec                   	in     (%dx),%al
    312e:	11 00                	adc    %eax,(%rax)
    3130:	00 3d 57 10 00 00    	add    %bh,0x1057(%rip)        # 418d <_license+0x20f3>
    3136:	00 40 8d             	add    %al,-0x73(%rax)
    3139:	04 f6                	add    $0xf6,%al
    313b:	11 00                	adc    %eax,(%rax)
    313d:	00 40 80             	add    %al,-0x80(%rax)
    3140:	08 ff                	or     %bh,%bh
    3142:	11 00                	adc    %eax,(%rax)
    3144:	00 40 08             	add    %al,0x8(%rax)
    3147:	08 12                	or     %dl,(%rdx)
    3149:	00 00                	add    %al,(%rax)
    314b:	00 00                	add    %al,(%rax)
    314d:	00 00                	add    %al,(%rax)
    314f:	00 3e                	add    %bh,(%rsi)
    3151:	fa                   	cli
    3152:	14 00                	adc    $0x0,%al
    3154:	00 58 2a             	add    %bl,0x2a(%rax)
    3157:	00 00                	add    %al,(%rax)
    3159:	00 00                	add    %al,(%rax)
    315b:	f8                   	clc
    315c:	02 0a                	add    (%rdx),%cl
    315e:	3f                   	(bad)
    315f:	01 53 03             	add    %edx,0x3(%rbx)
    3162:	15 00 00 3f 01       	adc    $0x13f0000,%eax
    3167:	5f                   	pop    %rdi
    3168:	0b 15 00 00 3f 02    	or     0x23f0000(%rip),%edx        # 23f316e <_license+0x23f10d4>
    316e:	31 9f 13 15 00 00    	xor    %ebx,0x1513(%rdi)
    3174:	3f                   	(bad)
    3175:	03 91 08 9f 1b 15    	add    0x151b9f08(%rcx),%edx
    317b:	00 00                	add    %al,(%rax)
    317d:	3b 11                	cmp    (%rcx),%edx
    317f:	72 00                	jb     3181 <_license+0x10e7>
    3181:	10 ff                	adc    %bh,%bh
    3183:	01 1a                	add    %ebx,(%rdx)
    3185:	a8 ba                	test   $0xba,%al
    3187:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    318e:	00 9f 23 15 00 00    	add    %bl,0x1523(%rdi)
    3194:	3c 43                	cmp    $0x43,%al
    3196:	2b 15 00 00 41 1d    	sub    0x1d410000(%rip),%edx        # 1d41319c <_license+0x1d411102>
    319c:	16                   	(bad)
    319d:	00 00                	add    %al,(%rax)
    319f:	59                   	pop    %rcx
    31a0:	02 00                	add    (%rax),%al
    31a2:	00 00                	add    %al,(%rax)
    31a4:	09 7b 0f             	or     %edi,0xf(%rbx)
    31a7:	3f                   	(bad)
    31a8:	02 31                	add    (%rcx),%dh
    31aa:	9f                   	lahf
    31ab:	26 16                	es (bad)
    31ad:	00 00                	add    %al,(%rax)
    31af:	3f                   	(bad)
    31b0:	11 72 00             	adc    %esi,0x0(%rdx)
    31b3:	10 ff                	adc    %bh,%bh
    31b5:	01 1a                	add    %ebx,(%rdx)
    31b7:	a8 ba                	test   $0xba,%al
    31b9:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    31c0:	00 9f 2e 16 00 00    	add    %bl,0x162e(%rdi)
    31c6:	00 00                	add    %al,(%rax)
    31c8:	3e 20 17             	ds and %dl,(%rdi)
    31cb:	00 00                	add    %al,(%rax)
    31cd:	5a                   	pop    %rdx
    31ce:	17                   	(bad)
    31cf:	00 00                	add    %al,(%rax)
    31d1:	00 00                	add    %al,(%rax)
    31d3:	fc                   	cld
    31d4:	02 0a                	add    (%rdx),%cl
    31d6:	3f                   	(bad)
    31d7:	01 53 29             	add    %edx,0x29(%rbx)
    31da:	17                   	(bad)
    31db:	00 00                	add    %al,(%rax)
    31dd:	3f                   	(bad)
    31de:	01 5f 31             	add    %ebx,0x31(%rdi)
    31e1:	17                   	(bad)
    31e2:	00 00                	add    %al,(%rax)
    31e4:	3f                   	(bad)
    31e5:	02 31                	add    (%rcx),%dh
    31e7:	9f                   	lahf
    31e8:	39 17                	cmp    %edx,(%rdi)
    31ea:	00 00                	add    %al,(%rax)
    31ec:	3f                   	(bad)
    31ed:	03 91 08 9f 41 17    	add    0x17419f08(%rcx),%edx
    31f3:	00 00                	add    %al,(%rax)
    31f5:	3b 11                	cmp    (%rcx),%edx
    31f7:	72 00                	jb     31f9 <_license+0x115f>
    31f9:	10 ff                	adc    %bh,%bh
    31fb:	01 1a                	add    %ebx,(%rdx)
    31fd:	a8 ba                	test   $0xba,%al
    31ff:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    3206:	00 9f 49 17 00 00    	add    %bl,0x1749(%rdi)
    320c:	3c 62                	cmp    $0x62,%al
    320e:	51                   	push   %rcx
    320f:	17                   	(bad)
    3210:	00 00                	add    %al,(%rax)
    3212:	41 1d 16 00 00 5b    	rex.B sbb $0x5b000016,%eax
    3218:	02 00                	add    (%rax),%al
    321a:	00 00                	add    %al,(%rax)
    321c:	09 61 0f             	or     %esp,0xf(%rcx)
    321f:	3f                   	(bad)
    3220:	02 31                	add    (%rcx),%dh
    3222:	9f                   	lahf
    3223:	26 16                	es (bad)
    3225:	00 00                	add    %al,(%rax)
    3227:	3f                   	(bad)
    3228:	11 72 00             	adc    %esi,0x0(%rdx)
    322b:	10 ff                	adc    %bh,%bh
    322d:	01 1a                	add    %ebx,(%rdx)
    322f:	a8 ba                	test   $0xba,%al
    3231:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    3238:	00 9f 2e 16 00 00    	add    %bl,0x162e(%rdi)
    323e:	00 00                	add    %al,(%rax)
    3240:	3d 5c 5a 00 00       	cmp    $0x5a5c,%eax
    3245:	00 40 01             	add    %al,0x1(%rax)
    3248:	31 0c 00             	xor    %ecx,(%rax,%rax,1)
    324b:	00 3e                	add    %bh,(%rsi)
    324d:	79 16                	jns    3265 <_license+0x11cb>
    324f:	00 00                	add    %al,(%rax)
    3251:	5c                   	pop    %rsp
    3252:	5a                   	pop    %rdx
    3253:	00 00                	add    %al,(%rax)
    3255:	00 00                	add    %al,(%rax)
    3257:	ed                   	in     (%dx),%eax
    3258:	02 0e                	add    (%rsi),%cl
    325a:	3f                   	(bad)
    325b:	03 91 08 9f 82 16    	add    0x16829f08(%rcx),%edx
    3261:	00 00                	add    %al,(%rax)
    3263:	3f                   	(bad)
    3264:	02 31                	add    (%rcx),%dh
    3266:	9f                   	lahf
    3267:	8a 16                	mov    (%rsi),%dl
    3269:	00 00                	add    %al,(%rax)
    326b:	3b 03                	cmp    (%rbx),%eax
    326d:	91                   	xchg   %eax,%ecx
    326e:	c0 00 9a             	rolb   $0x9a,(%rax)
    3271:	16                   	(bad)
    3272:	00 00                	add    %al,(%rax)
    3274:	3c 59                	cmp    $0x59,%al
    3276:	a3 16 00 00 3c 5b ac 	movabs %eax,0x16ac5b3c000016
    327d:	16 00 
    327f:	00 3d 5d 15 00 00    	add    %bh,0x155d(%rip)        # 47e2 <_license+0x2748>
    3285:	00 3c 56             	add    %bh,(%rsi,%rdx,2)
    3288:	b5 16                	mov    $0x16,%ch
    328a:	00 00                	add    %al,(%rax)
    328c:	42 01 bd 16 00 00 41 	rex.X add %edi,0x41000016(%rbp)
    3293:	02 17                	add    (%rdi),%dl
    3295:	00 00                	add    %al,(%rax)
    3297:	5d                   	pop    %rbp
    3298:	15 00 00 00 00       	adc    $0x0,%eax
    329d:	d5                   	(bad)
    329e:	1c 3a                	sbb    $0x3a,%al
    32a0:	57                   	push   %rdi
    32a1:	0c 17                	or     $0x17,%al
    32a3:	00 00                	add    %al,(%rax)
    32a5:	3a 58 16             	cmp    0x16(%rax),%bl
    32a8:	17                   	(bad)
    32a9:	00 00                	add    %al,(%rax)
    32ab:	00 00                	add    %al,(%rax)
    32ad:	3d 5e 1e 00 00       	cmp    $0x1e5e,%eax
    32b2:	00 40 86             	add    %al,-0x7a(%rax)
    32b5:	04 c7                	add    $0xc7,%al
    32b7:	16                   	(bad)
    32b8:	00 00                	add    %al,(%rax)
    32ba:	3d 5e 10 00 00       	cmp    $0x105e,%eax
    32bf:	00 3c 5a             	add    %bh,(%rdx,%rbx,2)
    32c2:	d0 16                	rclb   (%rsi)
    32c4:	00 00                	add    %al,(%rax)
    32c6:	42 06                	rex.X (bad)
    32c8:	d8 16                	fcoms  (%rsi)
    32ca:	00 00                	add    %al,(%rax)
    32cc:	3d 5e 10 00 00       	cmp    $0x105e,%eax
    32d1:	00 40 86             	add    %al,-0x7a(%rax)
    32d4:	04 e1                	add    $0xe1,%al
    32d6:	16                   	(bad)
    32d7:	00 00                	add    %al,(%rax)
    32d9:	40 80 08 e9          	rex orb $0xe9,(%rax)
    32dd:	16                   	(bad)
    32de:	00 00                	add    %al,(%rax)
    32e0:	40 08 f1             	or     %sil,%cl
    32e3:	16                   	(bad)
    32e4:	00 00                	add    %al,(%rax)
    32e6:	00 00                	add    %al,(%rax)
    32e8:	00 00                	add    %al,(%rax)
    32ea:	00 3d 5f 5a 00 00    	add    %bh,0x5a5f(%rip)        # 8d4f <_license+0x6cb5>
    32f0:	00 40 01             	add    %al,0x1(%rax)
    32f3:	3c 0c                	cmp    $0xc,%al
    32f5:	00 00                	add    %al,(%rax)
    32f7:	3e 79 16             	jns,pt 3310 <_license+0x1276>
    32fa:	00 00                	add    %al,(%rax)
    32fc:	5f                   	pop    %rdi
    32fd:	5a                   	pop    %rdx
    32fe:	00 00                	add    %al,(%rax)
    3300:	00 00                	add    %al,(%rax)
    3302:	e4 02                	in     $0x2,%al
    3304:	0e                   	(bad)
    3305:	3f                   	(bad)
    3306:	03 91 08 9f 82 16    	add    0x16829f08(%rcx),%edx
    330c:	00 00                	add    %al,(%rax)
    330e:	3f                   	(bad)
    330f:	02 31                	add    (%rcx),%dh
    3311:	9f                   	lahf
    3312:	8a 16                	mov    (%rsi),%dl
    3314:	00 00                	add    %al,(%rax)
    3316:	3b 03                	cmp    (%rbx),%eax
    3318:	91                   	xchg   %eax,%ecx
    3319:	c0 00 9a             	rolb   $0x9a,(%rax)
    331c:	16                   	(bad)
    331d:	00 00                	add    %al,(%rax)
    331f:	3c 5f                	cmp    $0x5f,%al
    3321:	a3 16 00 00 3c 61 ac 	movabs %eax,0x16ac613c000016
    3328:	16 00 
    332a:	00 3d 60 15 00 00    	add    %bh,0x1560(%rip)        # 4890 <_license+0x27f6>
    3330:	00 3c 5c             	add    %bh,(%rsp,%rbx,2)
    3333:	b5 16                	mov    $0x16,%ch
    3335:	00 00                	add    %al,(%rax)
    3337:	42 01 bd 16 00 00 41 	rex.X add %edi,0x41000016(%rbp)
    333e:	02 17                	add    (%rdi),%dl
    3340:	00 00                	add    %al,(%rax)
    3342:	60                   	(bad)
    3343:	15 00 00 00 00       	adc    $0x0,%eax
    3348:	d5                   	(bad)
    3349:	1c 3a                	sbb    $0x3a,%al
    334b:	5d                   	pop    %rbp
    334c:	0c 17                	or     $0x17,%al
    334e:	00 00                	add    %al,(%rax)
    3350:	3a 5e 16             	cmp    0x16(%rsi),%bl
    3353:	17                   	(bad)
    3354:	00 00                	add    %al,(%rax)
    3356:	00 00                	add    %al,(%rax)
    3358:	3d 61 1e 00 00       	cmp    $0x1e61,%eax
    335d:	00 40 86             	add    %al,-0x7a(%rax)
    3360:	04 c7                	add    $0xc7,%al
    3362:	16                   	(bad)
    3363:	00 00                	add    %al,(%rax)
    3365:	3d 61 10 00 00       	cmp    $0x1061,%eax
    336a:	00 3c 60             	add    %bh,(%rax,%riz,2)
    336d:	d0 16                	rclb   (%rsi)
    336f:	00 00                	add    %al,(%rax)
    3371:	42 06                	rex.X (bad)
    3373:	d8 16                	fcoms  (%rsi)
    3375:	00 00                	add    %al,(%rax)
    3377:	3d 61 10 00 00       	cmp    $0x1061,%eax
    337c:	00 40 86             	add    %al,-0x7a(%rax)
    337f:	04 e1                	add    $0xe1,%al
    3381:	16                   	(bad)
    3382:	00 00                	add    %al,(%rax)
    3384:	40 80 08 e9          	rex orb $0xe9,(%rax)
    3388:	16                   	(bad)
    3389:	00 00                	add    %al,(%rax)
    338b:	40 08 f1             	or     %sil,%cl
    338e:	16                   	(bad)
    338f:	00 00                	add    %al,(%rax)
    3391:	00 00                	add    %al,(%rax)
    3393:	00 00                	add    %al,(%rax)
    3395:	00 3d 62 1b 00 00    	add    %bh,0x1b62(%rip)        # 4efd <_license+0x2e63>
    339b:	00 3c 66             	add    %bh,(%rsi,%riz,2)
    339e:	47 0c 00             	rex.RXB or $0x0,%al
    33a1:	00 42 01             	add    %al,0x1(%rdx)
    33a4:	50                   	push   %rax
    33a5:	0c 00                	or     $0x0,%al
    33a7:	00 3e                	add    %bh,(%rsi)
    33a9:	02 17                	add    (%rdi),%dl
    33ab:	00 00                	add    %al,(%rax)
    33ad:	62                   	(bad)
    33ae:	1b 00                	sbb    (%rax),%eax
    33b0:	00 00                	add    %al,(%rax)
    33b2:	00 17                	add    %dl,(%rdi)
    33b4:	03 0e                	add    (%rsi),%ecx
    33b6:	3a 67 0c             	cmp    0xc(%rdi),%ah
    33b9:	17                   	(bad)
    33ba:	00 00                	add    %al,(%rax)
    33bc:	00 00                	add    %al,(%rax)
    33be:	3d 63 0e 00 00       	cmp    $0xe63,%eax
    33c3:	00 3c 79             	add    %bh,(%rcx,%rdi,2)
    33c6:	5b                   	pop    %rbx
    33c7:	0c 00                	or     $0x0,%al
    33c9:	00 42 01             	add    %al,0x1(%rdx)
    33cc:	64 0c 00             	fs or  $0x0,%al
    33cf:	00 43 02             	add    %al,0x2(%rbx)
    33d2:	17                   	(bad)
    33d3:	00 00                	add    %al,(%rax)
    33d5:	63 0e                	movsxd (%rsi),%ecx
    33d7:	00 00                	add    %al,(%rax)
    33d9:	00 00                	add    %al,(%rax)
    33db:	1a 03                	sbb    (%rbx),%al
    33dd:	10 00                	adc    %al,(%rax)
    33df:	3d 64 10 00 00       	cmp    $0x1064,%eax
    33e4:	00 3c 6a             	add    %bh,(%rdx,%rbp,2)
    33e7:	6f                   	outsl  %ds:(%rsi),(%dx)
    33e8:	0c 00                	or     $0x0,%al
    33ea:	00 42 06             	add    %al,0x6(%rdx)
    33ed:	78 0c                	js     33fb <_license+0x1361>
    33ef:	00 00                	add    %al,(%rax)
    33f1:	3d 64 10 00 00       	cmp    $0x1064,%eax
    33f6:	00 40 80             	add    %al,-0x80(%rax)
    33f9:	04 82                	add    $0x82,%al
    33fb:	0c 00                	or     $0x0,%al
    33fd:	00 40 80             	add    %al,-0x80(%rax)
    3400:	08 8b 0c 00 00 40    	or     %cl,0x4000000c(%rbx)
    3406:	08 94 0c 00 00 00 00 	or     %dl,0x0(%rsp,%rcx,1)
    340d:	3d 65 0c 00 00       	cmp    $0xc65,%eax
    3412:	00 3c 6c             	add    %bh,(%rsp,%rbp,2)
    3415:	a0 0c 00 00 00 44 1c 	movabs 0x6f3c1c440000000c,%al
    341c:	3c 6f 
    341e:	ab                   	stos   %eax,%es:(%rdi)
    341f:	0c 00                	or     $0x0,%al
    3421:	00 3c 70             	add    %bh,(%rax,%rsi,2)
    3424:	b4 0c                	mov    $0xc,%ah
    3426:	00 00                	add    %al,(%rax)
    3428:	44 1d 3c 6e be 0c    	rex.R sbb $0xcbe6e3c,%eax
    342e:	00 00                	add    %al,(%rax)
    3430:	3c 71                	cmp    $0x71,%al
    3432:	c7                   	(bad)
    3433:	0c 00                	or     $0x0,%al
    3435:	00 3c 72             	add    %bh,(%rdx,%rsi,2)
    3438:	d0 0c 00             	rorb   (%rax,%rax,1)
    343b:	00 00                	add    %al,(%rax)
    343d:	00 3d 66 31 00 00    	add    %bh,0x3166(%rip)        # 65a9 <_license+0x450f>
    3443:	00 40 83             	add    %al,-0x7d(%rax)
    3446:	04 dc                	add    $0xdc,%al
    3448:	0c 00                	or     $0x0,%al
    344a:	00 3c 74             	add    %bh,(%rsp,%rsi,2)
    344d:	e5 0c                	in     $0xc,%eax
    344f:	00 00                	add    %al,(%rax)
    3451:	3d 66 10 00 00       	cmp    $0x1066,%eax
    3456:	00 3c 73             	add    %bh,(%rbx,%rsi,2)
    3459:	ef                   	out    %eax,(%dx)
    345a:	0c 00                	or     $0x0,%al
    345c:	00 42 06             	add    %al,0x6(%rdx)
    345f:	f8                   	clc
    3460:	0c 00                	or     $0x0,%al
    3462:	00 3d 66 10 00 00    	add    %bh,0x1066(%rip)        # 44ce <_license+0x2434>
    3468:	00 40 83             	add    %al,-0x7d(%rax)
    346b:	04 02                	add    $0x2,%al
    346d:	0d 00 00 40 80       	or     $0x80400000,%eax
    3472:	08 0b                	or     %cl,(%rbx)
    3474:	0d 00 00 40 08       	or     $0x8400000,%eax
    3479:	14 0d                	adc    $0xd,%al
    347b:	00 00                	add    %al,(%rax)
    347d:	00 00                	add    %al,(%rax)
    347f:	00 44 1e 3c          	add    %al,0x3c(%rsi,%rbx,1)
    3483:	9b                   	fwait
    3484:	01 2b                	add    %ebp,(%rbx)
    3486:	0d 00 00 3c 9d       	or     $0x9d3c0000,%eax
    348b:	01 34 0d 00 00 3c 84 	add    %esi,-0x7bc40000(,%rcx,1)
    3492:	02 3d 0d 00 00 3d    	add    0x3d00000d(%rip),%bh        # 3d0034a5 <_license+0x3d00140b>
    3498:	67 10 00             	adc    %al,(%eax)
    349b:	00 00                	add    %al,(%rax)
    349d:	3c 9c                	cmp    $0x9c,%al
    349f:	01 47 0d             	add    %eax,0xd(%rdi)
    34a2:	00 00                	add    %al,(%rax)
    34a4:	42 06                	rex.X (bad)
    34a6:	50                   	push   %rax
    34a7:	0d 00 00 3d 67       	or     $0x673d0000,%eax
    34ac:	10 00                	adc    %al,(%rax)
    34ae:	00 00                	add    %al,(%rax)
    34b0:	40 00 5a 0d          	rex add %bl,0xd(%rdx)
    34b4:	00 00                	add    %al,(%rax)
    34b6:	40 01 63 0d          	rex add %esp,0xd(%rbx)
    34ba:	00 00                	add    %al,(%rax)
    34bc:	40 08 6c 0d 00       	or     %bpl,0x0(%rbp,%rcx,1)
    34c1:	00 00                	add    %al,(%rax)
    34c3:	00 39                	add    %bh,(%rcx)
    34c5:	96                   	xchg   %eax,%esi
    34c6:	17                   	(bad)
    34c7:	00 00                	add    %al,(%rax)
    34c9:	1f                   	(bad)
    34ca:	00 74 03 26          	add    %dh,0x26(%rbx,%rax,1)
    34ce:	3a 9e 01 a0 17 00    	cmp    0x17a001(%rsi),%bl
    34d4:	00 3a                	add    %bh,(%rdx)
    34d6:	9f                   	lahf
    34d7:	01 a9 17 00 00 3a    	add    %ebp,0x3a000017(%rcx)
    34dd:	a0 01 b2 17 00 00 3c 	movabs 0x1a13c000017b201,%al
    34e4:	a1 01 
    34e6:	c4                   	(bad)
    34e7:	17                   	(bad)
    34e8:	00 00                	add    %al,(%rax)
    34ea:	3c a2                	cmp    $0xa2,%al
    34ec:	01 ce                	add    %ecx,%esi
    34ee:	17                   	(bad)
    34ef:	00 00                	add    %al,(%rax)
    34f1:	3c a3                	cmp    $0xa3,%al
    34f3:	01 d8                	add    %ebx,%eax
    34f5:	17                   	(bad)
    34f6:	00 00                	add    %al,(%rax)
    34f8:	3c a4                	cmp    $0xa4,%al
    34fa:	01 e2                	add    %esp,%edx
    34fc:	17                   	(bad)
    34fd:	00 00                	add    %al,(%rax)
    34ff:	3c cb                	cmp    $0xcb,%al
    3501:	01 ec                	add    %ebp,%esp
    3503:	17                   	(bad)
    3504:	00 00                	add    %al,(%rax)
    3506:	44 20 3c ca          	and    %r15b,(%rdx,%rcx,8)
    350a:	01 09                	add    %ecx,(%rcx)
    350c:	18 00                	sbb    %al,(%rax)
    350e:	00 00                	add    %al,(%rax)
    3510:	00 3e                	add    %bh,(%rsi)
    3512:	c9                   	leave
    3513:	19 00                	sbb    %eax,(%rax)
    3515:	00 68 41             	add    %ch,0x41(%rax)
    3518:	00 00                	add    %al,(%rax)
    351a:	00 00                	add    %al,(%rax)
    351c:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    351d:	03 09                	add    (%rcx),%ecx
    351f:	3f                   	(bad)
    3520:	02 31                	add    (%rcx),%dh
    3522:	9f                   	lahf
    3523:	d8 19                	fcomps (%rcx)
    3525:	00 00                	add    %al,(%rax)
    3527:	3f                   	(bad)
    3528:	02 30                	add    (%rax),%dh
    352a:	9f                   	lahf
    352b:	e2 19                	loop   3546 <_license+0x14ac>
    352d:	00 00                	add    %al,(%rax)
    352f:	3c c1                	cmp    $0xc1,%al
    3531:	01 ec                	add    %ebp,%esp
    3533:	19 00                	sbb    %eax,(%rax)
    3535:	00 3d 68 33 00 00    	add    %bh,0x3368(%rip)        # 68a3 <_license+0x4809>
    353b:	00 3c c0             	add    %bh,(%rax,%rax,8)
    353e:	01 f7                	add    %esi,%edi
    3540:	19 00                	sbb    %eax,(%rax)
    3542:	00 42 06             	add    %al,0x6(%rdx)
    3545:	00 1a                	add    %bl,(%rdx)
    3547:	00 00                	add    %al,(%rax)
    3549:	3d 68 33 00 00       	cmp    $0x3368,%eax
    354e:	00 40 80             	add    %al,-0x80(%rax)
    3551:	04 0a                	add    $0xa,%al
    3553:	1a 00                	sbb    (%rax),%al
    3555:	00 40 08             	add    %al,0x8(%rax)
    3558:	13 1a                	adc    (%rdx),%ebx
    355a:	00 00                	add    %al,(%rax)
    355c:	00 00                	add    %al,(%rax)
    355e:	00 44 21 3c          	add    %al,0x3c(%rcx,%riz,1)
    3562:	8c 02                	mov    %es,(%rdx)
    3564:	78 0d                	js     3573 <_license+0x14d9>
    3566:	00 00                	add    %al,(%rax)
    3568:	39 cb                	cmp    %ecx,%ebx
    356a:	1d 00 00 22 00       	sbb    $0x220000,%eax
    356f:	78 03                	js     3574 <_license+0x14da>
    3571:	09 3a                	or     %edi,(%rdx)
    3573:	85 02                	test   %eax,(%rdx)
    3575:	d1 1d 00 00 3a 86    	rcrl   -0x79c60000(%rip)        # ffffffff863a357b <server_id_map+0x5ffffe0d17857b>
    357b:	02 da                	add    %dl,%bl
    357d:	1d 00 00 00 3d       	sbb    $0x3d000000,%eax
    3582:	69 05 00 00 00 3c 8d 	imul   $0xd8b028d,0x3c000000(%rip),%eax        # 3c00358c <_license+0x3c0014f2>
    3589:	02 8b 0d 
    358c:	00 00                	add    %al,(%rax)
    358e:	42 02 94 0d 00 00 3d 	add    0x693d0000(%rbp,%r9,1),%dl
    3595:	69 
    3596:	05 00 00 00 3b       	add    $0x3b000000,%eax
    359b:	01 50 9e             	add    %edx,-0x62(%rax)
    359e:	0d 00 00 40 fe       	or     $0xfe400000,%eax
    35a3:	ff                   	(bad)
    35a4:	ff 07                	incl   (%rdi)
    35a6:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    35a7:	0d 00 00 40 08       	or     $0x8400000,%eax
    35ac:	b0 0d                	mov    $0xd,%al
    35ae:	00 00                	add    %al,(%rax)
    35b0:	00 00                	add    %al,(%rax)
    35b2:	44 23 3c 93          	and    (%rbx,%rdx,4),%r15d
    35b6:	02 bc 0d 00 00 3d 6a 	add    0x6a3d0000(%rbp,%rcx,1),%bh
    35bd:	20 00                	and    %al,(%rax)
    35bf:	00 00                	add    %al,(%rax)
    35c1:	3c 8e                	cmp    $0x8e,%al
    35c3:	02 c6                	add    %dh,%al
    35c5:	0d 00 00 42 02       	or     $0x2420000,%eax
    35ca:	cf                   	iret
    35cb:	0d 00 00 3d 6a       	or     $0x6a3d0000,%eax
    35d0:	20 00                	and    %al,(%rax)
    35d2:	00 00                	add    %al,(%rax)
    35d4:	3c 8f                	cmp    $0x8f,%al
    35d6:	02 d9                	add    %cl,%bl
    35d8:	0d 00 00 40 80       	or     $0x80400000,%eax
    35dd:	20 e2                	and    %ah,%dl
    35df:	0d 00 00 40 18       	or     $0x18400000,%eax
    35e4:	eb 0d                	jmp    35f3 <_license+0x1559>
    35e6:	00 00                	add    %al,(%rax)
    35e8:	00 00                	add    %al,(%rax)
    35ea:	39 f6                	cmp    %esi,%esi
    35ec:	1e                   	(bad)
    35ed:	00 00                	add    %al,(%rax)
    35ef:	24 00                	and    $0x0,%al
    35f1:	8e 03                	mov    (%rbx),%es
    35f3:	17                   	(bad)
    35f4:	3a 90 02 00 1f 00    	cmp    0x1f0002(%rax),%dl
    35fa:	00 3a                	add    %bh,(%rdx)
    35fc:	91                   	xchg   %eax,%ecx
    35fd:	02 09                	add    (%rcx),%cl
    35ff:	1f                   	(bad)
    3600:	00 00                	add    %al,(%rax)
    3602:	3b 03                	cmp    (%rbx),%eax
    3604:	91                   	xchg   %eax,%ecx
    3605:	c0 00 12             	rolb   $0x12,(%rax)
    3608:	1f                   	(bad)
    3609:	00 00                	add    %al,(%rax)
    360b:	3c 92                	cmp    $0x92,%al
    360d:	02 1c 1f             	add    (%rdi,%rbx,1),%bl
    3610:	00 00                	add    %al,(%rax)
    3612:	3e 02 17             	ds add (%rdi),%dl
    3615:	00 00                	add    %al,(%rax)
    3617:	6b 0b 00             	imul   $0x0,(%rbx),%ecx
    361a:	00 00                	add    %al,(%rax)
    361c:	00 6a 02             	add    %ch,0x2(%rdx)
    361f:	22 3f                	and    (%rdi),%bh
    3621:	01 55 0c             	add    %edx,0xc(%rbp)
    3624:	17                   	(bad)
    3625:	00 00                	add    %al,(%rax)
    3627:	00 39                	add    %bh,(%rcx)
    3629:	78 19                	js     3644 <_license+0x15aa>
    362b:	00 00                	add    %al,(%rax)
    362d:	25 00 74 02 07       	and    $0x7027400,%eax
    3632:	3c e2                	cmp    $0xe2,%al
    3634:	02 8a 19 00 00 3c    	add    0x3c000019(%rdx),%cl
    363a:	e4 02                	in     $0x2,%al
    363c:	93                   	xchg   %eax,%ebx
    363d:	19 00                	sbb    %eax,(%rax)
    363f:	00 3d 6c 1a 00 00    	add    %bh,0x1a6c(%rip)        # 50b1 <_license+0x3017>
    3645:	00 3c e3             	add    %bh,(%rbx,%riz,8)
    3648:	02 9d 19 00 00 42    	add    0x42000019(%rbp),%bl
    364e:	06                   	(bad)
    364f:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    3650:	19 00                	sbb    %eax,(%rax)
    3652:	00 3d 6c 1a 00 00    	add    %bh,0x1a6c(%rip)        # 50c4 <_license+0x302a>
    3658:	00 40 82             	add    %al,-0x7e(%rax)
    365b:	04 ae                	add    $0xae,%al
    365d:	19 00                	sbb    %eax,(%rax)
    365f:	00 40 80             	add    %al,-0x80(%rax)
    3662:	08 b6 19 00 00 40    	or     %dh,0x40000019(%rsi)
    3668:	08 be 19 00 00 00    	or     %bh,0x19(%rsi)
    366e:	00 00                	add    %al,(%rax)
    3670:	3e e4 1d             	ds in  $0x1d,%al
    3673:	00 00                	add    %al,(%rax)
    3675:	6d                   	insl   (%dx),%es:(%rdi)
    3676:	12 00                	adc    (%rax),%al
    3678:	00 00                	add    %al,(%rax)
    367a:	00 79 02             	add    %bh,0x2(%rcx)
    367d:	03 3f                	add    (%rdi),%edi
    367f:	01 55 ee             	add    %edx,-0x12(%rbp)
    3682:	1d 00 00 45 f8       	sbb    $0xf8450000,%eax
    3687:	1d 00 00 3a ef       	sbb    $0xef3a0000,%eax
    368c:	02 01                	add    (%rcx),%al
    368e:	1e                   	(bad)
    368f:	00 00                	add    %al,(%rax)
    3691:	46 00 0a             	rex.RX add %r9b,(%rdx)
    3694:	1e                   	(bad)
    3695:	00 00                	add    %al,(%rax)
    3697:	00 00                	add    %al,(%rax)
    3699:	3e c9                	ds leave
    369b:	19 00                	sbb    %eax,(%rax)
    369d:	00 6e 35             	add    %ch,0x35(%rsi)
    36a0:	00 00                	add    %al,(%rax)
    36a2:	00 00                	add    %al,(%rax)
    36a4:	93                   	xchg   %eax,%ebx
    36a5:	03 0f                	add    (%rdi),%ecx
    36a7:	3f                   	(bad)
    36a8:	02 30                	add    (%rax),%dh
    36aa:	9f                   	lahf
    36ab:	d8 19                	fcomps (%rcx)
    36ad:	00 00                	add    %al,(%rax)
    36af:	3f                   	(bad)
    36b0:	02 31                	add    (%rcx),%dh
    36b2:	9f                   	lahf
    36b3:	e2 19                	loop   36ce <_license+0x1634>
    36b5:	00 00                	add    %al,(%rax)
    36b7:	3c ee                	cmp    $0xee,%al
    36b9:	02 ec                	add    %ah,%ch
    36bb:	19 00                	sbb    %eax,(%rax)
    36bd:	00 3d 6e 2a 00 00    	add    %bh,0x2a6e(%rip)        # 6131 <_license+0x4097>
    36c3:	00 3c ed 02 f7 19 00 	add    %bh,0x19f702(,%rbp,8)
    36ca:	00 42 06             	add    %al,0x6(%rdx)
    36cd:	00 1a                	add    %bl,(%rdx)
    36cf:	00 00                	add    %al,(%rax)
    36d1:	3d 6e 2a 00 00       	cmp    $0x2a6e,%eax
    36d6:	00 40 80             	add    %al,-0x80(%rax)
    36d9:	04 0a                	add    $0xa,%al
    36db:	1a 00                	sbb    (%rax),%al
    36dd:	00 40 08             	add    %al,0x8(%rax)
    36e0:	13 1a                	adc    (%rdx),%ebx
	...
    36ea:	3d 6f 43 00 00       	cmp    $0x436f,%eax
    36ef:	00 40 8b             	add    %al,-0x75(%rax)
    36f2:	04 fa                	add    $0xfa,%al
    36f4:	0d 00 00 3c a7       	or     $0xa73c0000,%eax
    36f9:	01 03                	add    %eax,(%rbx)
    36fb:	0e                   	(bad)
    36fc:	00 00                	add    %al,(%rax)
    36fe:	3d 6f 1a 00 00       	cmp    $0x1a6f,%eax
    3703:	00 3c a6             	add    %bh,(%rsi,%riz,4)
    3706:	01 0d 0e 00 00 42    	add    %ecx,0x4200000e(%rip)        # 4200371a <_license+0x42001680>
    370c:	06                   	(bad)
    370d:	16                   	(bad)
    370e:	0e                   	(bad)
    370f:	00 00                	add    %al,(%rax)
    3711:	3d 6f 1a 00 00       	cmp    $0x1a6f,%eax
    3716:	00 40 8b             	add    %al,-0x75(%rax)
    3719:	04 20                	add    $0x20,%al
    371b:	0e                   	(bad)
    371c:	00 00                	add    %al,(%rax)
    371e:	40 80 08 29          	rex orb $0x29,(%rax)
    3722:	0e                   	(bad)
    3723:	00 00                	add    %al,(%rax)
    3725:	40 08 32             	or     %sil,(%rdx)
    3728:	0e                   	(bad)
    3729:	00 00                	add    %al,(%rax)
    372b:	00 00                	add    %al,(%rax)
    372d:	3e 15 18 00 00 70    	ds adc $0x70000018,%eax
    3733:	0c 00                	or     $0x0,%al
    3735:	00 00                	add    %al,(%rax)
    3737:	00 6a 03             	add    %ch,0x3(%rdx)
    373a:	0b 3f                	or     (%rdi),%edi
    373c:	01 53 1f             	add    %edx,0x1f(%rbx)
    373f:	18 00                	sbb    %al,(%rax)
    3741:	00 3f                	add    %bh,(%rdi)
    3743:	02 31                	add    (%rcx),%dh
    3745:	9f                   	lahf
    3746:	31 18                	xor    %ebx,(%rax)
    3748:	00 00                	add    %al,(%rax)
    374a:	40 0e                	rex (bad)
    374c:	3a 18                	cmp    (%rax),%bl
    374e:	00 00                	add    %al,(%rax)
    3750:	3d 70 0c 00 00       	cmp    $0xc70,%eax
    3755:	00 3b                	add    %bh,(%rbx)
    3757:	03 73 36             	add    0x36(%rbx),%esi
    375a:	9f                   	lahf
    375b:	44 18 00             	sbb    %r8b,(%rax)
    375e:	00 00                	add    %al,(%rax)
    3760:	00 00                	add    %al,(%rax)
    3762:	3e 5a                	ds pop %rdx
    3764:	18 00                	sbb    %al,(%rax)
    3766:	00 71 6e             	add    %dh,0x6e(%rcx)
    3769:	00 00                	add    %al,(%rax)
    376b:	00 00                	add    %al,(%rax)
    376d:	dc 03                	faddl  (%rbx)
    376f:	07                   	(bad)
    3770:	3a 94 02 68 18 00 00 	cmp    0x1868(%rdx,%rax,1),%dl
    3777:	3a 95 02 70 18 00    	cmp    0x187002(%rbp),%dl
    377d:	00 3a                	add    %bh,(%rdx)
    377f:	96                   	xchg   %eax,%esi
    3780:	02 78 18             	add    0x18(%rax),%bh
    3783:	00 00                	add    %al,(%rax)
    3785:	3c 97                	cmp    $0x97,%al
    3787:	02 81 18 00 00 3c    	add    0x3c000018(%rcx),%al
    378d:	98                   	cwtl
    378e:	02 8a 18 00 00 3c    	add    0x3c000018(%rdx),%cl
    3794:	99                   	cltd
    3795:	02 93 18 00 00 41    	add    0x41000018(%rbx),%dl
    379b:	02 17                	add    (%rdi),%dl
    379d:	00 00                	add    %al,(%rax)
    379f:	71 0b                	jno    37ac <_license+0x1712>
    37a1:	00 00                	add    %al,(%rax)
    37a3:	00 00                	add    %al,(%rax)
    37a5:	b8 0d 3f 01 55       	mov    $0x55013f0d,%eax
    37aa:	0c 17                	or     $0x17,%al
    37ac:	00 00                	add    %al,(%rax)
    37ae:	00 3d 72 1a 00 00    	add    %bh,0x1a72(%rip)        # 5226 <_license+0x318c>
    37b4:	00 3c 9b             	add    %bh,(%rbx,%rbx,4)
    37b7:	02 9c 18 00 00 42 02 	add    0x2420000(%rax,%rbx,1),%bl
    37be:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    37bf:	18 00                	sbb    %al,(%rax)
    37c1:	00 3d 72 1a 00 00    	add    %bh,0x1a72(%rip)        # 5239 <_license+0x319f>
    37c7:	00 3c 9a             	add    %bh,(%rdx,%rbx,4)
    37ca:	02 ad 18 00 00 40    	add    0x40000018(%rbp),%ch
    37d0:	80 20 b5             	andb   $0xb5,(%rax)
    37d3:	18 00                	sbb    %al,(%rax)
    37d5:	00 40 18             	add    %al,0x18(%rax)
    37d8:	bd 18 00 00 00       	mov    $0x18,%ebp
    37dd:	00 00                	add    %al,(%rax)
    37df:	3e cd 18             	ds int $0x18
    37e2:	00 00                	add    %al,(%rax)
    37e4:	73 cc                	jae    37b2 <_license+0x1718>
    37e6:	00 00                	add    %al,(%rax)
    37e8:	00 00                	add    %al,(%rax)
    37ea:	e9 03 05 3f 03       	jmp    33f3cf2 <_license+0x33f1c58>
    37ef:	91                   	xchg   %eax,%ecx
    37f0:	08 9f e0 18 00 00    	or     %bl,0x18e0(%rdi)
    37f6:	3a 9c 02 e9 18 00 00 	cmp    0x18e9(%rdx,%rax,1),%bl
    37fd:	3f                   	(bad)
    37fe:	04 91                	add    $0x91,%al
    3800:	e8 00 9f f2 18       	call   18f2d705 <_license+0x18f2b66b>
    3805:	00 00                	add    %al,(%rax)
    3807:	3e 78 19             	js,pt  3823 <_license+0x1789>
    380a:	00 00                	add    %al,(%rax)
    380c:	74 5e                	je     386c <_license+0x17d2>
    380e:	00 00                	add    %al,(%rax)
    3810:	00 00                	add    %al,(%rax)
    3812:	93                   	xchg   %eax,%ebx
    3813:	02 32                	add    (%rdx),%dh
    3815:	40 82                	rex (bad)
    3817:	04 8a                	add    $0x8a,%al
    3819:	19 00                	sbb    %eax,(%rax)
    381b:	00 3c 9e             	add    %bh,(%rsi,%rbx,4)
    381e:	02 93 19 00 00 3d    	add    0x3d000019(%rbx),%dl
    3824:	74 1a                	je     3840 <_license+0x17a6>
    3826:	00 00                	add    %al,(%rax)
    3828:	00 3c 9d 02 9d 19 00 	add    %bh,0x199d02(,%rbx,4)
    382f:	00 42 06             	add    %al,0x6(%rdx)
    3832:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    3833:	19 00                	sbb    %eax,(%rax)
    3835:	00 3d 74 1a 00 00    	add    %bh,0x1a74(%rip)        # 52af <_license+0x3215>
    383b:	00 40 82             	add    %al,-0x7e(%rax)
    383e:	04 ae                	add    $0xae,%al
    3840:	19 00                	sbb    %eax,(%rax)
    3842:	00 40 80             	add    %al,-0x80(%rax)
    3845:	08 b6 19 00 00 40    	or     %dh,0x40000019(%rsi)
    384b:	08 be 19 00 00 00    	or     %bh,0x19(%rsi)
    3851:	00 00                	add    %al,(%rax)
    3853:	3d 75 59 00 00       	cmp    $0x5975,%eax
    3858:	00 3c a1             	add    %bh,(%rcx,%riz,4)
    385b:	02 06                	add    (%rsi),%al
    385d:	19 00                	sbb    %eax,(%rax)
    385f:	00 3d 75 15 00 00    	add    %bh,0x1575(%rip)        # 4dda <_license+0x2d40>
    3865:	00 3c 9f             	add    %bh,(%rdi,%rbx,4)
    3868:	02 11                	add    (%rcx),%dl
    386a:	19 00                	sbb    %eax,(%rax)
    386c:	00 42 0d             	add    %al,0xd(%rdx)
    386f:	1a 19                	sbb    (%rcx),%bl
    3871:	00 00                	add    %al,(%rax)
    3873:	3e 02 17             	ds add (%rdi),%dl
    3876:	00 00                	add    %al,(%rax)
    3878:	75 15                	jne    388f <_license+0x17f5>
    387a:	00 00                	add    %al,(%rax)
    387c:	00 00                	add    %al,(%rax)
    387e:	95                   	xchg   %eax,%ebp
    387f:	02 1c 3a             	add    (%rdx,%rdi,1),%bl
    3882:	a0 02 0c 17 00 00 00 	movabs 0x3d00000000170c02,%al
    3889:	00 3d 
    388b:	76 3f                	jbe    38cc <_license+0x1832>
    388d:	00 00                	add    %al,(%rax)
    388f:	00 3c a2             	add    %bh,(%rdx,%riz,4)
    3892:	02 25 19 00 00 3e    	add    0x3e000019(%rip),%ah        # 3e0038b1 <_license+0x3e001817>
    3898:	02 17                	add    (%rdi),%dl
    389a:	00 00                	add    %al,(%rax)
    389c:	77 09                	ja     38a7 <_license+0x180d>
    389e:	00 00                	add    %al,(%rax)
    38a0:	00 00                	add    %al,(%rax)
    38a2:	97                   	xchg   %eax,%edi
    38a3:	02 19                	add    (%rcx),%bl
    38a5:	3f                   	(bad)
    38a6:	01 50 0c             	add    %edx,0xc(%rax)
    38a9:	17                   	(bad)
    38aa:	00 00                	add    %al,(%rax)
    38ac:	3f                   	(bad)
    38ad:	01 54 16 17          	add    %edx,0x17(%rsi,%rdx,1)
    38b1:	00 00                	add    %al,(%rax)
    38b3:	00 3d 78 2c 00 00    	add    %bh,0x2c78(%rip)        # 6531 <_license+0x4497>
    38b9:	00 40 8f             	add    %al,-0x71(%rax)
    38bc:	04 30                	add    $0x30,%al
    38be:	19 00                	sbb    %eax,(%rax)
    38c0:	00 3c a4             	add    %bh,(%rsp,%riz,4)
    38c3:	02 39                	add    (%rcx),%bh
    38c5:	19 00                	sbb    %eax,(%rax)
    38c7:	00 3d 78 1a 00 00    	add    %bh,0x1a78(%rip)        # 5345 <_license+0x32ab>
    38cd:	00 3c a3             	add    %bh,(%rbx,%riz,4)
    38d0:	02 44 19 00          	add    0x0(%rcx,%rbx,1),%al
    38d4:	00 42 06             	add    %al,0x6(%rdx)
    38d7:	4d 19 00             	sbb    %r8,(%r8)
    38da:	00 3d 78 1a 00 00    	add    %bh,0x1a78(%rip)        # 5358 <_license+0x32be>
    38e0:	00 40 8f             	add    %al,-0x71(%rax)
    38e3:	04 57                	add    $0x57,%al
    38e5:	19 00                	sbb    %eax,(%rax)
    38e7:	00 40 80             	add    %al,-0x80(%rax)
    38ea:	08 60 19             	or     %ah,0x19(%rax)
    38ed:	00 00                	add    %al,(%rax)
    38ef:	40 08 69 19          	or     %bpl,0x19(%rcx)
	...
    38fb:	3d 79 34 00 00       	cmp    $0x3479,%eax
    3900:	00 40 81             	add    %al,-0x7f(%rax)
    3903:	04 40                	add    $0x40,%al
    3905:	0e                   	(bad)
    3906:	00 00                	add    %al,(%rax)
    3908:	3c b3                	cmp    $0xb3,%al
    390a:	02 49 0e             	add    0xe(%rcx),%cl
    390d:	00 00                	add    %al,(%rax)
    390f:	3d 79 1a 00 00       	cmp    $0x1a79,%eax
    3914:	00 3c b2             	add    %bh,(%rdx,%rsi,4)
    3917:	02 53 0e             	add    0xe(%rbx),%dl
    391a:	00 00                	add    %al,(%rax)
    391c:	42 06                	rex.X (bad)
    391e:	5c                   	pop    %rsp
    391f:	0e                   	(bad)
    3920:	00 00                	add    %al,(%rax)
    3922:	3d 79 1a 00 00       	cmp    $0x1a79,%eax
    3927:	00 40 81             	add    %al,-0x7f(%rax)
    392a:	04 66                	add    $0x66,%al
    392c:	0e                   	(bad)
    392d:	00 00                	add    %al,(%rax)
    392f:	40 80 08 6f          	rex orb $0x6f,(%rax)
    3933:	0e                   	(bad)
    3934:	00 00                	add    %al,(%rax)
    3936:	40 08 78 0e          	or     %dil,0xe(%rax)
    393a:	00 00                	add    %al,(%rax)
    393c:	00 00                	add    %al,(%rax)
    393e:	00 39                	add    %bh,(%rcx)
    3940:	09 1b                	or     %ebx,(%rbx)
    3942:	00 00                	add    %al,(%rax)
    3944:	26 00 ff             	es add %bh,%bh
    3947:	03 0c 3a             	add    (%rdx,%rdi,1),%ecx
    394a:	b4 02                	mov    $0x2,%ah
    394c:	1b 1b                	sbb    (%rbx),%ebx
    394e:	00 00                	add    %al,(%rax)
    3950:	3a b5 02 23 1b 00    	cmp    0x1b2302(%rbp),%dh
    3956:	00 3a                	add    %bh,(%rdx)
    3958:	b6 02                	mov    $0x2,%dh
    395a:	2b 1b                	sub    (%rbx),%ebx
    395c:	00 00                	add    %al,(%rax)
    395e:	3a b7 02 33 1b 00    	cmp    0x1b3302(%rdi),%dh
    3964:	00 3b                	add    %bh,(%rbx)
    3966:	03 91 c0 00 3b 1b    	add    0x1b3b00c0(%rcx),%edx
    396c:	00 00                	add    %al,(%rax)
    396e:	3c b8                	cmp    $0xb8,%al
    3970:	02 44 1b 00          	add    0x0(%rbx,%rbx,1),%al
    3974:	00 3c b9             	add    %bh,(%rcx,%rdi,4)
    3977:	02 4d 1b             	add    0x1b(%rbp),%cl
    397a:	00 00                	add    %al,(%rax)
    397c:	3c ba                	cmp    $0xba,%al
    397e:	02 56 1b             	add    0x1b(%rsi),%dl
    3981:	00 00                	add    %al,(%rax)
    3983:	3c c8                	cmp    $0xc8,%al
    3985:	02 5f 1b             	add    0x1b(%rdi),%bl
    3988:	00 00                	add    %al,(%rax)
    398a:	3c c9                	cmp    $0xc9,%al
    398c:	02 68 1b             	add    0x1b(%rax),%ch
    398f:	00 00                	add    %al,(%rax)
    3991:	41 78 19             	rex.B js 39ad <_license+0x1913>
    3994:	00 00                	add    %al,(%rax)
    3996:	7a 5f                	jp     39f7 <_license+0x195d>
    3998:	00 00                	add    %al,(%rax)
    399a:	00 00                	add    %al,(%rax)
    399c:	66 11 40 82          	adc    %ax,-0x7e(%rax)
    39a0:	04 8a                	add    $0x8a,%al
    39a2:	19 00                	sbb    %eax,(%rax)
    39a4:	00 3c bc             	add    %bh,(%rsp,%rdi,4)
    39a7:	02 93 19 00 00 3d    	add    0x3d000019(%rbx),%dl
    39ad:	7a 1d                	jp     39cc <_license+0x1932>
    39af:	00 00                	add    %al,(%rax)
    39b1:	00 3c bb             	add    %bh,(%rbx,%rdi,4)
    39b4:	02 9d 19 00 00 42    	add    0x42000019(%rbp),%bl
    39ba:	06                   	(bad)
    39bb:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    39bc:	19 00                	sbb    %eax,(%rax)
    39be:	00 3d 7a 1d 00 00    	add    %bh,0x1d7a(%rip)        # 573e <_license+0x36a4>
    39c4:	00 40 82             	add    %al,-0x7e(%rax)
    39c7:	04 ae                	add    $0xae,%al
    39c9:	19 00                	sbb    %eax,(%rax)
    39cb:	00 40 80             	add    %al,-0x80(%rax)
    39ce:	08 b6 19 00 00 40    	or     %dh,0x40000019(%rsi)
    39d4:	08 be 19 00 00 00    	or     %bh,0x19(%rsi)
    39da:	00 00                	add    %al,(%rax)
    39dc:	44 27                	rex.R (bad)
    39de:	3c bd                	cmp    $0xbd,%al
    39e0:	02 79 1b             	add    0x1b(%rcx),%bh
    39e3:	00 00                	add    %al,(%rax)
    39e5:	47 dc 1b             	rex.RXB fcompl (%r11)
    39e8:	00 00                	add    %al,(%rax)
    39ea:	28 00                	sub    %al,(%rax)
    39ec:	8f                   	(bad)
    39ed:	0c 3a                	or     $0x3a,%al
    39ef:	c0 02 e5             	rolb   $0xe5,(%rdx)
    39f2:	1b 00                	sbb    (%rax),%eax
    39f4:	00 3a                	add    %bh,(%rdx)
    39f6:	c1 02 ed             	roll   $0xed,(%rdx)
    39f9:	1b 00                	sbb    (%rax),%eax
    39fb:	00 47 31             	add    %al,0x31(%rdi)
    39fe:	1f                   	(bad)
    39ff:	00 00                	add    %al,(%rax)
    3a01:	29 00                	sub    %eax,(%rax)
    3a03:	1e                   	(bad)
    3a04:	09 3a                	or     %edi,(%rdx)
    3a06:	c2 02 4b             	ret    $0x4b02
    3a09:	1f                   	(bad)
    3a0a:	00 00                	add    %al,(%rax)
    3a0c:	3c be                	cmp    $0xbe,%al
    3a0e:	02 54 1f 00          	add    0x0(%rdi,%rbx,1),%dl
    3a12:	00 3c bf             	add    %bh,(%rdi,%rdi,4)
    3a15:	02 5d 1f             	add    0x1f(%rbp),%bl
    3a18:	00 00                	add    %al,(%rax)
    3a1a:	3c c3                	cmp    $0xc3,%al
    3a1c:	02 66 1f             	add    0x1f(%rsi),%ah
    3a1f:	00 00                	add    %al,(%rax)
    3a21:	3c c4                	cmp    $0xc4,%al
    3a23:	02 6f 1f             	add    0x1f(%rdi),%ch
    3a26:	00 00                	add    %al,(%rax)
    3a28:	41                   	rex.B
    3a29:	4a 1c 00             	rex.WX sbb $0x0,%al
    3a2c:	00 7b 03             	add    %bh,0x3(%rbx)
    3a2f:	00 00                	add    %al,(%rax)
    3a31:	00 0a                	add    %cl,(%rdx)
    3a33:	41 05 3f 01 53 53    	rex.B add $0x5353013f,%eax
    3a39:	1c 00                	sbb    $0x0,%al
    3a3b:	00 46 04             	add    %al,0x4(%rsi)
    3a3e:	5c                   	pop    %rsp
    3a3f:	1c 00                	sbb    $0x0,%al
    3a41:	00 00                	add    %al,(%rax)
    3a43:	41                   	rex.B
    3a44:	4a 1c 00             	rex.WX sbb $0x0,%al
    3a47:	00 7c 05 00          	add    %bh,0x0(%rbp,%rax,1)
    3a4b:	00 00                	add    %al,(%rax)
    3a4d:	0a 41 05             	or     0x5(%rcx),%al
    3a50:	3f                   	(bad)
    3a51:	01 53 53             	add    %edx,0x53(%rbx)
    3a54:	1c 00                	sbb    $0x0,%al
    3a56:	00 46 06             	add    %al,0x6(%rsi)
    3a59:	5c                   	pop    %rsp
    3a5a:	1c 00                	sbb    $0x0,%al
    3a5c:	00 00                	add    %al,(%rax)
    3a5e:	41                   	rex.B
    3a5f:	4a 1c 00             	rex.WX sbb $0x0,%al
    3a62:	00 7d 05             	add    %bh,0x5(%rbp)
    3a65:	00 00                	add    %al,(%rax)
    3a67:	00 0a                	add    %cl,(%rdx)
    3a69:	41 05 3f 01 55 53    	rex.B add $0x5355013f,%eax
    3a6f:	1c 00                	sbb    $0x0,%al
    3a71:	00 46 08             	add    %al,0x8(%rsi)
    3a74:	5c                   	pop    %rsp
    3a75:	1c 00                	sbb    $0x0,%al
    3a77:	00 00                	add    %al,(%rax)
    3a79:	41                   	rex.B
    3a7a:	4a 1c 00             	rex.WX sbb $0x0,%al
    3a7d:	00 7e 05             	add    %bh,0x5(%rsi)
    3a80:	00 00                	add    %al,(%rax)
    3a82:	00 0a                	add    %cl,(%rdx)
    3a84:	41 05 3f 01 52 53    	rex.B add $0x5352013f,%eax
    3a8a:	1c 00                	sbb    $0x0,%al
    3a8c:	00 46 10             	add    %al,0x10(%rsi)
    3a8f:	5c                   	pop    %rsp
    3a90:	1c 00                	sbb    $0x0,%al
    3a92:	00 00                	add    %al,(%rax)
    3a94:	41                   	rex.B
    3a95:	4a 1c 00             	rex.WX sbb $0x0,%al
    3a98:	00 7f 05             	add    %bh,0x5(%rdi)
    3a9b:	00 00                	add    %al,(%rax)
    3a9d:	00 0a                	add    %cl,(%rdx)
    3a9f:	41 05 3f 01 54 53    	rex.B add $0x5354013f,%eax
    3aa5:	1c 00                	sbb    $0x0,%al
    3aa7:	00 46 13             	add    %al,0x13(%rsi)
    3aaa:	5c                   	pop    %rsp
    3aab:	1c 00                	sbb    $0x0,%al
    3aad:	00 00                	add    %al,(%rax)
    3aaf:	41                   	rex.B
    3ab0:	4a 1c 00             	rex.WX sbb $0x0,%al
    3ab3:	00 80 01 07 00 00    	add    %al,0x701(%rax)
    3ab9:	00 0a                	add    %cl,(%rdx)
    3abb:	41 05 3f 01 53 53    	rex.B add $0x5353013f,%eax
    3ac1:	1c 00                	sbb    $0x0,%al
    3ac3:	00 46 04             	add    %al,0x4(%rsi)
    3ac6:	5c                   	pop    %rsp
    3ac7:	1c 00                	sbb    $0x0,%al
    3ac9:	00 00                	add    %al,(%rax)
    3acb:	41                   	rex.B
    3acc:	4a 1c 00             	rex.WX sbb $0x0,%al
    3acf:	00 81 01 05 00 00    	add    %al,0x501(%rcx)
    3ad5:	00 0a                	add    %cl,(%rdx)
    3ad7:	5e                   	pop    %rsi
    3ad8:	07                   	(bad)
    3ad9:	3f                   	(bad)
    3ada:	01 53 53             	add    %edx,0x53(%rbx)
    3add:	1c 00                	sbb    $0x0,%al
    3adf:	00 46 0e             	add    %al,0xe(%rsi)
    3ae2:	5c                   	pop    %rsp
    3ae3:	1c 00                	sbb    $0x0,%al
    3ae5:	00 00                	add    %al,(%rax)
    3ae7:	41                   	rex.B
    3ae8:	4a 1c 00             	rex.WX sbb $0x0,%al
    3aeb:	00 82 01 05 00 00    	add    %al,0x501(%rdx)
    3af1:	00 0a                	add    %cl,(%rdx)
    3af3:	5e                   	pop    %rsi
    3af4:	07                   	(bad)
    3af5:	3f                   	(bad)
    3af6:	01 52 53             	add    %edx,0x53(%rdx)
    3af9:	1c 00                	sbb    $0x0,%al
    3afb:	00 46 0b             	add    %al,0xb(%rsi)
    3afe:	5c                   	pop    %rsp
    3aff:	1c 00                	sbb    $0x0,%al
    3b01:	00 00                	add    %al,(%rax)
    3b03:	41                   	rex.B
    3b04:	4a 1c 00             	rex.WX sbb $0x0,%al
    3b07:	00 83 01 05 00 00    	add    %al,0x501(%rbx)
    3b0d:	00 0a                	add    %cl,(%rdx)
    3b0f:	5e                   	pop    %rsi
    3b10:	07                   	(bad)
    3b11:	3f                   	(bad)
    3b12:	01 51 53             	add    %edx,0x53(%rcx)
    3b15:	1c 00                	sbb    $0x0,%al
    3b17:	00 46 19             	add    %al,0x19(%rsi)
    3b1a:	5c                   	pop    %rsp
    3b1b:	1c 00                	sbb    $0x0,%al
    3b1d:	00 00                	add    %al,(%rax)
    3b1f:	41                   	rex.B
    3b20:	4a 1c 00             	rex.WX sbb $0x0,%al
    3b23:	00 84 01 05 00 00 00 	add    %al,0x5(%rcx,%rax,1)
    3b2a:	0a 5e 07             	or     0x7(%rsi),%bl
    3b2d:	3f                   	(bad)
    3b2e:	01 53 53             	add    %edx,0x53(%rbx)
    3b31:	1c 00                	sbb    $0x0,%al
    3b33:	00 46 10             	add    %al,0x10(%rsi)
    3b36:	5c                   	pop    %rsp
    3b37:	1c 00                	sbb    $0x0,%al
    3b39:	00 00                	add    %al,(%rax)
    3b3b:	41                   	rex.B
    3b3c:	4a 1c 00             	rex.WX sbb $0x0,%al
    3b3f:	00 85 01 05 00 00    	add    %al,0x501(%rbp)
    3b45:	00 0a                	add    %cl,(%rdx)
    3b47:	5e                   	pop    %rsi
    3b48:	07                   	(bad)
    3b49:	3f                   	(bad)
    3b4a:	01 52 53             	add    %edx,0x53(%rdx)
    3b4d:	1c 00                	sbb    $0x0,%al
    3b4f:	00 46 04             	add    %al,0x4(%rsi)
    3b52:	5c                   	pop    %rsp
    3b53:	1c 00                	sbb    $0x0,%al
    3b55:	00 00                	add    %al,(%rax)
    3b57:	41                   	rex.B
    3b58:	4a 1c 00             	rex.WX sbb $0x0,%al
    3b5b:	00 86 01 03 00 00    	add    %al,0x301(%rsi)
    3b61:	00 0a                	add    %cl,(%rdx)
    3b63:	5e                   	pop    %rsi
    3b64:	07                   	(bad)
    3b65:	3f                   	(bad)
    3b66:	01 51 53             	add    %edx,0x53(%rcx)
    3b69:	1c 00                	sbb    $0x0,%al
    3b6b:	00 46 0e             	add    %al,0xe(%rsi)
    3b6e:	5c                   	pop    %rsp
    3b6f:	1c 00                	sbb    $0x0,%al
    3b71:	00 00                	add    %al,(%rax)
    3b73:	41                   	rex.B
    3b74:	4a 1c 00             	rex.WX sbb $0x0,%al
    3b77:	00 87 01 03 00 00    	add    %al,0x301(%rdi)
    3b7d:	00 0a                	add    %cl,(%rdx)
    3b7f:	5e                   	pop    %rsi
    3b80:	07                   	(bad)
    3b81:	3f                   	(bad)
    3b82:	01 53 53             	add    %edx,0x53(%rbx)
    3b85:	1c 00                	sbb    $0x0,%al
    3b87:	00 46 18             	add    %al,0x18(%rsi)
    3b8a:	5c                   	pop    %rsp
    3b8b:	1c 00                	sbb    $0x0,%al
    3b8d:	00 00                	add    %al,(%rax)
    3b8f:	00 41 25             	add    %al,0x25(%rcx)
    3b92:	1c 00                	sbb    $0x0,%al
    3b94:	00 88 01 57 00 00    	add    %cl,0x5701(%rax)
    3b9a:	00 00                	add    %al,(%rax)
    3b9c:	1d 0c 46 80 84       	sbb    $0x8480460c,%eax
    3ba1:	80 10 40             	adcb   $0x40,(%rax)
    3ba4:	1c 00                	sbb    $0x0,%al
    3ba6:	00 41 f7             	add    %al,-0x9(%rcx)
    3ba9:	1b 00                	sbb    (%rax),%eax
    3bab:	00 88 01 57 00 00    	add    %cl,0x5701(%rax)
    3bb1:	00 0a                	add    %cl,(%rdx)
    3bb3:	6f                   	outsl  %ds:(%rsi),(%dx)
    3bb4:	0a 3a                	or     (%rdx),%bh
    3bb6:	c5 02 00             	(bad)
    3bb9:	1c 00                	sbb    $0x0,%al
    3bbb:	00 3a                	add    %bh,(%rdx)
    3bbd:	c6 02 09             	movb   $0x9,(%rdx)
    3bc0:	1c 00                	sbb    $0x0,%al
    3bc2:	00 3a                	add    %bh,(%rdx)
    3bc4:	c7 02 12 1c 00 00    	movl   $0x1c12,(%rdx)
    3bca:	46 f7 81 b7 85 fe ff 	rex.RX testl $0x1ffffff,-0x17a49(%rcx)
    3bd1:	ff ff ff 01 
    3bd5:	1b 1c 00             	sbb    (%rax,%rax,1),%ebx
    3bd8:	00 41 4a             	add    %al,0x4a(%rcx)
    3bdb:	1c 00                	sbb    $0x0,%al
    3bdd:	00 89 01 05 00 00    	add    %cl,0x501(%rcx)
    3be3:	00 0a                	add    %cl,(%rdx)
    3be5:	6a 03                	push   $0x3
    3be7:	3f                   	(bad)
    3be8:	01 54 53 1c          	add    %edx,0x1c(%rbx,%rdx,2)
    3bec:	00 00                	add    %al,(%rax)
    3bee:	46 0e                	rex.RX (bad)
    3bf0:	5c                   	pop    %rsp
    3bf1:	1c 00                	sbb    $0x0,%al
    3bf3:	00 00                	add    %al,(%rax)
    3bf5:	41                   	rex.B
    3bf6:	4a 1c 00             	rex.WX sbb $0x0,%al
    3bf9:	00 8a 01 05 00 00    	add    %cl,0x501(%rdx)
    3bff:	00 0a                	add    %cl,(%rdx)
    3c01:	6a 03                	push   $0x3
    3c03:	3f                   	(bad)
    3c04:	01 51 53             	add    %edx,0x53(%rcx)
    3c07:	1c 00                	sbb    $0x0,%al
    3c09:	00 46 0b             	add    %al,0xb(%rsi)
    3c0c:	5c                   	pop    %rsp
    3c0d:	1c 00                	sbb    $0x0,%al
    3c0f:	00 00                	add    %al,(%rax)
    3c11:	41                   	rex.B
    3c12:	4a 1c 00             	rex.WX sbb $0x0,%al
    3c15:	00 8b 01 05 00 00    	add    %cl,0x501(%rbx)
    3c1b:	00 0a                	add    %cl,(%rdx)
    3c1d:	6a 03                	push   $0x3
    3c1f:	3f                   	(bad)
    3c20:	01 52 53             	add    %edx,0x53(%rdx)
    3c23:	1c 00                	sbb    $0x0,%al
    3c25:	00 46 19             	add    %al,0x19(%rsi)
    3c28:	5c                   	pop    %rsp
    3c29:	1c 00                	sbb    $0x0,%al
    3c2b:	00 00                	add    %al,(%rax)
    3c2d:	41                   	rex.B
    3c2e:	4a 1c 00             	rex.WX sbb $0x0,%al
    3c31:	00 8c 01 05 00 00 00 	add    %cl,0x5(%rcx,%rax,1)
    3c38:	0a 6a 03             	or     0x3(%rdx),%ch
    3c3b:	3f                   	(bad)
    3c3c:	01 54 53 1c          	add    %edx,0x1c(%rbx,%rdx,2)
    3c40:	00 00                	add    %al,(%rax)
    3c42:	46 10 5c 1c 00       	adc    %r11b,0x0(%rsp,%r11,1)
    3c47:	00 00                	add    %al,(%rax)
    3c49:	41                   	rex.B
    3c4a:	4a 1c 00             	rex.WX sbb $0x0,%al
    3c4d:	00 8d 01 05 00 00    	add    %cl,0x501(%rbp)
    3c53:	00 0a                	add    %cl,(%rdx)
    3c55:	6a 03                	push   $0x3
    3c57:	3f                   	(bad)
    3c58:	01 51 53             	add    %edx,0x53(%rcx)
    3c5b:	1c 00                	sbb    $0x0,%al
    3c5d:	00 46 04             	add    %al,0x4(%rsi)
    3c60:	5c                   	pop    %rsp
    3c61:	1c 00                	sbb    $0x0,%al
    3c63:	00 00                	add    %al,(%rax)
    3c65:	41                   	rex.B
    3c66:	4a 1c 00             	rex.WX sbb $0x0,%al
    3c69:	00 8e 01 03 00 00    	add    %cl,0x301(%rsi)
    3c6f:	00 0a                	add    %cl,(%rdx)
    3c71:	6a 03                	push   $0x3
    3c73:	3f                   	(bad)
    3c74:	01 52 53             	add    %edx,0x53(%rdx)
    3c77:	1c 00                	sbb    $0x0,%al
    3c79:	00 46 0e             	add    %al,0xe(%rsi)
    3c7c:	5c                   	pop    %rsp
    3c7d:	1c 00                	sbb    $0x0,%al
    3c7f:	00 00                	add    %al,(%rax)
    3c81:	41                   	rex.B
    3c82:	4a 1c 00             	rex.WX sbb $0x0,%al
    3c85:	00 8f 01 03 00 00    	add    %cl,0x301(%rdi)
    3c8b:	00 0a                	add    %cl,(%rdx)
    3c8d:	6a 03                	push   $0x3
    3c8f:	3f                   	(bad)
    3c90:	01 54 53 1c          	add    %edx,0x1c(%rbx,%rdx,2)
    3c94:	00 00                	add    %al,(%rax)
    3c96:	46 18 5c 1c 00       	sbb    %r11b,0x0(%rsp,%r11,1)
    3c9b:	00 00                	add    %al,(%rax)
    3c9d:	00 00                	add    %al,(%rax)
    3c9f:	00 44 2a 3c          	add    %al,0x3c(%rdx,%rbp,1)
    3ca3:	cb                   	lret
    3ca4:	02 83 1b 00 00 42    	add    0x4200001b(%rbx),%al
    3caa:	02 8b 1b 00 00 44    	add    0x4400001b(%rbx),%cl
    3cb0:	2b 3c ca             	sub    (%rdx,%rcx,8),%edi
    3cb3:	02 94 1b 00 00 40 80 	add    -0x7fc00000(%rbx,%rbx,1),%dl
    3cba:	84 80 10 9c 1b 00    	test   %al,0x1b9c10(%rax)
    3cc0:	00 40 08             	add    %al,0x8(%rax)
    3cc3:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    3cc4:	1b 00                	sbb    (%rax),%eax
    3cc6:	00 00                	add    %al,(%rax)
    3cc8:	00 41 aa             	add    %al,-0x56(%rcx)
    3ccb:	1c 00                	sbb    $0x0,%al
    3ccd:	00 90 01 1f 00 00    	add    %dl,0x1f01(%rax)
    3cd3:	00 00                	add    %al,(%rax)
    3cd5:	9a                   	(bad)
    3cd6:	07                   	(bad)
    3cd7:	40 89 04 af          	rex mov %eax,(%rdi,%rbp,4)
    3cdb:	1c 00                	sbb    $0x0,%al
    3cdd:	00 3c d0             	add    %bh,(%rax,%rdx,8)
    3ce0:	02 b8 1c 00 00 3d    	add    0x3d00001c(%rax),%bh
    3ce6:	90                   	nop
    3ce7:	01 1a                	add    %ebx,(%rdx)
    3ce9:	00 00                	add    %al,(%rax)
    3ceb:	00 3c cf             	add    %bh,(%rdi,%rcx,8)
    3cee:	02 c2                	add    %dl,%al
    3cf0:	1c 00                	sbb    $0x0,%al
    3cf2:	00 42 06             	add    %al,0x6(%rdx)
    3cf5:	ca 1c 00             	lret   $0x1c
    3cf8:	00 3d 90 01 1a 00    	add    %bh,0x1a0190(%rip)        # 1a3e8e <_license+0x1a1df4>
    3cfe:	00 00                	add    %al,(%rax)
    3d00:	40 89 04 d3          	rex mov %eax,(%rbx,%rdx,8)
    3d04:	1c 00                	sbb    $0x0,%al
    3d06:	00 40 80             	add    %al,-0x80(%rax)
    3d09:	08 db                	or     %bl,%bl
    3d0b:	1c 00                	sbb    $0x0,%al
    3d0d:	00 40 08             	add    %al,0x8(%rax)
    3d10:	e3 1c                	jrcxz  3d2e <_license+0x1c94>
    3d12:	00 00                	add    %al,(%rax)
    3d14:	00 00                	add    %al,(%rax)
    3d16:	00 00                	add    %al,(%rax)
    3d18:	3d 91 01 06 00       	cmp    $0x60191,%eax
    3d1d:	00 00                	add    %al,(%rax)
    3d1f:	3c cc                	cmp    $0xcc,%al
    3d21:	02 b0 1b 00 00 42    	add    0x4200001b(%rax),%dh
    3d27:	02 b8 1b 00 00 3d    	add    0x3d00001b(%rax),%bh
    3d2d:	91                   	xchg   %eax,%ecx
    3d2e:	01 06                	add    %eax,(%rsi)
    3d30:	00 00                	add    %al,(%rax)
    3d32:	00 3b                	add    %bh,(%rbx)
    3d34:	01 56 c1             	add    %edx,-0x3f(%rsi)
    3d37:	1b 00                	sbb    (%rax),%eax
    3d39:	00 40 80             	add    %al,-0x80(%rax)
    3d3c:	20 c9                	and    %cl,%cl
    3d3e:	1b 00                	sbb    (%rax),%eax
    3d40:	00 40 18             	add    %al,0x18(%rax)
    3d43:	d1 1b                	rcrl   (%rbx)
    3d45:	00 00                	add    %al,(%rax)
    3d47:	00 00                	add    %al,(%rax)
    3d49:	41                   	rex.B
    3d4a:	66 1c 00             	data16 sbb $0x0,%al
    3d4d:	00 92 01 21 00 00    	add    %dl,0x2101(%rdx)
    3d53:	00 00                	add    %al,(%rax)
    3d55:	a3 05 40 89 04 6b 1c 	movabs %eax,0x1c6b04894005
    3d5c:	00 00 
    3d5e:	3c ce                	cmp    $0xce,%al
    3d60:	02 74 1c 00          	add    0x0(%rsp,%rbx,1),%dh
    3d64:	00 3d 92 01 1a 00    	add    %bh,0x1a0192(%rip)        # 1a3efc <_license+0x1a1e62>
    3d6a:	00 00                	add    %al,(%rax)
    3d6c:	3c cd                	cmp    $0xcd,%al
    3d6e:	02 7e 1c             	add    0x1c(%rsi),%bh
    3d71:	00 00                	add    %al,(%rax)
    3d73:	42 06                	rex.X (bad)
    3d75:	86 1c 00             	xchg   %bl,(%rax,%rax,1)
    3d78:	00 3d 92 01 1a 00    	add    %bh,0x1a0192(%rip)        # 1a3f10 <_license+0x1a1e76>
    3d7e:	00 00                	add    %al,(%rax)
    3d80:	40 89 04 8f          	rex mov %eax,(%rdi,%rcx,4)
    3d84:	1c 00                	sbb    $0x0,%al
    3d86:	00 40 80             	add    %al,-0x80(%rax)
    3d89:	08 97 1c 00 00 40    	or     %dl,0x4000001c(%rdi)
    3d8f:	08 9f 1c 00 00 00    	or     %bl,0x1c(%rdi)
    3d95:	00 00                	add    %al,(%rax)
    3d97:	41 e4 1d             	rex.B in $0x1d,%al
    3d9a:	00 00                	add    %al,(%rax)
    3d9c:	93                   	xchg   %eax,%ebx
    3d9d:	01 12                	add    %edx,(%rdx)
    3d9f:	00 00                	add    %al,(%rax)
    3da1:	00 00                	add    %al,(%rax)
    3da3:	ab                   	stos   %eax,%es:(%rdi)
    3da4:	05 3f 01 55 ee       	add    $0xee55013f,%eax
    3da9:	1d 00 00 46 00       	sbb    $0x460000,%eax
    3dae:	0a 1e                	or     (%rsi),%bl
    3db0:	00 00                	add    %al,(%rax)
    3db2:	00 00                	add    %al,(%rax)
    3db4:	3e 14 1e             	ds adc $0x1e,%al
    3db7:	00 00                	add    %al,(%rax)
    3db9:	94                   	xchg   %eax,%esp
    3dba:	01 8a 00 00 00 00    	add    %ecx,0x0(%rdx)
    3dc0:	04 04                	add    $0x4,%al
    3dc2:	0b 3f                	or     (%rdi),%edi
    3dc4:	04 91                	add    $0x91,%al
    3dc6:	e8 00 9f 1e 1e       	call   1e1edccb <_license+0x1e1ebc31>
    3dcb:	00 00                	add    %al,(%rax)
    3dcd:	3f                   	(bad)
    3dce:	02 31                	add    (%rcx),%dh
    3dd0:	9f                   	lahf
    3dd1:	39 1e                	cmp    %ebx,(%rsi)
    3dd3:	00 00                	add    %al,(%rax)
    3dd5:	40 00 4c 1e 00       	rex add %cl,0x0(%rsi,%rbx,1)
    3dda:	00 3d 95 01 34 00    	add    %bh,0x340195(%rip)        # 343f75 <_license+0x341edb>
    3de0:	00 00                	add    %al,(%rax)
    3de2:	3c db                	cmp    $0xdb,%al
    3de4:	02 7f 1e             	add    0x1e(%rdi),%bh
    3de7:	00 00                	add    %al,(%rax)
    3de9:	3c de                	cmp    $0xde,%al
    3deb:	02 88 1e 00 00 3d    	add    0x3d00001e(%rax),%cl
    3df1:	95                   	xchg   %eax,%ebp
    3df2:	01 28                	add    %ebp,(%rax)
    3df4:	00 00                	add    %al,(%rax)
    3df6:	00 3c dc             	add    %bh,(%rsp,%rbx,8)
    3df9:	02 93 1e 00 00 42    	add    0x4200001e(%rbx),%dl
    3dff:	06                   	(bad)
    3e00:	9c                   	pushf
    3e01:	1e                   	(bad)
    3e02:	00 00                	add    %al,(%rax)
    3e04:	3d 95 01 28 00       	cmp    $0x280195,%eax
    3e09:	00 00                	add    %al,(%rax)
    3e0b:	3c dd                	cmp    $0xdd,%al
    3e0d:	02 a6 1e 00 00 40    	add    0x4000001e(%rsi),%ah
    3e13:	80 20 af             	andb   $0xaf,(%rax)
    3e16:	1e                   	(bad)
    3e17:	00 00                	add    %al,(%rax)
    3e19:	40 08 b8 1e 00 00 00 	or     %dil,0x1e(%rax)
    3e20:	00 00                	add    %al,(%rax)
    3e22:	00 3d 96 01 27 00    	add    %bh,0x270196(%rip)        # 273fbe <_license+0x271f24>
    3e28:	00 00                	add    %al,(%rax)
    3e2a:	3c a5                	cmp    $0xa5,%al
    3e2c:	02 85 0e 00 00 42    	add    0x4200000e(%rbp),%al
    3e32:	06                   	(bad)
    3e33:	8e 0e                	mov    (%rsi),%cs
    3e35:	00 00                	add    %al,(%rax)
    3e37:	3d 96 01 27 00       	cmp    $0x270196,%eax
    3e3c:	00 00                	add    %al,(%rax)
    3e3e:	40 80 08 98          	rex orb $0x98,(%rax)
    3e42:	0e                   	(bad)
    3e43:	00 00                	add    %al,(%rax)
    3e45:	40 08 a1 0e 00 00 00 	or     %spl,0xe(%rcx)
    3e4c:	00 3d 97 01 2c 00    	add    %bh,0x2c0197(%rip)        # 2c3fe9 <_license+0x2c1f4f>
    3e52:	00 00                	add    %al,(%rax)
    3e54:	3c a6                	cmp    $0xa6,%al
    3e56:	02 b6 0e 00 00 42    	add    0x4200000e(%rsi),%dh
    3e5c:	06                   	(bad)
    3e5d:	bf 0e 00 00 3d       	mov    $0x3d00000e,%edi
    3e62:	97                   	xchg   %eax,%edi
    3e63:	01 2c 00             	add    %ebp,(%rax,%rax,1)
    3e66:	00 00                	add    %al,(%rax)
    3e68:	3c a7                	cmp    $0xa7,%al
    3e6a:	02 c9                	add    %cl,%cl
    3e6c:	0e                   	(bad)
    3e6d:	00 00                	add    %al,(%rax)
    3e6f:	3c a8                	cmp    $0xa8,%al
    3e71:	02 d2                	add    %dl,%dl
    3e73:	0e                   	(bad)
    3e74:	00 00                	add    %al,(%rax)
    3e76:	00 00                	add    %al,(%rax)
    3e78:	3e 28 1a             	ds sub %bl,(%rdx)
    3e7b:	00 00                	add    %al,(%rax)
    3e7d:	98                   	cwtl
    3e7e:	01 c0                	add    %eax,%eax
    3e80:	00 00                	add    %al,(%rax)
    3e82:	00 00                	add    %al,(%rax)
    3e84:	2d 04 0a 3f 01       	sub    $0x13f0a04,%eax
    3e89:	5d                   	pop    %rbp
    3e8a:	31 1a                	xor    %ebx,(%rdx)
    3e8c:	00 00                	add    %al,(%rax)
    3e8e:	3f                   	(bad)
    3e8f:	03 91 08 9f 41 1a    	add    0x1a419f08(%rcx),%edx
    3e95:	00 00                	add    %al,(%rax)
    3e97:	3f                   	(bad)
    3e98:	01 53 49             	add    %edx,0x49(%rbx)
    3e9b:	1a 00                	sbb    (%rax),%al
    3e9d:	00 3c 42             	add    %bh,(%rdx,%rax,2)
    3ea0:	59                   	pop    %rcx
    3ea1:	1a 00                	sbb    (%rax),%al
    3ea3:	00 3c a9             	add    %bh,(%rcx,%rbp,4)
    3ea6:	02 61 1a             	add    0x1a(%rcx),%ah
    3ea9:	00 00                	add    %al,(%rax)
    3eab:	3c aa                	cmp    $0xaa,%al
    3ead:	02 6a 1a             	add    0x1a(%rdx),%ch
    3eb0:	00 00                	add    %al,(%rax)
    3eb2:	3c ab                	cmp    $0xab,%al
    3eb4:	02 72 1a             	add    0x1a(%rdx),%dh
    3eb7:	00 00                	add    %al,(%rax)
    3eb9:	3c ac                	cmp    $0xac,%al
    3ebb:	02 7a 1a             	add    0x1a(%rdx),%bh
    3ebe:	00 00                	add    %al,(%rax)
    3ec0:	3c ad                	cmp    $0xad,%al
    3ec2:	02 82 1a 00 00 3c    	add    0x3c00001a(%rdx),%al
    3ec8:	ae                   	scas   %es:(%rdi),%al
    3ec9:	02 8b 1a 00 00 41    	add    0x4100001a(%rbx),%cl
    3ecf:	cb                   	lret
    3ed0:	1a 00                	sbb    (%rax),%al
    3ed2:	00 99 01 30 00 00    	add    %bl,0x3001(%rcx)
    3ed8:	00 0d 75 03 3a af    	add    %cl,-0x50c5fc8b(%rip)        # ffffffffaf3a4253 <server_id_map+0x5ffffe36179253>
    3ede:	02 d8                	add    %al,%bl
    3ee0:	1a 00                	sbb    (%rax),%al
    3ee2:	00 3f                	add    %bh,(%rdi)
    3ee4:	0e                   	(bad)
    3ee5:	7e 00                	jle    3ee7 <_license+0x1e4d>
    3ee7:	10 ff                	adc    %bh,%bh
    3ee9:	ff                   	(bad)
    3eea:	ff                   	(bad)
    3eeb:	ff 0f                	decl   (%rdi)
    3eed:	1a 10                	sbb    (%rax),%dl
    3eef:	ac                   	lods   %ds:(%rsi),%al
    3ef0:	21 21                	and    %esp,(%rcx)
    3ef2:	9f                   	lahf
    3ef3:	e0 1a                	loopne 3f0f <_license+0x1e75>
    3ef5:	00 00                	add    %al,(%rax)
    3ef7:	3f                   	(bad)
    3ef8:	01 52 e8             	add    %edx,-0x18(%rdx)
    3efb:	1a 00                	sbb    (%rax),%al
    3efd:	00 46 04             	add    %al,0x4(%rsi)
    3f00:	f8                   	clc
    3f01:	1a 00                	sbb    (%rax),%al
    3f03:	00 40 00             	add    %al,0x0(%rax)
    3f06:	00 1b                	add    %bl,(%rbx)
    3f08:	00 00                	add    %al,(%rax)
    3f0a:	41 1f                	rex.B (bad)
    3f0c:	13 00                	adc    (%rax),%eax
    3f0e:	00 9a 01 08 00 00    	add    %bl,0x801(%rdx)
    3f14:	00 0e                	add    %cl,(%rsi)
    3f16:	48 03 3f             	add    (%rdi),%rdi
    3f19:	03 70 0e             	add    0xe(%rax),%esi
    3f1c:	9f                   	lahf
    3f1d:	23 13                	and    (%rbx),%edx
    3f1f:	00 00                	add    %al,(%rax)
    3f21:	3c b1                	cmp    $0xb1,%al
    3f23:	02 33                	add    (%rbx),%dh
    3f25:	13 00                	adc    (%rax),%eax
    3f27:	00 3d 9a 01 08 00    	add    %bh,0x8019a(%rip)        # 840c7 <_license+0x8202d>
    3f2d:	00 00                	add    %al,(%rax)
    3f2f:	3c b0                	cmp    $0xb0,%al
    3f31:	02 3c 13             	add    (%rbx,%rdx,1),%bh
    3f34:	00 00                	add    %al,(%rax)
    3f36:	00 00                	add    %al,(%rax)
    3f38:	00 00                	add    %al,(%rax)
    3f3a:	3e ee                	ds out %al,(%dx)
    3f3c:	1c 00                	sbb    $0x0,%al
    3f3e:	00 9b 01 af 00 00    	add    %bl,0xaf01(%rbx)
    3f44:	00 00                	add    %al,(%rax)
    3f46:	29 04 0a             	sub    %eax,(%rdx,%rcx,1)
    3f49:	3f                   	(bad)
    3f4a:	01 5d f7             	add    %ebx,-0x9(%rbp)
    3f4d:	1c 00                	sbb    $0x0,%al
    3f4f:	00 3f                	add    %bh,(%rdi)
    3f51:	02 31                	add    (%rcx),%dh
    3f53:	9f                   	lahf
    3f54:	07                   	(bad)
    3f55:	1d 00 00 3f 03       	sbb    $0x33f0000,%eax
    3f5a:	91                   	xchg   %eax,%ecx
    3f5b:	08 9f 0f 1d 00 00    	or     %bl,0x1d0f(%rdi)
    3f61:	3f                   	(bad)
    3f62:	01 53 17             	add    %edx,0x17(%rbx)
    3f65:	1d 00 00 3c d1       	sbb    $0xd13c0000,%eax
    3f6a:	02 27                	add    (%rdi),%ah
    3f6c:	1d 00 00 3c d2       	sbb    $0xd23c0000,%eax
    3f71:	02 2f                	add    (%rdi),%ch
    3f73:	1d 00 00 3c d3       	sbb    $0xd33c0000,%eax
    3f78:	02 37                	add    (%rdi),%dh
    3f7a:	1d 00 00 3c d4       	sbb    $0xd43c0000,%eax
    3f7f:	02 40 1d             	add    0x1d(%rax),%al
    3f82:	00 00                	add    %al,(%rax)
    3f84:	3c d5                	cmp    $0xd5,%al
    3f86:	02 48 1d             	add    0x1d(%rax),%cl
    3f89:	00 00                	add    %al,(%rax)
    3f8b:	3c d6                	cmp    $0xd6,%al
    3f8d:	02 51 1d             	add    0x1d(%rcx),%dl
    3f90:	00 00                	add    %al,(%rax)
    3f92:	3c d7                	cmp    $0xd7,%al
    3f94:	02 59 1d             	add    0x1d(%rcx),%bl
    3f97:	00 00                	add    %al,(%rax)
    3f99:	3c d8                	cmp    $0xd8,%al
    3f9b:	02 61 1d             	add    0x1d(%rcx),%ah
    3f9e:	00 00                	add    %al,(%rax)
    3fa0:	48 76 1d             	rex.W jbe 3fc0 <_license+0x1f26>
    3fa3:	00 00                	add    %al,(%rax)
    3fa5:	9c                   	pushf
    3fa6:	01 04 00             	add    %eax,(%rax,%rax,1)
    3fa9:	00 00                	add    %al,(%rax)
    3fab:	0d 4b 05 41 94       	or     $0x9441054b,%eax
    3fb0:	1d 00 00 9d 01       	sbb    $0x19d0000,%eax
    3fb5:	40 00 00             	rex add %al,(%rax)
    3fb8:	00 0d 53 03 3a da    	add    %cl,-0x25c5fcad(%rip)        # ffffffffda3a4311 <server_id_map+0x5ffffe61179311>
    3fbe:	02 a1 1d 00 00 3f    	add    0x3f00001d(%rcx),%ah
    3fc4:	01 53 b2             	add    %edx,-0x4e(%rbx)
    3fc7:	1d 00 00 3a d9       	sbb    $0xd93a0000,%eax
    3fcc:	02 ba 1d 00 00 46    	add    0x4600001d(%rdx),%bh
    3fd2:	29 c2                	sub    %eax,%edx
    3fd4:	1d 00 00 00 00       	sbb    $0x0,%eax
    3fd9:	00 49 01             	add    %cl,0x1(%rcx)
    3fdc:	52                   	push   %rdx
    3fdd:	9e                   	sahf
    3fde:	01 4a 01             	add    %ecx,0x1(%rdx)
    3fe1:	55                   	push   %rbp
    3fe2:	02 7d 00             	add    0x0(%rbp),%bh
    3fe5:	00 49 01             	add    %cl,0x1(%rcx)
    3fe8:	50                   	push   %rax
    3fe9:	9f                   	lahf
    3fea:	01 4a 01             	add    %ecx,0x1(%rdx)
    3fed:	55                   	push   %rbp
    3fee:	02 7d 00             	add    0x0(%rbp),%bh
    3ff1:	00 49 01             	add    %cl,0x1(%rcx)
    3ff4:	50                   	push   %rax
    3ff5:	a0 01 4a 01 54 03 91 	movabs 0xc0910354014a01,%al
    3ffc:	c0 00 
    3ffe:	00 49 01             	add    %cl,0x1(%rcx)
    4001:	50                   	push   %rax
    4002:	a1 01 4a 01 54 03 91 	movabs 0xc0910354014a01,%eax
    4009:	c0 00 
    400b:	00 49 01             	add    %cl,0x1(%rcx)
    400e:	50                   	push   %rax
    400f:	a2 01 4a 01 55 02 7e 	movabs %al,0x4a007e0255014a01
    4016:	00 4a 
    4018:	01 54 03 91          	add    %edx,-0x6f(%rbx,%rax,1)
    401c:	e8 00 00 49 01       	call   1494021 <_license+0x1491f87>
    4021:	50                   	push   %rax
    4022:	a3 01 4a 01 55 02 7e 	movabs %eax,0x4a007e0255014a01
    4029:	00 4a 
    402b:	01 54 03 91          	add    %edx,-0x6f(%rbx,%rax,1)
    402f:	e8 00 00 49 01       	call   1494034 <_license+0x1491f9a>
    4034:	50                   	push   %rax
    4035:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    4036:	01 4a 01             	add    %ecx,0x1(%rdx)
    4039:	54                   	push   %rsp
    403a:	03 91 c0 00 00 49    	add    0x490000c0(%rcx),%edx
    4040:	01 50 a5             	add    %edx,-0x5b(%rax)
    4043:	01 4a 01             	add    %ecx,0x1(%rdx)
    4046:	54                   	push   %rsp
    4047:	03 91 c0 00 00 49    	add    0x490000c0(%rcx),%edx
    404d:	01 50 a6             	add    %edx,-0x5a(%rax)
    4050:	01 4a 01             	add    %ecx,0x1(%rdx)
    4053:	55                   	push   %rbp
    4054:	02 7e 00             	add    0x0(%rsi),%bh
    4057:	4a 01 54 03 91       	add    %rdx,-0x6f(%rbx,%r8,1)
    405c:	e8 00 00 49 01       	call   1494061 <_license+0x1491fc7>
    4061:	50                   	push   %rax
    4062:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    4063:	01 4a 01             	add    %ecx,0x1(%rdx)
    4066:	55                   	push   %rbp
    4067:	02 7e 00             	add    0x0(%rsi),%bh
    406a:	4a 01 54 03 91       	add    %rdx,-0x6f(%rbx,%r8,1)
    406f:	e8 00 00 49 01       	call   1494074 <_license+0x1491fda>
    4074:	50                   	push   %rax
    4075:	a8 01                	test   $0x1,%al
    4077:	4a 01 54 02 91       	add    %rdx,-0x6f(%rdx,%r8,1)
    407c:	08 4a 01             	or     %cl,0x1(%rdx)
    407f:	55                   	push   %rbp
    4080:	05 91 d0 00 94       	add    $0x9400d091,%eax
    4085:	08 00                	or     %al,(%rax)
    4087:	4b 01 50 a9          	rex.WXB add %rdx,-0x57(%r8)
    408b:	01 4b 01             	add    %ecx,0x1(%rbx)
    408e:	50                   	push   %rax
    408f:	aa                   	stos   %al,%es:(%rdi)
    4090:	01 49 01             	add    %ecx,0x1(%rcx)
    4093:	50                   	push   %rax
    4094:	ab                   	stos   %eax,%es:(%rdi)
    4095:	01 4a 01             	add    %ecx,0x1(%rdx)
    4098:	54                   	push   %rsp
    4099:	03 91 e8 00 00 49    	add    0x490000e8(%rcx),%edx
    409f:	01 52 ac             	add    %edx,-0x54(%rdx)
    40a2:	01 4a 01             	add    %ecx,0x1(%rdx)
    40a5:	54                   	push   %rsp
    40a6:	02 91 30 00 49 01    	add    0x1490030(%rcx),%dl
    40ac:	50                   	push   %rax
    40ad:	ad                   	lods   %ds:(%rsi),%eax
    40ae:	01 4a 01             	add    %ecx,0x1(%rdx)
    40b1:	54                   	push   %rsp
    40b2:	0b 10                	or     (%rax),%edx
    40b4:	ec                   	in     (%dx),%al
    40b5:	ff                   	(bad)
    40b6:	ff                   	(bad)
    40b7:	ff                   	(bad)
    40b8:	ff                   	(bad)
    40b9:	ff                   	(bad)
    40ba:	ff                   	(bad)
    40bb:	ff                   	(bad)
    40bc:	ff 01                	incl   (%rcx)
    40be:	4a 01 55 02          	rex.WX add %rdx,0x2(%rbp)
    40c2:	7d 00                	jge    40c4 <_license+0x202a>
    40c4:	00 4b 01             	add    %cl,0x1(%rbx)
    40c7:	50                   	push   %rax
    40c8:	ae                   	scas   %es:(%rdi),%al
    40c9:	01 49 01             	add    %ecx,0x1(%rcx)
    40cc:	50                   	push   %rax
    40cd:	af                   	scas   %es:(%rdi),%eax
    40ce:	01 4a 01             	add    %ecx,0x1(%rdx)
    40d1:	54                   	push   %rsp
    40d2:	0b 10                	or     (%rax),%edx
    40d4:	d8 ff                	fdivr  %st(7),%st
    40d6:	ff                   	(bad)
    40d7:	ff                   	(bad)
    40d8:	ff                   	(bad)
    40d9:	ff                   	(bad)
    40da:	ff                   	(bad)
    40db:	ff                   	(bad)
    40dc:	ff 01                	incl   (%rcx)
    40de:	4a 01 55 02          	rex.WX add %rdx,0x2(%rbp)
    40e2:	7d 00                	jge    40e4 <_license+0x204a>
    40e4:	00 49 01             	add    %cl,0x1(%rcx)
    40e7:	50                   	push   %rax
    40e8:	b0 01                	mov    $0x1,%al
    40ea:	4a 01 52 01          	rex.WX add %rdx,0x1(%rdx)
    40ee:	30 4a 01             	xor    %cl,0x1(%rdx)
    40f1:	51                   	push   %rcx
    40f2:	03 91 c0 00 4a 01    	add    0x14a00c0(%rcx),%edx
    40f8:	54                   	push   %rsp
    40f9:	02 91 08 4a 01 55    	add    0x55014a08(%rcx),%dl
    40ff:	05 91 d0 00 94       	add    $0x9400d091,%eax
    4104:	08 00                	or     %al,(%rax)
    4106:	49 01 50 b1          	add    %rdx,-0x4f(%r8)
    410a:	01 4a 01             	add    %ecx,0x1(%rdx)
    410d:	54                   	push   %rsp
    410e:	02 91 08 4a 01 55    	add    0x55014a08(%rcx),%dl
    4114:	05 91 d0 00 94       	add    $0x9400d091,%eax
    4119:	08 00                	or     %al,(%rax)
    411b:	49 01 50 b2          	add    %rdx,-0x4e(%r8)
    411f:	01 4a 01             	add    %ecx,0x1(%rdx)
    4122:	54                   	push   %rsp
    4123:	02 91 08 4a 01 55    	add    0x55014a08(%rcx),%dl
    4129:	05 91 d0 00 94       	add    $0x9400d091,%eax
    412e:	08 00                	or     %al,(%rax)
    4130:	4b 01 50 b3          	rex.WXB add %rdx,-0x4d(%r8)
    4134:	01 4b 01             	add    %ecx,0x1(%rbx)
    4137:	50                   	push   %rax
    4138:	b4 01                	mov    $0x1,%ah
    413a:	49 01 50 b5          	add    %rdx,-0x4b(%r8)
    413e:	01 4a 01             	add    %ecx,0x1(%rdx)
    4141:	54                   	push   %rsp
    4142:	03 91 e8 00 00 49    	add    0x490000e8(%rcx),%edx
    4148:	01 52 b6             	add    %edx,-0x4a(%rdx)
    414b:	01 4a 01             	add    %ecx,0x1(%rdx)
    414e:	54                   	push   %rsp
    414f:	02 91 30 00 49 01    	add    0x1490030(%rcx),%dl
    4155:	50                   	push   %rax
    4156:	b7 01                	mov    $0x1,%bh
    4158:	4a 01 54 0b 10       	add    %rdx,0x10(%rbx,%r9,1)
    415d:	ec                   	in     (%dx),%al
    415e:	ff                   	(bad)
    415f:	ff                   	(bad)
    4160:	ff                   	(bad)
    4161:	ff                   	(bad)
    4162:	ff                   	(bad)
    4163:	ff                   	(bad)
    4164:	ff                   	(bad)
    4165:	ff 01                	incl   (%rcx)
    4167:	4a 01 55 02          	rex.WX add %rdx,0x2(%rbp)
    416b:	7d 00                	jge    416d <_license+0x20d3>
    416d:	00 4b 01             	add    %cl,0x1(%rbx)
    4170:	50                   	push   %rax
    4171:	b8 01 49 01 50       	mov    $0x50014901,%eax
    4176:	b9 01 4a 01 54       	mov    $0x54014a01,%ecx
    417b:	0b 10                	or     (%rax),%edx
    417d:	d8 ff                	fdivr  %st(7),%st
    417f:	ff                   	(bad)
    4180:	ff                   	(bad)
    4181:	ff                   	(bad)
    4182:	ff                   	(bad)
    4183:	ff                   	(bad)
    4184:	ff                   	(bad)
    4185:	ff 01                	incl   (%rcx)
    4187:	4a 01 55 02          	rex.WX add %rdx,0x2(%rbp)
    418b:	7d 00                	jge    418d <_license+0x20f3>
    418d:	00 49 01             	add    %cl,0x1(%rcx)
    4190:	50                   	push   %rax
    4191:	ba 01 4a 01 52       	mov    $0x52014a01,%edx
    4196:	01 30                	add    %esi,(%rax)
    4198:	4a 01 51 03          	rex.WX add %rdx,0x3(%rcx)
    419c:	91                   	xchg   %eax,%ecx
    419d:	c0 00 4a             	rolb   $0x4a,(%rax)
    41a0:	01 54 02 91          	add    %edx,-0x6f(%rdx,%rax,1)
    41a4:	08 4a 01             	or     %cl,0x1(%rdx)
    41a7:	55                   	push   %rbp
    41a8:	05 91 d0 00 94       	add    $0x9400d091,%eax
    41ad:	08 00                	or     %al,(%rax)
    41af:	4b 01 50 bb          	rex.WXB add %rdx,-0x45(%r8)
    41b3:	01 49 01             	add    %ecx,0x1(%rcx)
    41b6:	50                   	push   %rax
    41b7:	bc 01 4a 01 54       	mov    $0x54014a01,%esp
    41bc:	02 91 08 4a 01 55    	add    0x55014a08(%rcx),%dl
    41c2:	05 91 d0 00 94       	add    $0x9400d091,%eax
    41c7:	08 00                	or     %al,(%rax)
    41c9:	49 01 50 bd          	add    %rdx,-0x43(%r8)
    41cd:	01 4a 01             	add    %ecx,0x1(%rdx)
    41d0:	52                   	push   %rdx
    41d1:	01 30                	add    %esi,(%rax)
    41d3:	4a 01 51 03          	rex.WX add %rdx,0x3(%rcx)
    41d7:	91                   	xchg   %eax,%ecx
    41d8:	c0 00 4a             	rolb   $0x4a,(%rax)
    41db:	01 54 02 91          	add    %edx,-0x6f(%rdx,%rax,1)
    41df:	08 4a 01             	or     %cl,0x1(%rdx)
    41e2:	55                   	push   %rbp
    41e3:	05 91 d0 00 94       	add    $0x9400d091,%eax
    41e8:	08 00                	or     %al,(%rax)
    41ea:	4b 01 50 be          	rex.WXB add %rdx,-0x42(%r8)
    41ee:	01 49 01             	add    %ecx,0x1(%rcx)
    41f1:	50                   	push   %rax
    41f2:	bf 01 4a 01 52       	mov    $0x52014a01,%edi
    41f7:	01 30                	add    %esi,(%rax)
    41f9:	4a 01 51 03          	rex.WX add %rdx,0x3(%rcx)
    41fd:	91                   	xchg   %eax,%ecx
    41fe:	c0 00 4a             	rolb   $0x4a,(%rax)
    4201:	01 54 02 91          	add    %edx,-0x6f(%rdx,%rax,1)
    4205:	08 4a 01             	or     %cl,0x1(%rdx)
    4208:	55                   	push   %rbp
    4209:	05 91 d0 00 94       	add    $0x9400d091,%eax
    420e:	08 00                	or     %al,(%rax)
	...

Disassembly of section .debug_rnglists:

0000000000000000 <.debug_rnglists>:
  void* data = (void*)(long)ctx->data;
   0:	b3 03                	mov    $0x3,%bl
   2:	00 00                	add    %al,(%rax)
   4:	05 00 08 00 2c       	add    $0x2c000800,%eax
   9:	00 00                	add    %al,(%rax)
   b:	00 b0 00 00 00 f6    	add    %dh,-0xa000000(%rax)
  11:	00 00                	add    %al,(%rax)
  13:	00 06                	add    %al,(%rsi)
  15:	01 00                	add    %eax,(%rax)
  17:	00 20                	add    %ah,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
  19:	01 00                	add    %eax,(%rax)
  1b:	00 2b                	add    %ch,(%rbx)
  if (data + nh_off > data_end) {
  1d:	01 00                	add    %eax,(%rax)
  1f:	00 3b                	add    %bh,(%rbx)
  21:	01 00                	add    %eax,(%rax)
  23:	00 46 01             	add    %al,0x1(%rsi)
  26:	00 00                	add    %al,(%rax)
  28:	51                   	push   %rcx
  29:	01 00                	add    %eax,(%rax)
  2b:	00 70 01             	add    %dh,0x1(%rax)
  2e:	00 00                	add    %al,(%rax)
  30:	85 01                	test   %eax,(%rcx)
  eth_proto = eth->h_proto;
  32:	00 00                	add    %al,(%rax)
  34:	90                   	nop
  if (eth_proto == BE_ETH_P_IP) {
  35:	01 00                	add    %eax,(%rax)
  37:	00 a0 01 00 00 ab    	add    %ah,-0x54ffffff(%rax)
  3d:	01 00                	add    %eax,(%rax)
  3f:	00 b6 01 00 00 c6    	add    %dh,-0x39ffffff(%rsi)
  45:	01 00                	add    %eax,(%rax)
  47:	00 d1                	add    %dl,%cl
  49:	01 00                	add    %eax,(%rax)
  4b:	00 dc                	add    %bl,%ah
  struct packet_description pckt = {};
  4d:	01 00                	add    %eax,(%rax)
  4f:	00 ec                	add    %ch,%ah
  51:	01 00                	add    %eax,(%rax)
  53:	00 f7                	add    %dh,%bh
  55:	01 00                	add    %eax,(%rax)
  57:	00 02                	add    %al,(%rdx)
  59:	02 00                	add    (%rax),%al
  5b:	00 0d 02 00 00 18    	add    %cl,0x18000002(%rip)        # 18000063 <_license+0x17ffdfc9>
  61:	02 00                	add    (%rax),%al
  63:	00 23                	add    %ah,(%rbx)
  65:	02 00                	add    (%rax),%al
  67:	00 2e                	add    %ch,(%rsi)
  69:	02 00                	add    (%rax),%al
  6b:	00 84 02 00 00 8f 02 	add    %al,0x28f0000(%rdx,%rax,1)
  72:	00 00                	add    %al,(%rax)
  74:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
  75:	02 00                	add    (%rax),%al
  77:	00 af 02 00 00 ba    	add    %ch,-0x45fffffe(%rdi)
  7d:	02 00                	add    (%rax),%al
  7f:	00 c5                	add    %al,%ch
  81:	02 00                	add    (%rax),%al
  83:	00 d0                	add    %dl,%al
  85:	02 00                	add    (%rax),%al
  87:	00 f4                	add    %dh,%ah
  89:	02 00                	add    (%rax),%al
  8b:	00 09                	add    %cl,(%rcx)
  bpf_tail_call(xdp, &subprograms, 0);
  8d:	03 00                	add    (%rax),%eax
  8f:	00 14 03             	add    %dl,(%rbx,%rax,1)
  92:	00 00                	add    %al,(%rax)
  94:	29 03                	sub    %eax,(%rbx)
  96:	00 00                	add    %al,(%rax)
  98:	34 03                	xor    $0x3,%al
  9a:	00 00                	add    %al,(%rax)
  9c:	44 03 00             	add    (%rax),%r8d
  9f:	00 59 03             	add    %bl,0x3(%rcx)
  a2:	00 00                	add    %al,(%rax)
  a4:	64 03 00             	add    %fs:(%rax),%eax
  struct packet_description pckt = {};
  a7:	00 74 03 00          	add    %dh,0x0(%rbx,%rax,1)
  ab:	00 7f 03             	add    %bh,0x3(%rdi)
  ae:	00 00                	add    %al,(%rax)
  b0:	8a 03                	mov    (%rbx),%al
  b2:	00 00                	add    %al,(%rax)
  b4:	95                   	xchg   %eax,%ebp
  b5:	03 00                	add    (%rax),%eax
  b7:	00 a0 03 00 00 04    	add    %ah,0x4000003(%rax)
  bd:	4c a5                	rex.WR movsq %ds:(%rsi),%es:(%rdi)
  bf:	01 04 82             	add    %eax,(%rdx,%rax,4)
  c2:	02 dc                	add    %ah,%bl
  c4:	03 04 fb             	add    (%rbx,%rdi,8),%eax
  c7:	08 9d 0a 04 84 10    	or     %bl,0x1084040a(%rbp)
  cd:	f4                   	hlt
  ce:	10 04 aa             	adc    %al,(%rdx,%rbp,4)
  d1:	11 f8                	adc    %edi,%eax
  d3:	13 04 81             	adc    (%rcx,%rax,4),%eax
  d6:	14 ad                	adc    $0xad,%al
  d8:	16                   	(bad)
  d9:	04 cc                	add    $0xcc,%al
  db:	17                   	(bad)
  dc:	82                   	(bad)
  dd:	18 04 c5 18 93 1c 04 	sbb    %al,0x41c9318(,%rax,8)
  e4:	ef                   	out    %eax,(%dx)
  bpf_tail_call(xdp, &subprograms, 0);
  e5:	1c bd                	sbb    $0xbd,%al
  e7:	1e                   	(bad)
  e8:	04 96                	add    $0x96,%al
  ea:	1f                   	(bad)
  eb:	f3 27                	repz (bad)
  ed:	04 e3                	add    $0xe3,%al
  ef:	28 c0                	sub    %al,%al
  f1:	2a 04 bf             	sub    (%rdi,%rdi,4),%al
  f4:	3b 99 3c 04 83 3d    	cmp    0x3d83043c(%rcx),%ebx
  fa:	93                   	xchg   %eax,%ebx
  fb:	3e 04 b7             	ds add $0xb7,%al
  fe:	3f                   	(bad)
  ff:	9a                   	(bad)
 100:	41 00 04 9c          	add    %al,(%r12,%rbx,4)
  struct vip_definition vip = {};
 104:	02 d3                	add    %bl,%dl
 106:	02 04 d7             	add    (%rdi,%rdx,8),%al
 109:	02 df                	add    %bh,%bl
 10b:	02 04 fb             	add    (%rbx,%rdi,8),%al
 10e:	08 89 09 00 04 df    	or     %cl,-0x20fbfff7(%rcx)
 114:	02 dc                	add    %ah,%bl
 116:	03 04 89             	add    (%rcx,%rcx,4),%eax
 119:	09 d2                	or     %edx,%edx
 11b:	09 04 84             	or     %eax,(%rsp,%rax,4)
    if (iph + 1 > data_end) {
 11e:	10 f4                	adc    %dh,%ah
 120:	10 04 93             	adc    %al,(%rbx,%rdx,4)
 123:	12 cf                	adc    %bh,%cl
 125:	12 04 d4             	adc    (%rsp,%rdx,8),%al
 128:	12 81 13 00 04 df    	adc    -0x20fbffed(%rcx),%al
    if (iph->ihl != 5) {
 12e:	02 dc                	add    %ah,%bl
 130:	03 04 84             	add    (%rsp,%rax,4),%eax
 133:	10 f4                	adc    %dh,%ah
    pckt->tos = iph->tos;
 135:	10 00                	adc    %al,(%rax)
 137:	04 8d                	add    $0x8d,%al
 139:	09 d2                	or     %edx,%edx
 13b:	09 04 93             	or     %eax,(%rbx,%rdx,4)
    *protocol = iph->protocol;
 13e:	12 cf                	adc    %bh,%cl
    pckt->flow.proto = *protocol;
 140:	12 04 d4             	adc    (%rsp,%rdx,8),%al
    if (iph->frag_off & PCKT_FRAGMENTED) {
 143:	12 81 13 00 04 e7    	adc    -0x18fbffed(%rcx),%al
 149:	15 f2 15 04 c5       	adc    $0xc50415f2,%eax
 14e:	18 de                	sbb    %bl,%dh
 150:	18 00                	sbb    %al,(%rax)
 152:	04 e7                	add    $0xe7,%al
 154:	15 f2 15 04 c5       	adc    $0xc50415f2,%eax
    if (*protocol == IPPROTO_ICMP) {
 159:	18 de                	sbb    %bl,%dh
 15b:	18 00                	sbb    %al,(%rax)
 15d:	04 8a                	add    $0x8a,%al
  if (icmp_hdr + 1 > data_end) {
 15f:	19 96 1a 04 e6 1d    	sbb    %edx,0x1de6041a(%rsi)
 165:	bd 1e 04 a1 2a       	mov    $0x2aa1041e,%ebp
 16a:	c0 2a 04             	shrb   $0x4,(%rdx)
  if (icmp_hdr->type == ICMP_ECHO) {
 16d:	bf 3b 99 3c 04       	mov    $0x43c993b,%edi
 172:	83 3d 93 3e 04 b7 3f 	cmpl   $0x3f,-0x48fbc16d(%rip)        # ffffffffb704400c <server_id_map+0x5ffffe3de1900c>
 179:	8f 41 00             	pop    0x0(%rcx)
 17c:	04 a3                	add    $0xa3,%al
 17e:	19 96 1a 04 e6 1d    	sbb    %edx,0x1de6041a(%rsi)
 184:	fc                   	cld
 185:	1d 04 a1 2a c0       	sbb    $0xc02aa104,%eax
 18a:	2a 04 bf             	sub    (%rdi,%rdi,4),%al
  icmp_hdr->type = ICMP_ECHOREPLY;
 18d:	3b 82 3c 00 04 e6    	cmp    -0x19fbffc4(%rdx),%eax
  icmp_hdr->checksum += 0x0008;
 193:	1d fc 1d 04 a1       	sbb    $0xa1041dfc,%eax
  iph->daddr = iph->saddr;
 198:	2a ab 2a 00 04 8a    	sub    -0x75fbffd6(%rbx),%ch
 19e:	3c 99                	cmp    $0x99,%al
 1a0:	3c 04                	cmp    $0x4,%al
  iph->saddr = tmp_addr;
 1a2:	83 3d 93 3e 04 b7 3f 	cmpl   $0x3f,-0x48fbc16d(%rip)        # ffffffffb704403c <server_id_map+0x5ffffe3de1903c>
 1a9:	8f 41 00             	pop    0x0(%rcx)
 1ac:	04 8a                	add    $0x8a,%al
 1ae:	3c 99                	cmp    $0x99,%al
 1b0:	3c 04                	cmp    $0x4,%al
 1b2:	83 3d 89 3d 00 04 a6 	cmpl   $0xffffffa6,0x4003d89(%rip)        # 4003f42 <_license+0x4001ea8>
 1b9:	3d 83 3e 04 b7       	cmp    $0xb7043e83,%eax
 1be:	3f                   	(bad)
 1bf:	8f 41 00             	pop    0x0(%rcx)
 1c2:	04 d7                	add    $0xd7,%al
 1c4:	3d f7 3d 04 b7       	cmp    $0xb7043df7,%eax
 1c9:	3f                   	(bad)
 1ca:	82                   	(bad)
 1cb:	40 04 bc             	rex add $0xbc,%al
 1ce:	40 ff 40 00          	rex incl 0x0(%rax)
 1d2:	04 b7                	add    $0xb7,%al
 1d4:	3f                   	(bad)
 1d5:	80 40 04 bc          	addb   $0xbc,0x4(%rax)
 1d9:	40 ce                	rex (bad)
 1db:	40 00 04 ec          	rex add %al,(%rsp,%rbp,8)
 1df:	1a ad 1b 04 96 1f    	sbb    0x1f96041b(%rbp),%ch
 1e5:	c4                   	(bad)
 1e6:	1f                   	(bad)
 1e7:	00 04 b0             	add    %al,(%rax,%rsi,4)
 1ea:	1b 93 1c 04 ef 1c    	sbb    0x1cef041c(%rbx),%edx
 1f0:	e6 1d                	out    %al,$0x1d
 1f2:	04 c4                	add    $0xc4,%al
 1f4:	1f                   	(bad)
 1f5:	cf                   	iret
    if (ip6h + 1 > data_end) {
 1f6:	1f                   	(bad)
 1f7:	00 04 ca             	add    %al,(%rdx,%rcx,8)
 1fa:	1b 93 1c 04 ef 1c    	sbb    0x1cef041c(%rbx),%edx
 200:	85 1d 00 04 f2 22    	test   %ebx,0x22f20400(%rip)        # 22f20606 <_license+0x22f1e56c>
    pckt->flow.proto = *protocol;
 206:	a8 26                	test   $0x26,%al
 208:	04 e3                	add    $0xe3,%al
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 20a:	28 8a 29 00 04 ec    	sub    %cl,-0x13fbffd7(%rdx)
 210:	23 b0 25 04 e4 25    	and    0x25e40425(%rax),%esi
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 216:	8c 26                	mov    %fs,(%rsi)
 218:	00 04 f1             	add    %al,(%rcx,%rsi,8)
 21b:	23 f7                	and    %edi,%esi
 21d:	23 04 9a             	and    (%rdx,%rbx,4),%eax
    if (*protocol == IPPROTO_FRAGMENT) {
 220:	24 ea                	and    $0xea,%al
 222:	24 00                	and    $0x0,%al
 224:	04 8c                	add    $0x8c,%al
 226:	25 92 25 04 98       	and    $0x98042592,%eax
 22b:	25 a4 25 00 04       	and    $0x40025a4,%eax
 230:	8c 25 92 25 04 98    	mov    %fs,-0x67fbda6e(%rip)        # ffffffff980427c8 <server_id_map+0x5ffffe1ee177c8>
  if (icmp_hdr + 1 > data_end) {
 236:	25 a4 25 00 04       	and    $0x40025a4,%eax
 23b:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
 23c:	01 82 02 04 dc 03    	add    %eax,0x3dc0402(%rdx)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 242:	e2 04                	loop   248 <balancer_ingress+0x248>
 244:	04 dc                	add    $0xdc,%al
 246:	05 97 07 04 b9       	add    $0xb9040797,%eax
 24b:	08 fb                	or     %bh,%bl
 24d:	08 04 a7             	or     %al,(%rdi,%riz,4)
 250:	0a 84 10 04 f4 10 aa 	or     -0x55ef0bfc(%rax,%rdx,1),%al
 257:	11 04 ad 16 cc 17 04 	adc    %eax,0x417cc16(,%rbp,4)
 25e:	82                   	(bad)
 25f:	18 c5                	sbb    %al,%ch
 261:	18 04 93             	sbb    %al,(%rbx,%rdx,4)
 264:	1c ef                	sbb    $0xef,%al
 266:	1c 04                	sbb    $0x4,%al
 268:	bd 1e 96 1f 04       	mov    $0x41f961e,%ebp
 26d:	f3 27                	repz (bad)
 26f:	d9 28                	fldcw  (%rax)
 271:	04 d3                	add    $0xd3,%al
 273:	2a a2 31 04 b0 32    	sub    0x32b00431(%rdx),%ah
 279:	ce                   	(bad)
 27a:	37                   	(bad)
 27b:	04 ef                	add    $0xef,%al
 27d:	37                   	(bad)
 27e:	c9                   	leave
 27f:	39 04 d6             	cmp    %eax,(%rsi,%rdx,8)
 282:	39 bf 3b 04 a0 3c    	cmp    %edi,0x3ca0043b(%rdi)
 288:	f0 3c 04             	lock cmp $0x4,%al
 28b:	9d                   	popf
 28c:	3e b7 3f             	ds mov $0x3f,%bh
 28f:	00 04 f6             	add    %al,(%rsi,%rsi,8)
 292:	03 b4 04 04 dc 05 80 	add    -0x7ffa23fc(%rsp,%rax,1),%esi
 299:	06                   	(bad)
 29a:	00 04 b4             	add    %al,(%rsp,%rsi,4)
 29d:	04 e2                	add    $0xe2,%al
 29f:	04 04                	add    $0x4,%al
 2a1:	80 06 97             	addb   $0x97,(%rsi)
 2a4:	07                   	(bad)
 2a5:	04 a7                	add    $0xa7,%al
 2a7:	0a 93 0b 04 9e 0d    	or     0xd9e040b(%rbx),%dl
 2ad:	8e 0e                	mov    (%rsi),%cs
 2af:	00 04 b4             	add    %al,(%rsp,%rsi,4)
 2b2:	04 e2                	add    $0xe2,%al
 2b4:	04 04                	add    $0x4,%al
 2b6:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
 2b7:	0a 93 0b 00 04 88    	or     -0x77fbfff5(%rbx),%dl
 2bd:	06                   	(bad)
 2be:	97                   	xchg   %eax,%edi
 2bf:	07                   	(bad)
 2c0:	04 9e                	add    $0x9e,%al
 2c2:	0d 8e 0e 00 04       	or     $0x4000e8e,%eax
 2c7:	c8 0f d3 0f          	enter  $0xd30f,$0xf
 2cb:	04 ad                	add    $0xad,%al
 2cd:	16                   	(bad)
 2ce:	c6                   	(bad)
 2cf:	16                   	(bad)
 2d0:	00 04 c8             	add    %al,(%rax,%rcx,8)
 2d3:	0f d3 0f             	psrlq  (%rdi),%mm1
 2d6:	04 ad                	add    $0xad,%al
 2d8:	16                   	(bad)
 2d9:	c6                   	(bad)
 2da:	16                   	(bad)
 2db:	00 04 f7             	add    %al,(%rdi,%rsi,8)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2de:	16                   	(bad)
 2df:	cc                   	int3
 2e0:	17                   	(bad)
 2e1:	04 93                	add    $0x93,%al
 2e3:	1c ef                	sbb    $0xef,%al
 2e5:	1c 04                	sbb    $0x4,%al
 2e7:	bd 1e 96 1f 04       	mov    $0x41f961e,%ebp
 2ec:	f3 27                	repz (bad)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2ee:	d9 28                	fldcw  (%rax)
 2f0:	04 d3                	add    $0xd3,%al
 2f2:	2a e1                	sub    %cl,%ah
 2f4:	2b 04 a0             	sub    (%rax,%riz,4),%eax
 2f7:	3c f0                	cmp    $0xf0,%al
 2f9:	3c 04                	cmp    $0x4,%al
 2fb:	9d                   	popf
 2fc:	3e ac                	lods   %ds:(%rsi),%al
 2fe:	3f                   	(bad)
 2ff:	00 04 90             	add    %al,(%rax,%rdx,4)
  if (protocol == IPPROTO_ICMPV6) {
 302:	17                   	(bad)
 303:	cc                   	int3
 304:	17                   	(bad)
 305:	04 93                	add    $0x93,%al
 307:	1c a9                	sbb    $0xa9,%al
  if (icmp_hdr + 1 > data_end) {
 309:	1c 04                	sbb    $0x4,%al
 30b:	bd 1e 96 1f 04       	mov    $0x41f961e,%ebp
 310:	f3 27                	repz (bad)
 312:	b6 28                	mov    $0x28,%dh
 314:	00 04 93             	add    %al,(%rbx,%rdx,4)
  if (icmp_hdr->type == ICMP_ECHO) {
 317:	1c a9                	sbb    $0xa9,%al
 319:	1c 04                	sbb    $0x4,%al
 31b:	bd 1e c7 1e 00       	mov    $0x1ec71e,%ebp
 320:	04 be                	add    $0xbe,%al
 322:	28 d9                	sub    %bl,%cl
 324:	28 04 d3             	sub    %al,(%rbx,%rdx,8)
 327:	2a e1                	sub    %cl,%ah
 329:	2b 04 a0             	sub    (%rax,%riz,4),%eax
 32c:	3c f0                	cmp    $0xf0,%al
 32e:	3c 04                	cmp    $0x4,%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 330:	9d                   	popf
 331:	3e ac                	lods   %ds:(%rsi),%al
 333:	3f                   	(bad)
 334:	00 04 be             	add    %al,(%rsi,%rdi,4)
 337:	28 d9                	sub    %bl,%cl
       sizeof(struct icmphdr)) > data_end) {
 339:	28 04 d3             	sub    %al,(%rbx,%rdx,8)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 33c:	2a d9                	sub    %cl,%bl
 33e:	2a 00                	sub    (%rax),%al
 340:	04 f6                	add    $0xf6,%al
  icmp_hdr->type = ICMP_ECHOREPLY;
 342:	2a d6                	sub    %dh,%dl
 344:	2b 04 a0             	sub    (%rax,%riz,4),%eax
  icmp_hdr->checksum += 0x0008;
 347:	3c f0                	cmp    $0xf0,%al
 349:	3c 04                	cmp    $0x4,%al
  iph->ttl = DEFAULT_TTL;
 34b:	9d                   	popf
 34c:	3e ac                	lods   %ds:(%rsi),%al
 34e:	3f                   	(bad)
  iph->daddr = iph->saddr;
 34f:	00 04 aa             	add    %al,(%rdx,%rbp,4)
  tmp_addr = iph->daddr;
 352:	2b ca                	sub    %edx,%ecx
 354:	2b 04 a0             	sub    (%rax,%riz,4),%eax
  iph->daddr = iph->saddr;
 357:	3c f0                	cmp    $0xf0,%al
  iph->saddr = tmp_addr;
 359:	3c 04                	cmp    $0x4,%al
 35b:	9d                   	popf
 35c:	3e 9f                	ds lahf
 35e:	3e 04 d9             	ds add $0xd9,%al
 361:	3e 9c                	ds pushf
 363:	3f                   	(bad)
 364:	00 04 a0             	add    %al,(%rax,%riz,4)
 367:	3c f0                	cmp    $0xf0,%al
 369:	3c 04                	cmp    $0x4,%al
 36b:	d9 3e                	fnstcw (%rsi)
 36d:	eb 3e                	jmp    3ad <balancer_ingress+0x3ad>
 36f:	00 04 eb             	add    %al,(%rbx,%rbp,8)
 372:	32 ce                	xor    %dh,%cl
 374:	37                   	(bad)
 375:	04 ef                	add    $0xef,%al
 377:	37                   	(bad)
 378:	8c 38                	mov    %?,(%rax)
 37a:	04 d6                	add    $0xd6,%al
 37c:	39 fd                	cmp    %edi,%ebp
 37e:	39 00                	cmp    %eax,(%rax)
 380:	04 e4                	add    $0xe4,%al
 382:	33 82 37 04 af 37    	xor    0x37af0437(%rdx),%eax
 388:	ce                   	(bad)
 389:	37                   	(bad)
 38a:	00 04 e9             	add    %al,(%rcx,%rbp,8)
 38d:	33 8b 34 04 b8 34    	xor    0x34b80434(%rbx),%ecx
 393:	c0 36 00             	shlb   $0x0,(%rsi)
 396:	04 ed                	add    $0xed,%al
 398:	33 8b 34 04 b8 34    	xor    0x34b80434(%rbx),%ecx
 39e:	e9 35 00 04 e2       	jmp    ffffffffe20403d8 <server_id_map+0x5ffffe68e153d8>
 3a3:	36 e8 36 04 ea 36    	ss call 36ea07df <_license+0x36e9e745>
 3a9:	f6 36                	divb   (%rsi)
 3ab:	00 04 e2             	add    %al,(%rdx,%riz,8)
 3ae:	36 e8 36 04 ea 36    	ss call 36ea07ea <_license+0x36e9e750>
 3b4:	f6 36                	divb   (%rsi)
	...

Disassembly of section .debug_str_offsets:

0000000000000000 <.debug_str_offsets>:
  void* data = (void*)(long)ctx->data;
   0:	d4                   	(bad)
   1:	05 00 00 05 00       	add    $0x50000,%eax
   6:	00 00                	add    %al,(%rax)
   8:	00 00                	add    %al,(%rax)
   a:	00 00                	add    %al,(%rax)
   c:	1c 00                	sbb    $0x0,%al
   e:	00 00                	add    %al,(%rax)
  10:	3a 00                	cmp    (%rax),%al
  12:	00 00                	add    %al,(%rax)
  14:	65 00 00             	add    %al,%gs:(%rax)
  17:	00 cd                	add    %cl,%ch
  void* data_end = (void*)(long)ctx->data_end;
  19:	00 00                	add    %al,(%rax)
  1b:	00 6e 00             	add    %ch,0x0(%rsi)
  if (data + nh_off > data_end) {
  1e:	00 00                	add    %al,(%rax)
  20:	82                   	(bad)
  21:	00 00                	add    %al,(%rax)
  23:	00 06                	add    %al,(%rsi)
  25:	09 00                	or     %eax,(%rax)
  27:	00 95 00 00 00 89    	add    %dl,-0x77000000(%rbp)
  2d:	0b 00                	or     (%rax),%eax
  2f:	00 8c 00 00 00 99 00 	add    %cl,0x990000(%rax,%rax,1)
  if (eth_proto == BE_ETH_P_IP) {
  36:	00 00                	add    %al,(%rax)
  38:	db 00                	fildl  (%rax)
  3a:	00 00                	add    %al,(%rax)
  3c:	9f                   	lahf
  3d:	00 00                	add    %al,(%rax)
  3f:	00 b2 00 00 00 b8    	add    %dh,-0x48000000(%rdx)
  45:	00 00                	add    %al,(%rax)
  47:	00 c0                	add    %al,%al
  49:	00 00                	add    %al,(%rax)
  4b:	00 c4                	add    %al,%ah
  struct packet_description pckt = {};
  4d:	00 00                	add    %al,(%rax)
  4f:	00 d2                	add    %dl,%dl
  51:	00 00                	add    %al,(%rax)
  53:	00 d7                	add    %dl,%bh
  55:	00 00                	add    %al,(%rax)
  57:	00 e1                	add    %ah,%cl
  59:	00 00                	add    %al,(%rax)
  5b:	00 ed                	add    %ch,%ch
  5d:	00 00                	add    %al,(%rax)
  5f:	00 7c 0a 00          	add    %bh,0x0(%rdx,%rcx,1)
  63:	00 36                	add    %dh,(%rsi)
  65:	08 00                	or     %al,(%rax)
  67:	00 f7                	add    %dh,%bh
  69:	00 00                	add    %al,(%rax)
  6b:	00 fe                	add    %bh,%dh
  6d:	00 00                	add    %al,(%rax)
  6f:	00 05 01 00 00 0d    	add    %al,0xd000001(%rip)        # d000076 <_license+0xcffdfdc>
  75:	01 00                	add    %eax,(%rax)
  77:	00 19                	add    %bl,(%rcx)
  79:	01 00                	add    %eax,(%rax)
  7b:	00 7c 0d 00          	add    %bh,0x0(%rbp,%rcx,1)
  7f:	00 21                	add    %ah,(%rcx)
  81:	01 00                	add    %eax,(%rax)
  83:	00 c8                	add    %cl,%al
  85:	06                   	(bad)
  86:	00 00                	add    %al,(%rax)
  88:	27                   	(bad)
  89:	01 00                	add    %eax,(%rax)
  8b:	00 36                	add    %dh,(%rsi)
  bpf_tail_call(xdp, &subprograms, 0);
  8d:	01 00                	add    %eax,(%rax)
  8f:	00 76 0e             	add    %dh,0xe(%rsi)
  92:	00 00                	add    %al,(%rax)
  94:	3c 01                	cmp    $0x1,%al
  96:	00 00                	add    %al,(%rax)
  98:	f1                   	int1
  99:	00 00                	add    %al,(%rax)
  9b:	00 4b 01             	add    %cl,0x1(%rbx)
  9e:	00 00                	add    %al,(%rax)
  a0:	53                   	push   %rbx
  a1:	01 00                	add    %eax,(%rax)
  a3:	00 5c 01 00          	add    %bl,0x0(%rcx,%rax,1)
  struct packet_description pckt = {};
  a7:	00 0a                	add    %cl,(%rdx)
  a9:	0d 00 00 6b 01       	or     $0x16b0000,%eax
  ae:	00 00                	add    %al,(%rax)
  b0:	82                   	(bad)
  b1:	0a 00                	or     (%rax),%al
  b3:	00 71 01             	add    %dh,0x1(%rcx)
  b6:	00 00                	add    %al,(%rax)
  b8:	77 01                	ja     bb <balancer_ingress+0xbb>
  ba:	00 00                	add    %al,(%rax)
  bc:	7d 01                	jge    bf <balancer_ingress+0xbf>
  be:	00 00                	add    %al,(%rax)
  c0:	84 01                	test   %al,(%rcx)
  c2:	00 00                	add    %al,(%rax)
  c4:	77 07                	ja     cd <balancer_ingress+0xcd>
  c6:	00 00                	add    %al,(%rax)
  c8:	8d 01                	lea    (%rcx),%eax
  ca:	00 00                	add    %al,(%rax)
  cc:	93                   	xchg   %eax,%ebx
  cd:	01 00                	add    %eax,(%rax)
  cf:	00 a0 01 00 00 ac    	add    %ah,-0x53ffffff(%rax)
  d5:	01 00                	add    %eax,(%rax)
  d7:	00 b3 01 00 00 bc    	add    %dh,-0x43ffffff(%rbx)
  dd:	01 00                	add    %eax,(%rax)
  df:	00 c2                	add    %al,%dl
  e1:	01 00                	add    %eax,(%rax)
  e3:	00 d2                	add    %dl,%dl
  bpf_tail_call(xdp, &subprograms, 0);
  e5:	01 00                	add    %eax,(%rax)
  e7:	00 7d 02             	add    %bh,0x2(%rbp)
  ea:	00 00                	add    %al,(%rax)
  ec:	84 02                	test   %al,(%rdx)
  ee:	00 00                	add    %al,(%rax)
  f0:	de 01                	fiadds (%rcx)
  f2:	00 00                	add    %al,(%rax)
  f4:	5f                   	pop    %rdi
  f5:	0d 00 00 e7 01       	or     $0x1e70000,%eax
  fa:	00 00                	add    %al,(%rax)
  fc:	a0 08 00 00 f6 01 00 	movabs 0x5000001f6000008,%al
 103:	00 05 
  struct vip_definition vip = {};
 105:	02 00                	add    (%rax),%al
 107:	00 0f                	add    %cl,(%rdi)
 109:	02 00                	add    (%rax),%al
 10b:	00 1b                	add    %bl,(%rbx)
 10d:	02 00                	add    (%rax),%al
 10f:	00 31                	add    %dh,(%rcx)
 111:	02 00                	add    (%rax),%al
 113:	00 4e 02             	add    %cl,0x2(%rsi)
 116:	00 00                	add    %al,(%rax)
 118:	59                   	pop    %rcx
 119:	02 00                	add    (%rax),%al
 11b:	00 72 02             	add    %dh,0x2(%rdx)
    if (iph + 1 > data_end) {
 11e:	00 00                	add    %al,(%rax)
 120:	79 02                	jns    124 <balancer_ingress+0x124>
 122:	00 00                	add    %al,(%rax)
 124:	80 02 00             	addb   $0x0,(%rdx)
 127:	00 87 02 00 00 8e    	add    %al,-0x71fffffe(%rdi)
    if (iph->ihl != 5) {
 12d:	02 00                	add    (%rax),%al
 12f:	00 9f 02 00 00 b3    	add    %bl,-0x4cfffffe(%rdi)
    pckt->tos = iph->tos;
 135:	02 00                	add    (%rax),%al
 137:	00 c8                	add    %cl,%al
 139:	02 00                	add    (%rax),%al
 13b:	00 de                	add    %bl,%dh
    *protocol = iph->protocol;
 13d:	02 00                	add    (%rax),%al
    pckt->flow.proto = *protocol;
 13f:	00 ee                	add    %ch,%dh
 141:	02 00                	add    (%rax),%al
    if (iph->frag_off & PCKT_FRAGMENTED) {
 143:	00 02                	add    %al,(%rdx)
 145:	03 00                	add    (%rax),%eax
 147:	00 1d 03 00 00 2d    	add    %bl,0x2d000003(%rip)        # 2d000150 <_license+0x2cffe0b6>
 14d:	03 00                	add    (%rax),%eax
 14f:	00 3b                	add    %bh,(%rbx)
 151:	03 00                	add    (%rax),%eax
 153:	00 49 03             	add    %cl,0x3(%rcx)
 156:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
 158:	54                   	push   %rsp
 159:	03 00                	add    (%rax),%eax
 15b:	00 5c 03 00          	add    %bl,0x0(%rbx,%rax,1)
  if (icmp_hdr + 1 > data_end) {
 15f:	00 71 03             	add    %dh,0x3(%rcx)
 162:	00 00                	add    %al,(%rax)
 164:	81 03 00 00 97 03    	addl   $0x3970000,(%rbx)
 16a:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
 16c:	a8 03                	test   $0x3,%al
 16e:	00 00                	add    %al,(%rax)
 170:	bc 03 00 00 c8       	mov    $0xc8000003,%esp
 175:	03 00                	add    (%rax),%eax
 177:	00 d1                	add    %dl,%cl
 179:	03 00                	add    (%rax),%eax
 17b:	00 da                	add    %bl,%dl
 17d:	03 00                	add    (%rax),%eax
 17f:	00 e1                	add    %ah,%cl
 181:	03 00                	add    (%rax),%eax
 183:	00 ee                	add    %ch,%dh
 185:	03 00                	add    (%rax),%eax
 187:	00 f9                	add    %bh,%cl
 189:	03 00                	add    (%rax),%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
 18b:	00 04 04             	add    %al,(%rsp,%rax,1)
 18e:	00 00                	add    %al,(%rax)
  icmp_hdr->checksum += 0x0008;
 190:	11 04 00             	adc    %eax,(%rax,%rax,1)
 193:	00 1e                	add    %bl,(%rsi)
  iph->ttl = DEFAULT_TTL;
 195:	04 00                	add    $0x0,%al
 197:	00 2b                	add    %ch,(%rbx)
  iph->daddr = iph->saddr;
 199:	04 00                	add    $0x0,%al
  tmp_addr = iph->daddr;
 19b:	00 37                	add    %dh,(%rdi)
 19d:	04 00                	add    $0x0,%al
  iph->daddr = iph->saddr;
 19f:	00 43 04             	add    %al,0x4(%rbx)
  iph->saddr = tmp_addr;
 1a2:	00 00                	add    %al,(%rax)
 1a4:	4f 04 00             	rex.WRXB add $0x0,%al
 1a7:	00 5b 04             	add    %bl,0x4(%rbx)
 1aa:	00 00                	add    %al,(%rax)
 1ac:	67 04 00             	addr32 add $0x0,%al
 1af:	00 72 04             	add    %dh,0x4(%rdx)
 1b2:	00 00                	add    %al,(%rax)
 1b4:	7f 04                	jg     1ba <balancer_ingress+0x1ba>
 1b6:	00 00                	add    %al,(%rax)
 1b8:	8c 04 00             	mov    %es,(%rax,%rax,1)
 1bb:	00 99 04 00 00 a5    	add    %bl,-0x5afffffc(%rcx)
 1c1:	04 00                	add    $0x0,%al
 1c3:	00 b1 04 00 00 bc    	add    %dh,-0x43fffffc(%rcx)
 1c9:	04 00                	add    $0x0,%al
 1cb:	00 c8                	add    %cl,%al
 1cd:	04 00                	add    $0x0,%al
 1cf:	00 d7                	add    %dl,%bh
 1d1:	04 00                	add    $0x0,%al
 1d3:	00 e5                	add    %ah,%ch
 1d5:	04 00                	add    $0x0,%al
 1d7:	00 f1                	add    %dh,%cl
 1d9:	04 00                	add    $0x0,%al
 1db:	00 fe                	add    %bh,%dh
 1dd:	04 00                	add    $0x0,%al
 1df:	00 0b                	add    %cl,(%rbx)
 1e1:	05 00 00 18 05       	add    $0x5180000,%eax
 1e6:	00 00                	add    %al,(%rax)
 1e8:	28 05 00 00 35 05    	sub    %al,0x5350000(%rip)        # 53501ee <_license+0x534e154>
 1ee:	00 00                	add    %al,(%rax)
 1f0:	46 05 00 00 56 05    	rex.RX add $0x5560000,%eax
    if (ip6h + 1 > data_end) {
 1f6:	00 00                	add    %al,(%rax)
 1f8:	62 05                	(bad)
 1fa:	00 00                	add    %al,(%rax)
 1fc:	6e                   	outsb  %ds:(%rsi),(%dx)
 1fd:	05 00 00 7c 05       	add    $0x57c0000,%eax
 202:	00 00                	add    %al,(%rax)
    *protocol = ip6h->nexthdr;
 204:	ad                   	lods   %ds:(%rsi),%eax
 205:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
 207:	00 d9                	add    %bl,%cl
 209:	0a 00                	or     (%rax),%al
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 20b:	00 88 05 00 00 91    	add    %cl,-0x6efffffb(%rax)
 211:	05 00 00 9b 05       	add    $0x59b0000,%eax
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 216:	00 00                	add    %al,(%rax)
 218:	ab                   	stos   %eax,%es:(%rdi)
 219:	05 00 00 af 05       	add    $0x5af0000,%eax
 21e:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_FRAGMENT) {
 220:	bc 05 00 00 c0       	mov    $0xc0000005,%esp
 225:	05 00 00 cd 05       	add    $0x5cd0000,%eax
 22a:	00 00                	add    %al,(%rax)
 22c:	d6                   	(bad)
 22d:	05 00 00 4d 07       	add    $0x74d0000,%eax
 232:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 234:	dd 05 00 00 ea 05    	fldl   0x5ea0000(%rip)        # 5ea023a <_license+0x5e9e1a0>
 23a:	00 00                	add    %al,(%rax)
 23c:	fc                   	cld
 23d:	05 00 00 ee 05       	add    $0x5ee0000,%eax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 242:	00 00                	add    %al,(%rax)
 244:	0d 06 00 00 9b       	or     $0x9b000006,%eax
 249:	00 00                	add    %al,(%rax)
 24b:	00 1f                	add    %bl,(%rdi)
 24d:	06                   	(bad)
 24e:	00 00                	add    %al,(%rax)
 250:	2e 06                	cs (bad)
 252:	00 00                	add    %al,(%rax)
 254:	32 06                	xor    (%rsi),%al
 256:	00 00                	add    %al,(%rax)
 258:	39 06                	cmp    %eax,(%rsi)
 25a:	00 00                	add    %al,(%rax)
 25c:	41 06                	rex.B (bad)
 25e:	00 00                	add    %al,(%rax)
 260:	47 06                	rex.RXB (bad)
 262:	00 00                	add    %al,(%rax)
 264:	4c 06                	rex.WR (bad)
 266:	00 00                	add    %al,(%rax)
 268:	51                   	push   %rcx
 269:	06                   	(bad)
 26a:	00 00                	add    %al,(%rax)
 26c:	5c                   	pop    %rsp
 26d:	06                   	(bad)
 26e:	00 00                	add    %al,(%rax)
 270:	60                   	(bad)
 271:	06                   	(bad)
 272:	00 00                	add    %al,(%rax)
 274:	73 06                	jae    27c <balancer_ingress+0x27c>
 276:	00 00                	add    %al,(%rax)
 278:	80 06 00             	addb   $0x0,(%rsi)
 27b:	00 f2                	add    %dh,%dl
 27d:	03 00                	add    (%rax),%eax
 27f:	00 87 06 00 00 90    	add    %al,-0x6ffffffa(%rdi)
 285:	06                   	(bad)
 286:	00 00                	add    %al,(%rax)
 288:	be 0c 00 00 99       	mov    $0x9900000c,%esi
 28d:	06                   	(bad)
 28e:	00 00                	add    %al,(%rax)
 290:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
 291:	06                   	(bad)
 292:	00 00                	add    %al,(%rax)
 294:	ac                   	lods   %ds:(%rsi),%al
 295:	06                   	(bad)
 296:	00 00                	add    %al,(%rax)
 298:	b4 06                	mov    $0x6,%ah
 29a:	00 00                	add    %al,(%rax)
 29c:	be 06 00 00 cd       	mov    $0xcd000006,%esi
 2a1:	06                   	(bad)
 2a2:	00 00                	add    %al,(%rax)
 2a4:	d2 06                	rolb   %cl,(%rsi)
 2a6:	00 00                	add    %al,(%rax)
 2a8:	da 06                	fiaddl (%rsi)
 2aa:	00 00                	add    %al,(%rax)
 2ac:	e3 06                	jrcxz  2b4 <balancer_ingress+0x2b4>
 2ae:	00 00                	add    %al,(%rax)
 2b0:	e8 06 00 00 ed       	call   ffffffffed0002bb <server_id_map+0x5ffffe73dd52bb>
 2b5:	06                   	(bad)
 2b6:	00 00                	add    %al,(%rax)
 2b8:	f4                   	hlt
 2b9:	06                   	(bad)
 2ba:	00 00                	add    %al,(%rax)
 2bc:	f8                   	clc
 2bd:	06                   	(bad)
 2be:	00 00                	add    %al,(%rax)
 2c0:	02 07                	add    (%rdi),%al
 2c2:	00 00                	add    %al,(%rax)
 2c4:	0e                   	(bad)
 2c5:	07                   	(bad)
 2c6:	00 00                	add    %al,(%rax)
 2c8:	1c 07                	sbb    $0x7,%al
 2ca:	00 00                	add    %al,(%rax)
 2cc:	26 07                	es (bad)
 2ce:	00 00                	add    %al,(%rax)
 2d0:	2e 07                	cs (bad)
 2d2:	00 00                	add    %al,(%rax)
 2d4:	cb                   	lret
 2d5:	02 00                	add    (%rax),%al
 2d7:	00 45 07             	add    %al,0x7(%rbp)
 2da:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2dc:	27                   	(bad)
 2dd:	02 00                	add    (%rax),%al
 2df:	00 49 07             	add    %cl,0x7(%rcx)
 2e2:	00 00                	add    %al,(%rax)
 2e4:	55                   	push   %rbp
 2e5:	07                   	(bad)
 2e6:	00 00                	add    %al,(%rax)
 2e8:	60                   	(bad)
 2e9:	07                   	(bad)
 2ea:	00 00                	add    %al,(%rax)
 2ec:	72 07                	jb     2f5 <balancer_ingress+0x2f5>
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2ee:	00 00                	add    %al,(%rax)
 2f0:	7b 07                	jnp    2f9 <balancer_ingress+0x2f9>
 2f2:	00 00                	add    %al,(%rax)
 2f4:	7f 07                	jg     2fd <balancer_ingress+0x2fd>
 2f6:	00 00                	add    %al,(%rax)
 2f8:	90                   	nop
 2f9:	07                   	(bad)
 2fa:	00 00                	add    %al,(%rax)
 2fc:	94                   	xchg   %eax,%esp
 2fd:	07                   	(bad)
 2fe:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 300:	98                   	cwtl
 301:	07                   	(bad)
 302:	00 00                	add    %al,(%rax)
 304:	a0 07 00 00 f9 05 00 	movabs 0xa7000005f9000007,%al
 30b:	00 a7 
  if (icmp_hdr + 1 > data_end) {
 30d:	07                   	(bad)
 30e:	00 00                	add    %al,(%rax)
 310:	b0 07                	mov    $0x7,%al
 312:	00 00                	add    %al,(%rax)
 314:	b4 07                	mov    $0x7,%ah
  if (icmp_hdr->type == ICMP_ECHO) {
 316:	00 00                	add    %al,(%rax)
 318:	ba 07 00 00 c2       	mov    $0xc2000007,%edx
 31d:	07                   	(bad)
 31e:	00 00                	add    %al,(%rax)
 320:	c8 07 00 00          	enter  $0x7,$0x0
 324:	ce                   	(bad)
 325:	07                   	(bad)
 326:	00 00                	add    %al,(%rax)
 328:	d4                   	(bad)
 329:	07                   	(bad)
 32a:	00 00                	add    %al,(%rax)
 32c:	da 07                	fiaddl (%rdi)
 32e:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 330:	df 07                	filds  (%rdi)
 332:	00 00                	add    %al,(%rax)
 334:	e8 07 00 00 f1       	call   fffffffff1000340 <server_id_map+0x5ffffe77dd5340>
       sizeof(struct icmphdr)) > data_end) {
 339:	07                   	(bad)
 33a:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 33c:	fd                   	std
 33d:	07                   	(bad)
 33e:	00 00                	add    %al,(%rax)
 340:	05 08 00 00 0f       	add    $0xf000008,%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
 345:	08 00                	or     %al,(%rax)
  icmp_hdr->checksum += 0x0008;
 347:	00 15 08 00 00 1e    	add    %dl,0x1e000008(%rip)        # 1e000355 <_license+0x1dffe2bb>
  iph->ttl = DEFAULT_TTL;
 34d:	08 00                	or     %al,(%rax)
  iph->daddr = iph->saddr;
 34f:	00 28                	add    %ch,(%rax)
 351:	08 00                	or     %al,(%rax)
  tmp_addr = iph->daddr;
 353:	00 32                	add    %dh,(%rdx)
  iph->daddr = iph->saddr;
 355:	08 00                	or     %al,(%rax)
 357:	00 3b                	add    %bh,(%rbx)
  iph->saddr = tmp_addr;
 359:	08 00                	or     %al,(%rax)
 35b:	00 43 08             	add    %al,0x8(%rbx)
 35e:	00 00                	add    %al,(%rax)
 360:	ac                   	lods   %ds:(%rsi),%al
 361:	07                   	(bad)
 362:	00 00                	add    %al,(%rax)
 364:	4e 08 00             	rex.WRX or %r8b,(%rax)
 367:	00 11                	add    %dl,(%rcx)
 369:	09 00                	or     %eax,(%rax)
 36b:	00 57 08             	add    %dl,0x8(%rdi)
 36e:	00 00                	add    %al,(%rax)
 370:	2c 09                	sub    $0x9,%al
 372:	00 00                	add    %al,(%rax)
 374:	65 09 00             	or     %eax,%gs:(%rax)
 377:	00 60 08             	add    %ah,0x8(%rax)
 37a:	00 00                	add    %al,(%rax)
 37c:	69 08 00 00 71 08    	imul   $0x8710000,(%rax),%ecx
 382:	00 00                	add    %al,(%rax)
 384:	76 08                	jbe    38e <balancer_ingress+0x38e>
 386:	00 00                	add    %al,(%rax)
 388:	7f 08                	jg     392 <balancer_ingress+0x392>
 38a:	00 00                	add    %al,(%rax)
 38c:	83 08 00             	orl    $0x0,(%rax)
 38f:	00 8c 08 00 00 94 08 	add    %cl,0x8940000(%rax,%rcx,1)
 396:	00 00                	add    %al,(%rax)
 398:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
 399:	08 00                	or     %al,(%rax)
 39b:	00 b5 08 00 00 c5    	add    %dh,-0x3afffff8(%rbp)
 3a1:	08 00                	or     %al,(%rax)
 3a3:	00 ce                	add    %cl,%dh
 3a5:	08 00                	or     %al,(%rax)
 3a7:	00 d3                	add    %dl,%bl
 3a9:	08 00                	or     %al,(%rax)
 3ab:	00 e4                	add    %ah,%ah
 3ad:	08 00                	or     %al,(%rax)
 3af:	00 f1                	add    %dh,%cl
 3b1:	08 00                	or     %al,(%rax)
 3b3:	00 f3                	add    %dh,%bl
 3b5:	08 00                	or     %al,(%rax)
 3b7:	00 00                	add    %al,(%rax)
 3b9:	09 00                	or     %eax,(%rax)
 3bb:	00 0b                	add    %cl,(%rbx)
 3bd:	09 00                	or     %eax,(%rax)
 3bf:	00 16                	add    %dl,(%rsi)
 3c1:	09 00                	or     %eax,(%rax)
 3c3:	00 22                	add    %ah,(%rdx)
 3c5:	09 00                	or     %eax,(%rax)
 3c7:	00 2f                	add    %ch,(%rdi)
 3c9:	09 00                	or     %eax,(%rax)
 3cb:	00 39                	add    %bh,(%rcx)
 3cd:	09 00                	or     %eax,(%rax)
 3cf:	00 43 09             	add    %al,0x9(%rbx)
 3d2:	00 00                	add    %al,(%rax)
 3d4:	4c 09 00             	or     %r8,(%rax)
 3d7:	00 53 09             	add    %dl,0x9(%rbx)
 3da:	00 00                	add    %al,(%rax)
 3dc:	5e                   	pop    %rsi
 3dd:	09 00                	or     %eax,(%rax)
 3df:	00 6a 09             	add    %ch,0x9(%rdx)
 3e2:	00 00                	add    %al,(%rax)
 3e4:	74 09                	je     3ef <balancer_ingress+0x3ef>
 3e6:	00 00                	add    %al,(%rax)
 3e8:	7d 09                	jge    3f3 <balancer_ingress+0x3f3>
 3ea:	00 00                	add    %al,(%rax)
 3ec:	87 09                	xchg   %ecx,(%rcx)
 3ee:	00 00                	add    %al,(%rax)
 3f0:	8e 09                	mov    (%rcx),%cs
 3f2:	00 00                	add    %al,(%rax)
 3f4:	98                   	cwtl
 3f5:	09 00                	or     %eax,(%rax)
 3f7:	00 a7 09 00 00 af    	add    %ah,-0x50fffff7(%rdi)
 3fd:	09 00                	or     %eax,(%rax)
 3ff:	00 bb 09 00 00 c6    	add    %bh,-0x39fffff7(%rbx)
 405:	09 00                	or     %eax,(%rax)
 407:	00 cc                	add    %cl,%ah
 409:	09 00                	or     %eax,(%rax)
 40b:	00 d4                	add    %dl,%ah
 40d:	09 00                	or     %eax,(%rax)
 40f:	00 e0                	add    %ah,%al
 411:	09 00                	or     %eax,(%rax)
 413:	00 ed                	add    %ch,%ch
 415:	09 00                	or     %eax,(%rax)
 417:	00 f6                	add    %dh,%dh
 419:	09 00                	or     %eax,(%rax)
 41b:	00 08                	add    %cl,(%rax)
 41d:	0a 00                	or     (%rax),%al
 41f:	00 0e                	add    %cl,(%rsi)
 421:	0a 00                	or     (%rax),%al
 423:	00 ff                	add    %bh,%bh
 425:	0b 00                	or     (%rax),%eax
 427:	00 f8                	add    %bh,%al
 429:	0b 00                	or     (%rax),%eax
 42b:	00 16                	add    %dl,(%rsi)
 42d:	0a 00                	or     (%rax),%al
 42f:	00 12                	add    %dl,(%rdx)
 431:	0a 00                	or     (%rax),%al
 433:	00 1a                	add    %bl,(%rdx)
 435:	0a 00                	or     (%rax),%al
 437:	00 1d 0a 00 00 22    	add    %bl,0x2200000a(%rip)        # 22000447 <_license+0x21ffe3ad>
  if (protocol == IPPROTO_IPIP) {
 43d:	0a 00                	or     (%rax),%al
 43f:	00 27                	add    %ah,(%rdi)
 441:	0a 00                	or     (%rax),%al
 443:	00 58 03             	add    %bl,0x3(%rax)
 446:	00 00                	add    %al,(%rax)
 448:	2b 0a                	sub    (%rdx),%ecx
 44a:	00 00                	add    %al,(%rax)
 44c:	2f                   	(bad)
 44d:	0a 00                	or     (%rax),%al
 44f:	00 33                	add    %dh,(%rbx)
  tcp = data + off;
 451:	0a 00                	or     (%rax),%al
 453:	00 37                	add    %dh,(%rdi)
  if (is_ipv6) {
 455:	0a 00                	or     (%rax),%al
  tcp = data + off;
 457:	00 3b                	add    %bh,(%rbx)
 459:	0a 00                	or     (%rax),%al
  if (tcp + 1 > data_end) {
 45b:	00 3f                	add    %bh,(%rdi)
 45d:	0a 00                	or     (%rax),%al
 45f:	00 43 0a             	add    %al,0xa(%rbx)
 462:	00 00                	add    %al,(%rax)
 464:	4a 0a 00             	rex.WX or (%rax),%al
 467:	00 52 0a             	add    %dl,0xa(%rdx)
  if (tcp->syn) {
 46a:	00 00                	add    %al,(%rax)
 46c:	59                   	pop    %rcx
 46d:	0a 00                	or     (%rax),%al
 46f:	00 65 0a             	add    %ah,0xa(%rbp)
    pckt->flags |= F_SYN_SET;
 472:	00 00                	add    %al,(%rax)
 474:	76 0a                	jbe    480 <balancer_ingress+0x480>
 476:	00 00                	add    %al,(%rax)
 478:	86 0a                	xchg   %cl,(%rdx)
 47a:	00 00                	add    %al,(%rax)
      pckt->flow.src = iph->saddr;
 47c:	8f 0a 00 00          	(bad)
 480:	9f                   	lahf
 481:	0a 00                	or     (%rax),%al
      pckt->flow.dst = iph->daddr;
 483:	00 37                	add    %dh,(%rdi)
 485:	03 00                	add    (%rax),%eax
 487:	00 b8 0a 00 00 be    	add    %bh,-0x41fffff6(%rax)
  if (icmp_hdr + 1 > data_end) {
 48d:	0a 00                	or     (%rax),%al
 48f:	00 f9                	add    %bh,%cl
 491:	07                   	(bad)
 492:	00 00                	add    %al,(%rax)
 494:	c2 0a 00             	ret    $0xa
 497:	00 c9                	add    %cl,%cl
 499:	0a 00                	or     (%rax),%al
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 49b:	00 6b 07             	add    %ch,0x7(%rbx)
 49e:	00 00                	add    %al,(%rax)
 4a0:	d4                   	(bad)
 4a1:	0a 00                	or     (%rax),%al
 4a3:	00 de                	add    %bl,%dh
 4a5:	0a 00                	or     (%rax),%al
 4a7:	00 e7                	add    %ah,%bh
 4a9:	0a 00                	or     (%rax),%al
 4ab:	00 ee                	add    %ch,%dh
 4ad:	0a 00                	or     (%rax),%al
 4af:	00 01                	add    %al,(%rcx)
 4b1:	06                   	(bad)
 4b2:	00 00                	add    %al,(%rax)
 4b4:	fc                   	cld
 4b5:	0a 00                	or     (%rax),%al
 4b7:	00 15 0b 00 00 60    	add    %dl,0x6000000b(%rip)        # 600004c8 <_license+0x5fffe42e>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 4bd:	0b 00                	or     (%rax),%eax
 4bf:	00 2d 0b 00 00 36    	add    %ch,0x3600000b(%rip)        # 360004d0 <_license+0x35ffe436>
       sizeof(struct icmp6hdr)) > data_end) {
 4c5:	0c 00                	or     $0x0,%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 4c7:	00 39                	add    %bh,(%rcx)
 4c9:	0b 00                	or     (%rax),%eax
 4cb:	00 42 0b             	add    %al,0xb(%rdx)
 4ce:	00 00                	add    %al,(%rax)
 4d0:	88 03                	mov    %al,(%rbx)
 4d2:	00 00                	add    %al,(%rax)
 4d4:	5b                   	pop    %rbx
 4d5:	0b 00                	or     (%rax),%eax
 4d7:	00 65 0b             	add    %ah,0xb(%rbp)
 4da:	00 00                	add    %al,(%rax)
 4dc:	70 0b                	jo     4e9 <balancer_ingress+0x4e9>
 4de:	00 00                	add    %al,(%rax)
 4e0:	7f 0b                	jg     4ed <balancer_ingress+0x4ed>
 4e2:	00 00                	add    %al,(%rax)
 4e4:	8d 0b                	lea    (%rbx),%ecx
 4e6:	00 00                	add    %al,(%rax)
 4e8:	9d                   	popf
 4e9:	0b 00                	or     (%rax),%eax
 4eb:	00 ba 0b 00 00 c2    	add    %bh,-0x3dfffff5(%rdx)
 4f1:	0b 00                	or     (%rax),%eax
  tcp = data + off;
 4f3:	00 d0                	add    %dl,%al
 4f5:	0b 00                	or     (%rax),%eax
  if (is_ipv6) {
 4f7:	00 de                	add    %bl,%dh
  tcp = data + off;
 4f9:	0b 00                	or     (%rax),%eax
 4fb:	00 e7                	add    %ah,%bh
  if (tcp + 1 > data_end) {
 4fd:	0b 00                	or     (%rax),%eax
 4ff:	00 ee                	add    %ch,%dh
 501:	0b 00                	or     (%rax),%eax
 503:	00 f6                	add    %dh,%dh
 505:	0b 00                	or     (%rax),%eax
 507:	00 fd                	add    %bh,%ch
 509:	0b 00                	or     (%rax),%eax
  if (tcp->syn) {
 50b:	00 74 0e 00          	add    %dh,0x0(%rsi,%rcx,1)
 50f:	00 06                	add    %al,(%rsi)
 511:	0c 00                	or     $0x0,%al
 513:	00 0d 0c 00 00 15    	add    %cl,0x1500000c(%rip)        # 15000525 <_license+0x14ffe48b>
    pckt->flags |= F_SYN_SET;
 519:	0c 00                	or     $0x0,%al
 51b:	00 23                	add    %ah,(%rbx)
 51d:	0c 00                	or     $0x0,%al
 51f:	00 32                	add    %dh,(%rdx)
 521:	0c 00                	or     $0x0,%al
 523:	00 73 0b             	add    %dh,0xb(%rbx)
 526:	00 00                	add    %al,(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
 528:	3e 0c 00             	ds or  $0x0,%al
 52b:	00 60 0c             	add    %ah,0xc(%rax)
 52e:	00 00                	add    %al,(%rax)
 530:	48 0c 00             	rex.W or $0x0,%al
 533:	00 55 0c             	add    %dl,0xc(%rbp)
 536:	00 00                	add    %al,(%rax)
    if (!icmp_ptb_v6_stats) {
 538:	65 0c 00             	gs or  $0x0,%al
 53b:	00 eb                	add    %ch,%bl
 53d:	09 00                	or     %eax,(%rax)
 53f:	00 74 0c 00          	add    %dh,0x0(%rsp,%rcx,1)
    icmp_ptb_v6_stats->v1 += 1;
 543:	00 38                	add    %bh,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 545:	00 00                	add    %al,(%rax)
 547:	00 76 0c             	add    %dh,0xc(%rsi)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 54a:	00 00                	add    %al,(%rax)
 54c:	7e 0c                	jle    55a <balancer_ingress+0x55a>
 54e:	00 00                	add    %al,(%rax)
 550:	8b 0c 00             	mov    (%rax,%rax,1),%ecx
      icmp_ptb_v6_stats->v2 += 1;
 553:	00 91 0c 00 00 96    	add    %dl,-0x69fffff4(%rcx)
  if (ip6h + 1 > data_end) {
 559:	0c 00                	or     $0x0,%al
 55b:	00 9c 0c 00 00 b6 0c 	add    %bl,0xcb60000(%rsp,%rcx,1)
 562:	00 00                	add    %al,(%rax)
  pckt->flow.proto = ip6h->nexthdr;
 564:	c8 0c 00 00          	enter  $0xc,$0x0
 568:	d6                   	(bad)
 569:	0c 00                	or     $0x0,%al
  pckt->flags |= F_ICMP;
 56b:	00 ef                	add    %ch,%bh
 56d:	0c 00                	or     $0x0,%al
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 56f:	00 f8                	add    %bh,%al
 571:	0c 00                	or     $0x0,%al
 573:	00 0e                	add    %cl,(%rsi)
 575:	0d 00 00 1c 0d       	or     $0xd1c0000,%eax
 57a:	00 00                	add    %al,(%rax)
 57c:	1f                   	(bad)
 57d:	0d 00 00 40 0d       	or     $0xd400000,%eax
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 582:	00 00                	add    %al,(%rax)
 584:	54                   	push   %rsp
 585:	0d 00 00 6e 0d       	or     $0xd6e0000,%eax
 58a:	00 00                	add    %al,(%rax)
 58c:	80 0d 00 00 93 0d 00 	orb    $0x0,0xd930000(%rip)        # d930593 <_license+0xd92e4f9>
 593:	00 a1 0d 00 00 ac    	add    %ah,-0x53fffff3(%rcx)
 599:	0d 00 00 b8 0d       	or     $0xdb80000,%eax
 59e:	00 00                	add    %al,(%rax)
 5a0:	c2 0d 00             	ret    $0xd
 5a3:	00 d0                	add    %dl,%al
 5a5:	0d 00 00 f3 0d       	or     $0xdf30000,%eax
 5aa:	00 00                	add    %al,(%rax)
 5ac:	f9                   	stc
 5ad:	0d 00 00 35 0a       	or     $0xa350000,%eax
 5b2:	00 00                	add    %al,(%rax)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 5b4:	00 0e                	add    %cl,(%rsi)
 5b6:	00 00                	add    %al,(%rax)
 5b8:	12 0e                	adc    (%rsi),%cl
 5ba:	00 00                	add    %al,(%rax)
 5bc:	24 0e                	and    $0xe,%al
 5be:	00 00                	add    %al,(%rax)
 5c0:	37                   	(bad)
 5c1:	0e                   	(bad)
 5c2:	00 00                	add    %al,(%rax)
 5c4:	4a 0e                	rex.WX (bad)
 5c6:	00 00                	add    %al,(%rax)
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
 5c8:	5d                   	pop    %rbp
 5c9:	0e                   	(bad)
 5ca:	00 00                	add    %al,(%rax)
 5cc:	6e                   	outsb  %ds:(%rsi),(%dx)
 5cd:	0e                   	(bad)
 5ce:	00 00                	add    %al,(%rax)
 5d0:	11 0c 00             	adc    %ecx,(%rax,%rax,1)
 5d3:	00 72 0e             	add    %dh,0xe(%rdx)
	...

Disassembly of section .debug_str:

0000000000000000 <.debug_str>:
  void* data = (void*)(long)ctx->data;
   0:	44                   	rex.R
   1:	65 62                	gs (bad)
   3:	69 61 6e 20 63 6c 61 	imul   $0x616c6320,0x6e(%rcx),%esp
   a:	6e                   	outsb  %ds:(%rsi),(%dx)
   b:	67 20 76 65          	and    %dh,0x65(%esi)
   f:	72 73                	jb     84 <balancer_ingress+0x84>
  11:	69 6f 6e 20 31 34 2e 	imul   $0x2e343120,0x6e(%rdi),%ebp
  void* data_end = (void*)(long)ctx->data_end;
  18:	30 2e                	xor    %ch,(%rsi)
  1a:	36 00 6b 61          	ss add %ch,0x61(%rbx)
  if (data + nh_off > data_end) {
  1e:	74 72                	je     92 <balancer_ingress+0x92>
  20:	61                   	(bad)
  21:	6e                   	outsb  %ds:(%rsi),(%dx)
  22:	2f                   	(bad)
  23:	6c                   	insb   (%dx),%es:(%rdi)
  24:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
  2b:	62 61 6c 61 6e       	(bad)
  30:	63 65 72             	movsxd 0x72(%rbp),%esp
  eth_proto = eth->h_proto;
  33:	2e 62                	cs (bad)
  if (eth_proto == BE_ETH_P_IP) {
  35:	70 66                	jo     9d <balancer_ingress+0x9d>
  37:	2e 63 00             	cs movsxd (%rax),%eax
  3a:	2f                   	(bad)
  3b:	72 6f                	jb     ac <balancer_ingress+0xac>
  3d:	6f                   	outsl  %ds:(%rsi),(%dx)
  3e:	74 2f                	je     6f <balancer_ingress+0x6f>
  40:	57                   	push   %rdi
  41:	6f                   	outsl  %ds:(%rsi),(%dx)
  42:	72 6b                	jb     af <balancer_ingress+0xaf>
  44:	73 70                	jae    b6 <balancer_ingress+0xb6>
  46:	61                   	(bad)
  47:	63 65 2f             	movsxd 0x2f(%rbp),%esp
  4a:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  struct packet_description pckt = {};
  4e:	61                   	(bad)
  4f:	6e                   	outsb  %ds:(%rsi),(%dx)
  50:	2f                   	(bad)
  51:	5f                   	pop    %rdi
  52:	62 75                	(bad)
  54:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
  5b:	73 
  5c:	2f                   	(bad)
  5d:	62                   	(bad)
  5e:	70 66                	jo     c6 <balancer_ingress+0xc6>
  60:	70 72                	jo     d4 <balancer_ingress+0xd4>
  62:	6f                   	outsl  %ds:(%rsi),(%dx)
  63:	67 00 5f 6c          	add    %bl,0x6c(%edi)
  67:	69 63 65 6e 73 65 00 	imul   $0x65736e,0x65(%rbx),%esp
  6e:	5f                   	pop    %rdi
  6f:	5f                   	pop    %rdi
  70:	41 52                	push   %r10
  72:	52                   	push   %rdx
  73:	41 59                	pop    %r9
  75:	5f                   	pop    %rdi
  76:	53                   	push   %rbx
  77:	49 5a                	rex.WB pop %r10
  79:	45 5f                	rex.RB pop %r15
  7b:	54                   	push   %rsp
  7c:	59                   	pop    %rcx
  7d:	50                   	push   %rax
  7e:	45 5f                	rex.RB pop %r15
  80:	5f                   	pop    %rdi
  81:	00 63 74             	add    %ah,0x74(%rbx)
  84:	6c                   	insb   (%dx),%es:(%rdi)
  85:	5f                   	pop    %rdi
  86:	61                   	(bad)
  87:	72 72                	jb     fb <balancer_ingress+0xfb>
  89:	61                   	(bad)
  8a:	79 00                	jns    8c <balancer_ingress+0x8c>
  bpf_tail_call(xdp, &subprograms, 0);
  8c:	75 6e                	jne    fc <balancer_ingress+0xfc>
  8e:	73 69                	jae    f9 <balancer_ingress+0xf9>
  90:	67 6e                	outsb  %ds:(%esi),(%dx)
  92:	65 64 20 69 6e       	gs and %ch,%fs:0x6e(%rcx)
  97:	74 00                	je     99 <balancer_ingress+0x99>
  99:	5f                   	pop    %rdi
  9a:	5f                   	pop    %rdi
  9b:	75 33                	jne    d0 <balancer_ingress+0xd0>
  9d:	32 00                	xor    (%rax),%al
  9f:	75 6e                	jne    10f <balancer_ingress+0x10f>
  a1:	73 69                	jae    10c <balancer_ingress+0x10c>
  a3:	67 6e                	outsb  %ds:(%esi),(%dx)
  struct packet_description pckt = {};
  a5:	65 64 20 6c 6f 6e    	gs and %ch,%fs:0x6e(%rdi,%rbp,2)
  ab:	67 20 6c 6f 6e       	and    %ch,0x6e(%edi,%ebp,2)
  b0:	67 00 5f 5f          	add    %bl,0x5f(%edi)
  b4:	75 36                	jne    ec <balancer_ingress+0xec>
  b6:	34 00                	xor    $0x0,%al
  b8:	69 66 69 6e 64 65 78 	imul   $0x7865646e,0x69(%rsi),%esp
  bf:	00 6d 61             	add    %ch,0x61(%rbp)
  c2:	63 00                	movsxd (%rax),%eax
  c4:	75 6e                	jne    134 <balancer_ingress+0x134>
  c6:	73 69                	jae    131 <balancer_ingress+0x131>
  c8:	67 6e                	outsb  %ds:(%esi),(%dx)
  ca:	65 64 20 63 68       	gs and %ah,%fs:0x68(%rbx)
  cf:	61                   	(bad)
  d0:	72 00                	jb     d2 <balancer_ingress+0xd2>
  d2:	5f                   	pop    %rdi
  d3:	5f                   	pop    %rdi
  d4:	75 38                	jne    10e <balancer_ingress+0x10e>
  d6:	00 63 74             	add    %ah,0x74(%rbx)
  d9:	6c                   	insb   (%dx),%es:(%rdi)
  da:	5f                   	pop    %rdi
  db:	76 61                	jbe    13e <balancer_ingress+0x13e>
  dd:	6c                   	insb   (%dx),%es:(%rdi)
  de:	75 65                	jne    145 <balancer_ingress+0x145>
  e0:	00 6d 61             	add    %ch,0x61(%rbp)
  e3:	78 5f                	js     144 <balancer_ingress+0x144>
  bpf_tail_call(xdp, &subprograms, 0);
  e5:	65 6e                	outsb  %gs:(%rsi),(%dx)
  e7:	74 72                	je     15b <balancer_ingress+0x15b>
  e9:	69 65 73 00 6d 61 70 	imul   $0x70616d00,0x73(%rbp),%esp
  f0:	5f                   	pop    %rdi
  f1:	66 6c                	data16 insb (%dx),%es:(%rdi)
  f3:	61                   	(bad)
  f4:	67 73 00             	addr32 jae f7 <balancer_ingress+0xf7>
  f7:	5f                   	pop    %rdi
  f8:	5f                   	pop    %rdi
  f9:	62 65                	(bad)
  fb:	33 32                	xor    (%rdx),%esi
  fd:	00 61 64             	add    %ah,0x64(%rcx)
 100:	64 72 76             	fs jb  179 <balancer_ingress+0x179>
  struct vip_definition vip = {};
 103:	36 00 61 64          	ss add %ah,0x64(%rcx)
 107:	64 72 65             	fs jb  16f <balancer_ingress+0x16f>
 10a:	73 73                	jae    17f <balancer_ingress+0x17f>
 10c:	00 73 75             	add    %dh,0x75(%rbx)
 10f:	62                   	(bad)
 110:	70 72                	jo     184 <balancer_ingress+0x184>
 112:	6f                   	outsl  %ds:(%rsi),(%dx)
 113:	67 72 61             	addr32 jb 177 <balancer_ingress+0x177>
 116:	6d                   	insl   (%dx),%es:(%rdi)
 117:	73 00                	jae    119 <balancer_ingress+0x119>
 119:	76 69                	jbe    184 <balancer_ingress+0x184>
 11b:	70 5f                	jo     17c <balancer_ingress+0x17c>
    if (iph + 1 > data_end) {
 11d:	6d                   	insl   (%dx),%es:(%rdi)
 11e:	61                   	(bad)
 11f:	70 00                	jo     121 <balancer_ingress+0x121>
 121:	76 69                	jbe    18c <balancer_ingress+0x18c>
 123:	70 76                	jo     19b <balancer_ingress+0x19b>
 125:	36 00 75 6e          	ss add %dh,0x6e(%rbp)
    if (iph->ihl != 5) {
 129:	73 69                	jae    194 <balancer_ingress+0x194>
 12b:	67 6e                	outsb  %ds:(%esi),(%dx)
 12d:	65 64 20 73 68       	gs and %dh,%fs:0x68(%rbx)
 132:	6f                   	outsl  %ds:(%rsi),(%dx)
 133:	72 74                	jb     1a9 <balancer_ingress+0x1a9>
    pckt->tos = iph->tos;
 135:	00 5f 5f             	add    %bl,0x5f(%rdi)
 138:	75 31                	jne    16b <balancer_ingress+0x16b>
 13a:	36 00 76 69          	ss add %dh,0x69(%rsi)
    *protocol = iph->protocol;
 13e:	70 5f                	jo     19f <balancer_ingress+0x19f>
    pckt->flow.proto = *protocol;
 140:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
 147:	69 
    if (iph->frag_off & PCKT_FRAGMENTED) {
 148:	6f                   	outsl  %ds:(%rsi),(%dx)
 149:	6e                   	outsb  %ds:(%rsi),(%dx)
 14a:	00 76 69             	add    %dh,0x69(%rsi)
 14d:	70 5f                	jo     1ae <balancer_ingress+0x1ae>
 14f:	6e                   	outsb  %ds:(%rsi),(%dx)
 150:	75 6d                	jne    1bf <balancer_ingress+0x1bf>
 152:	00 76 69             	add    %dh,0x69(%rsi)
 155:	70 5f                	jo     1b6 <balancer_ingress+0x1b6>
    if (*protocol == IPPROTO_ICMP) {
 157:	6d                   	insl   (%dx),%es:(%rdi)
 158:	65 74 61             	gs je  1bc <balancer_ingress+0x1bc>
 15b:	00 66 61             	add    %ah,0x61(%rsi)
 15e:	6c                   	insb   (%dx),%es:(%rdi)
  if (icmp_hdr + 1 > data_end) {
 15f:	6c                   	insb   (%dx),%es:(%rdi)
 160:	62 61                	(bad)
 162:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 165:	63 61 63             	movsxd 0x63(%rcx),%esp
 168:	68 65 00 73 72       	push   $0x72730065
  if (icmp_hdr->type == ICMP_ECHO) {
 16d:	63 76 36             	movsxd 0x36(%rsi),%esi
 170:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 174:	76 36                	jbe    1ac <balancer_ingress+0x1ac>
 176:	00 70 6f             	add    %dh,0x6f(%rax)
 179:	72 74                	jb     1ef <balancer_ingress+0x1ef>
 17b:	73 00                	jae    17d <balancer_ingress+0x17d>
 17d:	70 6f                	jo     1ee <balancer_ingress+0x1ee>
 17f:	72 74                	jb     1f5 <balancer_ingress+0x1f5>
 181:	31 36                	xor    %esi,(%rsi)
 183:	00 66 6c             	add    %ah,0x6c(%rsi)
 186:	6f                   	outsl  %ds:(%rsi),(%dx)
 187:	77 5f                	ja     1e8 <balancer_ingress+0x1e8>
 189:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
  icmp_hdr->type = ICMP_ECHOREPLY;
 18d:	61                   	(bad)
 18e:	74 69                	je     1f9 <balancer_ingress+0x1f9>
  icmp_hdr->checksum += 0x0008;
 190:	6d                   	insl   (%dx),%es:(%rdi)
 191:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
  iph->ttl = DEFAULT_TTL;
 195:	61                   	(bad)
 196:	6c                   	insb   (%dx),%es:(%rdi)
 197:	5f                   	pop    %rdi
  iph->daddr = iph->saddr;
 198:	70 6f                	jo     209 <balancer_ingress+0x209>
 19a:	73 5f                	jae    1fb <balancer_ingress+0x1fb>
  tmp_addr = iph->daddr;
 19c:	6c                   	insb   (%dx),%es:(%rdi)
 19d:	72 75                	jb     214 <balancer_ingress+0x214>
  iph->daddr = iph->saddr;
 19f:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
  iph->saddr = tmp_addr;
 1a3:	5f                   	pop    %rdi
 1a4:	6d                   	insl   (%dx),%es:(%rdi)
 1a5:	61                   	(bad)
 1a6:	70 70                	jo     218 <balancer_ingress+0x218>
 1a8:	69 6e 67 00 76 61 6c 	imul   $0x6c617600,0x67(%rsi),%ebp
 1af:	75 65                	jne    216 <balancer_ingress+0x216>
 1b1:	73 00                	jae    1b3 <balancer_ingress+0x1b3>
 1b3:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 1b6:	72 69                	jb     221 <balancer_ingress+0x221>
 1b8:	6e                   	outsb  %ds:(%rsi),(%dx)
 1b9:	67 73 00             	addr32 jae 1bc <balancer_ingress+0x1bc>
 1bc:	72 65                	jb     223 <balancer_ingress+0x223>
 1be:	61                   	(bad)
 1bf:	6c                   	insb   (%dx),%es:(%rdi)
 1c0:	73 00                	jae    1c2 <balancer_ingress+0x1c2>
 1c2:	72 65                	jb     229 <balancer_ingress+0x229>
 1c4:	61                   	(bad)
 1c5:	6c                   	insb   (%dx),%es:(%rdi)
 1c6:	5f                   	pop    %rdi
 1c7:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
 1ce:	69 
 1cf:	6f                   	outsl  %ds:(%rsi),(%dx)
 1d0:	6e                   	outsb  %ds:(%rsi),(%dx)
 1d1:	00 72 65             	add    %dh,0x65(%rdx)
 1d4:	61                   	(bad)
 1d5:	6c                   	insb   (%dx),%es:(%rdi)
 1d6:	73 5f                	jae    237 <balancer_ingress+0x237>
 1d8:	73 74                	jae    24e <balancer_ingress+0x24e>
 1da:	61                   	(bad)
 1db:	74 73                	je     250 <balancer_ingress+0x250>
 1dd:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 1e1:	73 74                	jae    257 <balancer_ingress+0x257>
 1e3:	61                   	(bad)
 1e4:	74 73                	je     259 <balancer_ingress+0x259>
 1e6:	00 76 69             	add    %dh,0x69(%rsi)
 1e9:	70 5f                	jo     24a <balancer_ingress+0x24a>
 1eb:	6d                   	insl   (%dx),%es:(%rdi)
 1ec:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 1f3:	74 73                	je     268 <balancer_ingress+0x268>
 1f5:	00 71 75             	add    %dh,0x75(%rcx)
    if (ip6h + 1 > data_end) {
 1f8:	69 63 5f 73 74 61 74 	imul   $0x74617473,0x5f(%rbx),%esp
 1ff:	73 5f                	jae    260 <balancer_ingress+0x260>
 201:	6d                   	insl   (%dx),%es:(%rdi)
 202:	61                   	(bad)
    *protocol = ip6h->nexthdr;
 203:	70 00                	jo     205 <balancer_ingress+0x205>
 205:	63 68 5f             	movsxd 0x5f(%rax),%ebp
    pckt->flow.proto = *protocol;
 208:	72 6f                	jb     279 <balancer_ingress+0x279>
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 20a:	75 74                	jne    280 <balancer_ingress+0x280>
 20c:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 211:	64 5f                	fs pop %rdi
 213:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 21a:	00 63 69             	add    %ah,0x69(%rbx)
 21d:	64 5f                	fs pop %rdi
 21f:	69 6e 76 61 6c 69 64 	imul   $0x64696c61,0x76(%rsi),%ebp
    if (*protocol == IPPROTO_FRAGMENT) {
 226:	5f                   	pop    %rdi
 227:	73 65                	jae    28e <balancer_ingress+0x28e>
 229:	72 76                	jb     2a1 <balancer_ingress+0x2a1>
 22b:	65 72 5f             	gs jb  28d <balancer_ingress+0x28d>
 22e:	69 64 00 63 69 64 5f 	imul   $0x695f6469,0x63(%rax,%rax,1),%esp
 235:	69 
  if (icmp_hdr + 1 > data_end) {
 236:	6e                   	outsb  %ds:(%rsi),(%dx)
 237:	76 61                	jbe    29a <balancer_ingress+0x29a>
 239:	6c                   	insb   (%dx),%es:(%rdi)
 23a:	69 64 5f 73 65 72 76 	imul   $0x65767265,0x73(%rdi,%rbx,2),%esp
 241:	65 
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 242:	72 5f                	jb     2a3 <balancer_ingress+0x2a3>
 244:	69 64 5f 73 61 6d 70 	imul   $0x6c706d61,0x73(%rdi,%rbx,2),%esp
 24b:	6c 
 24c:	65 00 63 69          	add    %ah,%gs:0x69(%rbx)
 250:	64 5f                	fs pop %rdi
 252:	72 6f                	jb     2c3 <balancer_ingress+0x2c3>
 254:	75 74                	jne    2ca <balancer_ingress+0x2ca>
 256:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 25b:	64 5f                	fs pop %rdi
 25d:	75 6e                	jne    2cd <balancer_ingress+0x2cd>
 25f:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
 263:	6e                   	outsb  %ds:(%rsi),(%dx)
 264:	5f                   	pop    %rdi
 265:	72 65                	jb     2cc <balancer_ingress+0x2cc>
 267:	61                   	(bad)
 268:	6c                   	insb   (%dx),%es:(%rdi)
 269:	5f                   	pop    %rdi
 26a:	64 72 6f             	fs jb  2dc <balancer_ingress+0x2dc>
 26d:	70 70                	jo     2df <balancer_ingress+0x2df>
 26f:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 274:	64 5f                	fs pop %rdi
 276:	76 30                	jbe    2a8 <balancer_ingress+0x2a8>
 278:	00 63 69             	add    %ah,0x69(%rbx)
 27b:	64 5f                	fs pop %rdi
 27d:	76 31                	jbe    2b0 <balancer_ingress+0x2b0>
 27f:	00 63 69             	add    %ah,0x69(%rbx)
 282:	64 5f                	fs pop %rdi
 284:	76 32                	jbe    2b8 <balancer_ingress+0x2b8>
 286:	00 63 69             	add    %ah,0x69(%rbx)
 289:	64 5f                	fs pop %rdi
 28b:	76 33                	jbe    2c0 <balancer_ingress+0x2c0>
 28d:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 291:	5f                   	pop    %rdi
 292:	6d                   	insl   (%dx),%es:(%rdi)
 293:	61                   	(bad)
 294:	74 63                	je     2f9 <balancer_ingress+0x2f9>
 296:	68 5f 69 6e 5f       	push   $0x5f6e695f
 29b:	6c                   	insb   (%dx),%es:(%rdi)
 29c:	72 75                	jb     313 <balancer_ingress+0x313>
 29e:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 2a2:	5f                   	pop    %rdi
 2a3:	6d                   	insl   (%dx),%es:(%rdi)
 2a4:	69 73 6d 61 74 63 68 	imul   $0x68637461,0x6d(%rbx),%esi
 2ab:	5f                   	pop    %rdi
 2ac:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
 2b3:	64 73 74             	fs jae 32a <balancer_ingress+0x32a>
 2b6:	5f                   	pop    %rdi
 2b7:	6e                   	outsb  %ds:(%rsi),(%dx)
 2b8:	6f                   	outsl  %ds:(%rsi),(%dx)
 2b9:	74 5f                	je     31a <balancer_ingress+0x31a>
 2bb:	66 6f                	outsw  %ds:(%rsi),(%dx)
 2bd:	75 6e                	jne    32d <balancer_ingress+0x32d>
 2bf:	64 5f                	fs pop %rdi
 2c1:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
 2c8:	6c                   	insb   (%dx),%es:(%rdi)
 2c9:	62                   	(bad)
 2ca:	5f                   	pop    %rdi
 2cb:	71 75                	jno    342 <balancer_ingress+0x342>
 2cd:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
 2d4:	65 74 73             	gs je  34a <balancer_ingress+0x34a>
 2d7:	5f                   	pop    %rdi
 2d8:	73 74                	jae    34e <balancer_ingress+0x34e>
 2da:	61                   	(bad)
 2db:	74 73                	je     350 <balancer_ingress+0x350>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2dd:	00 73 74             	add    %dh,0x74(%rbx)
 2e0:	61                   	(bad)
 2e1:	62                   	(bad)
 2e2:	6c                   	insb   (%dx),%es:(%rdi)
 2e3:	65 5f                	gs pop %rdi
 2e5:	72 74                	jb     35b <balancer_ingress+0x35b>
 2e7:	5f                   	pop    %rdi
 2e8:	73 74                	jae    35e <balancer_ingress+0x35e>
 2ea:	61                   	(bad)
 2eb:	74 73                	je     360 <balancer_ingress+0x360>
 2ed:	00 69 6e             	add    %ch,0x6e(%rcx)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2f0:	76 61                	jbe    353 <balancer_ingress+0x353>
 2f2:	6c                   	insb   (%dx),%es:(%rdi)
 2f3:	69 64 5f 70 61 63 6b 	imul   $0x656b6361,0x70(%rdi,%rbx,2),%esp
 2fa:	65 
 2fb:	74 5f                	je     35c <balancer_ingress+0x35c>
 2fd:	74 79                	je     378 <balancer_ingress+0x378>
 2ff:	70 65                	jo     366 <balancer_ingress+0x366>
  if (protocol == IPPROTO_ICMPV6) {
 301:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 305:	73 74                	jae    37b <balancer_ingress+0x37b>
 307:	61                   	(bad)
  if (icmp_hdr + 1 > data_end) {
 308:	62                   	(bad)
 309:	6c                   	insb   (%dx),%es:(%rdi)
 30a:	65 5f                	gs pop %rdi
 30c:	72 74                	jb     382 <balancer_ingress+0x382>
 30e:	5f                   	pop    %rdi
 30f:	70 61                	jo     372 <balancer_ingress+0x372>
 311:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 314:	74 73                	je     389 <balancer_ingress+0x389>
  if (icmp_hdr->type == ICMP_ECHO) {
 316:	5f                   	pop    %rdi
 317:	73 74                	jae    38d <balancer_ingress+0x38d>
 319:	61                   	(bad)
 31a:	74 73                	je     38f <balancer_ingress+0x38f>
 31c:	00 64 65 63          	add    %ah,0x63(%rbp,%riz,2)
 320:	61                   	(bad)
 321:	70 5f                	jo     382 <balancer_ingress+0x382>
 323:	76 69                	jbe    38e <balancer_ingress+0x38e>
 325:	70 5f                	jo     386 <balancer_ingress+0x386>
 327:	73 74                	jae    39d <balancer_ingress+0x39d>
 329:	61                   	(bad)
 32a:	74 73                	je     39f <balancer_ingress+0x39f>
 32c:	00 73 65             	add    %dh,0x65(%rbx)
 32f:	72 76                	jb     3a7 <balancer_ingress+0x3a7>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 331:	65 72 5f             	gs jb  393 <balancer_ingress+0x393>
 334:	69 64 5f 6d 61 70 00 	imul   $0x74007061,0x6d(%rdi,%rbx,2),%esp
 33b:	74 
 33c:	70 72                	jo     3b0 <balancer_ingress+0x3b0>
 33e:	5f                   	pop    %rdi
 33f:	73 74                	jae    3b5 <balancer_ingress+0x3b5>
 341:	61                   	(bad)
  icmp_hdr->type = ICMP_ECHOREPLY;
 342:	74 73                	je     3b7 <balancer_ingress+0x3b7>
 344:	5f                   	pop    %rdi
 345:	6d                   	insl   (%dx),%es:(%rdi)
  icmp_hdr->checksum += 0x0008;
 346:	61                   	(bad)
 347:	70 00                	jo     349 <balancer_ingress+0x349>
 349:	73 69                	jae    3b4 <balancer_ingress+0x3b4>
  iph->ttl = DEFAULT_TTL;
 34b:	64 5f                	fs pop %rdi
 34d:	72 6f                	jb     3be <balancer_ingress+0x3be>
  iph->daddr = iph->saddr;
 34f:	75 74                	jne    3c5 <balancer_ingress+0x3c5>
 351:	65 64 00 74 63 70    	gs add %dh,%fs:0x70(%rbx,%riz,2)
 357:	5f                   	pop    %rdi
  iph->saddr = tmp_addr;
 358:	73 79                	jae    3d3 <balancer_ingress+0x3d3>
 35a:	6e                   	outsb  %ds:(%rsi),(%dx)
 35b:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 35f:	74 70                	je     3d1 <balancer_ingress+0x3d1>
 361:	72 5f                	jb     3c2 <balancer_ingress+0x3c2>
 363:	70 61                	jo     3c6 <balancer_ingress+0x3c6>
 365:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 368:	74 73                	je     3dd <balancer_ingress+0x3dd>
 36a:	5f                   	pop    %rdi
 36b:	73 74                	jae    3e1 <balancer_ingress+0x3e1>
 36d:	61                   	(bad)
 36e:	74 73                	je     3e3 <balancer_ingress+0x3e3>
 370:	00 73 65             	add    %dh,0x65(%rbx)
 373:	72 76                	jb     3eb <balancer_ingress+0x3eb>
 375:	65 72 5f             	gs jb  3d7 <balancer_ingress+0x3d7>
 378:	69 64 5f 73 74 61 74 	imul   $0x73746174,0x73(%rdi,%rbx,2),%esp
 37f:	73 
 380:	00 76 69             	add    %dh,0x69(%rsi)
 383:	70 5f                	jo     3e4 <balancer_ingress+0x3e4>
 385:	74 6f                	je     3f6 <balancer_ingress+0x3f6>
 387:	5f                   	pop    %rdi
 388:	64 6f                	outsl  %fs:(%rsi),(%dx)
 38a:	77 6e                	ja     3fa <balancer_ingress+0x3fa>
 38c:	5f                   	pop    %rdi
 38d:	72 65                	jb     3f4 <balancer_ingress+0x3f4>
 38f:	61                   	(bad)
 390:	6c                   	insb   (%dx),%es:(%rdi)
 391:	73 5f                	jae    3f2 <balancer_ingress+0x3f2>
 393:	6d                   	insl   (%dx),%es:(%rdi)
 394:	61                   	(bad)
 395:	70 00                	jo     397 <balancer_ingress+0x397>
 397:	62                   	(bad)
 398:	70 66                	jo     400 <balancer_ingress+0x400>
 39a:	5f                   	pop    %rdi
 39b:	6b 74 69 6d 65       	imul   $0x65,0x6d(%rcx,%rbp,2),%esi
 3a0:	5f                   	pop    %rdi
 3a1:	67 65 74 5f          	addr32 gs je 404 <balancer_ingress+0x404>
 3a5:	6e                   	outsb  %ds:(%rsi),(%dx)
 3a6:	73 00                	jae    3a8 <balancer_ingress+0x3a8>
 3a8:	62                   	(bad)
 3a9:	70 66                	jo     411 <balancer_ingress+0x411>
 3ab:	5f                   	pop    %rdi
 3ac:	78 64                	js     412 <balancer_ingress+0x412>
 3ae:	70 5f                	jo     40f <balancer_ingress+0x40f>
 3b0:	61                   	(bad)
 3b1:	64 6a 75             	fs push $0x75
 3b4:	73 74                	jae    42a <balancer_ingress+0x42a>
 3b6:	5f                   	pop    %rdi
 3b7:	68 65 61 64 00       	push   $0x646165
 3bc:	58                   	pop    %rax
 3bd:	44 50                	rex.R push %rax
 3bf:	5f                   	pop    %rdi
 3c0:	41                   	rex.B
 3c1:	42                   	rex.X
 3c2:	4f 52                	rex.WRXB push %r10
 3c4:	54                   	push   %rsp
 3c5:	45                   	rex.RB
 3c6:	44 00 58 44          	add    %r11b,0x44(%rax)
 3ca:	50                   	push   %rax
 3cb:	5f                   	pop    %rdi
 3cc:	44 52                	rex.R push %rdx
 3ce:	4f 50                	rex.WRXB push %r8
 3d0:	00 58 44             	add    %bl,0x44(%rax)
 3d3:	50                   	push   %rax
 3d4:	5f                   	pop    %rdi
 3d5:	50                   	push   %rax
 3d6:	41 53                	push   %r11
 3d8:	53                   	push   %rbx
 3d9:	00 58 44             	add    %bl,0x44(%rax)
 3dc:	50                   	push   %rax
 3dd:	5f                   	pop    %rdi
 3de:	54                   	push   %rsp
 3df:	58                   	pop    %rax
 3e0:	00 58 44             	add    %bl,0x44(%rax)
 3e3:	50                   	push   %rax
 3e4:	5f                   	pop    %rdi
 3e5:	52                   	push   %rdx
 3e6:	45                   	rex.RB
 3e7:	44                   	rex.R
 3e8:	49 52                	rex.WB push %r10
 3ea:	45                   	rex.RB
 3eb:	43 54                	rex.XB push %r12
 3ed:	00 78 64             	add    %bh,0x64(%rax)
 3f0:	70 5f                	jo     451 <balancer_ingress+0x451>
 3f2:	61                   	(bad)
 3f3:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
 3f7:	6e                   	outsb  %ds:(%rsi),(%dx)
 3f8:	00 49 50             	add    %cl,0x50(%rcx)
 3fb:	50                   	push   %rax
 3fc:	52                   	push   %rdx
 3fd:	4f 54                	rex.WRXB push %r12
 3ff:	4f 5f                	rex.WRXB pop %r15
 401:	49 50                	rex.WB push %r8
 403:	00 49 50             	add    %cl,0x50(%rcx)
 406:	50                   	push   %rax
 407:	52                   	push   %rdx
 408:	4f 54                	rex.WRXB push %r12
 40a:	4f 5f                	rex.WRXB pop %r15
 40c:	49                   	rex.WB
 40d:	43                   	rex.XB
 40e:	4d 50                	rex.WRB push %r8
 410:	00 49 50             	add    %cl,0x50(%rcx)
 413:	50                   	push   %rax
 414:	52                   	push   %rdx
 415:	4f 54                	rex.WRXB push %r12
 417:	4f 5f                	rex.WRXB pop %r15
 419:	49                   	rex.WB
 41a:	47                   	rex.RXB
 41b:	4d 50                	rex.WRB push %r8
 41d:	00 49 50             	add    %cl,0x50(%rcx)
 420:	50                   	push   %rax
 421:	52                   	push   %rdx
 422:	4f 54                	rex.WRXB push %r12
 424:	4f 5f                	rex.WRXB pop %r15
 426:	49 50                	rex.WB push %r8
 428:	49 50                	rex.WB push %r8
 42a:	00 49 50             	add    %cl,0x50(%rcx)
 42d:	50                   	push   %rax
 42e:	52                   	push   %rdx
 42f:	4f 54                	rex.WRXB push %r12
 431:	4f 5f                	rex.WRXB pop %r15
 433:	54                   	push   %rsp
 434:	43 50                	rex.XB push %r8
 436:	00 49 50             	add    %cl,0x50(%rcx)
  if (protocol == IPPROTO_IPIP) {
 439:	50                   	push   %rax
 43a:	52                   	push   %rdx
 43b:	4f 54                	rex.WRXB push %r12
 43d:	4f 5f                	rex.WRXB pop %r15
 43f:	45                   	rex.RB
 440:	47 50                	rex.RXB push %r8
 442:	00 49 50             	add    %cl,0x50(%rcx)
 445:	50                   	push   %rax
 446:	52                   	push   %rdx
 447:	4f 54                	rex.WRXB push %r12
 449:	4f 5f                	rex.WRXB pop %r15
 44b:	50                   	push   %rax
 44c:	55                   	push   %rbp
 44d:	50                   	push   %rax
 44e:	00 49 50             	add    %cl,0x50(%rcx)
  tcp = data + off;
 451:	50                   	push   %rax
 452:	52                   	push   %rdx
 453:	4f 54                	rex.WRXB push %r12
  if (is_ipv6) {
 455:	4f 5f                	rex.WRXB pop %r15
  tcp = data + off;
 457:	55                   	push   %rbp
 458:	44 50                	rex.R push %rax
 45a:	00 49 50             	add    %cl,0x50(%rcx)
  if (tcp + 1 > data_end) {
 45d:	50                   	push   %rax
 45e:	52                   	push   %rdx
 45f:	4f 54                	rex.WRXB push %r12
 461:	4f 5f                	rex.WRXB pop %r15
 463:	49                   	rex.WB
 464:	44 50                	rex.R push %rax
 466:	00 49 50             	add    %cl,0x50(%rcx)
  if (tcp->syn) {
 469:	50                   	push   %rax
 46a:	52                   	push   %rdx
 46b:	4f 54                	rex.WRXB push %r12
 46d:	4f 5f                	rex.WRXB pop %r15
 46f:	54                   	push   %rsp
 470:	50                   	push   %rax
 471:	00 49 50             	add    %cl,0x50(%rcx)
    pckt->flags |= F_SYN_SET;
 474:	50                   	push   %rax
 475:	52                   	push   %rdx
 476:	4f 54                	rex.WRXB push %r12
 478:	4f 5f                	rex.WRXB pop %r15
 47a:	44                   	rex.R
      pckt->flow.src = iph->saddr;
 47b:	43                   	rex.XB
 47c:	43 50                	rex.XB push %r8
 47e:	00 49 50             	add    %cl,0x50(%rcx)
 481:	50                   	push   %rax
      pckt->flow.dst = iph->daddr;
 482:	52                   	push   %rdx
 483:	4f 54                	rex.WRXB push %r12
 485:	4f 5f                	rex.WRXB pop %r15
 487:	49 50                	rex.WB push %r8
  if (protocol == IPPROTO_ICMPV6) {
 489:	56                   	push   %rsi
 48a:	36 00 49 50          	ss add %cl,0x50(%rcx)
  if (icmp_hdr + 1 > data_end) {
 48e:	50                   	push   %rax
 48f:	52                   	push   %rdx
 490:	4f 54                	rex.WRXB push %r12
 492:	4f 5f                	rex.WRXB pop %r15
 494:	52                   	push   %rdx
 495:	53                   	push   %rbx
 496:	56                   	push   %rsi
 497:	50                   	push   %rax
 498:	00 49 50             	add    %cl,0x50(%rcx)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 49b:	50                   	push   %rax
 49c:	52                   	push   %rdx
 49d:	4f 54                	rex.WRXB push %r12
 49f:	4f 5f                	rex.WRXB pop %r15
 4a1:	47 52                	rex.RXB push %r10
 4a3:	45 00 49 50          	add    %r9b,0x50(%r9)
 4a7:	50                   	push   %rax
 4a8:	52                   	push   %rdx
 4a9:	4f 54                	rex.WRXB push %r12
 4ab:	4f 5f                	rex.WRXB pop %r15
 4ad:	45 53                	rex.RB push %r11
 4af:	50                   	push   %rax
 4b0:	00 49 50             	add    %cl,0x50(%rcx)
 4b3:	50                   	push   %rax
 4b4:	52                   	push   %rdx
 4b5:	4f 54                	rex.WRXB push %r12
 4b7:	4f 5f                	rex.WRXB pop %r15
 4b9:	41                   	rex.B
 4ba:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 4be:	50                   	push   %rax
 4bf:	52                   	push   %rdx
 4c0:	4f 54                	rex.WRXB push %r12
 4c2:	4f 5f                	rex.WRXB pop %r15
       sizeof(struct icmp6hdr)) > data_end) {
 4c4:	4d 54                	rex.WRB push %r12
 4c6:	50                   	push   %rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 4c7:	00 49 50             	add    %cl,0x50(%rcx)
 4ca:	50                   	push   %rax
 4cb:	52                   	push   %rdx
 4cc:	4f 54                	rex.WRXB push %r12
 4ce:	4f 5f                	rex.WRXB pop %r15
 4d0:	42                   	rex.X
 4d1:	45                   	rex.RB
 4d2:	45 54                	rex.RB push %r12
 4d4:	50                   	push   %rax
 4d5:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
 4d9:	50                   	push   %rax
 4da:	52                   	push   %rdx
 4db:	4f 54                	rex.WRXB push %r12
 4dd:	4f 5f                	rex.WRXB pop %r15
 4df:	45                   	rex.RB
 4e0:	4e                   	rex.WRX
 4e1:	43                   	rex.XB
 4e2:	41 50                	push   %r8
 4e4:	00 49 50             	add    %cl,0x50(%rcx)
 4e7:	50                   	push   %rax
 4e8:	52                   	push   %rdx
 4e9:	4f 54                	rex.WRXB push %r12
 4eb:	4f 5f                	rex.WRXB pop %r15
 4ed:	50                   	push   %rax
 4ee:	49                   	rex.WB
 4ef:	4d 00 49 50          	rex.WRB add %r9b,0x50(%r9)
  tcp = data + off;
 4f3:	50                   	push   %rax
 4f4:	52                   	push   %rdx
 4f5:	4f 54                	rex.WRXB push %r12
  if (is_ipv6) {
 4f7:	4f 5f                	rex.WRXB pop %r15
  tcp = data + off;
 4f9:	43                   	rex.XB
 4fa:	4f                   	rex.WRXB
 4fb:	4d 50                	rex.WRB push %r8
  if (tcp + 1 > data_end) {
 4fd:	00 49 50             	add    %cl,0x50(%rcx)
 500:	50                   	push   %rax
 501:	52                   	push   %rdx
 502:	4f 54                	rex.WRXB push %r12
 504:	4f 5f                	rex.WRXB pop %r15
 506:	4c 32 54 50 00       	rex.WR xor 0x0(%rax,%rdx,2),%r10b
  if (tcp->syn) {
 50b:	49 50                	rex.WB push %r8
 50d:	50                   	push   %rax
 50e:	52                   	push   %rdx
 50f:	4f 54                	rex.WRXB push %r12
 511:	4f 5f                	rex.WRXB pop %r15
 513:	53                   	push   %rbx
    pckt->flags |= F_SYN_SET;
 514:	43 54                	rex.XB push %r12
 516:	50                   	push   %rax
 517:	00 49 50             	add    %cl,0x50(%rcx)
 51a:	50                   	push   %rax
 51b:	52                   	push   %rdx
 51c:	4f 54                	rex.WRXB push %r12
 51e:	4f 5f                	rex.WRXB pop %r15
 520:	55                   	push   %rbp
 521:	44 50                	rex.R push %rax
 523:	4c                   	rex.WR
 524:	49 54                	rex.WB push %r12
 526:	45 00 49 50          	add    %r9b,0x50(%r9)
        bpf_map_lookup_elem(&stats, &stats_key);
 52a:	50                   	push   %rax
 52b:	52                   	push   %rdx
 52c:	4f 54                	rex.WRXB push %r12
 52e:	4f 5f                	rex.WRXB pop %r15
 530:	4d 50                	rex.WRB push %r8
 532:	4c 53                	rex.WR push %rbx
 534:	00 49 50             	add    %cl,0x50(%rcx)
    if (!icmp_ptb_v6_stats) {
 537:	50                   	push   %rax
 538:	52                   	push   %rdx
 539:	4f 54                	rex.WRXB push %r12
 53b:	4f 5f                	rex.WRXB pop %r15
 53d:	45 54                	rex.RB push %r12
 53f:	48                   	rex.W
    icmp_ptb_v6_stats->v1 += 1;
 540:	45 52                	rex.RB push %r10
 542:	4e                   	rex.WRX
 543:	45 54                	rex.RB push %r12
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 545:	00 49 50             	add    %cl,0x50(%rcx)
 548:	50                   	push   %rax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 549:	52                   	push   %rdx
 54a:	4f 54                	rex.WRXB push %r12
 54c:	4f 5f                	rex.WRXB pop %r15
 54e:	41                   	rex.B
 54f:	47                   	rex.RXB
 550:	47                   	rex.RXB
      icmp_ptb_v6_stats->v2 += 1;
 551:	46 52                	rex.RX push %rdx
 553:	41                   	rex.B
 554:	47 00 49 50          	rex.RXB add %r9b,0x50(%r9)
  if (ip6h + 1 > data_end) {
 558:	50                   	push   %rax
 559:	52                   	push   %rdx
 55a:	4f 54                	rex.WRXB push %r12
 55c:	4f 5f                	rex.WRXB pop %r15
 55e:	52                   	push   %rdx
 55f:	41 57                	push   %r15
 561:	00 49 50             	add    %cl,0x50(%rcx)
  pckt->flow.proto = ip6h->nexthdr;
 564:	50                   	push   %rax
 565:	52                   	push   %rdx
 566:	4f 54                	rex.WRXB push %r12
 568:	4f 5f                	rex.WRXB pop %r15
  pckt->flags |= F_ICMP;
 56a:	53                   	push   %rbx
 56b:	4d                   	rex.WRB
 56c:	43 00 49 50          	rex.XB add %cl,0x50(%r9)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 570:	50                   	push   %rax
 571:	52                   	push   %rdx
 572:	4f 54                	rex.WRXB push %r12
 574:	4f 5f                	rex.WRXB pop %r15
 576:	4d 50                	rex.WRB push %r8
 578:	54                   	push   %rsp
 579:	43 50                	rex.XB push %r8
 57b:	00 49 50             	add    %cl,0x50(%rcx)
 57e:	50                   	push   %rax
 57f:	52                   	push   %rdx
 580:	4f 54                	rex.WRXB push %r12
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 582:	4f 5f                	rex.WRXB pop %r15
 584:	4d                   	rex.WRB
 585:	41 58                	pop    %r8
 587:	00 64 61 74          	add    %ah,0x74(%rcx,%riz,2)
 58b:	61                   	(bad)
 58c:	5f                   	pop    %rdi
 58d:	65 6e                	outsb  %gs:(%rsi),(%dx)
 58f:	64 00 64 61 74       	add    %ah,%fs:0x74(%rcx,%riz,2)
 594:	61                   	(bad)
 595:	5f                   	pop    %rdi
 596:	6d                   	insl   (%dx),%es:(%rdi)
 597:	65 74 61             	gs je  5fb <balancer_ingress+0x5fb>
 59a:	00 64 61 74          	add    %ah,0x74(%rcx,%riz,2)
 59e:	61                   	(bad)
 59f:	5f                   	pop    %rdi
 5a0:	68 61 72 64 5f       	push   $0x5f647261
 5a5:	73 74                	jae    61b <balancer_ingress+0x61b>
 5a7:	61                   	(bad)
 5a8:	72 74                	jb     61e <balancer_ingress+0x61e>
 5aa:	00 72 78             	add    %dh,0x78(%rdx)
 5ad:	71 00                	jno    5af <balancer_ingress+0x5af>
 5af:	78 64                	js     615 <balancer_ingress+0x615>
 5b1:	70 5f                	jo     612 <balancer_ingress+0x612>
 5b3:	72 78                	jb     62d <balancer_ingress+0x62d>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 5b5:	71 5f                	jno    616 <balancer_ingress+0x616>
 5b7:	69 6e 66 6f 00 74 78 	imul   $0x7874006f,0x66(%rsi),%ebp
 5be:	71 00                	jno    5c0 <balancer_ingress+0x5c0>
 5c0:	78 64                	js     626 <balancer_ingress+0x626>
 5c2:	70 5f                	jo     623 <balancer_ingress+0x623>
 5c4:	74 78                	je     63e <balancer_ingress+0x63e>
 5c6:	71 5f                	jno    627 <balancer_ingress+0x627>
 5c8:	69 6e 66 6f 00 66 72 	imul   $0x7266006f,0x66(%rsi),%ebp
 5cf:	61                   	(bad)
 5d0:	6d                   	insl   (%dx),%es:(%rdi)
 5d1:	65 5f                	gs pop %rdi
 5d3:	73 7a                	jae    64f <balancer_ingress+0x64f>
 5d5:	00 78 64             	add    %bh,0x64(%rax)
 5d8:	70 5f                	jo     639 <balancer_ingress+0x639>
 5da:	6d                   	insl   (%dx),%es:(%rdi)
 5db:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
  if (decap_dst_flags) {
 5df:	6e                   	outsb  %ds:(%rsi),(%dx)
 5e0:	6e                   	outsb  %ds:(%rsi),(%dx)
 5e1:	5f                   	pop    %rdi
 5e2:	69 64 5f 6c 65 6e 73 	imul   $0x736e65,0x6c(%rdi,%rbx,2),%esp
 5e9:	00 
 5ea:	64 73 74             	fs jae 661 <balancer_ingress+0x661>
 5ed:	5f                   	pop    %rdi
 5ee:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 5f1:	6e                   	outsb  %ds:(%rsi),(%dx)
 5f2:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
 5f7:	6e                   	outsb  %ds:(%rsi),(%dx)
 5f8:	5f                   	pop    %rdi
 5f9:	69 64 00 71 75 69 63 	imul   $0x5f636975,0x71(%rax,%rax,1),%esp
 600:	5f 
    if (!data_stats) {
 601:	6c                   	insb   (%dx),%es:(%rdi)
 602:	6f                   	outsl  %ds:(%rsi),(%dx)
 603:	6e                   	outsb  %ds:(%rsi),(%dx)
 604:	67 5f                	addr32 pop %rdi
 606:	68 65 61 64 65       	push   $0x65646165
 60b:	72 00                	jb     60d <balancer_ingress+0x60d>
 60d:	71 75                	jno    684 <balancer_ingress+0x684>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 60f:	69 63 5f 73 68 6f 72 	imul   $0x726f6873,0x5f(%rbx),%esp
 616:	74 5f                	je     677 <balancer_ingress+0x677>
 618:	68 65 61 64 65       	push   $0x65646165
 61d:	72 00                	jb     61f <balancer_ingress+0x61f>
 61f:	70 72                	jo     693 <balancer_ingress+0x693>
 621:	6f                   	outsl  %ds:(%rsi),(%dx)
 622:	63 65 73             	movsxd 0x73(%rbp),%esp
 625:	73 5f                	jae    686 <balancer_ingress+0x686>
 627:	70 61                	jo     68a <balancer_ingress+0x68a>
 629:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 62c:	74 00                	je     62e <balancer_ingress+0x62e>
 62e:	78 64                	js     694 <balancer_ingress+0x694>
 630:	70 00                	jo     632 <balancer_ingress+0x632>
 632:	6e                   	outsb  %ds:(%rsi),(%dx)
 633:	68 5f 6f 66 66       	push   $0x66666f5f
  if (decap_dst_flags) {
 638:	00 69 73             	add    %ch,0x73(%rcx)
 63b:	5f                   	pop    %rdi
 63c:	69 70 76 36 00 5f 42 	imul   $0x425f0036,0x76(%rax),%esi
 643:	6f                   	outsl  %ds:(%rsi),(%dx)
 644:	6f                   	outsl  %ds:(%rsi),(%dx)
 645:	6c                   	insb   (%dx),%es:(%rdi)
 646:	00 70 63             	add    %dh,0x63(%rax)
 649:	6b 74 00 66 6c       	imul   $0x6c,0x66(%rax,%rax,1),%esi
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 64e:	6f                   	outsl  %ds:(%rsi),(%dx)
 64f:	77 00                	ja     651 <balancer_ingress+0x651>
 651:	72 65                	jb     6b8 <balancer_ingress+0x6b8>
 653:	61                   	(bad)
 654:	6c                   	insb   (%dx),%es:(%rdi)
 655:	5f                   	pop    %rdi
 656:	69 6e 64 65 78 00 74 	imul   $0x74007865,0x64(%rsi),%ebp
    if (!data_stats) {
 65d:	6f                   	outsl  %ds:(%rsi),(%dx)
 65e:	73 00                	jae    660 <balancer_ingress+0x660>
 660:	70 61                	jo     6c3 <balancer_ingress+0x6c3>
 662:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 665:	74 5f                	je     6c6 <balancer_ingress+0x6c6>
 667:	64 65 73 63          	fs gs jae 6ce <balancer_ingress+0x6ce>
  udp = data + off;
 66b:	72 69                	jb     6d6 <balancer_ingress+0x6d6>
  if (is_ipv6) {
 66d:	70 74                	jo     6e3 <balancer_ingress+0x6e3>
  udp = data + off;
 66f:	69 6f 6e 00 6d 61 63 	imul   $0x63616d00,0x6e(%rdi),%ebp
  if (udp + 1 > data_end) {
 676:	5f                   	pop    %rdi
 677:	61                   	(bad)
 678:	64 64 72 5f          	fs fs jb 6db <balancer_ingress+0x6db>
 67c:	70 6f                	jo     6ed <balancer_ingress+0x6ed>
 67e:	73 00                	jae    680 <balancer_ingress+0x680>
 680:	74 68                	je     6ea <balancer_ingress+0x6ea>
 682:	5f                   	pop    %rdi
 683:	6f                   	outsl  %ds:(%rsi),(%dx)
 684:	66 66 00 70 72       	data16 data16 add %dh,0x72(%rax)
 689:	6f                   	outsl  %ds:(%rsi),(%dx)
 68a:	74 6f                	je     6fb <balancer_ingress+0x6fb>
 68c:	63 6f 6c             	movsxd 0x6c(%rdi),%ebp
 68f:	00 76 69             	add    %dh,0x69(%rsi)
 692:	70 5f                	jo     6f3 <balancer_ingress+0x6f3>
 694:	69 6e 66 6f 00 64 61 	imul   $0x6164006f,0x66(%rsi),%ebp
 69b:	74 61                	je     6fe <balancer_ingress+0x6fe>
 69d:	5f                   	pop    %rdi
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 69e:	73 74                	jae    714 <balancer_ingress+0x714>
 6a0:	61                   	(bad)
 6a1:	74 73                	je     716 <balancer_ingress+0x716>
 6a3:	00 63 70             	add    %ah,0x70(%rbx)
 6a6:	75 5f                	jne    707 <balancer_ingress+0x707>
 6a8:	6e                   	outsb  %ds:(%rsi),(%dx)
 6a9:	75 6d                	jne    718 <balancer_ingress+0x718>
 6ab:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
        bpf_map_lookup_elem(&stats, &stats_key);
 6af:	5f                   	pop    %rdi
 6b0:	6d                   	insl   (%dx),%es:(%rdi)
 6b1:	61                   	(bad)
 6b2:	70 00                	jo     6b4 <balancer_ingress+0x6b4>
 6b4:	70 6b                	jo     721 <balancer_ingress+0x721>
 6b6:	74 5f                	je     717 <balancer_ingress+0x717>
 6b8:	62                   	(bad)
 6b9:	79 74                	jns    72f <balancer_ingress+0x72f>
 6bb:	65 73 00             	gs jae 6be <balancer_ingress+0x6be>
    if (!icmp_ptb_v4_stats) {
 6be:	6f                   	outsl  %ds:(%rsi),(%dx)
 6bf:	72 69                	jb     72a <balancer_ingress+0x72a>
 6c1:	67 69 6e 61 6c 5f 73 	imul   $0x70735f6c,0x61(%esi),%ebp
 6c8:	70 
    icmp_ptb_v4_stats->v1 += 1;
 6c9:	6f                   	outsl  %ds:(%rsi),(%dx)
 6ca:	72 74                	jb     740 <balancer_ingress+0x740>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 6cc:	00 63 76             	add    %ah,0x76(%rbx)
 6cf:	61                   	(bad)
 6d0:	6c                   	insb   (%dx),%es:(%rdi)
      icmp_ptb_v4_stats->v2 += 1;
 6d1:	00 69 70             	add    %ch,0x70(%rcx)
 6d4:	68 5f 6c 65 6e       	push   $0x6e656c5f
  if (iph + 1 > data_end) {
 6d9:	00 62 70             	add    %ah,0x70(%rdx)
 6dc:	66 5f                	pop    %di
 6de:	70 72                	jo     752 <balancer_ingress+0x752>
 6e0:	6f                   	outsl  %ds:(%rsi),(%dx)
 6e1:	67 00 66 75          	add    %ah,0x75(%esi)
  if (iph->ihl != 5) {
 6e5:	6e                   	outsb  %ds:(%rsi),(%dx)
 6e6:	63 00                	movsxd (%rax),%eax
 6e8:	70 61                	jo     74b <balancer_ingress+0x74b>
 6ea:	73 73                	jae    75f <balancer_ingress+0x75f>
 6ec:	00 5f 5f             	add    %bl,0x5f(%rdi)
  pckt->flow.proto = iph->protocol;
 6ef:	65 6c                	gs insb (%dx),%es:(%rdi)
 6f1:	65 6d                	gs insl (%dx),%es:(%rdi)
 6f3:	00 69 64             	add    %ch,0x64(%rcx)
  pckt->flags |= F_ICMP;
 6f6:	78 00                	js     6f8 <balancer_ingress+0x6f8>
 6f8:	65 6c                	gs insb (%dx),%es:(%rdi)
 6fa:	65 6d                	gs insl (%dx),%es:(%rdi)
  pckt->flow.src = iph->daddr;
 6fc:	5f                   	pop    %rdi
 6fd:	73 69                	jae    768 <balancer_ingress+0x768>
 6ff:	7a 65                	jp     766 <balancer_ingress+0x766>
 701:	00 5f 5f             	add    %bl,0x5f(%rdi)
  pckt->flow.dst = iph->saddr;
 704:	70 65                	jo     76b <balancer_ingress+0x76b>
 706:	72 63                	jb     76b <balancer_ingress+0x76b>
 708:	70 75                	jo     77f <balancer_ingress+0x77f>
 70a:	5f                   	pop    %rdi
 70b:	69 64 00 6c 72 75 5f 	imul   $0x735f7572,0x6c(%rax,%rax,1),%esp
 712:	73 
 713:	74 61                	je     776 <balancer_ingress+0x776>
 715:	74 73                	je     78a <balancer_ingress+0x78a>
 717:	5f                   	pop    %rdi
 718:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 71c:	6c                   	insb   (%dx),%es:(%rdi)
 71d:	72 75                	jb     794 <balancer_ingress+0x794>
 71f:	5f                   	pop    %rdi
 720:	73 74                	jae    796 <balancer_ingress+0x796>
 722:	61                   	(bad)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
 723:	74 73                	je     798 <balancer_ingress+0x798>
 725:	00 69 73             	add    %ch,0x73(%rcx)
 728:	5f                   	pop    %rdi
 729:	69 63 6d 70 00 71 75 	imul   $0x75710070,0x6d(%rbx),%esp
 730:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
  vip.port = pckt.flow.port16[1];
 737:	65 74 73             	gs je  7ad <balancer_ingress+0x7ad>
 73a:	5f                   	pop    %rdi
 73b:	73 74                	jae    7b1 <balancer_ingress+0x7b1>
 73d:	61                   	(bad)
 73e:	74 73                	je     7b3 <balancer_ingress+0x7b3>
 740:	5f                   	pop    %rdi
  vip.proto = pckt.flow.proto;
 741:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 745:	71 70                	jno    7b7 <balancer_ingress+0x7b7>
 747:	72 00                	jb     749 <balancer_ingress+0x749>
 749:	63 69 64             	movsxd 0x64(%rcx),%ebp
 74c:	5f                   	pop    %rdi
 74d:	76 65                	jbe    7b4 <balancer_ingress+0x7b4>
 74f:	72 73                	jb     7c4 <balancer_ingress+0x7c4>
 751:	69 6f 6e 00 69 73 5f 	imul   $0x5f736900,0x6e(%rdi),%ebp
 758:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
 75f:	00 71 75             	add    %dh,0x75(%rcx)
 762:	69 63 5f 70 61 72 73 	imul   $0x73726170,0x5f(%rbx),%esp
  if (!vip_info) {
 769:	65 5f                	gs pop %rdi
 76b:	72 65                	jb     7d2 <balancer_ingress+0x7d2>
  if (data_end - data > MAX_PCKT_SIZE) {
 76d:	73 75                	jae    7e4 <balancer_ingress+0x7e4>
 76f:	6c                   	insb   (%dx),%es:(%rdi)
 770:	74 00                	je     772 <balancer_ingress+0x772>
 772:	72 65                	jb     7d9 <balancer_ingress+0x7d9>
 774:	61                   	(bad)
 775:	6c                   	insb   (%dx),%es:(%rdi)
 776:	5f                   	pop    %rdi
 777:	70 6f                	jo     7e8 <balancer_ingress+0x7e8>
 779:	73 00                	jae    77b <balancer_ingress+0x77b>
 77b:	72 65                	jb     7e2 <balancer_ingress+0x7e2>
 77d:	73 00                	jae    77f <balancer_ingress+0x77f>
 77f:	70 61                	jo     7e2 <balancer_ingress+0x7e2>
 781:	72 73                	jb     7f6 <balancer_ingress+0x7f6>
 783:	65 5f                	gs pop %rdi
 785:	6c                   	insb   (%dx),%es:(%rdi)
 786:	33 5f 68             	xor    0x68(%rdi),%ebx
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 789:	65 61                	gs (bad)
 78b:	64 65 72 73          	fs gs jb 802 <balancer_ingress+0x802>
 78f:	00 69 70             	add    %ch,0x70(%rcx)
 792:	68 00 69 68 6c       	push   $0x6c686900
 797:	00 74 6f 74          	add    %dh,0x74(%rdi,%rbp,2)
  if (!data_stats) {
 79b:	5f                   	pop    %rdi
 79c:	6c                   	insb   (%dx),%es:(%rdi)
 79d:	65 6e                	outsb  %gs:(%rsi),(%dx)
 79f:	00 5f 5f             	add    %bl,0x5f(%rdi)
  data_stats->v1 += 1;
 7a2:	62 65                	(bad)
 7a4:	31 36                	xor    %esi,(%rsi)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 7a6:	00 66 72             	add    %ah,0x72(%rsi)
 7a9:	61                   	(bad)
 7aa:	67 5f                	addr32 pop %rdi
    pckt.flow.port16[0] = 0;
 7ac:	6f                   	outsl  %ds:(%rsi),(%dx)
 7ad:	66 66 00 74 74 6c    	data16 data16 add %dh,0x6c(%rsp,%rsi,2)
  vip_num = vip_info->vip_num;
 7b3:	00 63 68             	add    %ah,0x68(%rbx)
 7b6:	65 63 6b 00          	movsxd %gs:0x0(%rbx),%ebp
 7ba:	5f                   	pop    %rdi
 7bb:	5f                   	pop    %rdi
  __u32 cpu_num = bpf_get_smp_processor_id();
 7bc:	73 75                	jae    833 <balancer_ingress+0x833>
 7be:	6d                   	insl   (%dx),%es:(%rdi)
 7bf:	31 36                	xor    %esi,(%rsi)
 7c1:	00 73 61             	add    %dh,0x61(%rbx)
 7c4:	64 64 72 00          	fs fs jb 7c8 <balancer_ingress+0x7c8>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 7c8:	64 61                	fs (bad)
 7ca:	64 64 72 00          	fs fs jb 7ce <balancer_ingress+0x7ce>
 7ce:	61                   	(bad)
 7cf:	64 64 72 73          	fs fs jb 846 <balancer_ingress+0x846>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
 7d3:	00 69 70             	add    %ch,0x70(%rcx)
 7d6:	68 64 72 00 69       	push   $0x69007264
 7db:	70 36                	jo     813 <balancer_ingress+0x813>
 7dd:	68 00 70 72 69       	push   $0x69727000
 7e2:	6f                   	outsl  %ds:(%rsi),(%dx)
    if (!lru_stats) {
 7e3:	72 69                	jb     84e <balancer_ingress+0x84e>
 7e5:	74 79                	je     860 <balancer_ingress+0x860>
 7e7:	00 66 6c             	add    %ah,0x6c(%rsi)
 7ea:	6f                   	outsl  %ds:(%rsi),(%dx)
 7eb:	77 5f                	ja     84c <balancer_ingress+0x84c>
    lru_stats->v1 += 1;
 7ed:	6c                   	insb   (%dx),%es:(%rdi)
 7ee:	62                   	(bad)
 7ef:	6c                   	insb   (%dx),%es:(%rdi)
 7f0:	00 70 61             	add    %dh,0x61(%rax)
 7f3:	79 6c                	jns    861 <balancer_ingress+0x861>
 7f5:	6f                   	outsl  %ds:(%rsi),(%dx)
 7f6:	61                   	(bad)
 7f7:	64 5f                	fs pop %rdi
 7f9:	6c                   	insb   (%dx),%es:(%rdi)
 7fa:	65 6e                	outsb  %gs:(%rsi),(%dx)
 7fc:	00 6e 65             	add    %ch,0x65(%rsi)
 7ff:	78 74                	js     875 <balancer_ingress+0x875>
 801:	68 64 72 00 68       	push   $0x68007264
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 806:	6f                   	outsl  %ds:(%rsi),(%dx)
 807:	70 5f                	jo     868 <balancer_ingress+0x868>
 809:	6c                   	insb   (%dx),%es:(%rdi)
 80a:	69 6d 69 74 00 69 6e 	imul   $0x6e690074,0x69(%rbp),%ebp
 811:	36 5f                	ss pop %rdi
 813:	75 00                	jne    815 <balancer_ingress+0x815>
        bpf_map_lookup_elem(&stats, &stats_key);
 815:	75 36                	jne    84d <balancer_ingress+0x84d>
 817:	5f                   	pop    %rdi
 818:	61                   	(bad)
 819:	64 64 72 38          	fs fs jb 855 <balancer_ingress+0x855>
 81d:	00 75 36             	add    %dh,0x36(%rbp)
 820:	5f                   	pop    %rdi
 821:	61                   	(bad)
 822:	64 64 72 31          	fs fs jb 857 <balancer_ingress+0x857>
    if (!icmp_ptb_v4_stats) {
 826:	36 00 75 36          	ss add %dh,0x36(%rbp)
 82a:	5f                   	pop    %rdi
 82b:	61                   	(bad)
 82c:	64 64 72 33          	fs fs jb 863 <balancer_ingress+0x863>
    icmp_ptb_v4_stats->v1 += 1;
 830:	32 00                	xor    (%rax),%al
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 832:	69 6e 36 5f 61 64 64 	imul   $0x6464615f,0x36(%rsi),%ebp
      icmp_ptb_v4_stats->v2 += 1;
 839:	72 00                	jb     83b <balancer_ingress+0x83b>
 83b:	69 70 76 36 68 64 72 	imul   $0x72646836,0x76(%rax),%esi
  if (iph + 1 > data_end) {
 842:	00 70 61             	add    %dh,0x61(%rax)
 845:	72 73                	jb     8ba <balancer_ingress+0x8ba>
 847:	65 5f                	gs pop %rdi
  if (iph->ihl != 5) {
 849:	69 63 6d 70 00 69 63 	imul   $0x63690070,0x6d(%rbx),%esp
 850:	6d                   	insl   (%dx),%es:(%rdi)
 851:	70 5f                	jo     8b2 <balancer_ingress+0x8b2>
 853:	68 64 72 00 63       	push   $0x63007264
  pckt->flow.proto = iph->protocol;
 858:	68 65 63 6b 73       	push   $0x736b6365
  pckt->flags |= F_ICMP;
 85d:	75 6d                	jne    8cc <balancer_ingress+0x8cc>
 85f:	00 73 65             	add    %dh,0x65(%rbx)
  pckt->flow.src = iph->daddr;
 862:	71 75                	jno    8d9 <balancer_ingress+0x8d9>
 864:	65 6e                	outsb  %gs:(%rsi),(%dx)
 866:	63 65 00             	movsxd 0x0(%rbp),%esp
  pckt->flow.dst = iph->saddr;
 869:	67 61                	addr32 (bad)
 86b:	74 65                	je     8d2 <balancer_ingress+0x8d2>
 86d:	77 61                	ja     8d0 <balancer_ingress+0x8d0>
 86f:	79 00                	jns    871 <balancer_ingress+0x871>
 871:	66 72 61             	data16 jb 8d5 <balancer_ingress+0x8d5>
    vip.port = 0;
 874:	67 00 5f 5f          	add    %bl,0x5f(%edi)
 878:	75 6e                	jne    8e8 <balancer_ingress+0x8e8>
 87a:	75 73                	jne    8ef <balancer_ingress+0x8ef>
 87c:	65 64 00 6d 74       	gs add %ch,%fs:0x74(%rbp)
 881:	75 00                	jne    883 <balancer_ingress+0x883>
 883:	72 65                	jb     8ea <balancer_ingress+0x8ea>
 885:	73 65                	jae    8ec <balancer_ingress+0x8ec>
 887:	72 76                	jb     8ff <balancer_ingress+0x8ff>
    if (!vip_info) {
 889:	65 64 00 69 63       	gs add %ch,%fs:0x63(%rcx)
 88e:	6d                   	insl   (%dx),%es:(%rdi)
 88f:	70 68                	jo     8f9 <balancer_ingress+0x8f9>
 891:	64 72 00             	fs jb  894 <balancer_ingress+0x894>
 894:	69 63 6d 70 5f 70 74 	imul   $0x74705f70,0x6d(%rbx),%esp
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 89b:	62                   	(bad)
 89c:	5f                   	pop    %rdi
 89d:	76 34                	jbe    8d3 <balancer_ingress+0x8d3>
      pckt.flow.port16[1] = 0;
 89f:	5f                   	pop    %rdi
 8a0:	73 74                	jae    916 <balancer_ingress+0x916>
 8a2:	61                   	(bad)
 8a3:	74 73                	je     918 <balancer_ingress+0x918>
 8a5:	00 68 61             	add    %ch,0x61(%rax)
 8a8:	6e                   	outsb  %ds:(%rsi),(%dx)
 8a9:	64 6c                	fs insb (%dx),%es:(%rdi)
  struct address dst_addr = {};
 8ab:	65 5f                	gs pop %rdi
 8ad:	69 66 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rsi),%esp
 8b4:	00 73 65             	add    %dh,0x65(%rbx)
 8b7:	6e                   	outsb  %ds:(%rsi),(%dx)
 8b8:	64 5f                	fs pop %rdi
 8ba:	69 63 6d 70 5f 72 65 	imul   $0x65725f70,0x6d(%rbx),%esp
    dst_addr.addr = pckt->flow.dst;
 8c1:	70 6c                	jo     92f <balancer_ingress+0x92f>
 8c3:	79 00                	jns    8c5 <balancer_ingress+0x8c5>
 8c5:	74 6d                	je     934 <balancer_ingress+0x934>
 8c7:	70 5f                	jo     928 <balancer_ingress+0x928>
 8c9:	61                   	(bad)
 8ca:	64 64 72 00          	fs fs jb 8ce <balancer_ingress+0x8ce>
 8ce:	63 73 75             	movsxd 0x75(%rbx),%esi
 8d1:	6d                   	insl   (%dx),%es:(%rdi)
 8d2:	00 69 70             	add    %ch,0x70(%rcx)
 8d5:	76 34                	jbe    90b <balancer_ingress+0x90b>
 8d7:	5f                   	pop    %rdi
  if (decap_dst_flags) {
 8d8:	63 73 75             	movsxd 0x75(%rbx),%esi
 8db:	6d                   	insl   (%dx),%es:(%rdi)
 8dc:	5f                   	pop    %rdi
 8dd:	69 6e 6c 69 6e 65 00 	imul   $0x656e69,0x6c(%rsi),%ebp
 8e4:	6e                   	outsb  %ds:(%rsi),(%dx)
 8e5:	65 78 74             	gs js  95c <balancer_ingress+0x95c>
 8e8:	5f                   	pop    %rdi
 8e9:	69 70 68 5f 75 31 36 	imul   $0x3631755f,0x68(%rax),%esi
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 8f0:	00 69 00             	add    %ch,0x0(%rcx)
 8f3:	70 61                	jo     956 <balancer_ingress+0x956>
 8f5:	72 73                	jb     96a <balancer_ingress+0x96a>
 8f7:	65 5f                	gs pop %rdi
 8f9:	69 63 6d 70 76 36 00 	imul   $0x367670,0x6d(%rbx),%esp
    if (!data_stats) {
 900:	69 63 6d 70 36 5f 74 	imul   $0x745f3670,0x6d(%rbx),%esp
 907:	79 70                	jns    979 <balancer_ingress+0x979>
 909:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
 90d:	6d                   	insl   (%dx),%es:(%rdi)
 90e:	70 36                	jo     946 <balancer_ingress+0x946>
 910:	5f                   	pop    %rdi
 911:	63 6f 64             	movsxd 0x64(%rdi),%ebp
        bpf_map_lookup_elem(&stats, &stats_key);
 914:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
 918:	6d                   	insl   (%dx),%es:(%rdi)
 919:	70 36                	jo     951 <balancer_ingress+0x951>
 91b:	5f                   	pop    %rdi
 91c:	63 6b 73             	movsxd 0x73(%rbx),%ebp
 91f:	75 6d                	jne    98e <balancer_ingress+0x98e>
 921:	00 69 63             	add    %ch,0x63(%rcx)
    if (!icmp_ptb_v6_stats) {
 924:	6d                   	insl   (%dx),%es:(%rdi)
 925:	70 36                	jo     95d <balancer_ingress+0x95d>
 927:	5f                   	pop    %rdi
 928:	64 61                	fs (bad)
 92a:	74 61                	je     98d <balancer_ingress+0x98d>
    icmp_ptb_v6_stats->v1 += 1;
 92c:	75 6e                	jne    99c <balancer_ingress+0x99c>
 92e:	00 75 6e             	add    %dh,0x6e(%rbp)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 931:	5f                   	pop    %rdi
 932:	64 61                	fs (bad)
 934:	74 61                	je     997 <balancer_ingress+0x997>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 936:	33 32                	xor    (%rdx),%esi
 938:	00 75 6e             	add    %dh,0x6e(%rbp)
 93b:	5f                   	pop    %rdi
 93c:	64 61                	fs (bad)
      icmp_ptb_v6_stats->v2 += 1;
 93e:	74 61                	je     9a1 <balancer_ingress+0x9a1>
 940:	31 36                	xor    %esi,(%rsi)
  if (ip6h + 1 > data_end) {
 942:	00 75 6e             	add    %dh,0x6e(%rbp)
 945:	5f                   	pop    %rdi
 946:	64 61                	fs (bad)
 948:	74 61                	je     9ab <balancer_ingress+0x9ab>
 94a:	38 00                	cmp    %al,(%rax)
 94c:	75 5f                	jne    9ad <balancer_ingress+0x9ad>
 94e:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
 952:	00 69 64             	add    %ch,0x64(%rcx)
  pckt->flow.proto = ip6h->nexthdr;
 955:	65 6e                	outsb  %gs:(%rsi),(%dx)
 957:	74 69                	je     9c2 <balancer_ingress+0x9c2>
 959:	66 69 65 72 00 69    	imul   $0x6900,0x72(%rbp),%sp
  pckt->flags |= F_ICMP;
 95f:	63 6d 70             	movsxd 0x70(%rbp),%ebp
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 962:	76 36                	jbe    99a <balancer_ingress+0x99a>
 964:	5f                   	pop    %rdi
 965:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
 969:	00 75 5f             	add    %dh,0x5f(%rbp)
 96c:	6e                   	outsb  %ds:(%rsi),(%dx)
 96d:	64 5f                	fs pop %rdi
 96f:	61                   	(bad)
 970:	64 76 74             	fs jbe 9e7 <balancer_ingress+0x9e7>
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 973:	00 6f 76             	add    %ch,0x76(%rdi)
 976:	65 72 72             	gs jb  9eb <balancer_ingress+0x9eb>
 979:	69 64 65 00 73 6f 6c 	imul   $0x696c6f73,0x0(%rbp,%riz,2),%esp
 980:	69 
 981:	63 69 74             	movsxd 0x74(%rcx),%ebp
 984:	65 64 00 72 6f       	gs add %dh,%fs:0x6f(%rdx)
 989:	75 74                	jne    9ff <balancer_ingress+0x9ff>
  if (protocol == IPPROTO_IPIP) {
 98b:	65 72 00             	gs jb  98e <balancer_ingress+0x98e>
 98e:	72 65                	jb     9f5 <balancer_ingress+0x9f5>
 990:	73 65                	jae    9f7 <balancer_ingress+0x9f7>
 992:	72 76                	jb     a0a <balancer_ingress+0xa0a>
 994:	65 64 32 00          	gs xor %fs:(%rax),%al
 998:	69 63 6d 70 76 36 5f 	imul   $0x5f367670,0x6d(%rbx),%esp
  struct address dst_addr = {};
 99f:	6e                   	outsb  %ds:(%rsi),(%dx)
 9a0:	64 5f                	fs pop %rdi
 9a2:	61                   	(bad)
 9a3:	64 76 74             	fs jbe a1a <balancer_ingress+0xa1a>
 9a6:	00 75 5f             	add    %dh,0x5f(%rbp)
 9a9:	6e                   	outsb  %ds:(%rsi),(%dx)
 9aa:	64 5f                	fs pop %rdi
 9ac:	72 61                	jb     a0f <balancer_ingress+0xa0f>
 9ae:	00 72 6f             	add    %dh,0x6f(%rdx)
    dst_addr.addr = pckt->flow.dst;
 9b1:	75 74                	jne    a27 <balancer_ingress+0xa27>
 9b3:	65 72 5f             	gs jb  a15 <balancer_ingress+0xa15>
 9b6:	70 72                	jo     a2a <balancer_ingress+0xa2a>
 9b8:	65 66 00 68 6f       	data16 add %ch,%gs:0x6f(%rax)
 9bd:	6d                   	insl   (%dx),%es:(%rdi)
 9be:	65 5f                	gs pop %rdi
 9c0:	61                   	(bad)
 9c1:	67 65 6e             	outsb  %gs:(%esi),(%dx)
 9c4:	74 00                	je     9c6 <balancer_ingress+0x9c6>
 9c6:	6f                   	outsl  %ds:(%rsi),(%dx)
 9c7:	74 68                	je     a31 <balancer_ingress+0xa31>
 9c9:	65 72 00             	gs jb  9cc <balancer_ingress+0x9cc>
  if (decap_dst_flags) {
 9cc:	6d                   	insl   (%dx),%es:(%rdi)
 9cd:	61                   	(bad)
 9ce:	6e                   	outsb  %ds:(%rsi),(%dx)
 9cf:	61                   	(bad)
 9d0:	67 65 64 00 72 74    	gs add %dh,%fs:0x74(%edx)
 9d6:	5f                   	pop    %rdi
 9d7:	6c                   	insb   (%dx),%es:(%rdi)
 9d8:	69 66 65 74 69 6d 65 	imul   $0x656d6974,0x65(%rsi),%esp
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 9df:	00 69 63             	add    %ch,0x63(%rcx)
 9e2:	6d                   	insl   (%dx),%es:(%rdi)
 9e3:	70 76                	jo     a5b <balancer_ingress+0xa5b>
 9e5:	36 5f                	ss pop %rdi
 9e7:	6e                   	outsb  %ds:(%rsi),(%dx)
 9e8:	64 5f                	fs pop %rdi
 9ea:	72 61                	jb     a4d <balancer_ingress+0xa4d>
 9ec:	00 69 63             	add    %ch,0x63(%rcx)
    if (!data_stats) {
 9ef:	6d                   	insl   (%dx),%es:(%rdi)
 9f0:	70 36                	jo     a28 <balancer_ingress+0xa28>
 9f2:	68 64 72 00 69       	push   $0x69007264
 9f7:	63 6d 70             	movsxd 0x70(%rbp),%ebp
 9fa:	5f                   	pop    %rdi
 9fb:	70 74                	jo     a71 <balancer_ingress+0xa71>
 9fd:	62                   	(bad)
 9fe:	5f                   	pop    %rdi
 9ff:	76 36                	jbe    a37 <balancer_ingress+0xa37>
  udp = data + off;
 a01:	5f                   	pop    %rdi
 a02:	73 74                	jae    a78 <balancer_ingress+0xa78>
 a04:	61                   	(bad)
  if (is_ipv6) {
 a05:	74 73                	je     a7a <balancer_ingress+0xa7a>
  udp = data + off;
 a07:	00 70 61             	add    %dh,0x61(%rax)
 a0a:	72 73                	jb     a7f <balancer_ingress+0xa7f>
  if (udp + 1 > data_end) {
 a0c:	65 5f                	gs pop %rdi
 a0e:	74 63                	je     a73 <balancer_ingress+0xa73>
 a10:	70 00                	jo     a12 <balancer_ingress+0xa12>
 a12:	61                   	(bad)
 a13:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 a16:	73 65                	jae    a7d <balancer_ingress+0xa7d>
 a18:	71 00                	jno    a1a <balancer_ingress+0xa1a>
 a1a:	61                   	(bad)
 a1b:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
 a1f:	73 31                	jae    a52 <balancer_ingress+0xa52>
 a21:	00 64 6f 66          	add    %ah,0x66(%rdi,%rbp,2)
 a25:	66 00 66 69          	data16 add %ah,0x69(%rsi)
 a29:	6e                   	outsb  %ds:(%rsi),(%dx)
 a2a:	00 72 73             	add    %dh,0x73(%rdx)
 a2d:	74 00                	je     a2f <balancer_ingress+0xa2f>
 a2f:	70 73                	jo     aa4 <balancer_ingress+0xaa4>
 a31:	68 00 61 63 6b       	push   $0x6b636100
 a36:	00 75 72             	add    %dh,0x72(%rbp)
 a39:	67 00 65 63          	add    %ah,0x63(%ebp)
 a3d:	65 00 63 77          	add    %ah,%gs:0x77(%rbx)
 a41:	72 00                	jb     a43 <balancer_ingress+0xa43>
 a43:	77 69                	ja     aae <balancer_ingress+0xaae>
 a45:	6e                   	outsb  %ds:(%rsi),(%dx)
 a46:	64 6f                	outsl  %fs:(%rsi),(%dx)
 a48:	77 00                	ja     a4a <balancer_ingress+0xa4a>
    vip.vip = pckt.flow.dst;
 a4a:	75 72                	jne    abe <balancer_ingress+0xabe>
 a4c:	67 5f                	addr32 pop %rdi
 a4e:	70 74                	jo     ac4 <balancer_ingress+0xac4>
 a50:	72 00                	jb     a52 <balancer_ingress+0xa52>
  vip.port = pckt.flow.port16[1];
 a52:	74 63                	je     ab7 <balancer_ingress+0xab7>
 a54:	70 68                	jo     abe <balancer_ingress+0xabe>
 a56:	64 72 00             	fs jb  a59 <balancer_ingress+0xa59>
 a59:	63 61 6c             	movsxd 0x6c(%rcx),%esp
  vip.proto = pckt.flow.proto;
 a5c:	63 5f 6f             	movsxd 0x6f(%rdi),%ebx
 a5f:	66 66 73 65          	data16 data16 jae ac8 <balancer_ingress+0xac8>
 a63:	74 00                	je     a65 <balancer_ingress+0xa65>
 a65:	73 65                	jae    acc <balancer_ingress+0xacc>
 a67:	6e                   	outsb  %ds:(%rsi),(%dx)
 a68:	64 5f                	fs pop %rdi
 a6a:	69 63 6d 70 36 5f 72 	imul   $0x725f3670,0x6d(%rbx),%esp
 a71:	65 70 6c             	gs jo  ae0 <balancer_ingress+0xae0>
 a74:	79 00                	jns    a76 <balancer_ingress+0xa76>
 a76:	63 68 65             	movsxd 0x65(%rax),%ebp
 a79:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 a7c:	64 65 63 61 70       	fs movsxd %gs:0x70(%rcx),%esp
  if (!vip_info) {
 a81:	5f                   	pop    %rdi
 a82:	64 73 74             	fs jae af9 <balancer_ingress+0xaf9>
 a85:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
  if (data_end - data > MAX_PCKT_SIZE) {
 a89:	5f                   	pop    %rdi
 a8a:	61                   	(bad)
 a8b:	64 64 72 00          	fs fs jb a8f <balancer_ingress+0xa8f>
 a8f:	64 65 63 61 70       	fs movsxd %gs:0x70(%rcx),%esp
 a94:	5f                   	pop    %rdi
 a95:	64 73 74             	fs jae b0c <balancer_ingress+0xb0c>
 a98:	5f                   	pop    %rdi
 a99:	66 6c                	data16 insb (%dx),%es:(%rdi)
 a9b:	61                   	(bad)
 a9c:	67 73 00             	addr32 jae a9f <balancer_ingress+0xa9f>
 a9f:	72 65                	jb     b06 <balancer_ingress+0xb06>
 aa1:	61                   	(bad)
 aa2:	6c                   	insb   (%dx),%es:(%rdi)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 aa3:	5f                   	pop    %rdi
 aa4:	62                   	(bad)
 aa5:	70 66                	jo     b0d <balancer_ingress+0xb0d>
 aa7:	5f                   	pop    %rdi
 aa8:	6d                   	insl   (%dx),%es:(%rdi)
 aa9:	61                   	(bad)
 aaa:	70 5f                	jo     b0b <balancer_ingress+0xb0b>
 aac:	6c                   	insb   (%dx),%es:(%rdi)
 aad:	6f                   	outsl  %ds:(%rsi),(%dx)
 aae:	6f                   	outsl  %ds:(%rsi),(%dx)
 aaf:	6b 75 70 5f          	imul   $0x5f,0x70(%rbp),%esi
  if (!data_stats) {
 ab3:	65 6c                	gs insb (%dx),%es:(%rdi)
 ab5:	65 6d                	gs insl (%dx),%es:(%rdi)
 ab7:	00 70 61             	add    %dh,0x61(%rax)
 aba:	72 73                	jb     b2f <balancer_ingress+0xb2f>
  data_stats->v1 += 1;
 abc:	65 5f                	gs pop %rdi
 abe:	75 64                	jne    b24 <balancer_ingress+0xb24>
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 ac0:	70 00                	jo     ac2 <balancer_ingress+0xac2>
 ac2:	75 64                	jne    b28 <balancer_ingress+0xb28>
 ac4:	70 68                	jo     b2e <balancer_ingress+0xb2e>
    pckt.flow.port16[0] = 0;
 ac6:	64 72 00             	fs jb  ac9 <balancer_ingress+0xac9>
 ac9:	70 61                	jo     b2c <balancer_ingress+0xb2c>
 acb:	72 73                	jb     b40 <balancer_ingress+0xb40>
  vip_num = vip_info->vip_num;
 acd:	65 5f                	gs pop %rdi
 acf:	71 75                	jno    b46 <balancer_ingress+0xb46>
 ad1:	69 63 00 71 75 69 63 	imul   $0x63697571,0x0(%rbx),%esp
 ad8:	5f                   	pop    %rdi
 ad9:	64 61                	fs (bad)
  __u32 cpu_num = bpf_get_smp_processor_id();
 adb:	74 61                	je     b3e <balancer_ingress+0xb3e>
 add:	00 70 6b             	add    %dh,0x6b(%rax)
 ae0:	74 5f                	je     b41 <balancer_ingress+0xb41>
 ae2:	74 79                	je     b5d <balancer_ingress+0xb5d>
 ae4:	70 65                	jo     b4b <balancer_ingress+0xb4b>
 ae6:	00 63 6f             	add    %ah,0x6f(%rbx)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 ae9:	6e                   	outsb  %ds:(%rsi),(%dx)
 aea:	6e                   	outsb  %ds:(%rsi),(%dx)
 aeb:	49                   	rex.WB
 aec:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
 af0:	6e                   	outsb  %ds:(%rsi),(%dx)
 af1:	6e                   	outsb  %ds:(%rsi),(%dx)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
 af2:	49                   	rex.WB
 af3:	64 56                	fs push %rsi
 af5:	65 72 73             	gs jb  b6b <balancer_ingress+0xb6b>
 af8:	69 6f 6e 00 69 67 6e 	imul   $0x6e676900,0x6e(%rdi),%ebp
 aff:	6f                   	outsl  %ds:(%rsi),(%dx)
 b00:	72 61                	jb     b63 <balancer_ingress+0xb63>
 b02:	62                   	(bad)
 b03:	6c                   	insb   (%dx),%es:(%rdi)
 b04:	65 5f                	gs pop %rdi
 b06:	71 75                	jno    b7d <balancer_ingress+0xb7d>
 b08:	69 63 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rbx),%esp
    if (!lru_stats) {
 b0f:	5f                   	pop    %rdi
 b10:	63 6f 64             	movsxd 0x64(%rdi),%ebp
 b13:	65 00 63 6f          	add    %ah,%gs:0x6f(%rbx)
    lru_stats->v1 += 1;
 b17:	6e                   	outsb  %ds:(%rsi),(%dx)
 b18:	6e                   	outsb  %ds:(%rsi),(%dx)
 b19:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
 b1e:	6e                   	outsb  %ds:(%rsi),(%dx)
 b1f:	5f                   	pop    %rdi
 b20:	74 61                	je     b83 <balancer_ingress+0xb83>
 b22:	62                   	(bad)
 b23:	6c                   	insb   (%dx),%es:(%rdi)
 b24:	65 5f                	gs pop %rdi
 b26:	6c                   	insb   (%dx),%es:(%rdi)
 b27:	6f                   	outsl  %ds:(%rsi),(%dx)
 b28:	6f                   	outsl  %ds:(%rsi),(%dx)
 b29:	6b 75 70 00          	imul   $0x0,0x70(%rbp),%esi
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 b2d:	69 73 47 6c 6f 62 61 	imul   $0x61626f6c,0x47(%rbx),%esi
 b34:	6c                   	insb   (%dx),%es:(%rdi)
 b35:	4c 72 75             	rex.WR jb bad <balancer_ingress+0xbad>
 b38:	00 63 75             	add    %ah,0x75(%rbx)
 b3b:	72 5f                	jb     b9c <balancer_ingress+0xb9c>
 b3d:	74 69                	je     ba8 <balancer_ingress+0xba8>
 b3f:	6d                   	insl   (%dx),%es:(%rdi)
 b40:	65 00 63 68          	add    %ah,%gs:0x68(%rbx)
 b44:	65 63 6b 5f          	movsxd %gs:0x5f(%rbx),%ebp
  if (!lru_map) {
 b48:	75 64                	jne    bae <balancer_ingress+0xbae>
 b4a:	70 5f                	jo     bab <balancer_ingress+0xbab>
 b4c:	66 6c                	data16 insb (%dx),%es:(%rdi)
 b4e:	6f                   	outsl  %ds:(%rsi),(%dx)
 b4f:	77 5f                	ja     bb0 <balancer_ingress+0xbb0>
 b51:	6d                   	insl   (%dx),%es:(%rdi)
 b52:	69 67 72 61 74 69 6f 	imul   $0x6f697461,0x72(%rdi),%esp
  if ((vip_info->flags & F_QUIC_VIP)) {
 b59:	6e                   	outsb  %ds:(%rsi),(%dx)
 b5a:	00 64 6f 77          	add    %ah,0x77(%rdi,%rbp,2)
 b5e:	6e                   	outsb  %ds:(%rsi),(%dx)
 b5f:	5f                   	pop    %rdi
 b60:	72 65                	jb     bc7 <balancer_ingress+0xbc7>
    bool is_icmp = (pckt.flags & F_ICMP);
 b62:	61                   	(bad)
 b63:	6c                   	insb   (%dx),%es:(%rdi)
 b64:	00 73 74             	add    %dh,0x74(%rbx)
    if (is_icmp) {
 b67:	61                   	(bad)
 b68:	74 73                	je     bdd <balancer_ingress+0xbdd>
 b6a:	5f                   	pop    %rdi
 b6b:	64 61                	fs (bad)
 b6d:	74 61                	je     bd0 <balancer_ingress+0xbd0>
 b6f:	00 69 73             	add    %ch,0x73(%rcx)
 b72:	5f                   	pop    %rdi
 b73:	75 6e                	jne    be3 <balancer_ingress+0xbe3>
 b75:	64 65 72 5f          	fs gs jb bd8 <balancer_ingress+0xbd8>
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
 b79:	66 6c                	data16 insb (%dx),%es:(%rdi)
 b7b:	6f                   	outsl  %ds:(%rsi),(%dx)
 b7c:	6f                   	outsl  %ds:(%rsi),(%dx)
 b7d:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
 b81:	6e                   	outsb  %ds:(%rsi),(%dx)
 b82:	6e                   	outsb  %ds:(%rsi),(%dx)
 b83:	5f                   	pop    %rdi
 b84:	72 61                	jb     be7 <balancer_ingress+0xbe7>
 b86:	74 65                	je     bed <balancer_ingress+0xbed>
      if (!quic_packets_stats) {
 b88:	5f                   	pop    %rdi
 b89:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 b8d:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
 b90:	6e                   	outsb  %ds:(%rsi),(%dx)
 b91:	5f                   	pop    %rdi
 b92:	72 61                	jb     bf5 <balancer_ingress+0xbf5>
  bool is_icmp = (pckt->flags & F_ICMP);
 b94:	74 65                	je     bfb <balancer_ingress+0xbfb>
 b96:	5f                   	pop    %rdi
 b97:	73 74                	jae    c0d <balancer_ingress+0xc0d>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
 b99:	61                   	(bad)
 b9a:	74 73                	je     c0f <balancer_ingress+0xc0f>
 b9c:	00 69 6e             	add    %ch,0x6e(%rcx)
 b9f:	63 72 5f             	movsxd 0x5f(%rdx),%esi
 ba2:	73 65                	jae    c09 <balancer_ingress+0xc09>
 ba4:	72 76                	jb     c1c <balancer_ingress+0xc1c>
 ba6:	65 72 5f             	gs jb  c08 <balancer_ingress+0xc08>
 ba9:	69 64 5f 72 6f 75 74 	imul   $0x6974756f,0x72(%rdi,%rbx,2),%esp
 bb0:	69 
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
 bb1:	6e                   	outsb  %ds:(%rsi),(%dx)
 bb2:	67 5f                	addr32 pop %rdi
 bb4:	73 74                	jae    c2a <balancer_ingress+0xc2a>
 bb6:	61                   	(bad)
 bb7:	74 73                	je     c2c <balancer_ingress+0xc2c>
 bb9:	00 6e 65             	add    %ch,0x65(%rsi)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
 bbc:	77 43                	ja     c01 <balancer_ingress+0xc01>
 bbe:	6f                   	outsl  %ds:(%rsi),(%dx)
 bbf:	6e                   	outsb  %ds:(%rsi),(%dx)
 bc0:	6e                   	outsb  %ds:(%rsi),(%dx)
 bc1:	00 6d 69             	add    %ch,0x69(%rbp)
 bc4:	73 4d                	jae    c13 <balancer_ingress+0xc13>
 bc6:	61                   	(bad)
 bc7:	74 63                	je     c2c <balancer_ingress+0xc2c>
 bc9:	68 49 6e 4c 52       	push   $0x524c6e49
    vip.port = 0;
 bce:	55                   	push   %rbp
 bcf:	00 70 65             	add    %dh,0x65(%rax)
 bd2:	72 5f                	jb     c33 <balancer_ingress+0xc33>
 bd4:	76 69                	jbe    c3f <balancer_ingress+0xc3f>
 bd6:	70 5f                	jo     c37 <balancer_ingress+0xc37>
 bd8:	73 74                	jae    c4e <balancer_ingress+0xc4e>
 bda:	61                   	(bad)
 bdb:	74 73                	je     c50 <balancer_ingress+0xc50>
 bdd:	00 65 6e             	add    %ah,0x6e(%rbp)
 be0:	63 61 70             	movsxd 0x70(%rcx),%esp
    if (!vip_info) {
 be3:	5f                   	pop    %rdi
 be4:	76 34                	jbe    c1a <balancer_ingress+0xc1a>
 be6:	00 69 70             	add    %ch,0x70(%rcx)
 be9:	5f                   	pop    %rdi
 bea:	73 72                	jae    c5e <balancer_ingress+0xc5e>
 bec:	63 00                	movsxd (%rax),%eax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 bee:	6e                   	outsb  %ds:(%rsi),(%dx)
 bef:	65 77 5f             	gs ja  c51 <balancer_ingress+0xc51>
 bf2:	65 74 68             	gs je  c5d <balancer_ingress+0xc5d>
 bf5:	00 68 5f             	add    %ch,0x5f(%rax)
      pckt.flow.port16[1] = 0;
 bf8:	64 65 73 74          	fs gs jae c70 <balancer_ingress+0xc70>
 bfc:	00 68 5f             	add    %ch,0x5f(%rax)
 bff:	73 6f                	jae    c70 <balancer_ingress+0xc70>
 c01:	75 72                	jne    c75 <balancer_ingress+0xc75>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 c03:	63 65 00             	movsxd 0x0(%rbp),%esp
 c06:	65 74 68             	gs je  c71 <balancer_ingress+0xc71>
 c09:	68 64 72 00 6f       	push   $0x6f007264
 c0e:	6c                   	insb   (%dx),%es:(%rdi)
 c0f:	64 5f                	fs pop %rdi
 c11:	65 74 68             	gs je  c7c <balancer_ingress+0xc7c>
 c14:	00 63 72             	add    %ah,0x72(%rbx)
 c17:	65 61                	gs (bad)
 c19:	74 65                	je     c80 <balancer_ingress+0xc80>
 c1b:	5f                   	pop    %rdi
      if (!data_stats) {
 c1c:	76 34                	jbe    c52 <balancer_ingress+0xc52>
 c1e:	5f                   	pop    %rdi
 c1f:	68 64 72 00 67       	push   $0x67007264
 c24:	65 74 5f             	gs je  c86 <balancer_ingress+0xc86>
      data_stats->v1 += 1;
 c27:	70 61                	jo     c8a <balancer_ingress+0xc8a>
 c29:	63 6b 65             	movsxd 0x65(%rbx),%ebp
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
 c2c:	74 5f                	je     c8d <balancer_ingress+0xc8d>
 c2e:	64 73 74             	fs jae ca5 <balancer_ingress+0xca5>
 c31:	00 6e 65             	add    %ch,0x65(%rsi)
 c34:	77 5f                	ja     c95 <balancer_ingress+0xc95>
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
 c36:	64 73 74             	fs jae cad <balancer_ingress+0xcad>
 c39:	5f                   	pop    %rdi
 c3a:	6c                   	insb   (%dx),%es:(%rdi)
 c3b:	72 75                	jb     cb2 <balancer_ingress+0xcb2>
        data_stats->v2 += 1;
 c3d:	00 73 72             	add    %dh,0x72(%rbx)
 c40:	63 5f 66             	movsxd 0x66(%rdi),%ebx
 c43:	6f                   	outsl  %ds:(%rsi),(%dx)
 c44:	75 6e                	jne    cb4 <balancer_ingress+0xcb4>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 c46:	64 00 68 61          	add    %ch,%fs:0x61(%rax)
 c4a:	73 68                	jae    cb4 <balancer_ingress+0xcb4>
 c4c:	5f                   	pop    %rdi
 c4d:	31 36                	xor    %esi,(%rsi)
 c4f:	62                   	(bad)
 c50:	79 74                	jns    cc6 <balancer_ingress+0xcc6>
 c52:	65 73 00             	gs jae c55 <balancer_ingress+0xc55>
 c55:	67 65 74 5f          	addr32 gs je cb8 <balancer_ingress+0xcb8>
 c59:	70 61                	jo     cbc <balancer_ingress+0xcbc>
 c5b:	63 6b 65             	movsxd 0x65(%rbx),%ebp
  if (!lru_map) {
 c5e:	74 5f                	je     cbf <balancer_ingress+0xcbf>
 c60:	68 61 73 68 00       	push   $0x687361
 c65:	5f                   	pop    %rdi
 c66:	5f                   	pop    %rdi
 c67:	6a 68                	push   $0x68
 c69:	61                   	(bad)
 c6a:	73 68                	jae    cd4 <balancer_ingress+0xcd4>
  if ((vip_info->flags & F_QUIC_VIP)) {
 c6c:	5f                   	pop    %rdi
 c6d:	6e                   	outsb  %ds:(%rsi),(%dx)
 c6e:	77 6f                	ja     cdf <balancer_ingress+0xcdf>
 c70:	72 64                	jb     cd6 <balancer_ingress+0xcd6>
 c72:	73 00                	jae    c74 <balancer_ingress+0xc74>
 c74:	62                   	(bad)
    bool is_icmp = (pckt.flags & F_ICMP);
 c75:	00 69 6e             	add    %ch,0x6e(%rcx)
 c78:	69 74 76 61 6c 00 6a 	imul   $0x686a006c,0x61(%rsi,%rsi,2),%esi
 c7f:	68 
 c80:	61                   	(bad)
 c81:	73 68                	jae    ceb <balancer_ingress+0xceb>
 c83:	5f                   	pop    %rdi
 c84:	32 77 6f             	xor    0x6f(%rdi),%dh
 c87:	72 64                	jb     ced <balancer_ingress+0xced>
 c89:	73 00                	jae    c8b <balancer_ingress+0xc8b>
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
 c8b:	72 6f                	jb     cfc <balancer_ingress+0xcfc>
 c8d:	6c                   	insb   (%dx),%es:(%rdi)
 c8e:	33 32                	xor    (%rdx),%esi
 c90:	00 77 6f             	add    %dh,0x6f(%rdi)
 c93:	72 64                	jb     cf9 <balancer_ingress+0xcf9>
 c95:	00 73 68             	add    %dh,0x68(%rbx)
 c98:	69 66 74 00 69 6e 63 	imul   $0x636e6900,0x74(%rsi),%esp
      if (!quic_packets_stats) {
 c9f:	72 65                	jb     d06 <balancer_ingress+0xd06>
 ca1:	6d                   	insl   (%dx),%es:(%rdi)
 ca2:	65 6e                	outsb  %gs:(%rsi),(%dx)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
 ca4:	74 5f                	je     d05 <balancer_ingress+0xd05>
 ca6:	63 68 5f             	movsxd 0x5f(%rax),%ebp
  bool is_icmp = (pckt->flags & F_ICMP);
 ca9:	64 72 6f             	fs jb  d1b <balancer_ingress+0xd1b>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
 cac:	70 5f                	jo     d0d <balancer_ingress+0xd0d>
 cae:	6e                   	outsb  %ds:(%rsi),(%dx)
 caf:	6f                   	outsl  %ds:(%rsi),(%dx)
 cb0:	5f                   	pop    %rdi
 cb1:	72 65                	jb     d18 <balancer_ingress+0xd18>
 cb3:	61                   	(bad)
 cb4:	6c                   	insb   (%dx),%es:(%rdi)
 cb5:	00 63 68             	add    %ah,0x68(%rbx)
 cb8:	5f                   	pop    %rdi
 cb9:	64 72 6f             	fs jb  d2b <balancer_ingress+0xd2b>
 cbc:	70 5f                	jo     d1d <balancer_ingress+0xd1d>
 cbe:	73 74                	jae    d34 <balancer_ingress+0xd34>
 cc0:	61                   	(bad)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
 cc1:	74 73                	je     d36 <balancer_ingress+0xd36>
 cc3:	5f                   	pop    %rdi
 cc4:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 cc8:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 ccb:	64 72 6f             	fs jb  d3d <balancer_ingress+0xd3d>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
 cce:	70 5f                	jo     d2f <balancer_ingress+0xd2f>
 cd0:	73 74                	jae    d46 <balancer_ingress+0xd46>
 cd2:	61                   	(bad)
 cd3:	74 73                	je     d48 <balancer_ingress+0xd48>
 cd5:	00 69 6e             	add    %ch,0x6e(%rcx)
  if (!connId) {
 cd8:	63 72 65             	movsxd 0x65(%rdx),%esi
  __u8 connIdVersion = (connId[0] >> 6);
 cdb:	6d                   	insl   (%dx),%es:(%rdi)
 cdc:	65 6e                	outsb  %gs:(%rsi),(%dx)
 cde:	74 5f                	je     d3f <balancer_ingress+0xd3f>
 ce0:	63 68 5f             	movsxd 0x5f(%rax),%ebp
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
 ce3:	64 72 6f             	fs jb  d55 <balancer_ingress+0xd55>
 ce6:	70 5f                	jo     d47 <balancer_ingress+0xd47>
 ce8:	72 65                	jb     d4f <balancer_ingress+0xd4f>
 cea:	61                   	(bad)
 ceb:	6c                   	insb   (%dx),%es:(%rdi)
 cec:	5f                   	pop    %rdi
 ced:	30 00                	xor    %al,(%rax)
 cef:	65 6e                	outsb  %gs:(%rsi),(%dx)
 cf1:	63 61 70             	movsxd 0x70(%rcx),%esp
 cf4:	5f                   	pop    %rdi
 cf5:	76 36                	jbe    d2d <balancer_ingress+0xd2d>
 cf7:	00 63 72             	add    %ah,0x72(%rbx)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
 cfa:	65 61                	gs (bad)
 cfc:	74 65                	je     d63 <balancer_ingress+0xd63>
 cfe:	5f                   	pop    %rdi
 cff:	65 6e                	outsb  %gs:(%rsi),(%dx)
 d01:	63 61 70             	movsxd 0x70(%rcx),%esp
 d04:	5f                   	pop    %rdi
 d05:	69 70 76 36 5f 73 72 	imul   $0x72735f36,0x76(%rax),%esi
 d0c:	63 00                	movsxd (%rax),%eax
 d0e:	63 72 65             	movsxd 0x65(%rdx),%esi
 d11:	61                   	(bad)
 d12:	74 65                	je     d79 <balancer_ingress+0xd79>
 d14:	5f                   	pop    %rdi
 d15:	76 36                	jbe    d4d <balancer_ingress+0xd4d>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 d17:	5f                   	pop    %rdi
 d18:	68 64 72 00 74       	push   $0x74007264
 d1d:	63 00                	movsxd (%rax),%eax
 d1f:	69 6e 63 72 65 6d 65 	imul   $0x656d6572,0x63(%rsi),%ebp
 d26:	6e                   	outsb  %ds:(%rsi),(%dx)
 d27:	74 5f                	je     d88 <balancer_ingress+0xd88>
 d29:	71 75                	jno    da0 <balancer_ingress+0xda0>
 d2b:	69 63 5f 63 69 64 5f 	imul   $0x5f646963,0x5f(%rbx),%esp
      if (!data_stats) {
 d32:	76 65                	jbe    d99 <balancer_ingress+0xd99>
 d34:	72 73                	jb     da9 <balancer_ingress+0xda9>
 d36:	69 6f 6e 5f 73 74 61 	imul   $0x6174735f,0x6e(%rdi),%ebp
      data_stats->v1 += 1;
 d3d:	74 73                	je     db2 <balancer_ingress+0xdb2>
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
 d3f:	00 62 70             	add    %ah,0x70(%rdx)
 d42:	66 5f                	pop    %di
 d44:	6d                   	insl   (%dx),%es:(%rdi)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
 d45:	61                   	(bad)
 d46:	70 5f                	jo     da7 <balancer_ingress+0xda7>
        data_stats->v2 += 1;
 d48:	75 70                	jne    dba <balancer_ingress+0xdba>
 d4a:	64 61                	fs (bad)
 d4c:	74 65                	je     db3 <balancer_ingress+0xdb3>
 d4e:	5f                   	pop    %rdi
 d4f:	65 6c                	gs insb (%dx),%es:(%rdi)
  original_sport = pckt.flow.port16[0];
 d51:	65 6d                	gs insl (%dx),%es:(%rdi)
 d53:	00 75 70             	add    %dh,0x70(%rbp)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
 d56:	64 61                	fs (bad)
 d58:	74 65                	je     dbf <balancer_ingress+0xdbf>
 d5a:	5f                   	pop    %rdi
 d5b:	76 69                	jbe    dc6 <balancer_ingress+0xdc6>
 d5d:	70 5f                	jo     dbe <balancer_ingress+0xdbe>
 d5f:	6c                   	insb   (%dx),%es:(%rdi)
 d60:	72 75                	jb     dd7 <balancer_ingress+0xdd7>
        !(vip_info->flags & F_LRU_BYPASS)) {
 d62:	5f                   	pop    %rdi
 d63:	6d                   	insl   (%dx),%es:(%rdi)
 d64:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 d6b:	74 73                	je     de0 <balancer_ingress+0xde0>
 d6d:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
 d71:	5f                   	pop    %rdi
 d72:	6d                   	insl   (%dx),%es:(%rdi)
 d73:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
  if (!dst_lru) {
 d7a:	74 5f                	je     ddb <balancer_ingress+0xddb>
 d7c:	76 69                	jbe    de7 <balancer_ingress+0xde7>
 d7e:	70 00                	jo     d80 <balancer_ingress+0xd80>
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
 d80:	76 69                	jbe    deb <balancer_ingress+0xdeb>
 d82:	70 5f                	jo     de3 <balancer_ingress+0xde3>
 d84:	6d                   	insl   (%dx),%es:(%rdi)
 d85:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 d8c:	74 73                	je     e01 <balancer_ingress+0xe01>
 d8e:	5f                   	pop    %rdi
 d8f:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
 d93:	61                   	(bad)
 d94:	64 64 72 65          	fs fs jb dfd <balancer_ingress+0xdfd>
 d98:	73 73                	jae    e0d <balancer_ingress+0xe0d>
 d9a:	5f                   	pop    %rdi
 d9b:	6d                   	insl   (%dx),%es:(%rdi)
 d9c:	61                   	(bad)
 d9d:	74 63                	je     e02 <balancer_ingress+0xe02>
 d9f:	68 00 70 6f 72       	push   $0x726f7000
 da4:	74 5f                	je     e05 <balancer_ingress+0xe05>
 da6:	6d                   	insl   (%dx),%es:(%rdi)
 da7:	61                   	(bad)
 da8:	74 63                	je     e0d <balancer_ingress+0xe0d>
 daa:	68 00 70 72 6f       	push   $0x6f727000
 daf:	74 6f                	je     e20 <balancer_ingress+0xe20>
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
 db1:	5f                   	pop    %rdi
 db2:	6d                   	insl   (%dx),%es:(%rdi)
 db3:	61                   	(bad)
 db4:	74 63                	je     e19 <balancer_ingress+0xe19>
 db6:	68 00 76 69 70       	push   $0x70697600
 dbb:	5f                   	pop    %rdi
 dbc:	6d                   	insl   (%dx),%es:(%rdi)
 dbd:	61                   	(bad)
 dbe:	74 63                	je     e23 <balancer_ingress+0xe23>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
 dc0:	68 00 6c 72 75       	push   $0x75726c00
 dc5:	5f                   	pop    %rdi
 dc6:	6d                   	insl   (%dx),%es:(%rdi)
 dc7:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
      bpf_map_lookup_elem(&stats, &conn_rate_key);
 dce:	74 00                	je     dd0 <balancer_ingress+0xdd0>
 dd0:	63 68 65             	movsxd 0x65(%rax),%ebp
 dd3:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 dd6:	61                   	(bad)
 dd7:	6e                   	outsb  %ds:(%rsi),(%dx)
 dd8:	64 5f                	fs pop %rdi
 dda:	75 70                	jne    e4c <balancer_ingress+0xe4c>
 ddc:	64 61                	fs (bad)
 dde:	74 65                	je     e45 <balancer_ingress+0xe45>
 de0:	5f                   	pop    %rdi
 de1:	72 65                	jb     e48 <balancer_ingress+0xe48>
 de3:	61                   	(bad)
  if (!conn_rate_stats) {
 de4:	6c                   	insb   (%dx),%es:(%rdi)
 de5:	5f                   	pop    %rdi
 de6:	69 6e 64 65 78 5f 69 	imul   $0x695f7865,0x64(%rsi),%ebp
 ded:	6e                   	outsb  %ds:(%rsi),(%dx)
 dee:	5f                   	pop    %rdi
 def:	6c                   	insb   (%dx),%es:(%rdi)
 df0:	72 75                	jb     e67 <balancer_ingress+0xe67>
 df2:	00 6a 68             	add    %ch,0x68(%rdx)
  *cur_time = bpf_ktime_get_ns();
 df5:	61                   	(bad)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
 df6:	73 68                	jae    e60 <balancer_ingress+0xe60>
 df8:	00 6c 65 6e          	add    %ch,0x6e(%rbp,%riz,2)
 dfc:	67 74 68             	addr32 je e67 <balancer_ingress+0xe67>
 dff:	00 44 57 5f          	add    %al,0x5f(%rdi,%rdx,2)
 e03:	41 54                	push   %r12
 e05:	45 5f                	rex.RB pop %r15
    conn_rate_stats->v1 = 1;
 e07:	75 6e                	jne    e77 <balancer_ingress+0xe77>
 e09:	73 69                	jae    e74 <balancer_ingress+0xe74>
 e0b:	67 6e                	outsb  %ds:(%esi),(%dx)
    conn_rate_stats->v2 = *cur_time;
 e0d:	65 64 5f             	gs fs pop %rdi
 e10:	38 00                	cmp    %al,(%rax)
 e12:	44 57                	rex.R push %rdi
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
 e14:	5f                   	pop    %rdi
 e15:	41 54                	push   %r12
 e17:	45 5f                	rex.RB pop %r15
 e19:	75 6e                	jne    e89 <balancer_ingress+0xe89>
 e1b:	73 69                	jae    e86 <balancer_ingress+0xe86>
 e1d:	67 6e                	outsb  %ds:(%esi),(%dx)
 e1f:	65 64 5f             	gs fs pop %rdi
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
 e22:	31 00                	xor    %eax,(%rax)
 e24:	44 57                	rex.R push %rdi
 e26:	5f                   	pop    %rdi
 e27:	41 54                	push   %r12
        quic_packets_stats->cid_initial += 1;
 e29:	45 5f                	rex.RB pop %r15
 e2b:	75 6e                	jne    e9b <balancer_ingress+0xe9b>
 e2d:	73 69                	jae    e98 <balancer_ingress+0xe98>
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
 e2f:	67 6e                	outsb  %ds:(%esi),(%dx)
 e31:	65 64 5f             	gs fs pop %rdi
 e34:	36 34 00             	ss xor $0x0,%al
 e37:	44 57                	rex.R push %rdi
 e39:	5f                   	pop    %rdi
 e3a:	41 54                	push   %r12
 e3c:	45 5f                	rex.RB pop %r15
 e3e:	75 6e                	jne    eae <balancer_ingress+0xeae>
 e40:	73 69                	jae    eab <balancer_ingress+0xeab>
 e42:	67 6e                	outsb  %ds:(%esi),(%dx)
 e44:	65 64 5f             	gs fs pop %rdi
 e47:	33 32                	xor    (%rdx),%esi
 e49:	00 44 57 5f          	add    %al,0x5f(%rdi,%rdx,2)
 e4d:	41 54                	push   %r12
 e4f:	45 5f                	rex.RB pop %r15
 e51:	75 6e                	jne    ec1 <balancer_ingress+0xec1>
 e53:	73 69                	jae    ebe <balancer_ingress+0xebe>
 e55:	67 6e                	outsb  %ds:(%esi),(%dx)
 e57:	65 64 5f             	gs fs pop %rdi
 e5a:	31 36                	xor    %esi,(%rsi)
 e5c:	00 62 61             	add    %ah,0x61(%rdx)
 e5f:	6c                   	insb   (%dx),%es:(%rdi)
 e60:	61                   	(bad)
  if (!per_vip_stats) {
 e61:	6e                   	outsb  %ds:(%rsi),(%dx)
 e62:	63 65 72             	movsxd 0x72(%rbp),%esp
 e65:	5f                   	pop    %rdi
 e66:	69 6e 67 72 65 73 73 	imul   $0x73736572,0x67(%rsi),%ebp
 e6d:	00 63 74             	add    %ah,0x74(%rbx)
    conn_rate_stats->v1 += 1;
 e70:	78 00                	js     e72 <balancer_ingress+0xe72>
 e72:	65 74 68             	gs je  edd <balancer_ingress+0xedd>
 e75:	5f                   	pop    %rdi
 e76:	70 72                	jo     eea <balancer_ingress+0xeea>
 e78:	6f                   	outsl  %ds:(%rsi),(%dx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
 e79:	74 6f                	je     eea <balancer_ingress+0xeea>
	...

Disassembly of section .debug_addr:

0000000000000000 <.debug_addr>:
  void* data = (void*)(long)ctx->data;
   0:	04 06                	add    $0x6,%al
   2:	00 00                	add    %al,(%rax)
   4:	05 00 08 00 9a       	add    $0x9a000800,%eax
   9:	20 00                	and    %al,(%rax)
   b:	00 00                	add    %al,(%rax)
   d:	00 00                	add    %al,(%rax)
   f:	00 00                	add    %al,(%rax)
  11:	a8 b4                	test   $0xb4,%al
  13:	07                   	(bad)
  14:	01 00                	add    %eax,(%rax)
  16:	11 ff                	adc    %edi,%edi
  void* data_end = (void*)(long)ctx->data_end;
  18:	00 e0                	add    %ah,%al
  1a:	f2 a3 01 00 11 ff 00 	repnz movabs %eax,0x7b4a400ff110001
  21:	a4 b4 07 
  if (data + nh_off > data_end) {
  24:	01 00                	add    %eax,(%rax)
  26:	11 ff                	adc    %edi,%edi
  28:	00 f0                	add    %dh,%al
  2a:	f2 a3 01 00 11 ff 00 	repnz movabs %eax,0xa3f2e800ff110001
  31:	e8 f2 a3 
  eth_proto = eth->h_proto;
  34:	01 00                	add    %eax,(%rax)
  if (eth_proto == BE_ETH_P_IP) {
  36:	11 ff                	adc    %edi,%edi
  38:	00 40 1c             	add    %al,0x1c(%rax)
  3b:	a1 01 00 11 ff 00 a0 	movabs 0x691fa000ff110001,%eax
  42:	1f 69 
  44:	01 00                	add    %eax,(%rax)
  46:	a0 ff 00 d0 1f 79 01 	movabs 0xa00001791fd000ff,%al
  4d:	00 a0 
  struct packet_description pckt = {};
  4f:	ff 00                	incl   (%rax)
  51:	70 21                	jo     74 <balancer_ingress+0x74>
  53:	79 01                	jns    56 <balancer_ingress+0x56>
  55:	00 a0 ff 00 10 22    	add    %ah,0x221000ff(%rax)
  5b:	79 01                	jns    5e <balancer_ingress+0x5e>
  5d:	00 a0 ff 00 b8 b4    	add    %ah,-0x4b47ff01(%rax)
  63:	07                   	(bad)
  64:	01 00                	add    %eax,(%rax)
  66:	11 ff                	adc    %edi,%edi
  68:	00 c0                	add    %al,%al
  6a:	96                   	xchg   %eax,%esi
  6b:	2e 01 00             	cs add %eax,(%rax)
  6e:	11 ff                	adc    %edi,%edi
  70:	00 b4 b4 07 01 00 11 	add    %dh,0x11000107(%rsp,%rsi,4)
  77:	ff 00                	incl   (%rax)
  79:	b0 b4                	mov    $0xb4,%al
  7b:	07                   	(bad)
  7c:	01 00                	add    %eax,(%rax)
  7e:	11 ff                	adc    %edi,%edi
  80:	00 80 e6 53 01 00    	add    %al,0x153e6(%rax)
  86:	11 ff                	adc    %edi,%edi
  88:	00 b0 22 79 01 00    	add    %dh,0x17922(%rax)
  bpf_tail_call(xdp, &subprograms, 0);
  8e:	a0 ff 00 bc b4 07 01 	movabs 0x11000107b4bc00ff,%al
  95:	00 11 
  97:	ff 00                	incl   (%rax)
  99:	c0 e6 53             	shl    $0x53,%dh
  9c:	01 00                	add    %eax,(%rax)
  9e:	11 ff                	adc    %edi,%edi
  a0:	00 c8                	add    %cl,%al
  a2:	ad                   	lods   %ds:(%rsi),%eax
  a3:	08 01                	or     %al,(%rcx)
  struct packet_description pckt = {};
  a5:	00 11                	add    %dl,(%rcx)
  a7:	ff 00                	incl   (%rax)
  a9:	00 00                	add    %al,(%rax)
  ab:	00 00                	add    %al,(%rax)
  ad:	00 00                	add    %al,(%rax)
  af:	00 8c 00 00 00 00 00 	add    %cl,0x0(%rax,%rax,1)
  b6:	00 00                	add    %al,(%rax)
  b8:	8b 01                	mov    (%rcx),%eax
  ba:	00 00                	add    %al,(%rax)
  bc:	00 00                	add    %al,(%rax)
  be:	00 00                	add    %al,(%rax)
  c0:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
  c1:	01 00                	add    %eax,(%rax)
  c3:	00 00                	add    %al,(%rax)
  c5:	00 00                	add    %al,(%rax)
  c7:	00 14 08             	add    %dl,(%rax,%rcx,1)
  ca:	00 00                	add    %al,(%rax)
  cc:	00 00                	add    %al,(%rax)
  ce:	00 00                	add    %al,(%rax)
  d0:	bb 04 00 00 00       	mov    $0x4,%ebx
  d5:	00 00                	add    %al,(%rax)
  d7:	00 13                	add    %dl,(%rbx)
  d9:	09 00                	or     %eax,(%rax)
  db:	00 00                	add    %al,(%rax)
  dd:	00 00                	add    %al,(%rax)
  df:	00 f3                	add    %dh,%bl
  e1:	04 00                	add    $0x0,%al
  e3:	00 00                	add    %al,(%rax)
  bpf_tail_call(xdp, &subprograms, 0);
  e5:	00 00                	add    %al,(%rax)
  e7:	00 f7                	add    %dh,%bh
  e9:	04 00                	add    $0x0,%al
  eb:	00 00                	add    %al,(%rax)
  ed:	00 00                	add    %al,(%rax)
  ef:	00 01                	add    %al,(%rcx)
  f1:	0a 00                	or     (%rax),%al
  f3:	00 00                	add    %al,(%rax)
  f5:	00 00                	add    %al,(%rax)
  f7:	00 05 0a 00 00 00    	add    %al,0xa(%rip)        # 107 <balancer_ingress+0x107>
  fd:	00 00                	add    %al,(%rax)
  ff:	00 aa 08 00 00 00    	add    %ch,0x8(%rdx)
  struct vip_definition vip = {};
 105:	00 00                	add    %al,(%rax)
 107:	00 c3                	add    %al,%bl
 109:	08 00                	or     %al,(%rax)
 10b:	00 00                	add    %al,(%rax)
 10d:	00 00                	add    %al,(%rax)
 10f:	00 eb                	add    %ch,%bl
 111:	08 00                	or     %al,(%rax)
 113:	00 00                	add    %al,(%rax)
 115:	00 00                	add    %al,(%rax)
 117:	00 9e 09 00 00 00    	add    %bl,0x9(%rsi)
    if (iph + 1 > data_end) {
 11d:	00 00                	add    %al,(%rax)
 11f:	00 b7 09 00 00 00    	add    %dh,0x9(%rdi)
 125:	00 00                	add    %al,(%rax)
 127:	00 df                	add    %bl,%bh
    if (iph->ihl != 5) {
 129:	09 00                	or     %eax,(%rax)
 12b:	00 00                	add    %al,(%rax)
 12d:	00 00                	add    %al,(%rax)
 12f:	00 63 0a             	add    %ah,0xa(%rbx)
 132:	00 00                	add    %al,(%rax)
 134:	00 00                	add    %al,(%rax)
    pckt->tos = iph->tos;
 136:	00 00                	add    %al,(%rax)
 138:	d3 0b                	rorl   %cl,(%rbx)
 13a:	00 00                	add    %al,(%rax)
    *protocol = iph->protocol;
 13c:	00 00                	add    %al,(%rax)
 13e:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
 140:	a3 0a 00 00 00 00 00 	movabs %eax,0xdb0000000000000a
 147:	00 db 
    if (iph->frag_off & PCKT_FRAGMENTED) {
 149:	0a 00                	or     (%rax),%al
 14b:	00 00                	add    %al,(%rax)
 14d:	00 00                	add    %al,(%rax)
 14f:	00 f2                	add    %dh,%dl
 151:	0a 00                	or     (%rax),%al
 153:	00 00                	add    %al,(%rax)
 155:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
 157:	00 8a 0c 00 00 00    	add    %cl,0xc(%rdx)
 15d:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 15f:	00 01                	add    %al,(%rcx)
 161:	0f 00 00             	sldt   (%rax)
 164:	00 00                	add    %al,(%rax)
 166:	00 00                	add    %al,(%rax)
 168:	89 1e                	mov    %ebx,(%rsi)
 16a:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
 16c:	00 00                	add    %al,(%rax)
 16e:	00 00                	add    %al,(%rax)
 170:	ad                   	lods   %ds:(%rsi),%eax
 171:	1e                   	(bad)
 172:	00 00                	add    %al,(%rax)
 174:	00 00                	add    %al,(%rax)
 176:	00 00                	add    %al,(%rax)
 178:	d7                   	xlat   %ds:(%rbx)
 179:	1e                   	(bad)
 17a:	00 00                	add    %al,(%rax)
 17c:	00 00                	add    %al,(%rax)
 17e:	00 00                	add    %al,(%rax)
 180:	b7 1f                	mov    $0x1f,%bh
 182:	00 00                	add    %al,(%rax)
 184:	00 00                	add    %al,(%rax)
 186:	00 00                	add    %al,(%rax)
 188:	6d                   	insl   (%dx),%es:(%rdi)
 189:	20 00                	and    %al,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
 18b:	00 00                	add    %al,(%rax)
 18d:	00 00                	add    %al,(%rax)
  icmp_hdr->checksum += 0x0008;
 18f:	00 07                	add    %al,(%rdi)
 191:	20 00                	and    %al,(%rax)
 193:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 195:	00 00                	add    %al,(%rax)
 197:	00 16                	add    %dl,(%rsi)
  iph->daddr = iph->saddr;
 199:	0d 00 00 00 00       	or     $0x0,%eax
 19e:	00 00                	add    %al,(%rax)
 1a0:	3e 0d 00 00 00 00    	ds or  $0x0,%eax
 1a6:	00 00                	add    %al,(%rax)
 1a8:	6c                   	insb   (%dx),%es:(%rdi)
 1a9:	0d 00 00 00 00       	or     $0x0,%eax
 1ae:	00 00                	add    %al,(%rax)
 1b0:	aa                   	stos   %al,%es:(%rdi)
 1b1:	0f 00 00             	sldt   (%rax)
 1b4:	00 00                	add    %al,(%rax)
 1b6:	00 00                	add    %al,(%rax)
 1b8:	ca 0d 00             	lret   $0xd
 1bb:	00 00                	add    %al,(%rax)
 1bd:	00 00                	add    %al,(%rax)
 1bf:	00 85 0e 00 00 00    	add    %al,0xe(%rbp)
 1c5:	00 00                	add    %al,(%rax)
 1c7:	00 a3 0e 00 00 00    	add    %ah,0xe(%rbx)
 1cd:	00 00                	add    %al,(%rax)
 1cf:	00 a8 0e 00 00 00    	add    %ch,0xe(%rax)
 1d5:	00 00                	add    %al,(%rax)
 1d7:	00 ba 0e 00 00 00    	add    %bh,0xe(%rdx)
 1dd:	00 00                	add    %al,(%rax)
 1df:	00 3e                	add    %bh,(%rsi)
 1e1:	11 00                	adc    %eax,(%rax)
 1e3:	00 00                	add    %al,(%rax)
 1e5:	00 00                	add    %al,(%rax)
 1e7:	00 84 11 00 00 00 00 	add    %al,0x0(%rcx,%rdx,1)
 1ee:	00 00                	add    %al,(%rax)
 1f0:	1a 12                	sbb    (%rdx),%dl
 1f2:	00 00                	add    %al,(%rax)
 1f4:	00 00                	add    %al,(%rax)
    if (ip6h + 1 > data_end) {
 1f6:	00 00                	add    %al,(%rax)
 1f8:	2c 12                	sub    $0x12,%al
 1fa:	00 00                	add    %al,(%rax)
 1fc:	00 00                	add    %al,(%rax)
 1fe:	00 00                	add    %al,(%rax)
 200:	35 12 00 00 00       	xor    $0x12,%eax
    *protocol = ip6h->nexthdr;
 205:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
 207:	00 3e                	add    %bh,(%rsi)
 209:	12 00                	adc    (%rax),%al
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 20b:	00 00                	add    %al,(%rax)
 20d:	00 00                	add    %al,(%rax)
 20f:	00 47 12             	add    %al,0x12(%rdi)
 212:	00 00                	add    %al,(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 214:	00 00                	add    %al,(%rax)
 216:	00 00                	add    %al,(%rax)
 218:	50                   	push   %rax
 219:	12 00                	adc    (%rax),%al
 21b:	00 00                	add    %al,(%rax)
 21d:	00 00                	add    %al,(%rax)
 21f:	00 59 12             	add    %bl,0x12(%rcx)
    if (*protocol == IPPROTO_FRAGMENT) {
 222:	00 00                	add    %al,(%rax)
 224:	00 00                	add    %al,(%rax)
 226:	00 00                	add    %al,(%rax)
 228:	60                   	(bad)
 229:	12 00                	adc    (%rax),%al
 22b:	00 00                	add    %al,(%rax)
 22d:	00 00                	add    %al,(%rax)
 22f:	00 e4                	add    %ah,%ah
 231:	12 00                	adc    (%rax),%al
 233:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 235:	00 00                	add    %al,(%rax)
 237:	00 b4 12 00 00 00 00 	add    %dh,0x0(%rdx,%rdx,1)
 23e:	00 00                	add    %al,(%rax)
 240:	bc 12 00 00 00       	mov    $0x12,%esp
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 245:	00 00                	add    %al,(%rax)
 247:	00 78 14             	add    %bh,0x14(%rax)
 24a:	00 00                	add    %al,(%rax)
 24c:	00 00                	add    %al,(%rax)
 24e:	00 00                	add    %al,(%rax)
 250:	98                   	cwtl
 251:	14 00                	adc    $0x0,%al
 253:	00 00                	add    %al,(%rax)
 255:	00 00                	add    %al,(%rax)
 257:	00 c3                	add    %al,%bl
 259:	14 00                	adc    $0x0,%al
 25b:	00 00                	add    %al,(%rax)
 25d:	00 00                	add    %al,(%rax)
 25f:	00 d8                	add    %bl,%al
 261:	0f 00 00             	sldt   (%rax)
 264:	00 00                	add    %al,(%rax)
 266:	00 00                	add    %al,(%rax)
 268:	25 10 00 00 00       	and    $0x10,%eax
 26d:	00 00                	add    %al,(%rax)
 26f:	00 74 10 00          	add    %dh,0x0(%rax,%rdx,1)
 273:	00 00                	add    %al,(%rax)
 275:	00 00                	add    %al,(%rax)
 277:	00 06                	add    %al,(%rsi)
 279:	11 00                	adc    %eax,(%rax)
 27b:	00 00                	add    %al,(%rax)
 27d:	00 00                	add    %al,(%rax)
 27f:	00 2b                	add    %ch,(%rbx)
 281:	11 00                	adc    %eax,(%rax)
 283:	00 00                	add    %al,(%rax)
 285:	00 00                	add    %al,(%rax)
 287:	00 36                	add    %dh,(%rsi)
 289:	13 00                	adc    (%rax),%eax
 28b:	00 00                	add    %al,(%rax)
 28d:	00 00                	add    %al,(%rax)
 28f:	00 aa 13 00 00 00    	add    %ch,0x13(%rdx)
 295:	00 00                	add    %al,(%rax)
 297:	00 b2 13 00 00 00    	add    %dh,0x13(%rdx)
 29d:	00 00                	add    %al,(%rax)
 29f:	00 e5                	add    %ah,%ch
 2a1:	00 00                	add    %al,(%rax)
 2a3:	00 00                	add    %al,(%rax)
 2a5:	00 00                	add    %al,(%rax)
 2a7:	00 27                	add    %ah,(%rdi)
 2a9:	05 00 00 00 00       	add    $0x0,%eax
 2ae:	00 00                	add    %al,(%rax)
 2b0:	30 03                	xor    %al,(%rbx)
 2b2:	00 00                	add    %al,(%rax)
 2b4:	00 00                	add    %al,(%rax)
 2b6:	00 00                	add    %al,(%rax)
 2b8:	5b                   	pop    %rbx
 2b9:	03 00                	add    (%rax),%eax
 2bb:	00 00                	add    %al,(%rax)
 2bd:	00 00                	add    %al,(%rax)
 2bf:	00 ae 06 00 00 00    	add    %ch,0x6(%rsi)
 2c5:	00 00                	add    %al,(%rax)
 2c7:	00 51 04             	add    %dl,0x4(%rcx)
 2ca:	00 00                	add    %al,(%rax)
 2cc:	00 00                	add    %al,(%rax)
 2ce:	00 00                	add    %al,(%rax)
 2d0:	55                   	push   %rbp
 2d1:	04 00                	add    $0x0,%al
 2d3:	00 00                	add    %al,(%rax)
 2d5:	00 00                	add    %al,(%rax)
 2d7:	00 68 06             	add    %ch,0x6(%rax)
 2da:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 2dc:	00 00                	add    %al,(%rax)
 2de:	00 00                	add    %al,(%rax)
 2e0:	6c                   	insb   (%dx),%es:(%rdi)
 2e1:	06                   	(bad)
 2e2:	00 00                	add    %al,(%rax)
 2e4:	00 00                	add    %al,(%rax)
 2e6:	00 00                	add    %al,(%rax)
 2e8:	b4 05                	mov    $0x5,%ah
 2ea:	00 00                	add    %al,(%rax)
 2ec:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2ee:	00 00                	add    %al,(%rax)
 2f0:	c8 05 00 00          	enter  $0x5,$0x0
 2f4:	00 00                	add    %al,(%rax)
 2f6:	00 00                	add    %al,(%rax)
 2f8:	f0 05 00 00 00 00    	lock add $0x0,%eax
 2fe:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 300:	0e                   	(bad)
 301:	06                   	(bad)
 302:	00 00                	add    %al,(%rax)
 304:	00 00                	add    %al,(%rax)
 306:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 308:	22 06                	and    (%rsi),%al
 30a:	00 00                	add    %al,(%rax)
 30c:	00 00                	add    %al,(%rax)
 30e:	00 00                	add    %al,(%rax)
 310:	4a 06                	rex.WX (bad)
 312:	00 00                	add    %al,(%rax)
 314:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
 316:	00 00                	add    %al,(%rax)
 318:	49 07                	rex.WB (bad)
 31a:	00 00                	add    %al,(%rax)
 31c:	00 00                	add    %al,(%rax)
 31e:	00 00                	add    %al,(%rax)
 320:	7b 08                	jnp    32a <balancer_ingress+0x32a>
 322:	00 00                	add    %al,(%rax)
 324:	00 00                	add    %al,(%rax)
 326:	00 00                	add    %al,(%rax)
 328:	89 07                	mov    %eax,(%rdi)
 32a:	00 00                	add    %al,(%rax)
 32c:	00 00                	add    %al,(%rax)
 32e:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 330:	bc 07 00 00 00       	mov    $0x7,%esp
 335:	00 00                	add    %al,(%rax)
 337:	00 d3                	add    %dl,%bl
       sizeof(struct icmphdr)) > data_end) {
 339:	07                   	(bad)
 33a:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 33c:	00 00                	add    %al,(%rax)
 33e:	00 00                	add    %al,(%rax)
 340:	77 0b                	ja     34d <balancer_ingress+0x34d>
  icmp_hdr->type = ICMP_ECHOREPLY;
 342:	00 00                	add    %al,(%rax)
 344:	00 00                	add    %al,(%rax)
  icmp_hdr->checksum += 0x0008;
 346:	00 00                	add    %al,(%rax)
 348:	2e 0e                	cs (bad)
 34a:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 34c:	00 00                	add    %al,(%rax)
 34e:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
 350:	59                   	pop    %rcx
 351:	15 00 00 00 00       	adc    $0x0,%eax
 356:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
 358:	7c 15                	jl     36f <balancer_ingress+0x36f>
 35a:	00 00                	add    %al,(%rax)
 35c:	00 00                	add    %al,(%rax)
 35e:	00 00                	add    %al,(%rax)
 360:	aa                   	stos   %al,%es:(%rdi)
 361:	15 00 00 00 00       	adc    $0x0,%eax
 366:	00 00                	add    %al,(%rax)
 368:	20 1e                	and    %bl,(%rsi)
 36a:	00 00                	add    %al,(%rax)
 36c:	00 00                	add    %al,(%rax)
 36e:	00 00                	add    %al,(%rax)
 370:	8a 1f                	mov    (%rdi),%bl
 372:	00 00                	add    %al,(%rax)
 374:	00 00                	add    %al,(%rax)
 376:	00 00                	add    %al,(%rax)
 378:	24 1f                	and    $0x1f,%al
 37a:	00 00                	add    %al,(%rax)
 37c:	00 00                	add    %al,(%rax)
 37e:	00 00                	add    %al,(%rax)
 380:	02 0c 00             	add    (%rax,%rax,1),%cl
 383:	00 00                	add    %al,(%rax)
 385:	00 00                	add    %al,(%rax)
 387:	00 2a                	add    %ch,(%rdx)
 389:	0c 00                	or     $0x0,%al
 38b:	00 00                	add    %al,(%rax)
 38d:	00 00                	add    %al,(%rax)
 38f:	00 02                	add    %al,(%rdx)
 391:	16                   	(bad)
 392:	00 00                	add    %al,(%rax)
 394:	00 00                	add    %al,(%rax)
 396:	00 00                	add    %al,(%rax)
 398:	56                   	push   %rsi
 399:	16                   	(bad)
 39a:	00 00                	add    %al,(%rax)
 39c:	00 00                	add    %al,(%rax)
 39e:	00 00                	add    %al,(%rax)
 3a0:	75 16                	jne    3b8 <balancer_ingress+0x3b8>
 3a2:	00 00                	add    %al,(%rax)
 3a4:	00 00                	add    %al,(%rax)
 3a6:	00 00                	add    %al,(%rax)
 3a8:	8a 16                	mov    (%rsi),%dl
 3aa:	00 00                	add    %al,(%rax)
 3ac:	00 00                	add    %al,(%rax)
 3ae:	00 00                	add    %al,(%rax)
 3b0:	e8 16 00 00 00       	call   3cb <balancer_ingress+0x3cb>
 3b5:	00 00                	add    %al,(%rax)
 3b7:	00 02                	add    %al,(%rdx)
 3b9:	17                   	(bad)
 3ba:	00 00                	add    %al,(%rax)
 3bc:	00 00                	add    %al,(%rax)
 3be:	00 00                	add    %al,(%rax)
 3c0:	07                   	(bad)
 3c1:	17                   	(bad)
 3c2:	00 00                	add    %al,(%rax)
 3c4:	00 00                	add    %al,(%rax)
 3c6:	00 00                	add    %al,(%rax)
 3c8:	15 17 00 00 00       	adc    $0x17,%eax
 3cd:	00 00                	add    %al,(%rax)
 3cf:	00 37                	add    %dh,(%rdi)
 3d1:	19 00                	sbb    %eax,(%rax)
 3d3:	00 00                	add    %al,(%rax)
 3d5:	00 00                	add    %al,(%rax)
 3d7:	00 7d 19             	add    %bh,0x19(%rbp)
 3da:	00 00                	add    %al,(%rax)
 3dc:	00 00                	add    %al,(%rax)
 3de:	00 00                	add    %al,(%rax)
 3e0:	40 1a 00             	rex sbb (%rax),%al
 3e3:	00 00                	add    %al,(%rax)
 3e5:	00 00                	add    %al,(%rax)
 3e7:	00 57 1a             	add    %dl,0x1a(%rdi)
 3ea:	00 00                	add    %al,(%rax)
 3ec:	00 00                	add    %al,(%rax)
 3ee:	00 00                	add    %al,(%rax)
 3f0:	60                   	(bad)
 3f1:	1a 00                	sbb    (%rax),%al
 3f3:	00 00                	add    %al,(%rax)
 3f5:	00 00                	add    %al,(%rax)
 3f7:	00 6d 1a             	add    %ch,0x1a(%rbp)
 3fa:	00 00                	add    %al,(%rax)
 3fc:	00 00                	add    %al,(%rax)
 3fe:	00 00                	add    %al,(%rax)
 400:	78 1a                	js     41c <balancer_ingress+0x41c>
 402:	00 00                	add    %al,(%rax)
 404:	00 00                	add    %al,(%rax)
 406:	00 00                	add    %al,(%rax)
 408:	83 1a 00             	sbbl   $0x0,(%rdx)
 40b:	00 00                	add    %al,(%rax)
 40d:	00 00                	add    %al,(%rax)
 40f:	00 b2 1a 00 00 00    	add    %dh,0x1a(%rdx)
 415:	00 00                	add    %al,(%rax)
 417:	00 bb 1a 00 00 00    	add    %bh,0x1a(%rbx)
 41d:	00 00                	add    %al,(%rax)
 41f:	00 c4                	add    %al,%ah
 421:	1a 00                	sbb    (%rax),%al
 423:	00 00                	add    %al,(%rax)
 425:	00 00                	add    %al,(%rax)
 427:	00 cd                	add    %cl,%ch
 429:	1a 00                	sbb    (%rax),%al
 42b:	00 00                	add    %al,(%rax)
 42d:	00 00                	add    %al,(%rax)
 42f:	00 d6                	add    %dl,%dh
 431:	1a 00                	sbb    (%rax),%al
 433:	00 00                	add    %al,(%rax)
 435:	00 00                	add    %al,(%rax)
 437:	00 df                	add    %bl,%bh
  if (protocol == IPPROTO_IPIP) {
 439:	1a 00                	sbb    (%rax),%al
 43b:	00 00                	add    %al,(%rax)
 43d:	00 00                	add    %al,(%rax)
 43f:	00 e6                	add    %ah,%dh
 441:	1a 00                	sbb    (%rax),%al
 443:	00 00                	add    %al,(%rax)
 445:	00 00                	add    %al,(%rax)
 447:	00 e9                	add    %ch,%cl
 449:	1a 00                	sbb    (%rax),%al
 44b:	00 00                	add    %al,(%rax)
 44d:	00 00                	add    %al,(%rax)
 44f:	00 02                	add    %al,(%rdx)
  tcp = data + off;
 451:	1b 00                	sbb    (%rax),%eax
 453:	00 00                	add    %al,(%rax)
  if (is_ipv6) {
 455:	00 00                	add    %al,(%rax)
  tcp = data + off;
 457:	00 0b                	add    %cl,(%rbx)
 459:	1b 00                	sbb    (%rax),%eax
  if (tcp + 1 > data_end) {
 45b:	00 00                	add    %al,(%rax)
 45d:	00 00                	add    %al,(%rax)
 45f:	00 14 1b             	add    %dl,(%rbx,%rbx,1)
 462:	00 00                	add    %al,(%rax)
 464:	00 00                	add    %al,(%rax)
 466:	00 00                	add    %al,(%rax)
  if (tcp->syn) {
 468:	1d 1b 00 00 00       	sbb    $0x1b,%eax
 46d:	00 00                	add    %al,(%rax)
 46f:	00 26                	add    %ah,(%rsi)
 471:	1b 00                	sbb    (%rax),%eax
    pckt->flags |= F_SYN_SET;
 473:	00 00                	add    %al,(%rax)
 475:	00 00                	add    %al,(%rax)
 477:	00 2f                	add    %ch,(%rdi)
 479:	1b 00                	sbb    (%rax),%eax
      pckt->flow.src = iph->saddr;
 47b:	00 00                	add    %al,(%rax)
 47d:	00 00                	add    %al,(%rax)
 47f:	00 36                	add    %dh,(%rsi)
 481:	1b 00                	sbb    (%rax),%eax
      pckt->flow.dst = iph->daddr;
 483:	00 00                	add    %al,(%rax)
 485:	00 00                	add    %al,(%rax)
 487:	00 af 1b 00 00 00    	add    %ch,0x1b(%rdi)
  if (icmp_hdr + 1 > data_end) {
 48d:	00 00                	add    %al,(%rax)
 48f:	00 86 1b 00 00 00    	add    %al,0x1b(%rsi)
 495:	00 00                	add    %al,(%rax)
 497:	00 8e 1b 00 00 00    	add    %cl,0x1b(%rsi)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 49d:	00 00                	add    %al,(%rax)
 49f:	00 eb                	add    %ch,%bl
 4a1:	1c 00                	sbb    $0x0,%al
 4a3:	00 00                	add    %al,(%rax)
 4a5:	00 00                	add    %al,(%rax)
 4a7:	00 0b                	add    %cl,(%rbx)
 4a9:	1d 00 00 00 00       	sbb    $0x0,%eax
 4ae:	00 00                	add    %al,(%rax)
 4b0:	61                   	(bad)
 4b1:	1d 00 00 00 00       	sbb    $0x0,%eax
 4b6:	00 00                	add    %al,(%rax)
 4b8:	4f 17                	rex.WRXB (bad)
 4ba:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 4bc:	00 00                	add    %al,(%rax)
 4be:	00 00                	add    %al,(%rax)
 4c0:	95                   	xchg   %eax,%ebp
 4c1:	17                   	(bad)
 4c2:	00 00                	add    %al,(%rax)
       sizeof(struct icmp6hdr)) > data_end) {
 4c4:	00 00                	add    %al,(%rax)
 4c6:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 4c8:	e2 17                	loop   4e1 <balancer_ingress+0x4e1>
 4ca:	00 00                	add    %al,(%rax)
 4cc:	00 00                	add    %al,(%rax)
 4ce:	00 00                	add    %al,(%rax)
 4d0:	72 18                	jb     4ea <balancer_ingress+0x4ea>
 4d2:	00 00                	add    %al,(%rax)
 4d4:	00 00                	add    %al,(%rax)
 4d6:	00 00                	add    %al,(%rax)
 4d8:	9a                   	(bad)
 4d9:	18 00                	sbb    %al,(%rax)
 4db:	00 00                	add    %al,(%rax)
 4dd:	00 00                	add    %al,(%rax)
 4df:	00 1a                	add    %bl,(%rdx)
 4e1:	1c 00                	sbb    $0x0,%al
 4e3:	00 00                	add    %al,(%rax)
 4e5:	00 00                	add    %al,(%rax)
 4e7:	00 7d 1c             	add    %bh,0x1c(%rbp)
 4ea:	00 00                	add    %al,(%rax)
 4ec:	00 00                	add    %al,(%rax)
 4ee:	00 00                	add    %al,(%rax)
 4f0:	89 1c 00             	mov    %ebx,(%rax,%rax,1)
  tcp = data + off;
 4f3:	00 00                	add    %al,(%rax)
 4f5:	00 00                	add    %al,(%rax)
  if (is_ipv6) {
 4f7:	00 9e 00 00 00 00    	add    %bl,0x0(%rsi)
  if (tcp + 1 > data_end) {
 4fd:	00 00                	add    %al,(%rax)
 4ff:	00 fb                	add    %bh,%bl
 501:	00 00                	add    %al,(%rax)
 503:	00 00                	add    %al,(%rax)
 505:	00 00                	add    %al,(%rax)
 507:	00 dd                	add    %bl,%ch
 509:	05 00 00 00 00       	add    $0x0,%eax
  if (tcp->syn) {
 50e:	00 00                	add    %al,(%rax)
 510:	37                   	(bad)
 511:	06                   	(bad)
 512:	00 00                	add    %al,(%rax)
    pckt->flags |= F_SYN_SET;
 514:	00 00                	add    %al,(%rax)
 516:	00 00                	add    %al,(%rax)
 518:	61                   	(bad)
 519:	07                   	(bad)
 51a:	00 00                	add    %al,(%rax)
 51c:	00 00                	add    %al,(%rax)
 51e:	00 00                	add    %al,(%rax)
 520:	89 08                	mov    %ecx,(%rax)
 522:	00 00                	add    %al,(%rax)
 524:	00 00                	add    %al,(%rax)
 526:	00 00                	add    %al,(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
 528:	d8 08                	fmuls  (%rax)
 52a:	00 00                	add    %al,(%rax)
 52c:	00 00                	add    %al,(%rax)
 52e:	00 00                	add    %al,(%rax)
 530:	cc                   	int3
 531:	09 00                	or     %eax,(%rax)
 533:	00 00                	add    %al,(%rax)
 535:	00 00                	add    %al,(%rax)
    if (!icmp_ptb_v6_stats) {
 537:	00 7b 0a             	add    %bh,0xa(%rbx)
 53a:	00 00                	add    %al,(%rax)
 53c:	00 00                	add    %al,(%rax)
 53e:	00 00                	add    %al,(%rax)
    icmp_ptb_v6_stats->v1 += 1;
 540:	e1 0b                	loope  54d <balancer_ingress+0x54d>
 542:	00 00                	add    %al,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 544:	00 00                	add    %al,(%rax)
 546:	00 00                	add    %al,(%rax)
 548:	77 0d                	ja     557 <balancer_ingress+0x557>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 54a:	00 00                	add    %al,(%rax)
 54c:	00 00                	add    %al,(%rax)
 54e:	00 00                	add    %al,(%rax)
 550:	93                   	xchg   %eax,%ebx
      icmp_ptb_v6_stats->v2 += 1;
 551:	0d 00 00 00 00       	or     $0x0,%eax
  if (ip6h + 1 > data_end) {
 556:	00 00                	add    %al,(%rax)
 558:	f6 0d 00 00 00 00 00 	testb  $0x0,0x0(%rip)        # 55f <balancer_ingress+0x55f>
 55f:	00 9a 0e 00 00 00    	add    %bl,0xe(%rdx)
  pckt->flow.proto = ip6h->nexthdr;
 565:	00 00                	add    %al,(%rax)
 567:	00 b1 0e 00 00 00    	add    %dh,0xe(%rcx)
  pckt->flags |= F_ICMP;
 56d:	00 00                	add    %al,(%rax)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 56f:	00 8b 10 00 00 00    	add    %cl,0x10(%rbx)
 575:	00 00                	add    %al,(%rax)
 577:	00 ae 11 00 00 00    	add    %ch,0x11(%rsi)
 57d:	00 00                	add    %al,(%rax)
 57f:	00 40 13             	add    %al,0x13(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 582:	00 00                	add    %al,(%rax)
 584:	00 00                	add    %al,(%rax)
 586:	00 00                	add    %al,(%rax)
 588:	8a 14 00             	mov    (%rax,%rax,1),%dl
 58b:	00 00                	add    %al,(%rax)
 58d:	00 00                	add    %al,(%rax)
 58f:	00 b5 15 00 00 00    	add    %dh,0x15(%rbp)
 595:	00 00                	add    %al,(%rax)
 597:	00 0d 16 00 00 00    	add    %cl,0x16(%rip)        # 5b3 <balancer_ingress+0x5b3>
 59d:	00 00                	add    %al,(%rax)
 59f:	00 25 16 00 00 00    	add    %ah,0x16(%rip)        # 5bb <balancer_ingress+0x5bb>
 5a5:	00 00                	add    %al,(%rax)
 5a7:	00 b6 16 00 00 00    	add    %dh,0x16(%rsi)
 5ad:	00 00                	add    %al,(%rax)
 5af:	00 fd                	add    %bh,%ch
 5b1:	16                   	(bad)
 5b2:	00 00                	add    %al,(%rax)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 5b4:	00 00                	add    %al,(%rax)
 5b6:	00 00                	add    %al,(%rax)
 5b8:	10 17                	adc    %dl,(%rdi)
 5ba:	00 00                	add    %al,(%rax)
 5bc:	00 00                	add    %al,(%rax)
 5be:	00 00                	add    %al,(%rax)
 5c0:	f9                   	stc
 5c1:	17                   	(bad)
 5c2:	00 00                	add    %al,(%rax)
 5c4:	00 00                	add    %al,(%rax)
 5c6:	00 00                	add    %al,(%rax)
 5c8:	a8 19                	test   $0x19,%al
 5ca:	00 00                	add    %al,(%rax)
 5cc:	00 00                	add    %al,(%rax)
 5ce:	00 00                	add    %al,(%rax)
 5d0:	24 1c                	and    $0x1c,%al
 5d2:	00 00                	add    %al,(%rax)
 5d4:	00 00                	add    %al,(%rax)
 5d6:	00 00                	add    %al,(%rax)
 5d8:	fd                   	std
 5d9:	1c 00                	sbb    $0x0,%al
 5db:	00 00                	add    %al,(%rax)
  if (decap_dst_flags) {
 5dd:	00 00                	add    %al,(%rax)
 5df:	00 4c 1e 00          	add    %cl,0x0(%rsi,%rbx,1)
 5e3:	00 00                	add    %al,(%rax)
 5e5:	00 00                	add    %al,(%rax)
 5e7:	00 e2                	add    %ah,%dl
 5e9:	1e                   	(bad)
 5ea:	00 00                	add    %al,(%rax)
 5ec:	00 00                	add    %al,(%rax)
 5ee:	00 00                	add    %al,(%rax)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 5f0:	9c                   	pushf
 5f1:	1f                   	(bad)
 5f2:	00 00                	add    %al,(%rax)
 5f4:	00 00                	add    %al,(%rax)
 5f6:	00 00                	add    %al,(%rax)
 5f8:	e3 1f                	jrcxz  619 <balancer_ingress+0x619>
 5fa:	00 00                	add    %al,(%rax)
 5fc:	00 00                	add    %al,(%rax)
 5fe:	00 00                	add    %al,(%rax)
    if (!data_stats) {
 600:	7f 20                	jg     622 <balancer_ingress+0x622>
 602:	00 00                	add    %al,(%rax)
 604:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_line:

0000000000000000 <.debug_line>:
  void* data = (void*)(long)ctx->data;
       0:	d7                   	xlat   %ds:(%rbx)
       1:	16                   	(bad)
       2:	00 00                	add    %al,(%rax)
       4:	05 00 08 00 19       	add    $0x19000800,%eax
       9:	02 00                	add    (%rax),%al
       b:	00 01                	add    %al,(%rcx)
       d:	01 01                	add    %eax,(%rcx)
       f:	fb                   	sti
      10:	0e                   	(bad)
      11:	0d 00 01 01 01       	or     $0x1010100,%eax
      16:	01 00                	add    %eax,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
      18:	00 00                	add    %al,(%rax)
      1a:	01 00                	add    %eax,(%rax)
  if (data + nh_off > data_end) {
      1c:	00 01                	add    %al,(%rcx)
      1e:	01 01                	add    %eax,(%rcx)
      20:	1f                   	(bad)
      21:	06                   	(bad)
      22:	00 00                	add    %al,(%rax)
      24:	00 00                	add    %al,(%rax)
      26:	2b 00                	sub    (%rax),%eax
      28:	00 00                	add    %al,(%rax)
      2a:	3c 00                	cmp    $0x0,%al
      2c:	00 00                	add    %al,(%rax)
      2e:	55                   	push   %rbp
      2f:	00 00                	add    %al,(%rax)
  eth_proto = eth->h_proto;
      31:	00 68 00             	add    %ch,0x0(%rax)
      34:	00 00                	add    %al,(%rax)
  if (eth_proto == BE_ETH_P_IP) {
      36:	97                   	xchg   %eax,%edi
      37:	00 00                	add    %al,(%rax)
      39:	00 03                	add    %al,(%rbx)
      3b:	01 1f                	add    %ebx,(%rdi)
      3d:	02 0f                	add    (%rdi),%cl
      3f:	05 1e 17 b3 00       	add    $0xb3171e,%eax
      44:	00 00                	add    %al,(%rax)
      46:	00 ef                	add    %ch,%bh
      48:	12 af 12 30 9f 50    	adc    0x509f3012(%rdi),%ch
  struct packet_description pckt = {};
      4e:	35 1b 98 bf 34       	xor    $0x34bf981b,%eax
      53:	7d ae                	jge    3 <balancer_ingress+0x3>
      55:	60                   	(bad)
      56:	2b d1                	sub    %ecx,%edx
      58:	00 00                	add    %al,(%rax)
      5a:	00 01                	add    %al,(%rcx)
      5c:	5b                   	pop    %rbx
      5d:	e9 d1 d0 ad 34       	jmp    34add133 <_license+0x34adb099>
      62:	bd 71 a1 66 7a       	mov    $0x7a66a171,%ebp
      67:	92                   	xchg   %eax,%edx
      68:	98                   	cwtl
      69:	70 c0                	jo     2b <balancer_ingress+0x2b>
      6b:	11 e5                	adc    %esp,%ebp
      6d:	00 00                	add    %al,(%rax)
      6f:	00 02                	add    %al,(%rdx)
      71:	b8 10 f2 70 73       	mov    $0x7370f210,%eax
      76:	3e 10 63 19          	ds adc %ah,0x19(%rbx)
      7a:	b6 7e                	mov    $0x7e,%dh
      7c:	f5                   	cmc
      7d:	12 c6                	adc    %dh,%al
      7f:	24 6e                	and    $0x6e,%al
      81:	f0 00 00             	lock add %al,(%rax)
      84:	00 01                	add    %al,(%rcx)
      86:	bc 5f e5 9e a4       	mov    $0xa49ee55f,%esp
      8b:	ca 18 d4             	lret   $0xd418
  bpf_tail_call(xdp, &subprograms, 0);
      8e:	61                   	(bad)
      8f:	6a 93                	push   $0xffffffffffffff93
      91:	aa                   	stos   %al,%es:(%rdi)
      92:	35 0e 3d 0b 03       	xor    $0x30b3d0e,%eax
      97:	01 00                	add    %eax,(%rax)
      99:	00 03                	add    %al,(%rbx)
      9b:	c0 ad e1 a1 a3 09 d6 	shrb   $0xd6,0x9a3a1e1(%rbp)
      a2:	89 6c e6 08          	mov    %ebp,0x8(%rsi,%riz,8)
  struct packet_description pckt = {};
      a6:	0a 51 a2             	or     -0x5e(%rcx),%dl
      a9:	d1 05 0b 01 00 00    	roll   0x10b(%rip)        # 1ba <balancer_ingress+0x1ba>
      af:	01 b5 26 23 e8 bc    	add    %esi,-0x4317dcda(%rbp)
      b5:	42 2f                	rex.X (bad)
      b7:	8a 08                	mov    (%rax),%cl
      b9:	35 23 90 b1 84       	xor    $0x84b19023,%eax
      be:	d4                   	(bad)
      bf:	30 1b                	xor    %bl,(%rbx)
      c1:	01 00                	add    %eax,(%rax)
      c3:	00 04 38             	add    %al,(%rax,%rdi,1)
      c6:	67 c0 bb 28 0e 1e 1f 	sarb   $0x5b,0x1f1e0e28(%ebx)
      cd:	5b 
      ce:	bb 64 f9 22 b8       	mov    $0xb822f964,%ebx
      d3:	73 24                	jae    f9 <balancer_ingress+0xf9>
      d5:	29 01                	sub    %eax,(%rcx)
      d7:	00 00                	add    %al,(%rax)
      d9:	04 1a                	add    $0x1a,%al
      db:	44 71 1e             	rex.R jno fc <balancer_ingress+0xfc>
      de:	c9                   	leave
      df:	6a fe                	push   $0xfffffffffffffffe
      e1:	11 5d c1             	adc    %ebx,-0x3f(%rbp)
      e4:	30 dc                	xor    %bl,%ah
  bpf_tail_call(xdp, &subprograms, 0);
      e6:	e0 25                	loopne 10d <balancer_ingress+0x10d>
      e8:	7a 60                	jp     14a <balancer_ingress+0x14a>
      ea:	2f                   	(bad)
      eb:	01 00                	add    %eax,(%rax)
      ed:	00 03                	add    %al,(%rbx)
      ef:	fc                   	cld
      f0:	de 28                	fisubrs (%rax)
      f2:	42 9f                	rex.X lahf
      f4:	cb                   	lret
      f5:	e6 6e                	out    %al,$0x6e
      f7:	10 9e 5f e5 b9 9c    	adc    %bl,-0x63461aa1(%rsi)
      fd:	cd 45                	int    $0x45
      ff:	34 01                	xor    $0x1,%al
     101:	00 00                	add    %al,(%rax)
  struct vip_definition vip = {};
     103:	01 dd                	add    %ebx,%ebp
     105:	5f                   	pop    %rdi
     106:	2d 0c a8 b9 51       	sub    $0x51b9a80c,%eax
     10b:	1e                   	(bad)
     10c:	8f a8 d1 c6          	(bad)
     110:	4e d3 b3 ac 43 01 00 	rex.WRX shlq %cl,0x143ac(%rbx)
     117:	00 05 02 65 bf 5d    	add    %al,0x5dbf6502(%rip)        # 5dbf661f <_license+0x5dbf4585>
    if (iph + 1 > data_end) {
     11d:	da 79 6c             	fidivrl 0x6c(%rcx)
     120:	c0 b0 02 70 b2 7d c7 	shlb   $0xc7,0x7db27002(%rax)
     127:	a1 8e 4b 01 00 00 01 	movabs 0x5c24010000014b8e,%eax
     12e:	24 5c 
    if (iph->ihl != 5) {
     130:	80 12 ea             	adcb   $0xea,(%rdx)
     133:	92                   	xchg   %eax,%edx
     134:	00 48 b4             	add    %cl,-0x4c(%rax)
    pckt->tos = iph->tos;
     137:	e4 bf                	in     $0xbf,%al
     139:	3b 10                	cmp    (%rax),%edx
     13b:	c5 7e 15             	(bad)
    *protocol = iph->protocol;
     13e:	59                   	pop    %rcx
    pckt->flow.proto = *protocol;
     13f:	01 00                	add    %eax,(%rax)
     141:	00 01                	add    %al,(%rcx)
    if (iph->frag_off & PCKT_FRAGMENTED) {
     143:	f0 b1 d3             	lock mov $0xd3,%cl
     146:	dc 61 ec             	fsubl  -0x14(%rcx)
     149:	02 2c e5 2a 49 e7 c4 	add    -0x3b18b6d6(,%riz,8),%ch
     150:	a9 2a d6 68 01       	test   $0x168d62a,%eax
     155:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
     157:	01 5a 90             	add    %ebx,-0x70(%rdx)
     15a:	58                   	pop    %rax
     15b:	46 07                	rex.RX (bad)
     15d:	61                   	(bad)
     15e:	27                   	(bad)
  if (icmp_hdr + 1 > data_end) {
     15f:	c3                   	ret
     160:	c1 4a e0 0e          	rorl   $0xe,-0x20(%rdx)
     164:	b0 62                	mov    $0x62,%al
     166:	0c ca                	or     $0xca,%al
     168:	75 01                	jne    16b <balancer_ingress+0x16b>
     16a:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
     16c:	01 8a eb 55 f9 37    	add    %ecx,0x37f955eb(%rdx)
     172:	57                   	push   %rdi
     173:	66 5e                	pop    %si
     175:	31 61 34             	xor    %esp,0x34(%rcx)
     178:	d7                   	xlat   %ds:(%rbx)
     179:	5b                   	pop    %rbx
     17a:	72 4a                	jb     1c6 <balancer_ingress+0x1c6>
     17c:	48 85 01             	test   %rax,(%rcx)
     17f:	00 00                	add    %al,(%rax)
     181:	03 5c 58 d0          	add    -0x30(%rax,%rbx,2),%ebx
     185:	77 e9                	ja     170 <balancer_ingress+0x170>
     187:	10 b6 c2 58 85 5d    	adc    %dh,0x5d8558c2(%rsi)
  icmp_hdr->type = ICMP_ECHOREPLY;
     18d:	ca 54 d0             	lret   $0xd054
  icmp_hdr->checksum += 0x0008;
     190:	ec                   	in     (%dx),%al
     191:	22 8a 01 00 00 03    	and    0x3000001(%rdx),%cl
  iph->ttl = DEFAULT_TTL;
     197:	d2 88 e3 08 e1 42    	rorb   %cl,0x42e108e3(%rax)
  tmp_addr = iph->daddr;
     19d:	e5 1c                	in     $0x1c,%eax
  iph->daddr = iph->saddr;
     19f:	48 e7 42             	rex.W out %eax,$0x42
  iph->saddr = tmp_addr;
     1a2:	2f                   	(bad)
     1a3:	4f bb aa 3f 91 01 00 	rex.WRXB movabs $0xfc03000001913faa,%r11
     1aa:	00 03 fc 
     1ad:	a1 88 9f 02 74 df 06 	movabs 0x496e06df74029f88,%eax
     1b4:	6e 49 
     1b6:	cf                   	iret
     1b7:	4d 8d b8 01 1e 52 01 	lea    0x1521e01(%r8),%r15
     1be:	00 00                	add    %al,(%rax)
     1c0:	03 a5 05 63 28 98    	add    -0x67d79cfb(%rbp),%esp
     1c6:	dc e5                	fsub   %st,%st(5)
     1c8:	46 63 8b 33 44 62 7d 	rex.RX movsxd 0x7d624433(%rbx),%r9d
     1cf:	33 4b 97             	xor    -0x69(%rbx),%ecx
     1d2:	01 00                	add    %eax,(%rax)
     1d4:	00 03                	add    %al,(%rbx)
     1d6:	c5 73 77             	(bad)
     1d9:	4d 0b 3c 9a          	or     (%r10,%rbx,4),%r15
     1dd:	61                   	(bad)
     1de:	b5 51                	mov    $0x51,%ch
     1e0:	0b e7                	or     %edi,%esp
     1e2:	5a                   	pop    %rdx
     1e3:	6f                   	outsl  %ds:(%rsi),(%dx)
     1e4:	f3 74 a0             	repz je 187 <balancer_ingress+0x187>
     1e7:	01 00                	add    %eax,(%rax)
     1e9:	00 03                	add    %al,(%rbx)
     1eb:	5c                   	pop    %rsp
     1ec:	57                   	push   %rdi
     1ed:	70 df                	jo     1ce <balancer_ingress+0x1ce>
     1ef:	b5 68                	mov    $0x68,%ch
     1f1:	97                   	xchg   %eax,%edi
     1f2:	d0 23                	shlb   (%rbx)
     1f4:	c1 9c 17 13 f3 42 24 	rcrl   $0xa6,0x2442f313(%rdi,%rdx,1)
     1fb:	a6 
    if (ip6h + 1 > data_end) {
     1fc:	01 00                	add    %eax,(%rax)
     1fe:	00 03                	add    %al,(%rbx)
     200:	45 bc 38 cb 16 db    	rex.RB mov $0xdb16cb38,%r12d
    pckt->flow.proto = *protocol;
     206:	bc 75 84 26 5a       	mov    $0x5a268475,%esp
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     20b:	fc                   	cld
     20c:	29 89 c9 cc ac 01    	sub    %ecx,0x1acccc9(%rcx)
     212:	00 00                	add    %al,(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     214:	03 16                	add    (%rsi),%edx
     216:	3f                   	(bad)
     217:	54                   	push   %rsp
     218:	fb                   	sti
     219:	1a f2                	sbb    %dl,%dh
     21b:	e2 1f                	loop   23c <balancer_ingress+0x23c>
     21d:	ea                   	(bad)
     21e:	41 0f 14 eb          	unpcklps %xmm11,%xmm5
    if (*protocol == IPPROTO_FRAGMENT) {
     222:	18 fa                	sbb    %bh,%dl
     224:	76 04                	jbe    22a <balancer_ingress+0x22a>
     226:	00 00                	add    %al,(%rax)
     228:	09 02                	or     %eax,(%rdx)
	...
     232:	03 b5 08 01 05 22    	add    0x22050108(%rbp),%esi
  if (icmp_hdr + 1 > data_end) {
     238:	0a 13                	or     (%rbx),%dl
     23a:	05 26 08 75 05       	add    $0x5750826,%eax
     23f:	0c 50                	or     $0x50,%al
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     241:	05 15 06 90 05       	add    $0x5900615,%eax
     246:	07                   	(bad)
     247:	3c 03                	cmp    $0x3,%al
     249:	c2 77 66             	ret    $0x6677
     24c:	05 14 06 03 c3       	add    $0xc3030614,%eax
     251:	08 3c 05 07 4c 06 03 	or     %bh,0x3064c07(,%rax,1)
     258:	bb 77 82 03 c5       	mov    $0xc5038277,%ebx
     25d:	08 58 05             	or     %bl,0x5(%rax)
     260:	1d 06 03 e8 7c       	sbb    $0x7ce80306,%eax
     265:	9e                   	sahf
     266:	05 03 02 40 14       	add    $0x14400203,%eax
     26b:	06                   	(bad)
     26c:	74 3c                	je     2aa <balancer_ingress+0x2aa>
     26e:	2e 05 1d 06 c6 05    	cs add $0x5c6061d,%eax
     274:	03 02                	add    (%rdx),%eax
     276:	40 14 06             	rex adc $0x6,%al
     279:	74 3c                	je     2b7 <balancer_ingress+0x2b7>
     27b:	66 05 19 06          	add    $0x619,%ax
     27f:	ca 04 09             	lret   $0x904
     282:	05 0d 03 b9 7e       	add    $0x7eb9030d,%eax
     287:	08 90 05 11 06 4a    	or     %dl,0x4a061105(%rax)
     28d:	05 09 3c 05 0e       	add    $0xe053c09,%eax
     292:	06                   	(bad)
     293:	6a 05                	push   $0x5
     295:	12 06                	adc    (%rsi),%al
     297:	4a 05 09 2e 05 16    	rex.WX add $0x16052e09,%rax
     29d:	06                   	(bad)
     29e:	6b 05 0f 06 3c 05 16 	imul   $0x16,0x53c060f(%rip),%eax        # 53c08b4 <_license+0x53be81a>
     2a5:	06                   	(bad)
     2a6:	4b 3d 05 0e 4e 05    	rex.WXB cmp $0x54e0e05,%rax
     2ac:	17                   	(bad)
     2ad:	06                   	(bad)
     2ae:	4a 05 09 66 04 00    	rex.WX add $0x46609,%rax
     2b4:	05 00 03 87 7c       	add    $0x7c870300,%eax
     2b9:	66 04 09             	data16 add $0x9,%al
     2bc:	05 13 06 03 fd       	add    $0xfd030613,%eax
     2c1:	03 4a 05             	add    0x5(%rdx),%ecx
     2c4:	09 06                	or     %eax,(%rsi)
     2c6:	2e 04 0b             	cs add $0xb,%al
     2c9:	05 10 06 03 9e       	add    $0x9e030610,%eax
     2ce:	7e 66                	jle    336 <balancer_ingress+0x336>
     2d0:	05 14 06 4a 05       	add    $0x54a0614,%eax
     2d5:	07                   	(bad)
     2d6:	3c 05                	cmp    $0x5,%al
     2d8:	11 06                	adc    %eax,(%rsi)
     2da:	69 05 07 06 4a 03 e2 	imul   $0x3907de2,0x34a0607(%rip),%eax        # 34a08eb <_license+0x349e851>
     2e1:	7d 90 03 
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     2e4:	9e                   	sahf
     2e5:	02 58 03             	add    0x3(%rax),%bl
     2e8:	e2 7d                	loop   367 <balancer_ingress+0x367>
     2ea:	90                   	nop
     2eb:	05 12 06 03 cf       	add    $0xcf030612,%eax
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2f0:	00 4a 05             	add    %cl,0x5(%rdx)
     2f3:	16                   	(bad)
     2f4:	4e 05 0c 59 05 15    	rex.WRX add $0x1505590c,%rax
     2fa:	4c 05 13 3b 05 0e    	rex.WR add $0xe053b13,%rax
  if (protocol == IPPROTO_ICMPV6) {
     300:	3d 3d 04 0c 03       	cmp    $0x30c043d,%eax
     305:	61                   	(bad)
     306:	3c 05                	cmp    $0x5,%al
  if (icmp_hdr + 1 > data_end) {
     308:	0b 06                	or     (%rsi),%eax
     30a:	08 3c 05 0e 3c 05 0b 	or     %bh,0xb053c0e(,%rax,1)
     311:	3c 05                	cmp    $0x5,%al
     313:	0e                   	(bad)
     314:	3c 05                	cmp    $0x5,%al
  if (icmp_hdr->type == ICMP_ECHO) {
     316:	0b 4a 04             	or     0x4(%rdx),%ecx
     319:	00 05 19 06 03 f9    	add    %al,-0x6fcf9e7(%rip)        # fffffffff9030938 <server_id_map+0x5ffffe7fe05938>
     31f:	04 08                	add    $0x8,%al
     321:	66 04 09             	data16 add $0x9,%al
     324:	05 0e 03 a0 7e       	add    $0x7ea0030e,%eax
     329:	08 90 05 12 06 4a    	or     %dl,0x4a061205(%rax)
     32f:	05 09 3c 05 17       	add    $0x17053c09,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     334:	06                   	(bad)
     335:	6b 05 16 3d 05 18 4d 	imul   $0x4d,0x18053d16(%rip),%eax        # 18054052 <_license+0x18051fb8>
     33c:	05 21 06 3c 05       	add    $0x53c0621,%eax
     341:	0f 3c                	(bad)
  icmp_hdr->type = ICMP_ECHOREPLY;
     343:	05 1f 06 4b 05       	add    $0x54b061f,%eax
  icmp_hdr->checksum += 0x0008;
     348:	1b 06                	sbb    (%rsi),%eax
     34a:	3c 05                	cmp    $0x5,%al
  iph->ttl = DEFAULT_TTL;
     34c:	0f 58 05 09 06 4e 05 	addps  0x54e0609(%rip),%xmm0        # 54e095c <_license+0x54de8c2>
  tmp_addr = iph->daddr;
     353:	00 06                	add    %al,(%rsi)
  iph->daddr = iph->saddr;
     355:	03 a1 7c 82 05 09    	add    0x905827c(%rcx),%esp
     35b:	03 df                	add    %edi,%ebx
     35d:	03 4a 04             	add    0x4(%rdx),%ecx
     360:	0b 05 10 06 03 8d    	or     -0x72fcf9f0(%rip),%eax        # ffffffff8d030976 <server_id_map+0x5ffffe13e05976>
     366:	7e 82                	jle    2ea <balancer_ingress+0x2ea>
     368:	05 14 06 4a 05       	add    $0x54a0614,%eax
     36d:	07                   	(bad)
     36e:	3c 05                	cmp    $0x5,%al
     370:	11 06                	adc    %eax,(%rsi)
     372:	69 05 07 06 4a 03 91 	imul   $0x3f27e91,0x34a0607(%rip),%eax        # 34a0983 <_license+0x349e8e9>
     379:	7e f2 03 
     37c:	ef                   	out    %eax,(%dx)
     37d:	01 58 04             	add    %ebx,0x4(%rax)
     380:	00 05 00 03 91 7e    	add    %al,0x7e910300(%rip)        # 7e910686 <_license+0x7e90e5ec>
     386:	82                   	(bad)
     387:	04 09                	add    $0x9,%al
     389:	05 07 06 03 e5       	add    $0xe5030607,%eax
     38e:	03 02                	add    (%rdx),%eax
     390:	7a 01                	jp     393 <balancer_ingress+0x393>
     392:	08 21                	or     %ah,(%rcx)
     394:	04 0b                	add    $0xb,%al
     396:	03 f3                	add    %ebx,%esi
     398:	7e 08                	jle    3a2 <balancer_ingress+0x3a2>
     39a:	20 05 10 03 42 82    	and    %al,-0x7dbdfcf0(%rip)        # ffffffff824206b0 <server_id_map+0x5ffffe091f56b0>
     3a0:	05 14 06 4a 05       	add    $0x54a0614,%eax
     3a5:	07                   	(bad)
     3a6:	3c 05                	cmp    $0x5,%al
     3a8:	11 06                	adc    %eax,(%rsi)
     3aa:	69 05 07 06 4a 03 e2 	imul   $0x3907de2,0x34a0607(%rip),%eax        # 34a09bb <_license+0x349e921>
     3b1:	7d 90 03 
     3b4:	9e                   	sahf
     3b5:	02 58 05             	add    0x5(%rax),%bl
     3b8:	3c 06                	cmp    $0x6,%al
     3ba:	03 a9 7e 90 05 20    	add    0x2005907e(%rcx),%ebp
     3c0:	91                   	xchg   %eax,%ecx
     3c1:	05 07 3b 05 12       	add    $0x12053b07,%eax
     3c6:	6e                   	outsb  %ds:(%rsi),(%dx)
     3c7:	05 16 4e 05 0c       	add    $0xc054e16,%eax
     3cc:	59                   	pop    %rcx
     3cd:	05 15 4c 05 13       	add    $0x13054c15,%eax
     3d2:	3b 05 0e 3d 3d 04    	cmp    0x43d3d0e(%rip),%eax        # 43d40e6 <_license+0x43d204c>
     3d8:	0c 03                	or     $0x3,%al
     3da:	61                   	(bad)
     3db:	3c 05                	cmp    $0x5,%al
     3dd:	0b 06                	or     (%rsi),%eax
     3df:	08 ba 05 0e 3c 05    	or     %bh,0x53c0e05(%rdx)
     3e5:	0b 3c 05 0e 3c 05 0b 	or     0xb053c0e(,%rax,1),%edi
     3ec:	4a 04 00             	rex.WX add $0x0,%al
     3ef:	05 00 03 48 08       	add    $0x8480300,%eax
     3f4:	20 05 07 06 03 e2    	and    %al,-0x1dfcf9f9(%rip)        # ffffffffe2030a01 <server_id_map+0x5ffffe68e05a01>
     3fa:	05 02 a2 01 01       	add    $0x101a202,%eax
     3ff:	04 09                	add    $0x9,%al
     401:	05 0e 03 9b 7b       	add    $0x7b9b030e,%eax
     406:	08 74 05 07          	or     %dh,0x7(%rbp,%rax,1)
     40a:	03 50 4a             	add    0x4a(%rax),%edx
     40d:	05 0e 03 30 2e       	add    $0x2e30030e,%eax
     412:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
     417:	06                   	(bad)
     418:	4a 05 07 3c 06 6a    	rex.WX add $0x6a063c07,%rax
     41e:	06                   	(bad)
     41f:	4a 05 11 06 67 05    	rex.WX add $0x5670611,%rax
     425:	1d 03 fc 02 90       	sbb    $0x9002fc03,%eax
     42a:	05 16 06 3c 05       	add    $0x53c0616,%eax
     42f:	1d 06 4b 05 16       	sbb    $0x16054b06,%eax
     434:	06                   	(bad)
     435:	3c 04                	cmp    $0x4,%al
     437:	0b 05 07 06 03 d8    	or     -0x27fcf9f9(%rip),%eax        # ffffffffd8030a44 <server_id_map+0x5ffffe5ee05a44>
  if (protocol == IPPROTO_IPIP) {
     43d:	7e 4a                	jle    489 <balancer_ingress+0x489>
     43f:	05 10 03 93 7f       	add    $0x7f930310,%eax
     444:	4a 05 14 06 4a 05    	rex.WX add $0x54a0614,%rax
     44a:	07                   	(bad)
     44b:	3c 05                	cmp    $0x5,%al
     44d:	11 06                	adc    %eax,(%rsi)
     44f:	69 05 07 06 4a 03 91 	imul   $0x3f27e91,0x34a0607(%rip),%eax        # 34a0a60 <_license+0x349e9c6>
     456:	7e f2 03 
  tcp = data + off;
     459:	ef                   	out    %eax,(%dx)
     45a:	01 58 05             	add    %ebx,0x5(%rax)
  if (tcp + 1 > data_end) {
     45d:	3e 06                	ds (bad)
     45f:	03 f6                	add    %esi,%esi
     461:	7e 82                	jle    3e5 <balancer_ingress+0x3e5>
     463:	05 21 91 05 07       	add    $0x7059121,%eax
  if (tcp->syn) {
     468:	3b 06                	cmp    (%rsi),%eax
     46a:	03 9b 7f ac 04 00    	add    0x4ac7f(%rbx),%ebx
     470:	06                   	(bad)
     471:	03 e2                	add    %edx,%esp
    pckt->flags |= F_SYN_SET;
     473:	05 90 04 09 05       	add    $0x5090490,%eax
     478:	0e                   	(bad)
     479:	03 9b 7b 08 74 05    	add    0x574087b(%rbx),%ebx
      pckt->flow.src = iph->saddr;
     47f:	07                   	(bad)
     480:	03 50 4a             	add    0x4a(%rax),%edx
      pckt->flow.dst = iph->daddr;
     483:	05 0e 03 30 2e       	add    $0x2e30030e,%eax
     488:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
  if (icmp_hdr + 1 > data_end) {
     48d:	06                   	(bad)
     48e:	4a 05 07 3c 06 6a    	rex.WX add $0x6a063c07,%rax
     494:	06                   	(bad)
     495:	4a 05 11 06 67 06    	rex.WX add $0x6670611,%rax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     49b:	03 fc                	add    %esp,%edi
     49d:	7e 90                	jle    42f <balancer_ingress+0x42f>
     49f:	04 0b                	add    $0xb,%al
     4a1:	05 09 06 03 fa       	add    $0xfa030609,%eax
     4a6:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
     4ac:	09 06                	or     %eax,(%rsi)
     4ae:	3c 05                	cmp    $0x5,%al
     4b0:	1b 06                	sbb    (%rsi),%eax
     4b2:	69 05 11 4b 05 0d 59 	imul   $0x6090559,0xd054b11(%rip),%eax        # d054fcd <_license+0xd052f33>
     4b9:	05 09 06 
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4bc:	66 05 1d 06          	add    $0x61d,%ax
     4c0:	2f                   	(bad)
     4c1:	05 0c 60 05 10       	add    $0x1005600c,%eax
       sizeof(struct icmp6hdr)) > data_end) {
     4c6:	06                   	(bad)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4c7:	4a 05 07 3c 05 1c    	rex.WX add $0x1c053c07,%rax
     4cd:	06                   	(bad)
     4ce:	69 05 14 06 3c 05 0f 	imul   $0x54b060f,0x53c0614(%rip),%eax        # 53c0aec <_license+0x53bea52>
     4d5:	06 4b 05 
     4d8:	03 59 08             	add    0x8(%rcx),%ebx
     4db:	21 06                	and    %eax,(%rsi)
     4dd:	03 f1                	add    %ecx,%esi
     4df:	7d 08                	jge    4e9 <balancer_ingress+0x4e9>
     4e1:	20 04 00             	and    %al,(%rax,%rax,1)
     4e4:	05 07 06 03 e2       	add    $0xe2030607,%eax
     4e9:	05 90 05 05 03       	add    $0x3050590,%eax
     4ee:	ef                   	out    %eax,(%dx)
     4ef:	7b 08                	jnp    4f9 <balancer_ingress+0x4f9>
     4f1:	74 04                	je     4f7 <balancer_ingress+0x4f7>
  tcp = data + off;
     4f3:	06                   	(bad)
     4f4:	05 01 03 c7 01       	add    $0x1c70301,%eax
     4f9:	08 3c 04             	or     %bh,(%rsp,%rax,1)
     4fc:	00 05 07 03 bf 7e    	add    %al,0x7ebf0307(%rip)        # 7ebf0809 <_license+0x7ebee76f>
  if (tcp + 1 > data_end) {
     502:	08 4a 06             	or     %cl,0x6(%rdx)
     505:	3c 03                	cmp    $0x3,%al
     507:	a9 7e 66 05 12       	test   $0x1205667e,%eax
  if (tcp->syn) {
     50c:	06                   	(bad)
     50d:	03 da                	add    %edx,%ebx
     50f:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
    pckt->flags |= F_SYN_SET;
     515:	05 03 76 d6 04       	add    $0x4d67603,%eax
     51a:	06                   	(bad)
     51b:	05 01 03 c7 01       	add    $0x1c70301,%eax
     520:	08 3c 04             	or     %bh,(%rsp,%rax,1)
     523:	00 05 07 03 bf 7e    	add    %al,0x7ebf0307(%rip)        # 7ebf0830 <_license+0x7ebee796>
        bpf_map_lookup_elem(&stats, &stats_key);
     529:	08 4a 06             	or     %cl,0x6(%rdx)
     52c:	3c 03                	cmp    $0x3,%al
     52e:	a9 7e 66 05 12       	test   $0x1205667e,%eax
     533:	06                   	(bad)
     534:	03 da                	add    %edx,%ebx
     536:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
    if (!icmp_ptb_v6_stats) {
     53c:	09 06                	or     %eax,(%rsi)
     53e:	3c 04                	cmp    $0x4,%al
    icmp_ptb_v6_stats->v1 += 1;
     540:	09 05 0e 06 03 88    	or     %eax,-0x77fcf9f2(%rip)        # ffffffff88030b54 <server_id_map+0x5ffffe0ee05b54>
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     546:	7f ac                	jg     4f4 <balancer_ingress+0x4f4>
     548:	05 07 03 6a 4a       	add    $0x4a6a0307,%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     54d:	05 0e 03 16 2e       	add    $0x2e16030e,%eax
      icmp_ptb_v6_stats->v2 += 1;
     552:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
  if (ip6h + 1 > data_end) {
     557:	06                   	(bad)
     558:	4a 05 07 3c 04 00    	rex.WX add $0x43c07,%rax
     55e:	05 00 03 9b 7f       	add    $0x7f9b0300,%eax
  pckt->flow.proto = ip6h->nexthdr;
     563:	66 04 0b             	data16 add $0xb,%al
     566:	05 16 06 03 a5       	add    $0xa5030616,%eax
  pckt->flags |= F_ICMP;
     56b:	02 08                	add    (%rax),%cl
     56d:	d6                   	(bad)
     56e:	05 07 06 4a 03       	add    $0x34a0607,%eax
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     573:	db 7d 2e             	fstpt  0x2e(%rbp)
     576:	05 09 06 03 a8       	add    $0xa8030609,%eax
     57b:	02 9e 05 0a f3 05    	add    0x5f30a05(%rsi),%bl
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     581:	09 06                	or     %eax,(%rsi)
     583:	3c 05                	cmp    $0x5,%al
     585:	1b 06                	sbb    (%rsi),%eax
     587:	69 05 0d 4c 05 09 06 	imul   $0x1d054a06,0x9054c0d(%rip),%eax        # 905519e <_license+0x9053104>
     58e:	4a 05 1d 
     591:	06                   	(bad)
     592:	2f                   	(bad)
     593:	05 0b 5e 05 0f       	add    $0xf055e0b,%eax
     598:	06                   	(bad)
     599:	4a 05 07 3c 05 0c    	rex.WX add $0xc053c07,%rax
     59f:	06                   	(bad)
     5a0:	69 05 10 06 4a 05 07 	imul   $0x1b052e07,0x54a0610(%rip),%eax        # 54a0bba <_license+0x549eb20>
     5a7:	2e 05 1b 
     5aa:	06                   	(bad)
     5ab:	69 05 14 06 3c 05 0f 	imul   $0x54b060f,0x53c0614(%rip),%eax        # 53c0bc9 <_license+0x53beb2f>
     5b2:	06 4b 05 
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     5b5:	19 59 05             	sbb    %ebx,0x5(%rcx)
     5b8:	12 06                	adc    (%rsi),%al
     5ba:	3c 05                	cmp    $0x5,%al
     5bc:	19 06                	sbb    %eax,(%rsi)
     5be:	4b 05 12 06 3c 04    	rex.WXB add $0x43c0612,%rax
     5c4:	00 05 00 03 c2 7d    	add    %al,0x7dc20300(%rip)        # 7dc208ca <_license+0x7dc1e830>
     5ca:	90                   	nop
     5cb:	05 05 06 03 90       	add    $0x90030605,%eax
     5d0:	06                   	(bad)
     5d1:	08 4a 05             	or     %cl,0x5(%rdx)
     5d4:	0e                   	(bad)
     5d5:	08 41 05             	or     %al,0x5(%rcx)
     5d8:	0c 06                	or     $0x6,%al
     5da:	58                   	pop    %rax
     5db:	05 19 06 59 05       	add    $0x5590619,%eax
  if (decap_dst_flags) {
     5e0:	0d 06 4a 04 06       	or     $0x6044a06,%eax
     5e5:	05 01 06 03 82       	add    $0x82030601,%eax
     5ea:	7d 4a                	jge    636 <balancer_ingress+0x636>
     5ec:	04 00                	add    $0x0,%al
     5ee:	05 08 03 80 03       	add    $0x3800308,%eax
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     5f3:	08 9e 05 07 06 3c    	or     %bl,0x3c060705(%rsi)
     5f9:	05 10 06 03 0f       	add    $0xf030610,%eax
     5fe:	66 05 17 06          	add    $0x617,%ax
    if (!data_stats) {
     602:	66 05 07 66          	add    $0x6607,%ax
     606:	03 d9                	add    %ecx,%ebx
     608:	79 66                	jns    670 <balancer_ingress+0x670>
     60a:	05 10 06 03 bb       	add    $0xbb030610,%eax
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     60f:	06                   	(bad)
     610:	9e                   	sahf
     611:	05 08 f3 05 07       	add    $0x705f308,%eax
     616:	06                   	(bad)
     617:	3c 05                	cmp    $0x5,%al
     619:	12 06                	adc    (%rsi),%al
     61b:	6b 05 18 4c 05 07 06 	imul   $0x6,0x7054c18(%rip),%eax        # 705523a <_license+0x70531a0>
     622:	3c 05                	cmp    $0x5,%al
     624:	19 06                	sbb    %eax,(%rsi)
     626:	31 05 17 77 05 13    	xor    %eax,0x13057717(%rip)        # 13057d43 <_license+0x13055ca9>
     62c:	9f                   	lahf
     62d:	bb 06 58 05 22       	mov    $0x22055806,%ebx
     632:	06                   	(bad)
     633:	6a 05                	push   $0x5
     635:	0a f3                	or     %bl,%dh
  if (decap_dst_flags) {
     637:	05 09 06 3c 05       	add    $0x53c0609,%eax
     63c:	13 06                	adc    (%rsi),%eax
     63e:	6c                   	insb   (%dx),%es:(%rdi)
     63f:	06                   	(bad)
     640:	03 aa 79 d6 04 0b    	add    0xb04d679(%rdx),%ebp
     646:	05 16 06 03 a5       	add    $0xa5030616,%eax
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     64b:	02 9e 05 07 06 4a    	add    0x4a060705(%rsi),%bl
     651:	03 db                	add    %ebx,%ebx
     653:	7d 2e                	jge    683 <balancer_ingress+0x683>
     655:	05 09 06 03 a8       	add    $0xa8030609,%eax
    if (!data_stats) {
     65a:	02 9e 05 0a f3 05    	add    0x5f30a05(%rsi),%bl
     660:	09 06                	or     %eax,(%rsi)
     662:	3c 05                	cmp    $0x5,%al
     664:	1b 06                	sbb    (%rsi),%eax
     666:	69 05 0d 4c 05 09 06 	imul   $0x1d054a06,0x9054c0d(%rip),%eax        # 905527d <_license+0x90531e3>
     66d:	4a 05 1d 
  udp = data + off;
     670:	06                   	(bad)
     671:	2f                   	(bad)
  if (udp + 1 > data_end) {
     672:	05 0b 5e 05 0f       	add    $0xf055e0b,%eax
     677:	06                   	(bad)
     678:	4a 05 07 3c 05 0c    	rex.WX add $0xc053c07,%rax
     67e:	06                   	(bad)
     67f:	69 05 10 06 4a 05 07 	imul   $0x1b052e07,0x54a0610(%rip),%eax        # 54a0c99 <_license+0x549ebff>
     686:	2e 05 1b 
     689:	06                   	(bad)
     68a:	69 05 14 06 3c 05 0f 	imul   $0x54b060f,0x53c0614(%rip),%eax        # 53c0ca8 <_license+0x53bec0e>
     691:	06 4b 05 
     694:	19 59 05             	sbb    %ebx,0x5(%rcx)
     697:	12 06                	adc    (%rsi),%al
     699:	3c 05                	cmp    $0x5,%al
     69b:	19 06                	sbb    %eax,(%rsi)
     69d:	4b 05 12 06 3c 04    	rex.WXB add $0x43c0612,%rax
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     6a3:	00 05 0e 06 03 db    	add    %al,-0x24fcf9f2(%rip)        # ffffffffdb030cb7 <server_id_map+0x5ffffe61e05cb7>
     6a9:	03 90 04 06 05 01    	add    0x1050604(%rax),%edx
        bpf_map_lookup_elem(&stats, &stats_key);
     6af:	03 ff                	add    %edi,%edi
     6b1:	7c 74                	jl     727 <balancer_ingress+0x727>
     6b3:	04 00                	add    $0x0,%al
     6b5:	05 0a 03 83 03       	add    $0x383030a,%eax
     6ba:	d6                   	(bad)
     6bb:	05 09 06 3c 05       	add    $0x53c0609,%eax
    if (!icmp_ptb_v4_stats) {
     6c0:	00 03                	add    %al,(%rbx)
     6c2:	e5 79                	in     $0x79,%eax
     6c4:	66 05 30 06          	add    $0x630,%ax
    icmp_ptb_v4_stats->v1 += 1;
     6c8:	03 9f 06 3c 05 1b    	add    0x1b053c06(%rdi),%ebx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     6ce:	94                   	xchg   %eax,%esp
     6cf:	05 12 03 a9 7b       	add    $0x7ba90312,%eax
      icmp_ptb_v4_stats->v2 += 1;
     6d4:	ba 05 20 08 19       	mov    $0x19082005,%edx
  if (iph + 1 > data_end) {
     6d9:	05 13 06 4a 04       	add    $0x44a0613,%eax
     6de:	06                   	(bad)
     6df:	05 01 06 03 c5       	add    $0xc5030601,%eax
  if (iph->ihl != 5) {
     6e4:	01 4a 04             	add    %ecx,0x4(%rdx)
     6e7:	00 05 07 03 bf 7e    	add    %al,0x7ebf0307(%rip)        # 7ebf09f4 <_license+0x7ebee95a>
     6ed:	08 4a 06             	or     %cl,0x6(%rdx)
  pckt->flow.proto = iph->protocol;
     6f0:	3c 03                	cmp    $0x3,%al
     6f2:	a9 7e 66 05 12       	test   $0x1205667e,%eax
  pckt->flags |= F_ICMP;
     6f7:	06                   	(bad)
     6f8:	03 da                	add    %edx,%ebx
     6fa:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
  pckt->flow.src = iph->daddr;
     700:	09 06                	or     %eax,(%rsi)
  pckt->flow.dst = iph->saddr;
     702:	3c 03                	cmp    $0x3,%al
     704:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     705:	7e ac                	jle    6b3 <balancer_ingress+0x6b3>
     707:	04 0b                	add    $0xb,%al
     709:	06                   	(bad)
     70a:	03 fa                	add    %edx,%edi
     70c:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
     712:	09 06                	or     %eax,(%rsi)
     714:	3c 05                	cmp    $0x5,%al
     716:	1b 06                	sbb    (%rsi),%eax
     718:	69 05 11 4b 05 0d 59 	imul   $0x6090559,0xd054b11(%rip),%eax        # d055233 <_license+0xd053199>
     71f:	05 09 06 
     722:	66 05 1d 06          	add    $0x61d,%ax
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     726:	2f                   	(bad)
     727:	05 0c 60 05 10       	add    $0x1005600c,%eax
     72c:	06                   	(bad)
     72d:	4a 05 07 3c 04 00    	rex.WX add $0x43c07,%rax
     733:	05 00 03 f7 7d       	add    $0x7df70300,%eax
  vip.port = pckt.flow.port16[1];
     738:	66 04 0b             	data16 add $0xb,%al
     73b:	05 1c 06 03 8c       	add    $0x8c03061c,%eax
     740:	02 58 05             	add    0x5(%rax),%bl
  vip.proto = pckt.flow.proto;
     743:	14 06                	adc    $0x6,%al
     745:	3c 05                	cmp    $0x5,%al
     747:	0f 06                	clts
     749:	4b 05 03 59 08 21    	rex.WXB add $0x21085903,%rax
     74f:	06                   	(bad)
     750:	03 f1                	add    %ecx,%esi
     752:	7d e4                	jge    738 <balancer_ingress+0x738>
     754:	04 00                	add    $0x0,%al
     756:	05 07 06 03 e2       	add    $0xe2030607,%eax
     75b:	05 90 05 12 03       	add    $0x3120590,%eax
     760:	ea                   	(bad)
     761:	7b 08                	jnp    76b <balancer_ingress+0x76b>
     763:	3c 05                	cmp    $0x5,%al
  if (!vip_info) {
     765:	20 08                	and    %cl,(%rax)
     767:	19 05 13 06 4a 04    	sbb    %eax,0x44a0613(%rip)        # 44a0d80 <_license+0x449ece6>
  if (data_end - data > MAX_PCKT_SIZE) {
     76d:	06                   	(bad)
     76e:	05 01 06 03 c5       	add    $0xc5030601,%eax
     773:	01 4a 04             	add    %ecx,0x4(%rdx)
     776:	00 05 07 03 bf 7e    	add    %al,0x7ebf0307(%rip)        # 7ebf0a83 <_license+0x7ebee9e9>
     77c:	08 4a 06             	or     %cl,0x6(%rdx)
     77f:	3c 03                	cmp    $0x3,%al
     781:	a9 7e 66 05 12       	test   $0x1205667e,%eax
     786:	06                   	(bad)
     787:	03 da                	add    %edx,%ebx
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     789:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
     78f:	09 06                	or     %eax,(%rsi)
     791:	3c 05                	cmp    $0x5,%al
     793:	00 03                	add    %al,(%rbx)
     795:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     796:	7e 66                	jle    7fe <balancer_ingress+0x7fe>
     798:	04 09                	add    $0x9,%al
  if (!data_stats) {
     79a:	05 0e 06 03 e3       	add    $0xe303060e,%eax
     79f:	00 90 05 07 03 6a    	add    %dl,0x6a030705(%rax)
  data_stats->v1 += 1;
     7a5:	4a 05 0e 03 16 2e    	rex.WX add $0x2e16030e,%rax
    pckt.flow.port16[0] = 0;
     7ab:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
     7b0:	06                   	(bad)
     7b1:	4a 05 07 3c 04 00    	rex.WX add $0x43c07,%rax
  vip_num = vip_info->vip_num;
     7b7:	05 00 03 9b 7f       	add    $0x7f9b0300,%eax
  __u32 cpu_num = bpf_get_smp_processor_id();
     7bc:	66 05 19 06          	add    $0x619,%ax
     7c0:	03 92 06 02 31 01    	add    0x1310206(%rdx),%edx
     7c6:	05 0d 06 4a 05       	add    $0x54a060d,%eax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     7cb:	0e                   	(bad)
     7cc:	06                   	(bad)
     7cd:	4d 05 0c 06 58 05    	rex.WRB add $0x558060c,%rax
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     7d3:	19 06                	sbb    %eax,(%rsi)
     7d5:	59                   	pop    %rcx
     7d6:	05 0d 06 4a 04       	add    $0x44a060d,%eax
     7db:	06                   	(bad)
     7dc:	05 01 06 03 82       	add    $0x82030601,%eax
     7e1:	7d 4a                	jge    82d <balancer_ingress+0x82d>
    if (!lru_stats) {
     7e3:	04 00                	add    $0x0,%al
     7e5:	05 08 03 80 03       	add    $0x3800308,%eax
     7ea:	08 9e 05 07 06 3c    	or     %bl,0x3c060705(%rsi)
    lru_stats->v1 += 1;
     7f0:	05 10 06 03 0f       	add    $0xf030610,%eax
     7f5:	66 05 17 06          	add    $0x617,%ax
     7f9:	66 05 07 66          	add    $0x6607,%ax
     7fd:	03 d9                	add    %ecx,%ebx
     7ff:	79 66                	jns    867 <balancer_ingress+0x867>
     801:	05 10 06 03 bb       	add    $0xbb030610,%eax
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     806:	06                   	(bad)
     807:	9e                   	sahf
     808:	05 08 f3 05 07       	add    $0x705f308,%eax
     80d:	06                   	(bad)
     80e:	3c 05                	cmp    $0x5,%al
     810:	12 06                	adc    (%rsi),%al
     812:	6b 05 18 4c 05 07 06 	imul   $0x6,0x7054c18(%rip),%eax        # 7055431 <_license+0x7053397>
        bpf_map_lookup_elem(&stats, &stats_key);
     819:	3c 05                	cmp    $0x5,%al
     81b:	19 06                	sbb    %eax,(%rsi)
     81d:	31 05 17 77 05 13    	xor    %eax,0x13057717(%rip)        # 13057f3a <_license+0x13055ea0>
     823:	e5 bb                	in     $0xbb,%eax
    if (!icmp_ptb_v4_stats) {
     825:	06                   	(bad)
     826:	58                   	pop    %rax
     827:	05 22 06 6a 05       	add    $0x56a0622,%eax
     82c:	0a 08                	or     (%rax),%cl
    icmp_ptb_v4_stats->v1 += 1;
     82e:	91                   	xchg   %eax,%ecx
     82f:	05 09 06 3c 05       	add    $0x53c0609,%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     834:	13 06                	adc    (%rsi),%eax
     836:	6c                   	insb   (%dx),%es:(%rdi)
      icmp_ptb_v4_stats->v2 += 1;
     837:	06                   	(bad)
     838:	03 aa 79 d6 06 03    	add    0x306d679(%rdx),%ebp
  if (iph + 1 > data_end) {
     83e:	cb                   	lret
     83f:	06                   	(bad)
     840:	9e                   	sahf
     841:	06                   	(bad)
     842:	03 b5 79 2e 03 cb    	add    -0x34fcd187(%rbp),%esi
     848:	06                   	(bad)
  if (iph->ihl != 5) {
     849:	9e                   	sahf
     84a:	03 b5 79 82 05 08    	add    0x8058279(%rbp),%esi
     850:	06                   	(bad)
     851:	03 cc                	add    %esp,%ecx
     853:	06                   	(bad)
     854:	58                   	pop    %rax
  pckt->flow.proto = iph->protocol;
     855:	05 07 06 3c 03       	add    $0x33c0607,%eax
     85a:	b4 79                	mov    $0x79,%ah
  pckt->flags |= F_ICMP;
     85c:	66 05 18 06          	add    $0x618,%ax
     860:	03 da                	add    %edx,%ebx
  pckt->flow.src = iph->daddr;
     862:	06                   	(bad)
     863:	58                   	pop    %rax
     864:	05 07 06 82 05       	add    $0x5820607,%eax
  pckt->flow.dst = iph->saddr;
     869:	14 06                	adc    $0x6,%al
     86b:	67 05 09 59 06 03    	addr32 add $0x3065909,%eax
     871:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     872:	79 66                	jns    8da <balancer_ingress+0x8da>
    vip.port = 0;
     874:	05 0b 06 03 f0       	add    $0xf003060b,%eax
     879:	06                   	(bad)
     87a:	9e                   	sahf
     87b:	05 0c f3 05 0b       	add    $0xb05f30c,%eax
     880:	06                   	(bad)
     881:	3c 04                	cmp    $0x4,%al
     883:	09 05 0d 06 03 f2    	or     %eax,-0xdfcf9f3(%rip)        # fffffffff2030e96 <server_id_map+0x5ffffe78e05e96>
    if (!vip_info) {
     889:	7b 66                	jnp    8f1 <balancer_ingress+0x8f1>
     88b:	05 12 46 05 0d       	add    $0xd054612,%eax
     890:	5c                   	pop    %rsp
     891:	05 2b 06 4a 05       	add    $0x54a062b,%eax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     896:	3b 4a 05             	cmp    0x5(%rdx),%ecx
     899:	07                   	(bad)
     89a:	3c 05                	cmp    $0x5,%al
     89c:	00 03                	add    %al,(%rbx)
      pckt.flow.port16[1] = 0;
     89e:	9d                   	popf
     89f:	7d 66                	jge    907 <balancer_ingress+0x907>
     8a1:	05 08 06 03 ef       	add    $0xef030608,%eax
     8a6:	02 4a 05             	add    0x5(%rdx),%cl
     8a9:	26 06                	es (bad)
  struct address dst_addr = {};
     8ab:	3c 05                	cmp    $0x5,%al
     8ad:	07                   	(bad)
     8ae:	3c 05                	cmp    $0x5,%al
     8b0:	13 06                	adc    (%rsi),%eax
     8b2:	03 14 66             	add    (%rsi,%riz,2),%edx
     8b5:	05 36 06 4a 05       	add    $0x54a0636,%eax
     8ba:	09 3c 04             	or     %edi,(%rsp,%rax,1)
    dst_addr.addr = pckt->flow.dst;
     8bd:	00 05 0e 06 03 96    	add    %al,-0x69fcf9f2(%rip)        # ffffffff96030ed1 <server_id_map+0x5ffffe1ce05ed1>
     8c3:	03 ac 04 06 05 01 03 	add    0x3010506(%rsp,%rax,1),%ebp
     8ca:	ff                   	(bad)
     8cb:	7c 74                	jl     941 <balancer_ingress+0x941>
     8cd:	06                   	(bad)
     8ce:	03 e8                	add    %eax,%ebp
     8d0:	7c 3c                	jl     90e <balancer_ingress+0x90e>
     8d2:	03 98 03 58 04 00    	add    0x45803(%rax),%ebx
  if (decap_dst_flags) {
     8d8:	05 0a 06 03 83       	add    $0x8303060a,%eax
     8dd:	03 66 05             	add    0x5(%rsi),%esp
     8e0:	09 06                	or     %eax,(%rsi)
     8e2:	3c 05                	cmp    $0x5,%al
     8e4:	00 03                	add    %al,(%rbx)
     8e6:	e5 79                	in     $0x79,%eax
     8e8:	66 05 30 06          	add    $0x630,%ax
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8ec:	03 9f 06 3c 05 1b    	add    0x1b053c06(%rdi),%ebx
     8f2:	94                   	xchg   %eax,%esp
     8f3:	05 25 03 c1 00       	add    $0xc10325,%eax
     8f8:	ba 05 0c 08 91       	mov    $0x91080c05,%edx
    if (!data_stats) {
     8fd:	05 0b 06 3c 05       	add    $0x53c060b,%eax
     902:	16                   	(bad)
     903:	06                   	(bad)
     904:	69 04 0b 05 14 03 e1 	imul   $0xe1031405,(%rbx,%rcx,1),%eax
     90b:	7b 58                	jnp    965 <balancer_ingress+0x965>
     90d:	05 37 06 3c 04       	add    $0x43c0637,%eax
     912:	00 05 0b 06 03 a1    	add    %al,-0x5efcf9f5(%rip)        # ffffffffa1030f23 <server_id_map+0x5ffffe27e05f23>
        bpf_map_lookup_elem(&stats, &stats_key);
     918:	04 90                	add    $0x90,%al
     91a:	05 15 67 06 03       	add    $0x3066715,%eax
     91f:	95                   	xchg   %eax,%ebp
     920:	79 4a                	jns    96c <balancer_ingress+0x96c>
     922:	05 13 06 03 cb       	add    $0xcb030613,%eax
    if (!icmp_ptb_v6_stats) {
     927:	06                   	(bad)
     928:	58                   	pop    %rax
     929:	06                   	(bad)
     92a:	03 b5 79 2e 03 cb    	add    -0x34fcd187(%rbp),%esi
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     930:	06                   	(bad)
     931:	9e                   	sahf
     932:	03 b5 79 82 05 08    	add    0x8058279(%rbp),%esi
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     938:	06                   	(bad)
     939:	03 cc                	add    %esp,%ecx
     93b:	06                   	(bad)
     93c:	58                   	pop    %rax
      icmp_ptb_v6_stats->v2 += 1;
     93d:	05 07 06 3c 03       	add    $0x33c0607,%eax
  if (ip6h + 1 > data_end) {
     942:	b4 79                	mov    $0x79,%ah
     944:	66 05 18 06          	add    $0x618,%ax
     948:	03 da                	add    %edx,%ebx
     94a:	06                   	(bad)
     94b:	58                   	pop    %rax
     94c:	05 07 06 3c 05       	add    $0x53c0607,%eax
     951:	14 06                	adc    $0x6,%al
     953:	67 05 09 59 06 03    	addr32 add $0x3065909,%eax
  pckt->flow.proto = ip6h->nexthdr;
     959:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     95a:	79 66                	jns    9c2 <balancer_ingress+0x9c2>
  pckt->flags |= F_ICMP;
     95c:	05 0b 06 03 f0       	add    $0xf003060b,%eax
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     961:	06                   	(bad)
     962:	9e                   	sahf
     963:	05 0c f3 05 0b       	add    $0xb05f30c,%eax
     968:	06                   	(bad)
     969:	3c 04                	cmp    $0x4,%al
     96b:	09 05 0d 06 03 f2    	or     %eax,-0xdfcf9f3(%rip)        # fffffffff2030f7e <server_id_map+0x5ffffe78e05f7e>
     971:	7b 66                	jnp    9d9 <balancer_ingress+0x9d9>
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     973:	05 12 46 05 0d       	add    $0xd054612,%eax
     978:	5c                   	pop    %rsp
     979:	05 2b 06 4a 05       	add    $0x54a062b,%eax
     97e:	3b 4a 05             	cmp    0x5(%rdx),%ecx
     981:	07                   	(bad)
     982:	3c 05                	cmp    $0x5,%al
     984:	00 03                	add    %al,(%rbx)
     986:	9d                   	popf
     987:	7d 66                	jge    9ef <balancer_ingress+0x9ef>
     989:	05 08 06 03 ef       	add    $0xef030608,%eax
  if (protocol == IPPROTO_IPIP) {
     98e:	02 4a 05             	add    0x5(%rdx),%cl
     991:	26 06                	es (bad)
     993:	3c 05                	cmp    $0x5,%al
     995:	07                   	(bad)
     996:	3c 05                	cmp    $0x5,%al
     998:	13 06                	adc    (%rsi),%eax
     99a:	03 14 66             	add    (%rsi,%riz,2),%edx
     99d:	05 36 06 4a 05       	add    $0x54a0636,%eax
  struct address dst_addr = {};
     9a2:	09 3c 05 08 06 33 05 	or     %edi,0x5330608(,%rax,1)
     9a9:	07                   	(bad)
     9aa:	06                   	(bad)
     9ab:	3c 05                	cmp    $0x5,%al
     9ad:	19 06                	sbb    %eax,(%rsi)
    dst_addr.addr = pckt->flow.dst;
     9af:	32 05 23 06 3c 05    	xor    0x53c0623(%rip),%al        # 53c0fd8 <_license+0x53bef3e>
     9b5:	07                   	(bad)
     9b6:	06                   	(bad)
     9b7:	5a                   	pop    %rdx
     9b8:	05 15 08 6a 05       	add    $0x56a0815,%eax
     9bd:	1d 06 3c 05 27       	sbb    $0x27053c06,%eax
     9c2:	4a 05 24 4a 05 3a    	rex.WX add $0x3a054a24,%rax
     9c8:	4a 05 44 3c 04 00    	rex.WX add $0x43c44,%rax
  if (decap_dst_flags) {
     9ce:	05 25 06 03 d2       	add    $0xd2030625,%eax
     9d3:	03 9e 05 0c 08 91    	add    -0x6ef7f3fb(%rsi),%ebx
     9d9:	05 0b 06 3c 05       	add    $0x53c060b,%eax
     9de:	16                   	(bad)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     9df:	06                   	(bad)
     9e0:	69 04 0b 05 14 03 e6 	imul   $0xe6031405,(%rbx,%rcx,1),%eax
     9e7:	7b 58                	jnp    a41 <balancer_ingress+0xa41>
     9e9:	05 2f 06 3c 04       	add    $0x43c062f,%eax
     9ee:	00 05 0b 06 03 9c    	add    %al,-0x63fcf9f5(%rip)        # ffffffff9c030fff <server_id_map+0x5ffffe22e05fff>
    if (!data_stats) {
     9f4:	04 4a                	add    $0x4a,%al
     9f6:	05 15 2f 05 00       	add    $0x52f15,%eax
     9fb:	06                   	(bad)
     9fc:	03 95 79 4a 05 14    	add    0x14054a79(%rbp),%edx
  udp = data + off;
     a02:	06                   	(bad)
     a03:	03 b4 07 58 05 1e 03 	add    0x31e0558(%rdi,%rax,1),%esi
     a0a:	26 66 05 2b 06       	es add $0x62b,%ax
  if (udp + 1 > data_end) {
     a0f:	58                   	pop    %rax
     a10:	03 a6 78 2e 05 1b    	add    0x1b052e78(%rsi),%esp
     a16:	06                   	(bad)
     a17:	03 db                	add    %ebx,%ebx
     a19:	07                   	(bad)
     a1a:	58                   	pop    %rax
     a1b:	05 09 3b 06 03       	add    $0x3063b09,%eax
     a20:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     a21:	78 2e                	js     a51 <balancer_ingress+0xa51>
     a23:	04 06                	add    $0x6,%al
     a25:	05 01 06 03 98       	add    $0x98030601,%eax
     a2a:	03 58 06             	add    0x6(%rax),%ebx
     a2d:	03 e8                	add    %eax,%ebp
     a2f:	7c 3c                	jl     a6d <balancer_ingress+0xa6d>
     a31:	03 98 03 58 04 00    	add    0x45803(%rax),%ebx
     a37:	05 08 06 03 a1       	add    $0xa1030608,%eax
     a3c:	7e 3c                	jle    a7a <balancer_ingress+0xa7a>
     a3e:	05 07 06 3c 05       	add    $0x53c0607,%eax
     a43:	00 03                	add    %al,(%rbx)
     a45:	c7                   	(bad)
     a46:	7e 2e                	jle    a76 <balancer_ingress+0xa76>
     a48:	05 28 06 03 bc       	add    $0xbc030628,%eax
    vip.vip = pckt.flow.dst;
     a4d:	01 3c 05 07 06 58 03 	add    %edi,0x3580607(,%rax,1)
  vip.port = pckt.flow.port16[1];
     a54:	c4                   	(bad)
     a55:	7e 66                	jle    abd <balancer_ingress+0xabd>
     a57:	05 10 06 03 bd       	add    $0xbd030610,%eax
  vip.proto = pckt.flow.proto;
     a5c:	01 74 05 12          	add    %esi,0x12(%rbp,%rax,1)
     a60:	2f                   	(bad)
     a61:	05 23 06 08 12       	add    $0x12080623,%eax
     a66:	05 09 3c 03 c2       	add    $0xc2033c09,%eax
     a6b:	7e 66                	jle    ad3 <balancer_ingress+0xad3>
     a6d:	05 1f 06 03 92       	add    $0x9203061f,%eax
     a72:	05 3c 05 2e 06       	add    $0x62e053c,%eax
     a77:	58                   	pop    %rax
     a78:	03 ee                	add    %esi,%ebp
     a7a:	7a 66                	jp     ae2 <balancer_ingress+0xae2>
     a7c:	05 17 06 03 93       	add    $0x93030617,%eax
  if (!vip_info) {
     a81:	05 58 05 2e 06       	add    $0x62e0558,%eax
     a86:	4a 05 07 06 03 97    	rex.WX add $0xffffffff97030607,%rax
  if (data_end - data > MAX_PCKT_SIZE) {
     a8c:	7b 66                	jnp    af4 <balancer_ingress+0xaf4>
     a8e:	05 08 08 91 05       	add    $0x5910808,%eax
     a93:	07                   	(bad)
     a94:	06                   	(bad)
     a95:	3c 03                	cmp    $0x3,%al
     a97:	55                   	push   %rbp
     a98:	66 05 0f 06          	add    $0x60f,%ax
     a9c:	03 2e                	add    (%rsi),%ebp
     a9e:	74 05                	je     aa5 <balancer_ingress+0xaa5>
     aa0:	12 32                	adc    (%rdx),%dh
     aa2:	05 29 06 74 05       	add    $0x5740629,%eax
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     aa7:	07                   	(bad)
     aa8:	74 05                	je     aaf <balancer_ingress+0xaaf>
     aaa:	19 06                	sbb    %eax,(%rsi)
     aac:	30 75 04             	xor    %dh,0x4(%rbp)
     aaf:	09 05 13 03 bc 02    	or     %eax,0x2bc0313(%rip)        # 2bc0dc8 <_license+0x2bbed2e>
  if (!data_stats) {
     ab5:	66 05 35 06          	add    $0x635,%ax
     ab9:	4a 05 09 3c 05 2d    	rex.WX add $0x2d053c09,%rax
  data_stats->v1 += 1;
     abf:	06                   	(bad)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     ac0:	69 05 09 06 3c 04 00 	imul   $0x6290500,0x43c0609(%rip),%eax        # 43c10d3 <_license+0x43bf039>
     ac7:	05 29 06 
    pckt.flow.port16[0] = 0;
     aca:	03 b1 04 66 05 07    	add    0x7056604(%rcx),%esi
  vip_num = vip_info->vip_num;
     ad0:	03 db                	add    %ebx,%ebx
     ad2:	7d 58                	jge    b2c <balancer_ingress+0xb2c>
     ad4:	06                   	(bad)
     ad5:	03 80 7b 82 03 80    	add    -0x7ffc7d85(%rax),%eax
  __u32 cpu_num = bpf_get_smp_processor_id();
     adb:	05 58 03 80 7b       	add    $0x7b800358,%eax
     ae0:	66 03 80 05 e4 05 08 	add    0x805e405(%rax),%ax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     ae7:	06                   	(bad)
     ae8:	08 13                	or     %dl,(%rbx)
     aea:	05 07 06 3c 05       	add    $0x53c0607,%eax
     aef:	19 06                	sbb    %eax,(%rsi)
     af1:	03 b6 7b ac 05 1d    	add    0x1d05ac7b(%rsi),%esi
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     af7:	9f                   	lahf
     af8:	05 09 06 66 04       	add    $0x4660609,%eax
     afd:	06                   	(bad)
     afe:	05 01 06 03 e0       	add    $0xe0030601,%eax
     b03:	02 66 04             	add    0x4(%rsi),%ah
     b06:	00 05 09 03 fe 01    	add    %al,0x1fe0309(%rip)        # 1fe0e15 <_license+0x1fded7b>
    if (!lru_stats) {
     b0c:	08 4a 06             	or     %cl,0x6(%rdx)
     b0f:	3c 05                	cmp    $0x5,%al
     b11:	19 06                	sbb    %eax,(%rsi)
     b13:	67 04 06             	addr32 add $0x6,%al
    lru_stats->v1 += 1;
     b16:	05 01 03 81 7e       	add    $0x7e810301,%eax
     b1b:	58                   	pop    %rax
     b1c:	04 00                	add    $0x0,%al
     b1e:	05 0b 03 80 02       	add    $0x280030b,%eax
     b23:	90                   	nop
     b24:	06                   	(bad)
     b25:	3c 05                	cmp    $0x5,%al
     b27:	27                   	(bad)
     b28:	06                   	(bad)
     b29:	6b 05 0d 08 91 06 3c 	imul   $0x3c,0x691080d(%rip),%eax        # 691133d <_license+0x690f2a3>
     b30:	05 1a 06 67 04       	add    $0x467061a,%eax
     b35:	09 05 13 03 d2 7d    	or     %eax,0x7dd20313(%rip)        # 7dd20e4e <_license+0x7dd1edb4>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     b3b:	90                   	nop
     b3c:	05 35 06 4a 05       	add    $0x54a0635,%eax
     b41:	09 3c 05 2d 06 69 05 	or     %edi,0x569062d(,%rax,1)
  if (!lru_map) {
     b48:	09 06                	or     %eax,(%rsi)
     b4a:	3c 04                	cmp    $0x4,%al
     b4c:	00 05 29 06 03 b1    	add    %al,-0x4efcf9d7(%rip)        # ffffffffb103117b <server_id_map+0x5ffffe37e0617b>
     b52:	04 66                	add    $0x66,%al
  if ((vip_info->flags & F_QUIC_VIP)) {
     b54:	05 07 03 db 7d       	add    $0x7ddb0307,%eax
     b59:	58                   	pop    %rax
     b5a:	06                   	(bad)
     b5b:	82                   	(bad)
     b5c:	03 80 7b 66 03 80    	add    -0x7ffc9985(%rax),%eax
    bool is_icmp = (pckt.flags & F_ICMP);
     b62:	05 e4 05 08 06       	add    $0x60805e4,%eax
    if (is_icmp) {
     b67:	08 13                	or     %dl,(%rbx)
     b69:	05 07 06 3c 04       	add    $0x43c0607,%eax
     b6e:	09 05 23 06 03 fc    	or     %eax,-0x3fcf9dd(%rip)        # fffffffffc031197 <server_id_map+0x5ffffe82e06197>
     b74:	7d ac                	jge    b22 <balancer_ingress+0xb22>
     b76:	06                   	(bad)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     b77:	03 83 7d 4a 05 08    	add    0x8054a7d(%rbx),%eax
     b7d:	06                   	(bad)
     b7e:	03 88 03 c8 05 07    	add    0x705c803(%rax),%ecx
     b84:	06                   	(bad)
     b85:	3c 05                	cmp    $0x5,%al
      if (!quic_packets_stats) {
     b87:	19 06                	sbb    %eax,(%rsi)
     b89:	6a 05                	push   $0x5
     b8b:	23 06                	and    (%rsi),%eax
     b8d:	3c 05                	cmp    $0x5,%al
     b8f:	07                   	(bad)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b90:	06                   	(bad)
     b91:	5a                   	pop    %rdx
     b92:	05 15 08 a2 05       	add    $0x5a20815,%eax
  bool is_icmp = (pckt->flags & F_ICMP);
     b97:	1d 06 3c 05 27       	sbb    $0x27053c06,%eax
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b9c:	4a 05 24 4a 05 3a    	rex.WX add $0x3a054a24,%rax
     ba2:	4a 05 44 3c 04 00    	rex.WX add $0x43c44,%rax
     ba8:	05 14 06 03 af       	add    $0xaf030614,%eax
     bad:	7e 9e                	jle    b4d <balancer_ingress+0xb4d>
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     baf:	05 12 4c 06 03       	add    $0x3064c12,%eax
     bb4:	bd 7e 3c 03 c3       	mov    $0xc3033c7e,%ebp
     bb9:	01 3c 05 14 06 67 05 	add    %edi,0x5670614(,%rax,1)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     bc0:	0b 4b 06             	or     0x6(%rbx),%ecx
     bc3:	03 bb 7e 4a 03 c5    	add    -0x3afcb582(%rbx),%edi
     bc9:	01 9e 05 1f 06 03    	add    %ebx,0x3061f05(%rsi)
    vip.port = 0;
     bcf:	cd 03                	int    $0x3
     bd1:	ba 05 2e 06 58       	mov    $0x58062e05,%edx
     bd6:	05 0a 06 03 da       	add    $0xda03060a,%eax
     bdb:	02 66 05             	add    0x5(%rsi),%ah
     bde:	09 06                	or     %eax,(%rsi)
     be0:	3c 05                	cmp    $0x5,%al
    if (!vip_info) {
     be2:	10 06                	adc    %al,(%rsi)
     be4:	03 27                	add    (%rdi),%esp
     be6:	66 06                	data16 (bad)
     be8:	82                   	(bad)
     be9:	66 05 08 06          	add    $0x608,%ax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     bed:	08 e5                	or     %ah,%ch
     bef:	05 07 06 3c 03       	add    $0x33c0607,%eax
     bf4:	ec                   	in     (%dx),%al
     bf5:	77 66                	ja     c5d <balancer_ingress+0xc5d>
      pckt.flow.port16[1] = 0;
     bf7:	05 12 06 03 97       	add    $0x97030612,%eax
     bfc:	08 ac 05 15 4b 05 12 	or     %ch,0x12054b15(%rbp,%rax,1)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c03:	06                   	(bad)
     c04:	3c 05                	cmp    $0x5,%al
     c06:	10 06                	adc    %al,(%rsi)
     c08:	4d 06                	rex.WRB (bad)
     c0a:	03 e5                	add    %ebp,%esp
     c0c:	77 08                	ja     c16 <balancer_ingress+0xc16>
     c0e:	12 03                	adc    (%rbx),%al
     c10:	9b                   	fwait
     c11:	08 9e 05 08 06 08    	or     %bl,0x8060805(%rsi)
     c17:	13 05 07 06 3c 05    	adc    0x53c0607(%rip),%eax        # 53c1224 <_license+0x53bf18a>
      if (!data_stats) {
     c1d:	12 06                	adc    (%rsi),%al
     c1f:	69 4b 05 17 51 05 12 	imul   $0x12055117,0x5(%rbx),%ecx
      data_stats->v1 += 1;
     c26:	67 05 07 06 66 04    	addr32 add $0x4660607,%eax
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     c2c:	0d 05 49 06 03       	or     $0x3064905,%eax
     c31:	bb 78 66 06 03       	mov    $0x3066678,%ebx
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     c36:	9d                   	popf
     c37:	7f 66                	jg     c9f <balancer_ingress+0xc9f>
     c39:	05 07 06 03 e6       	add    $0xe6030607,%eax
        data_stats->v2 += 1;
     c3e:	00 74 06 ba          	add    %dh,-0x46(%rsi,%rax,1)
     c42:	05 1c 06 69 05       	add    $0x569061c,%eax
     c47:	20 4b 05             	and    %cl,0x5(%rbx)
     c4a:	0e                   	(bad)
     c4b:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     c51:	06                   	(bad)
     c52:	3c 03                	cmp    $0x3,%al
     c54:	92                   	xchg   %eax,%edx
     c55:	7f 66                	jg     cbd <balancer_ingress+0xcbd>
     c57:	03 ee                	add    %esi,%ebp
     c59:	00 90 03 92 7f 90    	add    %dl,-0x6f806dfd(%rax)
  if (!lru_map) {
     c5f:	05 03 06 03 f1       	add    $0xf1030603,%eax
     c64:	00 08                	add    %cl,(%rax)
     c66:	ba 08 2f 05 14       	mov    $0x14052f08,%edx
     c6b:	d7                   	xlat   %ds:(%rbx)
  if ((vip_info->flags & F_QUIC_VIP)) {
     c6c:	05 1c 68 05 2e       	add    $0x2e05681c,%eax
     c71:	06                   	(bad)
     c72:	4a 04 0e             	rex.WX add $0xe,%al
    bool is_icmp = (pckt.flags & F_ICMP);
     c75:	05 0c 06 03 45       	add    $0x4503060c,%eax
    if (is_icmp) {
     c7a:	4a                   	rex.WX
     c7b:	4f 05 12 40 05 10    	rex.WRXB add $0x10054012,%rax
     c81:	06                   	(bad)
     c82:	74 05                	je     c89 <balancer_ingress+0xc89>
     c84:	0b 06                	or     (%rsi),%eax
     c86:	4b 05 0e 75 3d 05    	rex.WXB add $0x53d750e,%rax
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     c8c:	0c 3d                	or     $0x3d,%al
     c8e:	04 0c                	add    $0xc,%al
     c90:	05 0e 03 71 66       	add    $0x6671030e,%eax
     c95:	06                   	(bad)
     c96:	03 48 74             	add    0x74(%rax),%ecx
     c99:	04 00                	add    $0x0,%al
      if (!quic_packets_stats) {
     c9b:	05 1b 06 03 ed       	add    $0xed03061b,%eax
     ca0:	07                   	(bad)
     ca1:	58                   	pop    %rax
     ca2:	05 0b 06 58 05       	add    $0x558060b,%eax
  bool is_icmp = (pckt->flags & F_ICMP);
     ca7:	0d 06 31 05 0e       	or     $0xe053106,%eax
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     cac:	08 91 05 0d 06 3c    	or     %dl,0x3c060d05(%rcx)
     cb2:	06                   	(bad)
     cb3:	69 05 00 06 03 8c 78 	imul   $0x1705ba78,-0x73fcfa00(%rip),%eax        # ffffffff8c0312bd <server_id_map+0x5ffffe12e062bd>
     cba:	ba 05 17 
     cbd:	06                   	(bad)
     cbe:	03 de                	add    %esi,%ebx
     cc0:	00 58 05             	add    %bl,0x5(%rax)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     cc3:	07                   	(bad)
     cc4:	03 4c 08 20          	add    0x20(%rax,%rcx,1),%ecx
     cc8:	06                   	(bad)
     cc9:	03 56 08             	add    0x8(%rsi),%edx
     ccc:	90                   	nop
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     ccd:	05 08 06 03 2b       	add    $0x2b030608,%eax
     cd2:	2e 05 07 06 3c 03    	cs add $0x33c0607,%eax
  if (!connId) {
     cd8:	55                   	push   %rbp
     cd9:	2e 05 0f 06 03 2e    	cs add $0x2e03060f,%eax
  __u8 connIdVersion = (connId[0] >> 6);
     cdf:	74 05                	je     ce6 <balancer_ingress+0xce6>
     ce1:	12 32                	adc    (%rdx),%dh
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     ce3:	05 29 06 74 05       	add    $0x5740629,%eax
     ce8:	07                   	(bad)
     ce9:	74 05                	je     cf0 <balancer_ingress+0xcf0>
     ceb:	19 06                	sbb    %eax,(%rsi)
     ced:	30 83 06 03 4b 66    	xor    %al,0x664b0306(%rbx)
     cf3:	06                   	(bad)
     cf4:	03 37                	add    (%rdi),%esi
     cf6:	4a 05 1d bb 05 09    	rex.WX add $0x905bb1d,%rax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     cfc:	06                   	(bad)
     cfd:	74 03                	je     d02 <balancer_ingress+0xd02>
     cff:	48                   	rex.W
     d00:	2e 05 19 06 03 88    	cs add $0x88030619,%eax
     d06:	01 74 05 09          	add    %esi,0x9(%rbp,%rax,1)
     d0a:	06                   	(bad)
     d0b:	3c 05                	cmp    $0x5,%al
     d0d:	00 03                	add    %al,(%rbx)
     d0f:	f8                   	clc
     d10:	7e 2e                	jle    d40 <balancer_ingress+0xd40>
     d12:	05 1e 06 03 8c       	add    $0x8c03061e,%eax
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     d17:	01 66 05             	add    %esp,0x5(%rsi)
     d1a:	1c 06                	sbb    $0x6,%al
     d1c:	58                   	pop    %rax
     d1d:	05 07 06 59 06       	add    $0x6590607,%eax
     d22:	03 f3                	add    %ebx,%esi
     d24:	7e 08                	jle    d2e <balancer_ingress+0xd2e>
     d26:	3c 04                	cmp    $0x4,%al
     d28:	0a 05 05 06 03 e8    	or     -0x17fcf9fb(%rip),%al        # ffffffffe8031333 <server_id_map+0x5ffffe6ee06333>
     d2e:	00 58 49             	add    %bl,0x49(%rax)
      if (!data_stats) {
     d31:	05 03 69 05 1a       	add    $0x1a056903,%eax
     d36:	03 9e 7f 82 05 03    	add    0x305827f(%rsi),%ebx
      data_stats->v1 += 1;
     d3c:	03 e2                	add    %edx,%esp
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     d3e:	00 58 05             	add    %bl,0x5(%rax)
     d41:	1a 03                	sbb    (%rbx),%al
     d43:	9e                   	sahf
     d44:	7f 4a                	jg     d90 <balancer_ingress+0xd90>
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     d46:	05 03 03 e2 00       	add    $0xe20303,%eax
     d4b:	58                   	pop    %rax
     d4c:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
  original_sport = pckt.flow.port16[0];
     d51:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     d57:	58                   	pop    %rax
     d58:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
     d5d:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
        !(vip_info->flags & F_LRU_BYPASS)) {
     d63:	58                   	pop    %rax
     d64:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
     d69:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
     d6f:	58                   	pop    %rax
     d70:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
     d75:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
  if (!dst_lru) {
     d7b:	3c 05                	cmp    $0x5,%al
     d7d:	1a 03                	sbb    (%rbx),%al
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
     d7f:	9e                   	sahf
     d80:	7f 4a                	jg     dcc <balancer_ingress+0xdcc>
     d82:	05 03 03 e2 00       	add    $0xe20303,%eax
     d87:	3c 06                	cmp    $0x6,%al
     d89:	03 96 7f 2e 04 00    	add    0x42e7f(%rsi),%edx
     d8f:	05 30 06 03 8f       	add    $0x8f030630,%eax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
     d94:	01 58 06             	add    %ebx,0x6(%rax)
     d97:	03 f1                	add    %ecx,%esi
     d99:	7e 08                	jle    da3 <balancer_ingress+0xda3>
     d9b:	12 05 22 06 03 90    	adc    -0x6ffcf9de(%rip),%al        # ffffffff900313c3 <server_id_map+0x5ffffe16e063c3>
     da1:	01 58 05             	add    %ebx,0x5(%rax)
     da4:	15 06 3c 05 2b       	adc    $0x2b053c06,%eax
     da9:	74 05                	je     db0 <balancer_ingress+0xdb0>
     dab:	10 06                	adc    %al,(%rsi)
     dad:	30 05 09 67 05 10    	xor    %al,0x10056709(%rip)        # 100574bc <_license+0x10055422>
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     db3:	65 06                	gs (bad)
     db5:	03 ee                	add    %esi,%ebp
     db7:	7e 2e                	jle    de7 <balancer_ingress+0xde7>
     db9:	05 0b 06 03 96       	add    $0x9603060b,%eax
     dbe:	01 9e 05 09 9f 05    	add    %ebx,0x59f0905(%rsi)
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
     dc4:	14 35                	adc    $0x35,%al
     dc6:	05 0b 4b 05 07       	add    $0x7054b0b,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     dcb:	67 03 a5 7f 2e 05 08 	add    0x8052e7f(%ebp),%esp
     dd2:	08 91 05 07 06 3c    	or     %dl,0x3c060705(%rcx)
     dd8:	06                   	(bad)
     dd9:	03 0a                	add    (%rdx),%ecx
     ddb:	ac                   	lods   %ds:(%rsi),%al
     ddc:	05 08 08 91 05       	add    $0x5910808,%eax
     de1:	07                   	(bad)
     de2:	06                   	(bad)
     de3:	3c 06                	cmp    $0x6,%al
  if (!conn_rate_stats) {
     de5:	03 d5                	add    %ebp,%edx
     de7:	00 ac 05 0f 06 66 03 	add    %ch,0x366060f(%rbp,%rax,1)
     dee:	da 7e 2e             	fidivrl 0x2e(%rsi)
     df1:	05 24 03 a6 01       	add    $0x1a60324,%eax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     df6:	58                   	pop    %rax
     df7:	05 34 74 03 da       	add    $0xda037434,%eax
     dfc:	7e 82                	jle    d80 <balancer_ingress+0xd80>
     dfe:	04 0d                	add    $0xd,%al
     e00:	05 07 06 03 3a       	add    $0x3a030607,%eax
     e05:	d6                   	(bad)
    conn_rate_stats->v1 = 1;
     e06:	06                   	(bad)
     e07:	ba 05 1c 06 69       	mov    $0x69061c05,%edx
     e0c:	05 20 4b 05 0f       	add    $0xf054b20,%eax
    conn_rate_stats->v2 = *cur_time;
     e11:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     e17:	06                   	(bad)
     e18:	3c 03                	cmp    $0x3,%al
     e1a:	be 7f 66 03 c2       	mov    $0xc203667f,%esi
     e1f:	00 90 03 be 7f d6    	add    %dl,-0x298041fd(%rax)
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     e25:	05 03 06 03 c5       	add    $0xc5030603,%eax
        quic_packets_stats->cid_initial += 1;
     e2a:	00 9e 08 2f 05 14    	add    %bl,0x14052f08(%rsi)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     e30:	d7                   	xlat   %ds:(%rbx)
     e31:	05 00 06 03 b9       	add    $0xb9030600,%eax
     e36:	7f 66                	jg     e9e <balancer_ingress+0xe9e>
     e38:	04 0e                	add    $0xe,%al
     e3a:	05 12 06 03 25       	add    $0x25030612,%eax
     e3f:	58                   	pop    %rax
     e40:	04 0d                	add    $0xd,%al
     e42:	05 1d 03 2e 4a       	add    $0x4a2e031d,%eax
     e47:	04 0e                	add    $0xe,%al
     e49:	05 03 4b 05 20       	add    $0x20054b03,%eax
     e4e:	68 05 12 06 58       	push   $0x58061205
     e53:	05 23 06 67 05       	add    $0x5670623,%eax
     e58:	15 06 3c 05 11       	adc    $0x11053c06,%eax
     e5d:	06                   	(bad)
     e5e:	40 05 15 67 05 03    	rex add $0x3056715,%eax
  if (!per_vip_stats) {
     e64:	4c 08 21             	rex.WR or %r12b,(%rcx)
     e67:	04 09                	add    $0x9,%al
     e69:	05 0a 03 ba 02       	add    $0x2ba030a,%eax
     e6e:	d6                   	(bad)
    conn_rate_stats->v1 += 1;
     e6f:	05 14 06 4a 05       	add    $0x54a0614,%eax
     e74:	1e                   	(bad)
     e75:	4a 05 28 4a 05 1b    	rex.WX add $0x1b054a28,%rax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
     e7b:	4a 05 32 3c 05 3c    	rex.WX add $0x3c053c32,%rax
     e81:	4a 05 2f 4a 05 45    	rex.WX add $0x45054a2f,%rax
     e87:	3c 03                	cmp    $0x3,%al
     e89:	e7 7c                	out    %eax,$0x7c
     e8b:	3c 05                	cmp    $0x5,%al
     e8d:	19 06                	sbb    %eax,(%rsi)
     e8f:	03 95 03 4a 05 23    	add    0x23054a03(%rbp),%edx
     e95:	06                   	(bad)
     e96:	4a 05 2d 4a 05 37    	rex.WX add $0x37054a2d,%rax
    if (down_reals_map) {
     e9c:	4a 05 2a 4a 05 40    	rex.WX add $0x40054a2a,%rax
     ea2:	3c 03                	cmp    $0x3,%al
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
     ea4:	eb 7c                	jmp    f22 <balancer_ingress+0xf22>
     ea6:	3c 04                	cmp    $0x4,%al
     ea8:	00 05 19 06 03 f5    	add    %al,-0xafcf9e7(%rip)        # fffffffff50314c7 <server_id_map+0x5ffffe7be064c7>
     eae:	06                   	(bad)
     eaf:	82                   	(bad)
     eb0:	05 0b 06 2e 05       	add    $0x52e060b,%eax
      if (down_real) {
     eb5:	07                   	(bad)
     eb6:	06                   	(bad)
     eb7:	03 c3                	add    %ebx,%eax
     eb9:	7d 66                	jge    f21 <balancer_ingress+0xf21>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
     ebb:	06                   	(bad)
     ebc:	03 c8                	add    %eax,%ecx
     ebe:	7b 08                	jnp    ec8 <balancer_ingress+0xec8>
     ec0:	9e                   	sahf
     ec1:	05 1a 06 03 a7       	add    $0xa703061a,%eax
     ec6:	01 9e 05 09 06 58    	add    %ebx,0x58060905(%rsi)
     ecc:	05 19 06 2f 05       	add    $0x52f0619,%eax
     ed1:	15 5a 06 03 d6       	adc    $0xd603065a,%eax
        if (stats_data) {
     ed6:	7e 4a                	jle    f22 <balancer_ingress+0xf22>
     ed8:	04 06                	add    $0x6,%al
     eda:	05 01 06 03 9d       	add    $0x9d030601,%eax
          stats_data->v1 += 1;
     edf:	03 58 04             	add    0x4(%rax),%ebx
     ee2:	00 05 0b 03 e7 04    	add    %al,0x4e7030b(%rip)        # 4e711f3 <_license+0x4e6f159>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     ee8:	08 20                	or     %ah,(%rax)
     eea:	06                   	(bad)
     eeb:	03 fc                	add    %esp,%edi
     eed:	77 4a                	ja     f39 <balancer_ingress+0xf39>
     eef:	05 28 06 03 d5       	add    $0xd5030628,%eax
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     ef4:	04 f2                	add    $0xf2,%al
     ef6:	05 35 06 74 05       	add    $0x5740635,%eax
     efb:	36 06                	ss (bad)
        quic_packets_stats->cid_initial += 1;
     efd:	59                   	pop    %rcx
     efe:	05 2f 06 4a 05       	add    $0x54a062f,%eax
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     f03:	00 03                	add    %al,(%rbx)
     f05:	aa                   	stos   %al,%es:(%rdi)
     f06:	7b 66                	jnp    f6e <balancer_ingress+0xf6e>
     f08:	05 22 06 03 d7       	add    $0xd7030622,%eax
     f0d:	04 4a                	add    $0x4a,%al
     f0f:	05 1c af 06 58       	add    $0x5806af1c,%eax
     f14:	66 03 a6 7b 2e 03 da 	add    -0x25fcd185(%rsi),%sp
     f1b:	04 9e                	add    $0x9e,%al
     f1d:	05 0a 06 08 13       	add    $0x1308060a,%eax
     f22:	05 09 06 3c 05       	add    $0x53c0609,%eax
     f27:	14 06                	adc    $0x6,%al
     f29:	69 06 03 a2 7b 3c    	imul   $0x3c7ba203,(%rsi),%eax
  if (!per_vip_stats) {
     f2f:	05 16 06 03 89       	add    $0x89030616,%eax
     f34:	08 08                	or     %cl,(%rax)
     f36:	e4 04                	in     $0x4,%al
     f38:	09 05 23 03 f4 7a    	or     %eax,0x7af40323(%rip)        # 7af41261 <_license+0x7af3f1c7>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
     f3e:	9e                   	sahf
     f3f:	06                   	(bad)
     f40:	03 83 7d 4a 05 08    	add    0x8054a7d(%rbx),%eax
     f46:	06                   	(bad)
     f47:	03 88 03 c8 05 07    	add    0x705c803(%rax),%ecx
     f4d:	06                   	(bad)
  if (!connId) {
     f4e:	3c 03                	cmp    $0x3,%al
     f50:	f8                   	clc
     f51:	7c ac                	jl     eff <balancer_ingress+0xeff>
     f53:	04 00                	add    $0x0,%al
     f55:	05 1b 06 03 fa       	add    $0xfa03061b,%eax
  __u8 connIdVersion = (connId[0] >> 6);
     f5a:	06                   	(bad)
     f5b:	08 82 05 0d 59 06    	or     %al,0x6590d05(%rdx)
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     f61:	03 85 79 2e 05 11    	add    0x11052e79(%rbp),%eax
     f67:	06                   	(bad)
     f68:	03 fd                	add    %ebp,%edi
     f6a:	06                   	(bad)
     f6b:	9e                   	sahf
     f6c:	05 0f 9f 05 1d       	add    $0x1d059f0f,%eax
     f71:	35 05 13 67 06       	xor    $0x6671305,%eax
     f76:	66 03 fa             	add    %dx,%di
     f79:	78 4a                	js     fc5 <balancer_ingress+0xfc5>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     f7b:	03 86 07 9e 05 12    	add    0x12059e07(%rsi),%eax
     f81:	06                   	(bad)
     f82:	bb 05 11 06 3c       	mov    $0x3c061105,%ebx
     f87:	03 f9                	add    %ecx,%edi
     f89:	78 66                	js     ff1 <balancer_ingress+0xff1>
     f8b:	04 06                	add    $0x6,%al
     f8d:	05 01 06 03 98       	add    $0x98030601,%eax
     f92:	03 58 04             	add    0x4(%rax),%ebx
     f95:	00 05 07 03 d3 01    	add    %al,0x1d30307(%rip)        # 1d312a2 <_license+0x1d2f208>
  key = dst_lru->pos;
     f9b:	ac                   	lods   %ds:(%rsi),%al
     f9c:	06                   	(bad)
     f9d:	3c 05                	cmp    $0x5,%al
     f9f:	1f                   	(bad)
     fa0:	06                   	(bad)
     fa1:	67 05 16 06 4a 05    	addr32 add $0x54a0616,%eax
  pckt->real_index = key;
     fa7:	09 2e                	or     %ebp,(%rsi)
     fa9:	05 23 06 03 a4       	add    $0xa4030623,%eax
     fae:	02 66 05             	add    0x5(%rsi),%ah
     fb1:	00 06                	add    %al,(%rsi)
     fb3:	03 f0                	add    %eax,%esi
     fb5:	78 ba                	js     f71 <balancer_ingress+0xf71>
     fb7:	05 14 06 03 b4       	add    $0xb4030614,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
     fbc:	07                   	(bad)
     fbd:	08 4a 05             	or     %cl,0x5(%rdx)
     fc0:	1e                   	(bad)
     fc1:	03 26                	add    (%rsi),%esp
     fc3:	66 05 2b 06          	add    $0x62b,%ax
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     fc7:	58                   	pop    %rax
     fc8:	05 1b 06 2f 05       	add    $0x52f061b,%eax
     fcd:	09 3b                	or     %edi,(%rbx)
    if (!dst) {
     fcf:	06                   	(bad)
     fd0:	03 a6 78 2e 04 06    	add    0x6042e78(%rsi),%esp
     fd6:	05 01 06 03 98       	add    $0x98030601,%eax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
     fdb:	03 58 04             	add    0x4(%rax),%ebx
     fde:	00 05 08 03 a1 7e    	add    %al,0x7ea10308(%rip)        # 7ea112ec <_license+0x7ea0f252>
     fe4:	ac                   	lods   %ds:(%rsi),%al
     fe5:	05 07 06 3c 05       	add    $0x53c0607,%eax
     fea:	00 03                	add    %al,(%rbx)
     fec:	c7                   	(bad)
     fed:	7e 2e                	jle    101d <balancer_ingress+0x101d>
     fef:	05 28 06 03 bc       	add    $0xbc030628,%eax
     ff4:	01 3c 05 07 06 58 03 	add    %edi,0x3580607(,%rax,1)
     ffb:	c4                   	(bad)
     ffc:	7e 2e                	jle    102c <balancer_ingress+0x102c>
     ffe:	05 10 06 03 bd       	add    $0xbd030610,%eax
    1003:	01 74 05 12          	add    %esi,0x12(%rbp,%rax,1)
  if (!data_stats) {
    1007:	2f                   	(bad)
    1008:	05 23 06 08 12       	add    $0x12080623,%eax
    100d:	05 09 3c 03 c2       	add    $0xc2033c09,%eax
    1012:	7e 2e                	jle    1042 <balancer_ingress+0x1042>
    1014:	05 14 06 03 c1       	add    $0xc1030614,%eax
    1019:	01 82 05 12 4c 06    	add    %eax,0x64c1205(%rdx)
  data_stats->v2 += pkt_bytes;
    101f:	03 bd 7e 3c 03 c3    	add    -0x3cfcc382(%rbp),%edi
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1025:	01 2e                	add    %ebp,(%rsi)
    1027:	05 14 06 67 05       	add    $0x5670614,%eax
    102c:	0b 4b 06             	or     0x6(%rbx),%ecx
    102f:	03 bb 7e 4a 03 c5    	add    -0x3afcb582(%rbx),%edi
    1035:	01 9e 03 bb 7e ba    	add    %ebx,-0x458144fd(%rsi)
    103b:	05 1f 06 03 92       	add    $0x9203061f,%eax
    1040:	05 58 05 2e 06       	add    $0x62e0558,%eax
    1045:	58                   	pop    %rax
    1046:	05 17 06 67 05       	add    $0x5670617,%eax
    104b:	2e 06                	cs (bad)
    104d:	4a 05 07 06 03 97    	rex.WX add $0xffffffff97030607,%rax
  if (!data_stats) {
    1053:	7b 66                	jnp    10bb <balancer_ingress+0x10bb>
    1055:	05 08 08 91 05       	add    $0x5910808,%eax
  data_stats->v1 += 1;
    105a:	07                   	(bad)
    105b:	06                   	(bad)
    105c:	3c 03                	cmp    $0x3,%al
  data_stats->v2 += pkt_bytes;
    105e:	55                   	push   %rbp
    105f:	66 05 0f 06          	add    $0x60f,%ax
  pckt.flow.port16[0] = original_sport;
    1063:	03 2e                	add    (%rsi),%ebp
    1065:	74 05                	je     106c <balancer_ingress+0x106c>
    1067:	12 32                	adc    (%rdx),%dh
  if (dst->flags & F_IPV6) {
    1069:	05 29 06 74 05       	add    $0x5740629,%eax
    106e:	07                   	(bad)
    106f:	74 05                	je     1076 <balancer_ingress+0x1076>
    1071:	19 06                	sbb    %eax,(%rsi)
    1073:	30 83 68 05 1d bb    	xor    %al,-0x44e2fa98(%rbx)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1079:	05 09 06 66 04       	add    $0x4660609,%eax
    107e:	06                   	(bad)
    107f:	05 01 06 03 e0       	add    $0xe0030601,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1084:	02 2e                	add    (%rsi),%ch
    1086:	04 00                	add    $0x0,%al
    1088:	05 09 03 fe 01       	add    $0x1fe0309,%eax
    108d:	08 4a 06             	or     %cl,0x6(%rdx)
    1090:	3c 05                	cmp    $0x5,%al
    1092:	19 06                	sbb    %eax,(%rsi)
  data = (void*)(long)xdp->data;
    1094:	2f                   	(bad)
    1095:	04 06                	add    $0x6,%al
  data_end = (void*)(long)xdp->data_end;
    1097:	05 01 03 81 7e       	add    $0x7e810301,%eax
  iph = data + sizeof(struct ethhdr);
    109c:	58                   	pop    %rax
    109d:	04 00                	add    $0x0,%al
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    109f:	05 0b 03 80 02       	add    $0x280030b,%eax
    10a4:	90                   	nop
    10a5:	06                   	(bad)
    10a6:	3c 05                	cmp    $0x5,%al
    10a8:	27                   	(bad)
    10a9:	06                   	(bad)
    10aa:	33 05 0d 08 91 06    	xor    0x691080d(%rip),%eax        # 69118bd <_license+0x690f823>
    10b0:	3c 05                	cmp    $0x5,%al
    10b2:	1a 06                	sbb    (%rsi),%al
    10b4:	67 05 0a 03 cd 02    	addr32 add $0x2cd030a,%eax
    10ba:	90                   	nop
    10bb:	05 09 06 3c 03       	add    $0x33c0609,%eax
    10c0:	94                   	xchg   %eax,%esp
    10c1:	78 66                	js     1129 <balancer_ingress+0x1129>
    10c3:	05 10 06 03 93       	add    $0x93030610,%eax
    10c8:	08 58 06             	or     %bl,0x6(%rax)
    10cb:	66 66 05 08 06       	data16 add $0x608,%ax
    10d0:	08 9f 05 07 06 3c    	or     %bl,0x3c060705(%rdi)
    10d6:	03 ec                	add    %esp,%ebp
  memcpy(new_eth->h_dest, cval->mac, 6);
    10d8:	77 66                	ja     1140 <balancer_ingress+0x1140>
    10da:	05 12 06 03 97       	add    $0x97030612,%eax
    10df:	08 82 05 15 75 05    	or     %al,0x5751505(%rdx)
    10e5:	12 06                	adc    (%rsi),%al
    10e7:	3c 05                	cmp    $0x5,%al
    10e9:	10 06                	adc    %al,(%rsi)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    10eb:	4d 06                	rex.WRB (bad)
    10ed:	03 e5                	add    %ebp,%esp
    10ef:	77 08                	ja     10f9 <balancer_ingress+0x10f9>
    10f1:	12 03                	adc    (%rbx),%al
    10f3:	9b                   	fwait
    10f4:	08 9e 05 08 06 08    	or     %bl,0x8060805(%rsi)
  new_eth->h_proto = BE_ETH_P_IP;
    10fa:	13 05 07 06 3c 05    	adc    0x53c0607(%rip),%eax        # 53c1707 <_license+0x53bf66d>
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1100:	12 06                	adc    (%rsi),%al
    1102:	69 4b 05 17 51 05 12 	imul   $0x12055117,0x5(%rbx),%ecx
  iph->ihl = 5;
    1109:	67 05 07 06 4a 04    	addr32 add $0x44a0607,%eax
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    110f:	0d 05 49 06 03       	or     $0x3064905,%eax
    1114:	bb 78 66 06 03       	mov    $0x3066678,%ebx
  iph->id = 0;
    1119:	9d                   	popf
    111a:	7f 66                	jg     1182 <balancer_ingress+0x1182>
    111c:	05 07 06 03 e6       	add    $0xe6030607,%eax
  iph->daddr = daddr;
    1121:	00 74 06 ba          	add    %dh,-0x46(%rsi,%rax,1)
  iph->ttl = DEFAULT_TTL;
    1125:	05 1c 06 69 05       	add    $0x569061c,%eax
    112a:	20 4b 05             	and    %cl,0x5(%rbx)
    112d:	0e                   	(bad)
    112e:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
    1134:	06                   	(bad)
    1135:	3c 03                	cmp    $0x3,%al
      if (pckt.flow.proto == IPPROTO_TCP) {
    1137:	92                   	xchg   %eax,%edx
    1138:	7f 66                	jg     11a0 <balancer_ingress+0x11a0>
    113a:	03 ee                	add    %esi,%ebp
    113c:	00 90 03 92 7f 90    	add    %dl,-0x6f806dfd(%rax)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1142:	05 03 06 03 f1       	add    $0xf1030603,%eax
    1147:	00 08                	add    %cl,(%rax)
    1149:	ba 08 2f 05 14       	mov    $0x14052f08,%edx
    114e:	d7                   	xlat   %ds:(%rbx)
    114f:	05 1c 68 05 2e       	add    $0x2e05681c,%eax
    1154:	06                   	(bad)
    1155:	4a 04 0e             	rex.WX add $0xe,%al
        if (!lru_stats) {
    1158:	05 0c 06 03 45       	add    $0x4503060c,%eax
    115d:	2e 4f 05 12 40 05 10 	cs rex.WRXB add $0x10054012,%rax
        if (pckt.flags & F_SYN_SET) {
    1164:	06                   	(bad)
    1165:	90                   	nop
    1166:	05 0b 06 59 05       	add    $0x559060b,%eax
    116b:	0e                   	(bad)
    116c:	75 3d                	jne    11ab <balancer_ingress+0x11ab>
    116e:	05 0c 3d 04 0c       	add    $0xc043d0c,%eax
  struct real_pos_lru new_dst_lru = {};
    1173:	05 0e 03 71 66       	add    $0x6671030e,%eax
    1178:	04 00                	add    $0x0,%al
    117a:	05 00 06 03 48       	add    $0x48030600,%eax
    117f:	82                   	(bad)
    1180:	05 1b 06 03 ed       	add    $0xed03061b,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1185:	07                   	(bad)
    1186:	02 8e 01 01 05 0b    	add    0xb050101(%rsi),%cl
    118c:	06                   	(bad)
    118d:	58                   	pop    %rax
    118e:	05 0d 06 31 05       	add    $0x531060d,%eax
    1193:	0e                   	(bad)
    1194:	08 91 05 0d 06 3c    	or     %dl,0x3c060d05(%rcx)
    119a:	06                   	(bad)
    119b:	69 05 00 06 03 8c 78 	imul   $0x1705ba78,-0x73fcfa00(%rip),%eax        # ffffffff8c0317a5 <server_id_map+0x5ffffe12e067a5>
    11a2:	ba 05 17 
    11a5:	06                   	(bad)
    11a6:	03 de                	add    %esi,%ebx
    11a8:	00 58 05             	add    %bl,0x5(%rax)
    11ab:	07                   	(bad)
  *cur_time = bpf_ktime_get_ns();
    11ac:	03 4c 08 20          	add    0x20(%rax,%rcx,1),%ecx
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    11b0:	06                   	(bad)
    11b1:	03 56 08             	add    0x8(%rsi),%edx
    11b4:	90                   	nop
    11b5:	05 08 06 03 2b       	add    $0x2b030608,%eax
    11ba:	3c 05                	cmp    $0x5,%al
    11bc:	07                   	(bad)
    11bd:	06                   	(bad)
    conn_rate_stats->v1 = 1;
    11be:	3c 03                	cmp    $0x3,%al
    11c0:	55                   	push   %rbp
    11c1:	2e 05 0f 06 03 2e    	cs add $0x2e03060f,%eax
    conn_rate_stats->v2 = *cur_time;
    11c7:	74 05                	je     11ce <balancer_ingress+0x11ce>
    11c9:	12 32                	adc    (%rdx),%dh
    11cb:	05 29 06 74 05       	add    $0x5740629,%eax
    conn_rate_stats->v1 += 1;
    11d0:	07                   	(bad)
    11d1:	74 05                	je     11d8 <balancer_ingress+0x11d8>
    11d3:	19 06                	sbb    %eax,(%rsi)
    11d5:	30 75 06             	xor    %dh,0x6(%rbp)
    11d8:	03 4b 66             	add    0x66(%rbx),%ecx
    11db:	06                   	(bad)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    11dc:	03 37                	add    (%rdi),%esi
    11de:	4a 05 1d 9f 05 09    	rex.WX add $0x9059f1d,%rax
    11e4:	06                   	(bad)
    11e5:	74 03                	je     11ea <balancer_ingress+0x11ea>
    11e7:	48                   	rex.W
    11e8:	2e 05 19 06 03 88    	cs add $0x88030619,%eax
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    11ee:	01 82 05 09 06 3c    	add    %eax,0x3c060905(%rdx)
    11f4:	05 00 03 f8 7e       	add    $0x7ef80300,%eax
      pckt->flow.port16[0] = pckt->flow.port16[1];
    11f9:	2e 04 0a             	cs add $0xa,%al
    11fc:	05 0a 06 03 3f       	add    $0x3f03060a,%eax
      memset(pckt->flow.srcv6, 0, 16);
    1201:	4a                   	rex.WX
    1202:	4b 05 11 03 17 4a    	rex.WXB add $0x4a170311,%rax
    1208:	5a                   	pop    %rdx
    1209:	5a                   	pop    %rdx
    120a:	05 0c 5a 04 00       	add    $0x45a0c,%eax
    120f:	05 1e 03 2f 74       	add    $0x742f031e,%eax
    1214:	05 1c 06 58 05       	add    $0x558061c,%eax
    1219:	07                   	(bad)
  b += initval;
    121a:	06                   	(bad)
    121b:	59                   	pop    %rcx
    121c:	04 0a                	add    $0xa,%al
  a += initval;
    121e:	03 b3 7f 02 23 01    	add    0x123027f(%rbx),%esi
  __jhash_final(a, b, c);
    1224:	05 05 67 05 1a       	add    $0x1a056705,%eax
    1229:	03 47 2e             	add    0x2e(%rdi),%eax
  return (word << shift) | (word >> ((-shift) & 31));
    122c:	05 05 03 39 3c       	add    $0x3c390305,%eax
  __jhash_final(a, b, c);
    1231:	05 07 2c 05 05       	add    $0x5052c07,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1236:	84 05 1a 03 47 9e    	test   %al,-0x61b8fce6(%rip)        # ffffffff9e471556 <server_id_map+0x5ffffe25246556>
  __jhash_final(a, b, c);
    123c:	05 05 03 39 58       	add    $0x58390305,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1241:	05 1a 03 47 4a       	add    $0x4a47031a,%eax
  __jhash_final(a, b, c);
    1246:	05 05 03 39 58       	add    $0x58390305,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    124b:	05 1a 03 47 82       	add    $0x8247031a,%eax
    1250:	05 05 03 39 58       	add    $0x58390305,%eax
  __jhash_final(a, b, c);
    1255:	05 1a 03 47 66       	add    $0x6647031a,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    125a:	05 05 03 39 58       	add    $0x58390305,%eax
  __jhash_final(a, b, c);
    125f:	05 1a 03 47 66       	add    $0x6647031a,%eax
    1264:	05 05 03 39 74       	add    $0x74390305,%eax
    1269:	05 0c 03 16 2e       	add    $0x2e16030c,%eax
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    126e:	05 16 06 4a 05       	add    $0x54a0616,%eax
    1273:	0c 06                	or     $0x6,%al
    1275:	3e 05 16 06 4a 05    	ds add $0x54a0616,%eax
    127b:	09 06                	or     %eax,(%rsi)
    127d:	3a 05 0c 32 05 16    	cmp    0x1605320c(%rip),%al        # 1605448f <_license+0x160523f5>
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1283:	06                   	(bad)
    1284:	4a 05 09 06 3a 05    	rex.WX add $0x53a0609,%rax
    128a:	0c 32                	or     $0x32,%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    128c:	05 09 48 30 05       	add    $0x5304809,%eax
    1291:	05 03 64 2e 05       	add    $0x52e6403,%eax
    if (!real_pos) {
    1296:	07                   	(bad)
    1297:	03 1d 2e 05 1a 03    	add    0x31a052e(%rip),%ebx        # 31a17cb <_license+0x319f731>
    129d:	aa                   	stos   %al,%es:(%rdi)
    129e:	7f 3c                	jg     12dc <balancer_ingress+0x12dc>
    12a0:	05 07 03 d6 00       	add    $0xd60307,%eax
    key = *real_pos;
    12a5:	58                   	pop    %rax
    12a6:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    12ab:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
  pckt->real_index = key;
    12b1:	58                   	pop    %rax
    12b2:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
    12b7:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    12bd:	58                   	pop    %rax
    12be:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    12c3:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
    12c9:	58                   	pop    %rax
    12ca:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    12cf:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
    12d5:	58                   	pop    %rax
  if (!ch_drop_stats) {
    12d6:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    12db:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
    12e1:	3c 05                	cmp    $0x5,%al
    12e3:	1a 03                	sbb    (%rbx),%al
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    12e5:	aa                   	stos   %al,%es:(%rdi)
    12e6:	7f 4a                	jg     1332 <balancer_ingress+0x1332>
    12e8:	05 05 03 df 00       	add    $0xdf0305,%eax
    12ed:	3c 75                	cmp    $0x75,%al
    12ef:	49 05 03 69 05 1a    	rex.WB add $0x1a056903,%rax
    12f5:	03 9e 7f 82 05 03    	add    0x305827f(%rsi),%ebx
    12fb:	03 e2                	add    %edx,%esp
    12fd:	00 58 05             	add    %bl,0x5(%rax)
  if (!ch_drop_stats) {
    1300:	1a 03                	sbb    (%rbx),%al
    1302:	9e                   	sahf
    1303:	7f 4a                	jg     134f <balancer_ingress+0x134f>
    1305:	05 03 03 e2 00       	add    $0xe20303,%eax
    130a:	58                   	pop    %rax
    130b:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1310:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    1316:	58                   	pop    %rax
    1317:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    131c:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    1322:	58                   	pop    %rax
    1323:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    1328:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    132e:	58                   	pop    %rax
    132f:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    1334:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    133a:	3c 05                	cmp    $0x5,%al
    133c:	1a 03                	sbb    (%rbx),%al
    133e:	9e                   	sahf
    133f:	7f 4a                	jg     138b <balancer_ingress+0x138b>
    1341:	05 03 03 e2 00       	add    $0xe20303,%eax
    1346:	3c 06                	cmp    $0x6,%al
  data = (void*)(long)xdp->data;
    1348:	03 96 7f 2e 04 00    	add    0x42e7f(%rsi),%edx
  data_end = (void*)(long)xdp->data_end;
    134e:	05 30 06 03 8f       	add    $0x8f030630,%eax
  ip6h = data + sizeof(struct ethhdr);
    1353:	01 58 06             	add    %ebx,0x6(%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1356:	03 f1                	add    %ecx,%esi
    1358:	7e 08                	jle    1362 <balancer_ingress+0x1362>
    135a:	12 05 22 06 03 90    	adc    -0x6ffcf9de(%rip),%al        # ffffffff90031982 <server_id_map+0x5ffffe16e06982>
    1360:	01 58 05             	add    %ebx,0x5(%rax)
    1363:	15 06 3c 05 2b       	adc    $0x2b053c06,%eax
    1368:	74 05                	je     136f <balancer_ingress+0x136f>
    136a:	10 06                	adc    %al,(%rsi)
    136c:	30 05 09 67 05 10    	xor    %al,0x10056709(%rip)        # 10057a7b <_license+0x100559e1>
    1372:	2d 06 03 ee 7e       	sub    $0x7eee0306,%eax
    1377:	2e 05 0b 06 03 96    	cs add $0x9603060b,%eax
    137d:	01 9e 05 09 9f 05    	add    %ebx,0x59f0905(%rsi)
  memcpy(new_eth->h_dest, cval->mac, 6);
    1383:	14 35                	adc    $0x35,%al
    1385:	05 0b 4b 05 07       	add    $0x7054b0b,%eax
    138a:	67 03 a5 7f 2e 05 08 	add    0x8052e7f(%ebp),%esp
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1391:	08 91 05 07 06 3c    	or     %dl,0x3c060705(%rcx)
    1397:	06                   	(bad)
    1398:	03 0a                	add    (%rdx),%ecx
    139a:	4a 05 08 08 91 05    	rex.WX add $0x5910808,%rax
  new_eth->h_proto = BE_ETH_P_IPV6;
    13a0:	07                   	(bad)
    13a1:	06                   	(bad)
    13a2:	3c 05                	cmp    $0x5,%al
    13a4:	00 03                	add    %al,(%rbx)
    13a6:	af                   	scas   %es:(%rdi),%eax
    13a7:	7f 2e                	jg     13d7 <balancer_ingress+0x13d7>
    13a9:	05 01 06 03 cd       	add    $0xcd030601,%eax
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    13ae:	08 c8                	or     %cl,%al
    13b0:	05 07 03 d9 78       	add    $0x78d90307,%eax
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    13b5:	08 3c 05 0f 06 66 03 	or     %bh,0x366060f(,%rax,1)
  ip6h->priority = (tc & 0xF0) >> 4;
    13bc:	da 7e 2e             	fidivrl 0x2e(%rsi)
    13bf:	05 24 03 a6 01       	add    $0x1a60324,%eax
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    13c4:	58                   	pop    %rax
    13c5:	05 34 74 03 da       	add    $0xda037434,%eax
  ip6h->nexthdr = proto;
    13ca:	7e 90                	jle    135c <balancer_ingress+0x135c>
    13cc:	04 0d                	add    $0xd,%al
    13ce:	05 07 06 03 3a       	add    $0x3a030607,%eax
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    13d3:	d6                   	(bad)
    13d4:	06                   	(bad)
    13d5:	ba 05 1c 06 31       	mov    $0x31061c05,%edx
    13da:	05 20 4b 05 0f       	add    $0xf054b20,%eax
    13df:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    13e5:	06                   	(bad)
    13e6:	3c 03                	cmp    $0x3,%al
    13e8:	be 7f 2e 03 c2       	mov    $0xc2032e7f,%esi
    13ed:	00 90 03 be 7f 58    	add    %dl,0x587fbe03(%rax)
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    13f3:	05 03 06 03 c5       	add    $0xc5030603,%eax
    13f8:	00 9e 08 2f 05 14    	add    %bl,0x14052f08(%rsi)
    13fe:	d7                   	xlat   %ds:(%rbx)
    13ff:	05 00 06 03 b9       	add    $0xb9030600,%eax
    1404:	7f 66                	jg     146c <balancer_ingress+0x146c>
    1406:	04 0e                	add    $0xe,%al
    1408:	05 12 06 03 25       	add    $0x25030612,%eax
    140d:	58                   	pop    %rax
    140e:	04 0d                	add    $0xd,%al
    1410:	05 1d 03 27 4a       	add    $0x4a27031d,%eax
    1415:	51                   	push   %rcx
    1416:	04 0e                	add    $0xe,%al
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1418:	05 03 4b 05 20       	add    $0x20054b03,%eax
    141d:	68 05 12 06 58       	push   $0x58061205
    1422:	05 23 06 67 05       	add    $0x5670623,%eax
    1427:	15 06 3c 05 11       	adc    $0x11053c06,%eax
    142c:	06                   	(bad)
    142d:	40 05 17 67 05 15    	rex add $0x15056717,%eax
    1433:	06                   	(bad)
    1434:	58                   	pop    %rax
    1435:	05 03 06 5a 08       	add    $0x85a0603,%eax
      if (qpr.server_id > 0) {
    143a:	21 04 00             	and    %eax,(%rax,%rax,1)
    143d:	05 00 06 03 a1       	add    $0xa1030600,%eax
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1442:	7f 74                	jg     14b8 <balancer_ingress+0x14b8>
    1444:	05 1a 06 03 a7       	add    $0xa703061a,%eax
    1449:	01 c8                	add    %ecx,%eax
    144b:	05 09 06 58 05       	add    $0x5580609,%eax
    1450:	19 06                	sbb    %eax,(%rsi)
    1452:	2f                   	(bad)
    1453:	05 15 5a 06 03       	add    $0x3065a15,%eax
    1458:	d6                   	(bad)
    1459:	7e 4a                	jle    14a5 <balancer_ingress+0x14a5>
    145b:	04 06                	add    $0x6,%al
    145d:	05 01 06 03 9d       	add    $0x9d030601,%eax
    1462:	03 58 04             	add    0x4(%rax),%ebx
    if (pckt->flow.proto == IPPROTO_UDP) {
    1465:	00 05 0b 03 e7 04    	add    %al,0x4e7030b(%rip)        # 4e71776 <_license+0x4e6f6dc>
      new_dst_lru.atime = cur_time;
    146b:	08 20                	or     %ah,(%rax)
    146d:	06                   	(bad)
    146e:	03 fc                	add    %esp,%edi
    new_dst_lru.pos = key;
    1470:	77 4a                	ja     14bc <balancer_ingress+0x14bc>
    1472:	05 1a 06 03 d0       	add    $0xd003061a,%eax
    1477:	04 9e                	add    $0x9e,%al
BPF_MAP_OPS_INLINE(map_update_elem,,
    1479:	05 36 06 82 05       	add    $0x5820636,%eax
    147e:	47                   	rex.RXB
    147f:	4a 05 1a 06 2f 05    	rex.WX add $0x52f061a,%rax
    1485:	36 06                	ss (bad)
    1487:	66 05 47 4a          	add    $0x4a47,%ax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    148b:	05 1a 06 2f 05       	add    $0x52f061a,%eax
    1490:	36 06                	ss (bad)
    1492:	66 05 47 4a          	add    $0x4a47,%ax
    1496:	05 00 03 ae 7b       	add    $0x7bae0300,%eax
    149b:	2e 05 28 06 03 d5    	cs add $0xd5030628,%eax
  bool port_match = lru_miss_stat_vip->port == vip->port;
    14a1:	04 c8                	add    $0xc8,%al
    14a3:	05 35 06 74 05       	add    $0x5740635,%eax
    14a8:	36 06                	ss (bad)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    14aa:	59                   	pop    %rcx
    14ab:	05 2f 06 4a 05       	add    $0x54a062f,%eax
    14b0:	22 06                	and    (%rsi),%al
    14b2:	67 05 1c cb 06 58    	addr32 add $0x5806cb1c,%eax
  bool vip_match = address_match && port_match && proto_match;
    14b8:	66 03 a6 7b 2e 03 da 	add    -0x25fcd185(%rsi),%sp
    14bf:	04 9e                	add    $0x9e,%al
    14c1:	05 0a 06 08 13       	add    $0x1308060a,%eax
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    14c6:	05 09 06 3c 05       	add    $0x53c0609,%eax
    14cb:	14 06                	adc    $0x6,%al
    14cd:	69 06 03 a2 7b 3c    	imul   $0x3c7ba203,(%rsi),%eax
    14d3:	05 16 06 03 89       	add    $0x89030616,%eax
    14d8:	08 08                	or     %cl,(%rax)
    14da:	e4 04                	in     $0x4,%al
    14dc:	09 05 0a 03 90 7b    	or     %eax,0x7b90030a(%rip)        # 7b9017ec <_license+0x7b8ff752>
    14e2:	9e                   	sahf
    14e3:	05 14 06 4a 05       	add    $0x54a0614,%eax
    14e8:	1e                   	(bad)
    14e9:	4a 05 28 4a 05 1b    	rex.WX add $0x1b054a28,%rax
    if (!lru_miss_stat) {
    14ef:	4a 05 32 3c 05 3c    	rex.WX add $0x3c053c32,%rax
    *lru_miss_stat += 1;
    14f5:	4a 05 2f 4a 05 45    	rex.WX add $0x45054a2f,%rax
    14fb:	3c 03                	cmp    $0x3,%al
    14fd:	e7 7c                	out    %eax,$0x7c
    14ff:	3c 05                	cmp    $0x5,%al
    1501:	19 06                	sbb    %eax,(%rsi)
    1503:	03 95 03 4a 05 23    	add    0x23054a03(%rbp),%edx
    1509:	06                   	(bad)
    150a:	4a 05 2d 4a 05 37    	rex.WX add $0x37054a2d,%rax
    1510:	4a 05 2a 4a 05 40    	rex.WX add $0x40054a2a,%rax
    1516:	3c 03                	cmp    $0x3,%al
      data_stats->v2 += 1;
    1518:	eb 7c                	jmp    1596 <balancer_ingress+0x1596>
    151a:	3c 04                	cmp    $0x4,%al
    151c:	00 05 19 06 03 f5    	add    %al,-0xafcf9e7(%rip)        # fffffffff5031b3b <server_id_map+0x5ffffe7be06b3b>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1522:	06                   	(bad)
    1523:	82                   	(bad)
    1524:	05 0b 06 2e 05       	add    $0x52e060b,%eax
    1529:	07                   	(bad)
    152a:	06                   	(bad)
    152b:	03 c3                	add    %ebx,%eax
    152d:	7d 66                	jge    1595 <balancer_ingress+0x1595>
    152f:	06                   	(bad)
    1530:	03 c8                	add    %eax,%ecx
  if (!connId) {
    1532:	7b e4                	jnp    1518 <balancer_ingress+0x1518>
    1534:	06                   	(bad)
    1535:	03 2a                	add    (%rdx),%ebp
    1537:	74 05                	je     153e <balancer_ingress+0x153e>
    1539:	08 08                	or     %cl,(%rax)
    153b:	91                   	xchg   %eax,%ecx
    153c:	05 07 06 3c 03       	add    $0x33c0607,%eax
    1541:	55                   	push   %rbp
    1542:	66 05 0f 06          	add    $0x60f,%ax
    1546:	03 2e                	add    (%rsi),%ebp
    1548:	74 05                	je     154f <balancer_ingress+0x154f>
    154a:	12 32                	adc    (%rdx),%dh
    154c:	05 29 06 74 05       	add    $0x5740629,%eax
    1551:	07                   	(bad)
    1552:	74 05                	je     1559 <balancer_ingress+0x1559>
    1554:	19 06                	sbb    %eax,(%rsi)
    1556:	68 75 06 03 4b       	push   $0x4b030675
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    155b:	90                   	nop
    155c:	05 1b 06 03 fa       	add    $0xfa03061b,%eax
    1561:	06                   	(bad)
    1562:	08 82 05 0d 59 06    	or     %al,0x6590d05(%rdx)
    1568:	03 85 79 2e 05 11    	add    0x11052e79(%rbp),%eax
          key = *real_pos;
    156e:	06                   	(bad)
    156f:	03 fd                	add    %ebp,%edi
    1571:	06                   	(bad)
    1572:	9e                   	sahf
    1573:	05 0f 9f 05 1d       	add    $0x1d059f0f,%eax
            pckt.real_index = key;
    1578:	35 05 13 75 06       	xor    $0x6751305,%eax
            dst = bpf_map_lookup_elem(&reals, &key);
    157d:	66 03 fa             	add    %dx,%di
    1580:	78 4a                	js     15cc <balancer_ingress+0x15cc>
    1582:	03 86 07 9e 05 12    	add    0x12059e07(%rsi),%eax
    1588:	06                   	(bad)
    1589:	bb 05 11 06 3c       	mov    $0x3c061105,%ebx
    158e:	03 f9                	add    %ecx,%edi
    1590:	78 2e                	js     15c0 <balancer_ingress+0x15c0>
    1592:	04 06                	add    $0x6,%al
    1594:	05 01 06 03 98       	add    $0x98030601,%eax
    1599:	03 58 04             	add    0x4(%rax),%ebx
            if (!dst) {
    159c:	00 05 07 03 d3 01    	add    %al,0x1d30307(%rip)        # 1d318a9 <_license+0x1d2f80f>
    15a2:	ac                   	lods   %ds:(%rsi),%al
    15a3:	06                   	(bad)
    15a4:	3c 05                	cmp    $0x5,%al
    15a6:	1f                   	(bad)
    15a7:	06                   	(bad)
    15a8:	67 05 16 06 4a 05    	addr32 add $0x54a0616,%eax
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    15ae:	09 2e                	or     %ebp,(%rsi)
    15b0:	05 23 06 03 a4       	add    $0xa4030623,%eax
  if (dst_lru) {
    15b5:	02 66 05             	add    0x5(%rsi),%ah
    15b8:	00 06                	add    %al,(%rsi)
    15ba:	03 f0                	add    %eax,%esi
    15bc:	78 ba                	js     1578 <balancer_ingress+0x1578>
    if (dst_lru->pos == pckt->real_index) {
    15be:	05 14 06 03 ef       	add    $0xef030614,%eax
    15c3:	04 08                	add    $0x8,%al
    15c5:	90                   	nop
    15c6:	05 37 03 a3 02       	add    $0x2a30337,%eax
              quic_packets_stats->dst_match_in_lru += 1;
    15cb:	2e 05 07 03 ee 7d    	cs add $0x7dee0307,%eax
    15d1:	58                   	pop    %rax
    15d2:	06                   	(bad)
    15d3:	82                   	(bad)
    15d4:	03 80 7b 2e 03 80    	add    -0x7ffcd185(%rax),%eax
    15da:	05 e4 05 08 06       	add    $0x60805e4,%eax
    15df:	08 13                	or     %dl,(%rbx)
    15e1:	05 07 06 3c 05       	add    $0x53c0607,%eax
    15e6:	14 06                	adc    $0x6,%al
    15e8:	35 06 03 f8 7a       	xor    $0x7af80306,%eax
  original_sport = pckt.flow.port16[0];
    15ed:	4a 05 19 06 03 37    	rex.WX add $0x37030619,%rax
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    15f3:	2e 05 1d 9f 05 09    	cs add $0x9059f1d,%eax
        !(vip_info->flags & F_LRU_BYPASS)) {
    15f9:	06                   	(bad)
    15fa:	66 05 17 06          	add    $0x617,%ax
    15fe:	03 bf 04 2e 05 1b    	add    0x1b052e04(%rdi),%edi
    1604:	08 21                	or     %ah,(%rcx)
    1606:	05 13 06 4a 03       	add    $0x34a0613,%eax
    160b:	88 7b 4a             	mov    %bh,0x4a(%rbx)
  if (!dst_lru) {
    160e:	04 06                	add    $0x6,%al
    1610:	05 01 06 03 9d       	add    $0x9d030601,%eax
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1615:	03 58 04             	add    0x4(%rax),%ebx
    1618:	00 05 23 03 fa 03    	add    %al,0x3fa0323(%rip)        # 3fa1941 <_license+0x3f9f8a7>
    161e:	08 20                	or     %ah,(%rax)
    1620:	05 00 06 03 e9       	add    $0xe9030600,%eax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1625:	78 74                	js     169b <balancer_ingress+0x169b>
    1627:	05 2c 06 03 99       	add    $0x9903062c,%eax
    162c:	07                   	(bad)
    162d:	4a 05 14 03 1b 58    	rex.WX add $0x581b0314,%rax
    1633:	06                   	(bad)
    1634:	03 cc                	add    %esp,%ecx
    1636:	78 66                	js     169e <balancer_ingress+0x169e>
    1638:	05 07 06 03 2a       	add    $0x2a030607,%eax
    163d:	58                   	pop    %rax
    163e:	05 08 08 91 05       	add    $0x5910808,%eax
    dst_lru->atime = cur_time;
    1643:	07                   	(bad)
    1644:	06                   	(bad)
    1645:	3c 03                	cmp    $0x3,%al
  key = dst_lru->pos;
    1647:	55                   	push   %rbp
    1648:	66 05 0f 06          	add    $0x60f,%ax
    164c:	03 2e                	add    (%rsi),%ebp
    164e:	74 05                	je     1655 <balancer_ingress+0x1655>
    1650:	12 32                	adc    (%rdx),%dh
  pckt->real_index = key;
    1652:	05 29 06 74 05       	add    $0x5740629,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
    1657:	07                   	(bad)
    1658:	74 05                	je     165f <balancer_ingress+0x165f>
    165a:	19 06                	sbb    %eax,(%rsi)
    165c:	30 75 05             	xor    %dh,0x5(%rbp)
    165f:	14 03                	adc    $0x3,%al
    1661:	ba 04 66 05 37       	mov    $0x37056604,%edx
    1666:	03 a3 02 2e 05 07    	add    0x7052e02(%rbx),%esp
    166c:	03 ee                	add    %esi,%ebp
    166e:	7d 58                	jge    16c8 <balancer_ingress+0x16c8>
    1670:	06                   	(bad)
    1671:	82                   	(bad)
    1672:	03 80 7b 2e 03 80    	add    -0x7ffcd185(%rax),%eax
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1678:	05 e4 05 08 06       	add    $0x60805e4,%eax
    167d:	08 13                	or     %dl,(%rbx)
    167f:	05 07 06 3c 05       	add    $0x53c0607,%eax
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1684:	14 06                	adc    $0x6,%al
    1686:	35 06 03 f8 7a       	xor    $0x7af80306,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    168b:	4a 05 19 06 03 37    	rex.WX add $0x37030619,%rax
    1691:	2e 05 1d 9f 05 09    	cs add $0x9059f1d,%eax
    1697:	06                   	(bad)
    1698:	66 05 17 06          	add    $0x617,%ax
    169c:	03 bf 04 2e 05 1b    	add    0x1b052e04(%rdi),%edi
    16a2:	08 21                	or     %ah,(%rcx)
  if (!conn_rate_stats) {
    16a4:	05 13 06 4a 03       	add    $0x34a0613,%eax
    16a9:	88 7b 4a             	mov    %bh,0x4a(%rbx)
    16ac:	04 06                	add    $0x6,%al
    16ae:	05 01 06 03 9d       	add    $0x9d030601,%eax
    16b3:	03 58 04             	add    0x4(%rax),%ebx
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    16b6:	00 05 23 03 fa 03    	add    %al,0x3fa0323(%rip)        # 3fa19df <_license+0x3f9f945>
    16bc:	08 20                	or     %ah,(%rax)
    16be:	05 00 06 03 e9       	add    $0xe9030600,%eax
    16c3:	78 74                	js     1739 <balancer_ingress+0x1739>
    16c5:	05 2c 06 03 99       	add    $0x9903062c,%eax
    conn_rate_stats->v1 = 1;
    16ca:	07                   	(bad)
    16cb:	4a 05 14 03 1b 58    	rex.WX add $0x581b0314,%rax
    conn_rate_stats->v2 = *cur_time;
    16d1:	06                   	(bad)
    16d2:	03 cc                	add    %esp,%ecx
    conn_rate_stats->v1 += 1;
    16d4:	78 66                	js     173c <balancer_ingress+0x173c>
    16d6:	02                   	.byte 0x2
    16d7:	05                   	.byte 0x5
    16d8:	00 01                	add    %al,(%rcx)
    16da:	01                   	.byte 0x1

Disassembly of section .debug_line_str:

0000000000000000 <.debug_line_str>:
  void* data = (void*)(long)ctx->data;
   0:	2f                   	(bad)
   1:	72 6f                	jb     72 <balancer_ingress+0x72>
   3:	6f                   	outsl  %ds:(%rsi),(%dx)
   4:	74 2f                	je     35 <balancer_ingress+0x35>
   6:	57                   	push   %rdi
   7:	6f                   	outsl  %ds:(%rsi),(%dx)
   8:	72 6b                	jb     75 <balancer_ingress+0x75>
   a:	73 70                	jae    7c <balancer_ingress+0x7c>
   c:	61                   	(bad)
   d:	63 65 2f             	movsxd 0x2f(%rbp),%esp
  10:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  14:	61                   	(bad)
  15:	6e                   	outsb  %ds:(%rsi),(%dx)
  16:	2f                   	(bad)
  17:	5f                   	pop    %rdi
  void* data_end = (void*)(long)ctx->data_end;
  18:	62 75                	(bad)
  1a:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
  21:	73 
  if (data + nh_off > data_end) {
  22:	2f                   	(bad)
  23:	62                   	(bad)
  24:	70 66                	jo     8c <balancer_ingress+0x8c>
  26:	70 72                	jo     9a <balancer_ingress+0x9a>
  28:	6f                   	outsl  %ds:(%rsi),(%dx)
  29:	67 00 2e             	add    %ch,(%esi)
  2c:	2f                   	(bad)
  2d:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  eth_proto = eth->h_proto;
  31:	61                   	(bad)
  32:	6e                   	outsb  %ds:(%rsi),(%dx)
  33:	2f                   	(bad)
  34:	6c                   	insb   (%dx),%es:(%rdi)
  if (eth_proto == BE_ETH_P_IP) {
  35:	69 62 2f 62 70 66 00 	imul   $0x667062,0x2f(%rdx),%esp
  3c:	2f                   	(bad)
  3d:	75 73                	jne    b2 <balancer_ingress+0xb2>
  3f:	72 2f                	jb     70 <balancer_ingress+0x70>
  41:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  48:	2f                   	(bad)
  49:	61                   	(bad)
  4a:	73 6d                	jae    b9 <balancer_ingress+0xb9>
  struct packet_description pckt = {};
  4c:	2d 67 65 6e 65       	sub    $0x656e6567,%eax
  51:	72 69                	jb     bc <balancer_ingress+0xbc>
  53:	63 00                	movsxd (%rax),%eax
  55:	2f                   	(bad)
  56:	75 73                	jne    cb <balancer_ingress+0xcb>
  58:	72 2f                	jb     89 <balancer_ingress+0x89>
  5a:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  61:	2f                   	(bad)
  62:	6c                   	insb   (%dx),%es:(%rdi)
  63:	69 6e 75 78 00 2e 2f 	imul   $0x2f2e0078,0x75(%rsi),%ebp
  6a:	2e 68 65 61 64 65    	cs push $0x65646165
  70:	72 5f                	jb     d1 <balancer_ingress+0xd1>
  72:	6f                   	outsl  %ds:(%rsi),(%dx)
  73:	76 65                	jbe    da <balancer_ingress+0xda>
  75:	72 72                	jb     e9 <balancer_ingress+0xe9>
  77:	69 64 65 2f 36 2f 6b 	imul   $0x616b2f36,0x2f(%rbp,%riz,2),%esp
  7e:	61 
  7f:	74 72                	je     f3 <balancer_ingress+0xf3>
  81:	61                   	(bad)
  82:	6e                   	outsb  %ds:(%rsi),(%dx)
  83:	2f                   	(bad)
  84:	6c                   	insb   (%dx),%es:(%rdi)
  85:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
  bpf_tail_call(xdp, &subprograms, 0);
  8c:	78 5f                	js     ed <balancer_ingress+0xed>
  8e:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  95:	73 00                	jae    97 <balancer_ingress+0x97>
  97:	2e 2f                	cs (bad)
  99:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  9d:	61                   	(bad)
  9e:	6e                   	outsb  %ds:(%rsi),(%dx)
  9f:	2f                   	(bad)
  a0:	6c                   	insb   (%dx),%es:(%rdi)
  a1:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
  struct packet_description pckt = {};
  a8:	78 5f                	js     109 <balancer_ingress+0x109>
  aa:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  b1:	73 00                	jae    b3 <balancer_ingress+0xb3>
  b3:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  b7:	61                   	(bad)
  b8:	6e                   	outsb  %ds:(%rsi),(%dx)
  b9:	2f                   	(bad)
  ba:	6c                   	insb   (%dx),%es:(%rdi)
  bb:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
  c2:	62 61 6c 61 6e       	(bad)
  c7:	63 65 72             	movsxd 0x72(%rbp),%esp
  ca:	2e 62                	cs (bad)
  cc:	70 66                	jo     134 <balancer_ingress+0x134>
  ce:	2e 63 00             	cs movsxd (%rax),%eax
  d1:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
  d4:	74 72                	je     148 <balancer_ingress+0x148>
  d6:	6f                   	outsl  %ds:(%rsi),(%dx)
  d7:	6c                   	insb   (%dx),%es:(%rdi)
  d8:	5f                   	pop    %rdi
  d9:	64 61                	fs (bad)
  db:	74 61                	je     13e <balancer_ingress+0x13e>
  dd:	5f                   	pop    %rdi
  de:	6d                   	insl   (%dx),%es:(%rdi)
  df:	61                   	(bad)
  e0:	70 73                	jo     155 <balancer_ingress+0x155>
  e2:	2e 68 00 69 6e 74    	cs push $0x746e6900
  bpf_tail_call(xdp, &subprograms, 0);
  e8:	2d 6c 6c 36 34       	sub    $0x34366c6c,%eax
  ed:	2e 68 00 62 61 6c    	cs push $0x6c616200
  f3:	61                   	(bad)
  f4:	6e                   	outsb  %ds:(%rsi),(%dx)
  f5:	63 65 72             	movsxd 0x72(%rbp),%esp
  f8:	5f                   	pop    %rdi
  f9:	73 74                	jae    16f <balancer_ingress+0x16f>
  fb:	72 75                	jb     172 <balancer_ingress+0x172>
  fd:	63 74 73 2e          	movsxd 0x2e(%rbx,%rsi,2),%esi
 101:	68 00 74 79 70       	push   $0x70797400
  struct vip_definition vip = {};
 106:	65 73 2e             	gs jae 137 <balancer_ingress+0x137>
 109:	68 00 62 61 6c       	push   $0x6c616200
 10e:	61                   	(bad)
 10f:	6e                   	outsb  %ds:(%rsi),(%dx)
 110:	63 65 72             	movsxd 0x72(%rbp),%esp
 113:	5f                   	pop    %rdi
 114:	6d                   	insl   (%dx),%es:(%rdi)
 115:	61                   	(bad)
 116:	70 73                	jo     18b <balancer_ingress+0x18b>
 118:	2e 68 00 62 70 66    	cs push $0x66706200
    if (iph + 1 > data_end) {
 11e:	5f                   	pop    %rdi
 11f:	68 65 6c 70 65       	push   $0x65706c65
 124:	72 73                	jb     199 <balancer_ingress+0x199>
 126:	2e 68 00 62 70 66    	cs push $0x66706200
    if (iph->ihl != 5) {
 12c:	2e 68 00 69 6e 2e    	cs push $0x2e6e6900
 132:	68 00 70 63 6b       	push   $0x6b637000
    pckt->tos = iph->tos;
 137:	74 5f                	je     198 <balancer_ingress+0x198>
 139:	70 61                	jo     19c <balancer_ingress+0x19c>
 13b:	72 73                	jb     1b0 <balancer_ingress+0x1b0>
    *protocol = iph->protocol;
 13d:	69 6e 67 2e 68 00 6a 	imul   $0x6a00682e,0x67(%rsi),%ebp
    if (iph->frag_off & PCKT_FRAGMENTED) {
 144:	68 61 73 68 2e       	push   $0x2e687361
 149:	68 00 68 61 6e       	push   $0x6e616800
 14e:	64 6c                	fs insb (%dx),%es:(%rdi)
 150:	65 5f                	gs pop %rdi
 152:	69 63 6d 70 2e 68 00 	imul   $0x682e70,0x6d(%rbx),%esp
    if (*protocol == IPPROTO_ICMP) {
 159:	63 73 75             	movsxd 0x75(%rbx),%esi
 15c:	6d                   	insl   (%dx),%es:(%rdi)
 15d:	5f                   	pop    %rdi
 15e:	68 65 6c 70 65       	push   $0x65706c65
  if (icmp_hdr + 1 > data_end) {
 163:	72 73                	jb     1d8 <balancer_ingress+0x1d8>
 165:	2e 68 00 70 63 6b    	cs push $0x6b637000
 16b:	74 5f                	je     1cc <balancer_ingress+0x1cc>
  if (icmp_hdr->type == ICMP_ECHO) {
 16d:	65 6e                	outsb  %gs:(%rsi),(%dx)
 16f:	63 61 70             	movsxd 0x70(%rcx),%esp
 172:	2e 68 00 65 6e 63    	cs push $0x636e6500
 178:	61                   	(bad)
 179:	70 5f                	jo     1da <balancer_ingress+0x1da>
 17b:	68 65 6c 70 65       	push   $0x65706c65
 180:	72 73                	jb     1f5 <balancer_ingress+0x1f5>
 182:	2e 68 00 69 70 2e    	cs push $0x2e706900
 188:	68 00 69 70 76       	push   $0x76706900
  icmp_hdr->type = ICMP_ECHOREPLY;
 18d:	36 2e 68 00 69 6e 36 	ss cs push $0x366e6900
  iph->ttl = DEFAULT_TTL;
 194:	2e 68 00 69 63 6d    	cs push $0x6d636900
  iph->daddr = iph->saddr;
 19a:	70 76                	jo     212 <balancer_ingress+0x212>
  tmp_addr = iph->daddr;
 19c:	36 2e 68 00 74 63 70 	ss cs push $0x70637400
  iph->saddr = tmp_addr;
 1a3:	2e 68 00 75 64 70    	cs push $0x70647500
 1a9:	2e 68 00 69 66 5f    	cs push $0x5f666900
 1af:	65 74 68             	gs je  21a <balancer_ingress+0x21a>
 1b2:	65 72 2e             	gs jb  1e3 <balancer_ingress+0x1e3>
 1b5:	68                   	.byte 0x68
	...
