
bpf/native/balancer.bpf:     file format elf64-x86-64


Disassembly of section xdp:

0000000000000000 <balancer_ingress>:

  return XDP_TX;
}

SEC(PROG_SEC_NAME)
int balancer_ingress(struct xdp_md* ctx) {
       0:	f3 0f 1e fa          	endbr64
       4:	0f 1f 44 00 08       	nopl   0x8(%rax,%rax,1)
       9:	55                   	push   %rbp
       a:	41 57                	push   %r15
       c:	41 56                	push   %r14
       e:	41 55                	push   %r13
      10:	41 54                	push   %r12
      12:	53                   	push   %rbx
      13:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  void* data = (void*)(long)ctx->data;
      1a:	48 8b 1f             	mov    (%rdi),%rbx
  void* data_end = (void*)(long)ctx->data_end;
      1d:	4c 8b 67 08          	mov    0x8(%rdi),%r12
  struct ethhdr* eth = data;
  __u32 eth_proto;
  __u32 nh_off;
  nh_off = sizeof(struct ethhdr);

  if (data + nh_off > data_end) {
      21:	48 8d 43 0e          	lea    0xe(%rbx),%rax
      25:	bd 01 00 00 00       	mov    $0x1,%ebp
      2a:	4c 39 e0             	cmp    %r12,%rax
      2d:	0f 87 19 1f 00 00    	ja     1f4c <balancer_ingress+0x1f4c>
      33:	49 89 fd             	mov    %rdi,%r13
    // bogus packet, len less than minimum ethernet frame size
    return XDP_DROP;
  }

  eth_proto = eth->h_proto;
      36:	0f b7 4b 0c          	movzwl 0xc(%rbx),%ecx

  if (eth_proto == BE_ETH_P_IP) {
      3a:	81 f9 86 dd 00 00    	cmp    $0xdd86,%ecx
      40:	0f 84 1e 01 00 00    	je     164 <balancer_ingress+0x164>
      46:	bd 02 00 00 00       	mov    $0x2,%ebp
      4b:	66 83 f9 08          	cmp    $0x8,%cx
      4f:	0f 85 f7 1e 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
  struct packet_description pckt = {};
      55:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
      5c:	00 00 
      5e:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
      65:	00 00 
      67:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
      6e:	00 00 
      70:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
      77:	00 00 
      79:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
      80:	00 00 
      82:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
      89:	00 00 
  struct vip_definition vip = {};
      8b:	c7 44 24 70 00 00 00 	movl   $0x0,0x70(%rsp)
      92:	00 
      93:	48 c7 44 24 68 00 00 	movq   $0x0,0x68(%rsp)
      9a:	00 00 
      9c:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
      a3:	00 00 
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
    }
  } else {
    iph = data + nh_off;
    if (iph + 1 > data_end) {
      a5:	4c 8d 73 22          	lea    0x22(%rbx),%r14
      a9:	4d 39 e6             	cmp    %r12,%r14
      ac:	0f 87 95 1e 00 00    	ja     1f47 <balancer_ingress+0x1f47>
      return XDP_DROP;
    }
    // ihl contains len of ipv4 header in 32bit words
    if (iph->ihl != 5) {
      b2:	8a 00                	mov    (%rax),%al
      b4:	24 0f                	and    $0xf,%al
      b6:	3c 05                	cmp    $0x5,%al
      b8:	0f 85 89 1e 00 00    	jne    1f47 <balancer_ingress+0x1f47>
      // if len of ipv4 hdr is not equal to 20bytes that means that header
      // contains ip options, and we dont support em
      return XDP_DROP;
    }
    pckt->tos = iph->tos;
      be:	8a 43 0f             	mov    0xf(%rbx),%al
      c1:	88 44 24 3d          	mov    %al,0x3d(%rsp)
    *protocol = iph->protocol;
      c5:	8a 43 17             	mov    0x17(%rbx),%al
    pckt->flow.proto = *protocol;
      c8:	88 44 24 34          	mov    %al,0x34(%rsp)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;

    if (iph->frag_off & PCKT_FRAGMENTED) {
      cc:	0f b7 4b 14          	movzwl 0x14(%rbx),%ecx
      d0:	f7 c1 3f ff 00 00    	test   $0xff3f,%ecx
      d6:	0f 85 6b 1e 00 00    	jne    1f47 <balancer_ingress+0x1f47>
      dc:	0f b7 7b 10          	movzwl 0x10(%rbx),%edi
      // we drop fragmented packets.
      return XDP_DROP;
    }
    if (*protocol == IPPROTO_ICMP) {
      e0:	3c 01                	cmp    $0x1,%al
      e2:	0f 85 43 03 00 00    	jne    42b <balancer_ingress+0x42b>
    __u64 off,
    struct packet_description* pckt) {
  struct icmphdr* icmp_hdr;
  struct iphdr* iph;
  icmp_hdr = data + off;
  if (icmp_hdr + 1 > data_end) {
      e8:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
      ec:	4c 39 e0             	cmp    %r12,%rax
      ef:	0f 87 52 1e 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    return XDP_DROP;
  }
  if (icmp_hdr->type == ICMP_ECHO) {
      f5:	41 8a 16             	mov    (%r14),%dl
      f8:	80 fa 03             	cmp    $0x3,%dl
      fb:	0f 84 50 08 00 00    	je     951 <balancer_ingress+0x951>
     101:	bd 02 00 00 00       	mov    $0x2,%ebp
     106:	80 fa 08             	cmp    $0x8,%dl
     109:	0f 85 3d 1e 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
     10f:	44 0f b7 c7          	movzwl %di,%r8d
  icmp_hdr->type = ICMP_ECHOREPLY;
     113:	c6 43 22 00          	movb   $0x0,0x22(%rbx)
  icmp_hdr->checksum += 0x0008;
     117:	66 83 43 24 08       	addw   $0x8,0x24(%rbx)
  iph->ttl = DEFAULT_TTL;
     11c:	c6 43 16 40          	movb   $0x40,0x16(%rbx)
  iph->daddr = iph->saddr;
     120:	8b 43 1a             	mov    0x1a(%rbx),%eax
  tmp_addr = iph->daddr;
     123:	8b 73 1e             	mov    0x1e(%rbx),%esi
  iph->daddr = iph->saddr;
     126:	89 43 1e             	mov    %eax,0x1e(%rbx)
  iph->saddr = tmp_addr;
     129:	89 73 1a             	mov    %esi,0x1a(%rbx)
    void* iph,
    __u64* csum) {
  __u16* next_iph_u16 = (__u16*)iph;
#pragma clang loop unroll(full)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    *csum += *next_iph_u16++;
     12c:	0f b7 7b 0e          	movzwl 0xe(%rbx),%edi
     130:	0f b7 6b 12          	movzwl 0x12(%rbx),%ebp
     134:	44 0f b7 4b 16       	movzwl 0x16(%rbx),%r9d
     139:	0f b7 d6             	movzwl %si,%edx
     13c:	48 c1 ee 10          	shr    $0x10,%rsi
     140:	48 01 d6             	add    %rdx,%rsi
     143:	0f b7 d0             	movzwl %ax,%edx
     146:	48 01 f2             	add    %rsi,%rdx
     149:	48 c1 e8 10          	shr    $0x10,%rax
     14d:	48 01 d0             	add    %rdx,%rax
     150:	48 01 f8             	add    %rdi,%rax
     153:	4c 01 c0             	add    %r8,%rax
     156:	48 01 e8             	add    %rbp,%rax
     159:	48 01 c8             	add    %rcx,%rax
     15c:	4c 01 c8             	add    %r9,%rax
     15f:	e9 e3 01 00 00       	jmp    347 <balancer_ingress+0x347>
  struct packet_description pckt = {};
     164:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
     16b:	00 00 
     16d:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
     174:	00 00 
     176:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
     17d:	00 00 
     17f:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
     186:	00 00 
     188:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
     18f:	00 00 
     191:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
     198:	00 00 
  struct vip_definition vip = {};
     19a:	c7 44 24 70 00 00 00 	movl   $0x0,0x70(%rsp)
     1a1:	00 
     1a2:	48 c7 44 24 68 00 00 	movq   $0x0,0x68(%rsp)
     1a9:	00 00 
     1ab:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
     1b2:	00 00 
    if (ip6h + 1 > data_end) {
     1b4:	4c 8d 7b 36          	lea    0x36(%rbx),%r15
     1b8:	4d 39 e7             	cmp    %r12,%r15
     1bb:	0f 87 86 1d 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    *protocol = ip6h->nexthdr;
     1c1:	8a 43 14             	mov    0x14(%rbx),%al
    pckt->flow.proto = *protocol;
     1c4:	88 44 24 34          	mov    %al,0x34(%rsp)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1c8:	8a 4b 0e             	mov    0xe(%rbx),%cl
     1cb:	c0 e1 04             	shl    $0x4,%cl
     1ce:	88 4c 24 3d          	mov    %cl,0x3d(%rsp)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1d2:	8a 53 0f             	mov    0xf(%rbx),%dl
     1d5:	c0 ea 04             	shr    $0x4,%dl
     1d8:	08 ca                	or     %cl,%dl
     1da:	88 54 24 3d          	mov    %dl,0x3d(%rsp)
    if (*protocol == IPPROTO_FRAGMENT) {
     1de:	3c 2c                	cmp    $0x2c,%al
     1e0:	0f 84 61 1d 00 00    	je     1f47 <balancer_ingress+0x1f47>
     1e6:	0f b7 7b 12          	movzwl 0x12(%rbx),%edi
     1ea:	3c 3a                	cmp    $0x3a,%al
     1ec:	0f 85 9b 00 00 00    	jne    28d <balancer_ingress+0x28d>
  if (icmp_hdr + 1 > data_end) {
     1f2:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     1f6:	4c 39 e0             	cmp    %r12,%rax
     1f9:	0f 87 48 1d 00 00    	ja     1f47 <balancer_ingress+0x1f47>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1ff:	41 8a 07             	mov    (%r15),%al
     202:	3c 02                	cmp    $0x2,%al
     204:	0f 84 c2 02 00 00    	je     4cc <balancer_ingress+0x4cc>
     20a:	3c 01                	cmp    $0x1,%al
     20c:	0f 84 f3 02 00 00    	je     505 <balancer_ingress+0x505>
     212:	bd 02 00 00 00       	mov    $0x2,%ebp
     217:	3c 80                	cmp    $0x80,%al
     219:	0f 85 2d 1d 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
     21f:	c6 43 36 81          	movb   $0x81,0x36(%rbx)
     223:	66 83 43 38 ff       	addw   $0xffff,0x38(%rbx)
     228:	c6 43 15 40          	movb   $0x40,0x15(%rbx)
     22c:	48 8b 43 16          	mov    0x16(%rbx),%rax
     230:	48 8b 4b 1e          	mov    0x1e(%rbx),%rcx
     234:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     239:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
     23e:	48 8b 43 26          	mov    0x26(%rbx),%rax
     242:	48 8b 4b 2e          	mov    0x2e(%rbx),%rcx
     246:	48 89 43 16          	mov    %rax,0x16(%rbx)
     24a:	48 89 4b 1e          	mov    %rcx,0x1e(%rbx)
     24e:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
     253:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
     258:	48 89 43 26          	mov    %rax,0x26(%rbx)
     25c:	48 89 4b 2e          	mov    %rcx,0x2e(%rbx)
     260:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     264:	66 89 44 24 7c       	mov    %ax,0x7c(%rsp)
     269:	8b 43 06             	mov    0x6(%rbx),%eax
     26c:	89 44 24 78          	mov    %eax,0x78(%rsp)
     270:	8b 03                	mov    (%rbx),%eax
     272:	89 43 06             	mov    %eax,0x6(%rbx)
     275:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     279:	66 89 43 0a          	mov    %ax,0xa(%rbx)
     27d:	8b 44 24 78          	mov    0x78(%rsp),%eax
     281:	89 03                	mov    %eax,(%rbx)
     283:	0f b7 44 24 7c       	movzwl 0x7c(%rsp),%eax
     288:	e9 45 01 00 00       	jmp    3d2 <balancer_ingress+0x3d2>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     28d:	48 8b 4b 16          	mov    0x16(%rbx),%rcx
     291:	48 8b 53 1e          	mov    0x1e(%rbx),%rdx
     295:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
     29a:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     29f:	48 8b 4b 26          	mov    0x26(%rbx),%rcx
     2a3:	48 8b 53 2e          	mov    0x2e(%rbx),%rdx
     2a7:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
     2ac:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
    void* data,
    void* data_end,
    __u64 off,
    struct packet_description* pckt,
    __u8 protocol) {
  if (protocol == IPPROTO_ICMPV6) {
     2b1:	3c 01                	cmp    $0x1,%al
     2b3:	0f 85 27 01 00 00    	jne    3e0 <balancer_ingress+0x3e0>
  if (icmp_hdr + 1 > data_end) {
     2b9:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     2bd:	4c 39 e0             	cmp    %r12,%rax
     2c0:	0f 87 81 1c 00 00    	ja     1f47 <balancer_ingress+0x1f47>
  if (icmp_hdr->type == ICMP_ECHO) {
     2c6:	41 8a 0f             	mov    (%r15),%cl
     2c9:	80 f9 03             	cmp    $0x3,%cl
     2cc:	0f 84 19 05 00 00    	je     7eb <balancer_ingress+0x7eb>
     2d2:	bd 02 00 00 00       	mov    $0x2,%ebp
     2d7:	80 f9 08             	cmp    $0x8,%cl
     2da:	0f 85 6c 1c 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2e0:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
     2e4:	bd 01 00 00 00       	mov    $0x1,%ebp
       sizeof(struct icmphdr)) > data_end) {
     2e9:	4c 39 e0             	cmp    %r12,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2ec:	0f 87 5a 1c 00 00    	ja     1f4c <balancer_ingress+0x1f4c>
  icmp_hdr->type = ICMP_ECHOREPLY;
     2f2:	c6 43 22 00          	movb   $0x0,0x22(%rbx)
  icmp_hdr->checksum += 0x0008;
     2f6:	66 83 43 24 08       	addw   $0x8,0x24(%rbx)
  iph->ttl = DEFAULT_TTL;
     2fb:	c6 43 16 40          	movb   $0x40,0x16(%rbx)
  iph->daddr = iph->saddr;
     2ff:	8b 43 1a             	mov    0x1a(%rbx),%eax
  tmp_addr = iph->daddr;
     302:	8b 4b 1e             	mov    0x1e(%rbx),%ecx
  iph->daddr = iph->saddr;
     305:	89 43 1e             	mov    %eax,0x1e(%rbx)
  iph->saddr = tmp_addr;
     308:	89 4b 1a             	mov    %ecx,0x1a(%rbx)
     30b:	44 0f b7 4b 0e       	movzwl 0xe(%rbx),%r9d
     310:	0f b7 73 10          	movzwl 0x10(%rbx),%esi
     314:	0f b7 7b 12          	movzwl 0x12(%rbx),%edi
     318:	0f b7 6b 14          	movzwl 0x14(%rbx),%ebp
     31c:	44 0f b7 43 16       	movzwl 0x16(%rbx),%r8d
     321:	0f b7 d1             	movzwl %cx,%edx
     324:	48 c1 e9 10          	shr    $0x10,%rcx
     328:	48 01 d1             	add    %rdx,%rcx
     32b:	0f b7 d0             	movzwl %ax,%edx
     32e:	48 01 ca             	add    %rcx,%rdx
     331:	48 c1 e8 10          	shr    $0x10,%rax
     335:	48 01 d0             	add    %rdx,%rax
     338:	4c 01 c8             	add    %r9,%rax
     33b:	48 01 f0             	add    %rsi,%rax
     33e:	48 01 f8             	add    %rdi,%rax
     341:	48 01 e8             	add    %rbp,%rax
     344:	4c 01 c0             	add    %r8,%rax
     347:	48 89 c1             	mov    %rax,%rcx
     34a:	48 c1 e9 10          	shr    $0x10,%rcx
     34e:	0f b7 d0             	movzwl %ax,%edx
     351:	48 01 ca             	add    %rcx,%rdx
     354:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
     35a:	48 0f 42 d0          	cmovb  %rax,%rdx
     35e:	48 89 d0             	mov    %rdx,%rax
     361:	48 c1 e8 10          	shr    $0x10,%rax
     365:	0f b7 ca             	movzwl %dx,%ecx
     368:	48 01 c1             	add    %rax,%rcx
     36b:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     372:	48 0f 42 ca          	cmovb  %rdx,%rcx
     376:	48 89 c8             	mov    %rcx,%rax
     379:	48 c1 e8 10          	shr    $0x10,%rax
     37d:	0f b7 d1             	movzwl %cx,%edx
     380:	48 01 c2             	add    %rax,%rdx
     383:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
     38a:	48 0f 42 d1          	cmovb  %rcx,%rdx
     38e:	89 d0                	mov    %edx,%eax
     390:	c1 e8 10             	shr    $0x10,%eax
     393:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     39a:	b9 00 00 01 00       	mov    $0x10000,%ecx
     39f:	0f 43 c8             	cmovae %eax,%ecx
     3a2:	01 d1                	add    %edx,%ecx
     3a4:	f7 d1                	not    %ecx
     3a6:	66 89 4b 18          	mov    %cx,0x18(%rbx)
     3aa:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     3ae:	66 89 44 24 44       	mov    %ax,0x44(%rsp)
     3b3:	8b 43 06             	mov    0x6(%rbx),%eax
     3b6:	89 44 24 40          	mov    %eax,0x40(%rsp)
     3ba:	8b 03                	mov    (%rbx),%eax
     3bc:	89 43 06             	mov    %eax,0x6(%rbx)
     3bf:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     3c3:	66 89 43 0a          	mov    %ax,0xa(%rbx)
     3c7:	8b 44 24 40          	mov    0x40(%rsp),%eax
     3cb:	89 03                	mov    %eax,(%rbx)
     3cd:	0f b7 44 24 44       	movzwl 0x44(%rsp),%eax
     3d2:	66 89 43 04          	mov    %ax,0x4(%rbx)
     3d6:	bd 03 00 00 00       	mov    $0x3,%ebp
     3db:	e9 6c 1b 00 00       	jmp    1f4c <balancer_ingress+0x1f4c>
     3e0:	b2 02                	mov    $0x2,%dl
     3e2:	b1 01                	mov    $0x1,%cl
     3e4:	bd 02 00 00 00       	mov    $0x2,%ebp
  if (protocol == IPPROTO_IPIP) {
     3e9:	3c 10                	cmp    $0x10,%al
     3eb:	0f 8f 62 01 00 00    	jg     553 <balancer_ingress+0x553>
     3f1:	3c 04                	cmp    $0x4,%al
     3f3:	0f 84 8c 02 00 00    	je     685 <balancer_ingress+0x685>
     3f9:	3c 06                	cmp    $0x6,%al
     3fb:	0f 85 4b 1b 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
  tcp = data + off;
     401:	48 8d 43 66          	lea    0x66(%rbx),%rax
  if (is_ipv6) {
     405:	84 c9                	test   %cl,%cl
  tcp = data + off;
     407:	49 0f 45 c7          	cmovne %r15,%rax
  if (tcp + 1 > data_end) {
     40b:	48 8d 70 14          	lea    0x14(%rax),%rsi
     40f:	4c 39 e6             	cmp    %r12,%rsi
     412:	0f 87 2f 1b 00 00    	ja     1f47 <balancer_ingress+0x1f47>
  if (tcp->syn) {
     418:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     41c:	0f 84 aa 03 00 00    	je     7cc <balancer_ingress+0x7cc>
    pckt->flags |= F_SYN_SET;
     422:	88 54 24 3c          	mov    %dl,0x3c(%rsp)
     426:	e9 a1 03 00 00       	jmp    7cc <balancer_ingress+0x7cc>
      return FURTHER_PROCESSING;
    } else {
      pckt->flow.src = iph->saddr;
     42b:	8b 4b 1a             	mov    0x1a(%rbx),%ecx
     42e:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
      pckt->flow.dst = iph->daddr;
     432:	8b 4b 1e             	mov    0x1e(%rbx),%ecx
     435:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
  if (protocol == IPPROTO_ICMPV6) {
     439:	3c 3a                	cmp    $0x3a,%al
     43b:	75 44                	jne    481 <balancer_ingress+0x481>
  if (icmp_hdr + 1 > data_end) {
     43d:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
     441:	4c 39 e0             	cmp    %r12,%rax
     444:	0f 87 fd 1a 00 00    	ja     1f47 <balancer_ingress+0x1f47>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     44a:	41 8a 06             	mov    (%r14),%al
     44d:	3c 02                	cmp    $0x2,%al
     44f:	0f 84 fc 06 00 00    	je     b51 <balancer_ingress+0xb51>
     455:	3c 01                	cmp    $0x1,%al
     457:	0f 84 2d 07 00 00    	je     b8a <balancer_ingress+0xb8a>
     45d:	bd 02 00 00 00       	mov    $0x2,%ebp
     462:	3c 80                	cmp    $0x80,%al
     464:	0f 85 e2 1a 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     46a:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     46e:	bd 01 00 00 00       	mov    $0x1,%ebp
       sizeof(struct icmp6hdr)) > data_end) {
     473:	4c 39 e0             	cmp    %r12,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     476:	0f 87 d0 1a 00 00    	ja     1f4c <balancer_ingress+0x1f4c>
     47c:	e9 9e fd ff ff       	jmp    21f <balancer_ingress+0x21f>
     481:	b2 02                	mov    $0x2,%dl
     483:	b1 01                	mov    $0x1,%cl
     485:	bd 02 00 00 00       	mov    $0x2,%ebp
     48a:	3c 10                	cmp    $0x10,%al
     48c:	0f 8f 48 07 00 00    	jg     bda <balancer_ingress+0xbda>
     492:	3c 04                	cmp    $0x4,%al
     494:	0f 84 5d 05 00 00    	je     9f7 <balancer_ingress+0x9f7>
     49a:	3c 06                	cmp    $0x6,%al
     49c:	0f 85 aa 1a 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
  tcp = data + off;
     4a2:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
  if (is_ipv6) {
     4a6:	84 c9                	test   %cl,%cl
  tcp = data + off;
     4a8:	49 0f 45 c6          	cmovne %r14,%rax
  if (tcp + 1 > data_end) {
     4ac:	48 8d 70 14          	lea    0x14(%rax),%rsi
     4b0:	4c 39 e6             	cmp    %r12,%rsi
     4b3:	0f 87 8e 1a 00 00    	ja     1f47 <balancer_ingress+0x1f47>
  if (tcp->syn) {
     4b9:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     4bd:	0f 84 72 08 00 00    	je     d35 <balancer_ingress+0xd35>
    pckt->flags |= F_SYN_SET;
     4c3:	88 54 24 3c          	mov    %dl,0x3c(%rsp)
     4c7:	e9 69 08 00 00       	jmp    d35 <balancer_ingress+0xd35>
     4cc:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     4d3:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     4d6:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     4dd:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     4e4:	65 bb 
    if (!icmp_ptb_v6_stats) {
     4e6:	48 85 c0             	test   %rax,%rax
     4e9:	0f 84 58 1a 00 00    	je     1f47 <balancer_ingress+0x1f47>
    icmp_ptb_v6_stats->v1 += 1;
     4ef:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4f3:	8b 4b 3a             	mov    0x3a(%rbx),%ecx
     4f6:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     4f8:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     4fe:	77 05                	ja     505 <balancer_ingress+0x505>
      icmp_ptb_v6_stats->v2 += 1;
     500:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     505:	48 8d 43 66          	lea    0x66(%rbx),%rax
     509:	4c 39 e0             	cmp    %r12,%rax
     50c:	0f 87 35 1a 00 00    	ja     1f47 <balancer_ingress+0x1f47>
  pckt->flow.proto = ip6h->nexthdr;
     512:	8a 43 44             	mov    0x44(%rbx),%al
     515:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     519:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     51e:	48 8b 4b 56          	mov    0x56(%rbx),%rcx
     522:	48 8b 53 5e          	mov    0x5e(%rbx),%rdx
     526:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
     52b:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     530:	48 8b 4b 46          	mov    0x46(%rbx),%rcx
     534:	48 8b 53 4e          	mov    0x4e(%rbx),%rdx
     538:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
     53d:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
     542:	b2 03                	mov    $0x3,%dl
     544:	31 c9                	xor    %ecx,%ecx
     546:	bd 02 00 00 00       	mov    $0x2,%ebp
     54b:	3c 10                	cmp    $0x10,%al
     54d:	0f 8e 9e fe ff ff    	jle    3f1 <balancer_ingress+0x3f1>
     553:	3c 11                	cmp    $0x11,%al
     555:	0f 84 5a 02 00 00    	je     7b5 <balancer_ingress+0x7b5>
     55b:	3c 29                	cmp    $0x29,%al
     55d:	0f 85 e9 19 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     563:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     568:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     56d:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     572:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
#define BPF_MAP_OPS_INLINE(name, pref, ret_type, decl_args, type_args, func_params)	\
	__attribute__((__always_inline__)) static inline ret_type pref##bpf_##name decl_args {	\
		return ((ret_type (*) type_args) (access_ptr_at_u64(access_ptr_at_u64(map, BPF_MAP_OPS_OFF), name##_off))) func_params;	\
	}

BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
     577:	48 bf 00 18 8a 91 81 	movabs $0xffff8881918a1800,%rdi
     57e:	88 ff ff 
     581:	48 8b 07             	mov    (%rdi),%rax
     584:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     589:	ff 50 60             	call   *0x60(%rax)
     58c:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     58f:	48 85 c0             	test   %rax,%rax
     592:	74 27                	je     5bb <balancer_ingress+0x5bb>
     594:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     59b:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     59e:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     5a5:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     5ac:	65 bb 
    if (!data_stats) {
     5ae:	48 85 c0             	test   %rax,%rax
     5b1:	0f 84 90 19 00 00    	je     1f47 <balancer_ingress+0x1f47>
    data_stats->v1 += 1;
     5b7:	48 83 00 01          	addq   $0x1,(%rax)
decrement_ttl(void* data, void* data_end, int offset, bool is_ipv6) {
  struct iphdr* iph;
  struct ipv6hdr* ip6h;

  if (is_ipv6) {
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5bb:	48 8d 43 5e          	lea    0x5e(%rbx),%rax
     5bf:	bd 01 00 00 00       	mov    $0x1,%ebp
     5c4:	41 bf 01 00 00 00    	mov    $0x1,%r15d
     5ca:	4c 39 e0             	cmp    %r12,%rax
     5cd:	77 13                	ja     5e2 <balancer_ingress+0x5e2>
      return XDP_DROP;
    }
    ip6h = (struct ipv6hdr*)(data + offset);
    if (!--ip6h->hop_limit) {
     5cf:	80 43 3d ff          	addb   $0xff,0x3d(%rbx)
     5d3:	b8 01 00 00 00       	mov    $0x1,%eax
     5d8:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
     5de:	44 0f 44 f8          	cmove  %eax,%r15d
decap_v6(struct xdp_md* xdp, void** data, void** data_end, bool inner_v4) {
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  old_eth = *data;
  new_eth = *data + sizeof(struct ipv6hdr);
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5e2:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     5e6:	66 89 43 32          	mov    %ax,0x32(%rbx)
     5ea:	8b 43 06             	mov    0x6(%rbx),%eax
     5ed:	89 43 2e             	mov    %eax,0x2e(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     5f0:	8b 03                	mov    (%rbx),%eax
     5f2:	89 43 28             	mov    %eax,0x28(%rbx)
     5f5:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     5f9:	66 89 43 2c          	mov    %ax,0x2c(%rbx)
     5fd:	66 c7 43 34 86 dd    	movw   $0xdd86,0x34(%rbx)
     603:	48 c7 c0 60 39 be b7 	mov    $0xffffffffb7be3960,%rax
  if (inner_v4) {
    new_eth->h_proto = BE_ETH_P_IP;
  } else {
    new_eth->h_proto = BE_ETH_P_IPV6;
  }
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     60a:	4c 89 ef             	mov    %r13,%rdi
     60d:	be 28 00 00 00       	mov    $0x28,%esi
     612:	ff d0                	call   *%rax
     614:	85 c0                	test   %eax,%eax
     616:	0f 85 30 19 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
     61c:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     623:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     626:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     62d:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
     634:	65 bb 
  if (!data_stats) {
     636:	48 85 c9             	test   %rcx,%rcx
     639:	0f 84 0d 19 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     63f:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     644:	45 85 ff             	test   %r15d,%r15d
     647:	bd 02 00 00 00       	mov    $0x2,%ebp
     64c:	41 0f 49 ef          	cmovns %r15d,%ebp
  if (decap_dst_flags) {
     650:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     653:	0f 84 f3 18 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     659:	45 85 ff             	test   %r15d,%r15d
     65c:	0f 89 ea 18 00 00    	jns    1f4c <balancer_ingress+0x1f4c>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     662:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     669:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     670:	65 bb 
    if (xpop_stats_data) {
     672:	48 85 c0             	test   %rax,%rax
     675:	0f 84 af 04 00 00    	je     b2a <balancer_ingress+0xb2a>
     67b:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
     680:	e9 a5 04 00 00       	jmp    b2a <balancer_ingress+0xb2a>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     685:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     68a:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     68f:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     694:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
     699:	48 bf 00 18 8a 91 81 	movabs $0xffff8881918a1800,%rdi
     6a0:	88 ff ff 
     6a3:	48 8b 07             	mov    (%rdi),%rax
     6a6:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     6ab:	ff 50 60             	call   *0x60(%rax)
     6ae:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     6b1:	48 85 c0             	test   %rax,%rax
     6b4:	74 27                	je     6dd <balancer_ingress+0x6dd>
     6b6:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     6bd:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     6c0:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     6c7:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     6ce:	65 bb 
    if (!data_stats) {
     6d0:	48 85 c0             	test   %rax,%rax
     6d3:	0f 84 6e 18 00 00    	je     1f47 <balancer_ingress+0x1f47>
    data_stats->v1 += 1;
     6d9:	48 83 00 01          	addq   $0x1,(%rax)
      // ttl 0
      return XDP_DROP;
    }
  } else {
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     6dd:	48 8d 43 4a          	lea    0x4a(%rbx),%rax
     6e1:	bd 01 00 00 00       	mov    $0x1,%ebp
     6e6:	41 bf 01 00 00 00    	mov    $0x1,%r15d
     6ec:	4c 39 e0             	cmp    %r12,%rax
     6ef:	77 26                	ja     717 <balancer_ingress+0x717>
      return XDP_DROP;
    }
    iph = (struct iphdr*)(data + offset);
    __u32 csum;
    csum = iph->check + 0x0001;
     6f1:	0f b7 43 40          	movzwl 0x40(%rbx),%eax
     6f5:	8d 48 01             	lea    0x1(%rax),%ecx
    iph->check = (csum & 0xffff) + (csum >> 16);
     6f8:	c1 e9 10             	shr    $0x10,%ecx
     6fb:	01 c8                	add    %ecx,%eax
     6fd:	83 c0 01             	add    $0x1,%eax
     700:	66 89 43 40          	mov    %ax,0x40(%rbx)
    if (!--iph->ttl) {
     704:	80 43 3e ff          	addb   $0xff,0x3e(%rbx)
     708:	b8 01 00 00 00       	mov    $0x1,%eax
     70d:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
     713:	44 0f 44 f8          	cmove  %eax,%r15d
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     717:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     71b:	66 89 43 32          	mov    %ax,0x32(%rbx)
     71f:	8b 43 06             	mov    0x6(%rbx),%eax
     722:	89 43 2e             	mov    %eax,0x2e(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     725:	8b 03                	mov    (%rbx),%eax
     727:	89 43 28             	mov    %eax,0x28(%rbx)
     72a:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     72e:	66 89 43 2c          	mov    %ax,0x2c(%rbx)
     732:	66 c7 43 34 08 00    	movw   $0x8,0x34(%rbx)
     738:	48 c7 c0 60 39 be b7 	mov    $0xffffffffb7be3960,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     73f:	4c 89 ef             	mov    %r13,%rdi
     742:	be 28 00 00 00       	mov    $0x28,%esi
     747:	ff d0                	call   *%rax
     749:	85 c0                	test   %eax,%eax
     74b:	0f 85 fb 17 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
     751:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     758:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     75b:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     762:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
     769:	65 bb 
  if (!data_stats) {
     76b:	48 85 c9             	test   %rcx,%rcx
     76e:	0f 84 d8 17 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     774:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     779:	45 85 ff             	test   %r15d,%r15d
     77c:	bd 02 00 00 00       	mov    $0x2,%ebp
     781:	41 0f 49 ef          	cmovns %r15d,%ebp
  if (decap_dst_flags) {
     785:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     788:	0f 84 be 17 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     78e:	45 85 ff             	test   %r15d,%r15d
     791:	0f 89 b5 17 00 00    	jns    1f4c <balancer_ingress+0x1f4c>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     797:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     79e:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     7a5:	65 bb 
    if (xpop_stats_data) {
     7a7:	48 85 c0             	test   %rax,%rax
     7aa:	0f 85 76 03 00 00    	jne    b26 <balancer_ingress+0xb26>
     7b0:	e9 75 03 00 00       	jmp    b2a <balancer_ingress+0xb2a>
  udp = data + off;
     7b5:	48 8d 43 66          	lea    0x66(%rbx),%rax
  if (is_ipv6) {
     7b9:	84 c9                	test   %cl,%cl
  udp = data + off;
     7bb:	49 0f 45 c7          	cmovne %r15,%rax
  if (udp + 1 > data_end) {
     7bf:	48 8d 50 08          	lea    0x8(%rax),%rdx
     7c3:	4c 39 e2             	cmp    %r12,%rdx
     7c6:	0f 87 7b 17 00 00    	ja     1f47 <balancer_ingress+0x1f47>
     7cc:	84 c9                	test   %cl,%cl
     7ce:	89 7c 24 5c          	mov    %edi,0x5c(%rsp)
     7d2:	0f 84 83 00 00 00    	je     85b <balancer_ingress+0x85b>
     7d8:	0f b7 10             	movzwl (%rax),%edx
     7db:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     7e0:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     7e5:	48 83 c0 02          	add    $0x2,%rax
     7e9:	eb 7e                	jmp    869 <balancer_ingress+0x869>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     7eb:	80 7b 37 04          	cmpb   $0x4,0x37(%rbx)
     7ef:	75 32                	jne    823 <balancer_ingress+0x823>
     7f1:	48 b9 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rcx
     7f8:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     7fb:	48 8b 89 68 11 00 00 	mov    0x1168(%rcx),%rcx
     802:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
     809:	65 bb 
    if (!icmp_ptb_v4_stats) {
     80b:	48 85 c9             	test   %rcx,%rcx
     80e:	0f 84 33 17 00 00    	je     1f47 <balancer_ingress+0x1f47>
    icmp_ptb_v4_stats->v1 += 1;
     814:	48 83 01 01          	addq   $0x1,(%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     818:	80 7b 3c 04          	cmpb   $0x4,0x3c(%rbx)
     81c:	77 05                	ja     823 <balancer_ingress+0x823>
      icmp_ptb_v4_stats->v2 += 1;
     81e:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (iph + 1 > data_end) {
     823:	48 8d 4b 52          	lea    0x52(%rbx),%rcx
     827:	4c 39 e1             	cmp    %r12,%rcx
     82a:	0f 87 17 17 00 00    	ja     1f47 <balancer_ingress+0x1f47>
  if (iph->ihl != 5) {
     830:	8a 00                	mov    (%rax),%al
     832:	24 0f                	and    $0xf,%al
     834:	3c 05                	cmp    $0x5,%al
     836:	0f 85 0b 17 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  pckt->flow.proto = iph->protocol;
     83c:	8a 43 47             	mov    0x47(%rbx),%al
     83f:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     843:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  pckt->flow.src = iph->daddr;
     848:	8b 4b 4e             	mov    0x4e(%rbx),%ecx
     84b:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
  pckt->flow.dst = iph->saddr;
     84f:	8b 4b 4a             	mov    0x4a(%rbx),%ecx
     852:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
     856:	e9 e7 fc ff ff       	jmp    542 <balancer_ingress+0x542>
     85b:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     85f:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     864:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     869:	0f b7 00             	movzwl (%rax),%eax
     86c:	66 89 41 02          	mov    %ax,0x2(%rcx)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     870:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     875:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     87a:	48 89 4c 24 68       	mov    %rcx,0x68(%rsp)
     87f:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
  vip.port = pckt.flow.port16[1];
     884:	0f b7 44 24 32       	movzwl 0x32(%rsp),%eax
     889:	66 89 44 24 70       	mov    %ax,0x70(%rsp)
  vip.proto = pckt.flow.proto;
     88e:	8a 44 24 34          	mov    0x34(%rsp),%al
     892:	88 44 24 72          	mov    %al,0x72(%rsp)
     896:	49 be 00 20 8a 91 81 	movabs $0xffff8881918a2000,%r14
     89d:	88 ff ff 
     8a0:	49 8b 06             	mov    (%r14),%rax
     8a3:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
     8a8:	4c 89 f7             	mov    %r14,%rdi
     8ab:	ff 50 60             	call   *0x60(%rax)
     8ae:	48 89 c7             	mov    %rax,%rdi
  if (!vip_info) {
     8b1:	48 85 c0             	test   %rax,%rax
     8b4:	0f 84 07 01 00 00    	je     9c1 <balancer_ingress+0x9c1>
  if (data_end - data > MAX_PCKT_SIZE) {
     8ba:	4c 89 e0             	mov    %r12,%rax
     8bd:	48 29 d8             	sub    %rbx,%rax
     8c0:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     8c6:	0f 8f 7b 16 00 00    	jg     1f47 <balancer_ingress+0x1f47>
     8cc:	48 ba 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rdx
     8d3:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8d6:	4c 8b b2 00 11 00 00 	mov    0x1100(%rdx),%r14
     8dd:	65 4c 03 34 25 28 b0 	add    %gs:0xffffffffbb65b028,%r14
     8e4:	65 bb 
  if (!data_stats) {
     8e6:	4d 85 f6             	test   %r14,%r14
     8e9:	0f 84 58 16 00 00    	je     1f47 <balancer_ingress+0x1f47>
  data_stats->v1 += 1;
     8ef:	49 83 06 01          	addq   $0x1,(%r14)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     8f3:	f6 07 01             	testb  $0x1,(%rdi)
     8f6:	74 07                	je     8ff <balancer_ingress+0x8ff>
    pckt.flow.port16[0] = 0;
     8f8:	66 c7 44 24 30 00 00 	movw   $0x0,0x30(%rsp)
  vip_num = vip_info->vip_num;
     8ff:	8b 77 04             	mov    0x4(%rdi),%esi
     902:	48 c7 c0 34 b0 65 bb 	mov    $0xffffffffbb65b034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     909:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     910:	65 bb 
     912:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     915:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     91a:	0f 84 1b 05 00 00    	je     e3b <balancer_ingress+0xe3b>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     920:	48 8b 82 18 11 00 00 	mov    0x1118(%rdx),%rax
     927:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     92e:	65 bb 
    if (!lru_stats) {
     930:	48 85 c0             	test   %rax,%rax
     933:	0f 84 0e 16 00 00    	je     1f47 <balancer_ingress+0x1f47>
    lru_stats->v1 += 1;
     939:	48 83 00 01          	addq   $0x1,(%rax)
     93d:	48 b8 00 28 8a 91 81 	movabs $0xffff8881918a2800,%rax
     944:	88 ff ff 
     947:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
     94c:	e9 0c 05 00 00       	jmp    e5d <balancer_ingress+0xe5d>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     951:	80 7b 23 04          	cmpb   $0x4,0x23(%rbx)
     955:	75 32                	jne    989 <balancer_ingress+0x989>
     957:	48 b9 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rcx
     95e:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     961:	48 8b 89 68 11 00 00 	mov    0x1168(%rcx),%rcx
     968:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
     96f:	65 bb 
    if (!icmp_ptb_v4_stats) {
     971:	48 85 c9             	test   %rcx,%rcx
     974:	0f 84 cd 15 00 00    	je     1f47 <balancer_ingress+0x1f47>
    icmp_ptb_v4_stats->v1 += 1;
     97a:	48 83 01 01          	addq   $0x1,(%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     97e:	80 7b 28 04          	cmpb   $0x4,0x28(%rbx)
     982:	77 05                	ja     989 <balancer_ingress+0x989>
      icmp_ptb_v4_stats->v2 += 1;
     984:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (iph + 1 > data_end) {
     989:	48 8d 4b 3e          	lea    0x3e(%rbx),%rcx
     98d:	4c 39 e1             	cmp    %r12,%rcx
     990:	0f 87 b1 15 00 00    	ja     1f47 <balancer_ingress+0x1f47>
  if (iph->ihl != 5) {
     996:	8a 00                	mov    (%rax),%al
     998:	24 0f                	and    $0xf,%al
     99a:	3c 05                	cmp    $0x5,%al
     99c:	0f 85 a5 15 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  pckt->flow.proto = iph->protocol;
     9a2:	8a 43 33             	mov    0x33(%rbx),%al
     9a5:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     9a9:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  pckt->flow.src = iph->daddr;
     9ae:	8b 4b 3a             	mov    0x3a(%rbx),%ecx
     9b1:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
  pckt->flow.dst = iph->saddr;
     9b5:	8b 4b 36             	mov    0x36(%rbx),%ecx
     9b8:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
     9bc:	e9 08 02 00 00       	jmp    bc9 <balancer_ingress+0xbc9>
    vip.port = 0;
     9c1:	66 c7 44 24 70 00 00 	movw   $0x0,0x70(%rsp)
     9c8:	49 8b 06             	mov    (%r14),%rax
     9cb:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
     9d0:	4c 89 f7             	mov    %r14,%rdi
     9d3:	ff 50 60             	call   *0x60(%rax)
    if (!vip_info) {
     9d6:	48 85 c0             	test   %rax,%rax
     9d9:	0f 84 6d 15 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     9df:	48 89 c7             	mov    %rax,%rdi
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     9e2:	f6 00 88             	testb  $0x88,(%rax)
     9e5:	0f 85 cf fe ff ff    	jne    8ba <balancer_ingress+0x8ba>
      pckt.flow.port16[1] = 0;
     9eb:	66 c7 44 24 32 00 00 	movw   $0x0,0x32(%rsp)
     9f2:	e9 c3 fe ff ff       	jmp    8ba <balancer_ingress+0x8ba>
  struct address dst_addr = {};
     9f7:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%rsp)
     9fe:	00 
     9ff:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
     a06:	00 00 
    dst_addr.addr = pckt->flow.dst;
     a08:	8b 44 24 20          	mov    0x20(%rsp),%eax
     a0c:	89 44 24 40          	mov    %eax,0x40(%rsp)
     a10:	48 bf 00 18 8a 91 81 	movabs $0xffff8881918a1800,%rdi
     a17:	88 ff ff 
     a1a:	48 8b 07             	mov    (%rdi),%rax
     a1d:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     a22:	ff 50 60             	call   *0x60(%rax)
     a25:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     a28:	48 85 c0             	test   %rax,%rax
     a2b:	74 27                	je     a54 <balancer_ingress+0xa54>
     a2d:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     a34:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a37:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     a3e:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     a45:	65 bb 
    if (!data_stats) {
     a47:	48 85 c0             	test   %rax,%rax
     a4a:	0f 84 f7 14 00 00    	je     1f47 <balancer_ingress+0x1f47>
    data_stats->v1 += 1;
     a50:	48 83 00 01          	addq   $0x1,(%rax)
     a54:	48 8d 43 14          	lea    0x14(%rbx),%rax
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     a58:	48 8d 4b 36          	lea    0x36(%rbx),%rcx
     a5c:	bd 01 00 00 00       	mov    $0x1,%ebp
     a61:	41 bf 01 00 00 00    	mov    $0x1,%r15d
     a67:	4c 39 e1             	cmp    %r12,%rcx
     a6a:	77 26                	ja     a92 <balancer_ingress+0xa92>
    csum = iph->check + 0x0001;
     a6c:	0f b7 4b 2c          	movzwl 0x2c(%rbx),%ecx
     a70:	8d 51 01             	lea    0x1(%rcx),%edx
    iph->check = (csum & 0xffff) + (csum >> 16);
     a73:	c1 ea 10             	shr    $0x10,%edx
     a76:	01 d1                	add    %edx,%ecx
     a78:	83 c1 01             	add    $0x1,%ecx
     a7b:	66 89 4b 2c          	mov    %cx,0x2c(%rbx)
    if (!--iph->ttl) {
     a7f:	80 43 2a ff          	addb   $0xff,0x2a(%rbx)
     a83:	b9 01 00 00 00       	mov    $0x1,%ecx
     a88:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
     a8e:	44 0f 44 f9          	cmove  %ecx,%r15d
decap_v4(struct xdp_md* xdp, void** data, void** data_end) {
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  old_eth = *data;
  new_eth = *data + sizeof(struct iphdr);
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     a92:	0f b7 4b 0a          	movzwl 0xa(%rbx),%ecx
     a96:	66 89 4b 1e          	mov    %cx,0x1e(%rbx)
     a9a:	8b 4b 06             	mov    0x6(%rbx),%ecx
     a9d:	89 4b 1a             	mov    %ecx,0x1a(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     aa0:	0f b7 4b 04          	movzwl 0x4(%rbx),%ecx
     aa4:	66 89 48 04          	mov    %cx,0x4(%rax)
     aa8:	8b 0b                	mov    (%rbx),%ecx
     aaa:	89 08                	mov    %ecx,(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
     aac:	66 c7 43 20 08 00    	movw   $0x8,0x20(%rbx)
     ab2:	48 c7 c0 60 39 be b7 	mov    $0xffffffffb7be3960,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     ab9:	4c 89 ef             	mov    %r13,%rdi
     abc:	be 14 00 00 00       	mov    $0x14,%esi
     ac1:	ff d0                	call   *%rax
     ac3:	85 c0                	test   %eax,%eax
     ac5:	0f 85 81 14 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
     acb:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     ad2:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     ad5:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     adc:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
     ae3:	65 bb 
  if (!data_stats) {
     ae5:	48 85 c9             	test   %rcx,%rcx
     ae8:	0f 84 5e 14 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     aee:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     af3:	45 85 ff             	test   %r15d,%r15d
     af6:	bd 02 00 00 00       	mov    $0x2,%ebp
     afb:	41 0f 49 ef          	cmovns %r15d,%ebp
  if (decap_dst_flags) {
     aff:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     b02:	0f 84 44 14 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     b08:	45 85 ff             	test   %r15d,%r15d
     b0b:	0f 89 3b 14 00 00    	jns    1f4c <balancer_ingress+0x1f4c>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b11:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     b18:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     b1f:	65 bb 
    if (xpop_stats_data) {
     b21:	48 85 c0             	test   %rax,%rax
     b24:	74 04                	je     b2a <balancer_ingress+0xb2a>
     b26:	48 83 00 01          	addq   $0x1,(%rax)
     b2a:	48 b8 00 50 5f 06 81 	movabs $0xffff8881065f5000,%rax
     b31:	88 ff ff 
     b34:	48 8b 88 00 01 00 00 	mov    0x100(%rax),%rcx
     b3b:	48 85 c9             	test   %rcx,%rcx
     b3e:	0f 84 c5 03 00 00    	je     f09 <balancer_ingress+0xf09>
     b44:	4c 89 ef             	mov    %r13,%rdi
     b47:	ff 51 30             	call   *0x30(%rcx)
     b4a:	89 c5                	mov    %eax,%ebp
     b4c:	e9 fb 13 00 00       	jmp    1f4c <balancer_ingress+0x1f4c>
     b51:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     b58:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     b5b:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     b62:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     b69:	65 bb 
    if (!icmp_ptb_v6_stats) {
     b6b:	48 85 c0             	test   %rax,%rax
     b6e:	0f 84 d3 13 00 00    	je     1f47 <balancer_ingress+0x1f47>
    icmp_ptb_v6_stats->v1 += 1;
     b74:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     b78:	8b 4b 26             	mov    0x26(%rbx),%ecx
     b7b:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     b7d:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     b83:	77 05                	ja     b8a <balancer_ingress+0xb8a>
      icmp_ptb_v6_stats->v2 += 1;
     b85:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     b8a:	48 8d 43 52          	lea    0x52(%rbx),%rax
     b8e:	4c 39 e0             	cmp    %r12,%rax
     b91:	0f 87 b0 13 00 00    	ja     1f47 <balancer_ingress+0x1f47>
     b97:	48 8d 4c 24 20       	lea    0x20(%rsp),%rcx
  pckt->flow.proto = ip6h->nexthdr;
     b9c:	8a 43 30             	mov    0x30(%rbx),%al
     b9f:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     ba3:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     ba8:	48 8b 53 42          	mov    0x42(%rbx),%rdx
     bac:	48 8b 73 4a          	mov    0x4a(%rbx),%rsi
     bb0:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
     bb5:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     bba:	48 8b 53 32          	mov    0x32(%rbx),%rdx
     bbe:	48 8b 73 3a          	mov    0x3a(%rbx),%rsi
     bc2:	48 89 11             	mov    %rdx,(%rcx)
     bc5:	48 89 71 08          	mov    %rsi,0x8(%rcx)
     bc9:	b2 03                	mov    $0x3,%dl
     bcb:	31 c9                	xor    %ecx,%ecx
     bcd:	bd 02 00 00 00       	mov    $0x2,%ebp
  if (protocol == IPPROTO_IPIP) {
     bd2:	3c 10                	cmp    $0x10,%al
     bd4:	0f 8e b8 f8 ff ff    	jle    492 <balancer_ingress+0x492>
     bda:	3c 11                	cmp    $0x11,%al
     bdc:	0f 84 3c 01 00 00    	je     d1e <balancer_ingress+0xd1e>
     be2:	3c 29                	cmp    $0x29,%al
     be4:	0f 85 62 13 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
  struct address dst_addr = {};
     bea:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%rsp)
     bf1:	00 
     bf2:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
     bf9:	00 00 
    dst_addr.addr = pckt->flow.dst;
     bfb:	8b 44 24 20          	mov    0x20(%rsp),%eax
     bff:	89 44 24 40          	mov    %eax,0x40(%rsp)
     c03:	48 bf 00 18 8a 91 81 	movabs $0xffff8881918a1800,%rdi
     c0a:	88 ff ff 
     c0d:	48 8b 07             	mov    (%rdi),%rax
     c10:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     c15:	ff 50 60             	call   *0x60(%rax)
     c18:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     c1b:	48 85 c0             	test   %rax,%rax
     c1e:	74 27                	je     c47 <balancer_ingress+0xc47>
     c20:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     c27:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c2a:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     c31:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     c38:	65 bb 
    if (!data_stats) {
     c3a:	48 85 c0             	test   %rax,%rax
     c3d:	0f 84 04 13 00 00    	je     1f47 <balancer_ingress+0x1f47>
    data_stats->v1 += 1;
     c43:	48 83 00 01          	addq   $0x1,(%rax)
    if ((*data + offset) > *data_end) {
     c47:	48 8d 43 36          	lea    0x36(%rbx),%rax
     c4b:	bd 01 00 00 00       	mov    $0x1,%ebp
     c50:	4c 39 e0             	cmp    %r12,%rax
     c53:	0f 87 f3 12 00 00    	ja     1f4c <balancer_ingress+0x1f4c>
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     c59:	48 8d 43 5e          	lea    0x5e(%rbx),%rax
     c5d:	bd 01 00 00 00       	mov    $0x1,%ebp
     c62:	41 bf 01 00 00 00    	mov    $0x1,%r15d
     c68:	4c 39 e0             	cmp    %r12,%rax
     c6b:	77 13                	ja     c80 <balancer_ingress+0xc80>
    if (!--ip6h->hop_limit) {
     c6d:	80 43 3d ff          	addb   $0xff,0x3d(%rbx)
     c71:	b8 01 00 00 00       	mov    $0x1,%eax
     c76:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
     c7c:	44 0f 44 f8          	cmove  %eax,%r15d
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     c80:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     c84:	66 89 43 32          	mov    %ax,0x32(%rbx)
     c88:	8b 43 06             	mov    0x6(%rbx),%eax
     c8b:	89 43 2e             	mov    %eax,0x2e(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     c8e:	8b 03                	mov    (%rbx),%eax
     c90:	89 43 28             	mov    %eax,0x28(%rbx)
     c93:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     c97:	66 89 43 2c          	mov    %ax,0x2c(%rbx)
     c9b:	66 c7 43 34 86 dd    	movw   $0xdd86,0x34(%rbx)
     ca1:	48 c7 c0 60 39 be b7 	mov    $0xffffffffb7be3960,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     ca8:	4c 89 ef             	mov    %r13,%rdi
     cab:	be 28 00 00 00       	mov    $0x28,%esi
     cb0:	ff d0                	call   *%rax
     cb2:	85 c0                	test   %eax,%eax
     cb4:	0f 85 92 12 00 00    	jne    1f4c <balancer_ingress+0x1f4c>
     cba:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     cc1:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     cc4:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     ccb:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
     cd2:	65 bb 
  if (!data_stats) {
     cd4:	48 85 c9             	test   %rcx,%rcx
     cd7:	0f 84 6f 12 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     cdd:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     ce2:	45 85 ff             	test   %r15d,%r15d
     ce5:	bd 02 00 00 00       	mov    $0x2,%ebp
     cea:	41 0f 49 ef          	cmovns %r15d,%ebp
  if (decap_dst_flags) {
     cee:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     cf1:	0f 84 55 12 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     cf7:	45 85 ff             	test   %r15d,%r15d
     cfa:	0f 89 4c 12 00 00    	jns    1f4c <balancer_ingress+0x1f4c>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     d00:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     d07:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     d0e:	65 bb 
    if (xpop_stats_data) {
     d10:	48 85 c0             	test   %rax,%rax
     d13:	0f 85 62 f9 ff ff    	jne    67b <balancer_ingress+0x67b>
     d19:	e9 0c fe ff ff       	jmp    b2a <balancer_ingress+0xb2a>
  udp = data + off;
     d1e:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
  if (is_ipv6) {
     d22:	84 c9                	test   %cl,%cl
  udp = data + off;
     d24:	49 0f 45 c6          	cmovne %r14,%rax
  if (udp + 1 > data_end) {
     d28:	48 8d 50 08          	lea    0x8(%rax),%rdx
     d2c:	4c 39 e2             	cmp    %r12,%rdx
     d2f:	0f 87 12 12 00 00    	ja     1f47 <balancer_ingress+0x1f47>
     d35:	84 c9                	test   %cl,%cl
     d37:	66 89 7c 24 5c       	mov    %di,0x5c(%rsp)
     d3c:	74 13                	je     d51 <balancer_ingress+0xd51>
     d3e:	0f b7 10             	movzwl (%rax),%edx
     d41:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     d46:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     d4b:	48 83 c0 02          	add    $0x2,%rax
     d4f:	eb 0e                	jmp    d5f <balancer_ingress+0xd5f>
     d51:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     d55:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     d5a:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     d5f:	0f b7 00             	movzwl (%rax),%eax
     d62:	66 89 41 02          	mov    %ax,0x2(%rcx)
    vip.vip = pckt.flow.dst;
     d66:	8b 44 24 20          	mov    0x20(%rsp),%eax
     d6a:	89 44 24 60          	mov    %eax,0x60(%rsp)
  vip.port = pckt.flow.port16[1];
     d6e:	0f b7 44 24 32       	movzwl 0x32(%rsp),%eax
     d73:	66 89 44 24 70       	mov    %ax,0x70(%rsp)
  vip.proto = pckt.flow.proto;
     d78:	8a 44 24 34          	mov    0x34(%rsp),%al
     d7c:	88 44 24 72          	mov    %al,0x72(%rsp)
     d80:	49 bf 00 20 8a 91 81 	movabs $0xffff8881918a2000,%r15
     d87:	88 ff ff 
     d8a:	49 8b 07             	mov    (%r15),%rax
     d8d:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
     d92:	4c 89 ff             	mov    %r15,%rdi
     d95:	ff 50 60             	call   *0x60(%rax)
     d98:	48 89 c7             	mov    %rax,%rdi
  if (!vip_info) {
     d9b:	48 85 c0             	test   %rax,%rax
     d9e:	0f 84 2f 01 00 00    	je     ed3 <balancer_ingress+0xed3>
  if (data_end - data > MAX_PCKT_SIZE) {
     da4:	4c 89 e0             	mov    %r12,%rax
     da7:	48 29 d8             	sub    %rbx,%rax
     daa:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     db0:	0f 8f 91 11 00 00    	jg     1f47 <balancer_ingress+0x1f47>
     db6:	48 ba 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rdx
     dbd:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     dc0:	4c 8b ba 00 11 00 00 	mov    0x1100(%rdx),%r15
     dc7:	65 4c 03 3c 25 28 b0 	add    %gs:0xffffffffbb65b028,%r15
     dce:	65 bb 
  if (!data_stats) {
     dd0:	4d 85 ff             	test   %r15,%r15
     dd3:	0f 84 6e 11 00 00    	je     1f47 <balancer_ingress+0x1f47>
  data_stats->v1 += 1;
     dd9:	49 83 07 01          	addq   $0x1,(%r15)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     ddd:	f6 07 01             	testb  $0x1,(%rdi)
     de0:	74 07                	je     de9 <balancer_ingress+0xde9>
    pckt.flow.port16[0] = 0;
     de2:	66 c7 44 24 30 00 00 	movw   $0x0,0x30(%rsp)
  vip_num = vip_info->vip_num;
     de9:	8b 77 04             	mov    0x4(%rdi),%esi
     dec:	48 c7 c0 34 b0 65 bb 	mov    $0xffffffffbb65b034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     df3:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     dfa:	65 bb 
     dfc:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     dff:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     e04:	0f 84 3d 01 00 00    	je     f47 <balancer_ingress+0xf47>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e0a:	48 8b 82 18 11 00 00 	mov    0x1118(%rdx),%rax
     e11:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
     e18:	65 bb 
    if (!lru_stats) {
     e1a:	48 85 c0             	test   %rax,%rax
     e1d:	0f 84 24 11 00 00    	je     1f47 <balancer_ingress+0x1f47>
    lru_stats->v1 += 1;
     e23:	48 83 00 01          	addq   $0x1,(%rax)
     e27:	48 b8 00 28 8a 91 81 	movabs $0xffff8881918a2800,%rax
     e2e:	88 ff ff 
     e31:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
     e36:	e9 2e 01 00 00       	jmp    f69 <balancer_ingress+0xf69>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e3b:	89 c0                	mov    %eax,%eax
     e3d:	48 b9 00 20 88 91 81 	movabs $0xffff888191882000,%rcx
     e44:	88 ff ff 
     e47:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     e4e:	00 
     e4f:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  if (!lru_map) {
     e54:	48 85 c0             	test   %rax,%rax
     e57:	0f 84 c3 fa ff ff    	je     920 <balancer_ingress+0x920>
  if ((vip_info->flags & F_QUIC_VIP)) {
     e5d:	f6 07 04             	testb  $0x4,(%rdi)
     e60:	0f 84 b7 0a 00 00    	je     191d <balancer_ingress+0x191d>
    bool is_icmp = (pckt.flags & F_ICMP);
     e66:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
    if (is_icmp) {
     e6b:	0f 85 a2 00 00 00    	jne    f13 <balancer_ingress+0xf13>
     e71:	48 b8 00 58 5f 06 81 	movabs $0xffff8881065f5800,%rax
     e78:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     e7b:	48 8b a8 00 01 00 00 	mov    0x100(%rax),%rbp
     e82:	65 48 03 2c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbp
     e89:	65 bb 
      if (!quic_packets_stats) {
     e8b:	48 85 ed             	test   %rbp,%rbp
     e8e:	0f 84 b3 10 00 00    	je     1f47 <balancer_ingress+0x1f47>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e94:	48 83 c3 66          	add    $0x66,%rbx
  bool is_icmp = (pckt->flags & F_ICMP);
     e98:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e9d:	49 0f 44 df          	cmove  %r15,%rbx
     ea1:	48 8d 43 09          	lea    0x9(%rbx),%rax
     ea5:	4c 39 e0             	cmp    %r12,%rax
     ea8:	0f 87 6a 0a 00 00    	ja     1918 <balancer_ingress+0x1918>
     eae:	49 89 f7             	mov    %rsi,%r15
     eb1:	48 83 c3 08          	add    $0x8,%rbx
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     eb5:	0f b6 0b             	movzbl (%rbx),%ecx
     eb8:	f6 c1 80             	test   $0x80,%cl
     ebb:	0f 85 b0 01 00 00    	jne    1071 <balancer_ingress+0x1071>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     ec1:	48 83 c3 09          	add    $0x9,%rbx
     ec5:	4c 39 e3             	cmp    %r12,%rbx
     ec8:	0f 86 d4 02 00 00    	jbe    11a2 <balancer_ingress+0x11a2>
     ece:	e9 38 0a 00 00       	jmp    190b <balancer_ingress+0x190b>
    vip.port = 0;
     ed3:	66 c7 44 24 70 00 00 	movw   $0x0,0x70(%rsp)
     eda:	49 8b 07             	mov    (%r15),%rax
     edd:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
     ee2:	4c 89 ff             	mov    %r15,%rdi
     ee5:	ff 50 60             	call   *0x60(%rax)
    if (!vip_info) {
     ee8:	48 85 c0             	test   %rax,%rax
     eeb:	0f 84 5b 10 00 00    	je     1f4c <balancer_ingress+0x1f4c>
     ef1:	48 89 c7             	mov    %rax,%rdi
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     ef4:	f6 00 88             	testb  $0x88,(%rax)
     ef7:	0f 85 a7 fe ff ff    	jne    da4 <balancer_ingress+0xda4>
      pckt.flow.port16[1] = 0;
     efd:	66 c7 44 24 32 00 00 	movw   $0x0,0x32(%rsp)
     f04:	e9 9b fe ff ff       	jmp    da4 <balancer_ingress+0xda4>
     f09:	bd 02 00 00 00       	mov    $0x2,%ebp
     f0e:	e9 39 10 00 00       	jmp    1f4c <balancer_ingress+0x1f4c>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     f13:	48 8b aa 58 11 00 00 	mov    0x1158(%rdx),%rbp
     f1a:	65 48 03 2c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbp
     f21:	65 bb 
      if (!data_stats) {
     f23:	48 85 ed             	test   %rbp,%rbp
     f26:	0f 84 1b 10 00 00    	je     1f47 <balancer_ingress+0x1f47>
      data_stats->v1 += 1;
     f2c:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     f31:	8a 43 37             	mov    0x37(%rbx),%al
     f34:	04 fd                	add    $0xfd,%al
     f36:	3c 01                	cmp    $0x1,%al
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     f38:	0f 87 df 09 00 00    	ja     191d <balancer_ingress+0x191d>
        data_stats->v2 += 1;
     f3e:	48 83 c5 08          	add    $0x8,%rbp
     f42:	e9 d1 09 00 00       	jmp    1918 <balancer_ingress+0x1918>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     f47:	89 c0                	mov    %eax,%eax
     f49:	48 b9 00 20 88 91 81 	movabs $0xffff888191882000,%rcx
     f50:	88 ff ff 
     f53:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     f5a:	00 
     f5b:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  if (!lru_map) {
     f60:	48 85 c0             	test   %rax,%rax
     f63:	0f 84 a1 fe ff ff    	je     e0a <balancer_ingress+0xe0a>
     f69:	48 89 b4 24 80 00 00 	mov    %rsi,0x80(%rsp)
     f70:	00 
  if ((vip_info->flags & F_QUIC_VIP)) {
     f71:	f6 07 04             	testb  $0x4,(%rdi)
     f74:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
     f79:	0f 84 8a 00 00 00    	je     1009 <balancer_ingress+0x1009>
    bool is_icmp = (pckt.flags & F_ICMP);
     f7f:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
    if (is_icmp) {
     f84:	75 44                	jne    fca <balancer_ingress+0xfca>
     f86:	48 b8 00 58 5f 06 81 	movabs $0xffff8881065f5800,%rax
     f8d:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     f90:	48 8b a8 00 01 00 00 	mov    0x100(%rax),%rbp
     f97:	65 48 03 2c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbp
     f9e:	65 bb 
      if (!quic_packets_stats) {
     fa0:	48 85 ed             	test   %rbp,%rbp
     fa3:	0f 84 9e 0f 00 00    	je     1f47 <balancer_ingress+0x1f47>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fa9:	48 83 c3 3e          	add    $0x3e,%rbx
  bool is_icmp = (pckt->flags & F_ICMP);
     fad:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fb2:	49 0f 44 de          	cmove  %r14,%rbx
     fb6:	48 8d 43 09          	lea    0x9(%rbx),%rax
     fba:	4c 39 e0             	cmp    %r12,%rax
     fbd:	0f 86 0b 01 00 00    	jbe    10ce <balancer_ingress+0x10ce>
     fc3:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
     fc8:	eb 3a                	jmp    1004 <balancer_ingress+0x1004>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fca:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
     fd1:	88 ff ff 
     fd4:	48 8b a8 58 11 00 00 	mov    0x1158(%rax),%rbp
     fdb:	65 48 03 2c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbp
     fe2:	65 bb 
      if (!data_stats) {
     fe4:	48 85 ed             	test   %rbp,%rbp
     fe7:	0f 84 5a 0f 00 00    	je     1f47 <balancer_ingress+0x1f47>
      data_stats->v1 += 1;
     fed:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     ff2:	8a 43 23             	mov    0x23(%rbx),%al
     ff5:	24 fd                	and    $0xfd,%al
     ff7:	3c 01                	cmp    $0x1,%al
     ff9:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     ffe:	75 09                	jne    1009 <balancer_ingress+0x1009>
        data_stats->v2 += 1;
    1000:	48 83 c5 08          	add    $0x8,%rbp
    1004:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
  original_sport = pckt.flow.port16[0];
    1009:	44 0f b7 64 24 30    	movzwl 0x30(%rsp),%r12d
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    100f:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    1014:	75 53                	jne    1069 <balancer_ingress+0x1069>
        !(vip_info->flags & F_LRU_BYPASS)) {
    1016:	f6 07 02             	testb  $0x2,(%rdi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1019:	75 46                	jne    1061 <balancer_ingress+0x1061>
    101b:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    1020:	48 8b 07             	mov    (%rdi),%rax
    1023:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    1028:	ff 50 60             	call   *0x60(%rax)
  if (!dst_lru) {
    102b:	48 85 c0             	test   %rax,%rax
    102e:	74 31                	je     1061 <balancer_ingress+0x1061>
    1030:	48 89 c5             	mov    %rax,%rbp
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1033:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1038:	0f 85 b0 01 00 00    	jne    11ee <balancer_ingress+0x11ee>
    103e:	48 c7 c0 60 23 a5 b5 	mov    $0xffffffffb5a52360,%rax
    cur_time = bpf_ktime_get_ns();
    1045:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1047:	48 89 c1             	mov    %rax,%rcx
    104a:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    104e:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    1055:	00 00 00 
    1058:	48 39 d1             	cmp    %rdx,%rcx
    105b:	0f 86 89 01 00 00    	jbe    11ea <balancer_ingress+0x11ea>
    1061:	45 31 f6             	xor    %r14d,%r14d
    1064:	e9 af 01 00 00       	jmp    1218 <balancer_ingress+0x1218>
    1069:	45 31 f6             	xor    %r14d,%r14d
    106c:	e9 ac 01 00 00       	jmp    121d <balancer_ingress+0x121d>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1071:	48 8d 43 0e          	lea    0xe(%rbx),%rax
    1075:	4c 39 e0             	cmp    %r12,%rax
    1078:	0f 87 8d 08 00 00    	ja     190b <balancer_ingress+0x190b>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    107e:	f6 c1 20             	test   $0x20,%cl
    1081:	0f 85 0a 01 00 00    	jne    1191 <balancer_ingress+0x1191>
        quic_packets_stats->cid_initial += 1;
    1087:	48 83 45 08 01       	addq   $0x1,0x8(%rbp)
    108c:	4c 89 fe             	mov    %r15,%rsi
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    108f:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
    1095:	48 ba 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rdx
    109c:	88 ff ff 
    109f:	0f 87 78 08 00 00    	ja     191d <balancer_ingress+0x191d>
    10a5:	48 b8 00 c0 5e 66 81 	movabs $0xffff8881665ec000,%rax
    10ac:	88 ff ff 
    10af:	48 8b ac f0 00 01 00 	mov    0x100(%rax,%rsi,8),%rbp
    10b6:	00 
    10b7:	65 48 03 2c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbp
    10be:	65 bb 
  if (!per_vip_stats) {
    10c0:	48 85 ed             	test   %rbp,%rbp
    10c3:	0f 85 4f 08 00 00    	jne    1918 <balancer_ingress+0x1918>
    10c9:	e9 4f 08 00 00       	jmp    191d <balancer_ingress+0x191d>
    10ce:	48 83 c3 08          	add    $0x8,%rbx
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    10d2:	0f b6 0b             	movzbl (%rbx),%ecx
    10d5:	f6 c1 80             	test   $0x80,%cl
    10d8:	75 55                	jne    112f <balancer_ingress+0x112f>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    10da:	48 83 c3 09          	add    $0x9,%rbx
    10de:	4c 39 e3             	cmp    %r12,%rbx
    10e1:	0f 87 dc fe ff ff    	ja     fc3 <balancer_ingress+0xfc3>
  if (!connId) {
    10e7:	48 85 c0             	test   %rax,%rax
    10ea:	0f 84 d3 fe ff ff    	je     fc3 <balancer_ingress+0xfc3>
  __u8 connIdVersion = (connId[0] >> 6);
    10f0:	0f b6 08             	movzbl (%rax),%ecx
    10f3:	89 ca                	mov    %ecx,%edx
    10f5:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10f8:	80 fa 03             	cmp    $0x3,%dl
    10fb:	0f 84 3e 10 00 00    	je     213f <balancer_ingress+0x213f>
    1101:	80 fa 02             	cmp    $0x2,%dl
    1104:	0f 84 5a 10 00 00    	je     2164 <balancer_ingress+0x2164>
    110a:	80 fa 01             	cmp    $0x1,%dl
    110d:	0f 85 b0 fe ff ff    	jne    fc3 <balancer_ingress+0xfc3>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    1113:	83 e1 3f             	and    $0x3f,%ecx
    1116:	48 c1 e1 0a          	shl    $0xa,%rcx
    111a:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    111e:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
    1122:	8a 40 02             	mov    0x2(%rax),%al
    1125:	c0 e8 06             	shr    $0x6,%al
    1128:	b2 01                	mov    $0x1,%dl
    112a:	e9 4d 10 00 00       	jmp    217c <balancer_ingress+0x217c>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    112f:	48 8d 43 0e          	lea    0xe(%rbx),%rax
    1133:	4c 39 e0             	cmp    %r12,%rax
    1136:	0f 87 87 fe ff ff    	ja     fc3 <balancer_ingress+0xfc3>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    113c:	f6 c1 20             	test   $0x20,%cl
    113f:	0f 85 03 07 00 00    	jne    1848 <balancer_ingress+0x1848>
        quic_packets_stats->cid_initial += 1;
    1145:	48 83 45 08 01       	addq   $0x1,0x8(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    114a:	81 bc 24 80 00 00 00 	cmpl   $0x1ff,0x80(%rsp)
    1151:	ff 01 00 00 
    1155:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    115a:	0f 87 a9 fe ff ff    	ja     1009 <balancer_ingress+0x1009>
    1160:	48 b8 00 c0 5e 66 81 	movabs $0xffff8881665ec000,%rax
    1167:	88 ff ff 
    116a:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
    1171:	00 
    1172:	48 8b ac c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rbp
    1179:	00 
    117a:	65 48 03 2c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbp
    1181:	65 bb 
  if (!per_vip_stats) {
    1183:	48 85 ed             	test   %rbp,%rbp
    1186:	0f 85 78 fe ff ff    	jne    1004 <balancer_ingress+0x1004>
    118c:	e9 78 fe ff ff       	jmp    1009 <balancer_ingress+0x1009>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1191:	80 7b 05 08          	cmpb   $0x8,0x5(%rbx)
    1195:	0f 82 70 07 00 00    	jb     190b <balancer_ingress+0x190b>
    119b:	48 83 c3 06          	add    $0x6,%rbx
    119f:	48 89 d8             	mov    %rbx,%rax
  if (!connId) {
    11a2:	48 85 c0             	test   %rax,%rax
    11a5:	0f 84 60 07 00 00    	je     190b <balancer_ingress+0x190b>
  __u8 connIdVersion = (connId[0] >> 6);
    11ab:	0f b6 08             	movzbl (%rax),%ecx
    11ae:	89 ca                	mov    %ecx,%edx
    11b0:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    11b3:	80 fa 03             	cmp    $0x3,%dl
    11b6:	0f 84 5e 05 00 00    	je     171a <balancer_ingress+0x171a>
    11bc:	80 fa 02             	cmp    $0x2,%dl
    11bf:	0f 84 7a 05 00 00    	je     173f <balancer_ingress+0x173f>
    11c5:	80 fa 01             	cmp    $0x1,%dl
    11c8:	0f 85 3d 07 00 00    	jne    190b <balancer_ingress+0x190b>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    11ce:	83 e1 3f             	and    $0x3f,%ecx
    11d1:	48 c1 e1 0a          	shl    $0xa,%rcx
    11d5:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    11d9:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
    11dd:	8a 40 02             	mov    0x2(%rax),%al
    11e0:	c0 e8 06             	shr    $0x6,%al
    11e3:	b2 01                	mov    $0x1,%dl
    11e5:	e9 6d 05 00 00       	jmp    1757 <balancer_ingress+0x1757>
    dst_lru->atime = cur_time;
    11ea:	48 89 45 08          	mov    %rax,0x8(%rbp)
  key = dst_lru->pos;
    11ee:	8b 45 00             	mov    0x0(%rbp),%eax
    11f1:	45 31 f6             	xor    %r14d,%r14d
    11f4:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    11fa:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    11fe:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    1202:	48 b9 00 30 3f 08 00 	movabs $0xffffc900083f3000,%rcx
    1209:	c9 ff ff 
    120c:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    1213:	00 
    1214:	4c 0f 42 f0          	cmovb  %rax,%r14
    1218:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    121d:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1222:	0f 85 be 00 00 00    	jne    12e6 <balancer_ingress+0x12e6>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1228:	f6 47 01 02          	testb  $0x2,0x1(%rdi)
    122c:	0f 84 b4 00 00 00    	je     12e6 <balancer_ingress+0x12e6>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1232:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    1239:	88 ff ff 
    123c:	48 8b 98 10 11 00 00 	mov    0x1110(%rax),%rbx
    1243:	65 48 03 1c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbx
    124a:	65 bb 
  if (!conn_rate_stats) {
    124c:	48 85 db             	test   %rbx,%rbx
    124f:	0f 84 91 00 00 00    	je     12e6 <balancer_ingress+0x12e6>
    1255:	48 c7 c0 60 23 a5 b5 	mov    $0xffffffffb5a52360,%rax
  *cur_time = bpf_ktime_get_ns();
    125c:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    125e:	48 89 c1             	mov    %rax,%rcx
    1261:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1265:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    126c:	72 0d                	jb     127b <balancer_ingress+0x127b>
    conn_rate_stats->v1 = 1;
    126e:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1275:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1279:	eb 12                	jmp    128d <balancer_ingress+0x128d>
    conn_rate_stats->v1 += 1;
    127b:	48 8b 03             	mov    (%rbx),%rax
    127e:	48 83 c0 01          	add    $0x1,%rax
    1282:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1285:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    128b:	77 59                	ja     12e6 <balancer_ingress+0x12e6>
    128d:	48 bf 00 40 8a 91 81 	movabs $0xffff8881918a4000,%rdi
    1294:	88 ff ff 
    1297:	48 8b 07             	mov    (%rdi),%rax
    129a:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
    129f:	ff 50 60             	call   *0x60(%rax)
    if (down_reals_map) {
    12a2:	48 85 c0             	test   %rax,%rax
    12a5:	74 3f                	je     12e6 <balancer_ingress+0x12e6>
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    12a7:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
    12ac:	48 8b 08             	mov    (%rax),%rcx
    12af:	48 89 c7             	mov    %rax,%rdi
    12b2:	ff 51 60             	call   *0x60(%rcx)
      if (down_real) {
    12b5:	48 85 c0             	test   %rax,%rax
    12b8:	74 2c                	je     12e6 <balancer_ingress+0x12e6>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    12ba:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    12c1:	88 ff ff 
    12c4:	48 8b 80 78 11 00 00 	mov    0x1178(%rax),%rax
    12cb:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    12d2:	65 bb 
        if (stats_data) {
    12d4:	48 85 c0             	test   %rax,%rax
    12d7:	0f 84 81 01 00 00    	je     145e <balancer_ingress+0x145e>
          stats_data->v1 += 1;
    12dd:	48 83 00 01          	addq   $0x1,(%rax)
    12e1:	e9 78 01 00 00       	jmp    145e <balancer_ingress+0x145e>
    if (!dst) {
    12e6:	4d 85 f6             	test   %r14,%r14
    12e9:	0f 84 6f 01 00 00    	je     145e <balancer_ingress+0x145e>
    12ef:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
    12f6:	00 
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    12f7:	81 f9 ff 03 00 00    	cmp    $0x3ff,%ecx
    12fd:	0f 87 44 0c 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    1303:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    130a:	88 ff ff 
    130d:	48 8b 8c c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rcx
    1314:	00 
    1315:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
    131c:	65 bb 
  if (!data_stats) {
    131e:	48 85 c9             	test   %rcx,%rcx
    1321:	0f 84 20 0c 00 00    	je     1f47 <balancer_ingress+0x1f47>
    1327:	0f b7 44 24 5c       	movzwl 0x5c(%rsp),%eax
    132c:	89 c3                	mov    %eax,%ebx
    132e:	66 c1 c3 08          	rol    $0x8,%bx
  data_stats->v1 += 1;
    1332:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    1336:	0f b7 c3             	movzwl %bx,%eax
    1339:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    133d:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    1341:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    1348:	0f 87 f9 0b 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    134e:	48 ba 00 f0 35 08 00 	movabs $0xffffc9000835f000,%rdx
    1355:	c9 ff ff 
    1358:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
    135f:	00 
    1360:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
    1367:	65 bb 
  if (!data_stats) {
    1369:	48 85 c9             	test   %rcx,%rcx
    136c:	0f 84 d5 0b 00 00    	je     1f47 <balancer_ingress+0x1f47>
  data_stats->v1 += 1;
    1372:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    1376:	48 01 41 08          	add    %rax,0x8(%rcx)
  pckt.flow.port16[0] = original_sport;
    137a:	66 44 89 64 24 30    	mov    %r12w,0x30(%rsp)
  if (dst->flags & F_IPV6) {
    1380:	41 f6 46 10 01       	testb  $0x1,0x10(%r14)
    1385:	0f 85 cd 02 00 00    	jne    1658 <balancer_ingress+0x1658>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    138b:	44 0f b7 7c 24 12    	movzwl 0x12(%rsp),%r15d
    1391:	48 c7 c0 60 39 be b7 	mov    $0xffffffffb7be3960,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1398:	4c 89 ef             	mov    %r13,%rdi
    139b:	be ec ff ff ff       	mov    $0xffffffec,%esi
    13a0:	ff d0                	call   *%rax
    13a2:	85 c0                	test   %eax,%eax
    13a4:	0f 85 9d 0b 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  data = (void*)(long)xdp->data;
    13aa:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    13ae:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  iph = data + sizeof(struct ethhdr);
    13b2:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    13b6:	48 39 ca             	cmp    %rcx,%rdx
    13b9:	0f 87 88 0b 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    13bf:	48 8d 50 22          	lea    0x22(%rax),%rdx
    13c3:	bd 01 00 00 00       	mov    $0x1,%ebp
    13c8:	48 39 ca             	cmp    %rcx,%rdx
    13cb:	0f 87 7b 0b 00 00    	ja     1f4c <balancer_ingress+0x1f4c>
    13d1:	66 41 c1 c4 08       	rol    $0x8,%r12w
    13d6:	45 31 e7             	xor    %r12d,%r15d
    13d9:	41 c1 e7 10          	shl    $0x10,%r15d
    13dd:	41 8d bf ac 10 00 00 	lea    0x10ac(%r15),%edi
    13e4:	48 b9 00 4c 5f 06 81 	movabs $0xffff8881065f4c00,%rcx
    13eb:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    13ee:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    13f5:	66 89 70 04          	mov    %si,0x4(%rax)
    13f9:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    13ff:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1401:	8b 48 14             	mov    0x14(%rax),%ecx
    1404:	89 48 06             	mov    %ecx,0x6(%rax)
    1407:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    140b:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    140f:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1415:	8a 54 24 3d          	mov    0x3d(%rsp),%dl
    1419:	41 8b 0e             	mov    (%r14),%ecx
    __u32 daddr,
    __u16 pkt_bytes,
    __u8 proto) {
  __u64 csum = 0;
  iph->version = 4;
  iph->ihl = 5;
    141c:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->frag_off = 0;
  iph->protocol = proto;
  iph->check = 0;
#ifdef COPY_INNER_PACKET_TOS
  iph->tos = tos;
    1420:	88 50 0f             	mov    %dl,0xf(%rax)
#else
  iph->tos = DEFAULT_TOS;
#endif
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1423:	83 c3 14             	add    $0x14,%ebx
    1426:	66 c1 c3 08          	rol    $0x8,%bx
    142a:	66 89 58 10          	mov    %bx,0x10(%rax)
  iph->id = 0;
    142e:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    1435:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    1438:	89 78 1a             	mov    %edi,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    143b:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    1441:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    1445:	0f b7 f3             	movzwl %bx,%esi
    1448:	0f b7 78 16          	movzwl 0x16(%rax),%edi
    144c:	41 c1 ef 10          	shr    $0x10,%r15d
    1450:	49 01 f7             	add    %rsi,%r15
    1453:	0f b7 f1             	movzwl %cx,%esi
    1456:	4c 01 fe             	add    %r15,%rsi
    1459:	e9 d1 07 00 00       	jmp    1c2f <balancer_ingress+0x1c2f>
      if (pckt.flow.proto == IPPROTO_TCP) {
    145e:	80 7c 24 34 06       	cmpb   $0x6,0x34(%rsp)
    1463:	75 34                	jne    1499 <balancer_ingress+0x1499>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1465:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    146c:	88 ff ff 
    146f:	48 8b 80 08 11 00 00 	mov    0x1108(%rax),%rax
    1476:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    147d:	65 bb 
        if (!lru_stats) {
    147f:	48 85 c0             	test   %rax,%rax
    1482:	0f 84 bf 0a 00 00    	je     1f47 <balancer_ingress+0x1f47>
        if (pckt.flags & F_SYN_SET) {
    1488:	8b 4c 24 3c          	mov    0x3c(%rsp),%ecx
    148c:	c1 e1 02             	shl    $0x2,%ecx
    148f:	f7 d1                	not    %ecx
    1491:	83 e1 08             	and    $0x8,%ecx
    1494:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
  struct real_pos_lru new_dst_lru = {};
    1499:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    14a0:	00 00 
    14a2:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    14a9:	00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    14ab:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    14b2:	88 ff ff 
    14b5:	48 8b a8 10 11 00 00 	mov    0x1110(%rax),%rbp
    14bc:	65 48 03 2c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbp
    14c3:	65 bb 
    14c5:	b3 01                	mov    $0x1,%bl
  if (!conn_rate_stats) {
    14c7:	48 85 ed             	test   %rbp,%rbp
    14ca:	74 27                	je     14f3 <balancer_ingress+0x14f3>
    14cc:	48 c7 c0 60 23 a5 b5 	mov    $0xffffffffb5a52360,%rax
  *cur_time = bpf_ktime_get_ns();
    14d3:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    14d5:	48 89 c1             	mov    %rax,%rcx
    14d8:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    14dc:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    14e3:	72 12                	jb     14f7 <balancer_ingress+0x14f7>
    conn_rate_stats->v1 = 1;
    14e5:	48 c7 45 00 01 00 00 	movq   $0x1,0x0(%rbp)
    14ec:	00 
    conn_rate_stats->v2 = *cur_time;
    14ed:	48 89 45 08          	mov    %rax,0x8(%rbp)
    14f1:	eb 19                	jmp    150c <balancer_ingress+0x150c>
    14f3:	31 c0                	xor    %eax,%eax
    14f5:	eb 17                	jmp    150e <balancer_ingress+0x150e>
    conn_rate_stats->v1 += 1;
    14f7:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
    14fb:	48 83 c1 01          	add    $0x1,%rcx
    14ff:	48 89 4d 00          	mov    %rcx,0x0(%rbp)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1503:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    150a:	77 02                	ja     150e <balancer_ingress+0x150e>
    150c:	31 db                	xor    %ebx,%ebx
    150e:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1513:	f6 01 08             	testb  $0x8,(%rcx)
    1516:	75 0b                	jne    1523 <balancer_ingress+0x1523>
    1518:	ba f7 c0 ad e0       	mov    $0xe0adc0f7,%edx
    151d:	03 54 24 10          	add    0x10(%rsp),%edx
    1521:	eb 21                	jmp    1544 <balancer_ingress+0x1544>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1523:	0f b7 4c 24 32       	movzwl 0x32(%rsp),%ecx
    1528:	66 89 4c 24 30       	mov    %cx,0x30(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    152d:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    1534:	00 00 
    1536:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
    153d:	00 00 
    153f:	ba f7 c0 ad e0       	mov    $0xe0adc0f7,%edx
    1544:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  return c;
}

static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval) {
  a += initval;
  b += initval;
    1549:	03 74 24 30          	add    0x30(%rsp),%esi
  c += initval;
  __jhash_final(a, b, c);
    154d:	89 f1                	mov    %esi,%ecx
    154f:	81 f1 f7 c0 ad e0    	xor    $0xe0adc0f7,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1555:	89 f7                	mov    %esi,%edi
    1557:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    155a:	29 f9                	sub    %edi,%ecx
    155c:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    155e:	89 cf                	mov    %ecx,%edi
    1560:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    1563:	29 fa                	sub    %edi,%edx
    1565:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1567:	89 d7                	mov    %edx,%edi
    1569:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    156c:	29 fe                	sub    %edi,%esi
    156e:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1570:	89 f7                	mov    %esi,%edi
    1572:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    1575:	29 f9                	sub    %edi,%ecx
    1577:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1579:	89 cf                	mov    %ecx,%edi
    157b:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    157e:	29 fa                	sub    %edi,%edx
    1580:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1582:	c1 c2 0e             	rol    $0xe,%edx
  __jhash_final(a, b, c);
    1585:	29 d6                	sub    %edx,%esi
    1587:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1589:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    158c:	29 f1                	sub    %esi,%ecx
    158e:	ba 01 00 ff ff       	mov    $0xffff0001,%edx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1593:	48 0f af d1          	imul   %rcx,%rdx
    1597:	48 c1 ea 30          	shr    $0x30,%rdx
    159b:	89 d6                	mov    %edx,%esi
    159d:	c1 e6 10             	shl    $0x10,%esi
    15a0:	09 d6                	or     %edx,%esi
    15a2:	29 f1                	sub    %esi,%ecx
    15a4:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    15a9:	8b 72 04             	mov    0x4(%rdx),%esi
    15ac:	89 f2                	mov    %esi,%edx
    15ae:	c1 e2 10             	shl    $0x10,%edx
    15b1:	01 f2                	add    %esi,%edx
    15b3:	01 ca                	add    %ecx,%edx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15b5:	81 fa ff 01 00 02    	cmp    $0x20001ff,%edx
    if (!real_pos) {
    15bb:	0f 87 86 09 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15c1:	89 d1                	mov    %edx,%ecx
    15c3:	48 ba 00 c0 5e 08 00 	movabs $0xffffc900085ec000,%rdx
    15ca:	c9 ff ff 
    key = *real_pos;
    15cd:	8b ac ca 00 01 00 00 	mov    0x100(%rdx,%rcx,8),%ebp
    15d4:	48 85 ed             	test   %rbp,%rbp
    if (key == 0) {
    15d7:	74 34                	je     160d <balancer_ingress+0x160d>
  pckt->real_index = key;
    15d9:	89 6c 24 38          	mov    %ebp,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    15dd:	81 fd 00 10 00 00    	cmp    $0x1000,%ebp
  if (!(*real)) {
    15e3:	72 50                	jb     1635 <balancer_ingress+0x1635>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    15e5:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    15ec:	88 ff ff 
    15ef:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    15f6:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    15fd:	65 bb 
  if (!ch_drop_stats) {
    15ff:	48 85 c0             	test   %rax,%rax
    1602:	0f 85 3b 09 00 00    	jne    1f43 <balancer_ingress+0x1f43>
    1608:	e9 3a 09 00 00       	jmp    1f47 <balancer_ingress+0x1f47>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    160d:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    1614:	88 ff ff 
    1617:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    161e:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    1625:	65 bb 
  if (!ch_drop_stats) {
    1627:	48 85 c0             	test   %rax,%rax
    162a:	0f 85 0f 09 00 00    	jne    1f3f <balancer_ingress+0x1f3f>
    1630:	e9 12 09 00 00       	jmp    1f47 <balancer_ingress+0x1f47>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1635:	48 83 7c 24 50 00    	cmpq   $0x0,0x50(%rsp)
    163b:	74 14                	je     1651 <balancer_ingress+0x1651>
    163d:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    1642:	8a 09                	mov    (%rcx),%cl
    1644:	80 e1 02             	and    $0x2,%cl
    1647:	d0 e9                	shr    %cl
    1649:	08 cb                	or     %cl,%bl
    164b:	0f 84 39 01 00 00    	je     178a <balancer_ingress+0x178a>
    1651:	89 e8                	mov    %ebp,%eax
    1653:	e9 5d 01 00 00       	jmp    17b5 <balancer_ingress+0x17b5>
    1658:	48 c7 c0 60 39 be b7 	mov    $0xffffffffb7be3960,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    165f:	4c 89 ef             	mov    %r13,%rdi
    1662:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1667:	ff d0                	call   *%rax
    1669:	85 c0                	test   %eax,%eax
    166b:	0f 85 d6 08 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  data = (void*)(long)xdp->data;
    1671:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1675:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1679:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    167d:	48 39 ca             	cmp    %rcx,%rdx
    1680:	0f 87 c1 08 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    1686:	48 8d 50 36          	lea    0x36(%rax),%rdx
    168a:	bd 01 00 00 00       	mov    $0x1,%ebp
    168f:	48 39 ca             	cmp    %rcx,%rdx
    1692:	0f b7 74 24 5c       	movzwl 0x5c(%rsp),%esi
    1697:	0f 87 af 08 00 00    	ja     1f4c <balancer_ingress+0x1f4c>
    169d:	48 b9 00 4c 5f 06 81 	movabs $0xffff8881065f4c00,%rcx
    16a4:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    16a7:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    16ae:	66 89 50 04          	mov    %dx,0x4(%rax)
    16b2:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    16b8:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    16ba:	8b 48 28             	mov    0x28(%rax),%ecx
    16bd:	89 48 06             	mov    %ecx,0x6(%rax)
    16c0:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    16c4:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    16c8:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    16ce:	0f b7 4c 24 30       	movzwl 0x30(%rsp),%ecx
  saddr[3] = src ^ port;
    16d3:	33 4c 24 10          	xor    0x10(%rsp),%ecx
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    16d7:	8a 5c 24 3d          	mov    0x3d(%rsp),%bl
    __u32* saddr,
    __u32* daddr,
    __u16 payload_len,
    __u8 proto) {
  ip6h->version = 6;
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    16db:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#ifdef COPY_INNER_PACKET_TOS
  ip6h->priority = (tc & 0xF0) >> 4;
    16e1:	89 da                	mov    %ebx,%edx
    16e3:	c0 ea 04             	shr    $0x4,%dl
    16e6:	80 ca 60             	or     $0x60,%dl
    16e9:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    16ec:	c0 e3 04             	shl    $0x4,%bl
    16ef:	88 58 0f             	mov    %bl,0xf(%rax)
#else
  ip6h->priority = DEFAULT_TOS;
#endif
  ip6h->nexthdr = proto;
    16f2:	66 c7 40 14 04 40    	movw   $0x4004,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    16f8:	66 89 70 12          	mov    %si,0x12(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    16fc:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    1703:	00 
    1704:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    170b:	89 48 22             	mov    %ecx,0x22(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    170e:	49 8b 0e             	mov    (%r14),%rcx
    1711:	49 8b 56 08          	mov    0x8(%r14),%rdx
    1715:	e9 20 09 00 00       	jmp    203a <balancer_ingress+0x203a>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    171a:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    171e:	48 c1 e1 18          	shl    $0x18,%rcx
    1722:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    1726:	48 c1 e2 10          	shl    $0x10,%rdx
    172a:	48 09 ca             	or     %rcx,%rdx
    172d:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    1731:	48 c1 e1 08          	shl    $0x8,%rcx
    1735:	48 09 d1             	or     %rdx,%rcx
    1738:	8a 40 04             	mov    0x4(%rax),%al
    173b:	b2 03                	mov    $0x3,%dl
    173d:	eb 18                	jmp    1757 <balancer_ingress+0x1757>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    173f:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    1743:	48 c1 e2 10          	shl    $0x10,%rdx
    1747:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    174b:	48 c1 e1 08          	shl    $0x8,%rcx
    174f:	48 09 d1             	or     %rdx,%rcx
    1752:	8a 40 03             	mov    0x3(%rax),%al
    1755:	b2 02                	mov    $0x2,%dl
    1757:	0f b6 c0             	movzbl %al,%eax
    175a:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    175d:	85 c0                	test   %eax,%eax
    175f:	0f 8e a6 01 00 00    	jle    190b <balancer_ingress+0x190b>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1765:	80 fa 01             	cmp    $0x1,%dl
    1768:	0f 84 f9 00 00 00    	je     1867 <balancer_ingress+0x1867>
    176e:	80 fa 03             	cmp    $0x3,%dl
    1771:	0f 84 f7 00 00 00    	je     186e <balancer_ingress+0x186e>
    1777:	80 fa 02             	cmp    $0x2,%dl
    177a:	0f 85 f5 00 00 00    	jne    1875 <balancer_ingress+0x1875>
    1780:	b9 40 00 00 00       	mov    $0x40,%ecx
    1785:	e9 f0 00 00 00       	jmp    187a <balancer_ingress+0x187a>
    if (pckt->flow.proto == IPPROTO_UDP) {
    178a:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    178f:	75 05                	jne    1796 <balancer_ingress+0x1796>
      new_dst_lru.atime = cur_time;
    1791:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    new_dst_lru.pos = key;
    1796:	89 6c 24 40          	mov    %ebp,0x40(%rsp)
    179a:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
		void*,
		(void* map, void* key),
		(void*, void*),
		(map, key))
BPF_MAP_OPS_INLINE(map_update_elem,,
    179f:	48 8b 07             	mov    (%rdi),%rax
    17a2:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    17a7:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    17ac:	31 c9                	xor    %ecx,%ecx
    17ae:	ff 50 68             	call   *0x68(%rax)
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    17b1:	8b 44 24 38          	mov    0x38(%rsp),%eax
    17b5:	48 bf 00 54 5f 06 81 	movabs $0xffff8881065f5400,%rdi
    17bc:	88 ff ff 
    17bf:	8b 9f 00 01 00 00    	mov    0x100(%rdi),%ebx
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17c5:	0f b7 97 10 01 00 00 	movzwl 0x110(%rdi),%edx
    17cc:	0f b7 74 24 70       	movzwl 0x70(%rsp),%esi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17d1:	8a 4c 24 72          	mov    0x72(%rsp),%cl
    17d5:	88 8f 12 01 00 00    	mov    %cl,0x112(%rdi)
    17db:	3b 5c 24 60          	cmp    0x60(%rsp),%ebx
  bool vip_match = address_match && port_match && proto_match;
    17df:	75 3d                	jne    181e <balancer_ingress+0x181e>
    17e1:	66 39 f2             	cmp    %si,%dx
    17e4:	75 38                	jne    181e <balancer_ingress+0x181e>
    17e6:	84 c9                	test   %cl,%cl
    17e8:	74 34                	je     181e <balancer_ingress+0x181e>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17ea:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    17ef:	0f 87 52 07 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    17f5:	89 c0                	mov    %eax,%eax
    17f7:	48 b9 00 30 3c 08 00 	movabs $0xffffc900083c3000,%rcx
    17fe:	c9 ff ff 
    1801:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    1808:	00 
    1809:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    1810:	65 bb 
    if (!lru_miss_stat) {
    1812:	48 85 c0             	test   %rax,%rax
    1815:	0f 84 2c 07 00 00    	je     1f47 <balancer_ingress+0x1f47>
    *lru_miss_stat += 1;
    181b:	83 00 01             	addl   $0x1,(%rax)
    181e:	48 8d 04 6d 00 00 00 	lea    0x0(,%rbp,2),%rax
    1825:	00 
    1826:	48 01 e8             	add    %rbp,%rax
    1829:	48 b9 00 30 3f 08 00 	movabs $0xffffc900083f3000,%rcx
    1830:	c9 ff ff 
    1833:	4c 8d 34 c1          	lea    (%rcx,%rax,8),%r14
    1837:	49 81 c6 00 01 00 00 	add    $0x100,%r14
      data_stats->v2 += 1;
    183e:	49 83 47 08 01       	addq   $0x1,0x8(%r15)
    1843:	e9 a7 fa ff ff       	jmp    12ef <balancer_ingress+0x12ef>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1848:	80 7b 05 08          	cmpb   $0x8,0x5(%rbx)
    184c:	0f 82 71 f7 ff ff    	jb     fc3 <balancer_ingress+0xfc3>
    1852:	48 83 c3 06          	add    $0x6,%rbx
    1856:	48 89 d8             	mov    %rbx,%rax
  if (!connId) {
    1859:	48 85 c0             	test   %rax,%rax
    185c:	0f 85 8e f8 ff ff    	jne    10f0 <balancer_ingress+0x10f0>
    1862:	e9 5c f7 ff ff       	jmp    fc3 <balancer_ingress+0xfc3>
    1867:	b9 38 00 00 00       	mov    $0x38,%ecx
    186c:	eb 0c                	jmp    187a <balancer_ingress+0x187a>
    186e:	b9 48 00 00 00       	mov    $0x48,%ecx
    1873:	eb 05                	jmp    187a <balancer_ingress+0x187a>
    1875:	b9 30 00 00 00       	mov    $0x30,%ecx
    187a:	48 83 44 0d 00 01    	addq   $0x1,0x0(%rbp,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1880:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    1885:	77 79                	ja     1900 <balancer_ingress+0x1900>
    1887:	48 b9 00 b0 41 22 00 	movabs $0xffffc9002241b000,%rcx
    188e:	c9 ff ff 
          key = *real_pos;
    1891:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    1898:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    189b:	74 63                	je     1900 <balancer_ingress+0x1900>
            pckt.real_index = key;
    189d:	89 4c 24 38          	mov    %ecx,0x38(%rsp)
    18a1:	31 d2                	xor    %edx,%edx
            dst = bpf_map_lookup_elem(&reals, &key);
    18a3:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    18a9:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    18ad:	48 b9 00 30 3f 08 00 	movabs $0xffffc900083f3000,%rcx
    18b4:	c9 ff ff 
    18b7:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    18be:	00 
    18bf:	48 0f 42 d0          	cmovb  %rax,%rdx
            if (!dst) {
    18c3:	48 85 d2             	test   %rdx,%rdx
    18c6:	0f 84 cc 09 00 00    	je     2298 <balancer_ingress+0x2298>
    18cc:	48 89 d3             	mov    %rdx,%rbx
    18cf:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    18d4:	48 8b 07             	mov    (%rdi),%rax
    18d7:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    18dc:	ff 50 60             	call   *0x60(%rax)
  if (dst_lru) {
    18df:	48 85 c0             	test   %rax,%rax
    18e2:	0f 84 b8 08 00 00    	je     21a0 <balancer_ingress+0x21a0>
    if (dst_lru->pos == pckt->real_index) {
    18e8:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    18ec:	39 08                	cmp    %ecx,(%rax)
    18ee:	0f 85 ae 09 00 00    	jne    22a2 <balancer_ingress+0x22a2>
              quic_packets_stats->dst_match_in_lru += 1;
    18f4:	48 89 e8             	mov    %rbp,%rax
    18f7:	48 83 c0 50          	add    $0x50,%rax
    18fb:	e9 22 0a 00 00       	jmp    2322 <balancer_ingress+0x2322>
    1900:	48 83 45 10 01       	addq   $0x1,0x10(%rbp)
    1905:	48 98                	cltq
    1907:	48 89 45 18          	mov    %rax,0x18(%rbp)
    190b:	48 ba 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rdx
    1912:	88 ff ff 
    1915:	4c 89 fe             	mov    %r15,%rsi
    1918:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
  original_sport = pckt.flow.port16[0];
    191d:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
    1922:	89 84 24 80 00 00 00 	mov    %eax,0x80(%rsp)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1929:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    192e:	75 52                	jne    1982 <balancer_ingress+0x1982>
        !(vip_info->flags & F_LRU_BYPASS)) {
    1930:	f6 07 02             	testb  $0x2,(%rdi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1933:	75 4d                	jne    1982 <balancer_ingress+0x1982>
    1935:	48 89 7c 24 50       	mov    %rdi,0x50(%rsp)
    193a:	49 89 f7             	mov    %rsi,%r15
    193d:	49 89 d4             	mov    %rdx,%r12
    1940:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    1945:	48 8b 07             	mov    (%rdi),%rax
    1948:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    194d:	ff 50 60             	call   *0x60(%rax)
  if (!dst_lru) {
    1950:	48 85 c0             	test   %rax,%rax
    1953:	74 29                	je     197e <balancer_ingress+0x197e>
    1955:	48 89 c5             	mov    %rax,%rbp
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1958:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    195d:	75 2b                	jne    198a <balancer_ingress+0x198a>
    195f:	48 c7 c0 60 23 a5 b5 	mov    $0xffffffffb5a52360,%rax
    cur_time = bpf_ktime_get_ns();
    1966:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1968:	48 89 c1             	mov    %rax,%rcx
    196b:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    196f:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    1976:	00 00 00 
    1979:	48 39 d1             	cmp    %rdx,%rcx
    197c:	76 08                	jbe    1986 <balancer_ingress+0x1986>
    197e:	31 db                	xor    %ebx,%ebx
    1980:	eb 31                	jmp    19b3 <balancer_ingress+0x19b3>
    1982:	31 db                	xor    %ebx,%ebx
    1984:	eb 38                	jmp    19be <balancer_ingress+0x19be>
    dst_lru->atime = cur_time;
    1986:	48 89 45 08          	mov    %rax,0x8(%rbp)
  key = dst_lru->pos;
    198a:	8b 45 00             	mov    0x0(%rbp),%eax
    198d:	31 db                	xor    %ebx,%ebx
    198f:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    1995:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1999:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    199d:	48 b9 00 30 3f 08 00 	movabs $0xffffc900083f3000,%rcx
    19a4:	c9 ff ff 
    19a7:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    19ae:	00 
    19af:	48 0f 42 d8          	cmovb  %rax,%rbx
    19b3:	4c 89 e2             	mov    %r12,%rdx
    19b6:	4c 89 fe             	mov    %r15,%rsi
    19b9:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    19be:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    19c3:	0f 85 f7 00 00 00    	jne    1ac0 <balancer_ingress+0x1ac0>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    19c9:	f6 47 01 02          	testb  $0x2,0x1(%rdi)
    19cd:	0f 84 ed 00 00 00    	je     1ac0 <balancer_ingress+0x1ac0>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    19d3:	48 8b aa 10 11 00 00 	mov    0x1110(%rdx),%rbp
    19da:	65 48 03 2c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbp
    19e1:	65 bb 
  if (!conn_rate_stats) {
    19e3:	48 85 ed             	test   %rbp,%rbp
    19e6:	0f 84 d4 00 00 00    	je     1ac0 <balancer_ingress+0x1ac0>
    19ec:	48 89 5c 24 50       	mov    %rbx,0x50(%rsp)
    19f1:	49 89 fc             	mov    %rdi,%r12
    19f4:	49 89 f7             	mov    %rsi,%r15
    19f7:	48 c7 c0 60 23 a5 b5 	mov    $0xffffffffb5a52360,%rax
  *cur_time = bpf_ktime_get_ns();
    19fe:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1a00:	48 89 c1             	mov    %rax,%rcx
    1a03:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    1a07:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1a0e:	72 0e                	jb     1a1e <balancer_ingress+0x1a1e>
    conn_rate_stats->v1 = 1;
    1a10:	48 c7 45 00 01 00 00 	movq   $0x1,0x0(%rbp)
    1a17:	00 
    conn_rate_stats->v2 = *cur_time;
    1a18:	48 89 45 08          	mov    %rax,0x8(%rbp)
    1a1c:	eb 29                	jmp    1a47 <balancer_ingress+0x1a47>
    conn_rate_stats->v1 += 1;
    1a1e:	48 8b 45 00          	mov    0x0(%rbp),%rax
    1a22:	48 83 c0 01          	add    $0x1,%rax
    1a26:	48 89 45 00          	mov    %rax,0x0(%rbp)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1a2a:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    1a30:	48 ba 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rdx
    1a37:	88 ff ff 
    1a3a:	4c 89 fe             	mov    %r15,%rsi
    1a3d:	4c 89 e7             	mov    %r12,%rdi
    1a40:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
    1a45:	77 79                	ja     1ac0 <balancer_ingress+0x1ac0>
    1a47:	48 bf 00 40 8a 91 81 	movabs $0xffff8881918a4000,%rdi
    1a4e:	88 ff ff 
    1a51:	48 8b 07             	mov    (%rdi),%rax
    1a54:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
    1a59:	ff 50 60             	call   *0x60(%rax)
    1a5c:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
    1a61:	4c 89 e7             	mov    %r12,%rdi
    1a64:	4c 89 fe             	mov    %r15,%rsi
    1a67:	48 ba 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rdx
    1a6e:	88 ff ff 
    if (down_reals_map) {
    1a71:	48 85 c0             	test   %rax,%rax
    1a74:	74 4a                	je     1ac0 <balancer_ingress+0x1ac0>
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1a76:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
    1a7b:	48 8b 08             	mov    (%rax),%rcx
    1a7e:	48 89 c7             	mov    %rax,%rdi
    1a81:	ff 51 60             	call   *0x60(%rcx)
    1a84:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
    1a89:	4c 89 e7             	mov    %r12,%rdi
    1a8c:	4c 89 fe             	mov    %r15,%rsi
    1a8f:	48 ba 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rdx
    1a96:	88 ff ff 
      if (down_real) {
    1a99:	48 85 c0             	test   %rax,%rax
    1a9c:	74 22                	je     1ac0 <balancer_ingress+0x1ac0>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1a9e:	48 8b 82 78 11 00 00 	mov    0x1178(%rdx),%rax
    1aa5:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    1aac:	65 bb 
        if (stats_data) {
    1aae:	48 85 c0             	test   %rax,%rax
    1ab1:	0f 84 f5 01 00 00    	je     1cac <balancer_ingress+0x1cac>
          stats_data->v1 += 1;
    1ab7:	48 83 00 01          	addq   $0x1,(%rax)
    1abb:	e9 ec 01 00 00       	jmp    1cac <balancer_ingress+0x1cac>
    if (!dst) {
    1ac0:	48 85 db             	test   %rbx,%rbx
    1ac3:	0f 84 e3 01 00 00    	je     1cac <balancer_ingress+0x1cac>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1ac9:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
    1acf:	0f 87 72 04 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    1ad5:	48 8b 8c f2 00 01 00 	mov    0x100(%rdx,%rsi,8),%rcx
    1adc:	00 
    1add:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
    1ae4:	65 bb 
  if (!data_stats) {
    1ae6:	48 85 c9             	test   %rcx,%rcx
    1ae9:	0f 84 58 04 00 00    	je     1f47 <balancer_ingress+0x1f47>
    1aef:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
    1af3:	66 c1 c0 08          	rol    $0x8,%ax
  data_stats->v1 += 1;
    1af7:	48 83 01 01          	addq   $0x1,(%rcx)
    1afb:	41 89 c7             	mov    %eax,%r15d
  data_stats->v2 += pkt_bytes;
    1afe:	0f b7 c0             	movzwl %ax,%eax
    1b01:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1b05:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    1b09:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    1b10:	0f 87 31 04 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    1b16:	48 ba 00 f0 35 08 00 	movabs $0xffffc9000835f000,%rdx
    1b1d:	c9 ff ff 
    1b20:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
    1b27:	00 
    1b28:	65 48 03 0c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rcx
    1b2f:	65 bb 
  if (!data_stats) {
    1b31:	48 85 c9             	test   %rcx,%rcx
    1b34:	0f 84 0d 04 00 00    	je     1f47 <balancer_ingress+0x1f47>
  data_stats->v1 += 1;
    1b3a:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    1b3e:	48 01 41 08          	add    %rax,0x8(%rcx)
    1b42:	8b 84 24 80 00 00 00 	mov    0x80(%rsp),%eax
  pckt.flow.port16[0] = original_sport;
    1b49:	66 89 44 24 30       	mov    %ax,0x30(%rsp)
  if (dst->flags & F_IPV6) {
    1b4e:	f6 43 10 01          	testb  $0x1,0x10(%rbx)
    1b52:	0f 85 2c 04 00 00    	jne    1f84 <balancer_ingress+0x1f84>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1b58:	44 0f b7 74 24 12    	movzwl 0x12(%rsp),%r14d
    1b5e:	48 c7 c0 60 39 be b7 	mov    $0xffffffffb7be3960,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1b65:	4c 89 ef             	mov    %r13,%rdi
    1b68:	be ec ff ff ff       	mov    $0xffffffec,%esi
    1b6d:	ff d0                	call   *%rax
    1b6f:	85 c0                	test   %eax,%eax
    1b71:	0f 85 d0 03 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  data = (void*)(long)xdp->data;
    1b77:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1b7b:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  iph = data + sizeof(struct ethhdr);
    1b7f:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1b83:	48 39 ca             	cmp    %rcx,%rdx
    1b86:	0f 87 bb 03 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    1b8c:	48 8d 50 22          	lea    0x22(%rax),%rdx
    1b90:	bd 01 00 00 00       	mov    $0x1,%ebp
    1b95:	48 39 ca             	cmp    %rcx,%rdx
    1b98:	0f 87 ae 03 00 00    	ja     1f4c <balancer_ingress+0x1f4c>
    1b9e:	8b 8c 24 80 00 00 00 	mov    0x80(%rsp),%ecx
    1ba5:	66 c1 c1 08          	rol    $0x8,%cx
    1ba9:	41 31 ce             	xor    %ecx,%r14d
    1bac:	41 c1 e6 10          	shl    $0x10,%r14d
    1bb0:	41 8d be ac 10 00 00 	lea    0x10ac(%r14),%edi
    1bb7:	48 b9 00 4c 5f 06 81 	movabs $0xffff8881065f4c00,%rcx
    1bbe:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1bc1:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    1bc8:	66 89 70 04          	mov    %si,0x4(%rax)
    1bcc:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1bd2:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1bd4:	8b 48 14             	mov    0x14(%rax),%ecx
    1bd7:	89 48 06             	mov    %ecx,0x6(%rax)
    1bda:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    1bde:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    1be2:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1be8:	8a 54 24 3d          	mov    0x3d(%rsp),%dl
    1bec:	8b 0b                	mov    (%rbx),%ecx
  iph->ihl = 5;
    1bee:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->tos = tos;
    1bf2:	88 50 0f             	mov    %dl,0xf(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1bf5:	41 83 c7 14          	add    $0x14,%r15d
    1bf9:	66 41 c1 c7 08       	rol    $0x8,%r15w
    1bfe:	66 44 89 78 10       	mov    %r15w,0x10(%rax)
  iph->id = 0;
    1c03:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    1c0a:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    1c0d:	89 78 1a             	mov    %edi,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    1c10:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    1c16:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    1c1a:	41 0f b7 f7          	movzwl %r15w,%esi
    1c1e:	0f b7 78 16          	movzwl 0x16(%rax),%edi
    1c22:	41 c1 ee 10          	shr    $0x10,%r14d
    1c26:	49 01 f6             	add    %rsi,%r14
    1c29:	0f b7 f1             	movzwl %cx,%esi
    1c2c:	4c 01 f6             	add    %r14,%rsi
    1c2f:	48 c1 e9 10          	shr    $0x10,%rcx
    1c33:	48 01 f1             	add    %rsi,%rcx
    1c36:	48 01 d1             	add    %rdx,%rcx
    1c39:	48 01 f9             	add    %rdi,%rcx
    1c3c:	48 81 c1 ac 10 00 00 	add    $0x10ac,%rcx
    1c43:	48 89 ca             	mov    %rcx,%rdx
    1c46:	48 c1 ea 10          	shr    $0x10,%rdx
    1c4a:	0f b7 f1             	movzwl %cx,%esi
    1c4d:	48 01 d6             	add    %rdx,%rsi
    1c50:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
    1c57:	48 0f 42 f1          	cmovb  %rcx,%rsi
    1c5b:	48 89 f1             	mov    %rsi,%rcx
    1c5e:	48 c1 e9 10          	shr    $0x10,%rcx
    1c62:	0f b7 d6             	movzwl %si,%edx
    1c65:	48 01 ca             	add    %rcx,%rdx
    1c68:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    1c6f:	48 0f 42 d6          	cmovb  %rsi,%rdx
    1c73:	48 89 d1             	mov    %rdx,%rcx
    1c76:	48 c1 e9 10          	shr    $0x10,%rcx
    1c7a:	0f b7 f2             	movzwl %dx,%esi
    1c7d:	48 01 ce             	add    %rcx,%rsi
    1c80:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
    1c87:	48 0f 42 f2          	cmovb  %rdx,%rsi
    1c8b:	89 f1                	mov    %esi,%ecx
    1c8d:	c1 e9 10             	shr    $0x10,%ecx
    1c90:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    1c97:	ba 00 00 01 00       	mov    $0x10000,%edx
    1c9c:	0f 43 d1             	cmovae %ecx,%edx
    1c9f:	01 f2                	add    %esi,%edx
    1ca1:	f7 d2                	not    %edx
    1ca3:	66 89 50 18          	mov    %dx,0x18(%rax)
    1ca7:	e9 2a e7 ff ff       	jmp    3d6 <balancer_ingress+0x3d6>
      if (pckt.flow.proto == IPPROTO_TCP) {
    1cac:	80 7c 24 34 06       	cmpb   $0x6,0x34(%rsp)
    1cb1:	75 2a                	jne    1cdd <balancer_ingress+0x1cdd>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1cb3:	48 8b 82 08 11 00 00 	mov    0x1108(%rdx),%rax
    1cba:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    1cc1:	65 bb 
        if (!lru_stats) {
    1cc3:	48 85 c0             	test   %rax,%rax
    1cc6:	0f 84 7b 02 00 00    	je     1f47 <balancer_ingress+0x1f47>
        if (pckt.flags & F_SYN_SET) {
    1ccc:	8b 4c 24 3c          	mov    0x3c(%rsp),%ecx
    1cd0:	c1 e1 02             	shl    $0x2,%ecx
    1cd3:	f7 d1                	not    %ecx
    1cd5:	83 e1 08             	and    $0x8,%ecx
    1cd8:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
    1cdd:	48 89 74 24 50       	mov    %rsi,0x50(%rsp)
  struct real_pos_lru new_dst_lru = {};
    1ce2:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    1ce9:	00 00 
    1ceb:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    1cf2:	00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1cf4:	48 8b 9a 10 11 00 00 	mov    0x1110(%rdx),%rbx
    1cfb:	65 48 03 1c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbx
    1d02:	65 bb 
    1d04:	41 b7 01             	mov    $0x1,%r15b
  if (!conn_rate_stats) {
    1d07:	48 85 db             	test   %rbx,%rbx
    1d0a:	74 29                	je     1d35 <balancer_ingress+0x1d35>
    1d0c:	48 89 fd             	mov    %rdi,%rbp
    1d0f:	48 c7 c0 60 23 a5 b5 	mov    $0xffffffffb5a52360,%rax
  *cur_time = bpf_ktime_get_ns();
    1d16:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1d18:	48 89 c1             	mov    %rax,%rcx
    1d1b:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1d1f:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1d26:	72 11                	jb     1d39 <balancer_ingress+0x1d39>
    conn_rate_stats->v1 = 1;
    1d28:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1d2f:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1d33:	eb 17                	jmp    1d4c <balancer_ingress+0x1d4c>
    1d35:	31 c0                	xor    %eax,%eax
    1d37:	eb 19                	jmp    1d52 <balancer_ingress+0x1d52>
    conn_rate_stats->v1 += 1;
    1d39:	48 8b 0b             	mov    (%rbx),%rcx
    1d3c:	48 83 c1 01          	add    $0x1,%rcx
    1d40:	48 89 0b             	mov    %rcx,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1d43:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    1d4a:	77 03                	ja     1d4f <balancer_ingress+0x1d4f>
    1d4c:	45 31 ff             	xor    %r15d,%r15d
    1d4f:	48 89 ef             	mov    %rbp,%rdi
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1d52:	f6 07 08             	testb  $0x8,(%rdi)
    1d55:	75 25                	jne    1d7c <balancer_ingress+0x1d7c>
    1d57:	49 89 fc             	mov    %rdi,%r12
    1d5a:	8b 54 24 10          	mov    0x10(%rsp),%edx
    b += *(u32*)(k + 4);
    1d5e:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
    c += *(u32*)(k + 8);
    1d62:	8b 74 24 18          	mov    0x18(%rsp),%esi
      a += (u32)k[3] << 24;
    1d66:	40 8a 6c 24 1f       	mov    0x1f(%rsp),%bpl
      a += (u32)k[2] << 16;
    1d6b:	44 8a 54 24 1e       	mov    0x1e(%rsp),%r10b
      a += (u32)k[1] << 8;
    1d70:	44 8a 4c 24 1d       	mov    0x1d(%rsp),%r9b
      a += k[0];
    1d75:	44 8a 44 24 1c       	mov    0x1c(%rsp),%r8b
    1d7a:	eb 30                	jmp    1dac <balancer_ingress+0x1dac>
    1d7c:	49 89 fc             	mov    %rdi,%r12
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1d7f:	0f b7 4c 24 32       	movzwl 0x32(%rsp),%ecx
    1d84:	66 89 4c 24 30       	mov    %cx,0x30(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    1d89:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    1d90:	00 00 
    1d92:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
    1d99:	00 00 
    1d9b:	45 31 c0             	xor    %r8d,%r8d
    1d9e:	45 31 c9             	xor    %r9d,%r9d
    1da1:	45 31 d2             	xor    %r10d,%r10d
    1da4:	31 ed                	xor    %ebp,%ebp
    1da6:	31 f6                	xor    %esi,%esi
    1da8:	31 c9                	xor    %ecx,%ecx
    1daa:	31 d2                	xor    %edx,%edx
    c += *(u32*)(k + 8);
    1dac:	8d 9e ff c0 ad de    	lea    -0x21523f01(%rsi),%ebx
    __jhash_mix(a, b, c);
    1db2:	29 f2                	sub    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1db4:	c1 c3 04             	rol    $0x4,%ebx
    __jhash_mix(a, b, c);
    1db7:	31 d3                	xor    %edx,%ebx
    b += *(u32*)(k + 4);
    1db9:	89 ca                	mov    %ecx,%edx
    1dbb:	81 c2 ff c0 ad de    	add    $0xdeadc0ff,%edx
    __jhash_mix(a, b, c);
    1dc1:	01 ce                	add    %ecx,%esi
    1dc3:	81 c6 fe 81 5b bd    	add    $0xbd5b81fe,%esi
    1dc9:	29 da                	sub    %ebx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1dcb:	89 df                	mov    %ebx,%edi
    1dcd:	c1 c7 06             	rol    $0x6,%edi
    __jhash_mix(a, b, c);
    1dd0:	31 d7                	xor    %edx,%edi
    1dd2:	01 f3                	add    %esi,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1dd4:	89 f9                	mov    %edi,%ecx
    1dd6:	c1 c1 08             	rol    $0x8,%ecx
    __jhash_mix(a, b, c);
    1dd9:	29 fe                	sub    %edi,%esi
    1ddb:	31 f1                	xor    %esi,%ecx
    1ddd:	01 df                	add    %ebx,%edi
    1ddf:	29 cb                	sub    %ecx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1de1:	89 ce                	mov    %ecx,%esi
    1de3:	c1 c6 10             	rol    $0x10,%esi
    __jhash_mix(a, b, c);
    1de6:	31 de                	xor    %ebx,%esi
    1de8:	01 f9                	add    %edi,%ecx
    1dea:	29 f7                	sub    %esi,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    1dec:	89 f3                	mov    %esi,%ebx
    1dee:	c1 c3 13             	rol    $0x13,%ebx
    __jhash_mix(a, b, c);
    1df1:	31 fb                	xor    %edi,%ebx
    1df3:	01 ce                	add    %ecx,%esi
    1df5:	29 d9                	sub    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1df7:	41 89 db             	mov    %ebx,%r11d
    1dfa:	41 c1 c3 04          	rol    $0x4,%r11d
    __jhash_mix(a, b, c);
    1dfe:	01 f3                	add    %esi,%ebx
      a += (u32)k[3] << 24;
    1e00:	40 0f b6 d5          	movzbl %bpl,%edx
    1e04:	c1 e2 18             	shl    $0x18,%edx
      a += (u32)k[2] << 16;
    1e07:	41 0f b6 ea          	movzbl %r10b,%ebp
    1e0b:	c1 e5 10             	shl    $0x10,%ebp
      a += (u32)k[3] << 24;
    1e0e:	09 d5                	or     %edx,%ebp
      a += (u32)k[1] << 8;
    1e10:	41 0f b6 f9          	movzbl %r9b,%edi
    1e14:	c1 e7 08             	shl    $0x8,%edi
      a += (u32)k[2] << 16;
    1e17:	09 ef                	or     %ebp,%edi
      a += k[0];
    1e19:	41 0f b6 d0          	movzbl %r8b,%edx
      a += (u32)k[1] << 8;
    1e1d:	09 fa                	or     %edi,%edx
      a += k[0];
    1e1f:	01 f2                	add    %esi,%edx
    __jhash_mix(a, b, c);
    1e21:	31 d9                	xor    %ebx,%ecx
      __jhash_final(a, b, c);
    1e23:	44 31 d9             	xor    %r11d,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e26:	89 de                	mov    %ebx,%esi
    1e28:	c1 c6 0e             	rol    $0xe,%esi
      __jhash_final(a, b, c);
    1e2b:	29 f1                	sub    %esi,%ecx
    1e2d:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e2f:	89 ce                	mov    %ecx,%esi
    1e31:	c1 c6 0b             	rol    $0xb,%esi
      __jhash_final(a, b, c);
    1e34:	29 f2                	sub    %esi,%edx
    1e36:	31 d3                	xor    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1e38:	89 d6                	mov    %edx,%esi
    1e3a:	c1 c6 19             	rol    $0x19,%esi
      __jhash_final(a, b, c);
    1e3d:	29 f3                	sub    %esi,%ebx
    1e3f:	31 d9                	xor    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e41:	89 de                	mov    %ebx,%esi
    1e43:	c1 c6 10             	rol    $0x10,%esi
      __jhash_final(a, b, c);
    1e46:	29 f1                	sub    %esi,%ecx
    1e48:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e4a:	89 ce                	mov    %ecx,%esi
    1e4c:	c1 c6 04             	rol    $0x4,%esi
      __jhash_final(a, b, c);
    1e4f:	29 f2                	sub    %esi,%edx
    1e51:	31 d3                	xor    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1e53:	c1 c2 0e             	rol    $0xe,%edx
      __jhash_final(a, b, c);
    1e56:	29 d3                	sub    %edx,%ebx
    1e58:	31 d9                	xor    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e5a:	c1 c3 18             	rol    $0x18,%ebx
  a += initval;
    1e5d:	29 d9                	sub    %ebx,%ecx
    1e5f:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  b += initval;
    1e64:	03 74 24 30          	add    0x30(%rsp),%esi
  a += initval;
    1e68:	81 c1 f7 c0 ad e0    	add    $0xe0adc0f7,%ecx
  __jhash_final(a, b, c);
    1e6e:	89 f2                	mov    %esi,%edx
    1e70:	81 f2 f7 c0 ad e0    	xor    $0xe0adc0f7,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e76:	89 f7                	mov    %esi,%edi
    1e78:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    1e7b:	29 fa                	sub    %edi,%edx
    1e7d:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e7f:	89 d7                	mov    %edx,%edi
    1e81:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    1e84:	29 f9                	sub    %edi,%ecx
    1e86:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1e88:	89 cf                	mov    %ecx,%edi
    1e8a:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    1e8d:	29 fe                	sub    %edi,%esi
    1e8f:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e91:	89 f7                	mov    %esi,%edi
    1e93:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    1e96:	29 fa                	sub    %edi,%edx
    1e98:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e9a:	89 d7                	mov    %edx,%edi
    1e9c:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1e9f:	29 f9                	sub    %edi,%ecx
    1ea1:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1ea3:	c1 c1 0e             	rol    $0xe,%ecx
  __jhash_final(a, b, c);
    1ea6:	29 ce                	sub    %ecx,%esi
    1ea8:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1eaa:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    1ead:	29 f2                	sub    %esi,%edx
    1eaf:	b9 01 00 ff ff       	mov    $0xffff0001,%ecx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1eb4:	48 0f af ca          	imul   %rdx,%rcx
    1eb8:	48 c1 e9 30          	shr    $0x30,%rcx
    1ebc:	89 ce                	mov    %ecx,%esi
    1ebe:	c1 e6 10             	shl    $0x10,%esi
    1ec1:	09 ce                	or     %ecx,%esi
    1ec3:	29 f2                	sub    %esi,%edx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1ec5:	41 8b 74 24 04       	mov    0x4(%r12),%esi
    1eca:	89 f1                	mov    %esi,%ecx
    1ecc:	c1 e1 10             	shl    $0x10,%ecx
    1ecf:	01 f1                	add    %esi,%ecx
    1ed1:	01 d1                	add    %edx,%ecx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1ed3:	81 f9 ff 01 00 02    	cmp    $0x20001ff,%ecx
    if (!real_pos) {
    1ed9:	77 6c                	ja     1f47 <balancer_ingress+0x1f47>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1edb:	89 c9                	mov    %ecx,%ecx
    1edd:	48 ba 00 c0 5e 08 00 	movabs $0xffffc900085ec000,%rdx
    1ee4:	c9 ff ff 
    key = *real_pos;
    1ee7:	8b ac ca 00 01 00 00 	mov    0x100(%rdx,%rcx,8),%ebp
    1eee:	48 85 ed             	test   %rbp,%rbp
    if (key == 0) {
    1ef1:	74 2d                	je     1f20 <balancer_ingress+0x1f20>
  pckt->real_index = key;
    1ef3:	89 6c 24 38          	mov    %ebp,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1ef7:	81 fd 00 10 00 00    	cmp    $0x1000,%ebp
  if (!(*real)) {
    1efd:	72 61                	jb     1f60 <balancer_ingress+0x1f60>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1eff:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    1f06:	88 ff ff 
    1f09:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1f10:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    1f17:	65 bb 
  if (!ch_drop_stats) {
    1f19:	48 85 c0             	test   %rax,%rax
    1f1c:	75 25                	jne    1f43 <balancer_ingress+0x1f43>
    1f1e:	eb 27                	jmp    1f47 <balancer_ingress+0x1f47>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1f20:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    1f27:	88 ff ff 
    1f2a:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1f31:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    1f38:	65 bb 
  if (!ch_drop_stats) {
    1f3a:	48 85 c0             	test   %rax,%rax
    1f3d:	74 08                	je     1f47 <balancer_ingress+0x1f47>
    1f3f:	48 83 c0 08          	add    $0x8,%rax
    1f43:	48 83 00 01          	addq   $0x1,(%rax)
    1f47:	bd 01 00 00 00       	mov    $0x1,%ebp
    return process_packet(ctx, nh_off, true);
  } else {
    // pass to tcp/ip stack
    return XDP_PASS;
  }
}
    1f4c:	89 e8                	mov    %ebp,%eax
    1f4e:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    1f55:	5b                   	pop    %rbx
    1f56:	41 5c                	pop    %r12
    1f58:	41 5d                	pop    %r13
    1f5a:	41 5e                	pop    %r14
    1f5c:	41 5f                	pop    %r15
    1f5e:	5d                   	pop    %rbp
    1f5f:	c3                   	ret
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1f60:	48 83 7c 24 08 00    	cmpq   $0x0,0x8(%rsp)
    1f66:	74 15                	je     1f7d <balancer_ingress+0x1f7d>
    1f68:	4c 89 e6             	mov    %r12,%rsi
    1f6b:	41 8a 0c 24          	mov    (%r12),%cl
    1f6f:	80 e1 02             	and    $0x2,%cl
    1f72:	d0 e9                	shr    %cl
    1f74:	41 08 cf             	or     %cl,%r15b
    1f77:	0f 84 ca 00 00 00    	je     2047 <balancer_ingress+0x2047>
    1f7d:	89 e8                	mov    %ebp,%eax
    1f7f:	e9 ee 00 00 00       	jmp    2072 <balancer_ingress+0x2072>
    1f84:	48 c7 c0 60 39 be b7 	mov    $0xffffffffb7be3960,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1f8b:	4c 89 ef             	mov    %r13,%rdi
    1f8e:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1f93:	ff d0                	call   *%rax
    1f95:	85 c0                	test   %eax,%eax
    1f97:	75 ae                	jne    1f47 <balancer_ingress+0x1f47>
  data = (void*)(long)xdp->data;
    1f99:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1f9d:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1fa1:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1fa5:	48 39 ca             	cmp    %rcx,%rdx
    1fa8:	77 9d                	ja     1f47 <balancer_ingress+0x1f47>
    1faa:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1fae:	bd 01 00 00 00       	mov    $0x1,%ebp
    1fb3:	48 39 ca             	cmp    %rcx,%rdx
    1fb6:	77 94                	ja     1f4c <balancer_ingress+0x1f4c>
    1fb8:	48 b9 00 4c 5f 06 81 	movabs $0xffff8881065f4c00,%rcx
    1fbf:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1fc2:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1fc9:	66 89 50 04          	mov    %dx,0x4(%rax)
    1fcd:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1fd3:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1fd5:	8b 48 28             	mov    0x28(%rax),%ecx
    1fd8:	89 48 06             	mov    %ecx,0x6(%rax)
    1fdb:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    1fdf:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    1fe3:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    1fe9:	0f b7 74 24 30       	movzwl 0x30(%rsp),%esi
  saddr[3] = src ^ port;
    1fee:	33 74 24 1c          	xor    0x1c(%rsp),%esi
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    1ff2:	41 83 c7 28          	add    $0x28,%r15d
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1ff6:	8a 4c 24 3d          	mov    0x3d(%rsp),%cl
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1ffa:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    2000:	89 ca                	mov    %ecx,%edx
    2002:	c0 ea 04             	shr    $0x4,%dl
    2005:	80 ca 60             	or     $0x60,%dl
    2008:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    200b:	c0 e1 04             	shl    $0x4,%cl
    200e:	88 48 0f             	mov    %cl,0xf(%rax)
  ip6h->nexthdr = proto;
    2011:	66 c7 40 14 29 40    	movw   $0x4029,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    2017:	66 41 c1 c7 08       	rol    $0x8,%r15w
    201c:	66 44 89 78 12       	mov    %r15w,0x12(%rax)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    2021:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    2028:	00 
    2029:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    2030:	89 70 22             	mov    %esi,0x22(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    2033:	48 8b 0b             	mov    (%rbx),%rcx
    2036:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    203a:	48 89 48 26          	mov    %rcx,0x26(%rax)
    203e:	48 89 50 2e          	mov    %rdx,0x2e(%rax)
    2042:	e9 8f e3 ff ff       	jmp    3d6 <balancer_ingress+0x3d6>
    if (pckt->flow.proto == IPPROTO_UDP) {
    2047:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    204c:	75 05                	jne    2053 <balancer_ingress+0x2053>
      new_dst_lru.atime = cur_time;
    204e:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    new_dst_lru.pos = key;
    2053:	89 6c 24 40          	mov    %ebp,0x40(%rsp)
    2057:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_update_elem,,
    205c:	48 8b 07             	mov    (%rdi),%rax
    205f:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    2064:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    2069:	31 c9                	xor    %ecx,%ecx
    206b:	ff 50 68             	call   *0x68(%rax)
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    206e:	8b 44 24 38          	mov    0x38(%rsp),%eax
    2072:	48 b9 00 54 5f 06 81 	movabs $0xffff8881065f5400,%rcx
    2079:	88 ff ff 
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    207c:	8b b1 00 01 00 00    	mov    0x100(%rcx),%esi
    2082:	b2 01                	mov    $0x1,%dl
    2084:	3b 74 24 60          	cmp    0x60(%rsp),%esi
    2088:	75 25                	jne    20af <balancer_ingress+0x20af>
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    208a:	8b b1 04 01 00 00    	mov    0x104(%rcx),%esi
    2090:	3b 74 24 64          	cmp    0x64(%rsp),%esi
    2094:	75 19                	jne    20af <balancer_ingress+0x20af>
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    2096:	8b b1 08 01 00 00    	mov    0x108(%rcx),%esi
    209c:	3b 74 24 68          	cmp    0x68(%rsp),%esi
    20a0:	75 0d                	jne    20af <balancer_ingress+0x20af>
    20a2:	8b 91 0c 01 00 00    	mov    0x10c(%rcx),%edx
    20a8:	3b 54 24 6c          	cmp    0x6c(%rsp),%edx
    20ac:	0f 95 c2             	setne  %dl
  bool port_match = lru_miss_stat_vip->port == vip->port;
    20af:	0f b7 b1 10 01 00 00 	movzwl 0x110(%rcx),%esi
    20b6:	0f b7 7c 24 70       	movzwl 0x70(%rsp),%edi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    20bb:	8a 5c 24 72          	mov    0x72(%rsp),%bl
    20bf:	88 99 12 01 00 00    	mov    %bl,0x112(%rcx)
  bool vip_match = address_match && port_match && proto_match;
    20c5:	84 d2                	test   %dl,%dl
    20c7:	75 3d                	jne    2106 <balancer_ingress+0x2106>
    20c9:	66 39 fe             	cmp    %di,%si
    20cc:	75 38                	jne    2106 <balancer_ingress+0x2106>
    20ce:	84 db                	test   %bl,%bl
    20d0:	74 34                	je     2106 <balancer_ingress+0x2106>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    20d2:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    20d7:	0f 87 6a fe ff ff    	ja     1f47 <balancer_ingress+0x1f47>
    20dd:	89 c0                	mov    %eax,%eax
    20df:	48 b9 00 30 3c 08 00 	movabs $0xffffc900083c3000,%rcx
    20e6:	c9 ff ff 
    20e9:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    20f0:	00 
    20f1:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    20f8:	65 bb 
    if (!lru_miss_stat) {
    20fa:	48 85 c0             	test   %rax,%rax
    20fd:	0f 84 44 fe ff ff    	je     1f47 <balancer_ingress+0x1f47>
    *lru_miss_stat += 1;
    2103:	83 00 01             	addl   $0x1,(%rax)
    2106:	48 8d 04 6d 00 00 00 	lea    0x0(,%rbp,2),%rax
    210d:	00 
    210e:	48 01 e8             	add    %rbp,%rax
    2111:	48 b9 00 30 3f 08 00 	movabs $0xffffc900083f3000,%rcx
    2118:	c9 ff ff 
    211b:	48 8d 1c c1          	lea    (%rcx,%rax,8),%rbx
    211f:	48 81 c3 00 01 00 00 	add    $0x100,%rbx
      data_stats->v2 += 1;
    2126:	49 83 46 08 01       	addq   $0x1,0x8(%r14)
    212b:	48 ba 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rdx
    2132:	88 ff ff 
    2135:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
    213a:	e9 8a f9 ff ff       	jmp    1ac9 <balancer_ingress+0x1ac9>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    213f:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    2143:	48 c1 e1 18          	shl    $0x18,%rcx
    2147:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    214b:	48 c1 e2 10          	shl    $0x10,%rdx
    214f:	48 09 ca             	or     %rcx,%rdx
    2152:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    2156:	48 c1 e1 08          	shl    $0x8,%rcx
    215a:	48 09 d1             	or     %rdx,%rcx
    215d:	8a 40 04             	mov    0x4(%rax),%al
    2160:	b2 03                	mov    $0x3,%dl
    2162:	eb 18                	jmp    217c <balancer_ingress+0x217c>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    2164:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    2168:	48 c1 e2 10          	shl    $0x10,%rdx
    216c:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    2170:	48 c1 e1 08          	shl    $0x8,%rcx
    2174:	48 09 d1             	or     %rdx,%rcx
    2177:	8a 40 03             	mov    0x3(%rax),%al
    217a:	b2 02                	mov    $0x2,%dl
    217c:	0f b6 c0             	movzbl %al,%eax
    217f:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    2182:	85 c0                	test   %eax,%eax
    2184:	0f 8e 39 ee ff ff    	jle    fc3 <balancer_ingress+0xfc3>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    218a:	80 fa 01             	cmp    $0x1,%dl
    218d:	74 61                	je     21f0 <balancer_ingress+0x21f0>
    218f:	80 fa 03             	cmp    $0x3,%dl
    2192:	74 63                	je     21f7 <balancer_ingress+0x21f7>
    2194:	80 fa 02             	cmp    $0x2,%dl
    2197:	75 65                	jne    21fe <balancer_ingress+0x21fe>
    2199:	b9 40 00 00 00       	mov    $0x40,%ecx
    219e:	eb 63                	jmp    2203 <balancer_ingress+0x2203>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    21a0:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    21a7:	88 ff ff 
    21aa:	4c 8b b0 10 11 00 00 	mov    0x1110(%rax),%r14
    21b1:	65 4c 03 34 25 28 b0 	add    %gs:0xffffffffbb65b028,%r14
    21b8:	65 bb 
  if (!conn_rate_stats) {
    21ba:	4d 85 f6             	test   %r14,%r14
    21bd:	0f 84 58 01 00 00    	je     231b <balancer_ingress+0x231b>
    21c3:	48 c7 c0 60 23 a5 b5 	mov    $0xffffffffb5a52360,%rax
  *cur_time = bpf_ktime_get_ns();
    21ca:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    21cc:	48 89 c1             	mov    %rax,%rcx
    21cf:	49 2b 4e 08          	sub    0x8(%r14),%rcx
    21d3:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    21da:	0f 82 f8 00 00 00    	jb     22d8 <balancer_ingress+0x22d8>
    conn_rate_stats->v1 = 1;
    21e0:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    conn_rate_stats->v2 = *cur_time;
    21e7:	49 89 46 08          	mov    %rax,0x8(%r14)
    21eb:	e9 fa 00 00 00       	jmp    22ea <balancer_ingress+0x22ea>
    21f0:	b9 38 00 00 00       	mov    $0x38,%ecx
    21f5:	eb 0c                	jmp    2203 <balancer_ingress+0x2203>
    21f7:	b9 48 00 00 00       	mov    $0x48,%ecx
    21fc:	eb 05                	jmp    2203 <balancer_ingress+0x2203>
    21fe:	b9 30 00 00 00       	mov    $0x30,%ecx
    2203:	48 83 44 0d 00 01    	addq   $0x1,0x0(%rbp,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    2209:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    220e:	77 73                	ja     2283 <balancer_ingress+0x2283>
    2210:	48 b9 00 b0 41 22 00 	movabs $0xffffc9002241b000,%rcx
    2217:	c9 ff ff 
          key = *real_pos;
    221a:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    2221:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    2224:	74 5d                	je     2283 <balancer_ingress+0x2283>
            pckt.real_index = key;
    2226:	89 4c 24 38          	mov    %ecx,0x38(%rsp)
    222a:	45 31 f6             	xor    %r14d,%r14d
            dst = bpf_map_lookup_elem(&reals, &key);
    222d:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    2233:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    2237:	48 b9 00 30 3f 08 00 	movabs $0xffffc900083f3000,%rcx
    223e:	c9 ff ff 
    2241:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    2248:	00 
    2249:	4c 0f 42 f0          	cmovb  %rax,%r14
            if (!dst) {
    224d:	4d 85 f6             	test   %r14,%r14
    2250:	74 46                	je     2298 <balancer_ingress+0x2298>
    2252:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    2257:	48 8b 07             	mov    (%rdi),%rax
    225a:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    225f:	ff 50 60             	call   *0x60(%rax)
  if (dst_lru) {
    2262:	48 85 c0             	test   %rax,%rax
    2265:	0f 84 de 00 00 00    	je     2349 <balancer_ingress+0x2349>
    if (dst_lru->pos == pckt->real_index) {
    226b:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    226f:	39 08                	cmp    %ecx,(%rax)
    2271:	0f 85 1b 01 00 00    	jne    2392 <balancer_ingress+0x2392>
              quic_packets_stats->dst_match_in_lru += 1;
    2277:	48 89 e8             	mov    %rbp,%rax
    227a:	48 83 c0 50          	add    $0x50,%rax
    227e:	e9 9b 01 00 00       	jmp    241e <balancer_ingress+0x241e>
    2283:	48 83 45 10 01       	addq   $0x1,0x10(%rbp)
    2288:	48 98                	cltq
    228a:	48 89 45 18          	mov    %rax,0x18(%rbp)
    228e:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    2293:	e9 6c ed ff ff       	jmp    1004 <balancer_ingress+0x1004>
    2298:	48 83 45 28 01       	addq   $0x1,0x28(%rbp)
    229d:	e9 a5 fc ff ff       	jmp    1f47 <balancer_ingress+0x1f47>
      dst_lru->pos = pckt->real_index;
    22a2:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    22a4:	48 83 45 58 01       	addq   $0x1,0x58(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    22a9:	41 81 ff ff 01 00 00 	cmp    $0x1ff,%r15d
    22b0:	77 74                	ja     2326 <balancer_ingress+0x2326>
    22b2:	48 b8 00 c0 5e 66 81 	movabs $0xffff8881665ec000,%rax
    22b9:	88 ff ff 
    22bc:	4a 8b 84 f8 00 01 00 	mov    0x100(%rax,%r15,8),%rax
    22c3:	00 
    22c4:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    22cb:	65 bb 
  if (!per_vip_stats) {
    22cd:	48 85 c0             	test   %rax,%rax
    22d0:	74 54                	je     2326 <balancer_ingress+0x2326>
    per_vip_stats->v2 += 1;
    22d2:	48 83 c0 08          	add    $0x8,%rax
    22d6:	eb 4a                	jmp    2322 <balancer_ingress+0x2322>
    conn_rate_stats->v1 += 1;
    22d8:	49 8b 06             	mov    (%r14),%rax
    22db:	48 83 c0 01          	add    $0x1,%rax
    22df:	49 89 06             	mov    %rax,(%r14)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    22e2:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    22e8:	77 31                	ja     231b <balancer_ingress+0x231b>
  struct real_pos_lru new_dst_lru = {};
    22ea:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    22f1:	00 00 
    22f3:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    22fa:	00 00 
  new_dst_lru.pos = pckt->real_index;
    22fc:	8b 44 24 38          	mov    0x38(%rsp),%eax
    2300:	89 44 24 40          	mov    %eax,0x40(%rsp)
    2304:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_update_elem,,
    2309:	48 8b 07             	mov    (%rdi),%rax
    230c:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    2311:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    2316:	31 c9                	xor    %ecx,%ecx
    2318:	ff 50 68             	call   *0x68(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    231b:	48 89 e8             	mov    %rbp,%rax
    231e:	48 83 c0 60          	add    $0x60,%rax
    2322:	48 83 00 01          	addq   $0x1,(%rax)
            quic_packets_stats->cid_routed += 1;
    2326:	48 83 45 20 01       	addq   $0x1,0x20(%rbp)
  original_sport = pckt.flow.port16[0];
    232b:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
    2330:	89 84 24 80 00 00 00 	mov    %eax,0x80(%rsp)
    2337:	48 ba 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rdx
    233e:	88 ff ff 
    2341:	4c 89 fe             	mov    %r15,%rsi
    2344:	e9 80 f7 ff ff       	jmp    1ac9 <balancer_ingress+0x1ac9>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2349:	48 b8 00 80 87 a4 81 	movabs $0xffff8881a4878000,%rax
    2350:	88 ff ff 
    2353:	48 8b 98 10 11 00 00 	mov    0x1110(%rax),%rbx
    235a:	65 48 03 1c 25 28 b0 	add    %gs:0xffffffffbb65b028,%rbx
    2361:	65 bb 
  if (!conn_rate_stats) {
    2363:	48 85 db             	test   %rbx,%rbx
    2366:	0f 84 ab 00 00 00    	je     2417 <balancer_ingress+0x2417>
    236c:	48 c7 c0 60 23 a5 b5 	mov    $0xffffffffb5a52360,%rax
  *cur_time = bpf_ktime_get_ns();
    2373:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    2375:	48 89 c1             	mov    %rax,%rcx
    2378:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    237c:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    2383:	72 4f                	jb     23d4 <balancer_ingress+0x23d4>
    conn_rate_stats->v1 = 1;
    2385:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    238c:	48 89 43 08          	mov    %rax,0x8(%rbx)
    2390:	eb 54                	jmp    23e6 <balancer_ingress+0x23e6>
      dst_lru->pos = pckt->real_index;
    2392:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    2394:	48 83 45 58 01       	addq   $0x1,0x58(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2399:	81 bc 24 80 00 00 00 	cmpl   $0x1ff,0x80(%rsp)
    23a0:	ff 01 00 00 
    23a4:	77 7c                	ja     2422 <balancer_ingress+0x2422>
    23a6:	48 b8 00 c0 5e 66 81 	movabs $0xffff8881665ec000,%rax
    23ad:	88 ff ff 
    23b0:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
    23b7:	00 
    23b8:	48 8b 84 c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rax
    23bf:	00 
    23c0:	65 48 03 04 25 28 b0 	add    %gs:0xffffffffbb65b028,%rax
    23c7:	65 bb 
  if (!per_vip_stats) {
    23c9:	48 85 c0             	test   %rax,%rax
    23cc:	74 54                	je     2422 <balancer_ingress+0x2422>
    per_vip_stats->v2 += 1;
    23ce:	48 83 c0 08          	add    $0x8,%rax
    23d2:	eb 4a                	jmp    241e <balancer_ingress+0x241e>
    conn_rate_stats->v1 += 1;
    23d4:	48 8b 03             	mov    (%rbx),%rax
    23d7:	48 83 c0 01          	add    $0x1,%rax
    23db:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    23de:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    23e4:	77 31                	ja     2417 <balancer_ingress+0x2417>
  struct real_pos_lru new_dst_lru = {};
    23e6:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    23ed:	00 00 
    23ef:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    23f6:	00 00 
  new_dst_lru.pos = pckt->real_index;
    23f8:	8b 44 24 38          	mov    0x38(%rsp),%eax
    23fc:	89 44 24 40          	mov    %eax,0x40(%rsp)
    2400:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    2405:	48 8b 07             	mov    (%rdi),%rax
    2408:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    240d:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    2412:	31 c9                	xor    %ecx,%ecx
    2414:	ff 50 68             	call   *0x68(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    2417:	48 89 e8             	mov    %rbp,%rax
    241a:	48 83 c0 60          	add    $0x60,%rax
    241e:	48 83 00 01          	addq   $0x1,(%rax)
            quic_packets_stats->cid_routed += 1;
    2422:	48 83 45 20 01       	addq   $0x1,0x20(%rbp)
  original_sport = pckt.flow.port16[0];
    2427:	44 0f b7 64 24 30    	movzwl 0x30(%rsp),%r12d
    242d:	e9 bd ee ff ff       	jmp    12ef <balancer_ingress+0x12ef>
