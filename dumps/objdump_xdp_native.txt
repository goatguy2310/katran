
bpf/native/balancer.bpf:     file format elf64-x86-64


Disassembly of section xdp:

0000000000000000 <balancer_ingress>:
  return XDP_TX;
}

SEC(PROG_SEC_NAME)
int balancer_ingress(struct xdp_md* ctx) {
  void* data = (void*)(long)ctx->data;
       0:	f3 0f 1e fa          	endbr64
       4:	55                   	push   %rbp
       5:	41 57                	push   %r15
       7:	41 56                	push   %r14
       9:	41 55                	push   %r13
       b:	41 54                	push   %r12
       d:	53                   	push   %rbx
       e:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
      15:	48 8b 1f             	mov    (%rdi),%rbx
  void* data_end = (void*)(long)ctx->data_end;
      18:	4c 8b 67 08          	mov    0x8(%rdi),%r12
  struct ethhdr* eth = data;
  __u32 eth_proto;
  __u32 nh_off;
  nh_off = sizeof(struct ethhdr);

  if (data + nh_off > data_end) {
      1c:	48 8d 43 0e          	lea    0xe(%rbx),%rax
      20:	bd 01 00 00 00       	mov    $0x1,%ebp
      25:	4c 39 e0             	cmp    %r12,%rax
      28:	0f 87 19 1f 00 00    	ja     1f47 <balancer_ingress+0x1f47>
      2e:	49 89 fd             	mov    %rdi,%r13
    // bogus packet, len less than minimum ethernet frame size
    return XDP_DROP;
  }

  eth_proto = eth->h_proto;
      31:	0f b7 4b 0c          	movzwl 0xc(%rbx),%ecx

  if (eth_proto == BE_ETH_P_IP) {
      35:	81 f9 86 dd 00 00    	cmp    $0xdd86,%ecx
      3b:	0f 84 1e 01 00 00    	je     15f <balancer_ingress+0x15f>
      41:	bd 02 00 00 00       	mov    $0x2,%ebp
      46:	66 83 f9 08          	cmp    $0x8,%cx
      4a:	0f 85 f7 1e 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  struct packet_description pckt = {};
      50:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
      57:	00 00 
      59:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
      60:	00 00 
      62:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
      69:	00 00 
      6b:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
      72:	00 00 
      74:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
      7b:	00 00 
      7d:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
      84:	00 00 
  struct vip_definition vip = {};
      86:	c7 44 24 70 00 00 00 	movl   $0x0,0x70(%rsp)
      8d:	00 
      8e:	48 c7 44 24 68 00 00 	movq   $0x0,0x68(%rsp)
      95:	00 00 
      97:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
      9e:	00 00 
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
    }
  } else {
    iph = data + nh_off;
    if (iph + 1 > data_end) {
      a0:	4c 8d 73 22          	lea    0x22(%rbx),%r14
      a4:	4d 39 e6             	cmp    %r12,%r14
      a7:	0f 87 95 1e 00 00    	ja     1f42 <balancer_ingress+0x1f42>
      return XDP_DROP;
    }
    // ihl contains len of ipv4 header in 32bit words
    if (iph->ihl != 5) {
      ad:	8a 00                	mov    (%rax),%al
      af:	24 0f                	and    $0xf,%al
      b1:	3c 05                	cmp    $0x5,%al
      b3:	0f 85 89 1e 00 00    	jne    1f42 <balancer_ingress+0x1f42>
      // if len of ipv4 hdr is not equal to 20bytes that means that header
      // contains ip options, and we dont support em
      return XDP_DROP;
    }
    pckt->tos = iph->tos;
      b9:	8a 43 0f             	mov    0xf(%rbx),%al
      bc:	88 44 24 3d          	mov    %al,0x3d(%rsp)
    *protocol = iph->protocol;
      c0:	8a 43 17             	mov    0x17(%rbx),%al
    pckt->flow.proto = *protocol;
      c3:	88 44 24 34          	mov    %al,0x34(%rsp)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;

    if (iph->frag_off & PCKT_FRAGMENTED) {
      c7:	0f b7 4b 14          	movzwl 0x14(%rbx),%ecx
      cb:	f7 c1 3f ff 00 00    	test   $0xff3f,%ecx
      d1:	0f 85 6b 1e 00 00    	jne    1f42 <balancer_ingress+0x1f42>
      d7:	0f b7 7b 10          	movzwl 0x10(%rbx),%edi
      // we drop fragmented packets.
      return XDP_DROP;
    }
    if (*protocol == IPPROTO_ICMP) {
      db:	3c 01                	cmp    $0x1,%al
      dd:	0f 85 43 03 00 00    	jne    426 <balancer_ingress+0x426>
    __u64 off,
    struct packet_description* pckt) {
  struct icmphdr* icmp_hdr;
  struct iphdr* iph;
  icmp_hdr = data + off;
  if (icmp_hdr + 1 > data_end) {
      e3:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
      e7:	4c 39 e0             	cmp    %r12,%rax
      ea:	0f 87 52 1e 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    return XDP_DROP;
  }
  if (icmp_hdr->type == ICMP_ECHO) {
      f0:	41 8a 16             	mov    (%r14),%dl
      f3:	80 fa 03             	cmp    $0x3,%dl
      f6:	0f 84 50 08 00 00    	je     94c <balancer_ingress+0x94c>
      fc:	bd 02 00 00 00       	mov    $0x2,%ebp
     101:	80 fa 08             	cmp    $0x8,%dl
     104:	0f 85 3d 1e 00 00    	jne    1f47 <balancer_ingress+0x1f47>
     10a:	44 0f b7 c7          	movzwl %di,%r8d
  icmp_hdr->type = ICMP_ECHOREPLY;
     10e:	c6 43 22 00          	movb   $0x0,0x22(%rbx)
  icmp_hdr->checksum += 0x0008;
     112:	66 83 43 24 08       	addw   $0x8,0x24(%rbx)
  iph->ttl = DEFAULT_TTL;
     117:	c6 43 16 40          	movb   $0x40,0x16(%rbx)
  iph->daddr = iph->saddr;
     11b:	8b 43 1a             	mov    0x1a(%rbx),%eax
  tmp_addr = iph->daddr;
     11e:	8b 73 1e             	mov    0x1e(%rbx),%esi
  iph->daddr = iph->saddr;
     121:	89 43 1e             	mov    %eax,0x1e(%rbx)
  iph->saddr = tmp_addr;
     124:	89 73 1a             	mov    %esi,0x1a(%rbx)
    void* iph,
    __u64* csum) {
  __u16* next_iph_u16 = (__u16*)iph;
#pragma clang loop unroll(full)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    *csum += *next_iph_u16++;
     127:	0f b7 7b 0e          	movzwl 0xe(%rbx),%edi
     12b:	0f b7 6b 12          	movzwl 0x12(%rbx),%ebp
     12f:	44 0f b7 4b 16       	movzwl 0x16(%rbx),%r9d
     134:	0f b7 d6             	movzwl %si,%edx
     137:	48 c1 ee 10          	shr    $0x10,%rsi
     13b:	48 01 d6             	add    %rdx,%rsi
     13e:	0f b7 d0             	movzwl %ax,%edx
     141:	48 01 f2             	add    %rsi,%rdx
     144:	48 c1 e8 10          	shr    $0x10,%rax
     148:	48 01 d0             	add    %rdx,%rax
     14b:	48 01 f8             	add    %rdi,%rax
     14e:	4c 01 c0             	add    %r8,%rax
     151:	48 01 e8             	add    %rbp,%rax
     154:	48 01 c8             	add    %rcx,%rax
     157:	4c 01 c8             	add    %r9,%rax
     15a:	e9 e3 01 00 00       	jmp    342 <balancer_ingress+0x342>
  struct packet_description pckt = {};
     15f:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
     166:	00 00 
     168:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
     16f:	00 00 
     171:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
     178:	00 00 
     17a:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
     181:	00 00 
     183:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
     18a:	00 00 
     18c:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
     193:	00 00 
  struct vip_definition vip = {};
     195:	c7 44 24 70 00 00 00 	movl   $0x0,0x70(%rsp)
     19c:	00 
     19d:	48 c7 44 24 68 00 00 	movq   $0x0,0x68(%rsp)
     1a4:	00 00 
     1a6:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
     1ad:	00 00 
    if (ip6h + 1 > data_end) {
     1af:	4c 8d 7b 36          	lea    0x36(%rbx),%r15
     1b3:	4d 39 e7             	cmp    %r12,%r15
     1b6:	0f 87 86 1d 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    *protocol = ip6h->nexthdr;
     1bc:	8a 43 14             	mov    0x14(%rbx),%al
    pckt->flow.proto = *protocol;
     1bf:	88 44 24 34          	mov    %al,0x34(%rsp)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1c3:	8a 4b 0e             	mov    0xe(%rbx),%cl
     1c6:	c0 e1 04             	shl    $0x4,%cl
     1c9:	88 4c 24 3d          	mov    %cl,0x3d(%rsp)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1cd:	8a 53 0f             	mov    0xf(%rbx),%dl
     1d0:	c0 ea 04             	shr    $0x4,%dl
     1d3:	08 ca                	or     %cl,%dl
     1d5:	88 54 24 3d          	mov    %dl,0x3d(%rsp)
    if (*protocol == IPPROTO_FRAGMENT) {
     1d9:	3c 2c                	cmp    $0x2c,%al
     1db:	0f 84 61 1d 00 00    	je     1f42 <balancer_ingress+0x1f42>
     1e1:	0f b7 7b 12          	movzwl 0x12(%rbx),%edi
     1e5:	3c 3a                	cmp    $0x3a,%al
     1e7:	0f 85 9b 00 00 00    	jne    288 <balancer_ingress+0x288>
  if (icmp_hdr + 1 > data_end) {
     1ed:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     1f1:	4c 39 e0             	cmp    %r12,%rax
     1f4:	0f 87 48 1d 00 00    	ja     1f42 <balancer_ingress+0x1f42>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1fa:	41 8a 07             	mov    (%r15),%al
     1fd:	3c 02                	cmp    $0x2,%al
     1ff:	0f 84 c2 02 00 00    	je     4c7 <balancer_ingress+0x4c7>
     205:	3c 01                	cmp    $0x1,%al
     207:	0f 84 f3 02 00 00    	je     500 <balancer_ingress+0x500>
     20d:	bd 02 00 00 00       	mov    $0x2,%ebp
     212:	3c 80                	cmp    $0x80,%al
     214:	0f 85 2d 1d 00 00    	jne    1f47 <balancer_ingress+0x1f47>
     21a:	c6 43 36 81          	movb   $0x81,0x36(%rbx)
     21e:	66 83 43 38 ff       	addw   $0xffff,0x38(%rbx)
     223:	c6 43 15 40          	movb   $0x40,0x15(%rbx)
     227:	48 8b 43 16          	mov    0x16(%rbx),%rax
     22b:	48 8b 4b 1e          	mov    0x1e(%rbx),%rcx
     22f:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     234:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
     239:	48 8b 43 26          	mov    0x26(%rbx),%rax
     23d:	48 8b 4b 2e          	mov    0x2e(%rbx),%rcx
     241:	48 89 43 16          	mov    %rax,0x16(%rbx)
     245:	48 89 4b 1e          	mov    %rcx,0x1e(%rbx)
     249:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
     24e:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
     253:	48 89 43 26          	mov    %rax,0x26(%rbx)
     257:	48 89 4b 2e          	mov    %rcx,0x2e(%rbx)
     25b:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     25f:	66 89 44 24 7c       	mov    %ax,0x7c(%rsp)
     264:	8b 43 06             	mov    0x6(%rbx),%eax
     267:	89 44 24 78          	mov    %eax,0x78(%rsp)
     26b:	8b 03                	mov    (%rbx),%eax
     26d:	89 43 06             	mov    %eax,0x6(%rbx)
     270:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     274:	66 89 43 0a          	mov    %ax,0xa(%rbx)
     278:	8b 44 24 78          	mov    0x78(%rsp),%eax
     27c:	89 03                	mov    %eax,(%rbx)
     27e:	0f b7 44 24 7c       	movzwl 0x7c(%rsp),%eax
     283:	e9 45 01 00 00       	jmp    3cd <balancer_ingress+0x3cd>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     288:	48 8b 4b 16          	mov    0x16(%rbx),%rcx
     28c:	48 8b 53 1e          	mov    0x1e(%rbx),%rdx
     290:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
     295:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     29a:	48 8b 4b 26          	mov    0x26(%rbx),%rcx
     29e:	48 8b 53 2e          	mov    0x2e(%rbx),%rdx
     2a2:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
     2a7:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
    void* data,
    void* data_end,
    __u64 off,
    struct packet_description* pckt,
    __u8 protocol) {
  if (protocol == IPPROTO_ICMPV6) {
     2ac:	3c 01                	cmp    $0x1,%al
     2ae:	0f 85 27 01 00 00    	jne    3db <balancer_ingress+0x3db>
  if (icmp_hdr + 1 > data_end) {
     2b4:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     2b8:	4c 39 e0             	cmp    %r12,%rax
     2bb:	0f 87 81 1c 00 00    	ja     1f42 <balancer_ingress+0x1f42>
  if (icmp_hdr->type == ICMP_ECHO) {
     2c1:	41 8a 0f             	mov    (%r15),%cl
     2c4:	80 f9 03             	cmp    $0x3,%cl
     2c7:	0f 84 19 05 00 00    	je     7e6 <balancer_ingress+0x7e6>
     2cd:	bd 02 00 00 00       	mov    $0x2,%ebp
     2d2:	80 f9 08             	cmp    $0x8,%cl
     2d5:	0f 85 6c 1c 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2db:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
     2df:	bd 01 00 00 00       	mov    $0x1,%ebp
       sizeof(struct icmphdr)) > data_end) {
     2e4:	4c 39 e0             	cmp    %r12,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2e7:	0f 87 5a 1c 00 00    	ja     1f47 <balancer_ingress+0x1f47>
  icmp_hdr->type = ICMP_ECHOREPLY;
     2ed:	c6 43 22 00          	movb   $0x0,0x22(%rbx)
  icmp_hdr->checksum += 0x0008;
     2f1:	66 83 43 24 08       	addw   $0x8,0x24(%rbx)
  iph->ttl = DEFAULT_TTL;
     2f6:	c6 43 16 40          	movb   $0x40,0x16(%rbx)
  iph->daddr = iph->saddr;
     2fa:	8b 43 1a             	mov    0x1a(%rbx),%eax
  tmp_addr = iph->daddr;
     2fd:	8b 4b 1e             	mov    0x1e(%rbx),%ecx
  iph->daddr = iph->saddr;
     300:	89 43 1e             	mov    %eax,0x1e(%rbx)
  iph->saddr = tmp_addr;
     303:	89 4b 1a             	mov    %ecx,0x1a(%rbx)
     306:	44 0f b7 4b 0e       	movzwl 0xe(%rbx),%r9d
     30b:	0f b7 73 10          	movzwl 0x10(%rbx),%esi
     30f:	0f b7 7b 12          	movzwl 0x12(%rbx),%edi
     313:	0f b7 6b 14          	movzwl 0x14(%rbx),%ebp
     317:	44 0f b7 43 16       	movzwl 0x16(%rbx),%r8d
     31c:	0f b7 d1             	movzwl %cx,%edx
     31f:	48 c1 e9 10          	shr    $0x10,%rcx
     323:	48 01 d1             	add    %rdx,%rcx
     326:	0f b7 d0             	movzwl %ax,%edx
     329:	48 01 ca             	add    %rcx,%rdx
     32c:	48 c1 e8 10          	shr    $0x10,%rax
     330:	48 01 d0             	add    %rdx,%rax
     333:	4c 01 c8             	add    %r9,%rax
     336:	48 01 f0             	add    %rsi,%rax
     339:	48 01 f8             	add    %rdi,%rax
     33c:	48 01 e8             	add    %rbp,%rax
     33f:	4c 01 c0             	add    %r8,%rax
     342:	48 89 c1             	mov    %rax,%rcx
     345:	48 c1 e9 10          	shr    $0x10,%rcx
     349:	0f b7 d0             	movzwl %ax,%edx
     34c:	48 01 ca             	add    %rcx,%rdx
     34f:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
     355:	48 0f 42 d0          	cmovb  %rax,%rdx
     359:	48 89 d0             	mov    %rdx,%rax
     35c:	48 c1 e8 10          	shr    $0x10,%rax
     360:	0f b7 ca             	movzwl %dx,%ecx
     363:	48 01 c1             	add    %rax,%rcx
     366:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     36d:	48 0f 42 ca          	cmovb  %rdx,%rcx
     371:	48 89 c8             	mov    %rcx,%rax
     374:	48 c1 e8 10          	shr    $0x10,%rax
     378:	0f b7 d1             	movzwl %cx,%edx
     37b:	48 01 c2             	add    %rax,%rdx
     37e:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
     385:	48 0f 42 d1          	cmovb  %rcx,%rdx
     389:	89 d0                	mov    %edx,%eax
     38b:	c1 e8 10             	shr    $0x10,%eax
     38e:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     395:	b9 00 00 01 00       	mov    $0x10000,%ecx
     39a:	0f 43 c8             	cmovae %eax,%ecx
     39d:	01 d1                	add    %edx,%ecx
     39f:	f7 d1                	not    %ecx
     3a1:	66 89 4b 18          	mov    %cx,0x18(%rbx)
     3a5:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     3a9:	66 89 44 24 44       	mov    %ax,0x44(%rsp)
     3ae:	8b 43 06             	mov    0x6(%rbx),%eax
     3b1:	89 44 24 40          	mov    %eax,0x40(%rsp)
     3b5:	8b 03                	mov    (%rbx),%eax
     3b7:	89 43 06             	mov    %eax,0x6(%rbx)
     3ba:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     3be:	66 89 43 0a          	mov    %ax,0xa(%rbx)
     3c2:	8b 44 24 40          	mov    0x40(%rsp),%eax
     3c6:	89 03                	mov    %eax,(%rbx)
     3c8:	0f b7 44 24 44       	movzwl 0x44(%rsp),%eax
     3cd:	66 89 43 04          	mov    %ax,0x4(%rbx)
     3d1:	bd 03 00 00 00       	mov    $0x3,%ebp
     3d6:	e9 6c 1b 00 00       	jmp    1f47 <balancer_ingress+0x1f47>
     3db:	b2 02                	mov    $0x2,%dl
     3dd:	b1 01                	mov    $0x1,%cl
     3df:	bd 02 00 00 00       	mov    $0x2,%ebp
  if (protocol == IPPROTO_IPIP) {
     3e4:	3c 10                	cmp    $0x10,%al
     3e6:	0f 8f 62 01 00 00    	jg     54e <balancer_ingress+0x54e>
     3ec:	3c 04                	cmp    $0x4,%al
     3ee:	0f 84 8c 02 00 00    	je     680 <balancer_ingress+0x680>
     3f4:	3c 06                	cmp    $0x6,%al
     3f6:	0f 85 4b 1b 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  tcp = data + off;
     3fc:	48 8d 43 66          	lea    0x66(%rbx),%rax
  if (is_ipv6) {
     400:	84 c9                	test   %cl,%cl
  tcp = data + off;
     402:	49 0f 45 c7          	cmovne %r15,%rax
  if (tcp + 1 > data_end) {
     406:	48 8d 70 14          	lea    0x14(%rax),%rsi
     40a:	4c 39 e6             	cmp    %r12,%rsi
     40d:	0f 87 2f 1b 00 00    	ja     1f42 <balancer_ingress+0x1f42>
  if (tcp->syn) {
     413:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     417:	0f 84 aa 03 00 00    	je     7c7 <balancer_ingress+0x7c7>
    pckt->flags |= F_SYN_SET;
     41d:	88 54 24 3c          	mov    %dl,0x3c(%rsp)
     421:	e9 a1 03 00 00       	jmp    7c7 <balancer_ingress+0x7c7>
      return FURTHER_PROCESSING;
    } else {
      pckt->flow.src = iph->saddr;
     426:	8b 4b 1a             	mov    0x1a(%rbx),%ecx
     429:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
      pckt->flow.dst = iph->daddr;
     42d:	8b 4b 1e             	mov    0x1e(%rbx),%ecx
     430:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
  if (protocol == IPPROTO_ICMPV6) {
     434:	3c 3a                	cmp    $0x3a,%al
     436:	75 44                	jne    47c <balancer_ingress+0x47c>
  if (icmp_hdr + 1 > data_end) {
     438:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
     43c:	4c 39 e0             	cmp    %r12,%rax
     43f:	0f 87 fd 1a 00 00    	ja     1f42 <balancer_ingress+0x1f42>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     445:	41 8a 06             	mov    (%r14),%al
     448:	3c 02                	cmp    $0x2,%al
     44a:	0f 84 fc 06 00 00    	je     b4c <balancer_ingress+0xb4c>
     450:	3c 01                	cmp    $0x1,%al
     452:	0f 84 2d 07 00 00    	je     b85 <balancer_ingress+0xb85>
     458:	bd 02 00 00 00       	mov    $0x2,%ebp
     45d:	3c 80                	cmp    $0x80,%al
     45f:	0f 85 e2 1a 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     465:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     469:	bd 01 00 00 00       	mov    $0x1,%ebp
       sizeof(struct icmp6hdr)) > data_end) {
     46e:	4c 39 e0             	cmp    %r12,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     471:	0f 87 d0 1a 00 00    	ja     1f47 <balancer_ingress+0x1f47>
     477:	e9 9e fd ff ff       	jmp    21a <balancer_ingress+0x21a>
     47c:	b2 02                	mov    $0x2,%dl
     47e:	b1 01                	mov    $0x1,%cl
     480:	bd 02 00 00 00       	mov    $0x2,%ebp
     485:	3c 10                	cmp    $0x10,%al
     487:	0f 8f 48 07 00 00    	jg     bd5 <balancer_ingress+0xbd5>
     48d:	3c 04                	cmp    $0x4,%al
     48f:	0f 84 5d 05 00 00    	je     9f2 <balancer_ingress+0x9f2>
     495:	3c 06                	cmp    $0x6,%al
     497:	0f 85 aa 1a 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  tcp = data + off;
     49d:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
  if (is_ipv6) {
     4a1:	84 c9                	test   %cl,%cl
  tcp = data + off;
     4a3:	49 0f 45 c6          	cmovne %r14,%rax
  if (tcp + 1 > data_end) {
     4a7:	48 8d 70 14          	lea    0x14(%rax),%rsi
     4ab:	4c 39 e6             	cmp    %r12,%rsi
     4ae:	0f 87 8e 1a 00 00    	ja     1f42 <balancer_ingress+0x1f42>
  if (tcp->syn) {
     4b4:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     4b8:	0f 84 72 08 00 00    	je     d30 <balancer_ingress+0xd30>
    pckt->flags |= F_SYN_SET;
     4be:	88 54 24 3c          	mov    %dl,0x3c(%rsp)
     4c2:	e9 69 08 00 00       	jmp    d30 <balancer_ingress+0xd30>
     4c7:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     4ce:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     4d1:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     4d8:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     4df:	79 b3 
    if (!icmp_ptb_v6_stats) {
     4e1:	48 85 c0             	test   %rax,%rax
     4e4:	0f 84 58 1a 00 00    	je     1f42 <balancer_ingress+0x1f42>
    icmp_ptb_v6_stats->v1 += 1;
     4ea:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4ee:	8b 4b 3a             	mov    0x3a(%rbx),%ecx
     4f1:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     4f3:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     4f9:	77 05                	ja     500 <balancer_ingress+0x500>
      icmp_ptb_v6_stats->v2 += 1;
     4fb:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     500:	48 8d 43 66          	lea    0x66(%rbx),%rax
     504:	4c 39 e0             	cmp    %r12,%rax
     507:	0f 87 35 1a 00 00    	ja     1f42 <balancer_ingress+0x1f42>
  pckt->flow.proto = ip6h->nexthdr;
     50d:	8a 43 44             	mov    0x44(%rbx),%al
     510:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     514:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     519:	48 8b 4b 56          	mov    0x56(%rbx),%rcx
     51d:	48 8b 53 5e          	mov    0x5e(%rbx),%rdx
     521:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
     526:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     52b:	48 8b 4b 46          	mov    0x46(%rbx),%rcx
     52f:	48 8b 53 4e          	mov    0x4e(%rbx),%rdx
     533:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
     538:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
     53d:	b2 03                	mov    $0x3,%dl
     53f:	31 c9                	xor    %ecx,%ecx
     541:	bd 02 00 00 00       	mov    $0x2,%ebp
     546:	3c 10                	cmp    $0x10,%al
     548:	0f 8e 9e fe ff ff    	jle    3ec <balancer_ingress+0x3ec>
     54e:	3c 11                	cmp    $0x11,%al
     550:	0f 84 5a 02 00 00    	je     7b0 <balancer_ingress+0x7b0>
     556:	3c 29                	cmp    $0x29,%al
     558:	0f 85 e9 19 00 00    	jne    1f47 <balancer_ingress+0x1f47>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     55e:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     563:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     568:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     56d:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
#define BPF_MAP_OPS_INLINE(ret_type, decl_args, type_args, call_params, name, pref)	\
	__attribute__((__always_inline__)) static inline ret_type pref##bpf_##name decl_args {	\
		return ((ret_type (*) type_args) (access_ptr_at_u64(access_ptr_at_u64(map, BPF_MAP_OPS_OFF), name##_off))) call_params;	\
	}

BPF_MAP_OPS_INLINE(void*,
     572:	48 bf 00 d0 0c 05 81 	movabs $0xffff8881050cd000,%rdi
     579:	88 ff ff 
     57c:	48 8b 07             	mov    (%rdi),%rax
     57f:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     584:	ff 50 60             	call   *0x60(%rax)
     587:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     58a:	48 85 c0             	test   %rax,%rax
     58d:	74 27                	je     5b6 <balancer_ingress+0x5b6>
     58f:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     596:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     599:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     5a0:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     5a7:	79 b3 
    if (!data_stats) {
     5a9:	48 85 c0             	test   %rax,%rax
     5ac:	0f 84 90 19 00 00    	je     1f42 <balancer_ingress+0x1f42>
    data_stats->v1 += 1;
     5b2:	48 83 00 01          	addq   $0x1,(%rax)
decrement_ttl(void* data, void* data_end, int offset, bool is_ipv6) {
  struct iphdr* iph;
  struct ipv6hdr* ip6h;

  if (is_ipv6) {
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5b6:	48 8d 43 5e          	lea    0x5e(%rbx),%rax
     5ba:	bd 01 00 00 00       	mov    $0x1,%ebp
     5bf:	41 bf 01 00 00 00    	mov    $0x1,%r15d
     5c5:	4c 39 e0             	cmp    %r12,%rax
     5c8:	77 13                	ja     5dd <balancer_ingress+0x5dd>
      return XDP_DROP;
    }
    ip6h = (struct ipv6hdr*)(data + offset);
    if (!--ip6h->hop_limit) {
     5ca:	80 43 3d ff          	addb   $0xff,0x3d(%rbx)
     5ce:	b8 01 00 00 00       	mov    $0x1,%eax
     5d3:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
     5d9:	44 0f 44 f8          	cmove  %eax,%r15d
decap_v6(struct xdp_md* xdp, void** data, void** data_end, bool inner_v4) {
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  old_eth = *data;
  new_eth = *data + sizeof(struct ipv6hdr);
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5dd:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     5e1:	66 89 43 32          	mov    %ax,0x32(%rbx)
     5e5:	8b 43 06             	mov    0x6(%rbx),%eax
     5e8:	89 43 2e             	mov    %eax,0x2e(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     5eb:	8b 03                	mov    (%rbx),%eax
     5ed:	89 43 28             	mov    %eax,0x28(%rbx)
     5f0:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     5f4:	66 89 43 2c          	mov    %ax,0x2c(%rbx)
     5f8:	66 c7 43 34 86 dd    	movw   $0xdd86,0x34(%rbx)
     5fe:	48 c7 c0 20 5c c3 af 	mov    $0xffffffffafc35c20,%rax
  if (inner_v4) {
    new_eth->h_proto = BE_ETH_P_IP;
  } else {
    new_eth->h_proto = BE_ETH_P_IPV6;
  }
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     605:	4c 89 ef             	mov    %r13,%rdi
     608:	be 28 00 00 00       	mov    $0x28,%esi
     60d:	ff d0                	call   *%rax
     60f:	85 c0                	test   %eax,%eax
     611:	0f 85 30 19 00 00    	jne    1f47 <balancer_ingress+0x1f47>
     617:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     61e:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     621:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     628:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
     62f:	79 b3 
  if (!data_stats) {
     631:	48 85 c9             	test   %rcx,%rcx
     634:	0f 84 0d 19 00 00    	je     1f47 <balancer_ingress+0x1f47>
     63a:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     63f:	45 85 ff             	test   %r15d,%r15d
     642:	bd 02 00 00 00       	mov    $0x2,%ebp
     647:	41 0f 49 ef          	cmovns %r15d,%ebp
  if (decap_dst_flags) {
     64b:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     64e:	0f 84 f3 18 00 00    	je     1f47 <balancer_ingress+0x1f47>
     654:	45 85 ff             	test   %r15d,%r15d
     657:	0f 89 ea 18 00 00    	jns    1f47 <balancer_ingress+0x1f47>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     65d:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     664:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     66b:	79 b3 
    if (xpop_stats_data) {
     66d:	48 85 c0             	test   %rax,%rax
     670:	0f 84 af 04 00 00    	je     b25 <balancer_ingress+0xb25>
     676:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
     67b:	e9 a5 04 00 00       	jmp    b25 <balancer_ingress+0xb25>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     680:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     685:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     68a:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     68f:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
     694:	48 bf 00 d0 0c 05 81 	movabs $0xffff8881050cd000,%rdi
     69b:	88 ff ff 
     69e:	48 8b 07             	mov    (%rdi),%rax
     6a1:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     6a6:	ff 50 60             	call   *0x60(%rax)
     6a9:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     6ac:	48 85 c0             	test   %rax,%rax
     6af:	74 27                	je     6d8 <balancer_ingress+0x6d8>
     6b1:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     6b8:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     6bb:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     6c2:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     6c9:	79 b3 
    if (!data_stats) {
     6cb:	48 85 c0             	test   %rax,%rax
     6ce:	0f 84 6e 18 00 00    	je     1f42 <balancer_ingress+0x1f42>
    data_stats->v1 += 1;
     6d4:	48 83 00 01          	addq   $0x1,(%rax)
      // ttl 0
      return XDP_DROP;
    }
  } else {
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     6d8:	48 8d 43 4a          	lea    0x4a(%rbx),%rax
     6dc:	bd 01 00 00 00       	mov    $0x1,%ebp
     6e1:	41 bf 01 00 00 00    	mov    $0x1,%r15d
     6e7:	4c 39 e0             	cmp    %r12,%rax
     6ea:	77 26                	ja     712 <balancer_ingress+0x712>
      return XDP_DROP;
    }
    iph = (struct iphdr*)(data + offset);
    __u32 csum;
    csum = iph->check + 0x0001;
     6ec:	0f b7 43 40          	movzwl 0x40(%rbx),%eax
     6f0:	8d 48 01             	lea    0x1(%rax),%ecx
    iph->check = (csum & 0xffff) + (csum >> 16);
     6f3:	c1 e9 10             	shr    $0x10,%ecx
     6f6:	01 c8                	add    %ecx,%eax
     6f8:	83 c0 01             	add    $0x1,%eax
     6fb:	66 89 43 40          	mov    %ax,0x40(%rbx)
    if (!--iph->ttl) {
     6ff:	80 43 3e ff          	addb   $0xff,0x3e(%rbx)
     703:	b8 01 00 00 00       	mov    $0x1,%eax
     708:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
     70e:	44 0f 44 f8          	cmove  %eax,%r15d
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     712:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     716:	66 89 43 32          	mov    %ax,0x32(%rbx)
     71a:	8b 43 06             	mov    0x6(%rbx),%eax
     71d:	89 43 2e             	mov    %eax,0x2e(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     720:	8b 03                	mov    (%rbx),%eax
     722:	89 43 28             	mov    %eax,0x28(%rbx)
     725:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     729:	66 89 43 2c          	mov    %ax,0x2c(%rbx)
     72d:	66 c7 43 34 08 00    	movw   $0x8,0x34(%rbx)
     733:	48 c7 c0 20 5c c3 af 	mov    $0xffffffffafc35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     73a:	4c 89 ef             	mov    %r13,%rdi
     73d:	be 28 00 00 00       	mov    $0x28,%esi
     742:	ff d0                	call   *%rax
     744:	85 c0                	test   %eax,%eax
     746:	0f 85 fb 17 00 00    	jne    1f47 <balancer_ingress+0x1f47>
     74c:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     753:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     756:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     75d:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
     764:	79 b3 
  if (!data_stats) {
     766:	48 85 c9             	test   %rcx,%rcx
     769:	0f 84 d8 17 00 00    	je     1f47 <balancer_ingress+0x1f47>
     76f:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     774:	45 85 ff             	test   %r15d,%r15d
     777:	bd 02 00 00 00       	mov    $0x2,%ebp
     77c:	41 0f 49 ef          	cmovns %r15d,%ebp
  if (decap_dst_flags) {
     780:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     783:	0f 84 be 17 00 00    	je     1f47 <balancer_ingress+0x1f47>
     789:	45 85 ff             	test   %r15d,%r15d
     78c:	0f 89 b5 17 00 00    	jns    1f47 <balancer_ingress+0x1f47>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     792:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     799:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     7a0:	79 b3 
    if (xpop_stats_data) {
     7a2:	48 85 c0             	test   %rax,%rax
     7a5:	0f 85 76 03 00 00    	jne    b21 <balancer_ingress+0xb21>
     7ab:	e9 75 03 00 00       	jmp    b25 <balancer_ingress+0xb25>
  udp = data + off;
     7b0:	48 8d 43 66          	lea    0x66(%rbx),%rax
  if (is_ipv6) {
     7b4:	84 c9                	test   %cl,%cl
  udp = data + off;
     7b6:	49 0f 45 c7          	cmovne %r15,%rax
  if (udp + 1 > data_end) {
     7ba:	48 8d 50 08          	lea    0x8(%rax),%rdx
     7be:	4c 39 e2             	cmp    %r12,%rdx
     7c1:	0f 87 7b 17 00 00    	ja     1f42 <balancer_ingress+0x1f42>
     7c7:	84 c9                	test   %cl,%cl
     7c9:	89 7c 24 5c          	mov    %edi,0x5c(%rsp)
     7cd:	0f 84 83 00 00 00    	je     856 <balancer_ingress+0x856>
     7d3:	0f b7 10             	movzwl (%rax),%edx
     7d6:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     7db:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     7e0:	48 83 c0 02          	add    $0x2,%rax
     7e4:	eb 7e                	jmp    864 <balancer_ingress+0x864>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     7e6:	80 7b 37 04          	cmpb   $0x4,0x37(%rbx)
     7ea:	75 32                	jne    81e <balancer_ingress+0x81e>
     7ec:	48 b9 00 40 77 3d 81 	movabs $0xffff88813d774000,%rcx
     7f3:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     7f6:	48 8b 89 68 11 00 00 	mov    0x1168(%rcx),%rcx
     7fd:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
     804:	79 b3 
    if (!icmp_ptb_v4_stats) {
     806:	48 85 c9             	test   %rcx,%rcx
     809:	0f 84 33 17 00 00    	je     1f42 <balancer_ingress+0x1f42>
    icmp_ptb_v4_stats->v1 += 1;
     80f:	48 83 01 01          	addq   $0x1,(%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     813:	80 7b 3c 04          	cmpb   $0x4,0x3c(%rbx)
     817:	77 05                	ja     81e <balancer_ingress+0x81e>
      icmp_ptb_v4_stats->v2 += 1;
     819:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (iph + 1 > data_end) {
     81e:	48 8d 4b 52          	lea    0x52(%rbx),%rcx
     822:	4c 39 e1             	cmp    %r12,%rcx
     825:	0f 87 17 17 00 00    	ja     1f42 <balancer_ingress+0x1f42>
  if (iph->ihl != 5) {
     82b:	8a 00                	mov    (%rax),%al
     82d:	24 0f                	and    $0xf,%al
     82f:	3c 05                	cmp    $0x5,%al
     831:	0f 85 0b 17 00 00    	jne    1f42 <balancer_ingress+0x1f42>
  pckt->flow.proto = iph->protocol;
     837:	8a 43 47             	mov    0x47(%rbx),%al
     83a:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     83e:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  pckt->flow.src = iph->daddr;
     843:	8b 4b 4e             	mov    0x4e(%rbx),%ecx
     846:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
  pckt->flow.dst = iph->saddr;
     84a:	8b 4b 4a             	mov    0x4a(%rbx),%ecx
     84d:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
     851:	e9 e7 fc ff ff       	jmp    53d <balancer_ingress+0x53d>
     856:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     85a:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     85f:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     864:	0f b7 00             	movzwl (%rax),%eax
     867:	66 89 41 02          	mov    %ax,0x2(%rcx)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     86b:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     870:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     875:	48 89 4c 24 68       	mov    %rcx,0x68(%rsp)
     87a:	48 89 44 24 60       	mov    %rax,0x60(%rsp)
  vip.port = pckt.flow.port16[1];
     87f:	0f b7 44 24 32       	movzwl 0x32(%rsp),%eax
     884:	66 89 44 24 70       	mov    %ax,0x70(%rsp)
  vip.proto = pckt.flow.proto;
     889:	8a 44 24 34          	mov    0x34(%rsp),%al
     88d:	88 44 24 72          	mov    %al,0x72(%rsp)
     891:	49 be 00 c8 0c 05 81 	movabs $0xffff8881050cc800,%r14
     898:	88 ff ff 
     89b:	49 8b 06             	mov    (%r14),%rax
     89e:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
     8a3:	4c 89 f7             	mov    %r14,%rdi
     8a6:	ff 50 60             	call   *0x60(%rax)
     8a9:	48 89 c7             	mov    %rax,%rdi
  if (!vip_info) {
     8ac:	48 85 c0             	test   %rax,%rax
     8af:	0f 84 07 01 00 00    	je     9bc <balancer_ingress+0x9bc>
  if (data_end - data > MAX_PCKT_SIZE) {
     8b5:	4c 89 e0             	mov    %r12,%rax
     8b8:	48 29 d8             	sub    %rbx,%rax
     8bb:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     8c1:	0f 8f 7b 16 00 00    	jg     1f42 <balancer_ingress+0x1f42>
     8c7:	48 ba 00 40 77 3d 81 	movabs $0xffff88813d774000,%rdx
     8ce:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8d1:	4c 8b b2 00 11 00 00 	mov    0x1100(%rdx),%r14
     8d8:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffb3795028,%r14
     8df:	79 b3 
  if (!data_stats) {
     8e1:	4d 85 f6             	test   %r14,%r14
     8e4:	0f 84 58 16 00 00    	je     1f42 <balancer_ingress+0x1f42>
  data_stats->v1 += 1;
     8ea:	49 83 06 01          	addq   $0x1,(%r14)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     8ee:	f6 07 01             	testb  $0x1,(%rdi)
     8f1:	74 07                	je     8fa <balancer_ingress+0x8fa>
    pckt.flow.port16[0] = 0;
     8f3:	66 c7 44 24 30 00 00 	movw   $0x0,0x30(%rsp)
  vip_num = vip_info->vip_num;
     8fa:	8b 77 04             	mov    0x4(%rdi),%esi
     8fd:	48 c7 c0 34 50 79 b3 	mov    $0xffffffffb3795034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     904:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     90b:	79 b3 
     90d:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     910:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     915:	0f 84 1b 05 00 00    	je     e36 <balancer_ingress+0xe36>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     91b:	48 8b 82 18 11 00 00 	mov    0x1118(%rdx),%rax
     922:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     929:	79 b3 
    if (!lru_stats) {
     92b:	48 85 c0             	test   %rax,%rax
     92e:	0f 84 0e 16 00 00    	je     1f42 <balancer_ingress+0x1f42>
    lru_stats->v1 += 1;
     934:	48 83 00 01          	addq   $0x1,(%rax)
     938:	48 b8 00 f8 0c 05 81 	movabs $0xffff8881050cf800,%rax
     93f:	88 ff ff 
     942:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
     947:	e9 0c 05 00 00       	jmp    e58 <balancer_ingress+0xe58>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     94c:	80 7b 23 04          	cmpb   $0x4,0x23(%rbx)
     950:	75 32                	jne    984 <balancer_ingress+0x984>
     952:	48 b9 00 40 77 3d 81 	movabs $0xffff88813d774000,%rcx
     959:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     95c:	48 8b 89 68 11 00 00 	mov    0x1168(%rcx),%rcx
     963:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
     96a:	79 b3 
    if (!icmp_ptb_v4_stats) {
     96c:	48 85 c9             	test   %rcx,%rcx
     96f:	0f 84 cd 15 00 00    	je     1f42 <balancer_ingress+0x1f42>
    icmp_ptb_v4_stats->v1 += 1;
     975:	48 83 01 01          	addq   $0x1,(%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     979:	80 7b 28 04          	cmpb   $0x4,0x28(%rbx)
     97d:	77 05                	ja     984 <balancer_ingress+0x984>
      icmp_ptb_v4_stats->v2 += 1;
     97f:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (iph + 1 > data_end) {
     984:	48 8d 4b 3e          	lea    0x3e(%rbx),%rcx
     988:	4c 39 e1             	cmp    %r12,%rcx
     98b:	0f 87 b1 15 00 00    	ja     1f42 <balancer_ingress+0x1f42>
  if (iph->ihl != 5) {
     991:	8a 00                	mov    (%rax),%al
     993:	24 0f                	and    $0xf,%al
     995:	3c 05                	cmp    $0x5,%al
     997:	0f 85 a5 15 00 00    	jne    1f42 <balancer_ingress+0x1f42>
  pckt->flow.proto = iph->protocol;
     99d:	8a 43 33             	mov    0x33(%rbx),%al
     9a0:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     9a4:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  pckt->flow.src = iph->daddr;
     9a9:	8b 4b 3a             	mov    0x3a(%rbx),%ecx
     9ac:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
  pckt->flow.dst = iph->saddr;
     9b0:	8b 4b 36             	mov    0x36(%rbx),%ecx
     9b3:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
     9b7:	e9 08 02 00 00       	jmp    bc4 <balancer_ingress+0xbc4>
    vip.port = 0;
     9bc:	66 c7 44 24 70 00 00 	movw   $0x0,0x70(%rsp)
     9c3:	49 8b 06             	mov    (%r14),%rax
     9c6:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
     9cb:	4c 89 f7             	mov    %r14,%rdi
     9ce:	ff 50 60             	call   *0x60(%rax)
    if (!vip_info) {
     9d1:	48 85 c0             	test   %rax,%rax
     9d4:	0f 84 6d 15 00 00    	je     1f47 <balancer_ingress+0x1f47>
     9da:	48 89 c7             	mov    %rax,%rdi
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     9dd:	f6 00 88             	testb  $0x88,(%rax)
     9e0:	0f 85 cf fe ff ff    	jne    8b5 <balancer_ingress+0x8b5>
      pckt.flow.port16[1] = 0;
     9e6:	66 c7 44 24 32 00 00 	movw   $0x0,0x32(%rsp)
     9ed:	e9 c3 fe ff ff       	jmp    8b5 <balancer_ingress+0x8b5>
  struct address dst_addr = {};
     9f2:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%rsp)
     9f9:	00 
     9fa:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
     a01:	00 00 
    dst_addr.addr = pckt->flow.dst;
     a03:	8b 44 24 20          	mov    0x20(%rsp),%eax
     a07:	89 44 24 40          	mov    %eax,0x40(%rsp)
     a0b:	48 bf 00 d0 0c 05 81 	movabs $0xffff8881050cd000,%rdi
     a12:	88 ff ff 
     a15:	48 8b 07             	mov    (%rdi),%rax
     a18:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     a1d:	ff 50 60             	call   *0x60(%rax)
     a20:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     a23:	48 85 c0             	test   %rax,%rax
     a26:	74 27                	je     a4f <balancer_ingress+0xa4f>
     a28:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     a2f:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a32:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     a39:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     a40:	79 b3 
    if (!data_stats) {
     a42:	48 85 c0             	test   %rax,%rax
     a45:	0f 84 f7 14 00 00    	je     1f42 <balancer_ingress+0x1f42>
    data_stats->v1 += 1;
     a4b:	48 83 00 01          	addq   $0x1,(%rax)
     a4f:	48 8d 43 14          	lea    0x14(%rbx),%rax
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     a53:	48 8d 4b 36          	lea    0x36(%rbx),%rcx
     a57:	bd 01 00 00 00       	mov    $0x1,%ebp
     a5c:	41 bf 01 00 00 00    	mov    $0x1,%r15d
     a62:	4c 39 e1             	cmp    %r12,%rcx
     a65:	77 26                	ja     a8d <balancer_ingress+0xa8d>
    csum = iph->check + 0x0001;
     a67:	0f b7 4b 2c          	movzwl 0x2c(%rbx),%ecx
     a6b:	8d 51 01             	lea    0x1(%rcx),%edx
    iph->check = (csum & 0xffff) + (csum >> 16);
     a6e:	c1 ea 10             	shr    $0x10,%edx
     a71:	01 d1                	add    %edx,%ecx
     a73:	83 c1 01             	add    $0x1,%ecx
     a76:	66 89 4b 2c          	mov    %cx,0x2c(%rbx)
    if (!--iph->ttl) {
     a7a:	80 43 2a ff          	addb   $0xff,0x2a(%rbx)
     a7e:	b9 01 00 00 00       	mov    $0x1,%ecx
     a83:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
     a89:	44 0f 44 f9          	cmove  %ecx,%r15d
decap_v4(struct xdp_md* xdp, void** data, void** data_end) {
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  old_eth = *data;
  new_eth = *data + sizeof(struct iphdr);
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     a8d:	0f b7 4b 0a          	movzwl 0xa(%rbx),%ecx
     a91:	66 89 4b 1e          	mov    %cx,0x1e(%rbx)
     a95:	8b 4b 06             	mov    0x6(%rbx),%ecx
     a98:	89 4b 1a             	mov    %ecx,0x1a(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     a9b:	0f b7 4b 04          	movzwl 0x4(%rbx),%ecx
     a9f:	66 89 48 04          	mov    %cx,0x4(%rax)
     aa3:	8b 0b                	mov    (%rbx),%ecx
     aa5:	89 08                	mov    %ecx,(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
     aa7:	66 c7 43 20 08 00    	movw   $0x8,0x20(%rbx)
     aad:	48 c7 c0 20 5c c3 af 	mov    $0xffffffffafc35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     ab4:	4c 89 ef             	mov    %r13,%rdi
     ab7:	be 14 00 00 00       	mov    $0x14,%esi
     abc:	ff d0                	call   *%rax
     abe:	85 c0                	test   %eax,%eax
     ac0:	0f 85 81 14 00 00    	jne    1f47 <balancer_ingress+0x1f47>
     ac6:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     acd:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     ad0:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     ad7:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
     ade:	79 b3 
  if (!data_stats) {
     ae0:	48 85 c9             	test   %rcx,%rcx
     ae3:	0f 84 5e 14 00 00    	je     1f47 <balancer_ingress+0x1f47>
     ae9:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     aee:	45 85 ff             	test   %r15d,%r15d
     af1:	bd 02 00 00 00       	mov    $0x2,%ebp
     af6:	41 0f 49 ef          	cmovns %r15d,%ebp
  if (decap_dst_flags) {
     afa:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     afd:	0f 84 44 14 00 00    	je     1f47 <balancer_ingress+0x1f47>
     b03:	45 85 ff             	test   %r15d,%r15d
     b06:	0f 89 3b 14 00 00    	jns    1f47 <balancer_ingress+0x1f47>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b0c:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     b13:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     b1a:	79 b3 
    if (xpop_stats_data) {
     b1c:	48 85 c0             	test   %rax,%rax
     b1f:	74 04                	je     b25 <balancer_ingress+0xb25>
     b21:	48 83 00 01          	addq   $0x1,(%rax)
     b25:	48 b8 00 f8 fd 6d 81 	movabs $0xffff88816dfdf800,%rax
     b2c:	88 ff ff 
     b2f:	48 8b 88 00 01 00 00 	mov    0x100(%rax),%rcx
     b36:	48 85 c9             	test   %rcx,%rcx
     b39:	0f 84 c5 03 00 00    	je     f04 <balancer_ingress+0xf04>
     b3f:	4c 89 ef             	mov    %r13,%rdi
     b42:	ff 51 30             	call   *0x30(%rcx)
     b45:	89 c5                	mov    %eax,%ebp
     b47:	e9 fb 13 00 00       	jmp    1f47 <balancer_ingress+0x1f47>
     b4c:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     b53:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     b56:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     b5d:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     b64:	79 b3 
    if (!icmp_ptb_v6_stats) {
     b66:	48 85 c0             	test   %rax,%rax
     b69:	0f 84 d3 13 00 00    	je     1f42 <balancer_ingress+0x1f42>
    icmp_ptb_v6_stats->v1 += 1;
     b6f:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     b73:	8b 4b 26             	mov    0x26(%rbx),%ecx
     b76:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     b78:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     b7e:	77 05                	ja     b85 <balancer_ingress+0xb85>
      icmp_ptb_v6_stats->v2 += 1;
     b80:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     b85:	48 8d 43 52          	lea    0x52(%rbx),%rax
     b89:	4c 39 e0             	cmp    %r12,%rax
     b8c:	0f 87 b0 13 00 00    	ja     1f42 <balancer_ingress+0x1f42>
     b92:	48 8d 4c 24 20       	lea    0x20(%rsp),%rcx
  pckt->flow.proto = ip6h->nexthdr;
     b97:	8a 43 30             	mov    0x30(%rbx),%al
     b9a:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     b9e:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     ba3:	48 8b 53 42          	mov    0x42(%rbx),%rdx
     ba7:	48 8b 73 4a          	mov    0x4a(%rbx),%rsi
     bab:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
     bb0:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     bb5:	48 8b 53 32          	mov    0x32(%rbx),%rdx
     bb9:	48 8b 73 3a          	mov    0x3a(%rbx),%rsi
     bbd:	48 89 11             	mov    %rdx,(%rcx)
     bc0:	48 89 71 08          	mov    %rsi,0x8(%rcx)
     bc4:	b2 03                	mov    $0x3,%dl
     bc6:	31 c9                	xor    %ecx,%ecx
     bc8:	bd 02 00 00 00       	mov    $0x2,%ebp
  if (protocol == IPPROTO_IPIP) {
     bcd:	3c 10                	cmp    $0x10,%al
     bcf:	0f 8e b8 f8 ff ff    	jle    48d <balancer_ingress+0x48d>
     bd5:	3c 11                	cmp    $0x11,%al
     bd7:	0f 84 3c 01 00 00    	je     d19 <balancer_ingress+0xd19>
     bdd:	3c 29                	cmp    $0x29,%al
     bdf:	0f 85 62 13 00 00    	jne    1f47 <balancer_ingress+0x1f47>
  struct address dst_addr = {};
     be5:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%rsp)
     bec:	00 
     bed:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
     bf4:	00 00 
    dst_addr.addr = pckt->flow.dst;
     bf6:	8b 44 24 20          	mov    0x20(%rsp),%eax
     bfa:	89 44 24 40          	mov    %eax,0x40(%rsp)
     bfe:	48 bf 00 d0 0c 05 81 	movabs $0xffff8881050cd000,%rdi
     c05:	88 ff ff 
     c08:	48 8b 07             	mov    (%rdi),%rax
     c0b:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     c10:	ff 50 60             	call   *0x60(%rax)
     c13:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     c16:	48 85 c0             	test   %rax,%rax
     c19:	74 27                	je     c42 <balancer_ingress+0xc42>
     c1b:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     c22:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c25:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     c2c:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     c33:	79 b3 
    if (!data_stats) {
     c35:	48 85 c0             	test   %rax,%rax
     c38:	0f 84 04 13 00 00    	je     1f42 <balancer_ingress+0x1f42>
    data_stats->v1 += 1;
     c3e:	48 83 00 01          	addq   $0x1,(%rax)
    if ((*data + offset) > *data_end) {
     c42:	48 8d 43 36          	lea    0x36(%rbx),%rax
     c46:	bd 01 00 00 00       	mov    $0x1,%ebp
     c4b:	4c 39 e0             	cmp    %r12,%rax
     c4e:	0f 87 f3 12 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     c54:	48 8d 43 5e          	lea    0x5e(%rbx),%rax
     c58:	bd 01 00 00 00       	mov    $0x1,%ebp
     c5d:	41 bf 01 00 00 00    	mov    $0x1,%r15d
     c63:	4c 39 e0             	cmp    %r12,%rax
     c66:	77 13                	ja     c7b <balancer_ingress+0xc7b>
    if (!--ip6h->hop_limit) {
     c68:	80 43 3d ff          	addb   $0xff,0x3d(%rbx)
     c6c:	b8 01 00 00 00       	mov    $0x1,%eax
     c71:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
     c77:	44 0f 44 f8          	cmove  %eax,%r15d
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     c7b:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     c7f:	66 89 43 32          	mov    %ax,0x32(%rbx)
     c83:	8b 43 06             	mov    0x6(%rbx),%eax
     c86:	89 43 2e             	mov    %eax,0x2e(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     c89:	8b 03                	mov    (%rbx),%eax
     c8b:	89 43 28             	mov    %eax,0x28(%rbx)
     c8e:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     c92:	66 89 43 2c          	mov    %ax,0x2c(%rbx)
     c96:	66 c7 43 34 86 dd    	movw   $0xdd86,0x34(%rbx)
     c9c:	48 c7 c0 20 5c c3 af 	mov    $0xffffffffafc35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     ca3:	4c 89 ef             	mov    %r13,%rdi
     ca6:	be 28 00 00 00       	mov    $0x28,%esi
     cab:	ff d0                	call   *%rax
     cad:	85 c0                	test   %eax,%eax
     caf:	0f 85 92 12 00 00    	jne    1f47 <balancer_ingress+0x1f47>
     cb5:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     cbc:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     cbf:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     cc6:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
     ccd:	79 b3 
  if (!data_stats) {
     ccf:	48 85 c9             	test   %rcx,%rcx
     cd2:	0f 84 6f 12 00 00    	je     1f47 <balancer_ingress+0x1f47>
     cd8:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     cdd:	45 85 ff             	test   %r15d,%r15d
     ce0:	bd 02 00 00 00       	mov    $0x2,%ebp
     ce5:	41 0f 49 ef          	cmovns %r15d,%ebp
  if (decap_dst_flags) {
     ce9:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     cec:	0f 84 55 12 00 00    	je     1f47 <balancer_ingress+0x1f47>
     cf2:	45 85 ff             	test   %r15d,%r15d
     cf5:	0f 89 4c 12 00 00    	jns    1f47 <balancer_ingress+0x1f47>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     cfb:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     d02:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     d09:	79 b3 
    if (xpop_stats_data) {
     d0b:	48 85 c0             	test   %rax,%rax
     d0e:	0f 85 62 f9 ff ff    	jne    676 <balancer_ingress+0x676>
     d14:	e9 0c fe ff ff       	jmp    b25 <balancer_ingress+0xb25>
  udp = data + off;
     d19:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
  if (is_ipv6) {
     d1d:	84 c9                	test   %cl,%cl
  udp = data + off;
     d1f:	49 0f 45 c6          	cmovne %r14,%rax
  if (udp + 1 > data_end) {
     d23:	48 8d 50 08          	lea    0x8(%rax),%rdx
     d27:	4c 39 e2             	cmp    %r12,%rdx
     d2a:	0f 87 12 12 00 00    	ja     1f42 <balancer_ingress+0x1f42>
     d30:	84 c9                	test   %cl,%cl
     d32:	66 89 7c 24 5c       	mov    %di,0x5c(%rsp)
     d37:	74 13                	je     d4c <balancer_ingress+0xd4c>
     d39:	0f b7 10             	movzwl (%rax),%edx
     d3c:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     d41:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     d46:	48 83 c0 02          	add    $0x2,%rax
     d4a:	eb 0e                	jmp    d5a <balancer_ingress+0xd5a>
     d4c:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     d50:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     d55:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     d5a:	0f b7 00             	movzwl (%rax),%eax
     d5d:	66 89 41 02          	mov    %ax,0x2(%rcx)
    vip.vip = pckt.flow.dst;
     d61:	8b 44 24 20          	mov    0x20(%rsp),%eax
     d65:	89 44 24 60          	mov    %eax,0x60(%rsp)
  vip.port = pckt.flow.port16[1];
     d69:	0f b7 44 24 32       	movzwl 0x32(%rsp),%eax
     d6e:	66 89 44 24 70       	mov    %ax,0x70(%rsp)
  vip.proto = pckt.flow.proto;
     d73:	8a 44 24 34          	mov    0x34(%rsp),%al
     d77:	88 44 24 72          	mov    %al,0x72(%rsp)
     d7b:	49 bf 00 c8 0c 05 81 	movabs $0xffff8881050cc800,%r15
     d82:	88 ff ff 
     d85:	49 8b 07             	mov    (%r15),%rax
     d88:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
     d8d:	4c 89 ff             	mov    %r15,%rdi
     d90:	ff 50 60             	call   *0x60(%rax)
     d93:	48 89 c7             	mov    %rax,%rdi
  if (!vip_info) {
     d96:	48 85 c0             	test   %rax,%rax
     d99:	0f 84 2f 01 00 00    	je     ece <balancer_ingress+0xece>
  if (data_end - data > MAX_PCKT_SIZE) {
     d9f:	4c 89 e0             	mov    %r12,%rax
     da2:	48 29 d8             	sub    %rbx,%rax
     da5:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     dab:	0f 8f 91 11 00 00    	jg     1f42 <balancer_ingress+0x1f42>
     db1:	48 ba 00 40 77 3d 81 	movabs $0xffff88813d774000,%rdx
     db8:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     dbb:	4c 8b ba 00 11 00 00 	mov    0x1100(%rdx),%r15
     dc2:	65 4c 03 3c 25 28 50 	add    %gs:0xffffffffb3795028,%r15
     dc9:	79 b3 
  if (!data_stats) {
     dcb:	4d 85 ff             	test   %r15,%r15
     dce:	0f 84 6e 11 00 00    	je     1f42 <balancer_ingress+0x1f42>
  data_stats->v1 += 1;
     dd4:	49 83 07 01          	addq   $0x1,(%r15)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     dd8:	f6 07 01             	testb  $0x1,(%rdi)
     ddb:	74 07                	je     de4 <balancer_ingress+0xde4>
    pckt.flow.port16[0] = 0;
     ddd:	66 c7 44 24 30 00 00 	movw   $0x0,0x30(%rsp)
  vip_num = vip_info->vip_num;
     de4:	8b 77 04             	mov    0x4(%rdi),%esi
     de7:	48 c7 c0 34 50 79 b3 	mov    $0xffffffffb3795034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     dee:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     df5:	79 b3 
     df7:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     dfa:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     dff:	0f 84 3d 01 00 00    	je     f42 <balancer_ingress+0xf42>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e05:	48 8b 82 18 11 00 00 	mov    0x1118(%rdx),%rax
     e0c:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
     e13:	79 b3 
    if (!lru_stats) {
     e15:	48 85 c0             	test   %rax,%rax
     e18:	0f 84 24 11 00 00    	je     1f42 <balancer_ingress+0x1f42>
    lru_stats->v1 += 1;
     e1e:	48 83 00 01          	addq   $0x1,(%rax)
     e22:	48 b8 00 f8 0c 05 81 	movabs $0xffff8881050cf800,%rax
     e29:	88 ff ff 
     e2c:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
     e31:	e9 2e 01 00 00       	jmp    f64 <balancer_ingress+0xf64>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e36:	89 c0                	mov    %eax,%eax
     e38:	48 b9 00 10 f4 50 81 	movabs $0xffff888150f41000,%rcx
     e3f:	88 ff ff 
     e42:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     e49:	00 
     e4a:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  if (!lru_map) {
     e4f:	48 85 c0             	test   %rax,%rax
     e52:	0f 84 c3 fa ff ff    	je     91b <balancer_ingress+0x91b>
  if ((vip_info->flags & F_QUIC_VIP)) {
     e58:	f6 07 04             	testb  $0x4,(%rdi)
     e5b:	0f 84 b7 0a 00 00    	je     1918 <balancer_ingress+0x1918>
    bool is_icmp = (pckt.flags & F_ICMP);
     e61:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
    if (is_icmp) {
     e66:	0f 85 a2 00 00 00    	jne    f0e <balancer_ingress+0xf0e>
     e6c:	48 b8 00 ec fd 6d 81 	movabs $0xffff88816dfdec00,%rax
     e73:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     e76:	48 8b a8 00 01 00 00 	mov    0x100(%rax),%rbp
     e7d:	65 48 03 2c 25 28 50 	add    %gs:0xffffffffb3795028,%rbp
     e84:	79 b3 
      if (!quic_packets_stats) {
     e86:	48 85 ed             	test   %rbp,%rbp
     e89:	0f 84 b3 10 00 00    	je     1f42 <balancer_ingress+0x1f42>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e8f:	48 83 c3 66          	add    $0x66,%rbx
  bool is_icmp = (pckt->flags & F_ICMP);
     e93:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e98:	49 0f 44 df          	cmove  %r15,%rbx
     e9c:	48 8d 43 09          	lea    0x9(%rbx),%rax
     ea0:	4c 39 e0             	cmp    %r12,%rax
     ea3:	0f 87 6a 0a 00 00    	ja     1913 <balancer_ingress+0x1913>
     ea9:	49 89 f7             	mov    %rsi,%r15
     eac:	48 83 c3 08          	add    $0x8,%rbx
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     eb0:	0f b6 0b             	movzbl (%rbx),%ecx
     eb3:	f6 c1 80             	test   $0x80,%cl
     eb6:	0f 85 b0 01 00 00    	jne    106c <balancer_ingress+0x106c>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     ebc:	48 83 c3 09          	add    $0x9,%rbx
     ec0:	4c 39 e3             	cmp    %r12,%rbx
     ec3:	0f 86 d4 02 00 00    	jbe    119d <balancer_ingress+0x119d>
     ec9:	e9 38 0a 00 00       	jmp    1906 <balancer_ingress+0x1906>
    vip.port = 0;
     ece:	66 c7 44 24 70 00 00 	movw   $0x0,0x70(%rsp)
     ed5:	49 8b 07             	mov    (%r15),%rax
     ed8:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
     edd:	4c 89 ff             	mov    %r15,%rdi
     ee0:	ff 50 60             	call   *0x60(%rax)
    if (!vip_info) {
     ee3:	48 85 c0             	test   %rax,%rax
     ee6:	0f 84 5b 10 00 00    	je     1f47 <balancer_ingress+0x1f47>
     eec:	48 89 c7             	mov    %rax,%rdi
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     eef:	f6 00 88             	testb  $0x88,(%rax)
     ef2:	0f 85 a7 fe ff ff    	jne    d9f <balancer_ingress+0xd9f>
      pckt.flow.port16[1] = 0;
     ef8:	66 c7 44 24 32 00 00 	movw   $0x0,0x32(%rsp)
     eff:	e9 9b fe ff ff       	jmp    d9f <balancer_ingress+0xd9f>
     f04:	bd 02 00 00 00       	mov    $0x2,%ebp
     f09:	e9 39 10 00 00       	jmp    1f47 <balancer_ingress+0x1f47>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     f0e:	48 8b aa 58 11 00 00 	mov    0x1158(%rdx),%rbp
     f15:	65 48 03 2c 25 28 50 	add    %gs:0xffffffffb3795028,%rbp
     f1c:	79 b3 
      if (!data_stats) {
     f1e:	48 85 ed             	test   %rbp,%rbp
     f21:	0f 84 1b 10 00 00    	je     1f42 <balancer_ingress+0x1f42>
      data_stats->v1 += 1;
     f27:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     f2c:	8a 43 37             	mov    0x37(%rbx),%al
     f2f:	04 fd                	add    $0xfd,%al
     f31:	3c 01                	cmp    $0x1,%al
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     f33:	0f 87 df 09 00 00    	ja     1918 <balancer_ingress+0x1918>
        data_stats->v2 += 1;
     f39:	48 83 c5 08          	add    $0x8,%rbp
     f3d:	e9 d1 09 00 00       	jmp    1913 <balancer_ingress+0x1913>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     f42:	89 c0                	mov    %eax,%eax
     f44:	48 b9 00 10 f4 50 81 	movabs $0xffff888150f41000,%rcx
     f4b:	88 ff ff 
     f4e:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     f55:	00 
     f56:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
  if (!lru_map) {
     f5b:	48 85 c0             	test   %rax,%rax
     f5e:	0f 84 a1 fe ff ff    	je     e05 <balancer_ingress+0xe05>
     f64:	48 89 b4 24 80 00 00 	mov    %rsi,0x80(%rsp)
     f6b:	00 
  if ((vip_info->flags & F_QUIC_VIP)) {
     f6c:	f6 07 04             	testb  $0x4,(%rdi)
     f6f:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
     f74:	0f 84 8a 00 00 00    	je     1004 <balancer_ingress+0x1004>
    bool is_icmp = (pckt.flags & F_ICMP);
     f7a:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
    if (is_icmp) {
     f7f:	75 44                	jne    fc5 <balancer_ingress+0xfc5>
     f81:	48 b8 00 ec fd 6d 81 	movabs $0xffff88816dfdec00,%rax
     f88:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     f8b:	48 8b a8 00 01 00 00 	mov    0x100(%rax),%rbp
     f92:	65 48 03 2c 25 28 50 	add    %gs:0xffffffffb3795028,%rbp
     f99:	79 b3 
      if (!quic_packets_stats) {
     f9b:	48 85 ed             	test   %rbp,%rbp
     f9e:	0f 84 9e 0f 00 00    	je     1f42 <balancer_ingress+0x1f42>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fa4:	48 83 c3 3e          	add    $0x3e,%rbx
  bool is_icmp = (pckt->flags & F_ICMP);
     fa8:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fad:	49 0f 44 de          	cmove  %r14,%rbx
     fb1:	48 8d 43 09          	lea    0x9(%rbx),%rax
     fb5:	4c 39 e0             	cmp    %r12,%rax
     fb8:	0f 86 0b 01 00 00    	jbe    10c9 <balancer_ingress+0x10c9>
     fbe:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
     fc3:	eb 3a                	jmp    fff <balancer_ingress+0xfff>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fc5:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
     fcc:	88 ff ff 
     fcf:	48 8b a8 58 11 00 00 	mov    0x1158(%rax),%rbp
     fd6:	65 48 03 2c 25 28 50 	add    %gs:0xffffffffb3795028,%rbp
     fdd:	79 b3 
      if (!data_stats) {
     fdf:	48 85 ed             	test   %rbp,%rbp
     fe2:	0f 84 5a 0f 00 00    	je     1f42 <balancer_ingress+0x1f42>
      data_stats->v1 += 1;
     fe8:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     fed:	8a 43 23             	mov    0x23(%rbx),%al
     ff0:	24 fd                	and    $0xfd,%al
     ff2:	3c 01                	cmp    $0x1,%al
     ff4:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     ff9:	75 09                	jne    1004 <balancer_ingress+0x1004>
        data_stats->v2 += 1;
     ffb:	48 83 c5 08          	add    $0x8,%rbp
     fff:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
  original_sport = pckt.flow.port16[0];
    1004:	44 0f b7 64 24 30    	movzwl 0x30(%rsp),%r12d
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    100a:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    100f:	75 53                	jne    1064 <balancer_ingress+0x1064>
        !(vip_info->flags & F_LRU_BYPASS)) {
    1011:	f6 07 02             	testb  $0x2,(%rdi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1014:	75 46                	jne    105c <balancer_ingress+0x105c>
    1016:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    101b:	48 8b 07             	mov    (%rdi),%rax
    101e:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    1023:	ff 50 60             	call   *0x60(%rax)
  if (!dst_lru) {
    1026:	48 85 c0             	test   %rax,%rax
    1029:	74 31                	je     105c <balancer_ingress+0x105c>
    102b:	48 89 c5             	mov    %rax,%rbp
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    102e:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1033:	0f 85 b0 01 00 00    	jne    11e9 <balancer_ingress+0x11e9>
    1039:	48 c7 c0 30 d6 a9 ad 	mov    $0xffffffffada9d630,%rax
    cur_time = bpf_ktime_get_ns();
    1040:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1042:	48 89 c1             	mov    %rax,%rcx
    1045:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    1049:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    1050:	00 00 00 
    1053:	48 39 d1             	cmp    %rdx,%rcx
    1056:	0f 86 89 01 00 00    	jbe    11e5 <balancer_ingress+0x11e5>
    105c:	45 31 f6             	xor    %r14d,%r14d
    105f:	e9 af 01 00 00       	jmp    1213 <balancer_ingress+0x1213>
    1064:	45 31 f6             	xor    %r14d,%r14d
    1067:	e9 ac 01 00 00       	jmp    1218 <balancer_ingress+0x1218>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    106c:	48 8d 43 0e          	lea    0xe(%rbx),%rax
    1070:	4c 39 e0             	cmp    %r12,%rax
    1073:	0f 87 8d 08 00 00    	ja     1906 <balancer_ingress+0x1906>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1079:	f6 c1 20             	test   $0x20,%cl
    107c:	0f 85 0a 01 00 00    	jne    118c <balancer_ingress+0x118c>
        quic_packets_stats->cid_initial += 1;
    1082:	48 83 45 08 01       	addq   $0x1,0x8(%rbp)
    1087:	4c 89 fe             	mov    %r15,%rsi
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    108a:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
    1090:	48 ba 00 40 77 3d 81 	movabs $0xffff88813d774000,%rdx
    1097:	88 ff ff 
    109a:	0f 87 78 08 00 00    	ja     1918 <balancer_ingress+0x1918>
    10a0:	48 b8 00 c0 a4 4b 81 	movabs $0xffff88814ba4c000,%rax
    10a7:	88 ff ff 
    10aa:	48 8b ac f0 00 01 00 	mov    0x100(%rax,%rsi,8),%rbp
    10b1:	00 
    10b2:	65 48 03 2c 25 28 50 	add    %gs:0xffffffffb3795028,%rbp
    10b9:	79 b3 
  if (!per_vip_stats) {
    10bb:	48 85 ed             	test   %rbp,%rbp
    10be:	0f 85 4f 08 00 00    	jne    1913 <balancer_ingress+0x1913>
    10c4:	e9 4f 08 00 00       	jmp    1918 <balancer_ingress+0x1918>
    10c9:	48 83 c3 08          	add    $0x8,%rbx
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    10cd:	0f b6 0b             	movzbl (%rbx),%ecx
    10d0:	f6 c1 80             	test   $0x80,%cl
    10d3:	75 55                	jne    112a <balancer_ingress+0x112a>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    10d5:	48 83 c3 09          	add    $0x9,%rbx
    10d9:	4c 39 e3             	cmp    %r12,%rbx
    10dc:	0f 87 dc fe ff ff    	ja     fbe <balancer_ingress+0xfbe>
  if (!connId) {
    10e2:	48 85 c0             	test   %rax,%rax
    10e5:	0f 84 d3 fe ff ff    	je     fbe <balancer_ingress+0xfbe>
  __u8 connIdVersion = (connId[0] >> 6);
    10eb:	0f b6 08             	movzbl (%rax),%ecx
    10ee:	89 ca                	mov    %ecx,%edx
    10f0:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10f3:	80 fa 03             	cmp    $0x3,%dl
    10f6:	0f 84 3e 10 00 00    	je     213a <balancer_ingress+0x213a>
    10fc:	80 fa 02             	cmp    $0x2,%dl
    10ff:	0f 84 5a 10 00 00    	je     215f <balancer_ingress+0x215f>
    1105:	80 fa 01             	cmp    $0x1,%dl
    1108:	0f 85 b0 fe ff ff    	jne    fbe <balancer_ingress+0xfbe>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    110e:	83 e1 3f             	and    $0x3f,%ecx
    1111:	48 c1 e1 0a          	shl    $0xa,%rcx
    1115:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    1119:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
    111d:	8a 40 02             	mov    0x2(%rax),%al
    1120:	c0 e8 06             	shr    $0x6,%al
    1123:	b2 01                	mov    $0x1,%dl
    1125:	e9 4d 10 00 00       	jmp    2177 <balancer_ingress+0x2177>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    112a:	48 8d 43 0e          	lea    0xe(%rbx),%rax
    112e:	4c 39 e0             	cmp    %r12,%rax
    1131:	0f 87 87 fe ff ff    	ja     fbe <balancer_ingress+0xfbe>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1137:	f6 c1 20             	test   $0x20,%cl
    113a:	0f 85 03 07 00 00    	jne    1843 <balancer_ingress+0x1843>
        quic_packets_stats->cid_initial += 1;
    1140:	48 83 45 08 01       	addq   $0x1,0x8(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1145:	81 bc 24 80 00 00 00 	cmpl   $0x1ff,0x80(%rsp)
    114c:	ff 01 00 00 
    1150:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    1155:	0f 87 a9 fe ff ff    	ja     1004 <balancer_ingress+0x1004>
    115b:	48 b8 00 c0 a4 4b 81 	movabs $0xffff88814ba4c000,%rax
    1162:	88 ff ff 
    1165:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
    116c:	00 
    116d:	48 8b ac c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rbp
    1174:	00 
    1175:	65 48 03 2c 25 28 50 	add    %gs:0xffffffffb3795028,%rbp
    117c:	79 b3 
  if (!per_vip_stats) {
    117e:	48 85 ed             	test   %rbp,%rbp
    1181:	0f 85 78 fe ff ff    	jne    fff <balancer_ingress+0xfff>
    1187:	e9 78 fe ff ff       	jmp    1004 <balancer_ingress+0x1004>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    118c:	80 7b 05 08          	cmpb   $0x8,0x5(%rbx)
    1190:	0f 82 70 07 00 00    	jb     1906 <balancer_ingress+0x1906>
    1196:	48 83 c3 06          	add    $0x6,%rbx
    119a:	48 89 d8             	mov    %rbx,%rax
  if (!connId) {
    119d:	48 85 c0             	test   %rax,%rax
    11a0:	0f 84 60 07 00 00    	je     1906 <balancer_ingress+0x1906>
  __u8 connIdVersion = (connId[0] >> 6);
    11a6:	0f b6 08             	movzbl (%rax),%ecx
    11a9:	89 ca                	mov    %ecx,%edx
    11ab:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    11ae:	80 fa 03             	cmp    $0x3,%dl
    11b1:	0f 84 5e 05 00 00    	je     1715 <balancer_ingress+0x1715>
    11b7:	80 fa 02             	cmp    $0x2,%dl
    11ba:	0f 84 7a 05 00 00    	je     173a <balancer_ingress+0x173a>
    11c0:	80 fa 01             	cmp    $0x1,%dl
    11c3:	0f 85 3d 07 00 00    	jne    1906 <balancer_ingress+0x1906>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    11c9:	83 e1 3f             	and    $0x3f,%ecx
    11cc:	48 c1 e1 0a          	shl    $0xa,%rcx
    11d0:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    11d4:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
    11d8:	8a 40 02             	mov    0x2(%rax),%al
    11db:	c0 e8 06             	shr    $0x6,%al
    11de:	b2 01                	mov    $0x1,%dl
    11e0:	e9 6d 05 00 00       	jmp    1752 <balancer_ingress+0x1752>
    dst_lru->atime = cur_time;
    11e5:	48 89 45 08          	mov    %rax,0x8(%rbp)
  key = dst_lru->pos;
    11e9:	8b 45 00             	mov    0x0(%rbp),%eax
    11ec:	45 31 f6             	xor    %r14d,%r14d
    11ef:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    11f5:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    11f9:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    11fd:	48 b9 00 e0 26 49 03 	movabs $0xffffc9034926e000,%rcx
    1204:	c9 ff ff 
    1207:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    120e:	00 
    120f:	4c 0f 42 f0          	cmovb  %rax,%r14
    1213:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1218:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    121d:	0f 85 be 00 00 00    	jne    12e1 <balancer_ingress+0x12e1>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1223:	f6 47 01 02          	testb  $0x2,0x1(%rdi)
    1227:	0f 84 b4 00 00 00    	je     12e1 <balancer_ingress+0x12e1>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    122d:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    1234:	88 ff ff 
    1237:	48 8b 98 10 11 00 00 	mov    0x1110(%rax),%rbx
    123e:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffb3795028,%rbx
    1245:	79 b3 
  if (!conn_rate_stats) {
    1247:	48 85 db             	test   %rbx,%rbx
    124a:	0f 84 91 00 00 00    	je     12e1 <balancer_ingress+0x12e1>
    1250:	48 c7 c0 30 d6 a9 ad 	mov    $0xffffffffada9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1257:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1259:	48 89 c1             	mov    %rax,%rcx
    125c:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1260:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1267:	72 0d                	jb     1276 <balancer_ingress+0x1276>
    conn_rate_stats->v1 = 1;
    1269:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1270:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1274:	eb 12                	jmp    1288 <balancer_ingress+0x1288>
    conn_rate_stats->v1 += 1;
    1276:	48 8b 03             	mov    (%rbx),%rax
    1279:	48 83 c0 01          	add    $0x1,%rax
    127d:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1280:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    1286:	77 59                	ja     12e1 <balancer_ingress+0x12e1>
    1288:	48 bf 00 b0 fc 4b 81 	movabs $0xffff88814bfcb000,%rdi
    128f:	88 ff ff 
    1292:	48 8b 07             	mov    (%rdi),%rax
    1295:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
    129a:	ff 50 60             	call   *0x60(%rax)
    if (down_reals_map) {
    129d:	48 85 c0             	test   %rax,%rax
    12a0:	74 3f                	je     12e1 <balancer_ingress+0x12e1>
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    12a2:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
    12a7:	48 8b 08             	mov    (%rax),%rcx
    12aa:	48 89 c7             	mov    %rax,%rdi
    12ad:	ff 51 60             	call   *0x60(%rcx)
      if (down_real) {
    12b0:	48 85 c0             	test   %rax,%rax
    12b3:	74 2c                	je     12e1 <balancer_ingress+0x12e1>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    12b5:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    12bc:	88 ff ff 
    12bf:	48 8b 80 78 11 00 00 	mov    0x1178(%rax),%rax
    12c6:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    12cd:	79 b3 
        if (stats_data) {
    12cf:	48 85 c0             	test   %rax,%rax
    12d2:	0f 84 81 01 00 00    	je     1459 <balancer_ingress+0x1459>
          stats_data->v1 += 1;
    12d8:	48 83 00 01          	addq   $0x1,(%rax)
    12dc:	e9 78 01 00 00       	jmp    1459 <balancer_ingress+0x1459>
    if (!dst) {
    12e1:	4d 85 f6             	test   %r14,%r14
    12e4:	0f 84 6f 01 00 00    	je     1459 <balancer_ingress+0x1459>
    12ea:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
    12f1:	00 
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    12f2:	81 f9 ff 03 00 00    	cmp    $0x3ff,%ecx
    12f8:	0f 87 44 0c 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    12fe:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    1305:	88 ff ff 
    1308:	48 8b 8c c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rcx
    130f:	00 
    1310:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
    1317:	79 b3 
  if (!data_stats) {
    1319:	48 85 c9             	test   %rcx,%rcx
    131c:	0f 84 20 0c 00 00    	je     1f42 <balancer_ingress+0x1f42>
    1322:	0f b7 44 24 5c       	movzwl 0x5c(%rsp),%eax
    1327:	89 c3                	mov    %eax,%ebx
    1329:	66 c1 c3 08          	rol    $0x8,%bx
  data_stats->v1 += 1;
    132d:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    1331:	0f b7 c3             	movzwl %bx,%eax
    1334:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1338:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    133c:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    1343:	0f 87 f9 0b 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    1349:	48 ba 00 80 28 49 03 	movabs $0xffffc90349288000,%rdx
    1350:	c9 ff ff 
    1353:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
    135a:	00 
    135b:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
    1362:	79 b3 
  if (!data_stats) {
    1364:	48 85 c9             	test   %rcx,%rcx
    1367:	0f 84 d5 0b 00 00    	je     1f42 <balancer_ingress+0x1f42>
  data_stats->v1 += 1;
    136d:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    1371:	48 01 41 08          	add    %rax,0x8(%rcx)
  pckt.flow.port16[0] = original_sport;
    1375:	66 44 89 64 24 30    	mov    %r12w,0x30(%rsp)
  if (dst->flags & F_IPV6) {
    137b:	41 f6 46 10 01       	testb  $0x1,0x10(%r14)
    1380:	0f 85 cd 02 00 00    	jne    1653 <balancer_ingress+0x1653>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1386:	44 0f b7 7c 24 12    	movzwl 0x12(%rsp),%r15d
    138c:	48 c7 c0 20 5c c3 af 	mov    $0xffffffffafc35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1393:	4c 89 ef             	mov    %r13,%rdi
    1396:	be ec ff ff ff       	mov    $0xffffffec,%esi
    139b:	ff d0                	call   *%rax
    139d:	85 c0                	test   %eax,%eax
    139f:	0f 85 9d 0b 00 00    	jne    1f42 <balancer_ingress+0x1f42>
  data = (void*)(long)xdp->data;
    13a5:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    13a9:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  iph = data + sizeof(struct ethhdr);
    13ad:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    13b1:	48 39 ca             	cmp    %rcx,%rdx
    13b4:	0f 87 88 0b 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    13ba:	48 8d 50 22          	lea    0x22(%rax),%rdx
    13be:	bd 01 00 00 00       	mov    $0x1,%ebp
    13c3:	48 39 ca             	cmp    %rcx,%rdx
    13c6:	0f 87 7b 0b 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    13cc:	66 41 c1 c4 08       	rol    $0x8,%r12w
    13d1:	45 31 e7             	xor    %r12d,%r15d
    13d4:	41 c1 e7 10          	shl    $0x10,%r15d
    13d8:	41 8d bf ac 10 00 00 	lea    0x10ac(%r15),%edi
    13df:	48 b9 00 e8 fd 6d 81 	movabs $0xffff88816dfde800,%rcx
    13e6:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    13e9:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    13f0:	66 89 70 04          	mov    %si,0x4(%rax)
    13f4:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    13fa:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    13fc:	8b 48 14             	mov    0x14(%rax),%ecx
    13ff:	89 48 06             	mov    %ecx,0x6(%rax)
    1402:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    1406:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    140a:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1410:	8a 54 24 3d          	mov    0x3d(%rsp),%dl
    1414:	41 8b 0e             	mov    (%r14),%ecx
    __u32 daddr,
    __u16 pkt_bytes,
    __u8 proto) {
  __u64 csum = 0;
  iph->version = 4;
  iph->ihl = 5;
    1417:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->frag_off = 0;
  iph->protocol = proto;
  iph->check = 0;
#ifdef COPY_INNER_PACKET_TOS
  iph->tos = tos;
    141b:	88 50 0f             	mov    %dl,0xf(%rax)
#else
  iph->tos = DEFAULT_TOS;
#endif
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    141e:	83 c3 14             	add    $0x14,%ebx
    1421:	66 c1 c3 08          	rol    $0x8,%bx
    1425:	66 89 58 10          	mov    %bx,0x10(%rax)
  iph->id = 0;
    1429:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    1430:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    1433:	89 78 1a             	mov    %edi,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    1436:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    143c:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    1440:	0f b7 f3             	movzwl %bx,%esi
    1443:	0f b7 78 16          	movzwl 0x16(%rax),%edi
    1447:	41 c1 ef 10          	shr    $0x10,%r15d
    144b:	49 01 f7             	add    %rsi,%r15
    144e:	0f b7 f1             	movzwl %cx,%esi
    1451:	4c 01 fe             	add    %r15,%rsi
    1454:	e9 d1 07 00 00       	jmp    1c2a <balancer_ingress+0x1c2a>
      if (pckt.flow.proto == IPPROTO_TCP) {
    1459:	80 7c 24 34 06       	cmpb   $0x6,0x34(%rsp)
    145e:	75 34                	jne    1494 <balancer_ingress+0x1494>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1460:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    1467:	88 ff ff 
    146a:	48 8b 80 08 11 00 00 	mov    0x1108(%rax),%rax
    1471:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    1478:	79 b3 
        if (!lru_stats) {
    147a:	48 85 c0             	test   %rax,%rax
    147d:	0f 84 bf 0a 00 00    	je     1f42 <balancer_ingress+0x1f42>
        if (pckt.flags & F_SYN_SET) {
    1483:	8b 4c 24 3c          	mov    0x3c(%rsp),%ecx
    1487:	c1 e1 02             	shl    $0x2,%ecx
    148a:	f7 d1                	not    %ecx
    148c:	83 e1 08             	and    $0x8,%ecx
    148f:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
  struct real_pos_lru new_dst_lru = {};
    1494:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    149b:	00 00 
    149d:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    14a4:	00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    14a6:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    14ad:	88 ff ff 
    14b0:	48 8b a8 10 11 00 00 	mov    0x1110(%rax),%rbp
    14b7:	65 48 03 2c 25 28 50 	add    %gs:0xffffffffb3795028,%rbp
    14be:	79 b3 
    14c0:	b3 01                	mov    $0x1,%bl
  if (!conn_rate_stats) {
    14c2:	48 85 ed             	test   %rbp,%rbp
    14c5:	74 27                	je     14ee <balancer_ingress+0x14ee>
    14c7:	48 c7 c0 30 d6 a9 ad 	mov    $0xffffffffada9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    14ce:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    14d0:	48 89 c1             	mov    %rax,%rcx
    14d3:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    14d7:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    14de:	72 12                	jb     14f2 <balancer_ingress+0x14f2>
    conn_rate_stats->v1 = 1;
    14e0:	48 c7 45 00 01 00 00 	movq   $0x1,0x0(%rbp)
    14e7:	00 
    conn_rate_stats->v2 = *cur_time;
    14e8:	48 89 45 08          	mov    %rax,0x8(%rbp)
    14ec:	eb 19                	jmp    1507 <balancer_ingress+0x1507>
    14ee:	31 c0                	xor    %eax,%eax
    14f0:	eb 17                	jmp    1509 <balancer_ingress+0x1509>
    conn_rate_stats->v1 += 1;
    14f2:	48 8b 4d 00          	mov    0x0(%rbp),%rcx
    14f6:	48 83 c1 01          	add    $0x1,%rcx
    14fa:	48 89 4d 00          	mov    %rcx,0x0(%rbp)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    14fe:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    1505:	77 02                	ja     1509 <balancer_ingress+0x1509>
    1507:	31 db                	xor    %ebx,%ebx
    1509:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    150e:	f6 01 08             	testb  $0x8,(%rcx)
    1511:	75 0b                	jne    151e <balancer_ingress+0x151e>
    1513:	ba f7 c0 ad e0       	mov    $0xe0adc0f7,%edx
    1518:	03 54 24 10          	add    0x10(%rsp),%edx
    151c:	eb 21                	jmp    153f <balancer_ingress+0x153f>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    151e:	0f b7 4c 24 32       	movzwl 0x32(%rsp),%ecx
    1523:	66 89 4c 24 30       	mov    %cx,0x30(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    1528:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    152f:	00 00 
    1531:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
    1538:	00 00 
    153a:	ba f7 c0 ad e0       	mov    $0xe0adc0f7,%edx
    153f:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  return c;
}

static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval) {
  a += initval;
  b += initval;
    1544:	03 74 24 30          	add    0x30(%rsp),%esi
  c += initval;
  __jhash_final(a, b, c);
    1548:	89 f1                	mov    %esi,%ecx
    154a:	81 f1 f7 c0 ad e0    	xor    $0xe0adc0f7,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1550:	89 f7                	mov    %esi,%edi
    1552:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    1555:	29 f9                	sub    %edi,%ecx
    1557:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1559:	89 cf                	mov    %ecx,%edi
    155b:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    155e:	29 fa                	sub    %edi,%edx
    1560:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1562:	89 d7                	mov    %edx,%edi
    1564:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    1567:	29 fe                	sub    %edi,%esi
    1569:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    156b:	89 f7                	mov    %esi,%edi
    156d:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    1570:	29 f9                	sub    %edi,%ecx
    1572:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1574:	89 cf                	mov    %ecx,%edi
    1576:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1579:	29 fa                	sub    %edi,%edx
    157b:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    157d:	c1 c2 0e             	rol    $0xe,%edx
  __jhash_final(a, b, c);
    1580:	29 d6                	sub    %edx,%esi
    1582:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1584:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    1587:	29 f1                	sub    %esi,%ecx
    1589:	ba 01 00 ff ff       	mov    $0xffff0001,%edx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    158e:	48 0f af d1          	imul   %rcx,%rdx
    1592:	48 c1 ea 30          	shr    $0x30,%rdx
    1596:	89 d6                	mov    %edx,%esi
    1598:	c1 e6 10             	shl    $0x10,%esi
    159b:	09 d6                	or     %edx,%esi
    159d:	29 f1                	sub    %esi,%ecx
    159f:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    15a4:	8b 72 04             	mov    0x4(%rdx),%esi
    15a7:	89 f2                	mov    %esi,%edx
    15a9:	c1 e2 10             	shl    $0x10,%edx
    15ac:	01 f2                	add    %esi,%edx
    15ae:	01 ca                	add    %ecx,%edx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15b0:	81 fa ff 01 00 02    	cmp    $0x20001ff,%edx
    if (!real_pos) {
    15b6:	0f 87 86 09 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15bc:	89 d1                	mov    %edx,%ecx
    15be:	48 ba 00 b0 26 39 03 	movabs $0xffffc9033926b000,%rdx
    15c5:	c9 ff ff 
    key = *real_pos;
    15c8:	8b ac ca 00 01 00 00 	mov    0x100(%rdx,%rcx,8),%ebp
    15cf:	48 85 ed             	test   %rbp,%rbp
    if (key == 0) {
    15d2:	74 34                	je     1608 <balancer_ingress+0x1608>
  pckt->real_index = key;
    15d4:	89 6c 24 38          	mov    %ebp,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    15d8:	81 fd 00 10 00 00    	cmp    $0x1000,%ebp
  if (!(*real)) {
    15de:	72 50                	jb     1630 <balancer_ingress+0x1630>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    15e0:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    15e7:	88 ff ff 
    15ea:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    15f1:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    15f8:	79 b3 
  if (!ch_drop_stats) {
    15fa:	48 85 c0             	test   %rax,%rax
    15fd:	0f 85 3b 09 00 00    	jne    1f3e <balancer_ingress+0x1f3e>
    1603:	e9 3a 09 00 00       	jmp    1f42 <balancer_ingress+0x1f42>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1608:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    160f:	88 ff ff 
    1612:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1619:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    1620:	79 b3 
  if (!ch_drop_stats) {
    1622:	48 85 c0             	test   %rax,%rax
    1625:	0f 85 0f 09 00 00    	jne    1f3a <balancer_ingress+0x1f3a>
    162b:	e9 12 09 00 00       	jmp    1f42 <balancer_ingress+0x1f42>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1630:	48 83 7c 24 50 00    	cmpq   $0x0,0x50(%rsp)
    1636:	74 14                	je     164c <balancer_ingress+0x164c>
    1638:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    163d:	8a 09                	mov    (%rcx),%cl
    163f:	80 e1 02             	and    $0x2,%cl
    1642:	d0 e9                	shr    %cl
    1644:	08 cb                	or     %cl,%bl
    1646:	0f 84 39 01 00 00    	je     1785 <balancer_ingress+0x1785>
    164c:	89 e8                	mov    %ebp,%eax
    164e:	e9 5d 01 00 00       	jmp    17b0 <balancer_ingress+0x17b0>
    1653:	48 c7 c0 20 5c c3 af 	mov    $0xffffffffafc35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    165a:	4c 89 ef             	mov    %r13,%rdi
    165d:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1662:	ff d0                	call   *%rax
    1664:	85 c0                	test   %eax,%eax
    1666:	0f 85 d6 08 00 00    	jne    1f42 <balancer_ingress+0x1f42>
  data = (void*)(long)xdp->data;
    166c:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1670:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1674:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1678:	48 39 ca             	cmp    %rcx,%rdx
    167b:	0f 87 c1 08 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    1681:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1685:	bd 01 00 00 00       	mov    $0x1,%ebp
    168a:	48 39 ca             	cmp    %rcx,%rdx
    168d:	0f b7 74 24 5c       	movzwl 0x5c(%rsp),%esi
    1692:	0f 87 af 08 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    1698:	48 b9 00 e8 fd 6d 81 	movabs $0xffff88816dfde800,%rcx
    169f:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    16a2:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    16a9:	66 89 50 04          	mov    %dx,0x4(%rax)
    16ad:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    16b3:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    16b5:	8b 48 28             	mov    0x28(%rax),%ecx
    16b8:	89 48 06             	mov    %ecx,0x6(%rax)
    16bb:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    16bf:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    16c3:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    16c9:	0f b7 4c 24 30       	movzwl 0x30(%rsp),%ecx
  saddr[3] = src ^ port;
    16ce:	33 4c 24 10          	xor    0x10(%rsp),%ecx
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    16d2:	8a 5c 24 3d          	mov    0x3d(%rsp),%bl
    __u32* saddr,
    __u32* daddr,
    __u16 payload_len,
    __u8 proto) {
  ip6h->version = 6;
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    16d6:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#ifdef COPY_INNER_PACKET_TOS
  ip6h->priority = (tc & 0xF0) >> 4;
    16dc:	89 da                	mov    %ebx,%edx
    16de:	c0 ea 04             	shr    $0x4,%dl
    16e1:	80 ca 60             	or     $0x60,%dl
    16e4:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    16e7:	c0 e3 04             	shl    $0x4,%bl
    16ea:	88 58 0f             	mov    %bl,0xf(%rax)
#else
  ip6h->priority = DEFAULT_TOS;
#endif
  ip6h->nexthdr = proto;
    16ed:	66 c7 40 14 04 40    	movw   $0x4004,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    16f3:	66 89 70 12          	mov    %si,0x12(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    16f7:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    16fe:	00 
    16ff:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    1706:	89 48 22             	mov    %ecx,0x22(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    1709:	49 8b 0e             	mov    (%r14),%rcx
    170c:	49 8b 56 08          	mov    0x8(%r14),%rdx
    1710:	e9 20 09 00 00       	jmp    2035 <balancer_ingress+0x2035>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1715:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    1719:	48 c1 e1 18          	shl    $0x18,%rcx
    171d:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    1721:	48 c1 e2 10          	shl    $0x10,%rdx
    1725:	48 09 ca             	or     %rcx,%rdx
    1728:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    172c:	48 c1 e1 08          	shl    $0x8,%rcx
    1730:	48 09 d1             	or     %rdx,%rcx
    1733:	8a 40 04             	mov    0x4(%rax),%al
    1736:	b2 03                	mov    $0x3,%dl
    1738:	eb 18                	jmp    1752 <balancer_ingress+0x1752>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    173a:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    173e:	48 c1 e2 10          	shl    $0x10,%rdx
    1742:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    1746:	48 c1 e1 08          	shl    $0x8,%rcx
    174a:	48 09 d1             	or     %rdx,%rcx
    174d:	8a 40 03             	mov    0x3(%rax),%al
    1750:	b2 02                	mov    $0x2,%dl
    1752:	0f b6 c0             	movzbl %al,%eax
    1755:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    1758:	85 c0                	test   %eax,%eax
    175a:	0f 8e a6 01 00 00    	jle    1906 <balancer_ingress+0x1906>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1760:	80 fa 01             	cmp    $0x1,%dl
    1763:	0f 84 f9 00 00 00    	je     1862 <balancer_ingress+0x1862>
    1769:	80 fa 03             	cmp    $0x3,%dl
    176c:	0f 84 f7 00 00 00    	je     1869 <balancer_ingress+0x1869>
    1772:	80 fa 02             	cmp    $0x2,%dl
    1775:	0f 85 f5 00 00 00    	jne    1870 <balancer_ingress+0x1870>
    177b:	b9 40 00 00 00       	mov    $0x40,%ecx
    1780:	e9 f0 00 00 00       	jmp    1875 <balancer_ingress+0x1875>
    if (pckt->flow.proto == IPPROTO_UDP) {
    1785:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    178a:	75 05                	jne    1791 <balancer_ingress+0x1791>
      new_dst_lru.atime = cur_time;
    178c:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    new_dst_lru.pos = key;
    1791:	89 6c 24 40          	mov    %ebp,0x40(%rsp)
    1795:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
		(void* map, void* key),
		(void*, void*),
		(map, key),
		map_lookup_elem, real_)
BPF_MAP_OPS_INLINE(int,
    179a:	48 8b 07             	mov    (%rdi),%rax
    179d:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    17a2:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    17a7:	31 c9                	xor    %ecx,%ecx
    17a9:	ff 50 68             	call   *0x68(%rax)
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    17ac:	8b 44 24 38          	mov    0x38(%rsp),%eax
    17b0:	48 bf 00 e0 fd 6d 81 	movabs $0xffff88816dfde000,%rdi
    17b7:	88 ff ff 
    17ba:	8b 9f 00 01 00 00    	mov    0x100(%rdi),%ebx
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17c0:	0f b7 97 10 01 00 00 	movzwl 0x110(%rdi),%edx
    17c7:	0f b7 74 24 70       	movzwl 0x70(%rsp),%esi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17cc:	8a 4c 24 72          	mov    0x72(%rsp),%cl
    17d0:	88 8f 12 01 00 00    	mov    %cl,0x112(%rdi)
    17d6:	3b 5c 24 60          	cmp    0x60(%rsp),%ebx
  bool vip_match = address_match && port_match && proto_match;
    17da:	75 3d                	jne    1819 <balancer_ingress+0x1819>
    17dc:	66 39 f2             	cmp    %si,%dx
    17df:	75 38                	jne    1819 <balancer_ingress+0x1819>
    17e1:	84 c9                	test   %cl,%cl
    17e3:	74 34                	je     1819 <balancer_ingress+0x1819>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17e5:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    17ea:	0f 87 52 07 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    17f0:	89 c0                	mov    %eax,%eax
    17f2:	48 b9 00 20 29 49 03 	movabs $0xffffc90349292000,%rcx
    17f9:	c9 ff ff 
    17fc:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    1803:	00 
    1804:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    180b:	79 b3 
    if (!lru_miss_stat) {
    180d:	48 85 c0             	test   %rax,%rax
    1810:	0f 84 2c 07 00 00    	je     1f42 <balancer_ingress+0x1f42>
    *lru_miss_stat += 1;
    1816:	83 00 01             	addl   $0x1,(%rax)
    1819:	48 8d 04 6d 00 00 00 	lea    0x0(,%rbp,2),%rax
    1820:	00 
    1821:	48 01 e8             	add    %rbp,%rax
    1824:	48 b9 00 e0 26 49 03 	movabs $0xffffc9034926e000,%rcx
    182b:	c9 ff ff 
    182e:	4c 8d 34 c1          	lea    (%rcx,%rax,8),%r14
    1832:	49 81 c6 00 01 00 00 	add    $0x100,%r14
      data_stats->v2 += 1;
    1839:	49 83 47 08 01       	addq   $0x1,0x8(%r15)
    183e:	e9 a7 fa ff ff       	jmp    12ea <balancer_ingress+0x12ea>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1843:	80 7b 05 08          	cmpb   $0x8,0x5(%rbx)
    1847:	0f 82 71 f7 ff ff    	jb     fbe <balancer_ingress+0xfbe>
    184d:	48 83 c3 06          	add    $0x6,%rbx
    1851:	48 89 d8             	mov    %rbx,%rax
  if (!connId) {
    1854:	48 85 c0             	test   %rax,%rax
    1857:	0f 85 8e f8 ff ff    	jne    10eb <balancer_ingress+0x10eb>
    185d:	e9 5c f7 ff ff       	jmp    fbe <balancer_ingress+0xfbe>
    1862:	b9 38 00 00 00       	mov    $0x38,%ecx
    1867:	eb 0c                	jmp    1875 <balancer_ingress+0x1875>
    1869:	b9 48 00 00 00       	mov    $0x48,%ecx
    186e:	eb 05                	jmp    1875 <balancer_ingress+0x1875>
    1870:	b9 30 00 00 00       	mov    $0x30,%ecx
    1875:	48 83 44 0d 00 01    	addq   $0x1,0x0(%rbp,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    187b:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    1880:	77 79                	ja     18fb <balancer_ingress+0x18fb>
    1882:	48 b9 00 c0 29 49 03 	movabs $0xffffc9034929c000,%rcx
    1889:	c9 ff ff 
          key = *real_pos;
    188c:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    1893:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    1896:	74 63                	je     18fb <balancer_ingress+0x18fb>
            pckt.real_index = key;
    1898:	89 4c 24 38          	mov    %ecx,0x38(%rsp)
    189c:	31 d2                	xor    %edx,%edx
            dst = bpf_map_lookup_elem(&reals, &key);
    189e:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    18a4:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    18a8:	48 b9 00 e0 26 49 03 	movabs $0xffffc9034926e000,%rcx
    18af:	c9 ff ff 
    18b2:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    18b9:	00 
    18ba:	48 0f 42 d0          	cmovb  %rax,%rdx
            if (!dst) {
    18be:	48 85 d2             	test   %rdx,%rdx
    18c1:	0f 84 cc 09 00 00    	je     2293 <balancer_ingress+0x2293>
    18c7:	48 89 d3             	mov    %rdx,%rbx
    18ca:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
BPF_MAP_OPS_INLINE(void*,
    18cf:	48 8b 07             	mov    (%rdi),%rax
    18d2:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    18d7:	ff 50 60             	call   *0x60(%rax)
  if (dst_lru) {
    18da:	48 85 c0             	test   %rax,%rax
    18dd:	0f 84 b8 08 00 00    	je     219b <balancer_ingress+0x219b>
    if (dst_lru->pos == pckt->real_index) {
    18e3:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    18e7:	39 08                	cmp    %ecx,(%rax)
    18e9:	0f 85 ae 09 00 00    	jne    229d <balancer_ingress+0x229d>
              quic_packets_stats->dst_match_in_lru += 1;
    18ef:	48 89 e8             	mov    %rbp,%rax
    18f2:	48 83 c0 50          	add    $0x50,%rax
    18f6:	e9 22 0a 00 00       	jmp    231d <balancer_ingress+0x231d>
    18fb:	48 83 45 10 01       	addq   $0x1,0x10(%rbp)
    1900:	48 98                	cltq
    1902:	48 89 45 18          	mov    %rax,0x18(%rbp)
    1906:	48 ba 00 40 77 3d 81 	movabs $0xffff88813d774000,%rdx
    190d:	88 ff ff 
    1910:	4c 89 fe             	mov    %r15,%rsi
    1913:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
  original_sport = pckt.flow.port16[0];
    1918:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
    191d:	89 84 24 80 00 00 00 	mov    %eax,0x80(%rsp)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1924:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    1929:	75 52                	jne    197d <balancer_ingress+0x197d>
        !(vip_info->flags & F_LRU_BYPASS)) {
    192b:	f6 07 02             	testb  $0x2,(%rdi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    192e:	75 4d                	jne    197d <balancer_ingress+0x197d>
    1930:	48 89 7c 24 50       	mov    %rdi,0x50(%rsp)
    1935:	49 89 f7             	mov    %rsi,%r15
    1938:	49 89 d4             	mov    %rdx,%r12
    193b:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    1940:	48 8b 07             	mov    (%rdi),%rax
    1943:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    1948:	ff 50 60             	call   *0x60(%rax)
  if (!dst_lru) {
    194b:	48 85 c0             	test   %rax,%rax
    194e:	74 29                	je     1979 <balancer_ingress+0x1979>
    1950:	48 89 c5             	mov    %rax,%rbp
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1953:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1958:	75 2b                	jne    1985 <balancer_ingress+0x1985>
    195a:	48 c7 c0 30 d6 a9 ad 	mov    $0xffffffffada9d630,%rax
    cur_time = bpf_ktime_get_ns();
    1961:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1963:	48 89 c1             	mov    %rax,%rcx
    1966:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    196a:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    1971:	00 00 00 
    1974:	48 39 d1             	cmp    %rdx,%rcx
    1977:	76 08                	jbe    1981 <balancer_ingress+0x1981>
    1979:	31 db                	xor    %ebx,%ebx
    197b:	eb 31                	jmp    19ae <balancer_ingress+0x19ae>
    197d:	31 db                	xor    %ebx,%ebx
    197f:	eb 38                	jmp    19b9 <balancer_ingress+0x19b9>
    dst_lru->atime = cur_time;
    1981:	48 89 45 08          	mov    %rax,0x8(%rbp)
  key = dst_lru->pos;
    1985:	8b 45 00             	mov    0x0(%rbp),%eax
    1988:	31 db                	xor    %ebx,%ebx
    198a:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    1990:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1994:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    1998:	48 b9 00 e0 26 49 03 	movabs $0xffffc9034926e000,%rcx
    199f:	c9 ff ff 
    19a2:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    19a9:	00 
    19aa:	48 0f 42 d8          	cmovb  %rax,%rbx
    19ae:	4c 89 e2             	mov    %r12,%rdx
    19b1:	4c 89 fe             	mov    %r15,%rsi
    19b4:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    19b9:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    19be:	0f 85 f7 00 00 00    	jne    1abb <balancer_ingress+0x1abb>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    19c4:	f6 47 01 02          	testb  $0x2,0x1(%rdi)
    19c8:	0f 84 ed 00 00 00    	je     1abb <balancer_ingress+0x1abb>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    19ce:	48 8b aa 10 11 00 00 	mov    0x1110(%rdx),%rbp
    19d5:	65 48 03 2c 25 28 50 	add    %gs:0xffffffffb3795028,%rbp
    19dc:	79 b3 
  if (!conn_rate_stats) {
    19de:	48 85 ed             	test   %rbp,%rbp
    19e1:	0f 84 d4 00 00 00    	je     1abb <balancer_ingress+0x1abb>
    19e7:	48 89 5c 24 50       	mov    %rbx,0x50(%rsp)
    19ec:	49 89 fc             	mov    %rdi,%r12
    19ef:	49 89 f7             	mov    %rsi,%r15
    19f2:	48 c7 c0 30 d6 a9 ad 	mov    $0xffffffffada9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    19f9:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    19fb:	48 89 c1             	mov    %rax,%rcx
    19fe:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    1a02:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1a09:	72 0e                	jb     1a19 <balancer_ingress+0x1a19>
    conn_rate_stats->v1 = 1;
    1a0b:	48 c7 45 00 01 00 00 	movq   $0x1,0x0(%rbp)
    1a12:	00 
    conn_rate_stats->v2 = *cur_time;
    1a13:	48 89 45 08          	mov    %rax,0x8(%rbp)
    1a17:	eb 29                	jmp    1a42 <balancer_ingress+0x1a42>
    conn_rate_stats->v1 += 1;
    1a19:	48 8b 45 00          	mov    0x0(%rbp),%rax
    1a1d:	48 83 c0 01          	add    $0x1,%rax
    1a21:	48 89 45 00          	mov    %rax,0x0(%rbp)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1a25:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    1a2b:	48 ba 00 40 77 3d 81 	movabs $0xffff88813d774000,%rdx
    1a32:	88 ff ff 
    1a35:	4c 89 fe             	mov    %r15,%rsi
    1a38:	4c 89 e7             	mov    %r12,%rdi
    1a3b:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
    1a40:	77 79                	ja     1abb <balancer_ingress+0x1abb>
    1a42:	48 bf 00 b0 fc 4b 81 	movabs $0xffff88814bfcb000,%rdi
    1a49:	88 ff ff 
    1a4c:	48 8b 07             	mov    (%rdi),%rax
    1a4f:	48 8d 74 24 60       	lea    0x60(%rsp),%rsi
    1a54:	ff 50 60             	call   *0x60(%rax)
    1a57:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
    1a5c:	4c 89 e7             	mov    %r12,%rdi
    1a5f:	4c 89 fe             	mov    %r15,%rsi
    1a62:	48 ba 00 40 77 3d 81 	movabs $0xffff88813d774000,%rdx
    1a69:	88 ff ff 
    if (down_reals_map) {
    1a6c:	48 85 c0             	test   %rax,%rax
    1a6f:	74 4a                	je     1abb <balancer_ingress+0x1abb>
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1a71:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
    1a76:	48 8b 08             	mov    (%rax),%rcx
    1a79:	48 89 c7             	mov    %rax,%rdi
    1a7c:	ff 51 60             	call   *0x60(%rcx)
    1a7f:	48 8b 5c 24 50       	mov    0x50(%rsp),%rbx
    1a84:	4c 89 e7             	mov    %r12,%rdi
    1a87:	4c 89 fe             	mov    %r15,%rsi
    1a8a:	48 ba 00 40 77 3d 81 	movabs $0xffff88813d774000,%rdx
    1a91:	88 ff ff 
      if (down_real) {
    1a94:	48 85 c0             	test   %rax,%rax
    1a97:	74 22                	je     1abb <balancer_ingress+0x1abb>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1a99:	48 8b 82 78 11 00 00 	mov    0x1178(%rdx),%rax
    1aa0:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    1aa7:	79 b3 
        if (stats_data) {
    1aa9:	48 85 c0             	test   %rax,%rax
    1aac:	0f 84 f5 01 00 00    	je     1ca7 <balancer_ingress+0x1ca7>
          stats_data->v1 += 1;
    1ab2:	48 83 00 01          	addq   $0x1,(%rax)
    1ab6:	e9 ec 01 00 00       	jmp    1ca7 <balancer_ingress+0x1ca7>
    if (!dst) {
    1abb:	48 85 db             	test   %rbx,%rbx
    1abe:	0f 84 e3 01 00 00    	je     1ca7 <balancer_ingress+0x1ca7>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1ac4:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
    1aca:	0f 87 72 04 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    1ad0:	48 8b 8c f2 00 01 00 	mov    0x100(%rdx,%rsi,8),%rcx
    1ad7:	00 
    1ad8:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
    1adf:	79 b3 
  if (!data_stats) {
    1ae1:	48 85 c9             	test   %rcx,%rcx
    1ae4:	0f 84 58 04 00 00    	je     1f42 <balancer_ingress+0x1f42>
    1aea:	8b 44 24 5c          	mov    0x5c(%rsp),%eax
    1aee:	66 c1 c0 08          	rol    $0x8,%ax
  data_stats->v1 += 1;
    1af2:	48 83 01 01          	addq   $0x1,(%rcx)
    1af6:	41 89 c7             	mov    %eax,%r15d
  data_stats->v2 += pkt_bytes;
    1af9:	0f b7 c0             	movzwl %ax,%eax
    1afc:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1b00:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    1b04:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    1b0b:	0f 87 31 04 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    1b11:	48 ba 00 80 28 49 03 	movabs $0xffffc90349288000,%rdx
    1b18:	c9 ff ff 
    1b1b:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
    1b22:	00 
    1b23:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffb3795028,%rcx
    1b2a:	79 b3 
  if (!data_stats) {
    1b2c:	48 85 c9             	test   %rcx,%rcx
    1b2f:	0f 84 0d 04 00 00    	je     1f42 <balancer_ingress+0x1f42>
  data_stats->v1 += 1;
    1b35:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    1b39:	48 01 41 08          	add    %rax,0x8(%rcx)
    1b3d:	8b 84 24 80 00 00 00 	mov    0x80(%rsp),%eax
  pckt.flow.port16[0] = original_sport;
    1b44:	66 89 44 24 30       	mov    %ax,0x30(%rsp)
  if (dst->flags & F_IPV6) {
    1b49:	f6 43 10 01          	testb  $0x1,0x10(%rbx)
    1b4d:	0f 85 2c 04 00 00    	jne    1f7f <balancer_ingress+0x1f7f>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1b53:	44 0f b7 74 24 12    	movzwl 0x12(%rsp),%r14d
    1b59:	48 c7 c0 20 5c c3 af 	mov    $0xffffffffafc35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1b60:	4c 89 ef             	mov    %r13,%rdi
    1b63:	be ec ff ff ff       	mov    $0xffffffec,%esi
    1b68:	ff d0                	call   *%rax
    1b6a:	85 c0                	test   %eax,%eax
    1b6c:	0f 85 d0 03 00 00    	jne    1f42 <balancer_ingress+0x1f42>
  data = (void*)(long)xdp->data;
    1b72:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1b76:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  iph = data + sizeof(struct ethhdr);
    1b7a:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1b7e:	48 39 ca             	cmp    %rcx,%rdx
    1b81:	0f 87 bb 03 00 00    	ja     1f42 <balancer_ingress+0x1f42>
    1b87:	48 8d 50 22          	lea    0x22(%rax),%rdx
    1b8b:	bd 01 00 00 00       	mov    $0x1,%ebp
    1b90:	48 39 ca             	cmp    %rcx,%rdx
    1b93:	0f 87 ae 03 00 00    	ja     1f47 <balancer_ingress+0x1f47>
    1b99:	8b 8c 24 80 00 00 00 	mov    0x80(%rsp),%ecx
    1ba0:	66 c1 c1 08          	rol    $0x8,%cx
    1ba4:	41 31 ce             	xor    %ecx,%r14d
    1ba7:	41 c1 e6 10          	shl    $0x10,%r14d
    1bab:	41 8d be ac 10 00 00 	lea    0x10ac(%r14),%edi
    1bb2:	48 b9 00 e8 fd 6d 81 	movabs $0xffff88816dfde800,%rcx
    1bb9:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1bbc:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    1bc3:	66 89 70 04          	mov    %si,0x4(%rax)
    1bc7:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1bcd:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1bcf:	8b 48 14             	mov    0x14(%rax),%ecx
    1bd2:	89 48 06             	mov    %ecx,0x6(%rax)
    1bd5:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    1bd9:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    1bdd:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1be3:	8a 54 24 3d          	mov    0x3d(%rsp),%dl
    1be7:	8b 0b                	mov    (%rbx),%ecx
  iph->ihl = 5;
    1be9:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->tos = tos;
    1bed:	88 50 0f             	mov    %dl,0xf(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1bf0:	41 83 c7 14          	add    $0x14,%r15d
    1bf4:	66 41 c1 c7 08       	rol    $0x8,%r15w
    1bf9:	66 44 89 78 10       	mov    %r15w,0x10(%rax)
  iph->id = 0;
    1bfe:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    1c05:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    1c08:	89 78 1a             	mov    %edi,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    1c0b:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    1c11:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    1c15:	41 0f b7 f7          	movzwl %r15w,%esi
    1c19:	0f b7 78 16          	movzwl 0x16(%rax),%edi
    1c1d:	41 c1 ee 10          	shr    $0x10,%r14d
    1c21:	49 01 f6             	add    %rsi,%r14
    1c24:	0f b7 f1             	movzwl %cx,%esi
    1c27:	4c 01 f6             	add    %r14,%rsi
    1c2a:	48 c1 e9 10          	shr    $0x10,%rcx
    1c2e:	48 01 f1             	add    %rsi,%rcx
    1c31:	48 01 d1             	add    %rdx,%rcx
    1c34:	48 01 f9             	add    %rdi,%rcx
    1c37:	48 81 c1 ac 10 00 00 	add    $0x10ac,%rcx
    1c3e:	48 89 ca             	mov    %rcx,%rdx
    1c41:	48 c1 ea 10          	shr    $0x10,%rdx
    1c45:	0f b7 f1             	movzwl %cx,%esi
    1c48:	48 01 d6             	add    %rdx,%rsi
    1c4b:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
    1c52:	48 0f 42 f1          	cmovb  %rcx,%rsi
    1c56:	48 89 f1             	mov    %rsi,%rcx
    1c59:	48 c1 e9 10          	shr    $0x10,%rcx
    1c5d:	0f b7 d6             	movzwl %si,%edx
    1c60:	48 01 ca             	add    %rcx,%rdx
    1c63:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    1c6a:	48 0f 42 d6          	cmovb  %rsi,%rdx
    1c6e:	48 89 d1             	mov    %rdx,%rcx
    1c71:	48 c1 e9 10          	shr    $0x10,%rcx
    1c75:	0f b7 f2             	movzwl %dx,%esi
    1c78:	48 01 ce             	add    %rcx,%rsi
    1c7b:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
    1c82:	48 0f 42 f2          	cmovb  %rdx,%rsi
    1c86:	89 f1                	mov    %esi,%ecx
    1c88:	c1 e9 10             	shr    $0x10,%ecx
    1c8b:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    1c92:	ba 00 00 01 00       	mov    $0x10000,%edx
    1c97:	0f 43 d1             	cmovae %ecx,%edx
    1c9a:	01 f2                	add    %esi,%edx
    1c9c:	f7 d2                	not    %edx
    1c9e:	66 89 50 18          	mov    %dx,0x18(%rax)
    1ca2:	e9 2a e7 ff ff       	jmp    3d1 <balancer_ingress+0x3d1>
      if (pckt.flow.proto == IPPROTO_TCP) {
    1ca7:	80 7c 24 34 06       	cmpb   $0x6,0x34(%rsp)
    1cac:	75 2a                	jne    1cd8 <balancer_ingress+0x1cd8>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1cae:	48 8b 82 08 11 00 00 	mov    0x1108(%rdx),%rax
    1cb5:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    1cbc:	79 b3 
        if (!lru_stats) {
    1cbe:	48 85 c0             	test   %rax,%rax
    1cc1:	0f 84 7b 02 00 00    	je     1f42 <balancer_ingress+0x1f42>
        if (pckt.flags & F_SYN_SET) {
    1cc7:	8b 4c 24 3c          	mov    0x3c(%rsp),%ecx
    1ccb:	c1 e1 02             	shl    $0x2,%ecx
    1cce:	f7 d1                	not    %ecx
    1cd0:	83 e1 08             	and    $0x8,%ecx
    1cd3:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
    1cd8:	48 89 74 24 50       	mov    %rsi,0x50(%rsp)
  struct real_pos_lru new_dst_lru = {};
    1cdd:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    1ce4:	00 00 
    1ce6:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    1ced:	00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1cef:	48 8b 9a 10 11 00 00 	mov    0x1110(%rdx),%rbx
    1cf6:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffb3795028,%rbx
    1cfd:	79 b3 
    1cff:	41 b7 01             	mov    $0x1,%r15b
  if (!conn_rate_stats) {
    1d02:	48 85 db             	test   %rbx,%rbx
    1d05:	74 29                	je     1d30 <balancer_ingress+0x1d30>
    1d07:	48 89 fd             	mov    %rdi,%rbp
    1d0a:	48 c7 c0 30 d6 a9 ad 	mov    $0xffffffffada9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1d11:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1d13:	48 89 c1             	mov    %rax,%rcx
    1d16:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1d1a:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1d21:	72 11                	jb     1d34 <balancer_ingress+0x1d34>
    conn_rate_stats->v1 = 1;
    1d23:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1d2a:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1d2e:	eb 17                	jmp    1d47 <balancer_ingress+0x1d47>
    1d30:	31 c0                	xor    %eax,%eax
    1d32:	eb 19                	jmp    1d4d <balancer_ingress+0x1d4d>
    conn_rate_stats->v1 += 1;
    1d34:	48 8b 0b             	mov    (%rbx),%rcx
    1d37:	48 83 c1 01          	add    $0x1,%rcx
    1d3b:	48 89 0b             	mov    %rcx,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1d3e:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    1d45:	77 03                	ja     1d4a <balancer_ingress+0x1d4a>
    1d47:	45 31 ff             	xor    %r15d,%r15d
    1d4a:	48 89 ef             	mov    %rbp,%rdi
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1d4d:	f6 07 08             	testb  $0x8,(%rdi)
    1d50:	75 25                	jne    1d77 <balancer_ingress+0x1d77>
    1d52:	49 89 fc             	mov    %rdi,%r12
    1d55:	8b 54 24 10          	mov    0x10(%rsp),%edx
    b += *(u32*)(k + 4);
    1d59:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
    c += *(u32*)(k + 8);
    1d5d:	8b 74 24 18          	mov    0x18(%rsp),%esi
      a += (u32)k[3] << 24;
    1d61:	40 8a 6c 24 1f       	mov    0x1f(%rsp),%bpl
      a += (u32)k[2] << 16;
    1d66:	44 8a 54 24 1e       	mov    0x1e(%rsp),%r10b
      a += (u32)k[1] << 8;
    1d6b:	44 8a 4c 24 1d       	mov    0x1d(%rsp),%r9b
      a += k[0];
    1d70:	44 8a 44 24 1c       	mov    0x1c(%rsp),%r8b
    1d75:	eb 30                	jmp    1da7 <balancer_ingress+0x1da7>
    1d77:	49 89 fc             	mov    %rdi,%r12
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1d7a:	0f b7 4c 24 32       	movzwl 0x32(%rsp),%ecx
    1d7f:	66 89 4c 24 30       	mov    %cx,0x30(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    1d84:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    1d8b:	00 00 
    1d8d:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
    1d94:	00 00 
    1d96:	45 31 c0             	xor    %r8d,%r8d
    1d99:	45 31 c9             	xor    %r9d,%r9d
    1d9c:	45 31 d2             	xor    %r10d,%r10d
    1d9f:	31 ed                	xor    %ebp,%ebp
    1da1:	31 f6                	xor    %esi,%esi
    1da3:	31 c9                	xor    %ecx,%ecx
    1da5:	31 d2                	xor    %edx,%edx
    c += *(u32*)(k + 8);
    1da7:	8d 9e ff c0 ad de    	lea    -0x21523f01(%rsi),%ebx
    __jhash_mix(a, b, c);
    1dad:	29 f2                	sub    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1daf:	c1 c3 04             	rol    $0x4,%ebx
    __jhash_mix(a, b, c);
    1db2:	31 d3                	xor    %edx,%ebx
    b += *(u32*)(k + 4);
    1db4:	89 ca                	mov    %ecx,%edx
    1db6:	81 c2 ff c0 ad de    	add    $0xdeadc0ff,%edx
    __jhash_mix(a, b, c);
    1dbc:	01 ce                	add    %ecx,%esi
    1dbe:	81 c6 fe 81 5b bd    	add    $0xbd5b81fe,%esi
    1dc4:	29 da                	sub    %ebx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1dc6:	89 df                	mov    %ebx,%edi
    1dc8:	c1 c7 06             	rol    $0x6,%edi
    __jhash_mix(a, b, c);
    1dcb:	31 d7                	xor    %edx,%edi
    1dcd:	01 f3                	add    %esi,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1dcf:	89 f9                	mov    %edi,%ecx
    1dd1:	c1 c1 08             	rol    $0x8,%ecx
    __jhash_mix(a, b, c);
    1dd4:	29 fe                	sub    %edi,%esi
    1dd6:	31 f1                	xor    %esi,%ecx
    1dd8:	01 df                	add    %ebx,%edi
    1dda:	29 cb                	sub    %ecx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1ddc:	89 ce                	mov    %ecx,%esi
    1dde:	c1 c6 10             	rol    $0x10,%esi
    __jhash_mix(a, b, c);
    1de1:	31 de                	xor    %ebx,%esi
    1de3:	01 f9                	add    %edi,%ecx
    1de5:	29 f7                	sub    %esi,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    1de7:	89 f3                	mov    %esi,%ebx
    1de9:	c1 c3 13             	rol    $0x13,%ebx
    __jhash_mix(a, b, c);
    1dec:	31 fb                	xor    %edi,%ebx
    1dee:	01 ce                	add    %ecx,%esi
    1df0:	29 d9                	sub    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1df2:	41 89 db             	mov    %ebx,%r11d
    1df5:	41 c1 c3 04          	rol    $0x4,%r11d
    __jhash_mix(a, b, c);
    1df9:	01 f3                	add    %esi,%ebx
      a += (u32)k[3] << 24;
    1dfb:	40 0f b6 d5          	movzbl %bpl,%edx
    1dff:	c1 e2 18             	shl    $0x18,%edx
      a += (u32)k[2] << 16;
    1e02:	41 0f b6 ea          	movzbl %r10b,%ebp
    1e06:	c1 e5 10             	shl    $0x10,%ebp
      a += (u32)k[3] << 24;
    1e09:	09 d5                	or     %edx,%ebp
      a += (u32)k[1] << 8;
    1e0b:	41 0f b6 f9          	movzbl %r9b,%edi
    1e0f:	c1 e7 08             	shl    $0x8,%edi
      a += (u32)k[2] << 16;
    1e12:	09 ef                	or     %ebp,%edi
      a += k[0];
    1e14:	41 0f b6 d0          	movzbl %r8b,%edx
      a += (u32)k[1] << 8;
    1e18:	09 fa                	or     %edi,%edx
      a += k[0];
    1e1a:	01 f2                	add    %esi,%edx
    __jhash_mix(a, b, c);
    1e1c:	31 d9                	xor    %ebx,%ecx
      __jhash_final(a, b, c);
    1e1e:	44 31 d9             	xor    %r11d,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e21:	89 de                	mov    %ebx,%esi
    1e23:	c1 c6 0e             	rol    $0xe,%esi
      __jhash_final(a, b, c);
    1e26:	29 f1                	sub    %esi,%ecx
    1e28:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e2a:	89 ce                	mov    %ecx,%esi
    1e2c:	c1 c6 0b             	rol    $0xb,%esi
      __jhash_final(a, b, c);
    1e2f:	29 f2                	sub    %esi,%edx
    1e31:	31 d3                	xor    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1e33:	89 d6                	mov    %edx,%esi
    1e35:	c1 c6 19             	rol    $0x19,%esi
      __jhash_final(a, b, c);
    1e38:	29 f3                	sub    %esi,%ebx
    1e3a:	31 d9                	xor    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e3c:	89 de                	mov    %ebx,%esi
    1e3e:	c1 c6 10             	rol    $0x10,%esi
      __jhash_final(a, b, c);
    1e41:	29 f1                	sub    %esi,%ecx
    1e43:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e45:	89 ce                	mov    %ecx,%esi
    1e47:	c1 c6 04             	rol    $0x4,%esi
      __jhash_final(a, b, c);
    1e4a:	29 f2                	sub    %esi,%edx
    1e4c:	31 d3                	xor    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1e4e:	c1 c2 0e             	rol    $0xe,%edx
      __jhash_final(a, b, c);
    1e51:	29 d3                	sub    %edx,%ebx
    1e53:	31 d9                	xor    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e55:	c1 c3 18             	rol    $0x18,%ebx
  a += initval;
    1e58:	29 d9                	sub    %ebx,%ecx
    1e5a:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  b += initval;
    1e5f:	03 74 24 30          	add    0x30(%rsp),%esi
  a += initval;
    1e63:	81 c1 f7 c0 ad e0    	add    $0xe0adc0f7,%ecx
  __jhash_final(a, b, c);
    1e69:	89 f2                	mov    %esi,%edx
    1e6b:	81 f2 f7 c0 ad e0    	xor    $0xe0adc0f7,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e71:	89 f7                	mov    %esi,%edi
    1e73:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    1e76:	29 fa                	sub    %edi,%edx
    1e78:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e7a:	89 d7                	mov    %edx,%edi
    1e7c:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    1e7f:	29 f9                	sub    %edi,%ecx
    1e81:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1e83:	89 cf                	mov    %ecx,%edi
    1e85:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    1e88:	29 fe                	sub    %edi,%esi
    1e8a:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e8c:	89 f7                	mov    %esi,%edi
    1e8e:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    1e91:	29 fa                	sub    %edi,%edx
    1e93:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e95:	89 d7                	mov    %edx,%edi
    1e97:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1e9a:	29 f9                	sub    %edi,%ecx
    1e9c:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1e9e:	c1 c1 0e             	rol    $0xe,%ecx
  __jhash_final(a, b, c);
    1ea1:	29 ce                	sub    %ecx,%esi
    1ea3:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1ea5:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    1ea8:	29 f2                	sub    %esi,%edx
    1eaa:	b9 01 00 ff ff       	mov    $0xffff0001,%ecx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1eaf:	48 0f af ca          	imul   %rdx,%rcx
    1eb3:	48 c1 e9 30          	shr    $0x30,%rcx
    1eb7:	89 ce                	mov    %ecx,%esi
    1eb9:	c1 e6 10             	shl    $0x10,%esi
    1ebc:	09 ce                	or     %ecx,%esi
    1ebe:	29 f2                	sub    %esi,%edx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1ec0:	41 8b 74 24 04       	mov    0x4(%r12),%esi
    1ec5:	89 f1                	mov    %esi,%ecx
    1ec7:	c1 e1 10             	shl    $0x10,%ecx
    1eca:	01 f1                	add    %esi,%ecx
    1ecc:	01 d1                	add    %edx,%ecx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1ece:	81 f9 ff 01 00 02    	cmp    $0x20001ff,%ecx
    if (!real_pos) {
    1ed4:	77 6c                	ja     1f42 <balancer_ingress+0x1f42>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1ed6:	89 c9                	mov    %ecx,%ecx
    1ed8:	48 ba 00 b0 26 39 03 	movabs $0xffffc9033926b000,%rdx
    1edf:	c9 ff ff 
    key = *real_pos;
    1ee2:	8b ac ca 00 01 00 00 	mov    0x100(%rdx,%rcx,8),%ebp
    1ee9:	48 85 ed             	test   %rbp,%rbp
    if (key == 0) {
    1eec:	74 2d                	je     1f1b <balancer_ingress+0x1f1b>
  pckt->real_index = key;
    1eee:	89 6c 24 38          	mov    %ebp,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1ef2:	81 fd 00 10 00 00    	cmp    $0x1000,%ebp
  if (!(*real)) {
    1ef8:	72 61                	jb     1f5b <balancer_ingress+0x1f5b>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1efa:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    1f01:	88 ff ff 
    1f04:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1f0b:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    1f12:	79 b3 
  if (!ch_drop_stats) {
    1f14:	48 85 c0             	test   %rax,%rax
    1f17:	75 25                	jne    1f3e <balancer_ingress+0x1f3e>
    1f19:	eb 27                	jmp    1f42 <balancer_ingress+0x1f42>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1f1b:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    1f22:	88 ff ff 
    1f25:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1f2c:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    1f33:	79 b3 
  if (!ch_drop_stats) {
    1f35:	48 85 c0             	test   %rax,%rax
    1f38:	74 08                	je     1f42 <balancer_ingress+0x1f42>
    1f3a:	48 83 c0 08          	add    $0x8,%rax
    1f3e:	48 83 00 01          	addq   $0x1,(%rax)
    1f42:	bd 01 00 00 00       	mov    $0x1,%ebp
    return process_packet(ctx, nh_off, true);
  } else {
    // pass to tcp/ip stack
    return XDP_PASS;
  }
}
    1f47:	89 e8                	mov    %ebp,%eax
    1f49:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    1f50:	5b                   	pop    %rbx
    1f51:	41 5c                	pop    %r12
    1f53:	41 5d                	pop    %r13
    1f55:	41 5e                	pop    %r14
    1f57:	41 5f                	pop    %r15
    1f59:	5d                   	pop    %rbp
    1f5a:	c3                   	ret
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1f5b:	48 83 7c 24 08 00    	cmpq   $0x0,0x8(%rsp)
    1f61:	74 15                	je     1f78 <balancer_ingress+0x1f78>
    1f63:	4c 89 e6             	mov    %r12,%rsi
    1f66:	41 8a 0c 24          	mov    (%r12),%cl
    1f6a:	80 e1 02             	and    $0x2,%cl
    1f6d:	d0 e9                	shr    %cl
    1f6f:	41 08 cf             	or     %cl,%r15b
    1f72:	0f 84 ca 00 00 00    	je     2042 <balancer_ingress+0x2042>
    1f78:	89 e8                	mov    %ebp,%eax
    1f7a:	e9 ee 00 00 00       	jmp    206d <balancer_ingress+0x206d>
    1f7f:	48 c7 c0 20 5c c3 af 	mov    $0xffffffffafc35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1f86:	4c 89 ef             	mov    %r13,%rdi
    1f89:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1f8e:	ff d0                	call   *%rax
    1f90:	85 c0                	test   %eax,%eax
    1f92:	75 ae                	jne    1f42 <balancer_ingress+0x1f42>
  data = (void*)(long)xdp->data;
    1f94:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1f98:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1f9c:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1fa0:	48 39 ca             	cmp    %rcx,%rdx
    1fa3:	77 9d                	ja     1f42 <balancer_ingress+0x1f42>
    1fa5:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1fa9:	bd 01 00 00 00       	mov    $0x1,%ebp
    1fae:	48 39 ca             	cmp    %rcx,%rdx
    1fb1:	77 94                	ja     1f47 <balancer_ingress+0x1f47>
    1fb3:	48 b9 00 e8 fd 6d 81 	movabs $0xffff88816dfde800,%rcx
    1fba:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1fbd:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1fc4:	66 89 50 04          	mov    %dx,0x4(%rax)
    1fc8:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1fce:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1fd0:	8b 48 28             	mov    0x28(%rax),%ecx
    1fd3:	89 48 06             	mov    %ecx,0x6(%rax)
    1fd6:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    1fda:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    1fde:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    1fe4:	0f b7 74 24 30       	movzwl 0x30(%rsp),%esi
  saddr[3] = src ^ port;
    1fe9:	33 74 24 1c          	xor    0x1c(%rsp),%esi
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    1fed:	41 83 c7 28          	add    $0x28,%r15d
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1ff1:	8a 4c 24 3d          	mov    0x3d(%rsp),%cl
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1ff5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    1ffb:	89 ca                	mov    %ecx,%edx
    1ffd:	c0 ea 04             	shr    $0x4,%dl
    2000:	80 ca 60             	or     $0x60,%dl
    2003:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    2006:	c0 e1 04             	shl    $0x4,%cl
    2009:	88 48 0f             	mov    %cl,0xf(%rax)
  ip6h->nexthdr = proto;
    200c:	66 c7 40 14 29 40    	movw   $0x4029,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    2012:	66 41 c1 c7 08       	rol    $0x8,%r15w
    2017:	66 44 89 78 12       	mov    %r15w,0x12(%rax)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    201c:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    2023:	00 
    2024:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    202b:	89 70 22             	mov    %esi,0x22(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    202e:	48 8b 0b             	mov    (%rbx),%rcx
    2031:	48 8b 53 08          	mov    0x8(%rbx),%rdx
    2035:	48 89 48 26          	mov    %rcx,0x26(%rax)
    2039:	48 89 50 2e          	mov    %rdx,0x2e(%rax)
    203d:	e9 8f e3 ff ff       	jmp    3d1 <balancer_ingress+0x3d1>
    if (pckt->flow.proto == IPPROTO_UDP) {
    2042:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    2047:	75 05                	jne    204e <balancer_ingress+0x204e>
      new_dst_lru.atime = cur_time;
    2049:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    new_dst_lru.pos = key;
    204e:	89 6c 24 40          	mov    %ebp,0x40(%rsp)
    2052:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
BPF_MAP_OPS_INLINE(int,
    2057:	48 8b 07             	mov    (%rdi),%rax
    205a:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    205f:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    2064:	31 c9                	xor    %ecx,%ecx
    2066:	ff 50 68             	call   *0x68(%rax)
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    2069:	8b 44 24 38          	mov    0x38(%rsp),%eax
    206d:	48 b9 00 e0 fd 6d 81 	movabs $0xffff88816dfde000,%rcx
    2074:	88 ff ff 
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    2077:	8b b1 00 01 00 00    	mov    0x100(%rcx),%esi
    207d:	b2 01                	mov    $0x1,%dl
    207f:	3b 74 24 60          	cmp    0x60(%rsp),%esi
    2083:	75 25                	jne    20aa <balancer_ingress+0x20aa>
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    2085:	8b b1 04 01 00 00    	mov    0x104(%rcx),%esi
    208b:	3b 74 24 64          	cmp    0x64(%rsp),%esi
    208f:	75 19                	jne    20aa <balancer_ingress+0x20aa>
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    2091:	8b b1 08 01 00 00    	mov    0x108(%rcx),%esi
    2097:	3b 74 24 68          	cmp    0x68(%rsp),%esi
    209b:	75 0d                	jne    20aa <balancer_ingress+0x20aa>
    209d:	8b 91 0c 01 00 00    	mov    0x10c(%rcx),%edx
    20a3:	3b 54 24 6c          	cmp    0x6c(%rsp),%edx
    20a7:	0f 95 c2             	setne  %dl
  bool port_match = lru_miss_stat_vip->port == vip->port;
    20aa:	0f b7 b1 10 01 00 00 	movzwl 0x110(%rcx),%esi
    20b1:	0f b7 7c 24 70       	movzwl 0x70(%rsp),%edi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    20b6:	8a 5c 24 72          	mov    0x72(%rsp),%bl
    20ba:	88 99 12 01 00 00    	mov    %bl,0x112(%rcx)
  bool vip_match = address_match && port_match && proto_match;
    20c0:	84 d2                	test   %dl,%dl
    20c2:	75 3d                	jne    2101 <balancer_ingress+0x2101>
    20c4:	66 39 fe             	cmp    %di,%si
    20c7:	75 38                	jne    2101 <balancer_ingress+0x2101>
    20c9:	84 db                	test   %bl,%bl
    20cb:	74 34                	je     2101 <balancer_ingress+0x2101>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    20cd:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    20d2:	0f 87 6a fe ff ff    	ja     1f42 <balancer_ingress+0x1f42>
    20d8:	89 c0                	mov    %eax,%eax
    20da:	48 b9 00 20 29 49 03 	movabs $0xffffc90349292000,%rcx
    20e1:	c9 ff ff 
    20e4:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    20eb:	00 
    20ec:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    20f3:	79 b3 
    if (!lru_miss_stat) {
    20f5:	48 85 c0             	test   %rax,%rax
    20f8:	0f 84 44 fe ff ff    	je     1f42 <balancer_ingress+0x1f42>
    *lru_miss_stat += 1;
    20fe:	83 00 01             	addl   $0x1,(%rax)
    2101:	48 8d 04 6d 00 00 00 	lea    0x0(,%rbp,2),%rax
    2108:	00 
    2109:	48 01 e8             	add    %rbp,%rax
    210c:	48 b9 00 e0 26 49 03 	movabs $0xffffc9034926e000,%rcx
    2113:	c9 ff ff 
    2116:	48 8d 1c c1          	lea    (%rcx,%rax,8),%rbx
    211a:	48 81 c3 00 01 00 00 	add    $0x100,%rbx
      data_stats->v2 += 1;
    2121:	49 83 46 08 01       	addq   $0x1,0x8(%r14)
    2126:	48 ba 00 40 77 3d 81 	movabs $0xffff88813d774000,%rdx
    212d:	88 ff ff 
    2130:	48 8b 74 24 50       	mov    0x50(%rsp),%rsi
    2135:	e9 8a f9 ff ff       	jmp    1ac4 <balancer_ingress+0x1ac4>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    213a:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    213e:	48 c1 e1 18          	shl    $0x18,%rcx
    2142:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    2146:	48 c1 e2 10          	shl    $0x10,%rdx
    214a:	48 09 ca             	or     %rcx,%rdx
    214d:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    2151:	48 c1 e1 08          	shl    $0x8,%rcx
    2155:	48 09 d1             	or     %rdx,%rcx
    2158:	8a 40 04             	mov    0x4(%rax),%al
    215b:	b2 03                	mov    $0x3,%dl
    215d:	eb 18                	jmp    2177 <balancer_ingress+0x2177>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    215f:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    2163:	48 c1 e2 10          	shl    $0x10,%rdx
    2167:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    216b:	48 c1 e1 08          	shl    $0x8,%rcx
    216f:	48 09 d1             	or     %rdx,%rcx
    2172:	8a 40 03             	mov    0x3(%rax),%al
    2175:	b2 02                	mov    $0x2,%dl
    2177:	0f b6 c0             	movzbl %al,%eax
    217a:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    217d:	85 c0                	test   %eax,%eax
    217f:	0f 8e 39 ee ff ff    	jle    fbe <balancer_ingress+0xfbe>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    2185:	80 fa 01             	cmp    $0x1,%dl
    2188:	74 61                	je     21eb <balancer_ingress+0x21eb>
    218a:	80 fa 03             	cmp    $0x3,%dl
    218d:	74 63                	je     21f2 <balancer_ingress+0x21f2>
    218f:	80 fa 02             	cmp    $0x2,%dl
    2192:	75 65                	jne    21f9 <balancer_ingress+0x21f9>
    2194:	b9 40 00 00 00       	mov    $0x40,%ecx
    2199:	eb 63                	jmp    21fe <balancer_ingress+0x21fe>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    219b:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    21a2:	88 ff ff 
    21a5:	4c 8b b0 10 11 00 00 	mov    0x1110(%rax),%r14
    21ac:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffb3795028,%r14
    21b3:	79 b3 
  if (!conn_rate_stats) {
    21b5:	4d 85 f6             	test   %r14,%r14
    21b8:	0f 84 58 01 00 00    	je     2316 <balancer_ingress+0x2316>
    21be:	48 c7 c0 30 d6 a9 ad 	mov    $0xffffffffada9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    21c5:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    21c7:	48 89 c1             	mov    %rax,%rcx
    21ca:	49 2b 4e 08          	sub    0x8(%r14),%rcx
    21ce:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    21d5:	0f 82 f8 00 00 00    	jb     22d3 <balancer_ingress+0x22d3>
    conn_rate_stats->v1 = 1;
    21db:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    conn_rate_stats->v2 = *cur_time;
    21e2:	49 89 46 08          	mov    %rax,0x8(%r14)
    21e6:	e9 fa 00 00 00       	jmp    22e5 <balancer_ingress+0x22e5>
    21eb:	b9 38 00 00 00       	mov    $0x38,%ecx
    21f0:	eb 0c                	jmp    21fe <balancer_ingress+0x21fe>
    21f2:	b9 48 00 00 00       	mov    $0x48,%ecx
    21f7:	eb 05                	jmp    21fe <balancer_ingress+0x21fe>
    21f9:	b9 30 00 00 00       	mov    $0x30,%ecx
    21fe:	48 83 44 0d 00 01    	addq   $0x1,0x0(%rbp,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    2204:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    2209:	77 73                	ja     227e <balancer_ingress+0x227e>
    220b:	48 b9 00 c0 29 49 03 	movabs $0xffffc9034929c000,%rcx
    2212:	c9 ff ff 
          key = *real_pos;
    2215:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    221c:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    221f:	74 5d                	je     227e <balancer_ingress+0x227e>
            pckt.real_index = key;
    2221:	89 4c 24 38          	mov    %ecx,0x38(%rsp)
    2225:	45 31 f6             	xor    %r14d,%r14d
            dst = bpf_map_lookup_elem(&reals, &key);
    2228:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    222e:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    2232:	48 b9 00 e0 26 49 03 	movabs $0xffffc9034926e000,%rcx
    2239:	c9 ff ff 
    223c:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    2243:	00 
    2244:	4c 0f 42 f0          	cmovb  %rax,%r14
            if (!dst) {
    2248:	4d 85 f6             	test   %r14,%r14
    224b:	74 46                	je     2293 <balancer_ingress+0x2293>
    224d:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
BPF_MAP_OPS_INLINE(void*,
    2252:	48 8b 07             	mov    (%rdi),%rax
    2255:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    225a:	ff 50 60             	call   *0x60(%rax)
  if (dst_lru) {
    225d:	48 85 c0             	test   %rax,%rax
    2260:	0f 84 de 00 00 00    	je     2344 <balancer_ingress+0x2344>
    if (dst_lru->pos == pckt->real_index) {
    2266:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    226a:	39 08                	cmp    %ecx,(%rax)
    226c:	0f 85 1b 01 00 00    	jne    238d <balancer_ingress+0x238d>
              quic_packets_stats->dst_match_in_lru += 1;
    2272:	48 89 e8             	mov    %rbp,%rax
    2275:	48 83 c0 50          	add    $0x50,%rax
    2279:	e9 9b 01 00 00       	jmp    2419 <balancer_ingress+0x2419>
    227e:	48 83 45 10 01       	addq   $0x1,0x10(%rbp)
    2283:	48 98                	cltq
    2285:	48 89 45 18          	mov    %rax,0x18(%rbp)
    2289:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    228e:	e9 6c ed ff ff       	jmp    fff <balancer_ingress+0xfff>
    2293:	48 83 45 28 01       	addq   $0x1,0x28(%rbp)
    2298:	e9 a5 fc ff ff       	jmp    1f42 <balancer_ingress+0x1f42>
      dst_lru->pos = pckt->real_index;
    229d:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    229f:	48 83 45 58 01       	addq   $0x1,0x58(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    22a4:	41 81 ff ff 01 00 00 	cmp    $0x1ff,%r15d
    22ab:	77 74                	ja     2321 <balancer_ingress+0x2321>
    22ad:	48 b8 00 c0 a4 4b 81 	movabs $0xffff88814ba4c000,%rax
    22b4:	88 ff ff 
    22b7:	4a 8b 84 f8 00 01 00 	mov    0x100(%rax,%r15,8),%rax
    22be:	00 
    22bf:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    22c6:	79 b3 
  if (!per_vip_stats) {
    22c8:	48 85 c0             	test   %rax,%rax
    22cb:	74 54                	je     2321 <balancer_ingress+0x2321>
    per_vip_stats->v2 += 1;
    22cd:	48 83 c0 08          	add    $0x8,%rax
    22d1:	eb 4a                	jmp    231d <balancer_ingress+0x231d>
    conn_rate_stats->v1 += 1;
    22d3:	49 8b 06             	mov    (%r14),%rax
    22d6:	48 83 c0 01          	add    $0x1,%rax
    22da:	49 89 06             	mov    %rax,(%r14)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    22dd:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    22e3:	77 31                	ja     2316 <balancer_ingress+0x2316>
  struct real_pos_lru new_dst_lru = {};
    22e5:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    22ec:	00 00 
    22ee:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    22f5:	00 00 
  new_dst_lru.pos = pckt->real_index;
    22f7:	8b 44 24 38          	mov    0x38(%rsp),%eax
    22fb:	89 44 24 40          	mov    %eax,0x40(%rsp)
    22ff:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
BPF_MAP_OPS_INLINE(int,
    2304:	48 8b 07             	mov    (%rdi),%rax
    2307:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    230c:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    2311:	31 c9                	xor    %ecx,%ecx
    2313:	ff 50 68             	call   *0x68(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    2316:	48 89 e8             	mov    %rbp,%rax
    2319:	48 83 c0 60          	add    $0x60,%rax
    231d:	48 83 00 01          	addq   $0x1,(%rax)
            quic_packets_stats->cid_routed += 1;
    2321:	48 83 45 20 01       	addq   $0x1,0x20(%rbp)
  original_sport = pckt.flow.port16[0];
    2326:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
    232b:	89 84 24 80 00 00 00 	mov    %eax,0x80(%rsp)
    2332:	48 ba 00 40 77 3d 81 	movabs $0xffff88813d774000,%rdx
    2339:	88 ff ff 
    233c:	4c 89 fe             	mov    %r15,%rsi
    233f:	e9 80 f7 ff ff       	jmp    1ac4 <balancer_ingress+0x1ac4>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2344:	48 b8 00 40 77 3d 81 	movabs $0xffff88813d774000,%rax
    234b:	88 ff ff 
    234e:	48 8b 98 10 11 00 00 	mov    0x1110(%rax),%rbx
    2355:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffb3795028,%rbx
    235c:	79 b3 
  if (!conn_rate_stats) {
    235e:	48 85 db             	test   %rbx,%rbx
    2361:	0f 84 ab 00 00 00    	je     2412 <balancer_ingress+0x2412>
    2367:	48 c7 c0 30 d6 a9 ad 	mov    $0xffffffffada9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    236e:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    2370:	48 89 c1             	mov    %rax,%rcx
    2373:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    2377:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    237e:	72 4f                	jb     23cf <balancer_ingress+0x23cf>
    conn_rate_stats->v1 = 1;
    2380:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    2387:	48 89 43 08          	mov    %rax,0x8(%rbx)
    238b:	eb 54                	jmp    23e1 <balancer_ingress+0x23e1>
      dst_lru->pos = pckt->real_index;
    238d:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    238f:	48 83 45 58 01       	addq   $0x1,0x58(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2394:	81 bc 24 80 00 00 00 	cmpl   $0x1ff,0x80(%rsp)
    239b:	ff 01 00 00 
    239f:	77 7c                	ja     241d <balancer_ingress+0x241d>
    23a1:	48 b8 00 c0 a4 4b 81 	movabs $0xffff88814ba4c000,%rax
    23a8:	88 ff ff 
    23ab:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
    23b2:	00 
    23b3:	48 8b 84 c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rax
    23ba:	00 
    23bb:	65 48 03 04 25 28 50 	add    %gs:0xffffffffb3795028,%rax
    23c2:	79 b3 
  if (!per_vip_stats) {
    23c4:	48 85 c0             	test   %rax,%rax
    23c7:	74 54                	je     241d <balancer_ingress+0x241d>
    per_vip_stats->v2 += 1;
    23c9:	48 83 c0 08          	add    $0x8,%rax
    23cd:	eb 4a                	jmp    2419 <balancer_ingress+0x2419>
    conn_rate_stats->v1 += 1;
    23cf:	48 8b 03             	mov    (%rbx),%rax
    23d2:	48 83 c0 01          	add    $0x1,%rax
    23d6:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    23d9:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    23df:	77 31                	ja     2412 <balancer_ingress+0x2412>
  struct real_pos_lru new_dst_lru = {};
    23e1:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    23e8:	00 00 
    23ea:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    23f1:	00 00 
  new_dst_lru.pos = pckt->real_index;
    23f3:	8b 44 24 38          	mov    0x38(%rsp),%eax
    23f7:	89 44 24 40          	mov    %eax,0x40(%rsp)
    23fb:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
    2400:	48 8b 07             	mov    (%rdi),%rax
    2403:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    2408:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    240d:	31 c9                	xor    %ecx,%ecx
    240f:	ff 50 68             	call   *0x68(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    2412:	48 89 e8             	mov    %rbp,%rax
    2415:	48 83 c0 60          	add    $0x60,%rax
    2419:	48 83 00 01          	addq   $0x1,(%rax)
            quic_packets_stats->cid_routed += 1;
    241d:	48 83 45 20 01       	addq   $0x1,0x20(%rbp)
  original_sport = pckt.flow.port16[0];
    2422:	44 0f b7 64 24 30    	movzwl 0x30(%rsp),%r12d
    2428:	e9 bd ee ff ff       	jmp    12ea <balancer_ingress+0x12ea>

Disassembly of section license:

000000000000242d <_license>:
    242d:	47 50                	rex.RXB push %r8
    242f:	4c                   	rex.WR
	...

Disassembly of section .maps:

0000000000002438 <.maps>:
	...

Disassembly of section .debug_loclists:

0000000000000000 <.debug_loclists>:
  void* data = (void*)(long)ctx->data;
       0:	62                   	(bad)
       1:	2e 00 00             	cs add %al,(%rax)
       4:	05 00 08 00 9a       	add    $0x9a000800,%eax
       9:	01 00                	add    %eax,(%rax)
       b:	00 68 06             	add    %ch,0x6(%rax)
       e:	00 00                	add    %al,(%rax)
      10:	85 06                	test   %eax,(%rsi)
      12:	00 00                	add    %al,(%rax)
      14:	a1 06 00 00 d2 06 00 	movabs 0xee000006d2000006,%eax
      1b:	00 ee 
  if (data + nh_off > data_end) {
      1d:	06                   	(bad)
      1e:	00 00                	add    %al,(%rax)
      20:	f6 06 00             	testb  $0x0,(%rsi)
      23:	00 26                	add    %ah,(%rsi)
      25:	07                   	(bad)
      26:	00 00                	add    %al,(%rax)
      28:	81 07 00 00 e9 07    	addl   $0x7e90000,(%rdi)
      2e:	00 00                	add    %al,(%rax)
      30:	51                   	push   %rcx
  eth_proto = eth->h_proto;
      31:	08 00                	or     %al,(%rax)
      33:	00 89 08 00 00 dd    	add    %cl,-0x22fffff8(%rcx)
  if (eth_proto == BE_ETH_P_IP) {
      39:	08 00                	or     %al,(%rax)
      3b:	00 68 09             	add    %ch,0x9(%rax)
      3e:	00 00                	add    %al,(%rax)
      40:	d1 09                	rorl   (%rcx)
      42:	00 00                	add    %al,(%rax)
      44:	fc                   	cld
      45:	09 00                	or     %eax,(%rax)
      47:	00 0f                	add    %cl,(%rdi)
      49:	0a 00                	or     (%rax),%al
      4b:	00 20                	add    %ah,(%rax)
      4d:	0a 00                	or     (%rax),%al
      4f:	00 2f                	add    %ch,(%rdi)
  struct packet_description pckt = {};
      51:	0a 00                	or     (%rax),%al
      53:	00 3e                	add    %bh,(%rsi)
      55:	0a 00                	or     (%rax),%al
      57:	00 4f 0a             	add    %cl,0xa(%rdi)
      5a:	00 00                	add    %al,(%rax)
      5c:	60                   	(bad)
      5d:	0a 00                	or     (%rax),%al
      5f:	00 6f 0a             	add    %ch,0xa(%rdi)
      62:	00 00                	add    %al,(%rax)
      64:	7e 0a                	jle    70 <balancer_ingress+0x70>
      66:	00 00                	add    %al,(%rax)
      68:	9a                   	(bad)
      69:	0a 00                	or     (%rax),%al
      6b:	00 ad 0a 00 00 bc    	add    %ch,-0x43fffff6(%rbp)
      71:	0a 00                	or     (%rax),%al
      73:	00 cc                	add    %cl,%ah
      75:	0a 00                	or     (%rax),%al
      77:	00 0c 0b             	add    %cl,(%rbx,%rcx,1)
      7a:	00 00                	add    %al,(%rax)
      7c:	45 0b 00             	or     (%r8),%r8d
      7f:	00 bd 0b 00 00 46    	add    %bh,0x4600000b(%rbp)
      85:	0c 00                	or     $0x0,%al
  struct vip_definition vip = {};
      87:	00 cf                	add    %cl,%bh
      89:	0c 00                	or     $0x0,%al
      8b:	00 08                	add    %cl,(%rax)
      8d:	0d 00 00 6b 0d       	or     $0xd6b0000,%eax
      92:	00 00                	add    %al,(%rax)
      94:	05 0e 00 00 8e       	add    $0x8e00000e,%eax
      99:	0e                   	(bad)
      9a:	00 00                	add    %al,(%rax)
      9c:	c2 0e 00             	ret    $0xe
      9f:	00 d5                	add    %dl,%ch
    if (iph + 1 > data_end) {
      a1:	0e                   	(bad)
      a2:	00 00                	add    %al,(%rax)
      a4:	e6 0e                	out    %al,$0xe
      a6:	00 00                	add    %al,(%rax)
      a8:	f5                   	cmc
      a9:	0e                   	(bad)
      aa:	00 00                	add    %al,(%rax)
      ac:	04 0f                	add    $0xf,%al
    if (iph->ihl != 5) {
      ae:	00 00                	add    %al,(%rax)
      b0:	15 0f 00 00 26       	adc    $0x2600000f,%eax
      b5:	0f 00 00             	sldt   (%rax)
      b8:	39 0f                	cmp    %ecx,(%rdi)
    pckt->tos = iph->tos;
      ba:	00 00                	add    %al,(%rax)
      bc:	48 0f 00 00          	rex.W sldt (%rax)
    *protocol = iph->protocol;
      c0:	57                   	push   %rdi
      c1:	0f 00 00             	sldt   (%rax)
    pckt->flow.proto = *protocol;
      c4:	6a 0f                	push   $0xf
      c6:	00 00                	add    %al,(%rax)
    if (iph->frag_off & PCKT_FRAGMENTED) {
      c8:	79 0f                	jns    d9 <balancer_ingress+0xd9>
      ca:	00 00                	add    %al,(%rax)
      cc:	25 10 00 00 49       	and    $0x49000010,%eax
      d1:	10 00                	adc    %al,(%rax)
      d3:	00 58 10             	add    %bl,0x10(%rax)
      d6:	00 00                	add    %al,(%rax)
      d8:	67 10 00             	adc    %al,(%eax)
    if (*protocol == IPPROTO_ICMP) {
      db:	00 7a 10             	add    %bh,0x10(%rdx)
      de:	00 00                	add    %al,(%rax)
      e0:	8d 10                	lea    (%rax),%edx
      e2:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
      e4:	95                   	xchg   %eax,%ebp
      e5:	10 00                	adc    %al,(%rax)
      e7:	00 a4 10 00 00 b3 10 	add    %ah,0x10b30000(%rax,%rdx,1)
      ee:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
      f0:	cf                   	iret
      f1:	10 00                	adc    %al,(%rax)
      f3:	00 e2                	add    %ah,%dl
      f5:	10 00                	adc    %al,(%rax)
      f7:	00 f1                	add    %dh,%cl
      f9:	10 00                	adc    %al,(%rax)
      fb:	00 01                	add    %al,(%rcx)
      fd:	11 00                	adc    %eax,(%rax)
      ff:	00 13                	add    %dl,(%rbx)
     101:	11 00                	adc    %eax,(%rax)
     103:	00 1d 11 00 00 6f    	add    %bl,0x6f000011(%rip)        # 6f00011a <_license+0x6effdced>
     109:	11 00                	adc    %eax,(%rax)
     10b:	00 ba 11 00 00 c2    	add    %bh,-0x3dffffef(%rdx)
  icmp_hdr->type = ICMP_ECHOREPLY;
     111:	11 00                	adc    %eax,(%rax)
  icmp_hdr->checksum += 0x0008;
     113:	00 ca                	add    %cl,%dl
     115:	11 00                	adc    %eax,(%rax)
  iph->ttl = DEFAULT_TTL;
     117:	00 52 12             	add    %dl,0x12(%rdx)
     11a:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
     11c:	76 12                	jbe    130 <balancer_ingress+0x130>
  tmp_addr = iph->daddr;
     11e:	00 00                	add    %al,(%rax)
     120:	85 12                	test   %edx,(%rdx)
  iph->daddr = iph->saddr;
     122:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
     124:	94                   	xchg   %eax,%esp
     125:	12 00                	adc    (%rax),%al
     127:	00 a7 12 00 00 ba    	add    %ah,-0x45ffffee(%rdi)
     12d:	12 00                	adc    (%rax),%al
     12f:	00 c2                	add    %al,%dl
     131:	12 00                	adc    (%rax),%al
     133:	00 d1                	add    %dl,%cl
     135:	12 00                	adc    (%rax),%al
     137:	00 e0                	add    %ah,%al
     139:	12 00                	adc    (%rax),%al
     13b:	00 fc                	add    %bh,%ah
     13d:	12 00                	adc    (%rax),%al
     13f:	00 0f                	add    %cl,(%rdi)
     141:	13 00                	adc    (%rax),%eax
     143:	00 1e                	add    %bl,(%rsi)
     145:	13 00                	adc    (%rax),%eax
     147:	00 26                	add    %ah,(%rsi)
     149:	13 00                	adc    (%rax),%eax
     14b:	00 36                	add    %dh,(%rsi)
     14d:	13 00                	adc    (%rax),%eax
     14f:	00 3e                	add    %bh,(%rsi)
     151:	13 00                	adc    (%rax),%eax
     153:	00 46 13             	add    %al,0x13(%rsi)
     156:	00 00                	add    %al,(%rax)
     158:	50                   	push   %rax
     159:	13 00                	adc    (%rax),%eax
     15b:	00 5a 13             	add    %bl,0x13(%rdx)
     15e:	00 00                	add    %al,(%rax)
  struct packet_description pckt = {};
     160:	6b 13 00             	imul   $0x0,(%rbx),%edx
     163:	00 7e 13             	add    %bh,0x13(%rsi)
     166:	00 00                	add    %al,(%rax)
     168:	8f                   	(bad)
     169:	13 00                	adc    (%rax),%eax
     16b:	00 9f 13 00 00 a7    	add    %bl,-0x58ffffed(%rdi)
     171:	13 00                	adc    (%rax),%eax
     173:	00 b2 13 00 00 c1    	add    %dh,-0x3effffed(%rdx)
     179:	13 00                	adc    (%rax),%eax
     17b:	00 d1                	add    %dl,%cl
     17d:	13 00                	adc    (%rax),%eax
     17f:	00 d9                	add    %bl,%cl
     181:	13 00                	adc    (%rax),%eax
     183:	00 e1                	add    %ah,%cl
     185:	13 00                	adc    (%rax),%eax
     187:	00 ec                	add    %ch,%ah
     189:	13 00                	adc    (%rax),%eax
     18b:	00 fc                	add    %bh,%ah
     18d:	13 00                	adc    (%rax),%eax
     18f:	00 04 14             	add    %al,(%rsp,%rdx,1)
     192:	00 00                	add    %al,(%rax)
     194:	14 14                	adc    $0x14,%al
  struct vip_definition vip = {};
     196:	00 00                	add    %al,(%rax)
     198:	1c 14                	sbb    $0x14,%al
     19a:	00 00                	add    %al,(%rax)
     19c:	2d 14 00 00 40       	sub    $0x40000014,%eax
     1a1:	14 00                	adc    $0x0,%al
     1a3:	00 51 14             	add    %dl,0x14(%rcx)
     1a6:	00 00                	add    %al,(%rax)
     1a8:	61                   	(bad)
     1a9:	14 00                	adc    $0x0,%al
     1ab:	00 69 14             	add    %ch,0x14(%rcx)
     1ae:	00 00                	add    %al,(%rax)
    if (ip6h + 1 > data_end) {
     1b0:	74 14                	je     1c6 <balancer_ingress+0x1c6>
     1b2:	00 00                	add    %al,(%rax)
     1b4:	83 14 00 00          	adcl   $0x0,(%rax,%rax,1)
     1b8:	93                   	xchg   %eax,%ebx
     1b9:	14 00                	adc    $0x0,%al
     1bb:	00 9b 14 00 00 a3    	add    %bl,-0x5cffffec(%rbx)
    pckt->flow.proto = *protocol;
     1c1:	14 00                	adc    $0x0,%al
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1c3:	00 ab 14 00 00 b6    	add    %ch,-0x49ffffec(%rbx)
     1c9:	14 00                	adc    $0x0,%al
     1cb:	00 c6                	add    %al,%dh
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1cd:	14 00                	adc    $0x0,%al
     1cf:	00 ce                	add    %cl,%dh
     1d1:	14 00                	adc    $0x0,%al
     1d3:	00 de                	add    %bl,%dh
     1d5:	14 00                	adc    $0x0,%al
     1d7:	00 e6                	add    %ah,%dh
    if (*protocol == IPPROTO_FRAGMENT) {
     1d9:	14 00                	adc    $0x0,%al
     1db:	00 ee                	add    %ch,%dh
     1dd:	14 00                	adc    $0x0,%al
     1df:	00 fe                	add    %bh,%dh
     1e1:	14 00                	adc    $0x0,%al
     1e3:	00 06                	add    %al,(%rsi)
     1e5:	15 00 00 17 15       	adc    $0x15170000,%eax
     1ea:	00 00                	add    %al,(%rax)
     1ec:	27                   	(bad)
  if (icmp_hdr + 1 > data_end) {
     1ed:	15 00 00 2f 15       	adc    $0x152f0000,%eax
     1f2:	00 00                	add    %al,(%rax)
     1f4:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     1f5:	15 00 00 1d 16       	adc    $0x161d0000,%eax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1fa:	00 00                	add    %al,(%rax)
     1fc:	2d 16 00 00 97       	sub    $0x97000016,%eax
     201:	16                   	(bad)
     202:	00 00                	add    %al,(%rax)
     204:	b1 16                	mov    $0x16,%cl
     206:	00 00                	add    %al,(%rax)
     208:	d8 16                	fcoms  (%rsi)
     20a:	00 00                	add    %al,(%rax)
     20c:	ff 16                	call   *(%rsi)
     20e:	00 00                	add    %al,(%rax)
     210:	1f                   	(bad)
     211:	17                   	(bad)
     212:	00 00                	add    %al,(%rax)
     214:	30 17                	xor    %dl,(%rdi)
     216:	00 00                	add    %al,(%rax)
     218:	45 17                	rex.RB (bad)
     21a:	00 00                	add    %al,(%rax)
     21c:	56                   	push   %rsi
     21d:	17                   	(bad)
     21e:	00 00                	add    %al,(%rax)
     220:	66 17                	data16 (bad)
     222:	00 00                	add    %al,(%rax)
     224:	6e                   	outsb  %ds:(%rsi),(%dx)
     225:	17                   	(bad)
     226:	00 00                	add    %al,(%rax)
     228:	0a 18                	or     (%rax),%bl
     22a:	00 00                	add    %al,(%rax)
     22c:	1a 18                	sbb    (%rax),%bl
     22e:	00 00                	add    %al,(%rax)
     230:	22 18                	and    (%rax),%bl
     232:	00 00                	add    %al,(%rax)
     234:	33 18                	xor    (%rax),%ebx
     236:	00 00                	add    %al,(%rax)
     238:	43 18 00             	rex.XB sbb %al,(%r8)
     23b:	00 54 18 00          	add    %dl,0x0(%rax,%rbx,1)
     23f:	00 67 18             	add    %ah,0x18(%rdi)
     242:	00 00                	add    %al,(%rax)
     244:	78 18                	js     25e <balancer_ingress+0x25e>
     246:	00 00                	add    %al,(%rax)
     248:	88 18                	mov    %bl,(%rax)
     24a:	00 00                	add    %al,(%rax)
     24c:	90                   	nop
     24d:	18 00                	sbb    %al,(%rax)
     24f:	00 9b 18 00 00 aa    	add    %bl,-0x55ffffe8(%rbx)
     255:	18 00                	sbb    %al,(%rax)
     257:	00 ba 18 00 00 c2    	add    %bh,-0x3dffffe8(%rdx)
     25d:	18 00                	sbb    %al,(%rax)
     25f:	00 ca                	add    %cl,%dl
     261:	18 00                	sbb    %al,(%rax)
     263:	00 d2                	add    %dl,%dl
     265:	18 00                	sbb    %al,(%rax)
     267:	00 da                	add    %bl,%dl
     269:	18 00                	sbb    %al,(%rax)
     26b:	00 e5                	add    %ah,%ch
     26d:	18 00                	sbb    %al,(%rax)
     26f:	00 f5                	add    %dh,%ch
     271:	18 00                	sbb    %al,(%rax)
     273:	00 fd                	add    %bh,%ch
     275:	18 00                	sbb    %al,(%rax)
     277:	00 0d 19 00 00 15    	add    %cl,0x15000019(%rip)        # 15000296 <_license+0x14ffde69>
     27d:	19 00                	sbb    %eax,(%rax)
     27f:	00 25 19 00 00 2d    	add    %ah,0x2d000019(%rip)        # 2d00029e <_license+0x2cffde71>
     285:	19 00                	sbb    %eax,(%rax)
     287:	00 35 19 00 00 3f    	add    %dh,0x3f000019(%rip)        # 3f0002a6 <_license+0x3effde79>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     28d:	19 00                	sbb    %eax,(%rax)
     28f:	00 50 19             	add    %dl,0x19(%rax)
     292:	00 00                	add    %al,(%rax)
     294:	63 19                	movsxd (%rcx),%ebx
     296:	00 00                	add    %al,(%rax)
     298:	74 19                	je     2b3 <balancer_ingress+0x2b3>
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     29a:	00 00                	add    %al,(%rax)
     29c:	84 19                	test   %bl,(%rcx)
     29e:	00 00                	add    %al,(%rax)
     2a0:	8c 19                	mov    %ds,(%rcx)
     2a2:	00 00                	add    %al,(%rax)
     2a4:	97                   	xchg   %eax,%edi
     2a5:	19 00                	sbb    %eax,(%rax)
     2a7:	00 a6 19 00 00 b6    	add    %ah,-0x49ffffe7(%rsi)
  if (protocol == IPPROTO_ICMPV6) {
     2ad:	19 00                	sbb    %eax,(%rax)
     2af:	00 be 19 00 00 c6    	add    %bh,-0x39ffffe7(%rsi)
  if (icmp_hdr + 1 > data_end) {
     2b5:	19 00                	sbb    %eax,(%rax)
     2b7:	00 d1                	add    %dl,%cl
     2b9:	19 00                	sbb    %eax,(%rax)
     2bb:	00 e1                	add    %ah,%cl
     2bd:	19 00                	sbb    %eax,(%rax)
     2bf:	00 e9                	add    %ch,%cl
  if (icmp_hdr->type == ICMP_ECHO) {
     2c1:	19 00                	sbb    %eax,(%rax)
     2c3:	00 f9                	add    %bh,%cl
     2c5:	19 00                	sbb    %eax,(%rax)
     2c7:	00 01                	add    %al,(%rcx)
     2c9:	1a 00                	sbb    (%rax),%al
     2cb:	00 09                	add    %cl,(%rcx)
     2cd:	1a 00                	sbb    (%rax),%al
     2cf:	00 19                	add    %bl,(%rcx)
     2d1:	1a 00                	sbb    (%rax),%al
     2d3:	00 21                	add    %ah,(%rcx)
     2d5:	1a 00                	sbb    (%rax),%al
     2d7:	00 f0                	add    %dh,%al
     2d9:	1a 00                	sbb    (%rax),%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2db:	00 41 1b             	add    %al,0x1b(%rcx)
     2de:	00 00                	add    %al,(%rax)
     2e0:	51                   	push   %rcx
     2e1:	1b 00                	sbb    (%rax),%eax
     2e3:	00 a6 1b 00 00 c0    	add    %ah,-0x3fffffe5(%rsi)
     2e9:	1b 00                	sbb    (%rax),%eax
     2eb:	00 e7                	add    %ah,%bh
  icmp_hdr->type = ICMP_ECHOREPLY;
     2ed:	1b 00                	sbb    (%rax),%eax
     2ef:	00 0e                	add    %cl,(%rsi)
  icmp_hdr->checksum += 0x0008;
     2f1:	1c 00                	sbb    $0x0,%al
     2f3:	00 2f                	add    %ch,(%rdi)
     2f5:	1c 00                	sbb    $0x0,%al
  iph->ttl = DEFAULT_TTL;
     2f7:	00 40 1c             	add    %al,0x1c(%rax)
  iph->daddr = iph->saddr;
     2fa:	00 00                	add    %al,(%rax)
     2fc:	55                   	push   %rbp
  tmp_addr = iph->daddr;
     2fd:	1c 00                	sbb    $0x0,%al
     2ff:	00 66 1c             	add    %ah,0x1c(%rsi)
  iph->daddr = iph->saddr;
     302:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
     304:	76 1c                	jbe    322 <balancer_ingress+0x322>
     306:	00 00                	add    %al,(%rax)
     308:	7e 1c                	jle    326 <balancer_ingress+0x326>
     30a:	00 00                	add    %al,(%rax)
     30c:	05 1d 00 00 3e       	add    $0x3e00001d,%eax
     311:	1d 00 00 4e 1d       	sbb    $0x1d4e0000,%eax
     316:	00 00                	add    %al,(%rax)
     318:	80 1d 00 00 88 1d 00 	sbbb   $0x0,0x1d880000(%rip)        # 1d88031f <_license+0x1d87def2>
     31f:	00 a5 1d 00 00 c6    	add    %ah,-0x39ffffe3(%rbp)
     325:	1d 00 00 ca 1e       	sbb    $0x1eca0000,%eax
     32a:	00 00                	add    %al,(%rax)
     32c:	e0 1e                	loopne 34c <balancer_ingress+0x34c>
     32e:	00 00                	add    %al,(%rax)
     330:	f6 1e                	negb   (%rsi)
     332:	00 00                	add    %al,(%rax)
     334:	24 1f                	and    $0x1f,%al
     336:	00 00                	add    %al,(%rax)
     338:	34 1f                	xor    $0x1f,%al
     33a:	00 00                	add    %al,(%rax)
     33c:	44 1f                	rex.R (bad)
     33e:	00 00                	add    %al,(%rax)
     340:	4c 1f                	rex.WR (bad)
     342:	00 00                	add    %al,(%rax)
     344:	7d 1f                	jge    365 <balancer_ingress+0x365>
     346:	00 00                	add    %al,(%rax)
     348:	8d 1f                	lea    (%rdi),%ebx
     34a:	00 00                	add    %al,(%rax)
     34c:	b8 1f 00 00 c0       	mov    $0xc000001f,%eax
     351:	1f                   	(bad)
     352:	00 00                	add    %al,(%rax)
     354:	dd 1f                	fstpl  (%rdi)
     356:	00 00                	add    %al,(%rax)
     358:	fe                   	(bad)
     359:	1f                   	(bad)
     35a:	00 00                	add    %al,(%rax)
     35c:	1a 21                	sbb    (%rcx),%ah
     35e:	00 00                	add    %al,(%rax)
     360:	2a 21                	sub    (%rcx),%ah
     362:	00 00                	add    %al,(%rax)
     364:	32 21                	xor    (%rcx),%ah
     366:	00 00                	add    %al,(%rax)
     368:	45 21 00             	and    %r8d,(%r8)
     36b:	00 5f 21             	add    %bl,0x21(%rdi)
     36e:	00 00                	add    %al,(%rax)
     370:	70 21                	jo     393 <balancer_ingress+0x393>
     372:	00 00                	add    %al,(%rax)
     374:	86 21                	xchg   %ah,(%rcx)
     376:	00 00                	add    %al,(%rax)
     378:	95                   	xchg   %eax,%ebp
     379:	21 00                	and    %eax,(%rax)
     37b:	00 a5 21 00 00 ad    	add    %ah,-0x52ffffdf(%rbp)
     381:	21 00                	and    %eax,(%rax)
     383:	00 c3                	add    %al,%bl
     385:	21 00                	and    %eax,(%rax)
     387:	00 d9                	add    %bl,%cl
     389:	21 00                	and    %eax,(%rax)
     38b:	00 0e                	add    %cl,(%rsi)
     38d:	22 00                	and    (%rax),%al
     38f:	00 24 22             	add    %ah,(%rdx,%riz,1)
     392:	00 00                	add    %al,(%rax)
     394:	34 22                	xor    $0x22,%al
     396:	00 00                	add    %al,(%rax)
     398:	3c 22                	cmp    $0x22,%al
     39a:	00 00                	add    %al,(%rax)
     39c:	44 22 00             	and    (%rax),%r8b
     39f:	00 5a 22             	add    %bl,0x22(%rdx)
     3a2:	00 00                	add    %al,(%rax)
     3a4:	62 22                	(bad)
     3a6:	00 00                	add    %al,(%rax)
     3a8:	6a 22                	push   $0x22
     3aa:	00 00                	add    %al,(%rax)
     3ac:	73 22                	jae    3d0 <balancer_ingress+0x3d0>
     3ae:	00 00                	add    %al,(%rax)
     3b0:	8b 22                	mov    (%rdx),%esp
     3b2:	00 00                	add    %al,(%rax)
     3b4:	9b                   	fwait
     3b5:	22 00                	and    (%rax),%al
     3b7:	00 a3 22 00 00 b3    	add    %ah,-0x4cffffde(%rbx)
     3bd:	22 00                	and    (%rax),%al
     3bf:	00 bb 22 00 00 c3    	add    %bh,-0x3cffffde(%rbx)
     3c5:	22 00                	and    (%rax),%al
     3c7:	00 cb                	add    %cl,%bl
     3c9:	22 00                	and    (%rax),%al
     3cb:	00 db                	add    %bl,%bl
     3cd:	22 00                	and    (%rax),%al
     3cf:	00 e3                	add    %ah,%bl
     3d1:	22 00                	and    (%rax),%al
     3d3:	00 f3                	add    %dh,%bl
     3d5:	22 00                	and    (%rax),%al
     3d7:	00 02                	add    %al,(%rdx)
     3d9:	23 00                	and    (%rax),%eax
     3db:	00 12                	add    %dl,(%rdx)
     3dd:	23 00                	and    (%rax),%eax
     3df:	00 1d 23 00 00 26    	add    %bl,0x26000023(%rip)        # 26000408 <_license+0x25ffdfdb>
  if (protocol == IPPROTO_IPIP) {
     3e5:	23 00                	and    (%rax),%eax
     3e7:	00 3f                	add    %bh,(%rdi)
     3e9:	23 00                	and    (%rax),%eax
     3eb:	00 54 23 00          	add    %dl,0x0(%rbx,%riz,1)
     3ef:	00 5d 23             	add    %bl,0x23(%rbp)
     3f2:	00 00                	add    %al,(%rax)
     3f4:	65 23 00             	and    %gs:(%rax),%eax
     3f7:	00 6d 23             	add    %ch,0x23(%rbp)
     3fa:	00 00                	add    %al,(%rax)
  tcp = data + off;
     3fc:	75 23                	jne    421 <balancer_ingress+0x421>
     3fe:	00 00                	add    %al,(%rax)
  if (is_ipv6) {
     400:	7d 23                	jge    425 <balancer_ingress+0x425>
  tcp = data + off;
     402:	00 00                	add    %al,(%rax)
     404:	87 23                	xchg   %esp,(%rbx)
  if (tcp + 1 > data_end) {
     406:	00 00                	add    %al,(%rax)
     408:	9c                   	pushf
     409:	23 00                	and    (%rax),%eax
     40b:	00 a4 23 00 00 ac 23 	add    %ah,0x23ac0000(%rbx,%riz,1)
     412:	00 00                	add    %al,(%rax)
  if (tcp->syn) {
     414:	e3 23                	jrcxz  439 <balancer_ingress+0x439>
     416:	00 00                	add    %al,(%rax)
     418:	28 24 00             	sub    %ah,(%rax,%rax,1)
     41b:	00 38                	add    %bh,(%rax)
    pckt->flags |= F_SYN_SET;
     41d:	24 00                	and    $0x0,%al
     41f:	00 40 24             	add    %al,0x24(%rax)
     422:	00 00                	add    %al,(%rax)
     424:	53                   	push   %rbx
     425:	24 00                	and    $0x0,%al
      pckt->flow.src = iph->saddr;
     427:	00 91 24 00 00 a2    	add    %dl,-0x5dffffdc(%rcx)
      pckt->flow.dst = iph->daddr;
     42d:	24 00                	and    $0x0,%al
     42f:	00 bc 24 00 00 dc 24 	add    %bh,0x24dc0000(%rsp)
  if (protocol == IPPROTO_ICMPV6) {
     436:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
     438:	ed                   	in     (%dx),%eax
     439:	24 00                	and    $0x0,%al
     43b:	00 05 25 00 00 15    	add    %al,0x15000025(%rip)        # 15000466 <_license+0x14ffe039>
     441:	25 00 00 1d 25       	and    $0x251d0000,%eax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     446:	00 00                	add    %al,(%rax)
     448:	2e 25 00 00 36 25    	cs and $0x25360000,%eax
     44e:	00 00                	add    %al,(%rax)
     450:	58                   	pop    %rax
     451:	25 00 00 60 25       	and    $0x25600000,%eax
     456:	00 00                	add    %al,(%rax)
     458:	68 25 00 00 85       	push   $0xffffffff85000025
     45d:	25 00 00 8e 25       	and    $0x258e0000,%eax
     462:	00 00                	add    %al,(%rax)
     464:	97                   	xchg   %eax,%edi
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     465:	25 00 00 a7 25       	and    $0x25a70000,%eax
     46a:	00 00                	add    %al,(%rax)
     46c:	af                   	scas   %es:(%rdi),%eax
     46d:	25 00 00 bf 25       	and    $0x25bf0000,%eax
     472:	00 00                	add    %al,(%rax)
     474:	c7                   	(bad)
     475:	25 00 00 e0 25       	and    $0x25e00000,%eax
     47a:	00 00                	add    %al,(%rax)
     47c:	e8 25 00 00 f0       	call   fffffffff00004a6 <server_id_map+0x36fca6d644a6>
     481:	25 00 00 f8 25       	and    $0x25f80000,%eax
     486:	00 00                	add    %al,(%rax)
     488:	00 26                	add    %ah,(%rsi)
     48a:	00 00                	add    %al,(%rax)
     48c:	0a 26                	or     (%rsi),%ah
     48e:	00 00                	add    %al,(%rax)
     490:	13 26                	adc    (%rsi),%esp
     492:	00 00                	add    %al,(%rax)
     494:	4d                   	rex.WRB
     495:	26 00 00             	es add %al,(%rax)
     498:	55                   	push   %rbp
     499:	26 00 00             	es add %al,(%rax)
     49c:	5d                   	pop    %rbp
  tcp = data + off;
     49d:	26 00 00             	es add %al,(%rax)
     4a0:	9f                   	lahf
  if (is_ipv6) {
     4a1:	26 00 00             	es add %al,(%rax)
  tcp = data + off;
     4a4:	ae                   	scas   %es:(%rdi),%al
     4a5:	26 00 00             	es add %al,(%rax)
  if (tcp + 1 > data_end) {
     4a8:	bd 26 00 00 c5       	mov    $0xc5000026,%ebp
     4ad:	26 00 00             	es add %al,(%rax)
     4b0:	d5                   	(bad)
     4b1:	26 00 00             	es add %al,(%rax)
  if (tcp->syn) {
     4b4:	dd 26                	frstor (%rsi)
     4b6:	00 00                	add    %al,(%rax)
     4b8:	e5 26                	in     $0x26,%eax
     4ba:	00 00                	add    %al,(%rax)
     4bc:	ed                   	in     (%dx),%eax
     4bd:	26 00 00             	es add %al,(%rax)
    pckt->flags |= F_SYN_SET;
     4c0:	fc                   	cld
     4c1:	26 00 00             	es add %al,(%rax)
     4c4:	05 27 00 00 15       	add    $0x15000027,%eax
     4c9:	27                   	(bad)
     4ca:	00 00                	add    %al,(%rax)
     4cc:	1d 27 00 00 42       	sbb    $0x42000027,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     4d1:	27                   	(bad)
     4d2:	00 00                	add    %al,(%rax)
     4d4:	71 27                	jno    4fd <balancer_ingress+0x4fd>
     4d6:	00 00                	add    %al,(%rax)
     4d8:	87 27                	xchg   %esp,(%rdi)
     4da:	00 00                	add    %al,(%rax)
     4dc:	a3 27 00 00 b6 27 00 	movabs %eax,0xce000027b6000027
     4e3:	00 ce 
    if (!icmp_ptb_v6_stats) {
     4e5:	27                   	(bad)
     4e6:	00 00                	add    %al,(%rax)
     4e8:	df 27                	fbld   (%rdi)
    icmp_ptb_v6_stats->v1 += 1;
     4ea:	00 00                	add    %al,(%rax)
     4ec:	f5                   	cmc
     4ed:	27                   	(bad)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4ee:	00 00                	add    %al,(%rax)
     4f0:	04 28                	add    $0x28,%al
     4f2:	00 00                	add    %al,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     4f4:	0c 28                	or     $0x28,%al
     4f6:	00 00                	add    %al,(%rax)
     4f8:	14 28                	adc    $0x28,%al
     4fa:	00 00                	add    %al,(%rax)
      icmp_ptb_v6_stats->v2 += 1;
     4fc:	1d 28 00 00 2c       	sbb    $0x2c000028,%eax
  if (ip6h + 1 > data_end) {
     501:	28 00                	sub    %al,(%rax)
     503:	00 3c 28             	add    %bh,(%rax,%rbp,1)
     506:	00 00                	add    %al,(%rax)
     508:	44 28 00             	sub    %r8b,(%rax)
     50b:	00 54 28 00          	add    %dl,0x0(%rax,%rbp,1)
  pckt->flow.proto = ip6h->nexthdr;
     50f:	00 5c 28 00          	add    %bl,0x0(%rax,%rbp,1)
     513:	00 64 28 00          	add    %ah,0x0(%rax,%rbp,1)
  pckt->flags |= F_ICMP;
     517:	00 6c 28 00          	add    %ch,0x0(%rax,%rbp,1)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     51b:	00 74 28 00          	add    %dh,0x0(%rax,%rbp,1)
     51f:	00 7c 28 00          	add    %bh,0x0(%rax,%rbp,1)
     523:	00 8c 28 00 00 94 28 	add    %cl,0x28940000(%rax,%rbp,1)
     52a:	00 00                	add    %al,(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     52c:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     52d:	28 00                	sub    %al,(%rax)
     52f:	00 b4 28 00 00 bf 28 	add    %dh,0x28bf0000(%rax,%rbp,1)
     536:	00 00                	add    %al,(%rax)
     538:	c8 28 00 00          	enter  $0x28,$0x0
     53c:	dd 28                	(bad)  (%rax)
     53e:	00 00                	add    %al,(%rax)
     540:	e6 28                	out    %al,$0x28
     542:	00 00                	add    %al,(%rax)
     544:	ee                   	out    %al,(%dx)
     545:	28 00                	sub    %al,(%rax)
     547:	00 f6                	add    %dh,%dh
     549:	28 00                	sub    %al,(%rax)
     54b:	00 fe                	add    %bh,%dh
     54d:	28 00                	sub    %al,(%rax)
     54f:	00 08                	add    %cl,(%rax)
     551:	29 00                	sub    %eax,(%rax)
     553:	00 1d 29 00 00 25    	add    %bl,0x25000029(%rip)        # 25000582 <_license+0x24ffe155>
     559:	29 00                	sub    %eax,(%rax)
     55b:	00 5c 29 00          	add    %bl,0x0(%rcx,%rbp,1)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     55f:	00 a1 29 00 00 b1    	add    %ah,-0x4effffd7(%rcx)
     565:	29 00                	sub    %eax,(%rax)
     567:	00 b9 29 00 00 d5    	add    %bh,-0x2affffd7(%rcx)
     56d:	29 00                	sub    %eax,(%rax)
     56f:	00 ee                	add    %ch,%dh
     571:	29 00                	sub    %eax,(%rax)
BPF_MAP_OPS_INLINE(void*,
     573:	00 0e                	add    %cl,(%rsi)
     575:	2a 00                	sub    (%rax),%al
     577:	00 45 2a             	add    %al,0x2a(%rbp)
     57a:	00 00                	add    %al,(%rax)
     57c:	5e                   	pop    %rsi
     57d:	2a 00                	sub    (%rax),%al
     57f:	00 7e 2a             	add    %bh,0x2a(%rsi)
     582:	00 00                	add    %al,(%rax)
     584:	8e 2a                	mov    (%rdx),%gs
     586:	00 00                	add    %al,(%rax)
     588:	96                   	xchg   %eax,%esi
     589:	2a 00                	sub    (%rax),%al
  if (decap_dst_flags) {
     58b:	00 a7 2a 00 00 dd    	add    %ah,-0x22ffffd6(%rdi)
     591:	2a 00                	sub    (%rax),%al
     593:	00 fa                	add    %bh,%dl
     595:	2a 00                	sub    (%rax),%al
     597:	00 04 2b             	add    %al,(%rbx,%rbp,1)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     59a:	00 00                	add    %al,(%rax)
     59c:	0d 2b 00 00 18       	or     $0x1800002b,%eax
     5a1:	2b 00                	sub    (%rax),%eax
     5a3:	00 40 2b             	add    %al,0x2b(%rax)
     5a6:	00 00                	add    %al,(%rax)
     5a8:	4c 2b 00             	sub    (%rax),%r8
    if (!data_stats) {
     5ab:	00 54 2b 00          	add    %dl,0x0(%rbx,%rbp,1)
     5af:	00 5c 2b 00          	add    %bl,0x0(%rbx,%rbp,1)
    data_stats->v1 += 1;
     5b3:	00 7e 2b             	add    %bh,0x2b(%rsi)
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5b6:	00 00                	add    %al,(%rax)
     5b8:	86 2b                	xchg   %ch,(%rbx)
     5ba:	00 00                	add    %al,(%rax)
     5bc:	a3 2b 00 00 ab 2b 00 	movabs %eax,0xb400002bab00002b
     5c3:	00 b4 
     5c5:	2b 00                	sub    (%rax),%eax
     5c7:	00 bd 2b 00 00 cd    	add    %bh,-0x32ffffd5(%rbp)
    if (!--ip6h->hop_limit) {
     5cd:	2b 00                	sub    (%rax),%eax
     5cf:	00 d5                	add    %dl,%ch
     5d1:	2b 00                	sub    (%rax),%eax
     5d3:	00 e5                	add    %ah,%ch
     5d5:	2b 00                	sub    (%rax),%eax
     5d7:	00 ed                	add    %ch,%ch
     5d9:	2b 00                	sub    (%rax),%eax
     5db:	00 f5                	add    %dh,%ch
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5dd:	2b 00                	sub    (%rax),%eax
     5df:	00 fd                	add    %bh,%ch
     5e1:	2b 00                	sub    (%rax),%eax
     5e3:	00 05 2c 00 00 0d    	add    %al,0xd00002c(%rip)        # d000615 <_license+0xcffe1e8>
     5e9:	2c 00                	sub    $0x0,%al
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     5eb:	00 17                	add    %dl,(%rdi)
     5ed:	2c 00                	sub    $0x0,%al
     5ef:	00 21                	add    %ah,(%rcx)
     5f1:	2c 00                	sub    $0x0,%al
     5f3:	00 49 2c             	add    %cl,0x2c(%rcx)
     5f6:	00 00                	add    %al,(%rax)
     5f8:	51                   	push   %rcx
     5f9:	2c 00                	sub    $0x0,%al
     5fb:	00 59 2c             	add    %bl,0x2c(%rcx)
     5fe:	00 00                	add    %al,(%rax)
     600:	61                   	(bad)
     601:	2c 00                	sub    $0x0,%al
     603:	00 69 2c             	add    %ch,0x2c(%rcx)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     606:	00 00                	add    %al,(%rax)
     608:	79 2c                	jns    636 <balancer_ingress+0x636>
     60a:	00 00                	add    %al,(%rax)
     60c:	81 2c 00 00 89 2c 00 	subl   $0x2c8900,(%rax,%rax,1)
     613:	00 cd                	add    %cl,%ch
     615:	2c 00                	sub    $0x0,%al
     617:	00 dc                	add    %bl,%ah
     619:	2c 00                	sub    $0x0,%al
     61b:	00 eb                	add    %ch,%bl
     61d:	2c 00                	sub    $0x0,%al
     61f:	00 00                	add    %al,(%rax)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     621:	2d 00 00 10 2d       	sub    $0x2d100000,%eax
     626:	00 00                	add    %al,(%rax)
     628:	1f                   	(bad)
     629:	2d 00 00 2e 2d       	sub    $0x2d2e0000,%eax
     62e:	00 00                	add    %al,(%rax)
     630:	37                   	(bad)
  if (!data_stats) {
     631:	2d 00 00 47 2d       	sub    $0x2d470000,%eax
     636:	00 00                	add    %al,(%rax)
     638:	4f 2d 00 00 6b 2d    	rex.WRXB sub $0x2d6b0000,%rax
     63e:	00 00                	add    %al,(%rax)
  if (action >= 0) {
     640:	95                   	xchg   %eax,%ebp
     641:	2d 00 00 ab 2d       	sub    $0x2dab0000,%eax
     646:	00 00                	add    %al,(%rax)
     648:	c7                   	(bad)
     649:	2d 00 00 d7 2d       	sub    $0x2dd70000,%eax
     64e:	00 00                	add    %al,(%rax)
     650:	df 2d 00 00 ea 2d    	fildll 0x2dea0000(%rip)        # 2dea0656 <_license+0x2de9e229>
     656:	00 00                	add    %al,(%rax)
     658:	fb                   	sti
     659:	2d 00 00 10 2e       	sub    $0x2e100000,%eax
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     65e:	00 00                	add    %al,(%rax)
     660:	20 2e                	and    %ch,(%rsi)
     662:	00 00                	add    %al,(%rax)
     664:	2f                   	(bad)
     665:	2e 00 00             	cs add %al,(%rax)
     668:	3f                   	(bad)
     669:	2e 00 00             	cs add %al,(%rax)
     66c:	47                   	rex.RXB
    if (xpop_stats_data) {
     66d:	2e 00 00             	cs add %al,(%rax)
     670:	52                   	push   %rdx
     671:	2e 00 00             	cs add %al,(%rax)
     674:	04 04                	add    $0x4,%al
     676:	41 01 55 04          	add    %edx,0x4(%r13)
     67a:	41 c7                	rex.B (bad)
     67c:	3e 01 5d 04          	ds add %ebx,0x4(%rbp)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     680:	c7                   	(bad)
     681:	3e db 3e             	ds fstpt (%rsi)
     684:	04 a3                	add    $0xa3,%al
     686:	01 55 9f             	add    %edx,-0x61(%rbp)
     689:	04 db                	add    $0xdb,%al
     68b:	3e ad                	lods   %ds:(%rsi),%eax
     68d:	48 01 5d 00          	add    %rbx,0x0(%rbp)
     691:	04 18                	add    $0x18,%al
     693:	d1 07                	roll   (%rdi)
     695:	01 53 04             	add    %edx,0x4(%rbx)
     698:	db 07                	fildl  (%rdi)
     69a:	93                   	xchg   %eax,%ebx
     69b:	1d 01 53 04 ce       	sbb    $0xce045301,%eax
     6a0:	1d a8 1f 01 53       	sbb    $0x53011fa8,%eax
     6a5:	04 c5                	add    $0xc5,%al
     6a7:	1f                   	(bad)
     6a8:	ff 1f                	lcall  *(%rdi)
     6aa:	01 53 00             	add    %edx,0x0(%rbx)
  if (decap_dst_flags) {
     6ad:	04 1c                	add    $0x1c,%al
     6af:	d1 07                	roll   (%rdi)
     6b1:	01 5c 04 db          	add    %ebx,-0x25(%rsp,%rax,1)
     6b5:	07                   	(bad)
     6b6:	8a 20                	mov    (%rax),%ah
     6b8:	01 5c 04 ec          	add    %ebx,-0x14(%rsp,%rax,1)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     6bc:	20 e5                	and    %ah,%ch
     6be:	23 01                	and    (%rcx),%eax
     6c0:	5c                   	pop    %rsp
     6c1:	04 95                	add    $0x95,%al
     6c3:	2e 85 2f             	cs test %ebp,(%rdi)
     6c6:	01 5c 04 c3          	add    %ebx,-0x3d(%rsp,%rax,1)
     6ca:	30 bb 32 01 5c 04    	xor    %bh,0x45c0132(%rbx)
    if (!data_stats) {
     6d0:	fd                   	std
     6d1:	32 81 33 01 5c 04    	xor    0x45c0133(%rcx),%al
    data_stats->v1 += 1;
     6d7:	ba 42 a8 48 01       	mov    $0x148a842,%edx
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     6dc:	5c                   	pop    %rsp
     6dd:	00 04 1c             	add    %al,(%rsp,%rbx,1)
     6e0:	d1 07                	roll   (%rdi)
     6e2:	01 53 04             	add    %edx,0x4(%rbx)
     6e5:	db 07                	fildl  (%rdi)
     6e7:	93                   	xchg   %eax,%ebx
     6e8:	1d 01 53 04 ce       	sbb    $0xce045301,%eax
    csum = iph->check + 0x0001;
     6ed:	1d a8 1f 01 53       	sbb    $0x53011fa8,%eax
     6f2:	04 c5                	add    $0xc5,%al
    iph->check = (csum & 0xffff) + (csum >> 16);
     6f4:	1f                   	(bad)
     6f5:	ff 1f                	lcall  *(%rdi)
     6f7:	01 53 00             	add    %edx,0x0(%rbx)
     6fa:	04 1c                	add    $0x1c,%al
     6fc:	ad                   	lods   %ds:(%rsi),%eax
     6fd:	48 02 3e             	rex.W add (%rsi),%dil
    if (!--iph->ttl) {
     700:	9f                   	lahf
     701:	00 04 35 cb 01 12 72 	add    %al,0x721201cb(,%rsi,1)
     708:	00 10                	add    %dl,(%rax)
     70a:	ff                   	(bad)
     70b:	ff 03                	incl   (%rbx)
     70d:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     713:	a8 b0                	test   $0xb0,%al
     715:	80 80 00 9f 04 df 02 	addb   $0x2,-0x20fb6100(%rax)
     71c:	c6 03 12             	movb   $0x12,(%rbx)
     71f:	72 00                	jb     721 <balancer_ingress+0x721>
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     721:	10 ff                	adc    %bh,%bh
     723:	ff 03                	incl   (%rbx)
     725:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
     72b:	a8 b0                	test   $0xb0,%al
     72d:	80 80 00 9f 00 04 50 	addb   $0x50,0x4009f00(%rax)
     734:	df 02                	filds  (%rdx)
     736:	01 5d 04             	add    %ebx,0x4(%rbp)
     739:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     73a:	08 c7                	or     %al,%bh
     73c:	09 01                	or     %eax,(%rcx)
     73e:	5d                   	pop    %rbp
     73f:	04 cc                	add    $0xcc,%al
     741:	12 bc 13 01 5d 04 f2 	adc    -0xdfba2ff(%rbx,%rdx,1),%bh
     748:	13 a1 16 01 5d 04    	adc    0x45d0116(%rcx),%esp
     74e:	cc                   	int3
     74f:	16                   	(bad)
     750:	b6 1c                	mov    $0x1c,%dh
     752:	01 5d 04             	add    %ebx,0x4(%rbp)
     755:	ce                   	(bad)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     756:	1d 84 1e 01 5d       	sbb    $0x5d011e84,%eax
     75b:	04 c2                	add    $0xc2,%al
     75d:	1e                   	(bad)
     75e:	dc 20                	fsubl  (%rax)
     760:	01 5d 04             	add    %ebx,0x4(%rbp)
     763:	c9                   	leave
     764:	21 8c 23 01 5d 04 e5 	and    %ecx,-0x1afba2ff(%rbx,%riz,1)
  if (!data_stats) {
     76b:	23 95 2e 01 5d 04    	and    0x45d012e(%rbp),%edx
     771:	85 2f                	test   %ebp,(%rdi)
     773:	e2 30                	loop   7a5 <balancer_ingress+0x7a5>
  if (action >= 0) {
     775:	01 5d 04             	add    %ebx,0x4(%rbp)
     778:	ba 42 94 43 01       	mov    $0x1439442,%edx
     77d:	5d                   	pop    %rbp
     77e:	04 fe                	add    $0xfe,%al
  if (decap_dst_flags) {
     780:	43 93                	rex.XB xchg %eax,%r11d
     782:	45 01 5d 04          	add    %r11d,0x4(%r13)
  if (action >= 0) {
     786:	c4                   	(bad)
     787:	46 ad                	rex.RX lods %ds:(%rsi),%eax
     789:	48 01 5d 00          	add    %rbx,0x0(%rbp)
     78d:	04 50                	add    $0x50,%al
     78f:	df 02                	filds  (%rdx)
     791:	02 3e                	add    (%rsi),%bh
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     793:	9f                   	lahf
     794:	04 a6                	add    $0xa6,%al
     796:	08 c7                	or     %al,%bh
     798:	09 02                	or     %eax,(%rdx)
     79a:	3e 9f                	ds lahf
     79c:	04 cc                	add    $0xcc,%al
     79e:	12 bc 13 02 3e 9f 04 	adc    0x49f3e02(%rbx,%rdx,1),%bh
    if (xpop_stats_data) {
     7a5:	f2 13 a1 16 02 3e 9f 	repnz adc -0x60c1fdea(%rcx),%esp
     7ac:	04 cc                	add    $0xcc,%al
     7ae:	16                   	(bad)
     7af:	b6 1c                	mov    $0x1c,%dh
  udp = data + off;
     7b1:	02 3e                	add    (%rsi),%bh
     7b3:	9f                   	lahf
  if (is_ipv6) {
     7b4:	04 ce                	add    $0xce,%al
  udp = data + off;
     7b6:	1d 84 1e 02 3e       	sbb    $0x3e021e84,%eax
  if (udp + 1 > data_end) {
     7bb:	9f                   	lahf
     7bc:	04 c2                	add    $0xc2,%al
     7be:	1e                   	(bad)
     7bf:	dc 20                	fsubl  (%rax)
     7c1:	02 3e                	add    (%rsi),%bh
     7c3:	9f                   	lahf
     7c4:	04 c9                	add    $0xc9,%al
     7c6:	21 8c 23 02 3e 9f 04 	and    %ecx,0x49f3e02(%rbx,%riz,1)
     7cd:	e5 23                	in     $0x23,%eax
     7cf:	95                   	xchg   %eax,%ebp
     7d0:	2e 02 3e             	cs add (%rsi),%bh
     7d3:	9f                   	lahf
     7d4:	04 85                	add    $0x85,%al
     7d6:	2f                   	(bad)
     7d7:	e2 30                	loop   809 <balancer_ingress+0x809>
     7d9:	02 3e                	add    (%rsi),%bh
     7db:	9f                   	lahf
     7dc:	04 ba                	add    $0xba,%al
     7de:	42 94                	rex.X xchg %eax,%esp
     7e0:	43 02 3e             	rex.XB add (%r14),%dil
     7e3:	9f                   	lahf
     7e4:	04 fe                	add    $0xfe,%al
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     7e6:	43 93                	rex.XB xchg %eax,%r11d
     7e8:	45 02 3e             	add    (%r14),%r15b
     7eb:	9f                   	lahf
     7ec:	04 c4                	add    $0xc4,%al
     7ee:	46 ad                	rex.RX lods %ds:(%rsi),%eax
     7f0:	48 02 3e             	rex.W add (%rsi),%dil
     7f3:	9f                   	lahf
     7f4:	00 04 50             	add    %al,(%rax,%rdx,2)
        bpf_map_lookup_elem(&stats, &stats_key);
     7f7:	df 02                	filds  (%rdx)
     7f9:	02 30                	add    (%rax),%dh
     7fb:	9f                   	lahf
     7fc:	04 a6                	add    $0xa6,%al
     7fe:	08 c7                	or     %al,%bh
     800:	09 02                	or     %eax,(%rdx)
     802:	30 9f 04 cc 12 bc    	xor    %bl,-0x43ed33fc(%rdi)
    if (!icmp_ptb_v4_stats) {
     808:	13 02                	adc    (%rdx),%eax
     80a:	30 9f 04 f2 13 a1    	xor    %bl,-0x5eec0dfc(%rdi)
    icmp_ptb_v4_stats->v1 += 1;
     810:	16                   	(bad)
     811:	02 30                	add    (%rax),%dh
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     813:	9f                   	lahf
     814:	04 cc                	add    $0xcc,%al
     816:	16                   	(bad)
     817:	b6 1c                	mov    $0x1c,%dh
      icmp_ptb_v4_stats->v2 += 1;
     819:	02 30                	add    (%rax),%dh
     81b:	9f                   	lahf
     81c:	04 ce                	add    $0xce,%al
  if (iph + 1 > data_end) {
     81e:	1d 84 1e 02 30       	sbb    $0x30021e84,%eax
     823:	9f                   	lahf
     824:	04 c2                	add    $0xc2,%al
     826:	1e                   	(bad)
     827:	dc 20                	fsubl  (%rax)
     829:	02 30                	add    (%rax),%dh
  if (iph->ihl != 5) {
     82b:	9f                   	lahf
     82c:	04 c9                	add    $0xc9,%al
     82e:	21 8c 23 02 30 9f 04 	and    %ecx,0x49f3002(%rbx,%riz,1)
     835:	e5 23                	in     $0x23,%eax
  pckt->flow.proto = iph->protocol;
     837:	95                   	xchg   %eax,%ebp
     838:	2e 02 30             	cs add (%rax),%dh
     83b:	9f                   	lahf
     83c:	04 85                	add    $0x85,%al
  pckt->flags |= F_ICMP;
     83e:	2f                   	(bad)
     83f:	e2 30                	loop   871 <balancer_ingress+0x871>
     841:	02 30                	add    (%rax),%dh
  pckt->flow.src = iph->daddr;
     843:	9f                   	lahf
     844:	04 ba                	add    $0xba,%al
     846:	42 94                	rex.X xchg %eax,%esp
     848:	43 02 30             	rex.XB add (%r8),%sil
  pckt->flow.dst = iph->saddr;
     84b:	9f                   	lahf
     84c:	04 fe                	add    $0xfe,%al
     84e:	43 93                	rex.XB xchg %eax,%r11d
     850:	45 02 30             	add    (%r8),%r14b
     853:	9f                   	lahf
     854:	04 c4                	add    $0xc4,%al
     856:	46 ad                	rex.RX lods %ds:(%rsi),%eax
     858:	48 02 30             	rex.W add (%rax),%sil
     85b:	9f                   	lahf
     85c:	00 04 50             	add    %al,(%rax,%rdx,2)
     85f:	df 02                	filds  (%rdx)
     861:	01 53 04             	add    %edx,0x4(%rbx)
     864:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     865:	08 c7                	or     %al,%bh
     867:	09 01                	or     %eax,(%rcx)
     869:	53                   	push   %rbx
     86a:	04 cc                	add    $0xcc,%al
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     86c:	12 bc 13 01 53 04 f2 	adc    -0xdfbacff(%rbx,%rdx,1),%bh
     873:	13 a1 16 01 53 04    	adc    0x4530116(%rcx),%esp
     879:	cc                   	int3
     87a:	16                   	(bad)
     87b:	b6 1c                	mov    $0x1c,%dh
     87d:	01 53 04             	add    %edx,0x4(%rbx)
  vip.port = pckt.flow.port16[1];
     880:	ce                   	(bad)
     881:	1d 84 1e 01 53       	sbb    $0x53011e84,%eax
     886:	04 c2                	add    $0xc2,%al
     888:	1e                   	(bad)
  vip.proto = pckt.flow.proto;
     889:	a8 1f                	test   $0x1f,%al
     88b:	01 53 04             	add    %edx,0x4(%rbx)
     88e:	c5 1f ff             	(bad)
     891:	1f                   	(bad)
     892:	01 53 00             	add    %edx,0x0(%rbx)
     895:	04 50                	add    $0x50,%al
     897:	df 02                	filds  (%rdx)
     899:	01 5c 04 a6          	add    %ebx,-0x5a(%rsp,%rax,1)
     89d:	08 c7                	or     %al,%bh
     89f:	09 01                	or     %eax,(%rcx)
     8a1:	5c                   	pop    %rsp
     8a2:	04 cc                	add    $0xcc,%al
     8a4:	12 bc 13 01 5c 04 f2 	adc    -0xdfba3ff(%rbx,%rdx,1),%bh
     8ab:	13 a1 16 01 5c 04    	adc    0x45c0116(%rcx),%esp
  if (!vip_info) {
     8b1:	cc                   	int3
     8b2:	16                   	(bad)
     8b3:	b6 1c                	mov    $0x1c,%dh
  if (data_end - data > MAX_PCKT_SIZE) {
     8b5:	01 5c 04 ce          	add    %ebx,-0x32(%rsp,%rax,1)
     8b9:	1d 84 1e 01 5c       	sbb    $0x5c011e84,%eax
     8be:	04 c2                	add    $0xc2,%al
     8c0:	1e                   	(bad)
     8c1:	ed                   	in     (%dx),%eax
     8c2:	1f                   	(bad)
     8c3:	01 5c 04 c9          	add    %ebx,-0x37(%rsp,%rax,1)
     8c7:	21 8c 23 01 5c 04 c3 	and    %ecx,-0x3cfba3ff(%rbx,%riz,1)
     8ce:	30 e2                	xor    %ah,%dl
     8d0:	30 01                	xor    %al,(%rcx)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8d2:	5c                   	pop    %rsp
     8d3:	04 ba                	add    $0xba,%al
     8d5:	42 94                	rex.X xchg %eax,%esp
     8d7:	43 01 5c 04 fe       	add    %ebx,-0x2(%r12,%r8,1)
     8dc:	43 93                	rex.XB xchg %eax,%r11d
     8de:	45 01 5c 04 c4       	add    %r11d,-0x3c(%r12,%rax,1)
  if (!data_stats) {
     8e3:	46 a8 48             	rex.RX test $0x48,%al
     8e6:	01 5c 00 04          	add    %ebx,0x4(%rax,%rax,1)
  data_stats->v1 += 1;
     8ea:	50                   	push   %rax
     8eb:	df 02                	filds  (%rdx)
     8ed:	02 30                	add    (%rax),%dh
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     8ef:	9f                   	lahf
     8f0:	04 a6                	add    $0xa6,%al
     8f2:	08 c7                	or     %al,%bh
    pckt.flow.port16[0] = 0;
     8f4:	09 02                	or     %eax,(%rdx)
     8f6:	30 9f 04 cc 12 bc    	xor    %bl,-0x43ed33fc(%rdi)
  vip_num = vip_info->vip_num;
     8fc:	13 02                	adc    (%rdx),%eax
     8fe:	30 9f 04 f2 13 a1    	xor    %bl,-0x5eec0dfc(%rdi)
  __u32 cpu_num = bpf_get_smp_processor_id();
     904:	16                   	(bad)
     905:	02 30                	add    (%rax),%dh
     907:	9f                   	lahf
     908:	04 cc                	add    $0xcc,%al
     90a:	16                   	(bad)
     90b:	b6 1c                	mov    $0x1c,%dh
     90d:	02 30                	add    (%rax),%dh
     90f:	9f                   	lahf
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     910:	04 ce                	add    $0xce,%al
     912:	1d 84 1e 02 30       	sbb    $0x30021e84,%eax
     917:	9f                   	lahf
     918:	04 c2                	add    $0xc2,%al
     91a:	1e                   	(bad)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     91b:	dc 20                	fsubl  (%rax)
     91d:	02 30                	add    (%rax),%dh
     91f:	9f                   	lahf
     920:	04 c9                	add    $0xc9,%al
     922:	21 8c 23 02 30 9f 04 	and    %ecx,0x49f3002(%rbx,%riz,1)
     929:	e5 23                	in     $0x23,%eax
    if (!lru_stats) {
     92b:	e1 25                	loope  952 <balancer_ingress+0x952>
     92d:	02 30                	add    (%rax),%dh
     92f:	9f                   	lahf
     930:	04 e1                	add    $0xe1,%al
     932:	25 ea 25 01 5e       	and    $0x5e0125ea,%eax
    lru_stats->v1 += 1;
     937:	04 fb                	add    $0xfb,%al
     939:	26 d9 28             	es fldcw (%rax)
     93c:	01 5e 04             	add    %ebx,0x4(%rsi)
     93f:	d3 2c 95 2e 01 5e 04 	shrl   %cl,0x45e012e(,%rdx,4)
     946:	c3                   	ret
     947:	30 e2                	xor    %ah,%dl
     949:	30 02                	xor    %al,(%rdx)
     94b:	30 9f 04 ba 42 94    	xor    %bl,-0x6bbd45fc(%rdi)
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     951:	43 02 30             	rex.XB add (%r8),%sil
     954:	9f                   	lahf
     955:	04 fe                	add    $0xfe,%al
     957:	43 c8 44 02 30       	rex.XB enter $0x244,$0x30
        bpf_map_lookup_elem(&stats, &stats_key);
     95c:	9f                   	lahf
     95d:	04 c8                	add    $0xc8,%al
     95f:	44 fe 44 01 5e       	rex.R incb 0x5e(%rcx,%rax,1)
     964:	04 fe                	add    $0xfe,%al
     966:	44 93                	rex.R xchg %eax,%ebx
     968:	45 02 30             	add    (%r8),%r14b
     96b:	9f                   	lahf
    if (!icmp_ptb_v4_stats) {
     96c:	04 c4                	add    $0xc4,%al
     96e:	46 ad                	rex.RX lods %ds:(%rsi),%eax
     970:	48 01 5e 00          	add    %rbx,0x0(%rsi)
     974:	04 a0                	add    $0xa0,%al
    icmp_ptb_v4_stats->v1 += 1;
     976:	01 df                	add    %ebx,%edi
     978:	02 02                	add    (%rdx),%al
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     97a:	30 9f 04 a6 08 c7    	xor    %bl,-0x38f759fc(%rdi)
      icmp_ptb_v4_stats->v2 += 1;
     980:	09 02                	or     %eax,(%rdx)
     982:	30 9f 04 cc 12 bc    	xor    %bl,-0x43ed33fc(%rdi)
  if (iph + 1 > data_end) {
     988:	13 02                	adc    (%rdx),%eax
     98a:	30 9f 04 f2 13 a1    	xor    %bl,-0x5eec0dfc(%rdi)
     990:	16                   	(bad)
  if (iph->ihl != 5) {
     991:	02 30                	add    (%rax),%dh
     993:	9f                   	lahf
     994:	04 cc                	add    $0xcc,%al
     996:	16                   	(bad)
     997:	b6 1c                	mov    $0x1c,%dh
     999:	02 30                	add    (%rax),%dh
     99b:	9f                   	lahf
     99c:	04 ce                	add    $0xce,%al
  pckt->flow.proto = iph->protocol;
     99e:	1d 84 1e 02 30       	sbb    $0x30021e84,%eax
     9a3:	9f                   	lahf
  pckt->flags |= F_ICMP;
     9a4:	04 c2                	add    $0xc2,%al
     9a6:	1e                   	(bad)
     9a7:	dc 20                	fsubl  (%rax)
  pckt->flow.src = iph->daddr;
     9a9:	02 30                	add    (%rax),%dh
     9ab:	9f                   	lahf
     9ac:	04 c9                	add    $0xc9,%al
     9ae:	21 8c 23 02 30 9f 04 	and    %ecx,0x49f3002(%rbx,%riz,1)
  pckt->flow.dst = iph->saddr;
     9b5:	e5 23                	in     $0x23,%eax
     9b7:	95                   	xchg   %eax,%ebp
     9b8:	2e 02 30             	cs add (%rax),%dh
     9bb:	9f                   	lahf
    vip.port = 0;
     9bc:	04 85                	add    $0x85,%al
     9be:	2f                   	(bad)
     9bf:	e2 30                	loop   9f1 <balancer_ingress+0x9f1>
     9c1:	02 30                	add    (%rax),%dh
     9c3:	9f                   	lahf
     9c4:	04 ba                	add    $0xba,%al
     9c6:	42 94                	rex.X xchg %eax,%esp
     9c8:	43 02 30             	rex.XB add (%r8),%sil
     9cb:	9f                   	lahf
     9cc:	04 fe                	add    $0xfe,%al
     9ce:	43 93                	rex.XB xchg %eax,%r11d
     9d0:	45 02 30             	add    (%r8),%r14b
    if (!vip_info) {
     9d3:	9f                   	lahf
     9d4:	04 c4                	add    $0xc4,%al
     9d6:	46 ad                	rex.RX lods %ds:(%rsi),%eax
     9d8:	48 02 30             	rex.W add (%rax),%sil
     9db:	9f                   	lahf
     9dc:	00 04 a0             	add    %al,(%rax,%riz,4)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     9df:	01 df                	add    %ebx,%edi
     9e1:	02 02                	add    (%rdx),%al
     9e3:	30 9f 04 a6 08 b4    	xor    %bl,-0x4bf759fc(%rdi)
      pckt.flow.port16[1] = 0;
     9e9:	08 02                	or     %al,(%rdx)
     9eb:	30 9f 04 b4 08 8d    	xor    %bl,-0x72f74bfc(%rdi)
     9f1:	09 03                	or     %eax,(%rbx)
  struct address dst_addr = {};
     9f3:	10 22                	adc    %ah,(%rdx)
     9f5:	9f                   	lahf
     9f6:	04 cc                	add    $0xcc,%al
     9f8:	12 bc 13 02 30 9f 04 	adc    0x49f3002(%rbx,%rdx,1),%bh
     9ff:	cc                   	int3
     a00:	16                   	(bad)
     a01:	c4                   	(bad)
     a02:	17                   	(bad)
    dst_addr.addr = pckt->flow.dst;
     a03:	03 10                	add    (%rax),%edx
     a05:	22 9f 00 04 a0 01    	and    0x1a00400(%rdi),%bl
     a0b:	e3 01                	jrcxz  a0e <balancer_ingress+0xa0e>
     a0d:	03 77 10             	add    0x10(%rdi),%esi
     a10:	9f                   	lahf
     a11:	04 a6                	add    $0xa6,%al
     a13:	08 b8 08 03 77 10    	or     %bh,0x10770308(%rax)
     a19:	9f                   	lahf
     a1a:	00 04 a0             	add    %al,(%rax,%riz,4)
     a1d:	01 e3                	add    %esp,%ebx
     a1f:	01 02                	add    %eax,(%rdx)
     a21:	3e 9f                	ds lahf
  if (decap_dst_flags) {
     a23:	04 a6                	add    $0xa6,%al
     a25:	08 b8 08 02 3e 9f    	or     %bh,-0x60c1fdf8(%rax)
     a2b:	00 04 a0             	add    %al,(%rax,%riz,4)
     a2e:	01 e3                	add    %esp,%ebx
     a30:	01 01                	add    %eax,(%rcx)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a32:	53                   	push   %rbx
     a33:	04 a6                	add    $0xa6,%al
     a35:	08 b8 08 01 53 00    	or     %bh,0x530108(%rax)
     a3b:	04 a0                	add    $0xa0,%al
     a3d:	01 e3                	add    %esp,%ebx
     a3f:	01 01                	add    %eax,(%rcx)
     a41:	5c                   	pop    %rsp
    if (!data_stats) {
     a42:	04 a6                	add    $0xa6,%al
     a44:	08 b8 08 01 5c 00    	or     %bh,0x5c0108(%rax)
     a4a:	04 a0                	add    $0xa0,%al
    data_stats->v1 += 1;
     a4c:	01 e3                	add    %esp,%ebx
     a4e:	01 02                	add    %eax,(%rdx)
     a50:	30 9f 04 a6 08 b8    	xor    %bl,-0x47f759fc(%rdi)
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     a56:	08 02                	or     %al,(%rdx)
     a58:	30 9f 00 04 a0 01    	xor    %bl,0x1a00400(%rdi)
     a5e:	ad                   	lods   %ds:(%rsi),%eax
     a5f:	01 03                	add    %eax,(%rbx)
     a61:	73 0e                	jae    a71 <balancer_ingress+0xa71>
     a63:	9f                   	lahf
     a64:	04 ad                	add    $0xad,%al
     a66:	01 af 01 01 50 00    	add    %ebp,0x500101(%rdi)
    csum = iph->check + 0x0001;
     a6c:	04 e3                	add    $0xe3,%al
    iph->check = (csum & 0xffff) + (csum >> 16);
     a6e:	01 df                	add    %ebx,%edi
     a70:	02 01                	add    (%rcx),%al
     a72:	53                   	push   %rbx
     a73:	04 cc                	add    $0xcc,%al
     a75:	12 bc 13 01 53 00 04 	adc    0x4005301(%rbx,%rdx,1),%bh
    if (!--iph->ttl) {
     a7c:	e3 01                	jrcxz  a7f <balancer_ingress+0xa7f>
     a7e:	df 02                	filds  (%rdx)
     a80:	01 5c 04 cc          	add    %ebx,-0x34(%rsp,%rax,1)
     a84:	12 bc 13 01 5c 00 04 	adc    0x4005c01(%rbx,%rdx,1),%bh
     a8b:	e3 01                	jrcxz  a8e <balancer_ingress+0xa8e>
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     a8d:	df 02                	filds  (%rdx)
     a8f:	03 10                	add    (%rax),%edx
     a91:	22 9f 04 cc 12 84    	and    -0x7bed33fc(%rdi),%bl
     a97:	13 03                	adc    (%rbx),%eax
     a99:	10 22                	adc    %ah,(%rdx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     a9b:	9f                   	lahf
     a9c:	04 84                	add    $0x84,%al
     a9e:	13 bc 13 03 10 2a 9f 	adc    -0x60d5effd(%rbx,%rdx,1),%edi
     aa5:	00 04 e3             	add    %al,(%rbx,%riz,8)
  new_eth->h_proto = BE_ETH_P_IP;
     aa8:	01 df                	add    %ebx,%edi
     aaa:	02 03                	add    (%rbx),%al
     aac:	77 10                	ja     abe <balancer_ingress+0xabe>
     aae:	9f                   	lahf
     aaf:	04 cc                	add    $0xcc,%al
     ab1:	12 bc 13 03 77 10 9f 	adc    -0x60ef88fd(%rbx,%rdx,1),%bh
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     ab8:	00 04 e3             	add    %al,(%rbx,%riz,8)
     abb:	01 df                	add    %ebx,%edi
     abd:	02 01                	add    (%rcx),%al
     abf:	5e                   	pop    %rsi
     ac0:	04 cc                	add    $0xcc,%al
     ac2:	12 bc 13 01 5e 00 04 	adc    0x4005e01(%rbx,%rdx,1),%bh
     ac9:	8e 02                	mov    (%rdx),%es
     acb:	a1 02 02 30 9f 04 a1 	movabs 0xbb02a1049f300202,%eax
     ad2:	02 bb 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     ad4:	02 01                	add    (%rcx),%al
     ad6:	54                   	push   %rsp
     ad7:	00 04 a7             	add    %al,(%rdi,%riz,4)
     ada:	02 ab 02 03 11 00    	add    0x110302(%rbx),%ch
  if (!data_stats) {
     ae0:	9f                   	lahf
     ae1:	04 ab                	add    $0xab,%al
     ae3:	02 af 02 03 11 02    	add    0x2110302(%rdi),%ch
     ae9:	9f                   	lahf
     aea:	04 af                	add    $0xaf,%al
     aec:	02 b4 02 03 11 04 9f 	add    -0x60fbeefd(%rdx,%rax,1),%dh
  if (action >= 0) {
     af3:	04 b4                	add    $0xb4,%al
     af5:	02 b7 02 03 11 06    	add    0x6110302(%rdi),%dh
  if (decap_dst_flags) {
     afb:	9f                   	lahf
     afc:	04 b7                	add    $0xb7,%al
  if (action >= 0) {
     afe:	02 bb 02 03 11 07    	add    0x7110302(%rbx),%bh
     b04:	9f                   	lahf
     b05:	04 bb                	add    $0xbb,%al
     b07:	02 c1                	add    %cl,%al
     b09:	02 03                	add    (%rbx),%al
     b0b:	11 08                	adc    %ecx,(%rax)
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b0d:	9f                   	lahf
     b0e:	04 c1                	add    $0xc1,%al
     b10:	02 df                	add    %bh,%bl
     b12:	02 03                	add    (%rbx),%al
     b14:	11 09                	adc    %ecx,(%rcx)
     b16:	9f                   	lahf
     b17:	00 04 ab             	add    %al,(%rbx,%rbp,4)
     b1a:	02 af 02 03 73 12    	add    0x12730302(%rdi),%ch
    if (xpop_stats_data) {
     b20:	9f                   	lahf
     b21:	04 af                	add    $0xaf,%al
     b23:	02 b4 02 03 73 16 9f 	add    -0x60e98cfd(%rdx,%rax,1),%dh
     b2a:	04 b4                	add    $0xb4,%al
     b2c:	02 b7 02 03 73 1c    	add    0x1c730302(%rdi),%dh
     b32:	9f                   	lahf
     b33:	04 b7                	add    $0xb7,%al
     b35:	02 bb 02 03 73 1e    	add    0x1e730302(%rbx),%bh
     b3b:	9f                   	lahf
     b3c:	04 bb                	add    $0xbb,%al
     b3e:	02 c1                	add    %cl,%al
     b40:	02 03                	add    (%rbx),%al
     b42:	73 20                	jae    b64 <balancer_ingress+0xb64>
     b44:	9f                   	lahf
     b45:	04 c1                	add    $0xc1,%al
     b47:	02 df                	add    %bh,%bl
     b49:	02 05 73 20 23 02    	add    0x2232073(%rip),%al        # 2232bc2 <_license+0x2230795>
     b4f:	9f                   	lahf
     b50:	00 04 df             	add    %al,(%rdi,%rbx,8)
     b53:	02 9a 04 01 5d 04    	add    0x45d0104(%rdx),%bl
        bpf_map_lookup_elem(&stats, &stats_key);
     b59:	88 05 c2 06 01 5d    	mov    %al,0x5d0106c2(%rip)        # 5d011221 <_license+0x5d00edf4>
     b5f:	04 db                	add    $0xdb,%al
     b61:	07                   	(bad)
     b62:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     b63:	08 01                	or     %al,(%rcx)
     b65:	5d                   	pop    %rbp
    if (!icmp_ptb_v6_stats) {
     b66:	04 c7                	add    $0xc7,%al
     b68:	09 f6                	or     %esi,%esi
     b6a:	0c 01                	or     $0x1,%al
     b6c:	5d                   	pop    %rbp
     b6d:	04 80                	add    $0x80,%al
    icmp_ptb_v6_stats->v1 += 1;
     b6f:	0d cc 12 01 5d       	or     $0x5d0112cc,%eax
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     b74:	04 bc                	add    $0xbc,%al
     b76:	13 f2                	adc    %edx,%esi
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     b78:	13 01                	adc    (%rcx),%eax
     b7a:	5d                   	pop    %rbp
     b7b:	04 b6                	add    $0xb6,%al
     b7d:	1c ce                	sbb    $0xce,%al
     b7f:	1d 01 5d 04 8e       	sbb    $0x8e045d01,%eax
      icmp_ptb_v6_stats->v2 += 1;
     b84:	1e                   	(bad)
  if (ip6h + 1 > data_end) {
     b85:	c2 1e 01             	ret    $0x11e
     b88:	5d                   	pop    %rbp
     b89:	04 ec                	add    $0xec,%al
     b8b:	20 c9                	and    %cl,%cl
     b8d:	21 01                	and    %eax,(%rcx)
     b8f:	5d                   	pop    %rbp
     b90:	04 8c                	add    $0x8c,%al
     b92:	23 e5                	and    %ebp,%esp
     b94:	23 01                	and    (%rcx),%eax
     b96:	5d                   	pop    %rbp
  pckt->flow.proto = ip6h->nexthdr;
     b97:	04 95                	add    $0x95,%al
     b99:	2e fb                	cs sti
     b9b:	2e 01 5d 04          	cs add %ebx,0x4(%rbp)
  pckt->flags |= F_ICMP;
     b9f:	f5                   	cmc
     ba0:	30 aa 38 01 5d 04    	xor    %ch,0x45d0138(%rdx)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     ba6:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     ba7:	39 ba 3e 01 5d 04    	cmp    %edi,0x45d013e(%rdx)
     bad:	db 3e                	fstpt  (%rsi)
     baf:	b5 40                	mov    $0x40,%ch
     bb1:	01 5d 04             	add    %ebx,0x4(%rbp)
     bb4:	c2 40 ba             	ret    $0xba40
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     bb7:	42 01 5d 04          	rex.X add %ebx,0x4(%rbp)
     bbb:	9b                   	fwait
     bbc:	43 eb 43             	rex.XB jmp c02 <balancer_ingress+0xc02>
     bbf:	01 5d 04             	add    %ebx,0x4(%rbp)
     bc2:	9d                   	popf
     bc3:	45 c4                	rex.RB (bad)
     bc5:	46 01 5d 00          	rex.RX add %r11d,0x0(%rbp)
     bc9:	04 df                	add    $0xdf,%al
     bcb:	02 9a 04 02 3e 9f    	add    -0x60c1fdfc(%rdx),%bl
  if (protocol == IPPROTO_IPIP) {
     bd1:	04 88                	add    $0x88,%al
     bd3:	05 c2 06 02 3e       	add    $0x3e0206c2,%eax
     bd8:	9f                   	lahf
     bd9:	04 db                	add    $0xdb,%al
     bdb:	07                   	(bad)
     bdc:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     bdd:	08 02                	or     %al,(%rdx)
     bdf:	3e 9f                	ds lahf
     be1:	04 c7                	add    $0xc7,%al
     be3:	09 f6                	or     %esi,%esi
  struct address dst_addr = {};
     be5:	0c 02                	or     $0x2,%al
     be7:	3e 9f                	ds lahf
     be9:	04 80                	add    $0x80,%al
     beb:	0d cc 12 02 3e       	or     $0x3e0212cc,%eax
     bf0:	9f                   	lahf
     bf1:	04 bc                	add    $0xbc,%al
     bf3:	13 f2                	adc    %edx,%esi
     bf5:	13 02                	adc    (%rdx),%eax
    dst_addr.addr = pckt->flow.dst;
     bf7:	3e 9f                	ds lahf
     bf9:	04 b6                	add    $0xb6,%al
     bfb:	1c ce                	sbb    $0xce,%al
     bfd:	1d 02 3e 9f 04       	sbb    $0x49f3e02,%eax
     c02:	8e 1e                	mov    (%rsi),%ds
     c04:	c2 1e 02             	ret    $0x21e
     c07:	3e 9f                	ds lahf
     c09:	04 ec                	add    $0xec,%al
     c0b:	20 c9                	and    %cl,%cl
     c0d:	21 02                	and    %eax,(%rdx)
     c0f:	3e 9f                	ds lahf
     c11:	04 8c                	add    $0x8c,%al
     c13:	23 e5                	and    %ebp,%esp
     c15:	23 02                	and    (%rdx),%eax
  if (decap_dst_flags) {
     c17:	3e 9f                	ds lahf
     c19:	04 95                	add    $0x95,%al
     c1b:	2e fb                	cs sti
     c1d:	2e 02 3e             	cs add (%rsi),%bh
     c20:	9f                   	lahf
     c21:	04 f5                	add    $0xf5,%al
     c23:	30 aa 38 02 3e 9f    	xor    %ch,-0x60c1fdc8(%rdx)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c29:	04 a7                	add    $0xa7,%al
     c2b:	39 ba 3e 02 3e 9f    	cmp    %edi,-0x60c1fdc2(%rdx)
     c31:	04 db                	add    $0xdb,%al
     c33:	3e b5 40             	ds mov $0x40,%ch
    if (!data_stats) {
     c36:	02 3e                	add    (%rsi),%bh
     c38:	9f                   	lahf
     c39:	04 c2                	add    $0xc2,%al
     c3b:	40 ba 42 02 3e 9f    	rex mov $0x9f3e0242,%edx
    data_stats->v1 += 1;
     c41:	04 9b                	add    $0x9b,%al
    if ((*data + offset) > *data_end) {
     c43:	43 eb 43             	rex.XB jmp c89 <balancer_ingress+0xc89>
     c46:	02 3e                	add    (%rsi),%bh
     c48:	9f                   	lahf
     c49:	04 9d                	add    $0x9d,%al
     c4b:	45 c4                	rex.RB (bad)
     c4d:	46 02 3e             	rex.RX add (%rsi),%r15b
     c50:	9f                   	lahf
     c51:	00 04 df             	add    %al,(%rdi,%rbx,8)
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     c54:	02 9a 04 02 31 9f    	add    -0x60cefdfc(%rdx),%bl
     c5a:	04 88                	add    $0x88,%al
     c5c:	05 c2 06 02 31       	add    $0x310206c2,%eax
     c61:	9f                   	lahf
     c62:	04 db                	add    $0xdb,%al
     c64:	07                   	(bad)
     c65:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     c66:	08 02                	or     %al,(%rdx)
    if (!--ip6h->hop_limit) {
     c68:	31 9f 04 c7 09 f6    	xor    %ebx,-0x9f638fc(%rdi)
     c6e:	0c 02                	or     $0x2,%al
     c70:	31 9f 04 80 0d cc    	xor    %ebx,-0x33f27ffc(%rdi)
     c76:	12 02                	adc    (%rdx),%al
     c78:	31 9f 04 bc 13 f2    	xor    %ebx,-0xdec43fc(%rdi)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     c7e:	13 02                	adc    (%rdx),%eax
     c80:	31 9f 04 b6 1c ce    	xor    %ebx,-0x31e349fc(%rdi)
     c86:	1d 02 31 9f 04       	sbb    $0x49f3102,%eax
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     c8b:	8e 1e                	mov    (%rsi),%ds
     c8d:	c2 1e 02             	ret    $0x21e
     c90:	31 9f 04 ec 20 c9    	xor    %ebx,-0x36df13fc(%rdi)
     c96:	21 02                	and    %eax,(%rdx)
     c98:	31 9f 04 8c 23 e5    	xor    %ebx,-0x1adc73fc(%rdi)
     c9e:	23 02                	and    (%rdx),%eax
     ca0:	31 9f 04 95 2e fb    	xor    %ebx,-0x4d16afc(%rdi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     ca6:	2e 02 31             	cs add (%rcx),%dh
     ca9:	9f                   	lahf
     caa:	04 f5                	add    $0xf5,%al
     cac:	30 aa 38 02 31 9f    	xor    %ch,-0x60cefdc8(%rdx)
     cb2:	04 a7                	add    $0xa7,%al
     cb4:	39 ba 3e 02 31 9f    	cmp    %edi,-0x60cefdc2(%rdx)
     cba:	04 db                	add    $0xdb,%al
     cbc:	3e b5 40             	ds mov $0x40,%ch
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     cbf:	02 31                	add    (%rcx),%dh
     cc1:	9f                   	lahf
     cc2:	04 c2                	add    $0xc2,%al
     cc4:	40 ba 42 02 31 9f    	rex mov $0x9f310242,%edx
     cca:	04 9b                	add    $0x9b,%al
     ccc:	43 eb 43             	rex.XB jmp d12 <balancer_ingress+0xd12>
  if (!data_stats) {
     ccf:	02 31                	add    (%rcx),%dh
     cd1:	9f                   	lahf
     cd2:	04 9d                	add    $0x9d,%al
     cd4:	45 c4                	rex.RB (bad)
     cd6:	46 02 31             	rex.RX add (%rcx),%r14b
     cd9:	9f                   	lahf
     cda:	00 04 df             	add    %al,(%rdi,%rbx,8)
  if (action >= 0) {
     cdd:	02 9a 04 01 53 04    	add    0x4530104(%rdx),%bl
     ce3:	88 05 c2 06 01 53    	mov    %al,0x530106c2(%rip)        # 530113ab <_license+0x5300ef7e>
  if (decap_dst_flags) {
     ce9:	04 db                	add    $0xdb,%al
     ceb:	07                   	(bad)
  if (action >= 0) {
     cec:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     ced:	08 01                	or     %al,(%rcx)
     cef:	53                   	push   %rbx
     cf0:	04 c7                	add    $0xc7,%al
     cf2:	09 f6                	or     %esi,%esi
     cf4:	0c 01                	or     $0x1,%al
     cf6:	53                   	push   %rbx
     cf7:	04 80                	add    $0x80,%al
     cf9:	0d cc 12 01 53       	or     $0x530112cc,%eax
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     cfe:	04 bc                	add    $0xbc,%al
     d00:	13 f2                	adc    %edx,%esi
     d02:	13 01                	adc    (%rcx),%eax
     d04:	53                   	push   %rbx
     d05:	04 b6                	add    $0xb6,%al
     d07:	1c 93                	sbb    $0x93,%al
     d09:	1d 01 53 04 8e       	sbb    $0x8e045301,%eax
    if (xpop_stats_data) {
     d0e:	1e                   	(bad)
     d0f:	c2 1e 01             	ret    $0x11e
     d12:	53                   	push   %rbx
     d13:	00 04 df             	add    %al,(%rdi,%rbx,8)
     d16:	02 9a 04 01 5c 04    	add    0x45c0104(%rdx),%bl
  udp = data + off;
     d1c:	88 05 c2 06 01 5c    	mov    %al,0x5c0106c2(%rip)        # 5c0113e4 <_license+0x5c00efb7>
     d22:	04 db                	add    $0xdb,%al
  if (udp + 1 > data_end) {
     d24:	07                   	(bad)
     d25:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     d26:	08 01                	or     %al,(%rcx)
     d28:	5c                   	pop    %rsp
     d29:	04 c7                	add    $0xc7,%al
     d2b:	09 f6                	or     %esi,%esi
     d2d:	0c 01                	or     $0x1,%al
     d2f:	5c                   	pop    %rsp
     d30:	04 80                	add    $0x80,%al
     d32:	0d cc 12 01 5c       	or     $0x5c0112cc,%eax
     d37:	04 bc                	add    $0xbc,%al
     d39:	13 f2                	adc    %edx,%esi
     d3b:	13 01                	adc    (%rcx),%eax
     d3d:	5c                   	pop    %rsp
     d3e:	04 b6                	add    $0xb6,%al
     d40:	1c ce                	sbb    $0xce,%al
     d42:	1d 01 5c 04 8e       	sbb    $0x8e045c01,%eax
     d47:	1e                   	(bad)
     d48:	ac                   	lods   %ds:(%rsi),%al
     d49:	1e                   	(bad)
     d4a:	01 5c 04 ec          	add    %ebx,-0x14(%rsp,%rax,1)
     d4e:	20 c9                	and    %cl,%cl
     d50:	21 01                	and    %eax,(%rcx)
     d52:	5c                   	pop    %rsp
     d53:	04 8c                	add    $0x8c,%al
     d55:	23 e5                	and    %ebp,%esp
     d57:	23 01                	and    (%rcx),%eax
     d59:	5c                   	pop    %rsp
     d5a:	04 95                	add    $0x95,%al
     d5c:	2e fb                	cs sti
     d5e:	2e 01 5c 04 f5       	cs add %ebx,-0xb(%rsp,%rax,1)
    vip.vip = pckt.flow.dst;
     d63:	30 93 32 01 5c 04    	xor    %dl,0x45c0132(%rbx)
  vip.port = pckt.flow.port16[1];
     d69:	9b                   	fwait
     d6a:	43 eb 43             	rex.XB jmp db0 <balancer_ingress+0xdb0>
     d6d:	01 5c 04 9d          	add    %ebx,-0x63(%rsp,%rax,1)
     d71:	45 c4                	rex.RB (bad)
  vip.proto = pckt.flow.proto;
     d73:	46 01 5c 00 04       	add    %r11d,0x4(%rax,%r8,1)
     d78:	df 02                	filds  (%rdx)
     d7a:	9a                   	(bad)
     d7b:	04 02                	add    $0x2,%al
     d7d:	30 9f 04 88 05 c2    	xor    %bl,-0x3dfa77fc(%rdi)
     d83:	06                   	(bad)
     d84:	02 30                	add    (%rax),%dh
     d86:	9f                   	lahf
     d87:	04 db                	add    $0xdb,%al
     d89:	07                   	(bad)
     d8a:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     d8b:	08 02                	or     %al,(%rdx)
     d8d:	30 9f 04 c7 09 f6    	xor    %bl,-0x9f638fc(%rdi)
     d93:	0c 02                	or     $0x2,%al
     d95:	30 9f 04 80 0d cc    	xor    %bl,-0x33f27ffc(%rdi)
  if (!vip_info) {
     d9b:	12 02                	adc    (%rdx),%al
     d9d:	30 9f 04 bc 13 f2    	xor    %bl,-0xdec43fc(%rdi)
  if (data_end - data > MAX_PCKT_SIZE) {
     da3:	13 02                	adc    (%rdx),%eax
     da5:	30 9f 04 b6 1c ce    	xor    %bl,-0x31e349fc(%rdi)
     dab:	1d 02 30 9f 04       	sbb    $0x49f3002,%eax
     db0:	8e 1e                	mov    (%rsi),%ds
     db2:	c2 1e 02             	ret    $0x21e
     db5:	30 9f 04 ec 20 c9    	xor    %bl,-0x36df13fc(%rdi)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     dbb:	21 02                	and    %eax,(%rdx)
     dbd:	30 9f 04 8c 23 e5    	xor    %bl,-0x1adc73fc(%rdi)
     dc3:	23 02                	and    (%rdx),%eax
     dc5:	30 9f 04 95 2e fb    	xor    %bl,-0x4d16afc(%rdi)
  if (!data_stats) {
     dcb:	2e 02 30             	cs add (%rax),%dh
     dce:	9f                   	lahf
     dcf:	04 f5                	add    $0xf5,%al
     dd1:	30 be 31 02 30 9f    	xor    %bh,-0x60cffdcf(%rsi)
  data_stats->v1 += 1;
     dd7:	04 be                	add    $0xbe,%al
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     dd9:	31 ca                	xor    %ecx,%edx
     ddb:	31 01                	xor    %eax,(%rcx)
    pckt.flow.port16[0] = 0;
     ddd:	51                   	push   %rcx
     dde:	04 ca                	add    $0xca,%al
     de0:	31 fb                	xor    %edi,%ebx
     de2:	31 01                	xor    %eax,(%rcx)
  vip_num = vip_info->vip_num;
     de4:	53                   	push   %rbx
     de5:	04 fb                	add    $0xfb,%al
     de7:	31 bb 35 02 30 9f    	xor    %edi,-0x60cffdcb(%rbx)
     ded:	04 bb                	add    $0xbb,%al
  __u32 cpu_num = bpf_get_smp_processor_id();
     def:	35 c4 35 01 53       	xor    $0x530135c4,%eax
     df4:	04 c9                	add    $0xc9,%al
     df6:	36 aa                	ss stos %al,%es:(%rdi)
     df8:	38 01                	cmp    %al,(%rcx)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     dfa:	53                   	push   %rbx
     dfb:	04 ff                	add    $0xff,%al
     dfd:	3e b5 40             	ds mov $0x40,%ch
     e00:	01 53 04             	add    %edx,0x4(%rbx)
     e03:	9b                   	fwait
     e04:	43 eb 43             	rex.XB jmp e4a <balancer_ingress+0xe4a>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e07:	01 53 04             	add    %edx,0x4(%rbx)
     e0a:	9d                   	popf
     e0b:	45 c4                	rex.RB (bad)
     e0d:	46 01 53 00          	rex.RX add %r10d,0x0(%rbx)
     e11:	04 af                	add    $0xaf,%al
     e13:	03 9a 04 02 30 9f    	add    -0x60cffdfc(%rdx),%ebx
    if (!lru_stats) {
     e19:	04 88                	add    $0x88,%al
     e1b:	05 c2 06 02 30       	add    $0x300206c2,%eax
    lru_stats->v1 += 1;
     e20:	9f                   	lahf
     e21:	04 db                	add    $0xdb,%al
     e23:	07                   	(bad)
     e24:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     e25:	08 02                	or     %al,(%rdx)
     e27:	30 9f 04 c7 09 f6    	xor    %bl,-0x9f638fc(%rdi)
     e2d:	0c 02                	or     $0x2,%al
     e2f:	30 9f 04 80 0d cc    	xor    %bl,-0x33f27ffc(%rdi)
     e35:	12 02                	adc    (%rdx),%al
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e37:	30 9f 04 bc 13 f2    	xor    %bl,-0xdec43fc(%rdi)
     e3d:	13 02                	adc    (%rdx),%eax
     e3f:	30 9f 04 b6 1c ce    	xor    %bl,-0x31e349fc(%rdi)
     e45:	1d 02 30 9f 04       	sbb    $0x49f3002,%eax
     e4a:	8e 1e                	mov    (%rsi),%ds
     e4c:	c2 1e 02             	ret    $0x21e
  if (!lru_map) {
     e4f:	30 9f 04 ec 20 c9    	xor    %bl,-0x36df13fc(%rdi)
     e55:	21 02                	and    %eax,(%rdx)
     e57:	30 9f 04 8c 23 e5    	xor    %bl,-0x1adc73fc(%rdi)
  if ((vip_info->flags & F_QUIC_VIP)) {
     e5d:	23 02                	and    (%rdx),%eax
     e5f:	30 9f 04 95 2e fb    	xor    %bl,-0x4d16afc(%rdi)
    bool is_icmp = (pckt.flags & F_ICMP);
     e65:	2e 02 30             	cs add (%rax),%dh
    if (is_icmp) {
     e68:	9f                   	lahf
     e69:	04 f5                	add    $0xf5,%al
     e6b:	30 aa 38 02 30 9f    	xor    %ch,-0x60cffdc8(%rdx)
     e71:	04 a7                	add    $0xa7,%al
     e73:	39 ba 3e 02 30 9f    	cmp    %edi,-0x60cffdc2(%rdx)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     e79:	04 db                	add    $0xdb,%al
     e7b:	3e b5 40             	ds mov $0x40,%ch
     e7e:	02 30                	add    (%rax),%dh
     e80:	9f                   	lahf
     e81:	04 c2                	add    $0xc2,%al
     e83:	40 ba 42 02 30 9f    	rex mov $0x9f300242,%edx
      if (!quic_packets_stats) {
     e89:	04 9b                	add    $0x9b,%al
     e8b:	43 eb 43             	rex.XB jmp ed1 <balancer_ingress+0xed1>
     e8e:	02 30                	add    (%rax),%dh
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e90:	9f                   	lahf
     e91:	04 9d                	add    $0x9d,%al
  bool is_icmp = (pckt->flags & F_ICMP);
     e93:	45 c4                	rex.RB (bad)
     e95:	46 02 30             	rex.RX add (%rax),%r14b
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e98:	9f                   	lahf
     e99:	00 04 af             	add    %al,(%rdi,%rbp,4)
     e9c:	03 9a 04 02 30 9f    	add    -0x60cffdfc(%rdx),%ebx
     ea2:	04 88                	add    $0x88,%al
     ea4:	05 ac 05 02 30       	add    $0x300205ac,%eax
     ea9:	9f                   	lahf
     eaa:	04 ac                	add    $0xac,%al
     eac:	05 c2 06 03 10       	add    $0x100306c2,%eax
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     eb1:	36 9f                	ss lahf
     eb3:	04 db                	add    $0xdb,%al
     eb5:	07                   	(bad)
     eb6:	ec                   	in     (%dx),%al
     eb7:	07                   	(bad)
     eb8:	03 10                	add    (%rax),%edx
     eba:	36 9f                	ss lahf
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     ebc:	04 c7                	add    $0xc7,%al
     ebe:	09 bd 0a 02 30 9f    	or     %edi,-0x60cffdf6(%rbp)
     ec4:	04 e6                	add    $0xe6,%al
     ec6:	0f d6                	(bad)
     ec8:	10 03                	adc    %al,(%rbx)
     eca:	10 36                	adc    %dh,(%rsi)
     ecc:	9f                   	lahf
     ecd:	00 04 af             	add    %al,(%rdi,%rbp,4)
    vip.port = 0;
     ed0:	03 ed                	add    %ebp,%ebp
     ed2:	03 03                	add    (%rbx),%eax
     ed4:	77 10                	ja     ee6 <balancer_ingress+0xee6>
     ed6:	9f                   	lahf
     ed7:	04 88                	add    $0x88,%al
     ed9:	05 b4 05 03 77       	add    $0x770305b4,%eax
     ede:	10 9f 00 04 af 03    	adc    %bl,0x3af0400(%rdi)
    if (!vip_info) {
     ee4:	ed                   	in     (%dx),%eax
     ee5:	03 02                	add    (%rdx),%eax
     ee7:	3e 9f                	ds lahf
     ee9:	04 88                	add    $0x88,%al
     eeb:	05 b4 05 02 3e       	add    $0x3e0205b4,%eax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     ef0:	9f                   	lahf
     ef1:	00 04 af             	add    %al,(%rdi,%rbp,4)
     ef4:	03 ed                	add    %ebp,%ebp
     ef6:	03 01                	add    (%rcx),%eax
      pckt.flow.port16[1] = 0;
     ef8:	53                   	push   %rbx
     ef9:	04 88                	add    $0x88,%al
     efb:	05 b4 05 01 53       	add    $0x530105b4,%eax
     f00:	00 04 af             	add    %al,(%rdi,%rbp,4)
     f03:	03 ed                	add    %ebp,%ebp
     f05:	03 01                	add    (%rcx),%eax
     f07:	5c                   	pop    %rsp
     f08:	04 88                	add    $0x88,%al
     f0a:	05 b4 05 01 5c       	add    $0x5c0105b4,%eax
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     f0f:	00 04 af             	add    %al,(%rdi,%rbp,4)
     f12:	03 ed                	add    %ebp,%ebp
     f14:	03 02                	add    (%rdx),%eax
     f16:	31 9f 04 88 05 b4    	xor    %ebx,-0x4bfa77fc(%rdi)
     f1c:	05 02 31 9f 00       	add    $0x9f3102,%eax
      if (!data_stats) {
     f21:	04 af                	add    $0xaf,%al
     f23:	03 bc 03 03 73 0e 9f 	add    -0x60f18cfd(%rbx,%rax,1),%edi
      data_stats->v1 += 1;
     f2a:	04 bc                	add    $0xbc,%al
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     f2c:	03 bf 03 01 50 00    	add    0x500103(%rdi),%edi
     f32:	04 bc                	add    $0xbc,%al
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     f34:	03 ed                	add    %ebp,%ebp
     f36:	03 03                	add    (%rbx),%eax
     f38:	10 28                	adc    %ch,(%rax)
        data_stats->v2 += 1;
     f3a:	9f                   	lahf
     f3b:	04 88                	add    $0x88,%al
     f3d:	05 b4 05 03 10       	add    $0x100305b4,%eax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     f42:	28 9f 00 04 ed 03    	sub    %bl,0x3ed0400(%rdi)
     f48:	9a                   	(bad)
     f49:	04 01                	add    $0x1,%al
     f4b:	53                   	push   %rbx
     f4c:	04 c7                	add    $0xc7,%al
     f4e:	09 bd 0a 01 53 00    	or     %edi,0x53010a(%rbp)
     f54:	04 ed                	add    $0xed,%al
     f56:	03 9a 04 01 5c 04    	add    0x45c0104(%rdx),%ebx
  if (!lru_map) {
     f5c:	c7                   	(bad)
     f5d:	09 bd 0a 01 5c 00    	or     %edi,0x5c010a(%rbp)
     f63:	04 ed                	add    $0xed,%al
     f65:	03 9a 04 03 77 10    	add    0x10770304(%rdx),%ebx
     f6b:	9f                   	lahf
  if ((vip_info->flags & F_QUIC_VIP)) {
     f6c:	04 c7                	add    $0xc7,%al
     f6e:	09 bd 0a 03 77 10    	or     %edi,0x1077030a(%rbp)
     f74:	9f                   	lahf
     f75:	00 04 ed 03 9a 04 01 	add    %al,0x1049a03(,%rbp,8)
    bool is_icmp = (pckt.flags & F_ICMP);
     f7c:	5f                   	pop    %rdi
     f7d:	04 c7                	add    $0xc7,%al
    if (is_icmp) {
     f7f:	09 bd 0a 01 5f 00    	or     %edi,0x5f010a(%rbp)
     f85:	04 ac                	add    $0xac,%al
     f87:	05 c2 06 03 11       	add    $0x110306c2,%eax
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     f8c:	7f 9f                	jg     f2d <balancer_ingress+0xf2d>
     f8e:	04 db                	add    $0xdb,%al
     f90:	07                   	(bad)
     f91:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     f92:	08 03                	or     %al,(%rbx)
     f94:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     f97:	04 c1                	add    $0xc1,%al
     f99:	0a b6 0b 03 11 7f    	or     0x7f11030b(%rsi),%dh
      if (!quic_packets_stats) {
     f9f:	9f                   	lahf
     fa0:	04 b6                	add    $0xb6,%al
     fa2:	0b f6                	or     %esi,%esi
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fa4:	0c 03                	or     $0x3,%al
     fa6:	11 01                	adc    %eax,(%rcx)
  bool is_icmp = (pckt->flags & F_ICMP);
     fa8:	9f                   	lahf
     fa9:	04 80                	add    $0x80,%al
     fab:	0d d8 0d 03 11       	or     $0x11030dd8,%eax
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fb0:	7f 9f                	jg     f51 <balancer_ingress+0xf51>
     fb2:	04 d8                	add    $0xd8,%al
     fb4:	0d b0 0f 03 11       	or     $0x11030fb0,%eax
     fb9:	01 9f 04 b0 0f cc    	add    %ebx,-0x33f04ffc(%rdi)
     fbf:	12 03                	adc    (%rbx),%al
     fc1:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     fc4:	04 bc                	add    $0xbc,%al
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fc6:	13 f2                	adc    %edx,%esi
     fc8:	13 03                	adc    (%rbx),%eax
     fca:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     fcd:	04 b6                	add    $0xb6,%al
     fcf:	1c ce                	sbb    $0xce,%al
     fd1:	1d 03 11 7f 9f       	sbb    $0x9f7f1103,%eax
     fd6:	04 8e                	add    $0x8e,%al
     fd8:	1e                   	(bad)
     fd9:	c2 1e 03             	ret    $0x31e
     fdc:	11 7f 9f             	adc    %edi,-0x61(%rdi)
      if (!data_stats) {
     fdf:	04 ec                	add    $0xec,%al
     fe1:	20 c9                	and    %cl,%cl
     fe3:	21 03                	and    %eax,(%rbx)
     fe5:	11 7f 9f             	adc    %edi,-0x61(%rdi)
      data_stats->v1 += 1;
     fe8:	04 8c                	add    $0x8c,%al
     fea:	23 e5                	and    %ebp,%esp
     fec:	23 03                	and    (%rbx),%eax
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     fee:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     ff1:	04 95                	add    $0x95,%al
     ff3:	2e fb                	cs sti
     ff5:	2e 03 11             	cs add (%rcx),%edx
     ff8:	7f 9f                	jg     f99 <balancer_ingress+0xf99>
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     ffa:	04 f5                	add    $0xf5,%al
        data_stats->v2 += 1;
     ffc:	30 aa 38 03 11 7f    	xor    %ch,0x7f110338(%rdx)
    1002:	9f                   	lahf
    1003:	04 a7                	add    $0xa7,%al
  original_sport = pckt.flow.port16[0];
    1005:	39 ba 3e 03 11 7f    	cmp    %edi,0x7f11033e(%rdx)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    100b:	9f                   	lahf
    100c:	04 db                	add    $0xdb,%al
    100e:	3e b5 40             	ds mov $0x40,%ch
        !(vip_info->flags & F_LRU_BYPASS)) {
    1011:	03 11                	add    (%rcx),%edx
    1013:	7f 9f                	jg     fb4 <balancer_ingress+0xfb4>
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1015:	04 c2                	add    $0xc2,%al
    1017:	40 ba 42 03 11 7f    	rex mov $0x7f110342,%edx
    101d:	9f                   	lahf
    101e:	04 9b                	add    $0x9b,%al
    1020:	43 eb 43             	rex.XB jmp 1066 <balancer_ingress+0x1066>
    1023:	03 11                	add    (%rcx),%edx
    1025:	7f 9f                	jg     fc6 <balancer_ingress+0xfc6>
  if (!dst_lru) {
    1027:	04 9d                	add    $0x9d,%al
    1029:	45 c4                	rex.RB (bad)
    102b:	46 03 11             	rex.RX add (%rcx),%r10d
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    102e:	7f 9f                	jg     fcf <balancer_ingress+0xfcf>
    1030:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    1033:	05 b8 05 01 50       	add    $0x500105b8,%eax
    1038:	04 db                	add    $0xdb,%al
    103a:	07                   	(bad)
    103b:	80 08 01             	orb    $0x1,(%rax)
    103e:	50                   	push   %rax
    103f:	04 c1                	add    $0xc1,%al
    cur_time = bpf_ktime_get_ns();
    1041:	0a e3                	or     %bl,%ah
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1043:	0a 01                	or     (%rcx),%al
    1045:	50                   	push   %rax
    1046:	04 80                	add    $0x80,%al
    1048:	0d 85 0d 01 50       	or     $0x50010d85,%eax
    104d:	04 b0                	add    $0xb0,%al
    104f:	0f b4 0f             	lfs    (%rdi),%ecx
    1052:	01 50 00             	add    %edx,0x0(%rax)
    1055:	04 ac                	add    $0xac,%al
    1057:	05 c2 06 01 53       	add    $0x530106c2,%eax
    105c:	04 e6                	add    $0xe6,%al
    105e:	0f d6                	(bad)
    1060:	10 01                	adc    %al,(%rcx)
    1062:	53                   	push   %rbx
    1063:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    1066:	05 c2 06 01 5c       	add    $0x5c0106c2,%eax
    106b:	04 e6                	add    $0xe6,%al
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    106d:	0f d6                	(bad)
    106f:	10 01                	adc    %al,(%rcx)
    1071:	5c                   	pop    %rsp
    1072:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    1075:	05 c2 06 03 10       	add    $0x100306c2,%eax
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    107a:	36 9f                	ss lahf
    107c:	04 e6                	add    $0xe6,%al
    107e:	0f d6                	(bad)
    1080:	10 03                	adc    %al,(%rbx)
        quic_packets_stats->cid_initial += 1;
    1082:	10 36                	adc    %dh,(%rsi)
    1084:	9f                   	lahf
    1085:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    1088:	05 c2 06 03 77       	add    $0x770306c2,%eax
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    108d:	10 9f 04 e6 0f d6    	adc    %bl,-0x29f019fc(%rdi)
    1093:	10 03                	adc    %al,(%rbx)
    1095:	77 10                	ja     10a7 <balancer_ingress+0x10a7>
    1097:	9f                   	lahf
    1098:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    109b:	05 b8 05 01 50       	add    $0x500105b8,%eax
    10a0:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    10a3:	05 c2 06 01 53       	add    $0x530106c2,%eax
    10a8:	04 e6                	add    $0xe6,%al
    10aa:	0f d6                	(bad)
    10ac:	10 01                	adc    %al,(%rcx)
    10ae:	53                   	push   %rbx
    10af:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    10b2:	05 c2 06 01 5c       	add    $0x5c0106c2,%eax
    10b7:	04 e6                	add    $0xe6,%al
    10b9:	0f d6                	(bad)
  if (!per_vip_stats) {
    10bb:	10 01                	adc    %al,(%rcx)
    10bd:	5c                   	pop    %rsp
    10be:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    10c1:	05 c2 06 03 10       	add    $0x100306c2,%eax
    10c6:	36 9f                	ss lahf
    10c8:	04 e6                	add    $0xe6,%al
    10ca:	0f 9e 10             	setle  (%rax)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    10cd:	03 10                	add    (%rax),%edx
    10cf:	36 9f                	ss lahf
    10d1:	04 9e                	add    $0x9e,%al
    10d3:	10 d6                	adc    %dl,%dh
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    10d5:	10 03                	adc    %al,(%rbx)
    10d7:	10 3e                	adc    %bh,(%rsi)
    10d9:	9f                   	lahf
    10da:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    10dd:	05 c2 06 03 77       	add    $0x770306c2,%eax
  if (!connId) {
    10e2:	10 9f 04 e6 0f d6    	adc    %bl,-0x29f019fc(%rdi)
    10e8:	10 03                	adc    %al,(%rbx)
    10ea:	77 10                	ja     10fc <balancer_ingress+0x10fc>
  __u8 connIdVersion = (connId[0] >> 6);
    10ec:	9f                   	lahf
    10ed:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    10f0:	05 c2 06 01 5f       	add    $0x5f0106c2,%eax
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10f5:	04 e6                	add    $0xe6,%al
    10f7:	0f d6                	(bad)
    10f9:	10 01                	adc    %al,(%rcx)
    10fb:	5f                   	pop    %rdi
    10fc:	00 04 db             	add    %al,(%rbx,%rbx,8)
    10ff:	05 80 06 02 30       	add    $0x30020680,%eax
    1104:	9f                   	lahf
    1105:	04 80                	add    $0x80,%al
    1107:	06                   	(bad)
    1108:	a3 06 01 52 00 04 db 	movabs %eax,0xed05db0400520106
    110f:	05 ed 
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    1111:	05 02 30 9f 04       	add    $0x49f3002,%eax
    1116:	ed                   	in     (%dx),%eax
    1117:	05 c2 06 03 10       	add    $0x100306c2,%eax
    111c:	22 9f 00 04 ed 05    	and    0x5ed0400(%rdi),%bl
    1122:	c2 06 03             	ret    $0x306
    1125:	73 22                	jae    1149 <balancer_ingress+0x1149>
    1127:	9f                   	lahf
    1128:	00 04 86             	add    %al,(%rsi,%rax,4)
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    112b:	06                   	(bad)
    112c:	8b 06                	mov    (%rsi),%eax
    112e:	03 11                	add    (%rcx),%edx
    1130:	00 9f 04 8b 06 8f    	add    %bl,-0x70f974fc(%rdi)
    1136:	06                   	(bad)
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1137:	03 11                	add    (%rcx),%edx
    1139:	01 9f 04 8f 06 93    	add    %ebx,-0x6cf970fc(%rdi)
    113f:	06                   	(bad)
        quic_packets_stats->cid_initial += 1;
    1140:	03 11                	add    (%rcx),%edx
    1142:	02 9f 04 93 06 97    	add    -0x68f96cfc(%rdi),%bl
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1148:	06                   	(bad)
    1149:	03 11                	add    (%rcx),%edx
    114b:	03 9f 04 97 06 9c    	add    -0x63f968fc(%rdi),%ebx
    1151:	06                   	(bad)
    1152:	03 11                	add    (%rcx),%edx
    1154:	04 9f                	add    $0x9f,%al
    1156:	04 9c                	add    $0x9c,%al
    1158:	06                   	(bad)
    1159:	9f                   	lahf
    115a:	06                   	(bad)
    115b:	03 11                	add    (%rcx),%edx
    115d:	06                   	(bad)
    115e:	9f                   	lahf
    115f:	04 9f                	add    $0x9f,%al
    1161:	06                   	(bad)
    1162:	a3 06 03 11 07 9f 04 	movabs %eax,0x6a3049f07110306
    1169:	a3 06 
    116b:	a9 06 03 11 08       	test   $0x8110306,%eax
    1170:	9f                   	lahf
    1171:	04 a9                	add    $0xa9,%al
    1173:	06                   	(bad)
    1174:	c2 06 03             	ret    $0x306
    1177:	11 09                	adc    %ecx,(%rcx)
    1179:	9f                   	lahf
    117a:	00 04 86             	add    %al,(%rsi,%rax,4)
    117d:	06                   	(bad)
  if (!per_vip_stats) {
    117e:	8f 06                	pop    (%rsi)
    1180:	03 73 10             	add    0x10(%rbx),%esi
    1183:	9f                   	lahf
    1184:	04 8f                	add    $0x8f,%al
    1186:	06                   	(bad)
    1187:	93                   	xchg   %eax,%ebx
    1188:	06                   	(bad)
    1189:	03 73 12             	add    0x12(%rbx),%esi
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    118c:	9f                   	lahf
    118d:	04 93                	add    $0x93,%al
    118f:	06                   	(bad)
    1190:	97                   	xchg   %eax,%edi
    1191:	06                   	(bad)
    1192:	03 73 14             	add    0x14(%rbx),%esi
    1195:	9f                   	lahf
    1196:	04 97                	add    $0x97,%al
    1198:	06                   	(bad)
    1199:	9c                   	pushf
    119a:	06                   	(bad)
    119b:	03 73 18             	add    0x18(%rbx),%esi
  if (!connId) {
    119e:	9f                   	lahf
    119f:	04 9c                	add    $0x9c,%al
    11a1:	06                   	(bad)
    11a2:	9f                   	lahf
    11a3:	06                   	(bad)
    11a4:	03 73 1c             	add    0x1c(%rbx),%esi
  __u8 connIdVersion = (connId[0] >> 6);
    11a7:	9f                   	lahf
    11a8:	04 9f                	add    $0x9f,%al
    11aa:	06                   	(bad)
    11ab:	a3 06 03 73 1e 9f 04 	movabs %eax,0x6a3049f1e730306
    11b2:	a3 06 
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    11b4:	a9 06 03 73 20       	test   $0x20730306,%eax
    11b9:	9f                   	lahf
    11ba:	04 a9                	add    $0xa9,%al
    11bc:	06                   	(bad)
    11bd:	c2 06 05             	ret    $0x506
    11c0:	73 20                	jae    11e2 <balancer_ingress+0x11e2>
    11c2:	23 02                	and    (%rdx),%eax
    11c4:	9f                   	lahf
    11c5:	00 04 fe             	add    %al,(%rsi,%rdi,8)
    11c8:	36 8b 37             	ss mov (%rdi),%esi
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    11cb:	01 51 00             	add    %edx,0x0(%rcx)
    11ce:	04 86                	add    $0x86,%al
    11d0:	08 a6 08 01 50 00    	or     %ah,0x500108(%rsi)
    11d6:	04 b4                	add    $0xb4,%al
    11d8:	08 c7                	or     %al,%bh
    11da:	09 03                	or     %eax,(%rbx)
    11dc:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    11df:	04 f2                	add    $0xf2,%al
    11e1:	13 d3                	adc    %ebx,%edx
    11e3:	14 03                	adc    $0x3,%al
    dst_lru->atime = cur_time;
    11e5:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    11e8:	04 d3                	add    $0xd3,%al
  key = dst_lru->pos;
    11ea:	14 a1                	adc    $0xa1,%al
    11ec:	16                   	(bad)
    11ed:	03 11                	add    (%rcx),%edx
    11ef:	01 9f 04 cc 16 c4    	add    %ebx,-0x3be933fc(%rdi)
  pckt->real_index = key;
    11f5:	17                   	(bad)
    11f6:	03 11                	add    (%rcx),%edx
    11f8:	7f 9f                	jg     1199 <balancer_ingress+0x1199>
  *real = bpf_map_lookup_elem(&reals, &key);
    11fa:	04 c8                	add    $0xc8,%al
    11fc:	17                   	(bad)
    11fd:	c2 18 03             	ret    $0x318
    1200:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    1203:	04 c2                	add    $0xc2,%al
    1205:	18 99 1a 03 11 01    	sbb    %bl,0x111031a(%rcx)
    120b:	9f                   	lahf
    120c:	04 99                	add    $0x99,%al
    120e:	1a b6 1c 03 11 7f    	sbb    0x7f11031c(%rsi),%dh
    1214:	9f                   	lahf
    1215:	04 ce                	add    $0xce,%al
    1217:	1d 84 1e 03 11       	sbb    $0x11031e84,%eax
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    121c:	7f 9f                	jg     11bd <balancer_ingress+0x11bd>
    121e:	04 c2                	add    $0xc2,%al
    1220:	1e                   	(bad)
    1221:	dc 20                	fsubl  (%rax)
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1223:	03 11                	add    (%rcx),%edx
    1225:	7f 9f                	jg     11c6 <balancer_ingress+0x11c6>
    1227:	04 c9                	add    $0xc9,%al
    1229:	21 8c 23 03 11 7f 9f 	and    %ecx,-0x6080eefd(%rbx,%riz,1)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1230:	04 e5                	add    $0xe5,%al
    1232:	23 95 2e 03 11 7f    	and    0x7f11032e(%rbp),%edx
    1238:	9f                   	lahf
    1239:	04 85                	add    $0x85,%al
    123b:	2f                   	(bad)
    123c:	e2 30                	loop   126e <balancer_ingress+0x126e>
    123e:	03 11                	add    (%rcx),%edx
    1240:	7f 9f                	jg     11e1 <balancer_ingress+0x11e1>
    1242:	04 ba                	add    $0xba,%al
    1244:	42 94                	rex.X xchg %eax,%esp
    1246:	43 03 11             	rex.XB add (%r9),%edx
  if (!conn_rate_stats) {
    1249:	7f 9f                	jg     11ea <balancer_ingress+0x11ea>
    124b:	04 fe                	add    $0xfe,%al
    124d:	43 93                	rex.XB xchg %eax,%r11d
    124f:	45 03 11             	add    (%r9),%r10d
    1252:	7f 9f                	jg     11f3 <balancer_ingress+0x11f3>
    1254:	04 c4                	add    $0xc4,%al
    1256:	46 ad                	rex.RX lods %ds:(%rsi),%eax
  *cur_time = bpf_ktime_get_ns();
    1258:	48 03 11             	add    (%rcx),%rdx
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    125b:	7f 9f                	jg     11fc <balancer_ingress+0x11fc>
    125d:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    1260:	08 bc 08 01 50 04 fc 	or     %bh,-0x3fbafff(%rax,%rcx,1)
    1267:	08 a1 09 01 50 04    	or     %ah,0x4500109(%rcx)
    conn_rate_stats->v1 = 1;
    126d:	f2 13 87 14 01 50 04 	repnz adc 0x4500114(%rdi),%eax
    conn_rate_stats->v2 = *cur_time;
    1274:	c8 17 fa 17          	enter  $0xfa17,$0x17
    conn_rate_stats->v1 += 1;
    1278:	01 50 04             	add    %edx,0x4(%rax)
    127b:	99                   	cltd
    127c:	1a 9d 1a 01 50 00    	sbb    0x50011a(%rbp),%bl
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1282:	04 b4                	add    $0xb4,%al
    1284:	08 fc                	or     %bh,%ah
    1286:	08 01                	or     %al,(%rcx)
    1288:	53                   	push   %rbx
    1289:	04 cc                	add    $0xcc,%al
    128b:	16                   	(bad)
    128c:	c4                   	(bad)
    128d:	17                   	(bad)
    128e:	01 53 00             	add    %edx,0x0(%rbx)
    1291:	04 b4                	add    $0xb4,%al
    1293:	08 fc                	or     %bh,%ah
    1295:	08 01                	or     %al,(%rcx)
    1297:	5c                   	pop    %rsp
    1298:	04 cc                	add    $0xcc,%al
    129a:	16                   	(bad)
    129b:	c4                   	(bad)
    129c:	17                   	(bad)
    if (down_reals_map) {
    129d:	01 5c 00 04          	add    %ebx,0x4(%rax,%rax,1)
    12a1:	b4 08                	mov    $0x8,%ah
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    12a3:	fc                   	cld
    12a4:	08 03                	or     %al,(%rbx)
    12a6:	10 22                	adc    %ah,(%rdx)
    12a8:	9f                   	lahf
    12a9:	04 cc                	add    $0xcc,%al
    12ab:	16                   	(bad)
    12ac:	c4                   	(bad)
    12ad:	17                   	(bad)
    12ae:	03 10                	add    (%rax),%edx
      if (down_real) {
    12b0:	22 9f 00 04 b4 08    	and    0x8b40400(%rdi),%bl
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    12b6:	fc                   	cld
    12b7:	08 03                	or     %al,(%rbx)
    12b9:	77 10                	ja     12cb <balancer_ingress+0x12cb>
    12bb:	9f                   	lahf
    12bc:	04 cc                	add    $0xcc,%al
    12be:	16                   	(bad)
    12bf:	c4                   	(bad)
    12c0:	17                   	(bad)
    12c1:	03 77 10             	add    0x10(%rdi),%esi
    12c4:	9f                   	lahf
    12c5:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    12c8:	08 bc 08 01 50 00 04 	or     %bh,0x4005001(%rax,%rcx,1)
        if (stats_data) {
    12cf:	b8 08 fc 08 01       	mov    $0x108fc08,%eax
    12d4:	53                   	push   %rbx
    12d5:	04 cc                	add    $0xcc,%al
    12d7:	16                   	(bad)
          stats_data->v1 += 1;
    12d8:	c4                   	(bad)
    12d9:	17                   	(bad)
    12da:	01 53 00             	add    %edx,0x0(%rbx)
    12dd:	04 b8                	add    $0xb8,%al
    12df:	08 fc                	or     %bh,%ah
    if (!dst) {
    12e1:	08 01                	or     %al,(%rcx)
    12e3:	5c                   	pop    %rsp
    12e4:	04 cc                	add    $0xcc,%al
    12e6:	16                   	(bad)
    12e7:	c4                   	(bad)
    12e8:	17                   	(bad)
    12e9:	01 5c 00 04          	add    %ebx,0x4(%rax,%rax,1)
    12ed:	b8 08 fc 08 03       	mov    $0x308fc08,%eax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    12f2:	10 22                	adc    %ah,(%rdx)
    12f4:	9f                   	lahf
    12f5:	04 cc                	add    $0xcc,%al
    12f7:	16                   	(bad)
    12f8:	85 17                	test   %edx,(%rdi)
    12fa:	03 10                	add    (%rax),%edx
    12fc:	22 9f 04 85 17 c4    	and    -0x3be87afc(%rdi),%bl
    1302:	17                   	(bad)
    1303:	03 10                	add    (%rax),%edx
    1305:	2a 9f 00 04 b8 08    	sub    0x8b80400(%rdi),%bl
    130b:	fc                   	cld
    130c:	08 03                	or     %al,(%rbx)
    130e:	77 10                	ja     1320 <balancer_ingress+0x1320>
    1310:	9f                   	lahf
    1311:	04 cc                	add    $0xcc,%al
    1313:	16                   	(bad)
    1314:	c4                   	(bad)
    1315:	17                   	(bad)
    1316:	03 77 10             	add    0x10(%rdi),%esi
  if (!data_stats) {
    1319:	9f                   	lahf
    131a:	00 04 b8             	add    %al,(%rax,%rdi,4)
    131d:	08 fc                	or     %bh,%ah
    131f:	08 01                	or     %al,(%rcx)
    1321:	5e                   	pop    %rsi
    1322:	04 cc                	add    $0xcc,%al
    1324:	16                   	(bad)
    1325:	c4                   	(bad)
    1326:	17                   	(bad)
    1327:	01 5e 00             	add    %ebx,0x0(%rsi)
    132a:	04 a7                	add    $0xa7,%al
    132c:	09 c7                	or     %eax,%edi
  data_stats->v1 += 1;
    132e:	09 01                	or     %eax,(%rcx)
    1330:	50                   	push   %rax
  data_stats->v2 += pkt_bytes;
    1331:	00 04 c7             	add    %al,(%rdi,%rax,8)
    1334:	09 d8                	or     %ebx,%eax
    1336:	09 02                	or     %eax,(%rdx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1338:	30 9f 04 d8 09 e1    	xor    %bl,-0x1ef627fc(%rdi)
    133e:	09 01                	or     %eax,(%rcx)
    1340:	50                   	push   %rax
    1341:	00 04 e1             	add    %al,(%rcx,%riz,8)
    1344:	09 80 0a 01 50 00    	or     %eax,0x50010a(%rax)
    134a:	04 f3                	add    $0xf3,%al
    134c:	09 80 0a 01 52 00    	or     %eax,0x52010a(%rax)
    1352:	04 80                	add    $0x80,%al
    1354:	0a bd 0a 03 10 3e    	or     0x3e10030a(%rbp),%bh
    135a:	9f                   	lahf
    135b:	00 04 80             	add    %al,(%rax,%rax,4)
    135e:	0a bd 0a 03 73 3e    	or     0x3e73030a(%rbp),%bh
  if (!data_stats) {
    1364:	9f                   	lahf
    1365:	00 04 de             	add    %al,(%rsi,%rbx,8)
    1368:	0a b6 0b 02 31 9f    	or     -0x60cefdf5(%rsi),%dh
  data_stats->v1 += 1;
    136e:	04 b6                	add    $0xb6,%al
    1370:	0b f6                	or     %esi,%esi
  data_stats->v2 += pkt_bytes;
    1372:	0c 02                	or     $0x2,%al
    1374:	30 9f 00 04 de 0a    	xor    %bl,0xade0400(%rdi)
  pckt.flow.port16[0] = original_sport;
    137a:	b6 0b                	mov    $0xb,%dh
  if (dst->flags & F_IPV6) {
    137c:	03 77 10             	add    0x10(%rdi),%esi
    137f:	9f                   	lahf
    1380:	04 ba                	add    $0xba,%al
    1382:	0c d4                	or     $0xd4,%al
    1384:	0c 03                	or     $0x3,%al
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1386:	77 10                	ja     1398 <balancer_ingress+0x1398>
    1388:	9f                   	lahf
    1389:	00 04 de             	add    %al,(%rsi,%rbx,8)
    138c:	0a b6 0b 02 31 9f    	or     -0x60cefdf5(%rsi),%dh
    1392:	04 ba                	add    $0xba,%al
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1394:	0c d4                	or     $0xd4,%al
    1396:	0c 02                	or     $0x2,%al
    1398:	31 9f 00 04 f2 0a    	xor    %ebx,0xaf20400(%rdi)
    139e:	8a 0b                	mov    (%rbx),%cl
    13a0:	02 30                	add    (%rax),%dh
    13a2:	9f                   	lahf
    13a3:	04 8a                	add    $0x8a,%al
  data = (void*)(long)xdp->data;
    13a5:	0b 8f 0b 01 5e 00    	or     0x5e010b(%rdi),%ecx
  data_end = (void*)(long)xdp->data_end;
    13ab:	04 fc                	add    $0xfc,%al
  iph = data + sizeof(struct ethhdr);
    13ad:	0a 87 0b 01 55 00    	or     0x55010b(%rdi),%al
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    13b3:	04 84                	add    $0x84,%al
    13b5:	0b 8f 0b 04 77 c0    	or     -0x3f88fbf5(%rdi),%ecx
    13bb:	00 9f 00 04 8a 0b    	add    %bl,0xb8a0400(%rdi)
    13c1:	b6 0b                	mov    $0xb,%dh
    13c3:	01 5e 04             	add    %ebx,0x4(%rsi)
    13c6:	ba 0c d4 0c 01       	mov    $0x10cd40c,%edx
    13cb:	5e                   	pop    %rsi
    13cc:	00 04 8f             	add    %al,(%rdi,%rcx,4)
    13cf:	0b a0 0b 02 30 9f    	or     -0x60cffdf5(%rax),%esp
    13d5:	04 a0                	add    $0xa0,%al
    13d7:	0b a9 0b 01 50 00    	or     0x50010b(%rcx),%ebp
    13dd:	04 a9                	add    $0xa9,%al
    13df:	0b b6 0b 01 50 00    	or     0x50010b(%rsi),%esi
    13e5:	04 dd                	add    $0xdd,%al
    13e7:	0b f6                	or     %esi,%esi
  memcpy(new_eth->h_dest, cval->mac, 6);
    13e9:	0c 01                	or     $0x1,%al
    13eb:	5f                   	pop    %rdi
    13ec:	00 04 97             	add    %al,(%rdi,%rdx,4)
    13ef:	0c f6                	or     $0xf6,%al
    13f1:	0c 04                	or     $0x4,%al
    13f3:	10 8a 04 9f 00 04    	adc    %cl,0x4009f04(%rdx)
    13f9:	97                   	xchg   %eax,%edi
    13fa:	0c a8                	or     $0xa8,%al
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    13fc:	0c 02                	or     $0x2,%al
    13fe:	30 9f 04 a8 0c b1    	xor    %bl,-0x4ef357fc(%rdi)
    1404:	0c 01                	or     $0x1,%al
    1406:	52                   	push   %rdx
    1407:	00 04 b1             	add    %al,(%rcx,%rsi,4)
  new_eth->h_proto = BE_ETH_P_IP;
    140a:	0c f6                	or     $0xf6,%al
    140c:	0c 01                	or     $0x1,%al
    140e:	52                   	push   %rdx
    140f:	00 04 dd 0c e4 0c 02 	add    %al,0x20ce40c(,%rbx,8)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1416:	30 9f 04 e4 0c ed    	xor    %bl,-0x12f31bfc(%rdi)
  iph->tos = tos;
    141c:	0c 01                	or     $0x1,%al
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    141e:	50                   	push   %rax
    141f:	00 04 ed 0c f6 0c 01 	add    %al,0x10cf60c(,%rbp,8)
    1426:	50                   	push   %rax
    1427:	00 04 80             	add    %al,(%rax,%rax,4)
  iph->id = 0;
    142a:	0d d8 0d 02 31       	or     $0x31020dd8,%eax
    142f:	9f                   	lahf
  iph->daddr = daddr;
    1430:	04 d8                	add    $0xd8,%al
    1432:	0d b0 0f 02 30       	or     $0x30020fb0,%eax
  iph->ttl = DEFAULT_TTL;
    1437:	9f                   	lahf
    1438:	00 04 80             	add    %al,(%rax,%rax,4)
    143b:	0d d8 0d 03 77       	or     $0x77030dd8,%eax
    1440:	10 9f 04 ef 0e 89    	adc    %bl,-0x76f110fc(%rdi)
    1446:	0f 03 77 10          	lsl    0x10(%rdi),%esi
    144a:	9f                   	lahf
    144b:	00 04 80             	add    %al,(%rax,%rax,4)
    144e:	0d d8 0d 02 31       	or     $0x31020dd8,%eax
    1453:	9f                   	lahf
    1454:	04 ef                	add    $0xef,%al
    1456:	0e                   	(bad)
    1457:	89 0f                	mov    %ecx,(%rdi)
      if (pckt.flow.proto == IPPROTO_TCP) {
    1459:	02 31                	add    (%rcx),%dh
    145b:	9f                   	lahf
    145c:	00 04 94             	add    %al,(%rsp,%rdx,4)
    145f:	0d ac 0d 02 30       	or     $0x30020dac,%eax
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1464:	9f                   	lahf
    1465:	04 ac                	add    $0xac,%al
    1467:	0d b1 0d 01 5e       	or     $0x5e010db1,%eax
    146c:	00 04 9e             	add    %al,(%rsi,%rbx,4)
    146f:	0d a9 0d 01 55       	or     $0x55010da9,%eax
    1474:	00 04 a6             	add    %al,(%rsi,%riz,4)
    1477:	0d b1 0d 04 77       	or     $0x77040db1,%eax
        if (!lru_stats) {
    147c:	c0 00 9f             	rolb   $0x9f,(%rax)
    147f:	00 04 ac             	add    %al,(%rsp,%rbp,4)
    1482:	0d d8 0d 01 5e       	or     $0x5e010dd8,%eax
        if (pckt.flags & F_SYN_SET) {
    1487:	04 ef                	add    $0xef,%al
    1489:	0e                   	(bad)
    148a:	89 0f                	mov    %ecx,(%rdi)
    148c:	01 5e 00             	add    %ebx,0x0(%rsi)
    148f:	04 b1                	add    $0xb1,%al
    1491:	0d c2 0d 02 30       	or     $0x30020dc2,%eax
  struct real_pos_lru new_dst_lru = {};
    1496:	9f                   	lahf
    1497:	04 c2                	add    $0xc2,%al
    1499:	0d cb 0d 01 50       	or     $0x50010dcb,%eax
    149e:	00 04 cb             	add    %al,(%rbx,%rcx,8)
    14a1:	0d d8 0d 01 50       	or     $0x50010dd8,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    14a6:	00 04 f3             	add    %al,(%rbx,%rsi,8)
    14a9:	0d f6 0d 01 52       	or     $0x52010df6,%eax
    14ae:	00 04 92             	add    %al,(%rdx,%rdx,4)
    14b1:	0e                   	(bad)
    14b2:	b0 0f                	mov    $0xf,%al
    14b4:	01 5f 00             	add    %ebx,0x0(%rdi)
    14b7:	04 cc                	add    $0xcc,%al
    14b9:	0e                   	(bad)
    14ba:	b0 0f                	mov    $0xf,%al
    14bc:	04 10                	add    $0x10,%al
    14be:	8a 04 9f             	mov    (%rdi,%rbx,4),%al
    14c1:	00 04 cc             	add    %al,(%rsp,%rcx,8)
  if (!conn_rate_stats) {
    14c4:	0e                   	(bad)
    14c5:	dd 0e                	fisttpll (%rsi)
    14c7:	02 30                	add    (%rax),%dh
    14c9:	9f                   	lahf
    14ca:	04 dd                	add    $0xdd,%al
    14cc:	0e                   	(bad)
    14cd:	e6 0e                	out    %al,$0xe
  *cur_time = bpf_ktime_get_ns();
    14cf:	01 52 00             	add    %edx,0x0(%rdx)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    14d2:	04 e6                	add    $0xe6,%al
    14d4:	0e                   	(bad)
    14d5:	b0 0f                	mov    $0xf,%al
    14d7:	01 52 00             	add    %edx,0x0(%rdx)
    14da:	04 92                	add    $0x92,%al
    14dc:	0f 99 0f             	setns  (%rdi)
    14df:	02 30                	add    (%rax),%dh
    conn_rate_stats->v1 = 1;
    14e1:	9f                   	lahf
    14e2:	04 99                	add    $0x99,%al
    14e4:	0f a2                	cpuid
    14e6:	0f 01 50 00          	lgdt   0x0(%rax)
    conn_rate_stats->v2 = *cur_time;
    14ea:	04 a2                	add    $0xa2,%al
    14ec:	0f b0 0f             	cmpxchg %cl,(%rdi)
    14ef:	01 50 00             	add    %edx,0x0(%rax)
    conn_rate_stats->v1 += 1;
    14f2:	04 ba                	add    $0xba,%al
    14f4:	0f c7 0f             	cmpxchg8b (%rdi)
    14f7:	01 50 00             	add    %edx,0x0(%rax)
    14fa:	04 ec                	add    $0xec,%al
    14fc:	0f fd 0f             	paddw  (%rdi),%mm1
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    14ff:	02 30                	add    (%rax),%dh
    1501:	9f                   	lahf
    1502:	04 fd                	add    $0xfd,%al
    1504:	0f 86 10 01 52 00    	jbe    52161a <_license+0x51f1ed>
    150a:	04 86                	add    $0x86,%al
    150c:	10 9e 10 01 52 00    	adc    %bl,0x520110(%rsi)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1512:	04 9e                	add    $0x9e,%al
    1514:	10 ab 10 03 73 3e    	adc    %ch,0x3e730310(%rbx)
    151a:	9f                   	lahf
    151b:	04 ab                	add    $0xab,%al
    151d:	10 ad 10 01 50 00    	adc    %ch,0x500110(%rbp)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1523:	04 91                	add    $0x91,%al
    1525:	11 ac 11 02 30 9f 04 	adc    %ebp,0x49f3002(%rcx,%rdx,1)
      memset(pckt->flow.srcv6, 0, 16);
    152c:	ac                   	lods   %ds:(%rsi),%al
    152d:	11 b5 11 01 55 00    	adc    %esi,0x550111(%rbp)
    1533:	04 9b                	add    $0x9b,%al
    1535:	11 b5 11 01 5e 00    	adc    %esi,0x5e0111(%rbp)
    153b:	04 ac                	add    $0xac,%al
    153d:	11 cc                	adc    %ecx,%esp
    153f:	12 01                	adc    (%rcx),%al
    1541:	55                   	push   %rbp
    1542:	04 bc                	add    $0xbc,%al
  b += initval;
    1544:	13 ce                	adc    %esi,%ecx
    1546:	13 01                	adc    (%rcx),%eax
  __jhash_final(a, b, c);
    1548:	55                   	push   %rbp
    1549:	04 d1                	add    $0xd1,%al
    154b:	13 e6                	adc    %esi,%esp
    154d:	13 01                	adc    (%rcx),%eax
    154f:	50                   	push   %rax
  return (word << shift) | (word >> ((-shift) & 31));
    1550:	04 e6                	add    $0xe6,%al
    1552:	13 f2                	adc    %edx,%esi
    1554:	13 01                	adc    (%rcx),%eax
  __jhash_final(a, b, c);
    1556:	55                   	push   %rbp
    1557:	04 b6                	add    $0xb6,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1559:	1c ce                	sbb    $0xce,%al
    155b:	1d 01 55 04 8e       	sbb    $0x8e045501,%eax
  __jhash_final(a, b, c);
    1560:	1e                   	(bad)
    1561:	c2 1e 01             	ret    $0x11e
  return (word << shift) | (word >> ((-shift) & 31));
    1564:	55                   	push   %rbp
    1565:	04 ec                	add    $0xec,%al
  __jhash_final(a, b, c);
    1567:	20 c9                	and    %cl,%cl
    1569:	21 01                	and    %eax,(%rcx)
  return (word << shift) | (word >> ((-shift) & 31));
    156b:	55                   	push   %rbp
    156c:	04 8c                	add    $0x8c,%al
    156e:	23 e5                	and    %ebp,%esp
  __jhash_final(a, b, c);
    1570:	23 01                	and    (%rcx),%eax
    1572:	55                   	push   %rbp
    1573:	04 95                	add    $0x95,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1575:	2e fb                	cs sti
    1577:	2e 01 55 04          	cs add %edx,0x4(%rbp)
  __jhash_final(a, b, c);
    157b:	f5                   	cmc
    157c:	30 cf                	xor    %cl,%bh
  return (word << shift) | (word >> ((-shift) & 31));
    157e:	31 01                	xor    %eax,(%rcx)
  __jhash_final(a, b, c);
    1580:	55                   	push   %rbp
    1581:	04 fb                	add    $0xfb,%al
    1583:	31 b5 32 01 55 04    	xor    %esi,0x4550132(%rbp)
    1589:	b5 32                	mov    $0x32,%ch
    158b:	fd                   	std
    158c:	32 03                	xor    (%rbx),%al
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    158e:	77 d0                	ja     1560 <balancer_ingress+0x1560>
    1590:	00 04 fd 32 81 33 01 	add    %al,0x1338132(,%rdi,8)
    1597:	55                   	push   %rbp
    1598:	04 81                	add    $0x81,%al
    159a:	33 b9 33 03 77 d0    	xor    -0x2f88fccd(%rcx),%edi
    15a0:	00 04 b9             	add    %al,(%rcx,%rdi,4)
    15a3:	33 ef                	xor    %edi,%ebp
    key = RING_SIZE * (vip_info->vip_num) + hash;
    15a5:	33 01                	xor    (%rcx),%eax
    15a7:	55                   	push   %rbp
    15a8:	04 ef                	add    $0xef,%al
    15aa:	33 bb 35 01 5c 00    	xor    0x5c0135(%rbx),%edi
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15b0:	04 c7                	add    $0xc7,%al
    15b2:	11 cc                	adc    %ecx,%esp
    15b4:	12 04 10             	adc    (%rax,%rdx,1),%al
    if (!real_pos) {
    15b7:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    15bb:	b6 1c                	mov    $0x1c,%dh
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15bd:	ce                   	(bad)
    15be:	1d 04 10 80 04       	sbb    $0x4801004,%eax
    15c3:	9f                   	lahf
    15c4:	04 8e                	add    $0x8e,%al
    15c6:	1e                   	(bad)
    15c7:	c2 1e 04             	ret    $0x41e
    key = *real_pos;
    15ca:	10 80 04 9f 04 ec    	adc    %al,-0x13fb60fc(%rax)
    15d0:	20 c9                	and    %cl,%cl
    if (key == 0) {
    15d2:	21 04 10             	and    %eax,(%rax,%rdx,1)
  pckt->real_index = key;
    15d5:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
  *real = bpf_map_lookup_elem(&reals, &key);
    15d9:	8c 23                	mov    %fs,(%rbx)
    15db:	e5 23                	in     $0x23,%eax
    15dd:	04 10                	add    $0x10,%al
  if (!(*real)) {
    15df:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    15e3:	95                   	xchg   %eax,%ebp
    15e4:	2e fb                	cs sti
    15e6:	2e 04 10             	cs add $0x10,%al
    15e9:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    15ed:	f5                   	cmc
    15ee:	30 aa 38 04 10 80    	xor    %ch,-0x7feffbc8(%rdx)
    15f4:	04 9f                	add    $0x9f,%al
    15f6:	04 a7                	add    $0xa7,%al
    15f8:	39 ba 3e 04 10 80    	cmp    %edi,-0x7feffbc2(%rdx)
  if (!ch_drop_stats) {
    15fe:	04 9f                	add    $0x9f,%al
    1600:	04 db                	add    $0xdb,%al
    1602:	3e b5 40             	ds mov $0x40,%ch
    1605:	04 10                	add    $0x10,%al
    1607:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    160b:	c2 40 ba             	ret    $0xba40
    160e:	42 04 10             	rex.X add $0x10,%al
    1611:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1615:	9b                   	fwait
    1616:	43 eb 43             	rex.XB jmp 165c <balancer_ingress+0x165c>
    1619:	04 10                	add    $0x10,%al
    161b:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    161f:	9d                   	popf
    1620:	45 c4                	rex.RB (bad)
  if (!ch_drop_stats) {
    1622:	46 04 10             	rex.RX add $0x10,%al
    1625:	80 04 9f 00          	addb   $0x0,(%rdi,%rbx,4)
    1629:	04 c7                	add    $0xc7,%al
    162b:	11 d8                	adc    %ebx,%eax
    162d:	11 02                	adc    %eax,(%rdx)
    162f:	30 9f 04 d8 11 e1    	xor    %bl,-0x1eee27fc(%rdi)
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1635:	11 01                	adc    %eax,(%rcx)
    1637:	5e                   	pop    %rsi
    1638:	00 04 e1             	add    %al,(%rcx,%riz,8)
    163b:	11 cc                	adc    %ecx,%esp
    163d:	12 01                	adc    (%rcx),%al
    163f:	5e                   	pop    %rsi
    1640:	04 b6                	add    $0xb6,%al
    1642:	1c ce                	sbb    $0xce,%al
    1644:	1d 01 5e 04 8e       	sbb    $0x8e045e01,%eax
    1649:	1e                   	(bad)
    164a:	c2 1e 01             	ret    $0x11e
    164d:	5e                   	pop    %rsi
    164e:	04 ec                	add    $0xec,%al
    1650:	20 c9                	and    %cl,%cl
    1652:	21 01                	and    %eax,(%rcx)
    1654:	5e                   	pop    %rsi
    1655:	04 8c                	add    $0x8c,%al
    1657:	23 e5                	and    %ebp,%esp
    1659:	23 01                	and    (%rcx),%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    165b:	5e                   	pop    %rsi
    165c:	04 95                	add    $0x95,%al
    165e:	2e fb                	cs sti
    1660:	2e 01 5e 04          	cs add %ebx,0x4(%rsi)
    1664:	f5                   	cmc
    1665:	30 c4                	xor    %al,%ah
    1667:	35 01 5e 04 e1       	xor    $0xe1045e01,%eax
  data = (void*)(long)xdp->data;
    166c:	35 84 36 01 52       	xor    $0x52013684,%eax
  data_end = (void*)(long)xdp->data_end;
    1671:	04 ac                	add    $0xac,%al
    1673:	36 ea                	ss (bad)
  ip6h = data + sizeof(struct ethhdr);
    1675:	36 01 52 04          	ss add %edx,0x4(%rdx)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1679:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    167a:	39 ba 3e 01 5e 04    	cmp    %edi,0x45e013e(%rdx)
    1680:	db 3e                	fstpt  (%rsi)
    1682:	ff                   	(bad)
    1683:	3e 01 5e 04          	ds add %ebx,0x4(%rsi)
    1687:	ff                   	(bad)
    1688:	3e 90                	ds nop
    168a:	3f                   	(bad)
    168b:	01 52 04             	add    %edx,0x4(%rdx)
    168e:	c2 40 ba             	ret    $0xba40
    1691:	42 01 5e 04          	rex.X add %ebx,0x4(%rsi)
    1695:	9b                   	fwait
    1696:	43 ac                	rex.XB lods %ds:(%rsi),%al
    1698:	43 01 5e 04          	rex.XB add %ebx,0x4(%r14)
    169c:	9d                   	popf
    169d:	45 d3 45 01          	rex.RB roll %cl,0x1(%r13)
    16a1:	5e                   	pop    %rsi
  memcpy(new_eth->h_dest, cval->mac, 6);
    16a2:	00 04 84             	add    %al,(%rsp,%rax,4)
    16a5:	12 8d 12 0c 10 b4    	adc    -0x4beff3ee(%rbp),%cl
    16ab:	a0 e5 9b fb ff ff ff 	movabs 0x1fffffffffb9be5,%al
    16b2:	ff 01 
    16b4:	9f                   	lahf
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    16b5:	04 8d                	add    $0x8d,%al
    16b7:	12 90 12 01 50 00    	adc    0x500112(%rax),%dl
    16bd:	04 90                	add    $0x90,%al
    16bf:	12 9b 12 0d 70 00    	adc    0x700d12(%rbx),%bl
  new_eth->h_proto = BE_ETH_P_IPV6;
    16c5:	a8 b5                	test   $0xb5,%al
    16c7:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
  saddr[3] = src ^ port;
    16ce:	00 9f 04 b6 1c b8    	add    %bl,-0x47e349fc(%rdi)
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    16d4:	1c 0d                	sbb    $0xd,%al
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    16d6:	70 00                	jo     16d8 <balancer_ingress+0x16d8>
    16d8:	a8 b5                	test   $0xb5,%al
    16da:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    16e1:	00 9f 00 04 90 12    	add    %bl,0x12900400(%rdi)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    16e7:	9b                   	fwait
    16e8:	12 0d 70 00 a8 b5    	adc    -0x4a57ff90(%rip),%cl        # ffffffffb5a8175e <server_id_map+0x36fc6c7e575e>
  ip6h->nexthdr = proto;
    16ee:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    16f5:	00 9f 04 b6 1c b8    	add    %bl,-0x47e349fc(%rdi)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    16fb:	1c 0d                	sbb    $0xd,%al
    16fd:	70 00                	jo     16ff <balancer_ingress+0x16ff>
    16ff:	a8 b5                	test   $0xb5,%al
    1701:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
    1708:	00 9f 00 04 90 12    	add    %bl,0x12900400(%rdi)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    170e:	9b                   	fwait
    170f:	12 02                	adc    (%rdx),%al
    1711:	30 9f 04 b6 1c ca    	xor    %bl,-0x35e349fc(%rdi)
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1717:	1c 02                	sbb    $0x2,%al
    1719:	30 9f 04 ca 1c cf    	xor    %bl,-0x30e335fc(%rdi)
    171f:	1c 01                	sbb    $0x1,%al
    1721:	50                   	push   %rax
    1722:	04 cf                	add    $0xcf,%al
    1724:	1c d8                	sbb    $0xd8,%al
    1726:	1c 02                	sbb    $0x2,%al
    1728:	77 08                	ja     1732 <balancer_ingress+0x1732>
    172a:	00 04 90             	add    %al,(%rax,%rdx,4)
    172d:	12 9b 12 02 3c 9f    	adc    -0x60c3fdee(%rbx),%bl
    1733:	04 b6                	add    $0xb6,%al
    1735:	1c d8                	sbb    $0xd8,%al
    1737:	1c 02                	sbb    $0x2,%al
    1739:	3c 9f                	cmp    $0x9f,%al
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    173b:	00 04 90             	add    %al,(%rax,%rdx,4)
    173e:	12 9b 12 04 10 80    	adc    -0x7feffbee(%rbx),%bl
    1744:	01 9f 04 b6 1c d8    	add    %ebx,-0x27e349fc(%rdi)
    174a:	1c 04                	sbb    $0x4,%al
    174c:	10 80 01 9f 00 04    	adc    %al,0x4009f01(%rax)
    1752:	90                   	nop
    1753:	12 9b 12 02 38 9f    	adc    -0x60c7fdee(%rbx),%bl
      if (qpr.server_id > 0) {
    1759:	04 b6                	add    $0xb6,%al
    175b:	1c d8                	sbb    $0xd8,%al
    175d:	1c 02                	sbb    $0x2,%al
    175f:	38 9f 00 04 9b 12    	cmp    %bl,0x129b0400(%rdi)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1765:	a2 12 02 30 9f 04 a2 	movabs %al,0xab12a2049f300212
    176c:	12 ab 
    176e:	12 01                	adc    (%rcx),%al
    1770:	50                   	push   %rax
    1771:	00 04 ab             	add    %al,(%rbx,%rbp,4)
    1774:	12 c2                	adc    %dl,%al
    1776:	12 01                	adc    (%rcx),%al
    1778:	50                   	push   %rax
    1779:	00 04 ca             	add    %al,(%rdx,%rcx,8)
    177c:	1c cf                	sbb    $0xcf,%al
    177e:	1c 01                	sbb    $0x1,%al
    1780:	50                   	push   %rax
    1781:	04 cf                	add    $0xcf,%al
    1783:	1c ce                	sbb    $0xce,%al
    if (pckt->flow.proto == IPPROTO_UDP) {
    1785:	1d 02 77 08 04       	sbb    $0x4087702,%eax
    178a:	8e 1e                	mov    (%rsi),%ds
      new_dst_lru.atime = cur_time;
    178c:	c2 1e 02             	ret    $0x21e
    178f:	77 08                	ja     1799 <balancer_ingress+0x1799>
    new_dst_lru.pos = key;
    1791:	04 ec                	add    $0xec,%al
    1793:	20 c9                	and    %cl,%cl
    1795:	21 02                	and    %eax,(%rdx)
    1797:	77 08                	ja     17a1 <balancer_ingress+0x17a1>
    1799:	04 8c                	add    $0x8c,%al
BPF_MAP_OPS_INLINE(int,
    179b:	23 e5                	and    %ebp,%esp
    179d:	23 02                	and    (%rdx),%eax
    179f:	77 08                	ja     17a9 <balancer_ingress+0x17a9>
    17a1:	04 95                	add    $0x95,%al
    17a3:	2e fb                	cs sti
    17a5:	2e 02 77 08          	cs add 0x8(%rdi),%dh
    17a9:	04 f5                	add    $0xf5,%al
    17ab:	30 cf                	xor    %cl,%bh
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    17ad:	31 02                	xor    %eax,(%rdx)
    17af:	77 08                	ja     17b9 <balancer_ingress+0x17b9>
    17b1:	04 cf                	add    $0xcf,%al
    17b3:	31 da                	xor    %ebx,%edx
    17b5:	31 01                	xor    %eax,(%rcx)
    17b7:	55                   	push   %rbp
    17b8:	04 da                	add    $0xda,%al
    17ba:	31 c0                	xor    %eax,%eax
    17bc:	32 02                	xor    (%rdx),%al
    17be:	77 08                	ja     17c8 <balancer_ingress+0x17c8>
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17c0:	04 c0                	add    $0xc0,%al
    17c2:	32 cb                	xor    %bl,%cl
    17c4:	32 01                	xor    (%rcx),%al
    17c6:	55                   	push   %rbp
    17c7:	04 cb                	add    $0xcb,%al
    17c9:	32 aa 38 02 77 08    	xor    0x8770238(%rdx),%ch
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17cf:	04 a7                	add    $0xa7,%al
    17d1:	39 ba 3e 02 77 08    	cmp    %edi,0x877023e(%rdx)
    17d7:	04 db                	add    $0xdb,%al
    17d9:	3e b5 40             	ds mov $0x40,%ch
  bool vip_match = address_match && port_match && proto_match;
    17dc:	02 77 08             	add    0x8(%rdi),%dh
    17df:	04 c2                	add    $0xc2,%al
    17e1:	40 d7                	rex xlat %ds:(%rbx)
    17e3:	40 02 77 08          	add    0x8(%rdi),%sil
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17e7:	04 d7                	add    $0xd7,%al
    17e9:	40 e9 40 01 55 04    	rex jmp 455192f <_license+0x454f502>
    17ef:	e9 40 ba 42 02       	jmp    242d234 <_license+0x242ae07>
    17f4:	77 08                	ja     17fe <balancer_ingress+0x17fe>
    17f6:	04 9b                	add    $0x9b,%al
    17f8:	43 eb 43             	rex.XB jmp 183e <balancer_ingress+0x183e>
    17fb:	02 77 08             	add    0x8(%rdi),%dh
    17fe:	04 9d                	add    $0x9d,%al
    1800:	45 84 46 02          	test   %r8b,0x2(%r14)
    1804:	77 08                	ja     180e <balancer_ingress+0x180e>
    1806:	04 84                	add    $0x84,%al
    1808:	46 96                	rex.RX xchg %eax,%esi
    180a:	46 01 55 04          	rex.RX add %r10d,0x4(%rbp)
    if (!lru_miss_stat) {
    180e:	96                   	xchg   %eax,%esi
    180f:	46 c4                	rex.RX (bad)
    1811:	46 02 77 08          	rex.RX add 0x8(%rdi),%r14b
    1815:	00 04 d2             	add    %al,(%rdx,%rdx,8)
    *lru_miss_stat += 1;
    1818:	12 e3                	adc    %bl,%ah
    181a:	12 02                	adc    (%rdx),%al
    181c:	30 9f 04 e3 12 ec    	xor    %bl,-0x13ed1cfc(%rdi)
    1822:	12 01                	adc    (%rcx),%al
    1824:	52                   	push   %rdx
    1825:	00 04 ec             	add    %al,(%rsp,%rbp,8)
    1828:	12 84 13 01 52 00 04 	adc    0x4005201(%rbx,%rdx,1),%al
    182f:	84 13                	test   %dl,(%rbx)
    1831:	91                   	xchg   %eax,%ecx
    1832:	13 03                	adc    (%rbx),%eax
    1834:	73 2a                	jae    1860 <balancer_ingress+0x1860>
    1836:	9f                   	lahf
    1837:	04 91                	add    $0x91,%al
      data_stats->v2 += 1;
    1839:	13 93 13 01 50 00    	adc    0x500113(%rbx),%edx
    183f:	04 c3                	add    $0xc3,%al
    1841:	13 d1                	adc    %ecx,%edx
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1843:	13 02                	adc    (%rdx),%eax
    1845:	30 9f 04 d1 13 da    	xor    %bl,-0x25ec2efc(%rdi)
    184b:	13 01                	adc    (%rcx),%eax
    184d:	50                   	push   %rax
    184e:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    1851:	13 cf                	adc    %edi,%ecx
    1853:	14 02                	adc    $0x2,%al
  if (!connId) {
    1855:	31 9f 04 d3 14 a1    	xor    %ebx,-0x5eeb2cfc(%rdi)
    185b:	16                   	(bad)
    185c:	02 30                	add    (%rax),%dh
    185e:	9f                   	lahf
    185f:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    1862:	13 cf                	adc    %edi,%ecx
    1864:	14 03                	adc    $0x3,%al
    1866:	77 10                	ja     1878 <balancer_ingress+0x1878>
    1868:	9f                   	lahf
    1869:	04 e9                	add    $0xe9,%al
    186b:	15 83 16 03 77       	adc    $0x77031683,%eax
    1870:	10 9f 00 04 f2 13    	adc    %bl,0x13f20400(%rdi)
    1876:	cf                   	iret
    1877:	14 02                	adc    $0x2,%al
    1879:	30 9f 04 e9 15 83    	xor    %bl,-0x7cea16fc(%rdi)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    187f:	16                   	(bad)
        if (real_pos) {
    1880:	02 30                	add    (%rax),%dh
    1882:	9f                   	lahf
    1883:	00 04 8b             	add    %al,(%rbx,%rcx,4)
    1886:	14 a3                	adc    $0xa3,%al
    1888:	14 02                	adc    $0x2,%al
    188a:	30 9f 04 a3 14 a8    	xor    %bl,-0x57eb5cfc(%rdi)
          key = *real_pos;
    1890:	14 01                	adc    $0x1,%al
    1892:	5e                   	pop    %rsi
    1893:	00 04 95 14 a0 14 01 	add    %al,0x114a014(,%rdx,4)
            pckt.real_index = key;
    189a:	55                   	push   %rbp
    189b:	00 04 9d 14 a8 14 04 	add    %al,0x414a814(,%rbx,4)
            dst = bpf_map_lookup_elem(&reals, &key);
    18a2:	77 c0                	ja     1864 <balancer_ingress+0x1864>
    18a4:	00 9f 00 04 a3 14    	add    %bl,0x14a30400(%rdi)
    18aa:	cf                   	iret
    18ab:	14 01                	adc    $0x1,%al
    18ad:	5e                   	pop    %rsi
    18ae:	04 e9                	add    $0xe9,%al
    18b0:	15 83 16 01 5e       	adc    $0x5e011683,%eax
    18b5:	00 04 a8             	add    %al,(%rax,%rbp,4)
    18b8:	14 b9                	adc    $0xb9,%al
    18ba:	14 02                	adc    $0x2,%al
    18bc:	30 9f 04 b9 14 c2    	xor    %bl,-0x3deb46fc(%rdi)
            if (!dst) {
    18c2:	14 01                	adc    $0x1,%al
    18c4:	50                   	push   %rax
    18c5:	00 04 c2             	add    %al,(%rdx,%rax,8)
    18c8:	14 cf                	adc    $0xcf,%al
    18ca:	14 01                	adc    $0x1,%al
    18cc:	50                   	push   %rax
    18cd:	00 04 ee             	add    %al,(%rsi,%rbp,8)
BPF_MAP_OPS_INLINE(void*,
    18d0:	14 f1                	adc    $0xf1,%al
    18d2:	14 01                	adc    $0x1,%al
    18d4:	51                   	push   %rcx
    18d5:	00 04 8d 15 a1 16 01 	add    %al,0x116a115(,%rcx,4)
  if (dst_lru) {
    18dc:	5f                   	pop    %rdi
    18dd:	00 04 8d 15 b4 15 01 	add    %al,0x115b415(,%rcx,4)
    if (dst_lru->pos == pckt->real_index) {
    18e4:	50                   	push   %rax
    18e5:	00 04 c6             	add    %al,(%rsi,%rax,8)
    18e8:	15 a1 16 04 10       	adc    $0x100416a1,%eax
    18ed:	8a 04 9f             	mov    (%rdi,%rbx,4),%al
              quic_packets_stats->dst_match_in_lru += 1;
    18f0:	00 04 c6             	add    %al,(%rsi,%rax,8)
    18f3:	15 d7 15 02 30       	adc    $0x300215d7,%eax
    18f8:	9f                   	lahf
    18f9:	04 d7                	add    $0xd7,%al
    18fb:	15 e0 15 01 52       	adc    $0x520115e0,%eax
    1900:	00 04 e0             	add    %al,(%rax,%riz,8)
    1903:	15 a1 16 01 52       	adc    $0x520116a1,%eax
    1908:	00 04 8c             	add    %al,(%rsp,%rcx,4)
    190b:	16                   	(bad)
    190c:	93                   	xchg   %eax,%ebx
    190d:	16                   	(bad)
    190e:	02 30                	add    (%rax),%dh
    1910:	9f                   	lahf
    1911:	04 93                	add    $0x93,%al
    1913:	16                   	(bad)
    1914:	9c                   	pushf
    1915:	16                   	(bad)
    1916:	01 50 00             	add    %edx,0x0(%rax)
  original_sport = pckt.flow.port16[0];
    1919:	04 9c                	add    $0x9c,%al
    191b:	16                   	(bad)
    191c:	a1 16 01 50 00 04 cc 	movabs 0xdd16cc0400500116,%eax
    1923:	16 dd 
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1925:	16                   	(bad)
    1926:	02 30                	add    (%rax),%dh
    1928:	9f                   	lahf
    1929:	04 dd                	add    $0xdd,%al
        !(vip_info->flags & F_LRU_BYPASS)) {
    192b:	16                   	(bad)
    192c:	e6 16                	out    %al,$0x16
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    192e:	01 50 00             	add    %edx,0x0(%rax)
    1931:	04 e6                	add    $0xe6,%al
    1933:	16                   	(bad)
    1934:	85 17                	test   %edx,(%rdi)
    1936:	01 50 00             	add    %edx,0x0(%rax)
    1939:	04 f8                	add    $0xf8,%al
    193b:	16                   	(bad)
    193c:	85 17                	test   %edx,(%rdi)
    193e:	01 52 00             	add    %edx,0x0(%rdx)
    1941:	04 85                	add    $0x85,%al
    1943:	17                   	(bad)
    1944:	c4                   	(bad)
    1945:	17                   	(bad)
    1946:	03 73 2a             	add    0x2a(%rbx),%esi
    1949:	9f                   	lahf
    194a:	00 04 e5 17 c2 18 02 	add    %al,0x218c217(,%riz,8)
    1951:	31 9f 04 c2 18 99    	xor    %ebx,-0x66e73dfc(%rdi)
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1957:	1a 02                	sbb    (%rdx),%al
    1959:	30 9f 00 04 e5 17    	xor    %bl,0x17e50400(%rdi)
    195f:	c2 18 03             	ret    $0x318
    cur_time = bpf_ktime_get_ns();
    1962:	77 10                	ja     1974 <balancer_ingress+0x1974>
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1964:	9f                   	lahf
    1965:	04 d8                	add    $0xd8,%al
    1967:	19 f2                	sbb    %esi,%edx
    1969:	19 03                	sbb    %eax,(%rbx)
    196b:	77 10                	ja     197d <balancer_ingress+0x197d>
    196d:	9f                   	lahf
    196e:	00 04 e5 17 c2 18 02 	add    %al,0x218c217(,%riz,8)
    1975:	30 9f 04 d8 19 f2    	xor    %bl,-0xde627fc(%rdi)
    197b:	19 02                	sbb    %eax,(%rdx)
    197d:	30 9f 00 04 fe 17    	xor    %bl,0x17fe0400(%rdi)
    dst_lru->atime = cur_time;
    1983:	96                   	xchg   %eax,%esi
    1984:	18 02                	sbb    %al,(%rdx)
  key = dst_lru->pos;
    1986:	30 9f 04 96 18 9b    	xor    %bl,-0x64e769fc(%rdi)
    198c:	18 01                	sbb    %al,(%rcx)
    198e:	5e                   	pop    %rsi
    198f:	00 04 88             	add    %al,(%rax,%rcx,4)
  pckt->real_index = key;
    1992:	18 93 18 01 55 00    	sbb    %dl,0x550118(%rbx)
    1998:	04 90                	add    $0x90,%al
    199a:	18 9b 18 04 77 c0    	sbb    %bl,-0x3f88fbe8(%rbx)
    19a0:	00 9f 00 04 96 18    	add    %bl,0x18960400(%rdi)
  *real = bpf_map_lookup_elem(&reals, &key);
    19a6:	c2 18 01             	ret    $0x118
    19a9:	5e                   	pop    %rsi
    19aa:	04 d8                	add    $0xd8,%al
    19ac:	19 f2                	sbb    %esi,%edx
    19ae:	19 01                	sbb    %eax,(%rcx)
    19b0:	5e                   	pop    %rsi
    19b1:	00 04 9b             	add    %al,(%rbx,%rbx,4)
    19b4:	18 ac 18 02 30 9f 04 	sbb    %ch,0x49f3002(%rax,%rbx,1)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    19bb:	ac                   	lods   %ds:(%rsi),%al
    19bc:	18 b5 18 01 50 00    	sbb    %dh,0x500118(%rbp)
    19c2:	04 b5                	add    $0xb5,%al
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    19c4:	18 c2                	sbb    %al,%dl
    19c6:	18 01                	sbb    %al,(%rcx)
    19c8:	50                   	push   %rax
    19c9:	00 04 fb             	add    %al,(%rbx,%rdi,8)
    19cc:	18 99 1a 01 5f 00    	sbb    %bl,0x5f011a(%rcx)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    19d2:	04 b5                	add    $0xb5,%al
    19d4:	19 99 1a 04 10 8a    	sbb    %ebx,-0x75effbe6(%rcx)
    19da:	04 9f                	add    $0x9f,%al
    19dc:	00 04 b5 19 c6 19 02 	add    %al,0x219c619(,%rsi,4)
  if (!conn_rate_stats) {
    19e3:	30 9f 04 c6 19 cf    	xor    %bl,-0x30e639fc(%rdi)
    19e9:	19 01                	sbb    %eax,(%rcx)
    19eb:	52                   	push   %rdx
    19ec:	00 04 cf             	add    %al,(%rdi,%rcx,8)
    19ef:	19 99 1a 01 52 00    	sbb    %ebx,0x52011a(%rcx)
    19f5:	04 fb                	add    $0xfb,%al
    19f7:	19 82 1a 02 30 9f    	sbb    %eax,-0x60cffde6(%rdx)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    19fd:	04 82                	add    $0x82,%al
    19ff:	1a 8b 1a 01 50 00    	sbb    0x50011a(%rbx),%cl
    1a05:	04 8b                	add    $0x8b,%al
    1a07:	1a 99 1a 01 50 00    	sbb    0x50011a(%rcx),%bl
    conn_rate_stats->v1 = 1;
    1a0d:	04 a3                	add    $0xa3,%al
    1a0f:	1a b0 1a 01 50 00    	sbb    0x50011a(%rax),%dh
    conn_rate_stats->v2 = *cur_time;
    1a15:	04 fb                	add    $0xfb,%al
    1a17:	1a 96 1b 02 30 9f    	sbb    -0x60cffde5(%rsi),%dl
    conn_rate_stats->v1 += 1;
    1a1d:	04 96                	add    $0x96,%al
    1a1f:	1b 9f 1b 01 55 00    	sbb    0x55011b(%rdi),%ebx
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1a25:	04 85                	add    $0x85,%al
    1a27:	1b 9f 1b 01 5f 00    	sbb    0x5f011b(%rdi),%ebx
    1a2d:	04 96                	add    $0x96,%al
    1a2f:	1b b6 1c 01 55 04    	sbb    0x455011c(%rsi),%esi
    1a35:	ce                   	(bad)
    1a36:	1d e0 1d 01 55       	sbb    $0x55011de0,%eax
    1a3b:	04 e3                	add    $0xe3,%al
    1a3d:	1d f8 1d 01 50       	sbb    $0x50011df8,%eax
    1a42:	04 f8                	add    $0xf8,%al
    1a44:	1d 84 1e 01 55       	sbb    $0x55011e84,%eax
    1a49:	04 c2                	add    $0xc2,%al
    1a4b:	1e                   	(bad)
    1a4c:	f4                   	hlt
    1a4d:	1e                   	(bad)
    1a4e:	01 55 04             	add    %edx,0x4(%rbp)
    1a51:	f4                   	hlt
    1a52:	1e                   	(bad)
    1a53:	fa                   	cli
    1a54:	1e                   	(bad)
    1a55:	02 77 08             	add    0x8(%rdi),%dh
    1a58:	04 fa                	add    $0xfa,%al
    1a5a:	1e                   	(bad)
    1a5b:	c3                   	ret
    1a5c:	1f                   	(bad)
    1a5d:	01 55 04             	add    %edx,0x4(%rbp)
    1a60:	c5 1f f9             	(bad)
    1a63:	1f                   	(bad)
    1a64:	01 55 04             	add    %edx,0x4(%rbp)
    1a67:	fb                   	sti
    1a68:	1f                   	(bad)
    1a69:	9b                   	fwait
    1a6a:	20 01                	and    %al,(%rcx)
    if (down_reals_map) {
    1a6c:	55                   	push   %rbp
    1a6d:	04 ab                	add    $0xab,%al
    1a6f:	20 dc                	and    %bl,%ah
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1a71:	20 02                	and    %al,(%rdx)
    1a73:	77 08                	ja     1a7d <balancer_ingress+0x1a7d>
    1a75:	04 c9                	add    $0xc9,%al
    1a77:	21 d5                	and    %edx,%ebp
    1a79:	22 01                	and    (%rcx),%al
    1a7b:	55                   	push   %rbp
    1a7c:	04 db                	add    $0xdb,%al
    1a7e:	22 8c 23 01 55 04 e5 	and    -0x1afbaaff(%rbx,%riz,1),%cl
    1a85:	23 98 24 02 77 08    	and    0x8770224(%rax),%ebx
    1a8b:	04 98                	add    $0x98,%al
    1a8d:	24 d9                	and    $0xd9,%al
    1a8f:	24 01                	and    $0x1,%al
    1a91:	55                   	push   %rbp
    1a92:	04 d9                	add    $0xd9,%al
      if (down_real) {
    1a94:	24 8e                	and    $0x8e,%al
    1a96:	2a 02                	sub    (%rdx),%al
    1a98:	77 08                	ja     1aa2 <balancer_ingress+0x1aa2>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1a9a:	04 8e                	add    $0x8e,%al
    1a9c:	2a a3 2a 01 52 04    	sub    0x452012a(%rbx),%ah
    1aa2:	a3 2a a4 2b 02 77 08 	movabs %eax,0xa4040877022ba42a
    1aa9:	04 a4 
        if (stats_data) {
    1aab:	2b a9 2b 01 51 04    	sub    0x451012b(%rcx),%ebp
    1ab1:	a9 2b bd 2c 02       	test   $0x22cbd2b,%eax
          stats_data->v1 += 1;
    1ab6:	77 08                	ja     1ac0 <balancer_ingress+0x1ac0>
    1ab8:	04 bd                	add    $0xbd,%al
    1aba:	2c bf                	sub    $0xbf,%al
    if (!dst) {
    1abc:	2c 01                	sub    $0x1,%al
    1abe:	52                   	push   %rdx
    1abf:	04 bf                	add    $0xbf,%al
    1ac1:	2c 95                	sub    $0x95,%al
    1ac3:	2e 02 77 08          	cs add 0x8(%rdi),%dh
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1ac7:	04 85                	add    $0x85,%al
    1ac9:	2f                   	(bad)
    1aca:	c3                   	ret
    1acb:	30 02                	xor    %al,(%rdx)
    1acd:	77 08                	ja     1ad7 <balancer_ingress+0x1ad7>
    1acf:	04 c3                	add    $0xc3,%al
    1ad1:	30 e2                	xor    %ah,%dl
    1ad3:	30 01                	xor    %al,(%rcx)
    1ad5:	55                   	push   %rbp
    1ad6:	04 ba                	add    $0xba,%al
    1ad8:	42 94                	rex.X xchg %eax,%esp
    1ada:	43 01 55 04          	rex.XB add %edx,0x4(%r13)
    1ade:	fe 43 d2             	incb   -0x2e(%rbx)
  if (!data_stats) {
    1ae1:	44 01 55 04          	add    %r10d,0x4(%rbp)
    1ae5:	e6 44                	out    %al,$0x44
    1ae7:	fe 44 02 77          	incb   0x77(%rdx,%rax,1)
    1aeb:	08 04 fe             	or     %al,(%rsi,%rdi,8)
    1aee:	44 8e 45 01          	rex.R mov 0x1(%rbp),%es
  data_stats->v1 += 1;
    1af2:	55                   	push   %rbp
    1af3:	04 c4                	add    $0xc4,%al
    1af5:	46 ad                	rex.RX lods %ds:(%rsi),%eax
    1af7:	48 02 77 08          	rex.W add 0x8(%rdi),%sil
  data_stats->v2 += pkt_bytes;
    1afb:	00 04 b1             	add    %al,(%rcx,%rsi,4)
    1afe:	1b b6 1c 04 10 80    	sbb    -0x7feffbe4(%rsi),%esi
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1b04:	04 9f                	add    $0x9f,%al
    1b06:	04 c2                	add    $0xc2,%al
    1b08:	1e                   	(bad)
    1b09:	dc 20                	fsubl  (%rax)
    1b0b:	04 10                	add    $0x10,%al
    1b0d:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1b11:	c9                   	leave
    1b12:	21 8c 23 04 10 80 04 	and    %ecx,0x4801004(%rbx,%riz,1)
    1b19:	9f                   	lahf
    1b1a:	04 e5                	add    $0xe5,%al
    1b1c:	23 95 2e 04 10 80    	and    -0x7feffbd2(%rbp),%edx
    1b22:	04 9f                	add    $0x9f,%al
    1b24:	04 85                	add    $0x85,%al
    1b26:	2f                   	(bad)
    1b27:	e2 30                	loop   1b59 <balancer_ingress+0x1b59>
    1b29:	04 10                	add    $0x10,%al
    1b2b:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
  if (!data_stats) {
    1b2f:	ba 42 94 43 04       	mov    $0x4439442,%edx
    1b34:	10 80 04 9f 04 fe    	adc    %al,-0x1fb60fc(%rax)
  data_stats->v2 += pkt_bytes;
    1b3a:	43 93                	rex.XB xchg %eax,%r11d
    1b3c:	45 04 10             	rex.RB add $0x10,%al
    1b3f:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1b43:	c4                   	(bad)
  pckt.flow.port16[0] = original_sport;
    1b44:	46 ad                	rex.RX lods %ds:(%rsi),%eax
    1b46:	48 04 10             	rex.W add $0x10,%al
  if (dst->flags & F_IPV6) {
    1b49:	80 04 9f 00          	addb   $0x0,(%rdi,%rbx,4)
    1b4d:	04 b1                	add    $0xb1,%al
    1b4f:	1b c2                	sbb    %edx,%eax
    1b51:	1b 02                	sbb    (%rdx),%eax
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1b53:	30 9f 04 c2 1b cb    	xor    %bl,-0x34e43dfc(%rdi)
    1b59:	1b 01                	sbb    (%rcx),%eax
    1b5b:	5f                   	pop    %rdi
    1b5c:	00 04 cb             	add    %al,(%rbx,%rcx,8)
    1b5f:	1b b6 1c 01 5f 04    	sbb    0x45f011c(%rsi),%esi
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1b65:	c2 1e dc             	ret    $0xdc1e
    1b68:	20 01                	and    %al,(%rcx)
    1b6a:	5f                   	pop    %rdi
    1b6b:	04 c9                	add    $0xc9,%al
    1b6d:	21 8c 23 01 5f 04 e5 	and    %ecx,-0x1afba0ff(%rbx,%riz,1)
  data = (void*)(long)xdp->data;
    1b74:	23 99 26 01 5f 04    	and    0x45f0126(%rcx),%ebx
  iph = data + sizeof(struct ethhdr);
    1b7a:	99                   	cltd
    1b7b:	26 bc 26 01 52 04    	es mov $0x4520126,%esp
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1b81:	e4 26                	in     $0x26,%al
    1b83:	9d                   	popf
    1b84:	27                   	(bad)
    1b85:	01 52 04             	add    %edx,0x4(%rdx)
    1b88:	d9 28                	fldcw  (%rax)
    1b8a:	d3 2c 01             	shrl   %cl,(%rcx,%rax,1)
    1b8d:	5f                   	pop    %rdi
    1b8e:	04 d3                	add    $0xd3,%al
    1b90:	2c e4                	sub    $0xe4,%al
    1b92:	2c 01                	sub    $0x1,%al
    1b94:	52                   	push   %rdx
    1b95:	04 85                	add    $0x85,%al
    1b97:	2f                   	(bad)
    1b98:	e2 30                	loop   1bca <balancer_ingress+0x1bca>
    1b9a:	01 5f 04             	add    %ebx,0x4(%rdi)
    1b9d:	ba 42 94 43 01       	mov    $0x1439442,%edx
    1ba2:	5f                   	pop    %rdi
    1ba3:	04 fe                	add    $0xfe,%al
    1ba5:	43 93                	rex.XB xchg %eax,%r11d
    1ba7:	45 01 5f 04          	add    %r11d,0x4(%r15)
    1bab:	c4                   	(bad)
    1bac:	46 ad                	rex.RX lods %ds:(%rsi),%eax
    1bae:	48 01 5f 00          	add    %rbx,0x0(%rdi)
    1bb2:	04 ee                	add    $0xee,%al
    1bb4:	1b f7                	sbb    %edi,%esi
    1bb6:	1b 0c 10             	sbb    (%rax,%rdx,1),%ecx
    1bb9:	b4 a0                	mov    $0xa0,%ah
    1bbb:	e5 9b                	in     $0x9b,%eax
  memcpy(new_eth->h_dest, cval->mac, 6);
    1bbd:	fb                   	sti
    1bbe:	ff                   	(bad)
    1bbf:	ff                   	(bad)
    1bc0:	ff                   	(bad)
    1bc1:	ff 01                	incl   (%rcx)
    1bc3:	9f                   	lahf
    1bc4:	04 f7                	add    $0xf7,%al
    1bc6:	1b fa                	sbb    %edx,%edi
    1bc8:	1b 01                	sbb    (%rcx),%eax
    1bca:	50                   	push   %rax
    1bcb:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    1bce:	1b 85 1c 0d 70 00    	sbb    0x700d1c(%rbp),%eax
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1bd4:	a8 b5                	test   $0xb5,%al
    1bd6:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    1bdd:	00 9f 04 c2 1e c4    	add    %bl,-0x3be13dfc(%rdi)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1be3:	1e                   	(bad)
    1be4:	0d 70 00 a8 b5       	or     $0xb5a80070,%eax
  iph->ihl = 5;
    1be9:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1bf0:	00 9f 00 04 fa 1b    	add    %bl,0x1bfa0400(%rdi)
    1bf6:	85 1c 0d 70 00 a8 b5 	test   %ebx,-0x4a57ff90(,%rcx,1)
    1bfd:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
  iph->id = 0;
    1c04:	00 9f 04 c2 1e c4    	add    %bl,-0x3be13dfc(%rdi)
  iph->saddr = saddr;
    1c0a:	1e                   	(bad)
  iph->ttl = DEFAULT_TTL;
    1c0b:	0d 70 00 a8 b5       	or     $0xb5a80070,%eax
    1c10:	80 80 00 a8 b0 80 80 	addb   $0x80,-0x7f4f5800(%rax)
    1c17:	00 9f 00 04 fa 1b    	add    %bl,0x1bfa0400(%rdi)
    1c1d:	85 1c 02             	test   %ebx,(%rdx,%rax,1)
    1c20:	30 9f 04 c2 1e d6    	xor    %bl,-0x29e13dfc(%rdi)
    1c26:	1e                   	(bad)
    1c27:	02 30                	add    (%rax),%dh
    1c29:	9f                   	lahf
    1c2a:	04 d6                	add    $0xd6,%al
    1c2c:	1e                   	(bad)
    1c2d:	db 1e                	fistpl (%rsi)
    1c2f:	01 50 04             	add    %edx,0x4(%rax)
    1c32:	db 1e                	fistpl (%rsi)
    1c34:	e4 1e                	in     $0x1e,%al
    1c36:	03 77 d0             	add    -0x30(%rdi),%esi
    1c39:	00 00                	add    %al,(%rax)
    1c3b:	04 fa                	add    $0xfa,%al
    1c3d:	1b 85 1c 02 3c 9f    	sbb    -0x60c3fde4(%rbp),%eax
    1c43:	04 c2                	add    $0xc2,%al
    1c45:	1e                   	(bad)
    1c46:	e4 1e                	in     $0x1e,%al
    1c48:	02 3c 9f             	add    (%rdi,%rbx,4),%bh
    1c4b:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    1c4e:	1b 85 1c 04 10 80    	sbb    -0x7feffbe4(%rbp),%eax
    1c54:	01 9f 04 c2 1e e4    	add    %ebx,-0x1be13dfc(%rdi)
    1c5a:	1e                   	(bad)
    1c5b:	04 10                	add    $0x10,%al
    1c5d:	80 01 9f             	addb   $0x9f,(%rcx)
    1c60:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    1c63:	1b 85 1c 02 38 9f    	sbb    -0x60c7fde4(%rbp),%eax
    1c69:	04 c2                	add    $0xc2,%al
    1c6b:	1e                   	(bad)
    1c6c:	e4 1e                	in     $0x1e,%al
    1c6e:	02 38                	add    (%rax),%bh
    1c70:	9f                   	lahf
    1c71:	00 04 85 1c 8c 1c 02 	add    %al,0x21c8c1c(,%rax,4)
    1c78:	30 9f 04 8c 1c 95    	xor    %bl,-0x6ae373fc(%rdi)
    1c7e:	1c 01                	sbb    $0x1,%al
    1c80:	50                   	push   %rax
    1c81:	00 04 95 1c ac 1c 01 	add    %al,0x11cac1c(,%rdx,4)
    1c88:	50                   	push   %rax
    1c89:	00 04 d6             	add    %al,(%rsi,%rdx,8)
    1c8c:	1e                   	(bad)
    1c8d:	db 1e                	fistpl (%rsi)
    1c8f:	01 50 04             	add    %edx,0x4(%rax)
    1c92:	db 1e                	fistpl (%rsi)
    1c94:	9b                   	fwait
    1c95:	20 03                	and    %al,(%rbx)
    1c97:	77 d0                	ja     1c69 <balancer_ingress+0x1c69>
    1c99:	00 04 9b             	add    %al,(%rbx,%rbx,4)
    1c9c:	20 a6 20 01 55 04    	and    %ah,0x4550120(%rsi)
    1ca2:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1ca3:	20 dc                	and    %bl,%ah
    1ca5:	20 03                	and    %al,(%rbx)
      if (pckt.flow.proto == IPPROTO_TCP) {
    1ca7:	77 d0                	ja     1c79 <balancer_ingress+0x1c79>
    1ca9:	00 04 c9             	add    %al,(%rcx,%rcx,8)
    1cac:	21 8c 23 03 77 d0 00 	and    %ecx,0xd07703(%rbx,%riz,1)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1cb3:	04 e5                	add    $0xe5,%al
    1cb5:	23 95 2e 03 77 d0    	and    -0x2f88fcd2(%rbp),%edx
    1cbb:	00 04 85 2f 9a 2f 03 	add    %al,0x32f9a2f(,%rax,4)
        if (!lru_stats) {
    1cc2:	77 d0                	ja     1c94 <balancer_ingress+0x1c94>
    1cc4:	00 04 9a             	add    %al,(%rdx,%rbx,4)
        if (pckt.flags & F_SYN_SET) {
    1cc7:	2f                   	(bad)
    1cc8:	ac                   	lods   %ds:(%rsi),%al
    1cc9:	2f                   	(bad)
    1cca:	01 55 04             	add    %edx,0x4(%rbp)
    1ccd:	ac                   	lods   %ds:(%rsi),%al
    1cce:	2f                   	(bad)
    1ccf:	e2 30                	loop   1d01 <balancer_ingress+0x1d01>
    1cd1:	03 77 d0             	add    -0x30(%rdi),%esi
    1cd4:	00 04 ba             	add    %al,(%rdx,%rdi,4)
    1cd7:	42 94                	rex.X xchg %eax,%esp
    1cd9:	43 03 77 d0          	rex.XB add -0x30(%r15),%esi
  struct real_pos_lru new_dst_lru = {};
    1cdd:	00 04 fe             	add    %al,(%rsi,%rdi,8)
    1ce0:	43 d2 44 03 77       	rolb   %cl,0x77(%r11,%r8,1)
    1ce5:	d0 00                	rolb   (%rax)
    1ce7:	04 d2                	add    $0xd2,%al
    1ce9:	44 dd 44 01 55       	rex.R fldl 0x55(%rcx,%rax,1)
    1cee:	04 dd                	add    $0xdd,%al
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1cf0:	44 93                	rex.R xchg %eax,%ebx
    1cf2:	45 03 77 d0          	add    -0x30(%r15),%r14d
    1cf6:	00 04 c4             	add    %al,(%rsp,%rax,8)
    1cf9:	46 80 48 03 77       	rex.RX orb $0x77,0x3(%rax)
    1cfe:	d0 00                	rolb   (%rax)
    1d00:	04 80                	add    $0x80,%al
  if (!conn_rate_stats) {
    1d02:	48 92                	xchg   %rax,%rdx
    1d04:	48 01 55 04          	add    %rdx,0x4(%rbp)
    1d08:	92                   	xchg   %eax,%edx
    1d09:	48 ad                	lods   %ds:(%rsi),%rax
    1d0b:	48 03 77 d0          	add    -0x30(%rdi),%rsi
    1d0f:	00 00                	add    %al,(%rax)
  *cur_time = bpf_ktime_get_ns();
    1d11:	04 ec                	add    $0xec,%al
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1d13:	1c ce                	sbb    $0xce,%al
    1d15:	1d 02 30 9f 04       	sbb    $0x49f3002,%eax
    1d1a:	ec                   	in     (%dx),%al
    1d1b:	20 c9                	and    %cl,%cl
    1d1d:	21 02                	and    %eax,(%rdx)
    1d1f:	30 9f 04 8c 23 e5    	xor    %bl,-0x1adc73fc(%rdi)
    conn_rate_stats->v1 = 1;
    1d25:	23 02                	and    (%rdx),%eax
    1d27:	30 9f 04 95 2e fb    	xor    %bl,-0x4d16afc(%rdi)
    conn_rate_stats->v2 = *cur_time;
    1d2d:	2e 02 30             	cs add (%rax),%dh
    1d30:	9f                   	lahf
    1d31:	04 f5                	add    $0xf5,%al
    1d33:	30 86 32 02 30 9f    	xor    %al,-0x60cffdce(%rsi)
    conn_rate_stats->v1 += 1;
    1d39:	04 9b                	add    $0x9b,%al
    1d3b:	43 eb 43             	rex.XB jmp 1d81 <balancer_ingress+0x1d81>
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1d3e:	02 30                	add    (%rax),%dh
    1d40:	9f                   	lahf
    1d41:	04 9d                	add    $0x9d,%al
    1d43:	45 c4                	rex.RB (bad)
    1d45:	46 02 30             	rex.RX add (%rax),%r14b
    1d48:	9f                   	lahf
    1d49:	00 04 ec             	add    %al,(%rsp,%rbp,8)
    1d4c:	1c fd                	sbb    $0xfd,%al
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1d4e:	1c 02                	sbb    $0x2,%al
    1d50:	30 9f 04 fd 1c 86    	xor    %bl,-0x79e302fc(%rdi)
    1d56:	1d 01 56 00 04       	sbb    $0x4005601,%eax
    b += *(u32*)(k + 4);
    1d5b:	86 1d ce 1d 01 56    	xchg   %bl,0x56011dce(%rip)        # 56013b2f <_license+0x56011702>
      a += (u32)k[3] << 24;
    1d61:	04 ec                	add    $0xec,%al
    1d63:	20 b2 21 01 56 04    	and    %dh,0x4560121(%rdx)
      a += (u32)k[2] << 16;
    1d69:	8c 23                	mov    %fs,(%rbx)
      a += (u32)k[1] << 8;
    1d6b:	e5 23                	in     $0x23,%eax
    1d6d:	01 56 04             	add    %edx,0x4(%rsi)
      a += k[0];
    1d70:	95                   	xchg   %eax,%ebp
    1d71:	2e fb                	cs sti
    1d73:	2e 01 56 04          	cs add %edx,0x4(%rsi)
    1d77:	f5                   	cmc
    1d78:	30 86 32 01 56 04    	xor    %al,0x4560132(%rsi)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1d7e:	9b                   	fwait
    1d7f:	43 eb 43             	rex.XB jmp 1dc5 <balancer_ingress+0x1dc5>
    1d82:	01 56 04             	add    %edx,0x4(%rsi)
      memset(pckt->flow.srcv6, 0, 16);
    1d85:	9d                   	popf
    1d86:	45 c4                	rex.RB (bad)
    1d88:	46 01 56 00          	rex.RX add %r10d,0x0(%rsi)
    1d8c:	04 8f                	add    $0x8f,%al
    1d8e:	1d 93 1d 01 53       	sbb    $0x53011d93,%eax
    1d93:	00 04 8f             	add    %al,(%rdi,%rcx,4)
    1d96:	1d ce 1d 01 5c       	sbb    $0x5c011dce,%eax
    1d9b:	04 ec                	add    $0xec,%al
    1d9d:	20 82 21 01 5c 04    	and    %al,0x45c0121(%rdx)
    1da3:	8c 23                	mov    %fs,(%rbx)
    1da5:	e5 23                	in     $0x23,%eax
    c += *(u32*)(k + 8);
    1da7:	01 5c 04 95          	add    %ebx,-0x6b(%rsp,%rax,1)
    1dab:	2e e0 2e             	loopne,pn 1ddc <balancer_ingress+0x1ddc>
    __jhash_mix(a, b, c);
    1dae:	01 5c 00 04          	add    %ebx,0x4(%rax,%rax,1)
    1db2:	8f                   	(bad)
    1db3:	1d ce 1d 02 31       	sbb    $0x31021dce,%eax
    b += *(u32*)(k + 4);
    1db8:	9f                   	lahf
    1db9:	04 ec                	add    $0xec,%al
    1dbb:	20 82 21 02 31 9f    	and    %al,-0x60cefddf(%rdx)
    __jhash_mix(a, b, c);
    1dc1:	04 8c                	add    $0x8c,%al
    1dc3:	23 e5                	and    %ebp,%esp
    1dc5:	23 02                	and    (%rdx),%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1dc7:	31 9f 04 95 2e e0    	xor    %ebx,-0x1fd16afc(%rdi)
    __jhash_mix(a, b, c);
    1dcd:	2e 02 31             	cs add (%rcx),%dh
  return (word << shift) | (word >> ((-shift) & 31));
    1dd0:	9f                   	lahf
    1dd1:	00 04 8f             	add    %al,(%rdi,%rcx,4)
    __jhash_mix(a, b, c);
    1dd4:	1d ce 1d 12 30       	sbb    $0x30121dce,%eax
    1dd9:	20 9f 93 04 30 20    	and    %bl,0x20300493(%rdi)
  return (word << shift) | (word >> ((-shift) & 31));
    1ddf:	9f                   	lahf
    1de0:	93                   	xchg   %eax,%ebx
    __jhash_mix(a, b, c);
    1de1:	01 30                	add    %esi,(%rax)
    1de3:	9f                   	lahf
    1de4:	93                   	xchg   %eax,%ebx
    1de5:	01 30                	add    %esi,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1de7:	9f                   	lahf
    1de8:	93                   	xchg   %eax,%ebx
    1de9:	02 04 ec             	add    (%rsp,%rbp,8),%al
    __jhash_mix(a, b, c);
    1dec:	20 82 21 12 30 20    	and    %al,0x20301221(%rdx)
  return (word << shift) | (word >> ((-shift) & 31));
    1df2:	9f                   	lahf
    1df3:	93                   	xchg   %eax,%ebx
    1df4:	04 30                	add    $0x30,%al
    1df6:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
      a += (u32)k[3] << 24;
    1dfc:	93                   	xchg   %eax,%ebx
    1dfd:	01 30                	add    %esi,(%rax)
    1dff:	9f                   	lahf
    1e00:	93                   	xchg   %eax,%ebx
    1e01:	02 04 8c             	add    (%rsp,%rcx,4),%al
      a += (u32)k[2] << 16;
    1e04:	23 ae 23 12 30 20    	and    0x20301223(%rsi),%ebp
      a += (u32)k[3] << 24;
    1e0a:	9f                   	lahf
      a += (u32)k[1] << 8;
    1e0b:	93                   	xchg   %eax,%ebx
    1e0c:	04 30                	add    $0x30,%al
    1e0e:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
      a += k[0];
    1e14:	93                   	xchg   %eax,%ebx
    1e15:	01 30                	add    %esi,(%rax)
    1e17:	9f                   	lahf
      a += (u32)k[1] << 8;
    1e18:	93                   	xchg   %eax,%ebx
    1e19:	02 04 ae             	add    (%rsi,%rbp,4),%al
    __jhash_mix(a, b, c);
    1e1c:	23 cc                	and    %esp,%ecx
      __jhash_final(a, b, c);
    1e1e:	23 10                	and    (%rax),%edx
    1e20:	30 20                	xor    %ah,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1e22:	9f                   	lahf
    1e23:	93                   	xchg   %eax,%ebx
    1e24:	04 51                	add    $0x51,%al
      __jhash_final(a, b, c);
    1e26:	93                   	xchg   %eax,%ebx
    1e27:	01 30                	add    %esi,(%rax)
    1e29:	9f                   	lahf
  return (word << shift) | (word >> ((-shift) & 31));
    1e2a:	93                   	xchg   %eax,%ebx
    1e2b:	01 30                	add    %esi,(%rax)
    1e2d:	9f                   	lahf
    1e2e:	93                   	xchg   %eax,%ebx
      __jhash_final(a, b, c);
    1e2f:	02 04 cc             	add    (%rsp,%rcx,8),%al
    1e32:	23 d4                	and    %esp,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e34:	23 0d 93 04 51 93    	and    -0x6caefb6d(%rip),%ecx        # ffffffff935122cd <server_id_map+0x36fc4a2762cd>
      __jhash_final(a, b, c);
    1e3a:	01 30                	add    %esi,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1e3c:	9f                   	lahf
    1e3d:	93                   	xchg   %eax,%ebx
    1e3e:	01 30                	add    %esi,(%rax)
    1e40:	9f                   	lahf
      __jhash_final(a, b, c);
    1e41:	93                   	xchg   %eax,%ebx
    1e42:	02 04 d4             	add    (%rsp,%rdx,8),%al
  return (word << shift) | (word >> ((-shift) & 31));
    1e45:	23 e5                	and    %ebp,%esp
    1e47:	23 0a                	and    (%rdx),%ecx
    1e49:	93                   	xchg   %eax,%ebx
      __jhash_final(a, b, c);
    1e4a:	05 30 9f 93 01       	add    $0x1939f30,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1e4f:	30 9f 93 02 04 95    	xor    %bl,-0x6afbfd6d(%rdi)
    1e55:	2e a1 2e 10 30 20 9f 	cs movabs 0x5104939f2030102e,%eax
    1e5c:	93 04 51 
  b += initval;
    1e5f:	93                   	xchg   %eax,%ebx
    1e60:	01 30                	add    %esi,(%rax)
    1e62:	9f                   	lahf
  a += initval;
    1e63:	93                   	xchg   %eax,%ebx
    1e64:	01 30                	add    %esi,(%rax)
    1e66:	9f                   	lahf
    1e67:	93                   	xchg   %eax,%ebx
    1e68:	02 04 a1             	add    (%rcx,%riz,4),%al
  __jhash_final(a, b, c);
    1e6b:	2e b6 2e             	cs mov $0x2e,%dh
    1e6e:	0f 30                	wrmsr
    1e70:	20 9f 93 04 93 01    	and    %bl,0x1930493(%rdi)
    1e76:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
  return (word << shift) | (word >> ((-shift) & 31));
    1e7c:	93                   	xchg   %eax,%ebx
    1e7d:	02 04 b6             	add    (%rsi,%rsi,4),%al
  __jhash_final(a, b, c);
    1e80:	2e ba 2e 0a 93 05    	cs mov $0x5930a2e,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e86:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    1e8c:	93                   	xchg   %eax,%ebx
    1e8d:	02 04 ba             	add    (%rdx,%rdi,4),%al
    1e90:	2e be 2e 10 30 20    	cs mov $0x2030102e,%esi
    1e96:	9f                   	lahf
    1e97:	93                   	xchg   %eax,%ebx
    1e98:	04 51                	add    $0x51,%al
  __jhash_final(a, b, c);
    1e9a:	93                   	xchg   %eax,%ebx
    1e9b:	01 30                	add    %esi,(%rax)
    1e9d:	9f                   	lahf
  return (word << shift) | (word >> ((-shift) & 31));
    1e9e:	93                   	xchg   %eax,%ebx
    1e9f:	01 30                	add    %esi,(%rax)
  __jhash_final(a, b, c);
    1ea1:	9f                   	lahf
    1ea2:	93                   	xchg   %eax,%ebx
    1ea3:	02 04 be             	add    (%rsi,%rdi,4),%al
  return (word << shift) | (word >> ((-shift) & 31));
    1ea6:	2e d0 2e             	cs shrb (%rsi)
  __jhash_final(a, b, c);
    1ea9:	0f 30                	wrmsr
    1eab:	20 9f 93 04 93 01    	and    %bl,0x1930493(%rdi)
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1eb1:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    1eb7:	93                   	xchg   %eax,%ebx
    1eb8:	02 04 d0             	add    (%rax,%rdx,8),%al
    1ebb:	2e d8 2e             	cs fsubrs (%rsi)
    1ebe:	0a 93 05 30 9f 93    	or     -0x6c60cffb(%rbx),%dl
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1ec4:	01 30                	add    %esi,(%rax)
    1ec6:	9f                   	lahf
    1ec7:	93                   	xchg   %eax,%ebx
    1ec8:	02 04 d8             	add    (%rax,%rbx,8),%al
    1ecb:	2e e0 2e             	loopne,pn 1efc <balancer_ingress+0x1efc>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1ece:	06                   	(bad)
    1ecf:	93                   	xchg   %eax,%ebx
    1ed0:	06                   	(bad)
    1ed1:	30 9f 93 02 00 04    	xor    %bl,0x4000293(%rdi)
    1ed7:	b0 1d                	mov    $0x1d,%al
    1ed9:	c0 1d 01 53 04 ec 20 	rcrb   $0x20,-0x13fbacff(%rip)        # ffffffffec0471e1 <server_id_map+0x36fca2dab1e1>
    1ee0:	82                   	(bad)
    1ee1:	21 01                	and    %eax,(%rcx)
    key = *real_pos;
    1ee3:	53                   	push   %rbx
    1ee4:	04 8c                	add    $0x8c,%al
    1ee6:	23 9a 23 01 53 00    	and    0x530123(%rdx),%ebx
    if (key == 0) {
    1eec:	04 b0                	add    $0xb0,%al
  pckt->real_index = key;
    1eee:	1d c0 1d 01 53       	sbb    $0x53011dc0,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
    1ef3:	04 ec                	add    $0xec,%al
    1ef5:	20 82 21 01 53 04    	and    %al,0x4530121(%rdx)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1efb:	8c 23                	mov    %fs,(%rbx)
    1efd:	9a                   	(bad)
    1efe:	23 01                	and    (%rcx),%eax
    1f00:	53                   	push   %rbx
    1f01:	00 04 b0             	add    %al,(%rax,%rsi,4)
    1f04:	1d ce 1d 02 30       	sbb    $0x30021dce,%eax
    1f09:	9f                   	lahf
    1f0a:	04 ec                	add    $0xec,%al
    1f0c:	20 82 21 02 30 9f    	and    %al,-0x60cffddf(%rdx)
    1f12:	04 8c                	add    $0x8c,%al
  if (!ch_drop_stats) {
    1f14:	23 90 23 02 30 9f    	and    -0x60cffddd(%rax),%edx
    1f1a:	04 9d                	add    $0x9d,%al
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1f1c:	23 db                	and    %ebx,%ebx
    1f1e:	23 01                	and    (%rcx),%eax
    1f20:	50                   	push   %rax
    1f21:	04 95                	add    $0x95,%al
    1f23:	2e b6 2e             	cs mov $0x2e,%dh
    1f26:	01 50 04             	add    %edx,0x4(%rax)
    1f29:	ba 2e d0 2e 01       	mov    $0x12ed02e,%edx
    1f2e:	50                   	push   %rax
    1f2f:	00 04 d5 1d e3 1d 02 	add    %al,0x21de31d(,%rdx,8)
  if (!ch_drop_stats) {
    1f36:	30 9f 04 e3 1d ec    	xor    %bl,-0x13e21cfc(%rdi)
    1f3c:	1d 01 50 00 04       	sbb    $0x4005001,%eax
    1f41:	8e 1e                	mov    (%rsi),%ds
    1f43:	95                   	xchg   %eax,%ebp
    1f44:	1e                   	(bad)
    1f45:	02 30                	add    (%rax),%dh
}
    1f47:	9f                   	lahf
    1f48:	04 95                	add    $0x95,%al
    1f4a:	1e                   	(bad)
    1f4b:	9e                   	sahf
    1f4c:	1e                   	(bad)
    1f4d:	01 56 00             	add    %edx,0x0(%rsi)
    1f50:	04 9e                	add    $0x9e,%al
    1f52:	1e                   	(bad)
    1f53:	bd 1e 01 56 00       	mov    $0x56011e,%ebp
    1f58:	04 81                	add    $0x81,%al
    1f5a:	1f                   	(bad)
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1f5b:	be 1f 02 30 9f       	mov    $0x9f30021f,%esi
    1f60:	04 c9                	add    $0xc9,%al
    1f62:	21 8c 23 02 30 9f 04 	and    %ecx,0x49f3002(%rbx,%riz,1)
    1f69:	c3                   	ret
    1f6a:	30 e2                	xor    %ah,%dl
    1f6c:	30 02                	xor    %al,(%rdx)
    1f6e:	30 9f 04 ba 42 94    	xor    %bl,-0x6bbd45fc(%rdi)
    1f74:	43 02 30             	rex.XB add (%r8),%sil
    1f77:	9f                   	lahf
    1f78:	04 fe                	add    $0xfe,%al
    1f7a:	43 93                	rex.XB xchg %eax,%r11d
    1f7c:	45 02 30             	add    (%r8),%r14b
    1f7f:	9f                   	lahf
    1f80:	04 c4                	add    $0xc4,%al
    1f82:	46 ad                	rex.RX lods %ds:(%rsi),%eax
    1f84:	48 02 30             	rex.W add (%rax),%sil
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1f87:	9f                   	lahf
    1f88:	00 04 81             	add    %al,(%rcx,%rax,4)
    1f8b:	1f                   	(bad)
    1f8c:	92                   	xchg   %eax,%edx
    1f8d:	1f                   	(bad)
    1f8e:	02 30                	add    (%rax),%dh
    1f90:	9f                   	lahf
    1f91:	04 92                	add    $0x92,%al
    1f93:	1f                   	(bad)
  data = (void*)(long)xdp->data;
    1f94:	9b                   	fwait
    1f95:	1f                   	(bad)
    1f96:	01 56 00             	add    %edx,0x0(%rsi)
  data_end = (void*)(long)xdp->data_end;
    1f99:	04 9b                	add    $0x9b,%al
    1f9b:	1f                   	(bad)
  ip6h = data + sizeof(struct ethhdr);
    1f9c:	be 1f 01 56 04       	mov    $0x456011f,%esi
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1fa1:	c9                   	leave
    1fa2:	21 f5                	and    %esi,%ebp
    1fa4:	22 01                	and    (%rcx),%al
    1fa6:	56                   	push   %rsi
    1fa7:	04 c3                	add    $0xc3,%al
    1fa9:	30 e2                	xor    %ah,%dl
    1fab:	30 01                	xor    %al,(%rcx)
    1fad:	56                   	push   %rsi
    1fae:	04 ba                	add    $0xba,%al
    1fb0:	42 94                	rex.X xchg %eax,%esp
    1fb2:	43 01 56 04          	rex.XB add %edx,0x4(%r14)
    1fb6:	fe 43 93             	incb   -0x6d(%rbx)
    1fb9:	45 01 56 04          	add    %r10d,0x4(%r14)
  memcpy(new_eth->h_dest, cval->mac, 6);
    1fbd:	c4                   	(bad)
    1fbe:	46 ad                	rex.RX lods %ds:(%rsi),%eax
    1fc0:	48 01 56 00          	add    %rdx,0x0(%rsi)
    1fc4:	04 a4                	add    $0xa4,%al
    1fc6:	1f                   	(bad)
    1fc7:	a8 1f                	test   $0x1f,%al
    1fc9:	01 53 00             	add    %edx,0x0(%rbx)
    1fcc:	04 a4                	add    $0xa4,%al
    1fce:	1f                   	(bad)
    1fcf:	be 1f 01 5c 04       	mov    $0x45c011f,%esi
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1fd4:	c9                   	leave
    1fd5:	21 c0                	and    %eax,%eax
    1fd7:	22 01                	and    (%rcx),%al
    1fd9:	5c                   	pop    %rsp
    1fda:	04 c3                	add    $0xc3,%al
    1fdc:	30 e2                	xor    %ah,%dl
  new_eth->h_proto = BE_ETH_P_IPV6;
    1fde:	30 01                	xor    %al,(%rcx)
    1fe0:	5c                   	pop    %rsp
    1fe1:	04 ba                	add    $0xba,%al
    1fe3:	42 85 43 01          	rex.X test %eax,0x1(%rbx)
    1fe7:	5c                   	pop    %rsp
    1fe8:	00 04 a4             	add    %al,(%rsp,%riz,4)
  saddr[3] = src ^ port;
    1feb:	1f                   	(bad)
    1fec:	be 1f 02 30 9f       	mov    $0x9f30021f,%esi
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1ff1:	04 c9                	add    $0xc9,%al
    1ff3:	21 c0                	and    %eax,%eax
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1ff5:	22 02                	and    (%rdx),%al
    1ff7:	30 9f 04 c3 30 e2    	xor    %bl,-0x1dcf3cfc(%rdi)
  ip6h->priority = (tc & 0xF0) >> 4;
    1ffd:	30 02                	xor    %al,(%rdx)
    1fff:	30 9f 04 ba 42 85    	xor    %bl,-0x7abd45fc(%rdi)
    2005:	43 02 30             	rex.XB add (%r8),%sil
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    2008:	9f                   	lahf
    2009:	00 04 a4             	add    %al,(%rsp,%riz,4)
  ip6h->nexthdr = proto;
    200c:	1f                   	(bad)
    200d:	be 1f 12 30 20       	mov    $0x2030121f,%esi
  ip6h->payload_len = bpf_htons(payload_len);
    2012:	9f                   	lahf
    2013:	93                   	xchg   %eax,%ebx
    2014:	04 30                	add    $0x30,%al
    2016:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    201c:	93                   	xchg   %eax,%ebx
    201d:	01 30                	add    %esi,(%rax)
    201f:	9f                   	lahf
    2020:	93                   	xchg   %eax,%ebx
    2021:	02 04 c9             	add    (%rcx,%rcx,8),%al
    2024:	21 f3                	and    %esi,%ebx
    2026:	21 12                	and    %edx,(%rdx)
    2028:	30 20                	xor    %ah,(%rax)
    202a:	9f                   	lahf
    202b:	93                   	xchg   %eax,%ebx
    202c:	04 30                	add    $0x30,%al
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    202e:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    2034:	93                   	xchg   %eax,%ebx
    2035:	01 30                	add    %esi,(%rax)
    2037:	9f                   	lahf
    2038:	93                   	xchg   %eax,%ebx
    2039:	02 04 f3             	add    (%rbx,%rsi,8),%al
    203c:	21 91 22 10 30 20    	and    %edx,0x20301022(%rcx)
    if (pckt->flow.proto == IPPROTO_UDP) {
    2042:	9f                   	lahf
    2043:	93                   	xchg   %eax,%ebx
    2044:	04 51                	add    $0x51,%al
    2046:	93                   	xchg   %eax,%ebx
    2047:	01 30                	add    %esi,(%rax)
      new_dst_lru.atime = cur_time;
    2049:	9f                   	lahf
    204a:	93                   	xchg   %eax,%ebx
    204b:	01 30                	add    %esi,(%rax)
    204d:	9f                   	lahf
    new_dst_lru.pos = key;
    204e:	93                   	xchg   %eax,%ebx
    204f:	02 04 91             	add    (%rcx,%rdx,4),%al
    2052:	22 99 22 0d 93 04    	and    0x4930d22(%rcx),%bl
BPF_MAP_OPS_INLINE(int,
    2058:	51                   	push   %rcx
    2059:	93                   	xchg   %eax,%ebx
    205a:	01 30                	add    %esi,(%rax)
    205c:	9f                   	lahf
    205d:	93                   	xchg   %eax,%ebx
    205e:	01 30                	add    %esi,(%rax)
    2060:	9f                   	lahf
    2061:	93                   	xchg   %eax,%ebx
    2062:	02 04 99             	add    (%rcx,%rbx,4),%al
    2065:	22 aa 22 0a 93 05    	and    0x5930a22(%rdx),%ch
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    206b:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    2071:	93                   	xchg   %eax,%ebx
    2072:	02 04 aa             	add    (%rdx,%rbp,4),%al
    2075:	22 c0                	and    %al,%al
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    2077:	22 12                	and    (%rdx),%dl
    2079:	30 20                	xor    %ah,(%rax)
    207b:	9f                   	lahf
    207c:	93                   	xchg   %eax,%ebx
    207d:	04 30                	add    $0x30,%al
    207f:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    2085:	93                   	xchg   %eax,%ebx
    2086:	01 30                	add    %esi,(%rax)
    2088:	9f                   	lahf
    2089:	93                   	xchg   %eax,%ebx
    208a:	02 04 c3             	add    (%rbx,%rax,8),%al
    208d:	30 e2                	xor    %ah,%dl
    208f:	30 12                	xor    %dl,(%rdx)
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    2091:	30 20                	xor    %ah,(%rax)
    2093:	9f                   	lahf
    2094:	93                   	xchg   %eax,%ebx
    2095:	04 30                	add    $0x30,%al
    2097:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    209d:	93                   	xchg   %eax,%ebx
    209e:	01 30                	add    %esi,(%rax)
    20a0:	9f                   	lahf
    20a1:	93                   	xchg   %eax,%ebx
    20a2:	02 04 ba             	add    (%rdx,%rdi,4),%al
    20a5:	42 c6 42 10 30       	rex.X movb $0x30,0x10(%rdx)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    20aa:	20 9f 93 04 51 93    	and    %bl,-0x6caefb6d(%rdi)
    20b0:	01 30                	add    %esi,(%rax)
    20b2:	9f                   	lahf
    20b3:	93                   	xchg   %eax,%ebx
    20b4:	01 30                	add    %esi,(%rax)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    20b6:	9f                   	lahf
    20b7:	93                   	xchg   %eax,%ebx
    20b8:	02 04 c6             	add    (%rsi,%rax,8),%al
    20bb:	42 db 42 0f          	rex.X fildl 0xf(%rdx)
    20bf:	30 20                	xor    %ah,(%rax)
  bool vip_match = address_match && port_match && proto_match;
    20c1:	9f                   	lahf
    20c2:	93                   	xchg   %eax,%ebx
    20c3:	04 93                	add    $0x93,%al
    20c5:	01 30                	add    %esi,(%rax)
    20c7:	9f                   	lahf
    20c8:	93                   	xchg   %eax,%ebx
    20c9:	01 30                	add    %esi,(%rax)
    20cb:	9f                   	lahf
    20cc:	93                   	xchg   %eax,%ebx
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    20cd:	02 04 db             	add    (%rbx,%rbx,8),%al
    20d0:	42 df 42 0a          	rex.X filds 0xa(%rdx)
    20d4:	93                   	xchg   %eax,%ebx
    20d5:	05 30 9f 93 01       	add    $0x1939f30,%eax
    20da:	30 9f 93 02 04 df    	xor    %bl,-0x20fbfd6d(%rdi)
    20e0:	42 e3 42             	rex.X jrcxz 2125 <balancer_ingress+0x2125>
    20e3:	10 30                	adc    %dh,(%rax)
    20e5:	20 9f 93 04 51 93    	and    %bl,-0x6caefb6d(%rdi)
    20eb:	01 30                	add    %esi,(%rax)
    20ed:	9f                   	lahf
    20ee:	93                   	xchg   %eax,%ebx
    20ef:	01 30                	add    %esi,(%rax)
    20f1:	9f                   	lahf
    20f2:	93                   	xchg   %eax,%ebx
    20f3:	02 04 e3             	add    (%rbx,%riz,8),%al
    if (!lru_miss_stat) {
    20f6:	42 f5                	rex.X cmc
    20f8:	42 0f 30             	rex.X wrmsr
    20fb:	20 9f 93 04 93 01    	and    %bl,0x1930493(%rdi)
    2101:	30 9f 93 01 30 9f    	xor    %bl,-0x60cffe6d(%rdi)
    2107:	93                   	xchg   %eax,%ebx
    2108:	02 04 f5 42 fd 42 0a 	add    0xa42fd42(,%rsi,8),%al
    210f:	93                   	xchg   %eax,%ebx
    2110:	05 30 9f 93 01       	add    $0x1939f30,%eax
    2115:	30 9f 93 02 04 fd    	xor    %bl,-0x2fbfd6d(%rdi)
    211b:	42 85 43 06          	rex.X test %eax,0x6(%rbx)
    211f:	93                   	xchg   %eax,%ebx
    2120:	06                   	(bad)
      data_stats->v2 += 1;
    2121:	30 9f 93 02 00 04    	xor    %bl,0x4000293(%rdi)
    2127:	c5 1f d6             	(bad)
    212a:	1f                   	(bad)
    212b:	02 30                	add    (%rax),%dh
    212d:	9f                   	lahf
    212e:	04 d6                	add    $0xd6,%al
    2130:	1f                   	(bad)
    2131:	df 1f                	fistps (%rdi)
    2133:	01 56 00             	add    %edx,0x0(%rsi)
    2136:	04 df                	add    $0xdf,%al
    2138:	1f                   	(bad)
    2139:	ff 1f                	lcall  *(%rdi)
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    213b:	01 56 00             	add    %edx,0x0(%rsi)
    213e:	04 96                	add    $0x96,%al
    2140:	20 dc                	and    %bl,%ah
    2142:	20 03                	and    %al,(%rbx)
    2144:	77 10                	ja     2156 <balancer_ingress+0x2156>
    2146:	9f                   	lahf
    2147:	04 e5                	add    $0xe5,%al
    2149:	23 93 24 03 77 10    	and    0x10770324(%rbx),%edx
    214f:	9f                   	lahf
    2150:	00 04 9b             	add    %al,(%rbx,%rbx,4)
    2153:	20 a6 20 01 55 04    	and    %ah,0x4550120(%rsi)
    2159:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    215a:	20 dc                	and    %bl,%ah
    215c:	20 03                	and    %al,(%rbx)
    215e:	77 d0                	ja     2130 <balancer_ingress+0x2130>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    2160:	00 04 e5 23 93 24 03 	add    %al,0x3249323(,%riz,8)
    2167:	77 d0                	ja     2139 <balancer_ingress+0x2139>
    2169:	00 00                	add    %al,(%rax)
    216b:	04 96                	add    $0x96,%al
    216d:	20 dc                	and    %bl,%ah
    216f:	20 02                	and    %al,(%rdx)
    2171:	30 9f 04 e5 23 93    	xor    %bl,-0x6cdc1afc(%rdi)
    2177:	24 02                	and    $0x2,%al
    2179:	30 9f 00 04 a6 20    	xor    %bl,0x20a60400(%rdi)
      if (qpr.server_id > 0) {
    217f:	b9 20 01 50 04       	mov    $0x4500120,%ecx
    2184:	b9 20 dc 20 01       	mov    $0x120dc20,%ecx
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    2189:	56                   	push   %rsi
    218a:	04 e5                	add    $0xe5,%al
    218c:	23 93 24 01 56 00    	and    0x560124(%rbx),%edx
    2192:	04 c2                	add    $0xc2,%al
    2194:	20 dc                	and    %bl,%ah
    2196:	20 01                	and    %al,(%rcx)
    2198:	50                   	push   %rax
    2199:	04 e5                	add    $0xe5,%al
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    219b:	23 e9                	and    %ecx,%ebp
    219d:	23 01                	and    (%rcx),%eax
    219f:	50                   	push   %rax
    21a0:	00 04 87             	add    %al,(%rdi,%rax,4)
    21a3:	21 b2 21 02 30 9f    	and    %esi,-0x60cffddf(%rdx)
    21a9:	04 b2                	add    $0xb2,%al
    21ab:	21 bb 21 01 56 00    	and    %edi,0x560121(%rbx)
    21b1:	04 bb                	add    $0xbb,%al
    21b3:	21 c9                	and    %ecx,%ecx
  if (!conn_rate_stats) {
    21b5:	21 01                	and    %eax,(%rcx)
    21b7:	56                   	push   %rsi
    21b8:	00 04 cd 21 d9 21 01 	add    %al,0x121d921(,%rcx,8)
    21bf:	53                   	push   %rbx
    21c0:	04 aa                	add    $0xaa,%al
    21c2:	22 c0                	and    %al,%al
    21c4:	22 01                	and    (%rcx),%al
  *cur_time = bpf_ktime_get_ns();
    21c6:	53                   	push   %rbx
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    21c7:	04 c3                	add    $0xc3,%al
    21c9:	30 d1                	xor    %dl,%cl
    21cb:	30 01                	xor    %al,(%rcx)
    21cd:	53                   	push   %rbx
    21ce:	00 04 cd 21 d9 21 01 	add    %al,0x121d921(,%rcx,8)
    21d5:	53                   	push   %rbx
    21d6:	04 aa                	add    $0xaa,%al
    21d8:	22 c0                	and    %al,%al
    21da:	22 01                	and    (%rcx),%al
    conn_rate_stats->v1 = 1;
    21dc:	53                   	push   %rbx
    21dd:	04 c3                	add    $0xc3,%al
    21df:	30 d1                	xor    %dl,%cl
    21e1:	30 01                	xor    %al,(%rcx)
    conn_rate_stats->v2 = *cur_time;
    21e3:	53                   	push   %rbx
    21e4:	00 04 cd 21 e2 21 02 	add    %al,0x221e221(,%rcx,8)
    21eb:	30 9f 04 e2 21 a0    	xor    %bl,-0x5fde1dfc(%rdi)
    21f1:	22 01                	and    (%rcx),%al
    21f3:	50                   	push   %rax
    21f4:	04 aa                	add    $0xaa,%al
    21f6:	22 c0                	and    %al,%al
    21f8:	22 02                	and    (%rdx),%al
    21fa:	30 9f 04 c3 30 c7    	xor    %bl,-0x38cf3cfc(%rdi)
    2200:	30 02                	xor    %al,(%rdx)
    2202:	30 9f 04 d4 30 e2    	xor    %bl,-0x1dcf2bfc(%rdi)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    2208:	30 01                	xor    %al,(%rcx)
        if (real_pos) {
    220a:	53                   	push   %rbx
    220b:	04 ba                	add    $0xba,%al
    220d:	42 db 42 01          	rex.X fildl 0x1(%rdx)
    2211:	50                   	push   %rax
    2212:	04 df                	add    $0xdf,%al
    2214:	42 f5                	rex.X cmc
          key = *real_pos;
    2216:	42 01 50 00          	rex.X add %edx,0x0(%rax)
    221a:	04 f3                	add    $0xf3,%al
    221c:	21 99 22 01 51 04    	and    %ebx,0x4510122(%rcx)
            pckt.real_index = key;
    2222:	ba 42 c6 42 01       	mov    $0x142c642,%edx
    2227:	51                   	push   %rcx
            dst = bpf_map_lookup_elem(&reals, &key);
    2228:	04 df                	add    $0xdf,%al
    222a:	42 e3 42             	rex.X jrcxz 226f <balancer_ingress+0x226f>
    222d:	01 51 00             	add    %edx,0x0(%rcx)
    2230:	04 c5                	add    $0xc5,%al
    2232:	22 f5                	and    %ch,%dh
    2234:	22 02                	and    (%rdx),%al
    2236:	30 9f 04 f5 22 fe    	xor    %bl,-0x1dd0afc(%rdi)
    223c:	22 01                	and    (%rcx),%al
    223e:	56                   	push   %rsi
    223f:	00 04 fe             	add    %al,(%rsi,%rdi,8)
    2242:	22 8c 23 01 56 00 04 	and    0x4005601(%rbx,%riz,1),%cl
            if (!dst) {
    2249:	8c 23                	mov    %fs,(%rbx)
    224b:	96                   	xchg   %eax,%esi
    224c:	23 01                	and    (%rcx),%eax
    224e:	53                   	push   %rbx
    224f:	00 04 ae             	add    %al,(%rsi,%rbp,4)
BPF_MAP_OPS_INLINE(void*,
    2252:	23 d4                	and    %esp,%edx
    2254:	23 01                	and    (%rcx),%eax
    2256:	51                   	push   %rcx
    2257:	04 95                	add    $0x95,%al
    2259:	2e a1 2e 01 51 04 ba 	cs movabs 0x2ebe2eba0451012e,%eax
    2260:	2e be 2e 
  if (dst_lru) {
    2263:	01 51 00             	add    %edx,0x0(%rcx)
    if (dst_lru->pos == pckt->real_index) {
    2266:	04 ec                	add    $0xec,%al
    2268:	23 fd                	and    %ebp,%edi
    226a:	23 01                	and    (%rcx),%eax
    226c:	50                   	push   %rax
    226d:	00 04 ec             	add    %al,(%rsp,%rbp,8)
    2270:	23 fd                	and    %ebp,%edi
              quic_packets_stats->dst_match_in_lru += 1;
    2272:	23 01                	and    (%rcx),%eax
    2274:	50                   	push   %rax
    2275:	00 04 f9             	add    %al,(%rcx,%rdi,8)
    2278:	23 93 24 02 30 9f    	and    -0x60cffddc(%rbx),%edx
    227e:	00 04 98             	add    %al,(%rax,%rbx,4)
    2281:	24 a3                	and    $0xa3,%al
    2283:	24 02                	and    $0x2,%al
    2285:	77 08                	ja     228f <balancer_ingress+0x228f>
    2287:	04 a3                	add    $0xa3,%al
    2289:	24 d9                	and    $0xd9,%al
    228b:	24 01                	and    $0x1,%al
    228d:	55                   	push   %rbp
    228e:	04 d9                	add    $0xd9,%al
    2290:	24 e1                	and    $0xe1,%al
    2292:	25 02 77 08 00       	and    $0x87702,%eax
    2297:	04 ad                	add    $0xad,%al
    2299:	24 be                	and    $0xbe,%al
    229b:	24 02                	and    $0x2,%al
      dst_lru->pos = pckt->real_index;
    229d:	30 9f 04 be 24 c7    	xor    %bl,-0x38db41fc(%rdi)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    22a3:	24 01                	and    $0x1,%al
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    22a5:	53                   	push   %rbx
    22a6:	00 04 c7             	add    %al,(%rdi,%rax,8)
    22a9:	24 88                	and    $0x88,%al
    22ab:	25 01 53 00 04       	and    $0x4005301,%eax
    22b0:	88 25 9d 25 02 30    	mov    %ah,0x3002259d(%rip)        # 30024853 <_license+0x30022426>
    22b6:	9f                   	lahf
    22b7:	04 9d                	add    $0x9d,%al
    22b9:	25 a2 25 01 50       	and    $0x500125a2,%eax
    22be:	00 04 92             	add    %al,(%rdx,%rdx,4)
    22c1:	25 9d 25 01 55       	and    $0x5501259d,%eax
    22c6:	00 04 9d 25 b0 25 01 	add    %al,0x125b025(,%rbx,4)
    per_vip_stats->v2 += 1;
    22cd:	50                   	push   %rax
    22ce:	00 04 b0             	add    %al,(%rax,%rsi,4)
    22d1:	25 bf 25 01 50       	and    $0x500125bf,%eax
    conn_rate_stats->v1 += 1;
    22d6:	00 04 b5 25 c6 25 02 	add    %al,0x225c625(,%rsi,4)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    22dd:	30 9f 04 c6 25 cf    	xor    %bl,-0x30da39fc(%rdi)
    22e3:	25 01 50 00 04       	and    $0x4005001,%eax
  struct real_pos_lru new_dst_lru = {};
    22e8:	cf                   	iret
    22e9:	25 e1 25 01 50       	and    $0x500125e1,%eax
    22ee:	00 04 ea             	add    %al,(%rdx,%rbp,8)
    22f1:	25 90 26 02 30       	and    $0x30022690,%eax
    22f6:	9f                   	lahf
  new_dst_lru.pos = pckt->real_index;
    22f7:	04 90                	add    $0x90,%al
    22f9:	26 99                	es cltd
    22fb:	26 01 52 00          	es add %edx,0x0(%rdx)
    22ff:	04 b1                	add    $0xb1,%al
    2301:	26 a1 28 01 53 04 d3 	es movabs 0x2dd62cd304530128,%eax
    2308:	2c d6 2d 
BPF_MAP_OPS_INLINE(int,
    230b:	01 53 00             	add    %edx,0x0(%rbx)
    230e:	04 b8                	add    $0xb8,%al
    2310:	26 db 26             	es (bad) (%rsi)
    2313:	02 30                	add    (%rax),%dh
    2315:	9f                   	lahf
              quic_packets_stats->dst_not_found_in_lru += 1;
    2316:	04 db                	add    $0xdb,%al
    2318:	26 e4 26             	es in  $0x26,%al
    231b:	01 52 00             	add    %edx,0x0(%rdx)
    231e:	04 c3                	add    $0xc3,%al
    2320:	26 ed                	es in  (%dx),%eax
            quic_packets_stats->cid_routed += 1;
    2322:	26 04 10             	es add $0x10,%al
    2325:	80 20 9f             	andb   $0x9f,(%rax)
  original_sport = pckt.flow.port16[0];
    2328:	00 04 c3             	add    %al,(%rbx,%rax,8)
    232b:	26 ed                	es in  (%dx),%eax
    232d:	26 02 38             	es add (%rax),%bh
    2330:	9f                   	lahf
    2331:	00 04 86             	add    %al,(%rsi,%rax,4)
    2334:	27                   	(bad)
    2335:	a1 28 12 73 00 10 ff 	movabs 0x3ffff1000731228,%eax
    233c:	ff 03 
    233e:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2344:	a8 b0                	test   $0xb0,%al
    2346:	80 80 00 9f 00 04 d8 	addb   $0xd8,0x4009f00(%rax)
    234d:	27                   	(bad)
    234e:	cb                   	lret
    234f:	28 0e                	sub    %cl,(%rsi)
    2351:	7f 00                	jg     2353 <balancer_ingress+0x2353>
    2353:	10 ff                	adc    %bh,%bh
    2355:	ff                   	(bad)
    2356:	ff                   	(bad)
    2357:	ff 0f                	decl   (%rdi)
    2359:	1a 10                	sbb    (%rax),%dl
    235b:	ac                   	lods   %ds:(%rsi),%al
    235c:	21 21                	and    %esp,(%rcx)
  if (!conn_rate_stats) {
    235e:	9f                   	lahf
    235f:	00 04 8c             	add    %al,(%rsp,%rcx,4)
    2362:	27                   	(bad)
    2363:	d9 28                	fldcw  (%rax)
    2365:	02 30                	add    (%rax),%dh
    2367:	9f                   	lahf
    2368:	00 04 a9             	add    %al,(%rcx,%rbp,4)
    236b:	27                   	(bad)
    236c:	d9 28                	fldcw  (%rax)
  *cur_time = bpf_ktime_get_ns();
    236e:	01 50 00             	add    %edx,0x0(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    2371:	04 ad                	add    $0xad,%al
    2373:	27                   	(bad)
    2374:	e9 27 01 52 00       	jmp    5224a0 <_license+0x520073>
    2379:	04 ad                	add    $0xad,%al
    237b:	27                   	(bad)
    237c:	d9 28                	fldcw  (%rax)
    237e:	01 50 00             	add    %edx,0x0(%rax)
    conn_rate_stats->v1 = 1;
    2381:	04 b1                	add    $0xb1,%al
    2383:	27                   	(bad)
    2384:	be 27 01 51 00       	mov    $0x510127,%esi
    conn_rate_stats->v2 = *cur_time;
    2389:	04 b1                	add    $0xb1,%al
    238b:	27                   	(bad)
    238c:	d9 28                	fldcw  (%rax)
      dst_lru->pos = pckt->real_index;
    238e:	03 70 14             	add    0x14(%rax),%esi
              quic_packets_stats->dst_mismatch_in_lru += 1;
    2391:	9f                   	lahf
    2392:	00 04 97             	add    %al,(%rdi,%rdx,4)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2395:	28 cb                	sub    %cl,%bl
    2397:	28 0e                	sub    %cl,(%rsi)
    2399:	7f 00                	jg     239b <balancer_ingress+0x239b>
    239b:	10 ff                	adc    %bh,%bh
    239d:	ff                   	(bad)
    239e:	ff                   	(bad)
    239f:	ff 0f                	decl   (%rdi)
    23a1:	1a 10                	sbb    (%rax),%dl
    23a3:	ac                   	lods   %ds:(%rsi),%al
    23a4:	21 21                	and    %esp,(%rcx)
    23a6:	9f                   	lahf
    23a7:	00 04 97             	add    %al,(%rdi,%rdx,4)
    23aa:	28 a1 28 01 53 00    	sub    %ah,0x530128(%rcx)
    23b0:	04 97                	add    $0x97,%al
    23b2:	28 c0                	sub    %al,%al
    23b4:	28 01                	sub    %al,(%rcx)
    23b6:	51                   	push   %rcx
    23b7:	00 04 bc             	add    %al,(%rsp,%rdi,4)
    23ba:	28 c0                	sub    %al,%al
    23bc:	28 03                	sub    %al,(%rbx)
    23be:	11 00                	adc    %eax,(%rax)
    23c0:	9f                   	lahf
    23c1:	04 c0                	add    $0xc0,%al
    23c3:	28 c3                	sub    %al,%bl
  if (!per_vip_stats) {
    23c5:	28 03                	sub    %al,(%rbx)
    23c7:	11 01                	adc    %eax,(%rcx)
    per_vip_stats->v2 += 1;
    23c9:	9f                   	lahf
    23ca:	04 c3                	add    $0xc3,%al
    23cc:	28 c7                	sub    %al,%bh
    23ce:	28 03                	sub    %al,(%rbx)
    conn_rate_stats->v1 += 1;
    23d0:	11 04 9f             	adc    %eax,(%rdi,%rbx,4)
    23d3:	04 c7                	add    $0xc7,%al
    23d5:	28 cb                	sub    %cl,%bl
    23d7:	28 03                	sub    %al,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    23d9:	11 07                	adc    %eax,(%rdi)
    23db:	9f                   	lahf
    23dc:	04 cb                	add    $0xcb,%al
    23de:	28 d1                	sub    %dl,%cl
    23e0:	28 03                	sub    %al,(%rbx)
  struct real_pos_lru new_dst_lru = {};
    23e2:	11 08                	adc    %ecx,(%rax)
    23e4:	9f                   	lahf
    23e5:	04 d1                	add    $0xd1,%al
    23e7:	28 d9                	sub    %bl,%cl
    23e9:	28 03                	sub    %al,(%rbx)
    23eb:	11 09                	adc    %ecx,(%rcx)
    23ed:	9f                   	lahf
    23ee:	00 04 bc             	add    %al,(%rsp,%rdi,4)
    23f1:	28 c0                	sub    %al,%al
  new_dst_lru.pos = pckt->real_index;
    23f3:	28 05 70 0e 23 02    	sub    %al,0x2230e70(%rip)        # 2233269 <_license+0x2230e3c>
    23f9:	9f                   	lahf
    23fa:	04 c0                	add    $0xc0,%al
    23fc:	28 c3                	sub    %al,%bl
    23fe:	28 05 70 0e 23 04    	sub    %al,0x4230e70(%rip)        # 4233274 <_license+0x4230e47>
    2404:	9f                   	lahf
    2405:	04 c3                	add    $0xc3,%al
    2407:	28 c7                	sub    %al,%bh
    2409:	28 05 70 0e 23 0a    	sub    %al,0xa230e70(%rip)        # a23327f <_license+0xa230e52>
    240f:	9f                   	lahf
    2410:	04 c7                	add    $0xc7,%al
              quic_packets_stats->dst_not_found_in_lru += 1;
    2412:	28 cb                	sub    %cl,%bl
    2414:	28 05 70 0e 23 10    	sub    %al,0x10230e70(%rip)        # 1023328a <_license+0x10230e5d>
    241a:	9f                   	lahf
    241b:	04 cb                	add    $0xcb,%al
            quic_packets_stats->cid_routed += 1;
    241d:	28 d1                	sub    %dl,%cl
    241f:	28 05 70 0e 23 12    	sub    %al,0x12230e70(%rip)        # 12233295 <_license+0x12230e68>
  original_sport = pckt.flow.port16[0];
    2425:	9f                   	lahf
    2426:	04 d1                	add    $0xd1,%al
    2428:	28 d9                	sub    %bl,%cl
    242a:	28 07                	sub    %al,(%rdi)
    242c:	70 0e                	jo     243c <_license+0xf>
    242e:	23 12                	and    (%rdx),%edx
    2430:	23 02                	and    (%rdx),%eax
    2432:	9f                   	lahf
    2433:	00 04 e0             	add    %al,(%rax,%riz,8)
    2436:	28 f1                	sub    %dh,%cl
    2438:	28 02                	sub    %al,(%rdx)
    243a:	30 9f 04 f1 28 fa    	xor    %bl,-0x5d70efc(%rdi)
    2440:	28 01                	sub    %al,(%rcx)
    2442:	50                   	push   %rax
    2443:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    2446:	28 94 29 01 50 00 04 	sub    %dl,0x4005001(%rcx,%rbp,1)
    244d:	94                   	xchg   %eax,%esp
    244e:	29 cc                	sub    %ecx,%esp
    2450:	2c 03                	sub    $0x3,%al
    2452:	77 10                	ja     2464 <_license+0x37>
    2454:	9f                   	lahf
    2455:	04 85                	add    $0x85,%al
    2457:	2f                   	(bad)
    2458:	b0 2f                	mov    $0x2f,%al
    245a:	03 77 10             	add    0x10(%rdi),%esi
    245d:	9f                   	lahf
    245e:	00 04 94             	add    %al,(%rsp,%rdx,4)
    2461:	29 8e 2a 02 77 08    	sub    %ecx,0x877022a(%rsi)
    2467:	04 8e                	add    $0x8e,%al
    2469:	2a a3 2a 01 52 04    	sub    0x452012a(%rbx),%ah
    246f:	a3 2a a4 2b 02 77 08 	movabs %eax,0xa4040877022ba42a
    2476:	04 a4 
    2478:	2b a9 2b 01 51 04    	sub    0x451012b(%rcx),%ebp
    247e:	a9 2b bd 2c 02       	test   $0x22cbd2b,%eax
    2483:	77 08                	ja     248d <_license+0x60>
    2485:	04 bd                	add    $0xbd,%al
    2487:	2c bf                	sub    $0xbf,%al
    2489:	2c 01                	sub    $0x1,%al
    248b:	52                   	push   %rdx
    248c:	04 bf                	add    $0xbf,%al
    248e:	2c cc                	sub    $0xcc,%al
    2490:	2c 02                	sub    $0x2,%al
    2492:	77 08                	ja     249c <_license+0x6f>
    2494:	04 85                	add    $0x85,%al
    2496:	2f                   	(bad)
    2497:	b0 2f                	mov    $0x2f,%al
    2499:	02 77 08             	add    0x8(%rdi),%dh
    249c:	00 04 94             	add    %al,(%rsp,%rdx,4)
    249f:	29 cc                	sub    %ecx,%esp
    24a1:	2c 02                	sub    $0x2,%al
    24a3:	30 9f 04 85 2f b0    	xor    %bl,-0x4fd07afc(%rdi)
    24a9:	2f                   	(bad)
    24aa:	02 30                	add    (%rax),%dh
    24ac:	9f                   	lahf
    24ad:	00 04 94             	add    %al,(%rsp,%rdx,4)
    24b0:	29 cc                	sub    %ecx,%esp
    24b2:	2c 03                	sub    $0x3,%al
    24b4:	77 d0                	ja     2486 <_license+0x59>
    24b6:	00 04 85 2f 9a 2f 03 	add    %al,0x32f9a2f(,%rax,4)
    24bd:	77 d0                	ja     248f <_license+0x62>
    24bf:	00 04 9a             	add    %al,(%rdx,%rbx,4)
    24c2:	2f                   	(bad)
    24c3:	ac                   	lods   %ds:(%rsi),%al
    24c4:	2f                   	(bad)
    24c5:	01 55 00             	add    %edx,0x0(%rbp)
    24c8:	04 a6                	add    $0xa6,%al
    24ca:	29 89 2a 02 30 9f    	sub    %ecx,-0x60cffdd6(%rcx)
    24d0:	04 89                	add    $0x89,%al
    24d2:	2a c6                	sub    %dh,%al
    24d4:	2c 11                	sub    $0x11,%al
    24d6:	73 00                	jae    24d8 <_license+0xab>
    24d8:	10 ff                	adc    %bh,%bh
    24da:	01 1a                	add    %ebx,(%rdx)
    24dc:	a8 ba                	test   $0xba,%al
    24de:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    24e5:	00 9f 00 04 a6 29    	add    %bl,0x29a60400(%rdi)
    24eb:	cc                   	int3
    24ec:	2c 02                	sub    $0x2,%al
    24ee:	30 9f 04 85 2f b0    	xor    %bl,-0x4fd07afc(%rdi)
    24f4:	2f                   	(bad)
    24f5:	02 30                	add    (%rax),%dh
    24f7:	9f                   	lahf
    24f8:	00 04 a6             	add    %al,(%rsi,%riz,4)
    24fb:	29 cc                	sub    %ecx,%esp
    24fd:	2c 02                	sub    $0x2,%al
    24ff:	30 9f 04 85 2f 8c    	xor    %bl,-0x73d07afc(%rdi)
    2505:	2f                   	(bad)
    2506:	02 30                	add    (%rax),%dh
    2508:	9f                   	lahf
    2509:	04 8c                	add    $0x8c,%al
    250b:	2f                   	(bad)
    250c:	91                   	xchg   %eax,%ecx
    250d:	2f                   	(bad)
    250e:	01 50 00             	add    %edx,0x0(%rax)
    2511:	04 a6                	add    $0xa6,%al
    2513:	29 b7 29 02 30 9f    	sub    %esi,-0x60cffdd7(%rdi)
    2519:	04 b7                	add    $0xb7,%al
    251b:	29 c7                	sub    %eax,%edi
    251d:	29 01                	sub    %eax,(%rcx)
    251f:	56                   	push   %rsi
    2520:	00 04 c0             	add    %al,(%rax,%rax,8)
    2523:	29 87 2a 01 56 00    	sub    %eax,0x56012a(%rdi)
    2529:	04 89                	add    $0x89,%al
    252b:	2a d4                	sub    %ah,%dl
    252d:	2b 02                	sub    (%rdx),%eax
    252f:	30 9f 04 88 2c b0    	xor    %bl,-0x4fd377fc(%rdi)
    2535:	2c 02                	sub    $0x2,%al
    2537:	30 9f 00 04 c8 2a    	xor    %bl,0x2ac80400(%rdi)
    253d:	87 2b                	xchg   %ebp,(%rbx)
    253f:	01 54 00 04          	add    %edx,0x4(%rax,%rax,1)
    2543:	bf 2a c8 2a 02       	mov    $0x22ac82a,%edi
    2548:	30 9f 04 c8 2a d0    	xor    %bl,-0x2fd537fc(%rdi)
    254e:	2a 0c 10             	sub    (%rax,%rdx,1),%cl
    2551:	f7 81 b7 85 fe ff ff 	testl  $0x1ffffff,-0x17a49(%rcx)
    2558:	ff ff 01 
    255b:	9f                   	lahf
    255c:	04 d0                	add    $0xd0,%al
    255e:	2a 9f 2b 01 52 00    	sub    0x52012b(%rdi),%bl
    2564:	04 bf                	add    $0xbf,%al
    2566:	2a 80 2b 01 51 00    	sub    0x51012b(%rax),%al
    256c:	04 9f                	add    $0x9f,%al
    256e:	2b be 2b 01 52 00    	sub    0x52012b(%rsi),%edi
    2574:	04 b0                	add    $0xb0,%al
    2576:	2b c8                	sub    %eax,%ecx
    2578:	2b 01                	sub    (%rcx),%eax
    257a:	51                   	push   %rcx
    257b:	04 c8                	add    $0xc8,%al
    257d:	2b cf                	sub    %edi,%ecx
    257f:	2b 01                	sub    (%rcx),%eax
    2581:	52                   	push   %rdx
    2582:	04 cf                	add    $0xcf,%al
    2584:	2b cc                	sub    %esp,%ecx
    2586:	2c 01                	sub    $0x1,%al
    2588:	56                   	push   %rsi
    2589:	04 85                	add    $0x85,%al
    258b:	2f                   	(bad)
    258c:	b0 2f                	mov    $0x2f,%al
    258e:	01 56 00             	add    %edx,0x0(%rsi)
    2591:	04 b0                	add    $0xb0,%al
    2593:	2b b6 2b 02 30 9f    	sub    -0x60cffdd5(%rsi),%esi
    2599:	00 04 d8             	add    %al,(%rax,%rbx,8)
    259c:	2b de                	sub    %esi,%ebx
    259e:	2b 02                	sub    (%rdx),%eax
    25a0:	30 9f 00 04 e0 2b    	xor    %bl,0x2be00400(%rdi)
    25a6:	f1                   	int1
    25a7:	2b 02                	sub    (%rdx),%eax
    25a9:	30 9f 04 f1 2b fa    	xor    %bl,-0x5d40efc(%rdi)
    25af:	2b 01                	sub    (%rcx),%eax
    25b1:	50                   	push   %rax
    25b2:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    25b5:	2b 88 2c 01 50 00    	sub    0x50012c(%rax),%ecx
    25bb:	04 88                	add    $0x88,%al
    25bd:	2c 99                	sub    $0x99,%al
    25bf:	2c 02                	sub    $0x2,%al
    25c1:	30 9f 04 99 2c a2    	xor    %bl,-0x5dd366fc(%rdi)
    25c7:	2c 01                	sub    $0x1,%al
    25c9:	50                   	push   %rax
    25ca:	00 04 a2             	add    %al,(%rdx,%riz,4)
    25cd:	2c b0                	sub    $0xb0,%al
    25cf:	2c 01                	sub    $0x1,%al
    25d1:	50                   	push   %rax
    25d2:	00 04 d3             	add    %al,(%rbx,%rdx,8)
    25d5:	2c d6                	sub    $0xd6,%al
    25d7:	2d 12 73 00 10       	sub    $0x10007312,%eax
    25dc:	ff                   	(bad)
    25dd:	ff 03                	incl   (%rbx)
    25df:	1a a8 ab 80 80 00    	sbb    0x8080ab(%rax),%ch
    25e5:	a8 b0                	test   $0xb0,%al
    25e7:	80 80 00 9f 00 04 f0 	addb   $0xf0,0x4009f00(%rax)
    25ee:	2c 95                	sub    $0x95,%al
    25f0:	2e 01 50 00          	cs add %edx,0x0(%rax)
    25f4:	04 f4                	add    $0xf4,%al
    25f6:	2c a2                	sub    $0xa2,%al
    25f8:	2d 01 52 00 04       	sub    $0x4005201,%eax
    25fd:	f4                   	hlt
    25fe:	2c 95                	sub    $0x95,%al
    2600:	2e 01 50 00          	cs add %edx,0x0(%rax)
    2604:	04 f8                	add    $0xf8,%al
    2606:	2c 85                	sub    $0x85,%al
    2608:	2d 01 51 00 04       	sub    $0x4005101,%eax
    260d:	f8                   	clc
    260e:	2c 95                	sub    $0x95,%al
    2610:	2e 03 70 28          	cs add 0x28(%rax),%esi
    2614:	9f                   	lahf
    2615:	00 04 ce             	add    %al,(%rsi,%rcx,8)
    2618:	2d 95 2e 02 34       	sub    $0x34022e95,%eax
    261d:	9f                   	lahf
    261e:	00 04 ce             	add    %al,(%rsi,%rcx,8)
    2621:	2d d2 2d 0c 31       	sub    $0x310c2dd2,%eax
    2626:	9f                   	lahf
    2627:	93                   	xchg   %eax,%ebx
    2628:	04 30                	add    $0x30,%al
    262a:	9f                   	lahf
    262b:	93                   	xchg   %eax,%ebx
    262c:	04 30                	add    $0x30,%al
    262e:	9f                   	lahf
    262f:	93                   	xchg   %eax,%ebx
    2630:	04 04                	add    $0x4,%al
    2632:	d2 2d 8c 2e 0f 31    	shrb   %cl,0x310f2e8c(%rip)        # 310f54c4 <_license+0x310f3097>
    2638:	9f                   	lahf
    2639:	93                   	xchg   %eax,%ebx
    263a:	04 30                	add    $0x30,%al
    263c:	9f                   	lahf
    263d:	93                   	xchg   %eax,%ebx
    263e:	04 30                	add    $0x30,%al
    2640:	9f                   	lahf
    2641:	93                   	xchg   %eax,%ebx
    2642:	04 52                	add    $0x52,%al
    2644:	93                   	xchg   %eax,%ebx
    2645:	04 04                	add    $0x4,%al
    2647:	8c 2e                	mov    %gs,(%rsi)
    2649:	95                   	xchg   %eax,%ebp
    264a:	2e 0c 31             	cs or  $0x31,%al
    264d:	9f                   	lahf
    264e:	93                   	xchg   %eax,%ebx
    264f:	04 30                	add    $0x30,%al
    2651:	9f                   	lahf
    2652:	93                   	xchg   %eax,%ebx
    2653:	04 30                	add    $0x30,%al
    2655:	9f                   	lahf
    2656:	93                   	xchg   %eax,%ebx
    2657:	04 00                	add    $0x0,%al
    2659:	04 d2                	add    $0xd2,%al
    265b:	2d d6 2d 01 53       	sub    $0x53012dd6,%eax
    2660:	00 04 d6             	add    %al,(%rsi,%rdx,8)
    2663:	2d ea 2d 01 53       	sub    $0x53012dea,%eax
    2668:	00 04 d8             	add    %al,(%rax,%rbx,8)
    266b:	2e e0 2e             	loopne,pn 269c <_license+0x26f>
    266e:	03 50 93             	add    -0x6d(%rax),%edx
    2671:	04 04                	add    $0x4,%al
    2673:	e0 2e                	loopne 26a3 <_license+0x276>
    2675:	fb                   	sti
    2676:	2e 06                	cs (bad)
    2678:	50                   	push   %rax
    2679:	93                   	xchg   %eax,%ebx
    267a:	04 51                	add    $0x51,%al
    267c:	93                   	xchg   %eax,%ebx
    267d:	01 04 f5 30 9e 31 06 	add    %eax,0x6319e30(,%rsi,8)
    2684:	50                   	push   %rax
    2685:	93                   	xchg   %eax,%ebx
    2686:	04 51                	add    $0x51,%al
    2688:	93                   	xchg   %eax,%ebx
    2689:	01 04 9e             	add    %eax,(%rsi,%rbx,4)
    268c:	31 a8 31 03 50 93    	xor    %ebp,-0x6caffccf(%rax)
    2692:	04 04                	add    $0x4,%al
    2694:	fb                   	sti
    2695:	31 82 32 06 50 93    	xor    %eax,-0x6caff9ce(%rdx)
    269b:	04 51                	add    $0x51,%al
    269d:	93                   	xchg   %eax,%ebx
    269e:	01 04 82             	add    %eax,(%rdx,%rax,4)
    26a1:	32 86 32 05 93 04    	xor    0x4930532(%rsi),%al
    26a7:	51                   	push   %rcx
    26a8:	93                   	xchg   %eax,%ebx
    26a9:	01 00                	add    %eax,(%rax)
    26ab:	04 e0                	add    $0xe0,%al
    26ad:	2e fb                	cs sti
    26af:	2e 01 56 04          	cs add %edx,0x4(%rsi)
    26b3:	f5                   	cmc
    26b4:	30 82 31 01 56 00    	xor    %al,0x560131(%rdx)
    26ba:	04 e0                	add    $0xe0,%al
    26bc:	2e fb                	cs sti
    26be:	2e 01 51 04          	cs add %edx,0x4(%rcx)
    26c2:	f5                   	cmc
    26c3:	30 82 31 01 51 00    	xor    %al,0x510131(%rdx)
    26c9:	04 e5                	add    $0xe5,%al
    26cb:	2f                   	(bad)
    26cc:	f2 2f                	repnz (bad)
    26ce:	01 50 00             	add    %edx,0x0(%rax)
    26d1:	04 e5                	add    $0xe5,%al
    26d3:	2f                   	(bad)
    26d4:	84 30                	test   %dh,(%rax)
    26d6:	02 30                	add    (%rax),%dh
    26d8:	9f                   	lahf
    26d9:	04 84                	add    $0x84,%al
    26db:	30 8d 30 01 50 00    	xor    %cl,0x500130(%rbp)
    26e1:	04 e5                	add    $0xe5,%al
    26e3:	2f                   	(bad)
    26e4:	f2 2f                	repnz (bad)
    26e6:	01 50 00             	add    %edx,0x0(%rax)
    26e9:	04 8d                	add    $0x8d,%al
    26eb:	30 99 30 01 50 00    	xor    %bl,0x500130(%rcx)
    26f1:	04 c3                	add    $0xc3,%al
    26f3:	30 cd                	xor    %cl,%ch
    26f5:	30 01                	xor    %al,(%rcx)
    26f7:	53                   	push   %rbx
    26f8:	00 04 fb             	add    %al,(%rbx,%rdi,8)
    26fb:	30 93 31 01 50 04    	xor    %dl,0x4500131(%rbx)
    2701:	93                   	xchg   %eax,%ebx
    2702:	31 b2 31 01 52 00    	xor    %esi,0x520131(%rdx)
    2708:	04 fb                	add    $0xfb,%al
    270a:	30 80 31 02 30 9f    	xor    %al,-0x60cffdcf(%rax)
    2710:	00 04 9e             	add    %al,(%rsi,%rbx,4)
    2713:	31 be 31 02 30 9f    	xor    %edi,-0x60cffdcf(%rsi)
    2719:	04 be                	add    $0xbe,%al
    271b:	31 c7                	xor    %eax,%edi
    271d:	31 01                	xor    %eax,(%rcx)
    271f:	51                   	push   %rcx
    2720:	00 04 9e             	add    %al,(%rsi,%rbx,4)
    2723:	31 b2 31 01 52 00    	xor    %esi,0x520131(%rdx)
    2729:	04 ca                	add    $0xca,%al
    272b:	31 ef                	xor    %ebp,%edi
    272d:	31 03                	xor    %eax,(%rbx)
    272f:	77 10                	ja     2741 <_license+0x314>
    2731:	9f                   	lahf
    2732:	04 9b                	add    $0x9b,%al
    2734:	43 eb 43             	rex.XB jmp 277a <_license+0x34d>
    2737:	03 77 10             	add    0x10(%rdi),%esi
    273a:	9f                   	lahf
    273b:	04 9d                	add    $0x9d,%al
    273d:	45 ad                	rex.RB lods %ds:(%rsi),%eax
    273f:	45 03 77 10          	add    0x10(%r15),%r14d
    2743:	9f                   	lahf
    2744:	04 d3                	add    $0xd3,%al
    2746:	45 96                	rex.RB xchg %eax,%r14d
    2748:	46 03 77 10          	rex.RX add 0x10(%rdi),%r14d
    274c:	9f                   	lahf
    274d:	00 04 cf             	add    %al,(%rdi,%rcx,8)
    2750:	31 da                	xor    %ebx,%edx
    2752:	31 01                	xor    %eax,(%rcx)
    2754:	55                   	push   %rbp
    2755:	04 da                	add    $0xda,%al
    2757:	31 ef                	xor    %ebp,%edi
    2759:	31 02                	xor    %eax,(%rdx)
    275b:	77 08                	ja     2765 <_license+0x338>
    275d:	04 9b                	add    $0x9b,%al
    275f:	43 eb 43             	rex.XB jmp 27a5 <_license+0x378>
    2762:	02 77 08             	add    0x8(%rdi),%dh
    2765:	04 9d                	add    $0x9d,%al
    2767:	45 ad                	rex.RB lods %ds:(%rsi),%eax
    2769:	45 02 77 08          	add    0x8(%r15),%r14b
    276d:	04 d3                	add    $0xd3,%al
    276f:	45 84 46 02          	test   %r8b,0x2(%r14)
    2773:	77 08                	ja     277d <_license+0x350>
    2775:	04 84                	add    $0x84,%al
    2777:	46 96                	rex.RX xchg %eax,%esi
    2779:	46 01 55 00          	rex.RX add %r10d,0x0(%rbp)
    277d:	04 da                	add    $0xda,%al
    277f:	31 ef                	xor    %ebp,%edi
    2781:	31 01                	xor    %eax,(%rcx)
    2783:	50                   	push   %rax
    2784:	04 9b                	add    $0x9b,%al
    2786:	43 a5                	rex.XB movsl %ds:(%rsi),%es:(%rdi)
    2788:	43 01 50 04          	rex.XB add %edx,0x4(%r8)
    278c:	9d                   	popf
    278d:	45 ad                	rex.RB lods %ds:(%rsi),%eax
    278f:	45 01 50 00          	add    %r10d,0x0(%r8)
    2793:	04 ef                	add    $0xef,%al
    2795:	31 fb                	xor    %edi,%ebx
    2797:	31 03                	xor    %eax,(%rbx)
    2799:	11 01                	adc    %eax,(%rcx)
    279b:	9f                   	lahf
    279c:	04 9f                	add    $0x9f,%al
    279e:	45 d3 45 03          	rex.RB roll %cl,0x3(%r13)
    27a2:	11 01                	adc    %eax,(%rcx)
    27a4:	9f                   	lahf
    27a5:	04 96                	add    $0x96,%al
    27a7:	46 c4                	rex.RX (bad)
    27a9:	46 03 11             	rex.RX add (%rcx),%r10d
    27ac:	01 9f 00 04 b0 32    	add    %ebx,0x32b00400(%rdi)
    27b2:	fd                   	std
    27b3:	32 03                	xor    (%rbx),%al
    27b5:	77 10                	ja     27c7 <_license+0x39a>
    27b7:	9f                   	lahf
    27b8:	04 81                	add    $0x81,%al
    27ba:	33 ae 33 03 77 10    	xor    0x10770333(%rsi),%ebp
    27c0:	9f                   	lahf
    27c1:	00 04 c0             	add    %al,(%rax,%rax,8)
    27c4:	32 cb                	xor    %bl,%cl
    27c6:	32 01                	xor    (%rcx),%al
    27c8:	55                   	push   %rbp
    27c9:	04 cb                	add    $0xcb,%al
    27cb:	32 fd                	xor    %ch,%bh
    27cd:	32 02                	xor    (%rdx),%al
    27cf:	77 08                	ja     27d9 <_license+0x3ac>
    27d1:	04 81                	add    $0x81,%al
    27d3:	33 ae 33 02 77 08    	xor    0x8770233(%rsi),%ebp
    27d9:	00 04 b0             	add    %al,(%rax,%rsi,4)
    27dc:	32 fd                	xor    %ch,%bh
    27de:	32 02                	xor    (%rdx),%al
    27e0:	30 9f 04 81 33 ae    	xor    %bl,-0x51cc7efc(%rdi)
    27e6:	33 02                	xor    (%rdx),%eax
    27e8:	30 9f 00 04 cb 32    	xor    %bl,0x32cb0400(%rdi)
    27ee:	da 32                	fidivl (%rdx)
    27f0:	01 50 04             	add    %edx,0x4(%rax)
    27f3:	da 32                	fidivl (%rdx)
    27f5:	f9                   	stc
    27f6:	32 01                	xor    (%rcx),%al
    27f8:	56                   	push   %rsi
    27f9:	04 81                	add    $0x81,%al
    27fb:	33 ae 33 01 56 00    	xor    0x560133(%rsi),%ebp
    2801:	04 e3                	add    $0xe3,%al
    2803:	32 f9                	xor    %cl,%bh
    2805:	32 01                	xor    (%rcx),%al
    2807:	50                   	push   %rax
    2808:	04 81                	add    $0x81,%al
    280a:	33 85 33 01 50 00    	xor    0x500133(%rbp),%eax
    2810:	04 88                	add    $0x88,%al
    2812:	33 98 33 01 50 00    	xor    0x500133(%rax),%ebx
    2818:	04 88                	add    $0x88,%al
    281a:	33 98 33 01 50 00    	xor    0x500133(%rax),%ebx
    2820:	04 94                	add    $0x94,%al
    2822:	33 ae 33 02 30 9f    	xor    -0x60cffdcd(%rsi),%ebp
    2828:	00 04 b9             	add    %al,(%rcx,%rdi,4)
    282b:	33 ef                	xor    %edi,%ebp
    282d:	33 01                	xor    (%rcx),%eax
    282f:	55                   	push   %rbp
    2830:	04 ef                	add    $0xef,%al
    2832:	33 bb 35 01 5c 00    	xor    0x5c0135(%rbx),%edi
    2838:	04 ce                	add    $0xce,%al
    283a:	33 d5                	xor    %ebp,%edx
    283c:	33 02                	xor    (%rdx),%eax
    283e:	30 9f 04 d5 33 de    	xor    %bl,-0x21cc2afc(%rdi)
    2844:	33 01                	xor    (%rcx),%eax
    2846:	56                   	push   %rsi
    2847:	00 04 de             	add    %al,(%rsi,%rbx,8)
    284a:	33 c2                	xor    %edx,%eax
    284c:	34 01                	xor    $0x1,%al
    284e:	56                   	push   %rsi
    284f:	00 04 c2             	add    %al,(%rdx,%rax,8)
    2852:	34 ec                	xor    $0xec,%al
    2854:	34 02                	xor    $0x2,%al
    2856:	30 9f 04 ec 34 f1    	xor    %bl,-0xecb13fc(%rdi)
    285c:	34 01                	xor    $0x1,%al
    285e:	50                   	push   %rax
    285f:	00 04 cc             	add    %al,(%rsp,%rcx,8)
    2862:	34 d7                	xor    $0xd7,%al
    2864:	34 01                	xor    $0x1,%al
    2866:	55                   	push   %rbp
    2867:	00 04 ec             	add    %al,(%rsp,%rbp,8)
    286a:	34 ff                	xor    $0xff,%al
    286c:	34 01                	xor    $0x1,%al
    286e:	50                   	push   %rax
    286f:	00 04 f6             	add    %al,(%rsi,%rsi,8)
    2872:	34 ff                	xor    $0xff,%al
    2874:	34 01                	xor    $0x1,%al
    2876:	50                   	push   %rax
    2877:	00 04 f6             	add    %al,(%rsi,%rsi,8)
    287a:	34 ff                	xor    $0xff,%al
    287c:	34 01                	xor    $0x1,%al
    287e:	54                   	push   %rsp
    287f:	00 04 94             	add    %al,(%rsp,%rdx,4)
    2882:	35 a0 35 01 50       	xor    $0x500135a0,%eax
    2887:	00 04 99             	add    %al,(%rcx,%rbx,4)
    288a:	35 a0 35 02 30       	xor    $0x300235a0,%eax
    288f:	9f                   	lahf
    2890:	04 a0                	add    $0xa0,%al
    2892:	35 a9 35 01 50       	xor    $0x500135a9,%eax
    2897:	00 04 a9             	add    %al,(%rcx,%rbp,4)
    289a:	35 bb 35 01 50       	xor    $0x500135bb,%eax
    289f:	00 04 c4             	add    %al,(%rsp,%rax,8)
    28a2:	35 d8 35 02 30       	xor    $0x300235d8,%eax
    28a7:	9f                   	lahf
    28a8:	04 d8                	add    $0xd8,%al
    28aa:	35 e1 35 01 52       	xor    $0x520135e1,%eax
    28af:	00 04 80             	add    %al,(%rax,%rax,4)
    28b2:	36 a3 36 02 30 9f 04 	ss movabs %eax,0xac36a3049f300236
    28b9:	a3 36 ac 
    28bc:	36 01 52 00          	ss add %edx,0x0(%rdx)
    28c0:	04 8b                	add    $0x8b,%al
    28c2:	36 b5 36             	ss mov $0x36,%ch
    28c5:	04 10                	add    $0x10,%al
    28c7:	80 20 9f             	andb   $0x9f,(%rax)
    28ca:	00 04 8b             	add    %al,(%rbx,%rcx,4)
    28cd:	36 b5 36             	ss mov $0x36,%ch
    28d0:	02 38                	add    (%rax),%bh
    28d2:	9f                   	lahf
    28d3:	00 04 ab             	add    %al,(%rbx,%rbp,4)
    28d6:	37                   	(bad)
    28d7:	a1 38 0e 7e 00 10 ff 	movabs 0xffffff10007e0e38,%eax
    28de:	ff ff 
    28e0:	ff 0f                	decl   (%rdi)
    28e2:	1a 10                	sbb    (%rax),%dl
    28e4:	ac                   	lods   %ds:(%rsi),%al
    28e5:	21 21                	and    %esp,(%rcx)
    28e7:	9f                   	lahf
    28e8:	00 04 d9             	add    %al,(%rcx,%rbx,8)
    28eb:	36 aa                	ss stos %al,%es:(%rdi)
    28ed:	38 02                	cmp    %al,(%rdx)
    28ef:	30 9f 00 04 f6 36    	xor    %bl,0x36f60400(%rdi)
    28f5:	aa                   	stos   %al,%es:(%rdi)
    28f6:	38 01                	cmp    %al,(%rcx)
    28f8:	50                   	push   %rax
    28f9:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    28fc:	36 a0 37 01 52 00 04 	ss movabs 0xaa36fa0400520137,%al
    2903:	fa 36 aa 
    2906:	38 01                	cmp    %al,(%rcx)
    2908:	50                   	push   %rax
    2909:	00 04 fe             	add    %al,(%rsi,%rdi,8)
    290c:	36 aa                	ss stos %al,%es:(%rdi)
    290e:	38 03                	cmp    %al,(%rbx)
    2910:	70 14                	jo     2926 <_license+0x4f9>
    2912:	9f                   	lahf
    2913:	00 04 e9             	add    %al,(%rcx,%rbp,8)
    2916:	37                   	(bad)
    2917:	a1 38 0e 7e 00 10 ff 	movabs 0xffffff10007e0e38,%eax
    291e:	ff ff 
    2920:	ff 0f                	decl   (%rdi)
    2922:	1a 10                	sbb    (%rax),%dl
    2924:	ac                   	lods   %ds:(%rsi),%al
    2925:	21 21                	and    %esp,(%rcx)
    2927:	9f                   	lahf
    2928:	00 04 e9             	add    %al,(%rcx,%rbp,8)
    292b:	37                   	(bad)
    292c:	95                   	xchg   %eax,%ebp
    292d:	38 01                	cmp    %al,(%rcx)
    292f:	51                   	push   %rcx
    2930:	00 04 91             	add    %al,(%rcx,%rdx,4)
    2933:	38 95 38 03 11 00    	cmp    %dl,0x110338(%rbp)
    2939:	9f                   	lahf
    293a:	04 95                	add    $0x95,%al
    293c:	38 99 38 03 11 01    	cmp    %bl,0x1110338(%rcx)
    2942:	9f                   	lahf
    2943:	04 99                	add    $0x99,%al
    2945:	38 9d 38 03 11 04    	cmp    %bl,0x4110338(%rbp)
    294b:	9f                   	lahf
    294c:	04 9d                	add    $0x9d,%al
    294e:	38 a1 38 03 11 07    	cmp    %ah,0x7110338(%rcx)
    2954:	9f                   	lahf
    2955:	04 a1                	add    $0xa1,%al
    2957:	38 a7 38 03 11 08    	cmp    %ah,0x8110338(%rdi)
    295d:	9f                   	lahf
    295e:	04 a7                	add    $0xa7,%al
    2960:	38 aa 38 03 11 09    	cmp    %ch,0x9110338(%rdx)
    2966:	9f                   	lahf
    2967:	00 04 91             	add    %al,(%rcx,%rdx,4)
    296a:	38 95 38 05 70 0e    	cmp    %dl,0xe700538(%rbp)
    2970:	23 02                	and    (%rdx),%eax
    2972:	9f                   	lahf
    2973:	04 95                	add    $0x95,%al
    2975:	38 99 38 05 70 0e    	cmp    %bl,0xe700538(%rcx)
    297b:	23 04 9f             	and    (%rdi,%rbx,4),%eax
    297e:	04 99                	add    $0x99,%al
    2980:	38 9d 38 05 70 0e    	cmp    %bl,0xe700538(%rbp)
    2986:	23 0a                	and    (%rdx),%ecx
    2988:	9f                   	lahf
    2989:	04 9d                	add    $0x9d,%al
    298b:	38 a1 38 05 70 0e    	cmp    %ah,0xe700538(%rcx)
    2991:	23 10                	and    (%rax),%edx
    2993:	9f                   	lahf
    2994:	04 a1                	add    $0xa1,%al
    2996:	38 a7 38 05 70 0e    	cmp    %ah,0xe700538(%rdi)
    299c:	23 12                	and    (%rdx),%edx
    299e:	9f                   	lahf
    299f:	04 a7                	add    $0xa7,%al
    29a1:	38 aa 38 07 70 0e    	cmp    %ch,0xe700738(%rdx)
    29a7:	23 12                	and    (%rdx),%edx
    29a9:	23 02                	and    (%rdx),%eax
    29ab:	9f                   	lahf
    29ac:	00 04 ae             	add    %al,(%rsi,%rbp,4)
    29af:	39 b5 39 02 30 9f    	cmp    %esi,-0x60cffdc7(%rbp)
    29b5:	04 b5                	add    $0xb5,%al
    29b7:	39 be 39 01 50 00    	cmp    %edi,0x500139(%rsi)
    29bd:	04 be                	add    $0xbe,%al
    29bf:	39 d8                	cmp    %ebx,%eax
    29c1:	39 01                	cmp    %eax,(%rcx)
    29c3:	50                   	push   %rax
    29c4:	00 04 d8             	add    %al,(%rax,%rbx,8)
    29c7:	39 ba 3e 03 77 10    	cmp    %edi,0x1077033e(%rdx)
    29cd:	9f                   	lahf
    29ce:	04 db                	add    $0xdb,%al
    29d0:	3e f8                	ds clc
    29d2:	3e 03 77 10          	ds add 0x10(%rdi),%esi
    29d6:	9f                   	lahf
    29d7:	04 c2                	add    $0xc2,%al
    29d9:	40 ed                	rex in (%dx),%eax
    29db:	40 03 77 10          	rex add 0x10(%rdi),%esi
    29df:	9f                   	lahf
    29e0:	00 04 d8             	add    %al,(%rax,%rbx,8)
    29e3:	39 ba 3e 02 31 9f    	cmp    %edi,-0x60cefdc2(%rdx)
    29e9:	04 db                	add    $0xdb,%al
    29eb:	3e f8                	ds clc
    29ed:	3e 02 31             	ds add (%rcx),%dh
    29f0:	9f                   	lahf
    29f1:	04 c2                	add    $0xc2,%al
    29f3:	40 ed                	rex in (%dx),%eax
    29f5:	40 02 31             	add    (%rcx),%sil
    29f8:	9f                   	lahf
    29f9:	00 04 d8             	add    %al,(%rax,%rbx,8)
    29fc:	39 ba 3e 02 77 08    	cmp    %edi,0x877023e(%rdx)
    2a02:	04 db                	add    $0xdb,%al
    2a04:	3e f8                	ds clc
    2a06:	3e 02 77 08          	ds add 0x8(%rdi),%dh
    2a0a:	04 c2                	add    $0xc2,%al
    2a0c:	40 d7                	rex xlat %ds:(%rbx)
    2a0e:	40 02 77 08          	add    0x8(%rdi),%sil
    2a12:	04 d7                	add    $0xd7,%al
    2a14:	40 e9 40 01 55 00    	rex jmp 552b5a <_license+0x55072d>
    2a1a:	04 ef                	add    $0xef,%al
    2a1c:	39 cd                	cmp    %ecx,%ebp
    2a1e:	3a 02                	cmp    (%rdx),%al
    2a20:	30 9f 04 cd 3a ba    	xor    %bl,-0x45c532fc(%rdi)
    2a26:	3e 11 7f 00          	ds adc %edi,0x0(%rdi)
    2a2a:	10 ff                	adc    %bh,%bh
    2a2c:	01 1a                	add    %ebx,(%rdx)
    2a2e:	a8 ba                	test   $0xba,%al
    2a30:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    2a37:	00 9f 04 db 3e f2    	add    %bl,-0xdc124fc(%rdi)
    2a3d:	3e 11 7f 00          	ds adc %edi,0x0(%rdi)
    2a41:	10 ff                	adc    %bh,%bh
    2a43:	01 1a                	add    %ebx,(%rdx)
    2a45:	a8 ba                	test   $0xba,%al
    2a47:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    2a4e:	00 9f 00 04 ef 39    	add    %bl,0x39ef0400(%rdi)
    2a54:	ba 3e 02 30 9f       	mov    $0x9f30023e,%edx
    2a59:	04 db                	add    $0xdb,%al
    2a5b:	3e f8                	ds clc
    2a5d:	3e 02 30             	ds add (%rax),%dh
    2a60:	9f                   	lahf
    2a61:	04 c2                	add    $0xc2,%al
    2a63:	40 ed                	rex in (%dx),%eax
    2a65:	40 02 30             	add    (%rax),%sil
    2a68:	9f                   	lahf
    2a69:	00 04 ef             	add    %al,(%rdi,%rbp,8)
    2a6c:	39 ba 3e 02 30 9f    	cmp    %edi,-0x60cffdc2(%rdx)
    2a72:	04 db                	add    $0xdb,%al
    2a74:	3e f8                	ds clc
    2a76:	3e 02 30             	ds add (%rax),%dh
    2a79:	9f                   	lahf
    2a7a:	04 c2                	add    $0xc2,%al
    2a7c:	40 c9                	rex leave
    2a7e:	40 02 30             	add    (%rax),%sil
    2a81:	9f                   	lahf
    2a82:	04 c9                	add    $0xc9,%al
    2a84:	40 ce                	rex (bad)
    2a86:	40 01 50 00          	rex add %edx,0x0(%rax)
    2a8a:	04 ef                	add    $0xef,%al
    2a8c:	39 f6                	cmp    %esi,%esi
    2a8e:	39 02                	cmp    %eax,(%rdx)
    2a90:	30 9f 04 f6 39 87    	xor    %bl,-0x78c609fc(%rdi)
    2a96:	3a 01                	cmp    (%rcx),%al
    2a98:	53                   	push   %rbx
    2a99:	00 04 ff             	add    %al,(%rdi,%rdi,8)
    2a9c:	39 c7                	cmp    %eax,%edi
    2a9e:	3a 01                	cmp    (%rcx),%al
    2aa0:	53                   	push   %rbx
    2aa1:	00 04 cd 3a ee 3d 02 	add    %al,0x23dee3a(,%rcx,8)
    2aa8:	31 9f 04 9b 3e ba    	xor    %ebx,-0x45c164fc(%rdi)
    2aae:	3e 02 31             	ds add (%rcx),%dh
    2ab1:	9f                   	lahf
    2ab2:	00 04 ad 3b b2 3b 01 	add    %al,0x13bb23b(,%rbp,4)
    2ab9:	53                   	push   %rbx
    2aba:	04 b4                	add    $0xb4,%al
    2abc:	3b c4                	cmp    %esp,%eax
    2abe:	3b 0c 10             	cmp    (%rax,%rdx,1),%ecx
    2ac1:	ff 81 b7 f5 fd ff    	incl   -0x20a49(%rcx)
    2ac7:	ff                   	(bad)
    2ac8:	ff                   	(bad)
    2ac9:	ff 01                	incl   (%rcx)
    2acb:	9f                   	lahf
    2acc:	04 c4                	add    $0xc4,%al
    2ace:	3b cf                	cmp    %edi,%ecx
    2ad0:	3b 01                	cmp    (%rcx),%eax
    2ad2:	54                   	push   %rsp
    2ad3:	04 d6                	add    $0xd6,%al
    2ad5:	3b d8                	cmp    %eax,%ebx
    2ad7:	3b 01                	cmp    (%rcx),%eax
    2ad9:	54                   	push   %rsp
    2ada:	04 d8                	add    $0xd8,%al
    2adc:	3b f9                	cmp    %ecx,%edi
    2ade:	3b 01                	cmp    (%rcx),%eax
    2ae0:	52                   	push   %rdx
    2ae1:	04 a8                	add    $0xa8,%al
    2ae3:	3c d8                	cmp    $0xd8,%al
    2ae5:	3c 01                	cmp    $0x1,%al
    2ae7:	52                   	push   %rdx
    2ae8:	00 04 af             	add    %al,(%rdi,%rbp,4)
    2aeb:	3b b4 3b 01 51 04 cf 	cmp    -0x30fbaeff(%rbx,%rdi,1),%esi
    2af2:	3b e3                	cmp    %ebx,%esp
    2af4:	3b 01                	cmp    (%rcx),%eax
    2af6:	53                   	push   %rbx
    2af7:	04 e3                	add    $0xe3,%al
    2af9:	3b 82 3c 01 54 04    	cmp    0x454013c(%rdx),%eax
    2aff:	9c                   	pushf
    2b00:	3c d1                	cmp    $0xd1,%al
    2b02:	3c 01                	cmp    $0x1,%al
    2b04:	51                   	push   %rcx
    2b05:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    2b08:	3b d6                	cmp    %esi,%edx
    2b0a:	3d 03 77 10 9f       	cmp    $0x9f107703,%eax
    2b0f:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    2b12:	3b d6                	cmp    %esi,%edx
    2b14:	3d 02 31 9f 00       	cmp    $0x9f3102,%eax
    2b19:	04 b4                	add    $0xb4,%al
    2b1b:	3b d6                	cmp    %esi,%edx
    2b1d:	3d 04 10 80 04       	cmp    $0x4801004,%eax
    2b22:	9f                   	lahf
    2b23:	00 04 b4             	add    %al,(%rsp,%rsi,4)
    2b26:	3b bc 3b 0c 10 ff 81 	cmp    -0x7e00eff4(%rbx,%rdi,1),%edi
    2b2d:	b7 f5                	mov    $0xf5,%bh
    2b2f:	fd                   	std
    2b30:	ff                   	(bad)
    2b31:	ff                   	(bad)
    2b32:	ff                   	(bad)
    2b33:	ff 01                	incl   (%rcx)
    2b35:	9f                   	lahf
    2b36:	04 bc                	add    $0xbc,%al
    2b38:	3b cd                	cmp    %ebp,%ecx
    2b3a:	3b 01                	cmp    (%rcx),%eax
    2b3c:	51                   	push   %rcx
    2b3d:	04 cd                	add    $0xcd,%al
    2b3f:	3b ee                	cmp    %esi,%ebp
    2b41:	3b 01                	cmp    (%rcx),%eax
    2b43:	55                   	push   %rbp
    2b44:	04 ee                	add    $0xee,%al
    2b46:	3b d8                	cmp    %eax,%ebx
    2b48:	3c 01                	cmp    $0x1,%al
    2b4a:	53                   	push   %rbx
    2b4b:	00 04 fb             	add    %al,(%rbx,%rdi,8)
    2b4e:	3b d6                	cmp    %esi,%edx
    2b50:	3d 05 77 10 23       	cmp    $0x23107705,%eax
    2b55:	0c 9f                	or     $0x9f,%al
    2b57:	00 04 e9             	add    %al,(%rcx,%rbp,8)
    2b5a:	3c a1                	cmp    $0xa1,%al
    2b5c:	3d 01 52 00 04       	cmp    $0x4005201,%eax
    2b61:	e3 3c                	jrcxz  2b9f <_license+0x772>
    2b63:	a8 3d                	test   $0x3d,%al
    2b65:	01 54 00 04          	add    %edx,0x4(%rax,%rax,1)
    2b69:	d8 3c e3             	fdivrs (%rbx,%riz,8)
    2b6c:	3c 02                	cmp    $0x2,%al
    2b6e:	30 9f 04 e3 3c f1    	xor    %bl,-0xec31cfc(%rdi)
    2b74:	3c 0c                	cmp    $0xc,%al
    2b76:	10 f7                	adc    %dh,%bh
    2b78:	81 b7 85 fe ff ff ff 	xorl   $0x9f01ffff,-0x17b(%rdi)
    2b7f:	ff 01 9f 
    2b82:	04 f1                	add    $0xf1,%al
    2b84:	3c c0                	cmp    $0xc0,%al
    2b86:	3d 01 51 00 04       	cmp    $0x4005101,%eax
    2b8b:	c0 3d e2 3d 01 51 00 	sarb   $0x0,0x51013de2(%rip)        # 51016974 <_license+0x51014547>
    2b92:	04 ce                	add    $0xce,%al
    2b94:	3d d8 3d 01 52       	cmp    $0x52013dd8,%eax
    2b99:	04 e9                	add    $0xe9,%al
    2b9b:	3d ba 3e 01 56       	cmp    $0x56013eba,%eax
    2ba0:	04 db                	add    $0xdb,%al
    2ba2:	3e f8                	ds clc
    2ba4:	3e 01 56 04          	ds add %edx,0x4(%rsi)
    2ba8:	c2 40 ed             	ret    $0xed40
    2bab:	40 01 56 00          	rex add %edx,0x0(%rsi)
    2baf:	04 ce                	add    $0xce,%al
    2bb1:	3d d8 3d 01 52       	cmp    $0x52013dd8,%eax
    2bb6:	00 04 ce             	add    %al,(%rsi,%rcx,8)
    2bb9:	3d d4 3d 02 30       	cmp    $0x30023dd4,%eax
    2bbe:	9f                   	lahf
    2bbf:	00 04 f2             	add    %al,(%rdx,%rsi,8)
    2bc2:	3d f8 3d 02 30       	cmp    $0x30023df8,%eax
    2bc7:	9f                   	lahf
    2bc8:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    2bcb:	3d 8b 3e 02 30       	cmp    $0x30023e8b,%eax
    2bd0:	9f                   	lahf
    2bd1:	04 8b                	add    $0x8b,%al
    2bd3:	3e 94                	ds xchg %eax,%esp
    2bd5:	3e 01 50 00          	ds add %edx,0x0(%rax)
    2bd9:	04 94                	add    $0x94,%al
    2bdb:	3e 9b                	ds fwait
    2bdd:	3e 01 50 00          	ds add %edx,0x0(%rax)
    2be1:	04 9b                	add    $0x9b,%al
    2be3:	3e ac                	lods   %ds:(%rsi),%al
    2be5:	3e 02 30             	ds add (%rax),%dh
    2be8:	9f                   	lahf
    2be9:	04 ac                	add    $0xac,%al
    2beb:	3e b5 3e             	ds mov $0x3e,%ch
    2bee:	01 50 00             	add    %edx,0x0(%rax)
    2bf1:	04 b5                	add    $0xb5,%al
    2bf3:	3e ba 3e 01 50 00    	ds mov $0x50013e,%edx
    2bf9:	04 98                	add    $0x98,%al
    2bfb:	3f                   	(bad)
    2bfc:	b5 40                	mov    $0x40,%ch
    2bfe:	01 50 00             	add    %edx,0x0(%rax)
    2c01:	04 9c                	add    $0x9c,%al
    2c03:	3f                   	(bad)
    2c04:	bd 3f 01 52 00       	mov    $0x52013f,%ebp
    2c09:	04 9c                	add    $0x9c,%al
    2c0b:	3f                   	(bad)
    2c0c:	b5 40                	mov    $0x40,%ch
    2c0e:	01 50 00             	add    %edx,0x0(%rax)
    2c11:	04 a0                	add    $0xa0,%al
    2c13:	3f                   	(bad)
    2c14:	a9 3f 01 51 00       	test   $0x51013f,%eax
    2c19:	04 a0                	add    $0xa0,%al
    2c1b:	3f                   	(bad)
    2c1c:	b5 40                	mov    $0x40,%ch
    2c1e:	03 70 28             	add    0x28(%rax),%esi
    2c21:	9f                   	lahf
    2c22:	00 04 e9             	add    %al,(%rcx,%rbp,8)
    2c25:	3f                   	(bad)
    2c26:	b5 40                	mov    $0x40,%ch
    2c28:	03 10                	add    (%rax),%edx
    2c2a:	29 9f 00 04 e9 3f    	sub    %ebx,0x3fe90400(%rdi)
    2c30:	ed                   	in     (%dx),%eax
    2c31:	3f                   	(bad)
    2c32:	0c 31                	or     $0x31,%al
    2c34:	9f                   	lahf
    2c35:	93                   	xchg   %eax,%ebx
    2c36:	04 30                	add    $0x30,%al
    2c38:	9f                   	lahf
    2c39:	93                   	xchg   %eax,%ebx
    2c3a:	04 30                	add    $0x30,%al
    2c3c:	9f                   	lahf
    2c3d:	93                   	xchg   %eax,%ebx
    2c3e:	04 04                	add    $0x4,%al
    2c40:	ed                   	in     (%dx),%eax
    2c41:	3f                   	(bad)
    2c42:	b5 40                	mov    $0x40,%ch
    2c44:	0f 31                	rdtsc
    2c46:	9f                   	lahf
    2c47:	93                   	xchg   %eax,%ebx
    2c48:	04 30                	add    $0x30,%al
    2c4a:	9f                   	lahf
    2c4b:	93                   	xchg   %eax,%ebx
    2c4c:	04 30                	add    $0x30,%al
    2c4e:	9f                   	lahf
    2c4f:	93                   	xchg   %eax,%ebx
    2c50:	04 54                	add    $0x54,%al
    2c52:	93                   	xchg   %eax,%ebx
    2c53:	04 00                	add    $0x0,%al
    2c55:	04 f1                	add    $0xf1,%al
    2c57:	3f                   	(bad)
    2c58:	97                   	xchg   %eax,%edi
    2c59:	40 01 5f 00          	rex add %ebx,0x0(%rdi)
    2c5d:	04 f1                	add    $0xf1,%al
    2c5f:	3f                   	(bad)
    2c60:	97                   	xchg   %eax,%edi
    2c61:	40 01 5f 00          	rex add %ebx,0x0(%rdi)
    2c65:	04 f5                	add    $0xf5,%al
    2c67:	3f                   	(bad)
    2c68:	89 40 01             	mov    %eax,0x1(%rax)
    2c6b:	52                   	push   %rdx
    2c6c:	00 04 cd 41 da 41 01 	add    %al,0x141da41(,%rcx,8)
    2c73:	50                   	push   %rax
    2c74:	00 04 cd 41 ec 41 02 	add    %al,0x241ec41(,%rcx,8)
    2c7b:	30 9f 04 ec 41 f5    	xor    %bl,-0xabe13fc(%rdi)
    2c81:	41 01 50 00          	add    %edx,0x0(%r8)
    2c85:	04 cd                	add    $0xcd,%al
    2c87:	41 da 41 01          	fiaddl 0x1(%r9)
    2c8b:	50                   	push   %rax
    2c8c:	00 04 f5 41 81 42 01 	add    %al,0x1428141(,%rsi,8)
    2c93:	50                   	push   %rax
    2c94:	00 04 fd 42 85 43 03 	add    %al,0x3438542(,%rdi,8)
    2c9b:	50                   	push   %rax
    2c9c:	93                   	xchg   %eax,%ebx
    2c9d:	04 04                	add    $0x4,%al
    2c9f:	85 43 94             	test   %eax,-0x6c(%rbx)
    2ca2:	43 06                	rex.XB (bad)
    2ca4:	50                   	push   %rax
    2ca5:	93                   	xchg   %eax,%ebx
    2ca6:	04 51                	add    $0x51,%al
    2ca8:	93                   	xchg   %eax,%ebx
    2ca9:	01 04 fe             	add    %eax,(%rsi,%rdi,8)
    2cac:	43 b2 44             	rex.XB mov $0x44,%r10b
    2caf:	06                   	(bad)
    2cb0:	50                   	push   %rax
    2cb1:	93                   	xchg   %eax,%ebx
    2cb2:	04 51                	add    $0x51,%al
    2cb4:	93                   	xchg   %eax,%ebx
    2cb5:	01 04 b2             	add    %eax,(%rdx,%rsi,4)
    2cb8:	44 dd 44 05 93       	rex.R fldl -0x6d(%rbp,%rax,1)
    2cbd:	04 51                	add    $0x51,%al
    2cbf:	93                   	xchg   %eax,%ebx
    2cc0:	01 04 fe             	add    %eax,(%rsi,%rdi,8)
    2cc3:	44 85 45 06          	test   %r8d,0x6(%rbp)
    2cc7:	50                   	push   %rax
    2cc8:	93                   	xchg   %eax,%ebx
    2cc9:	04 51                	add    $0x51,%al
    2ccb:	93                   	xchg   %eax,%ebx
    2ccc:	01 04 85 45 93 45 05 	add    %eax,0x5459345(,%rax,4)
    2cd3:	93                   	xchg   %eax,%ebx
    2cd4:	04 51                	add    $0x51,%al
    2cd6:	93                   	xchg   %eax,%ebx
    2cd7:	01 00                	add    %eax,(%rax)
    2cd9:	04 85                	add    $0x85,%al
    2cdb:	43 94                	rex.XB xchg %eax,%r12d
    2cdd:	43 01 56 04          	rex.XB add %edx,0x4(%r14)
    2ce1:	fe 43 8b             	incb   -0x75(%rbx)
    2ce4:	44 01 56 00          	add    %r10d,0x0(%rsi)
    2ce8:	04 85                	add    $0x85,%al
    2cea:	43 94                	rex.XB xchg %eax,%r12d
    2cec:	43 01 51 04          	rex.XB add %edx,0x4(%r9)
    2cf0:	fe 43 8b             	incb   -0x75(%rbx)
    2cf3:	44 01 51 00          	add    %r10d,0x0(%rcx)
    2cf7:	04 9b                	add    $0x9b,%al
    2cf9:	43 eb 43             	rex.XB jmp 2d3f <_license+0x912>
    2cfc:	04 10                	add    $0x10,%al
    2cfe:	82                   	(bad)
    2cff:	04 9f                	add    $0x9f,%al
    2d01:	04 d3                	add    $0xd3,%al
    2d03:	45 e5 45             	rex.RB in $0x45,%eax
    2d06:	04 10                	add    $0x10,%al
    2d08:	82                   	(bad)
    2d09:	04 9f                	add    $0x9f,%al
    2d0b:	00 04 9b             	add    %al,(%rbx,%rbx,4)
    2d0e:	43 ac                	rex.XB lods %ds:(%rsi),%al
    2d10:	43 02 30             	rex.XB add (%r8),%sil
    2d13:	9f                   	lahf
    2d14:	04 ac                	add    $0xac,%al
    2d16:	43 b5 43             	rex.XB mov $0x43,%r13b
    2d19:	01 5e 00             	add    %ebx,0x0(%rsi)
    2d1c:	04 b5                	add    $0xb5,%al
    2d1e:	43 eb 43             	rex.XB jmp 2d64 <_license+0x937>
    2d21:	01 5e 04             	add    %ebx,0x4(%rsi)
    2d24:	d3 45 e5             	roll   %cl,-0x1b(%rbp)
    2d27:	45 01 5e 00          	add    %r11d,0x0(%r14)
    2d2b:	04 84                	add    $0x84,%al
    2d2d:	44 9c                	rex.R pushf
    2d2f:	44 01 50 04          	add    %r10d,0x4(%rax)
    2d33:	9c                   	pushf
    2d34:	44 bc 44 01 52 00    	rex.R mov $0x520144,%esp
    2d3a:	04 84                	add    $0x84,%al
    2d3c:	44 89 44 02 30       	mov    %r8d,0x30(%rdx,%rax,1)
    2d41:	9f                   	lahf
    2d42:	00 04 a8             	add    %al,(%rax,%rbp,4)
    2d45:	44 c8 44 02 30       	rex.R enter $0x244,$0x30
    2d4a:	9f                   	lahf
    2d4b:	04 c8                	add    $0xc8,%al
    2d4d:	44 cd 44             	rex.R int $0x44
    2d50:	01 5e 00             	add    %ebx,0x0(%rsi)
    2d53:	04 a8                	add    $0xa8,%al
    2d55:	44 bc 44 01 52 00    	rex.R mov $0x520144,%esp
    2d5b:	04 cd                	add    $0xcd,%al
    2d5d:	44                   	rex.R
    2d5e:	f2 44 03 77 10       	repnz add 0x10(%rdi),%r14d
    2d63:	9f                   	lahf
    2d64:	04 c4                	add    $0xc4,%al
    2d66:	46 a1 47 03 77 10 9f 	rex.RX movabs 0x47cf049f10770347,%eax
    2d6d:	04 cf 47 
    2d70:	92                   	xchg   %eax,%edx
    2d71:	48 03 77 10          	add    0x10(%rdi),%rsi
    2d75:	9f                   	lahf
    2d76:	00 04 d2             	add    %al,(%rdx,%rdx,8)
    2d79:	44 dd 44 01 55       	rex.R fldl 0x55(%rcx,%rax,1)
    2d7e:	04 dd                	add    $0xdd,%al
    2d80:	44                   	rex.R
    2d81:	f2 44 03 77 d0       	repnz add -0x30(%rdi),%r14d
    2d86:	00 04 c4             	add    %al,(%rsp,%rax,8)
    2d89:	46 a1 47 03 77 d0 00 	rex.RX movabs 0x47cf0400d0770347,%eax
    2d90:	04 cf 47 
    2d93:	80 48 03 77          	orb    $0x77,0x3(%rax)
    2d97:	d0 00                	rolb   (%rax)
    2d99:	04 80                	add    $0x80,%al
    2d9b:	48 92                	xchg   %rax,%rdx
    2d9d:	48 01 55 00          	add    %rdx,0x0(%rbp)
    2da1:	04 dd                	add    $0xdd,%al
    2da3:	44                   	rex.R
    2da4:	f2 44 01 50 04       	repnz add %r10d,0x4(%rax)
    2da9:	c4                   	(bad)
    2daa:	46 ce                	rex.RX (bad)
    2dac:	46 01 50 04          	rex.RX add %r10d,0x4(%rax)
    2db0:	8d 47 a1             	lea    -0x5f(%rdi),%eax
    2db3:	47 01 50 00          	rex.RXB add %r10d,0x0(%r8)
    2db7:	04 f2                	add    $0xf2,%al
    2db9:	44 fe 44 03 11       	rex.R incb 0x11(%rbx,%rax,1)
    2dbe:	01 9f 04 8f 47 cf    	add    %ebx,-0x30b870fc(%rdi)
    2dc4:	47 03 11             	rex.RXB add (%r9),%r10d
    2dc7:	01 9f 04 92 48 ad    	add    %ebx,-0x52b76dfc(%rdi)
    2dcd:	48 03 11             	add    (%rcx),%rdx
    2dd0:	01 9f 00 04 a4 45    	add    %ebx,0x45a40400(%rdi)
    2dd6:	bf 45 02 30 9f       	mov    $0x9f300245,%edi
    2ddb:	04 bf                	add    $0xbf,%al
    2ddd:	45 c8 45 01 50       	rex.RB enter $0x145,$0x50
    2de2:	00 04 c8             	add    %al,(%rax,%rcx,8)
    2de5:	45 d1 45 01          	rex.RB roll 0x1(%r13)
    2de9:	50                   	push   %rax
    2dea:	00 04 91             	add    %al,(%rcx,%rdx,4)
    2ded:	46 96                	rex.RX xchg %eax,%esi
    2def:	46 04 77             	rex.RX add $0x77,%al
    2df2:	c0 00 9f             	rolb   $0x9f,(%rax)
    2df5:	00 04 ab             	add    %al,(%rbx,%rbp,4)
    2df8:	46 b2 46             	rex.RX mov $0x46,%dl
    2dfb:	01 50 04             	add    %edx,0x4(%rax)
    2dfe:	b2 46                	mov    $0x46,%dl
    2e00:	c4                   	(bad)
    2e01:	46 03 77 80          	rex.RX add -0x80(%rdi),%r14d
    2e05:	01 00                	add    %eax,(%rax)
    2e07:	04 c4                	add    $0xc4,%al
    2e09:	46 8d 47 04          	rex.RX lea 0x4(%rdi),%r8d
    2e0d:	10 82 04 9f 04 cf    	adc    %al,-0x30fb60fc(%rdx)
    2e13:	47 e1 47             	rex.RXB loope 2e5d <_license+0xa30>
    2e16:	04 10                	add    $0x10,%al
    2e18:	82                   	(bad)
    2e19:	04 9f                	add    $0x9f,%al
    2e1b:	00 04 c4             	add    %al,(%rsp,%rax,8)
    2e1e:	46 d5                	rex.RX (bad)
    2e20:	46 02 30             	rex.RX add (%rax),%r14b
    2e23:	9f                   	lahf
    2e24:	04 d5                	add    $0xd5,%al
    2e26:	46 de 46 01          	rex.RX fiadds 0x1(%rsi)
    2e2a:	53                   	push   %rbx
    2e2b:	00 04 de             	add    %al,(%rsi,%rbx,8)
    2e2e:	46 8d 47 01          	rex.RX lea 0x1(%rdi),%r8d
    2e32:	53                   	push   %rbx
    2e33:	04 cf                	add    $0xcf,%al
    2e35:	47 e1 47             	rex.RXB loope 2e7f <_license+0xa52>
    2e38:	01 53 00             	add    %edx,0x0(%rbx)
    2e3b:	04 94                	add    $0x94,%al
    2e3d:	47 bb 47 02 30 9f    	rex.RXB mov $0x9f300247,%r11d
    2e43:	04 bb                	add    $0xbb,%al
    2e45:	47 c4                	rex.RXB (bad)
    2e47:	47 01 50 00          	rex.RXB add %r10d,0x0(%r8)
    2e4b:	04 c4                	add    $0xc4,%al
    2e4d:	47 cd 47             	rex.RXB int $0x47
    2e50:	01 50 00             	add    %edx,0x0(%rax)
    2e53:	04 8d                	add    $0x8d,%al
    2e55:	48 92                	xchg   %rax,%rdx
    2e57:	48 04 77             	rex.W add $0x77,%al
    2e5a:	c0 00 9f             	rolb   $0x9f,(%rax)
    2e5d:	00 04 a8             	add    %al,(%rax,%rbp,4)
    2e60:	48 ad                	lods   %ds:(%rsi),%rax
    2e62:	48                   	rex.W
    2e63:	01                   	.byte 0x1
    2e64:	5c                   	pop    %rsp
	...

Disassembly of section .debug_abbrev:

0000000000000000 <.debug_abbrev>:
  void* data = (void*)(long)ctx->data;
   0:	01 11                	add    %edx,(%rcx)
   2:	01 25 25 13 05 03    	add    %esp,0x3051325(%rip)        # 305132d <_license+0x304ef00>
   8:	25 72 17 10 17       	and    $0x17101772,%eax
   d:	1b 25 11 1b 12 06    	sbb    0x6121b11(%rip),%esp        # 6121b24 <_license+0x611f6f7>
  13:	73 17                	jae    2c <balancer_ingress+0x2c>
  15:	74 17                	je     2e <balancer_ingress+0x2e>
  17:	8c 01                	mov    %es,(%rcx)
  void* data_end = (void*)(long)ctx->data_end;
  19:	17                   	(bad)
  1a:	00 00                	add    %al,(%rax)
  if (data + nh_off > data_end) {
  1c:	02 24 00             	add    (%rax,%rax,1),%ah
  1f:	03 26                	add    (%rsi),%esp
  21:	3e 0b 0b             	ds or  (%rbx),%ecx
  24:	0b 00                	or     (%rax),%eax
  26:	00 03                	add    %al,(%rbx)
  28:	34 00                	xor    $0x0,%al
  2a:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f1379 <_license+0x193eef4c>
  30:	3a 0b                	cmp    (%rbx),%cl
  eth_proto = eth->h_proto;
  32:	3b 05 02 18 00 00    	cmp    0x1802(%rip),%eax        # 183a <balancer_ingress+0x183a>
  if (eth_proto == BE_ETH_P_IP) {
  38:	04 01                	add    $0x1,%al
  3a:	01 49 13             	add    %ecx,0x13(%rcx)
  3d:	00 00                	add    %al,(%rax)
  3f:	05 21 00 49 13       	add    $0x13490021,%eax
  44:	37                   	(bad)
  45:	0b 00                	or     (%rax),%eax
  47:	00 06                	add    %al,(%rsi)
  49:	24 00                	and    $0x0,%al
  4b:	03 25 3e 0b 0b 0b    	add    0xb0b0b3e(%rip),%esp        # b0b0b8f <_license+0xb0ae762>
  struct packet_description pckt = {};
  51:	00 00                	add    %al,(%rax)
  53:	07                   	(bad)
  54:	24 00                	and    $0x0,%al
  56:	03 25 0b 0b 3e 0b    	add    0xb3e0b0b(%rip),%esp        # b3e0b67 <_license+0xb3de73a>
  5c:	00 00                	add    %al,(%rax)
  5e:	08 34 00             	or     %dh,(%rax,%rax,1)
  61:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f13b0 <_license+0x193eef83>
  67:	3a 0b                	cmp    (%rbx),%cl
  69:	3b 0b                	cmp    (%rbx),%ecx
  6b:	02 18                	add    (%rax),%bl
  6d:	00 00                	add    %al,(%rax)
  6f:	09 13                	or     %edx,(%rbx)
  71:	01 0b                	add    %ecx,(%rbx)
  73:	0b 3a                	or     (%rdx),%edi
  75:	0b 3b                	or     (%rbx),%edi
  77:	0b 00                	or     (%rax),%eax
  79:	00 0a                	add    %cl,(%rdx)
  7b:	0d 00 03 25 49       	or     $0x49250300,%eax
  80:	13 3a                	adc    (%rdx),%edi
  82:	0b 3b                	or     (%rbx),%edi
  84:	0b 38                	or     (%rax),%edi
  struct vip_definition vip = {};
  86:	0b 00                	or     (%rax),%eax
  88:	00 0b                	add    %cl,(%rbx)
  8a:	0f 00 49 13          	str    0x13(%rcx)
  8e:	00 00                	add    %al,(%rax)
  90:	0c 16                	or     $0x16,%al
  92:	00 49 13             	add    %cl,0x13(%rcx)
  95:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0bd5 <_license+0xb3ae7a8>
  9b:	00 00                	add    %al,(%rax)
  9d:	0d 13 01 03 25       	or     $0x25030113,%eax
    if (iph + 1 > data_end) {
  a2:	0b 0b                	or     (%rbx),%ecx
  a4:	3a 0b                	cmp    (%rbx),%cl
  a6:	3b 0b                	cmp    (%rbx),%ecx
  a8:	00 00                	add    %al,(%rax)
  aa:	0e                   	(bad)
  ab:	0d 00 49 13 3a       	or     $0x3a134900,%eax
    if (iph->ihl != 5) {
  b0:	0b 3b                	or     (%rbx),%edi
  b2:	0b 38                	or     (%rax),%edi
  b4:	0b 00                	or     (%rax),%eax
  b6:	00 0f                	add    %cl,(%rdi)
  b8:	17                   	(bad)
    pckt->tos = iph->tos;
  b9:	01 0b                	add    %ecx,(%rbx)
  bb:	0b 3a                	or     (%rdx),%edi
  bd:	0b 3b                	or     (%rbx),%edi
  bf:	0b 00                	or     (%rax),%eax
    *protocol = iph->protocol;
  c1:	00 10                	add    %dl,(%rax)
    pckt->flow.proto = *protocol;
  c3:	21 00                	and    %eax,(%rax)
  c5:	49 13 37             	adc    (%r15),%rsi
    if (iph->frag_off & PCKT_FRAGMENTED) {
  c8:	05 00 00 11 21       	add    $0x21110000,%eax
  cd:	00 49 13             	add    %cl,0x13(%rcx)
  d0:	00 00                	add    %al,(%rax)
  d2:	12 21                	adc    (%rcx),%ah
  d4:	00 49 13             	add    %cl,0x13(%rcx)
  d7:	37                   	(bad)
  d8:	06                   	(bad)
  d9:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
  db:	13 34 00             	adc    (%rax,%rax,1),%esi
  de:	03 25 49 13 3a 0b    	add    0xb3a1349(%rip),%esp        # b3a142d <_license+0xb39f000>
  if (icmp_hdr + 1 > data_end) {
  e4:	3b 0b                	cmp    (%rbx),%ecx
  e6:	00 00                	add    %al,(%rax)
  e8:	14 15                	adc    $0x15,%al
  ea:	01 49 13             	add    %ecx,0x13(%rcx)
  ed:	27                   	(bad)
  ee:	19 00                	sbb    %eax,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
  f0:	00 15 05 00 49 13    	add    %dl,0x13490005(%rip)        # 134900fb <_license+0x1348dcce>
  f6:	00 00                	add    %al,(%rax)
  f8:	16                   	(bad)
  f9:	0f 00 00             	sldt   (%rax)
  fc:	00 17                	add    %dl,(%rdi)
  fe:	15 00 49 13 27       	adc    $0x27134900,%eax
 103:	19 00                	sbb    %eax,(%rax)
 105:	00 18                	add    %bl,(%rax)
 107:	04 01                	add    $0x1,%al
 109:	49 13 03             	adc    (%r11),%rax
 10c:	25 0b 0b 3a 0b       	and    $0xb3a0b0b,%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
 111:	3b 05 00 00 19 28    	cmp    0x28190000(%rip),%eax        # 28190117 <_license+0x2818dcea>
  iph->ttl = DEFAULT_TTL;
 117:	00 03                	add    %al,(%rbx)
 119:	25 1c 0f 00 00       	and    $0xf1c,%eax
  tmp_addr = iph->daddr;
 11e:	1a 04 01             	sbb    (%rcx,%rax,1),%al
  iph->daddr = iph->saddr;
 121:	49 13 0b             	adc    (%r11),%rcx
  iph->saddr = tmp_addr;
 124:	0b 3a                	or     (%rdx),%edi
 126:	0b 3b                	or     (%rbx),%edi
 128:	0b 00                	or     (%rax),%eax
 12a:	00 1b                	add    %bl,(%rbx)
 12c:	0d 00 03 25 49       	or     $0x49250300,%eax
 131:	13 3a                	adc    (%rdx),%edi
 133:	0b 3b                	or     (%rbx),%edi
 135:	0b 0b                	or     (%rbx),%ecx
 137:	0b 0d 0b 0c 0b 38    	or     0x380b0c0b(%rip),%ecx        # 380b0d48 <_license+0x380ae91b>
 13d:	0b 00                	or     (%rax),%eax
 13f:	00 1c 2e             	add    %bl,(%rsi,%rbp,1)
 142:	01 03                	add    %eax,(%rbx)
 144:	25 3a 0b 3b 05       	and    $0x53b0b3a,%eax
 149:	27                   	(bad)
 14a:	19 49 13             	sbb    %ecx,0x13(%rcx)
 14d:	20 21                	and    %ah,(%rcx)
 14f:	01 00                	add    %eax,(%rax)
 151:	00 1d 05 00 03 25    	add    %bl,0x25030005(%rip)        # 2503015c <_license+0x2502dd2f>
 157:	3a 0b                	cmp    (%rbx),%cl
 159:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 14a8 <balancer_ingress+0x14a8>
  struct packet_description pckt = {};
 15f:	1e                   	(bad)
 160:	34 00                	xor    $0x0,%al
 162:	03 25 3a 0b 3b 05    	add    0x53b0b3a(%rip),%esp        # 53b0ca2 <_license+0x53ae875>
 168:	49 13 00             	adc    (%r8),%rax
 16b:	00 1f                	add    %bl,(%rdi)
 16d:	0b 01                	or     (%rcx),%eax
 16f:	00 00                	add    %al,(%rax)
 171:	20 13                	and    %dl,(%rbx)
 173:	01 03                	add    %eax,(%rbx)
 175:	25 0b 0b 3a 0b       	and    $0xb3a0b0b,%eax
 17a:	3b 05 00 00 21 0d    	cmp    0xd210000(%rip),%eax        # d210180 <_license+0xd20dd53>
 180:	00 03                	add    %al,(%rbx)
 182:	25 49 13 3a 0b       	and    $0xb3a1349,%eax
 187:	3b 05 38 0b 00 00    	cmp    0xb38(%rip),%eax        # cc5 <balancer_ingress+0xcc5>
 18d:	22 13                	and    (%rbx),%dl
 18f:	00 03                	add    %al,(%rbx)
 191:	25 3c 19 00 00       	and    $0x193c,%eax
  struct vip_definition vip = {};
 196:	23 26                	and    (%rsi),%esp
 198:	00 49 13             	add    %cl,0x13(%rcx)
 19b:	00 00                	add    %al,(%rax)
 19d:	24 2e                	and    $0x2e,%al
 19f:	01 03                	add    %eax,(%rbx)
 1a1:	25 3a 0b 3b 0b       	and    $0xb3b0b3a,%eax
 1a6:	27                   	(bad)
 1a7:	19 49 13             	sbb    %ecx,0x13(%rcx)
 1aa:	20 21                	and    %ah,(%rcx)
 1ac:	01 00                	add    %eax,(%rax)
 1ae:	00 25 05 00 03 25    	add    %ah,0x25030005(%rip)        # 250301b9 <_license+0x2502dd8c>
    if (ip6h + 1 > data_end) {
 1b4:	3a 0b                	cmp    (%rbx),%cl
 1b6:	3b 0b                	cmp    (%rbx),%ecx
 1b8:	49 13 00             	adc    (%r8),%rax
 1bb:	00 26                	add    %ah,(%rsi)
    *protocol = ip6h->nexthdr;
 1bd:	34 00                	xor    $0x0,%al
    pckt->flow.proto = *protocol;
 1bf:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0cff <_license+0xb3ae8d2>
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1c5:	49 13 00             	adc    (%r8),%rax
 1c8:	00 27                	add    %ah,(%rdi)
 1ca:	2e 01 03             	cs add %eax,(%rbx)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1cd:	25 3a 0b 3b 0b       	and    $0xb3b0b3a,%eax
 1d2:	27                   	(bad)
 1d3:	19 20                	sbb    %esp,(%rax)
 1d5:	21 01                	and    %eax,(%rcx)
 1d7:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_FRAGMENT) {
 1d9:	28 34 00             	sub    %dh,(%rax,%rax,1)
 1dc:	03 26                	add    (%rsi),%esp
 1de:	3a 0b                	cmp    (%rbx),%cl
 1e0:	3b 0b                	cmp    (%rbx),%ecx
 1e2:	49 13 00             	adc    (%r8),%rax
 1e5:	00 29                	add    %ch,(%rcx)
 1e7:	13 01                	adc    (%rcx),%eax
 1e9:	03 26                	add    (%rsi),%esp
 1eb:	0b 0b                	or     (%rbx),%ecx
  if (icmp_hdr + 1 > data_end) {
 1ed:	3a 0b                	cmp    (%rbx),%cl
 1ef:	3b 0b                	cmp    (%rbx),%ecx
 1f1:	00 00                	add    %al,(%rax)
 1f3:	2a 2e                	sub    (%rsi),%ch
 1f5:	01 03                	add    %eax,(%rbx)
 1f7:	26 3a 0b             	es cmp (%rbx),%cl
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 1fa:	3b 0b                	cmp    (%rbx),%ecx
 1fc:	27                   	(bad)
 1fd:	19 49 13             	sbb    %ecx,0x13(%rcx)
 200:	20 21                	and    %ah,(%rcx)
 202:	01 00                	add    %eax,(%rax)
 204:	00 2b                	add    %ch,(%rbx)
 206:	0d 00 03 26 49       	or     $0x49260300,%eax
 20b:	13 3a                	adc    (%rdx),%edi
 20d:	0b 3b                	or     (%rbx),%edi
 20f:	0b 38                	or     (%rax),%edi
 211:	0b 00                	or     (%rax),%eax
 213:	00 2c 0d 00 03 26 49 	add    %ch,0x49260300(,%rcx,1)
 21a:	13 3a                	adc    (%rdx),%edi
 21c:	0b 3b                	or     (%rbx),%edi
 21e:	0b 0b                	or     (%rbx),%ecx
 220:	0b 0d 0b 0c 0b 38    	or     0x380b0c0b(%rip),%ecx        # 380b0e31 <_license+0x380aea04>
 226:	0b 00                	or     (%rax),%eax
 228:	00 2d 2e 01 03 26    	add    %ch,0x2603012e(%rip)        # 2603035c <_license+0x2602df2f>
 22e:	3a 0b                	cmp    (%rbx),%cl
 230:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491b5d <_license+0x1348f730>
 236:	20 21                	and    %ah,(%rcx)
 238:	01 00                	add    %eax,(%rax)
 23a:	00 2e                	add    %ch,(%rsi)
 23c:	05 00 03 26 3a       	add    $0x3a260300,%eax
 241:	0b 3b                	or     (%rbx),%edi
 243:	05 49 13 00 00       	add    $0x1349,%eax
 248:	2f                   	(bad)
 249:	05 00 03 26 3a       	add    $0x3a260300,%eax
 24e:	0b 3b                	or     (%rbx),%edi
 250:	0b 49 13             	or     0x13(%rcx),%ecx
 253:	00 00                	add    %al,(%rax)
 255:	30 34 00             	xor    %dh,(%rax,%rax,1)
 258:	03 26                	add    (%rsi),%esp
 25a:	3a 0b                	cmp    (%rbx),%cl
 25c:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 15ab <balancer_ingress+0x15ab>
 262:	31 2e                	xor    %ebp,(%rsi)
 264:	01 03                	add    %eax,(%rbx)
 266:	26 3a 0b             	es cmp (%rbx),%cl
 269:	3b 0b                	cmp    (%rbx),%ecx
 26b:	27                   	(bad)
 26c:	19 20                	sbb    %esp,(%rax)
 26e:	21 01                	and    %eax,(%rcx)
 270:	00 00                	add    %al,(%rax)
 272:	32 2e                	xor    (%rsi),%ch
 274:	01 03                	add    %eax,(%rbx)
 276:	26 3a 0b             	es cmp (%rbx),%cl
 279:	3b 05 27 19 20 21    	cmp    0x21201927(%rip),%eax        # 21201ba6 <_license+0x211ff779>
 27f:	01 00                	add    %eax,(%rax)
 281:	00 33                	add    %dh,(%rbx)
 283:	2e 01 03             	cs add %eax,(%rbx)
 286:	26 3a 0b             	es cmp (%rbx),%cl
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 289:	3b 0b                	cmp    (%rbx),%ecx
 28b:	20 21                	and    %ah,(%rcx)
 28d:	01 00                	add    %eax,(%rax)
 28f:	00 34 26             	add    %dh,(%rsi,%riz,1)
 292:	00 00                	add    %al,(%rax)
 294:	00 35 2e 01 11 1b    	add    %dh,0x1b11012e(%rip)        # 1b1103c8 <_license+0x1b10df9b>
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 29a:	12 06                	adc    (%rsi),%al
 29c:	40 18 7a 19          	sbb    %dil,0x19(%rdx)
 2a0:	03 26                	add    (%rsi),%esp
 2a2:	3a 0b                	cmp    (%rbx),%cl
 2a4:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491bd1 <_license+0x1348f7a4>
 2aa:	3f                   	(bad)
 2ab:	19 00                	sbb    %eax,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 2ad:	00 36                	add    %dh,(%rsi)
 2af:	05 00 02 22 03       	add    $0x3220200,%eax
  if (icmp_hdr + 1 > data_end) {
 2b4:	26 3a 0b             	es cmp (%rbx),%cl
 2b7:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 1606 <balancer_ingress+0x1606>
 2bd:	37                   	(bad)
 2be:	34 00                	xor    $0x0,%al
 2c0:	02 22                	add    (%rdx),%ah
  if (icmp_hdr->type == ICMP_ECHO) {
 2c2:	03 25 3a 0b 3b 05    	add    0x53b0b3a(%rip),%esp        # 53b0e02 <_license+0x53ae9d5>
 2c8:	49 13 00             	adc    (%r8),%rax
 2cb:	00 38                	add    %bh,(%rax)
 2cd:	34 00                	xor    $0x0,%al
 2cf:	02 22                	add    (%rdx),%ah
 2d1:	03 26                	add    (%rsi),%esp
 2d3:	3a 0b                	cmp    (%rbx),%cl
 2d5:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 1624 <balancer_ingress+0x1624>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2db:	39 1d 01 31 13 55    	cmp    %ebx,0x55133101(%rip)        # 551333e2 <_license+0x55130fb5>
 2e1:	23 58 0b             	and    0xb(%rax),%ebx
       sizeof(struct icmphdr)) > data_end) {
 2e4:	59                   	pop    %rcx
 2e5:	05 57 0b 00 00       	add    $0xb57,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2ea:	3a 05 00 02 22 31    	cmp    0x31220200(%rip),%al        # 312204f0 <_license+0x3121e0c3>
  icmp_hdr->type = ICMP_ECHOREPLY;
 2f0:	13 00                	adc    (%rax),%eax
  icmp_hdr->checksum += 0x0008;
 2f2:	00 3b                	add    %bh,(%rbx)
 2f4:	34 00                	xor    $0x0,%al
  iph->ttl = DEFAULT_TTL;
 2f6:	02 18                	add    (%rax),%bl
 2f8:	31 13                	xor    %edx,(%rbx)
  iph->daddr = iph->saddr;
 2fa:	00 00                	add    %al,(%rax)
 2fc:	3c 34                	cmp    $0x34,%al
  tmp_addr = iph->daddr;
 2fe:	00 02                	add    %al,(%rdx)
  iph->daddr = iph->saddr;
 300:	22 31                	and    (%rcx),%dh
 302:	13 00                	adc    (%rax),%eax
  iph->saddr = tmp_addr;
 304:	00 3d 1d 01 31 13    	add    %bh,0x1331011d(%rip)        # 13310427 <_license+0x1330dffa>
 30a:	11 1b                	adc    %ebx,(%rbx)
 30c:	12 06                	adc    (%rsi),%al
 30e:	58                   	pop    %rax
 30f:	0b 59 05             	or     0x5(%rcx),%ebx
 312:	57                   	push   %rdi
 313:	0b 00                	or     (%rax),%eax
 315:	00 3e                	add    %bh,(%rsi)
 317:	05 00 02 18 31       	add    $0x31180200,%eax
 31c:	13 00                	adc    (%rax),%eax
 31e:	00 3f                	add    %bh,(%rdi)
 320:	34 00                	xor    $0x0,%al
 322:	1c 0f                	sbb    $0xf,%al
 324:	31 13                	xor    %edx,(%rbx)
 326:	00 00                	add    %al,(%rax)
 328:	40 1d 01 31 13 11    	rex sbb $0x11133101,%eax
 32e:	1b 12                	sbb    (%rdx),%edx
 330:	06                   	(bad)
 331:	58                   	pop    %rax
 332:	0b 59 0b             	or     0xb(%rcx),%ebx
 335:	57                   	push   %rdi
 336:	0b 00                	or     (%rax),%eax
 338:	00 41 0b             	add    %al,0xb(%rcx)
 33b:	01 11                	add    %edx,(%rcx)
 33d:	1b 12                	sbb    (%rdx),%edx
 33f:	06                   	(bad)
 340:	00 00                	add    %al,(%rax)
 342:	42 34 00             	rex.X xor $0x0,%al
 345:	1c 0d                	sbb    $0xd,%al
 347:	31 13                	xor    %edx,(%rbx)
 349:	00 00                	add    %al,(%rax)
 34b:	43 0b 01             	rex.XB or (%r9),%eax
 34e:	55                   	push   %rbp
 34f:	23 00                	and    (%rax),%eax
 351:	00 44 05 00          	add    %al,0x0(%rbp,%rax,1)
 355:	1c 0d                	sbb    $0xd,%al
 357:	31 13                	xor    %edx,(%rbx)
 359:	00 00                	add    %al,(%rax)
 35b:	45 34 00             	rex.RB xor $0x0,%al
 35e:	31 13                	xor    %edx,(%rbx)
 360:	00 00                	add    %al,(%rax)
 362:	46 1d 00 31 13 11    	rex.RX sbb $0x11133100,%eax
 368:	1b 12                	sbb    (%rdx),%edx
 36a:	06                   	(bad)
 36b:	58                   	pop    %rax
 36c:	0b 59 05             	or     0x5(%rcx),%ebx
 36f:	57                   	push   %rdi
 370:	0b 00                	or     (%rax),%eax
 372:	00 47 05             	add    %al,0x5(%rdi)
 375:	00 31                	add    %dh,(%rcx)
 377:	13 00                	adc    (%rax),%eax
 379:	00 48 05             	add    %cl,0x5(%rax)
 37c:	00 1c 0f             	add    %bl,(%rdi,%rcx,1)
 37f:	31 13                	xor    %edx,(%rbx)
 381:	00 00                	add    %al,(%rax)
 383:	49 1d 00 31 13 11    	rex.WB sbb $0x11133100,%rax
 389:	1b 12                	sbb    (%rdx),%edx
 38b:	06                   	(bad)
 38c:	58                   	pop    %rax
 38d:	0b 59 0b             	or     0xb(%rcx),%ebx
 390:	57                   	push   %rdi
 391:	0b 00                	or     (%rax),%eax
 393:	00 4a 1d             	add    %cl,0x1d(%rdx)
 396:	01 31                	add    %esi,(%rcx)
 398:	13 55 23             	adc    0x23(%rbp),%edx
 39b:	58                   	pop    %rax
 39c:	0b 59 0b             	or     0xb(%rcx),%ebx
 39f:	57                   	push   %rdi
 3a0:	0b 00                	or     (%rax),%eax
 3a2:	00 4b 48             	add    %cl,0x48(%rbx)
 3a5:	00 83 01 18 7d 1b    	add    %al,0x1b7d1801(%rbx)
 3ab:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_info:

0000000000000000 <.debug_info>:
  void* data = (void*)(long)ctx->data;
       0:	64 46 00 00          	rex.RX add %r8b,%fs:(%rax)
       4:	05 00 01 08 00       	add    $0x80100,%eax
       9:	00 00                	add    %al,(%rax)
       b:	00 01                	add    %al,(%rcx)
       d:	00 0c 00             	add    %cl,(%rax,%rax,1)
      10:	01 08                	add    %ecx,(%rax)
      12:	00 00                	add    %al,(%rax)
      14:	00 00                	add    %al,(%rax)
      16:	00 00                	add    %al,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
      18:	00 02                	add    %al,(%rdx)
      1a:	14 2d                	adc    $0x2d,%al
  if (data + nh_off > data_end) {
      1c:	24 00                	and    $0x0,%al
      1e:	00 08                	add    %cl,(%rax)
      20:	00 00                	add    %al,(%rax)
      22:	00 0c 00             	add    %cl,(%rax,%rax,1)
      25:	00 00                	add    %al,(%rax)
      27:	0c 00                	or     $0x0,%al
      29:	00 00                	add    %al,(%rax)
      2b:	02 76 01             	add    0x1(%rsi),%dh
      2e:	07                   	(bad)
      2f:	02 02                	add    (%rdx),%al
  eth_proto = eth->h_proto;
      31:	75 01                	jne    34 <balancer_ingress+0x34>
      33:	07                   	(bad)
      34:	04 02                	add    $0x2,%al
  if (eth_proto == BE_ETH_P_IP) {
      36:	74 01                	je     39 <balancer_ingress+0x39>
      38:	07                   	(bad)
      39:	08 02                	or     %al,(%rdx)
      3b:	73 01                	jae    3e <balancer_ingress+0x3e>
      3d:	07                   	(bad)
      3e:	01 02                	add    %eax,(%rdx)
      40:	72 01                	jb     43 <balancer_ingress+0x43>
      42:	07                   	(bad)
      43:	01 03                	add    %eax,(%rbx)
      45:	03 50 00             	add    0x0(%rax),%edx
      48:	00 00                	add    %al,(%rax)
      4a:	00 4a 04             	add    %cl,0x4(%rdx)
      4d:	02 a1 00 04 5c 00    	add    0x5c0400(%rcx),%ah
  struct packet_description pckt = {};
      53:	00 00                	add    %al,(%rax)
      55:	05 60 00 00 00       	add    $0x60,%eax
      5a:	04 00                	add    $0x0,%al
      5c:	06                   	(bad)
      5d:	04 06                	add    $0x6,%al
      5f:	01 07                	add    %eax,(%rdi)
      61:	05 08 07 08 06       	add    $0x6080708,%eax
      66:	6f                   	outsl  %ds:(%rsi),(%dx)
      67:	00 00                	add    %al,(%rax)
      69:	00 01                	add    %al,(%rcx)
      6b:	29 02                	sub    %eax,(%rdx)
      6d:	a1 01 09 28 01 23 0a 	movabs 0xa1070a2301280901,%eax
      74:	07 a1 
      76:	00 00                	add    %al,(%rax)
      78:	00 01                	add    %al,(%rcx)
      7a:	24 00                	and    $0x0,%al
      7c:	0a 09                	or     (%rcx),%cl
      7e:	b6 00                	mov    $0x0,%dh
      80:	00 00                	add    %al,(%rax)
      82:	01 25 08 0a 0c c7    	add    %esp,-0x38f3f5f8(%rip)        # ffffffffc70c0a90 <server_id_map+0x36fc7de24a90>
  struct vip_definition vip = {};
      88:	00 00                	add    %al,(%rax)
      8a:	00 01                	add    %al,(%rcx)
      8c:	26 10 0a             	es adc %cl,(%rdx)
      8f:	14 1e                	adc    $0x1e,%al
      91:	01 00                	add    %eax,(%rax)
      93:	00 01                	add    %al,(%rcx)
      95:	27                   	(bad)
      96:	18 0a                	sbb    %cl,(%rdx)
      98:	15 2f 01 00 00       	adc    $0x12f,%eax
      9d:	01 28                	add    %ebp,(%rax)
      9f:	20 00                	and    %al,(%rax)
    if (iph + 1 > data_end) {
      a1:	0b a6 00 00 00 04    	or     0x4000000(%rsi),%esp
      a7:	b2 00                	mov    $0x0,%dl
      a9:	00 00                	add    %al,(%rax)
      ab:	05 60 00 00 00       	add    $0x60,%eax
    if (iph->ihl != 5) {
      b0:	02 00                	add    (%rax),%al
      b2:	06                   	(bad)
      b3:	08 05 04 0b bb 00    	or     %al,0xbb0b04(%rip)        # bb0bbd <_license+0xbae790>
    pckt->tos = iph->tos;
      b9:	00 00                	add    %al,(%rax)
      bb:	0c c3                	or     $0xc3,%al
      bd:	00 00                	add    %al,(%rax)
      bf:	00 0b                	add    %cl,(%rbx)
    *protocol = iph->protocol;
      c1:	02 1b                	add    (%rbx),%bl
    pckt->flow.proto = *protocol;
      c3:	06                   	(bad)
      c4:	0a 07                	or     (%rdi),%al
      c6:	04 0b                	add    $0xb,%al
    if (iph->frag_off & PCKT_FRAGMENTED) {
      c8:	cc                   	int3
      c9:	00 00                	add    %al,(%rax)
      cb:	00 0d 13 08 03 35    	add    %cl,0x35030813(%rip)        # 350308e4 <_license+0x3502e4b7>
      d1:	0e                   	(bad)
      d2:	d9 00                	flds   (%rax)
      d4:	00 00                	add    %al,(%rax)
      d6:	03 36                	add    (%rsi),%esi
      d8:	00 0f                	add    %cl,(%rdi)
      da:	08 03                	or     %al,(%rbx)
    if (*protocol == IPPROTO_ICMP) {
      dc:	36 0a 0c fa          	ss or  (%rdx,%rdi,8),%cl
      e0:	00 00                	add    %al,(%rax)
      e2:	00 03                	add    %al,(%rbx)
  if (icmp_hdr + 1 > data_end) {
      e4:	37                   	(bad)
      e5:	00 0a                	add    %cl,(%rdx)
      e7:	0f bb 00             	btc    %eax,(%rax)
      ea:	00 00                	add    %al,(%rax)
      ec:	03 38                	add    (%rax),%edi
      ee:	00 0a                	add    %cl,(%rdx)
  if (icmp_hdr->type == ICMP_ECHO) {
      f0:	10 06                	adc    %al,(%rsi)
      f2:	01 00                	add    %eax,(%rax)
      f4:	00 03                	add    %al,(%rbx)
      f6:	39 00                	cmp    %eax,(%rax)
      f8:	00 00                	add    %al,(%rax)
      fa:	0c 02                	or     $0x2,%al
      fc:	01 00                	add    %eax,(%rax)
      fe:	00 0e                	add    %cl,(%rsi)
     100:	02 1f                	add    (%rdi),%bl
     102:	06                   	(bad)
     103:	0d 07 08 04 12       	or     $0x12040807,%eax
     108:	01 00                	add    %eax,(%rax)
     10a:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 170 <balancer_ingress+0x170>
  icmp_hdr->type = ICMP_ECHOREPLY;
     110:	06                   	(bad)
     111:	00 0c 1a             	add    %cl,(%rdx,%rbx,1)
  icmp_hdr->checksum += 0x0008;
     114:	01 00                	add    %eax,(%rax)
     116:	00 12                	add    %dl,(%rdx)
  iph->ttl = DEFAULT_TTL;
     118:	02 15 06 11 08 01    	add    0x1081106(%rip),%dl        # 1081224 <_license+0x107edf7>
  tmp_addr = iph->daddr;
     11e:	0b 23                	or     (%rbx),%esp
     120:	01 00                	add    %eax,(%rax)
  iph->daddr = iph->saddr;
     122:	00 04 b2             	add    %al,(%rdx,%rsi,4)
  iph->saddr = tmp_addr;
     125:	00 00                	add    %al,(%rax)
     127:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 18d <balancer_ingress+0x18d>
     12d:	10 00                	adc    %al,(%rax)
     12f:	0b 34 01             	or     (%rcx,%rax,1),%esi
     132:	00 00                	add    %al,(%rax)
     134:	04 b2                	add    $0xb2,%al
     136:	00 00                	add    %al,(%rax)
     138:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 19e <balancer_ingress+0x19e>
     13e:	00 00                	add    %al,(%rax)
     140:	08 16                	or     %dl,(%rsi)
     142:	4b 01 00             	rex.WXB add %rax,(%r8)
     145:	00 01                	add    %al,(%rcx)
     147:	3e 02 a1 02 09 28 01 	ds add 0x1280902(%rcx),%ah
     14e:	38 0a                	cmp    %cl,(%rdx)
     150:	07                   	(bad)
     151:	7d 01                	jge    154 <balancer_ingress+0x154>
     153:	00 00                	add    %al,(%rax)
     155:	01 39                	add    %edi,(%rcx)
     157:	00 0a                	add    %cl,(%rdx)
     159:	09 8e 01 00 00 01    	or     %ecx,0x1000001(%rsi)
  struct packet_description pckt = {};
     15f:	3a 08                	cmp    (%rax),%cl
     161:	0a 0c b6             	or     (%rsi,%rsi,4),%cl
     164:	00 00                	add    %al,(%rax)
     166:	00 01                	add    %al,(%rcx)
     168:	3b 10                	cmp    (%rax),%edx
     16a:	0a 14 cc             	or     (%rsp,%rcx,8),%dl
     16d:	01 00                	add    %eax,(%rax)
     16f:	00 01                	add    %al,(%rcx)
     171:	3c 18                	cmp    $0x18,%al
     173:	0a 15 2f 01 00 00    	or     0x12f(%rip),%dl        # 2a8 <balancer_ingress+0x2a8>
     179:	01 3d 20 00 0b 82    	add    %edi,-0x7df4ffe0(%rip)        # ffffffff820b019f <server_id_map+0x36fc38e1419f>
     17f:	01 00                	add    %eax,(%rax)
     181:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     184:	00 00                	add    %al,(%rax)
     186:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 1ec <balancer_ingress+0x1ec>
     18c:	01 00                	add    %eax,(%rax)
     18e:	0b 93 01 00 00 0d    	or     0xd000001(%rbx),%edx
     194:	1a 10                	sbb    (%rax),%dl
  struct vip_definition vip = {};
     196:	03 6e 0e             	add    0xe(%rsi),%ebp
     199:	a0 01 00 00 03 6f 00 	movabs 0x100f006f03000001,%al
     1a0:	0f 10 
     1a2:	03 6f 0a             	add    0xa(%rdi),%ebp
     1a5:	17                   	(bad)
     1a6:	b8 01 00 00 03       	mov    $0x3000001,%eax
     1ab:	70 00                	jo     1ad <balancer_ingress+0x1ad>
     1ad:	0a 19                	or     (%rcx),%bl
    if (ip6h + 1 > data_end) {
     1af:	c0 01 00             	rolb   $0x0,(%rcx)
     1b2:	00 03                	add    %al,(%rbx)
     1b4:	71 00                	jno    1b6 <balancer_ingress+0x1b6>
     1b6:	00 00                	add    %al,(%rax)
     1b8:	0c bb                	or     $0xbb,%al
     1ba:	00 00                	add    %al,(%rax)
    *protocol = ip6h->nexthdr;
     1bc:	00 18                	add    %bl,(%rax)
     1be:	04 22                	add    $0x22,%al
    pckt->flow.proto = *protocol;
     1c0:	04 b8                	add    $0xb8,%al
     1c2:	01 00                	add    %eax,(%rax)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1c4:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 22a <balancer_ingress+0x22a>
     1ca:	04 00                	add    $0x0,%al
     1cc:	0b d1                	or     %ecx,%edx
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1ce:	01 00                	add    %eax,(%rax)
     1d0:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     1d3:	00 00                	add    %al,(%rax)
     1d5:	00 10                	add    %dl,(%rax)
     1d7:	60                   	(bad)
     1d8:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_FRAGMENT) {
     1da:	00 00                	add    %al,(%rax)
     1dc:	02 00                	add    (%rax),%al
     1de:	08 1b                	or     %bl,(%rbx)
     1e0:	e9 01 00 00 01       	jmp    10001e6 <_license+0xffddb9>
     1e5:	45 02 a1 03 09 20 01 	add    0x1200903(%r9),%r12b
     1ec:	40 0a 07             	rex or (%rdi),%al
  if (icmp_hdr + 1 > data_end) {
     1ef:	12 02                	adc    (%rdx),%al
     1f1:	00 00                	add    %al,(%rax)
     1f3:	01 41 00             	add    %eax,0x0(%rcx)
     1f6:	0a 09                	or     (%rcx),%cl
     1f8:	b6 00                	mov    $0x0,%dh
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1fa:	00 00                	add    %al,(%rax)
     1fc:	01 42 08             	add    %eax,0x8(%rdx)
     1ff:	0a 0c b6             	or     (%rsi,%rsi,4),%cl
     202:	00 00                	add    %al,(%rax)
     204:	00 01                	add    %al,(%rcx)
     206:	43 10 0a             	rex.XB adc %cl,(%r10)
     209:	14 7d                	adc    $0x7d,%al
     20b:	01 00                	add    %eax,(%rax)
     20d:	00 01                	add    %al,(%rcx)
     20f:	44 18 00             	sbb    %r8b,(%rax)
     212:	0b 17                	or     (%rdi),%edx
     214:	02 00                	add    (%rax),%al
     216:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     219:	00 00                	add    %al,(%rax)
     21b:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 281 <balancer_ingress+0x281>
     221:	03 00                	add    (%rax),%eax
     223:	08 1c 2e             	or     %bl,(%rsi,%rbp,1)
     226:	02 00                	add    (%rax),%al
     228:	00 05 26 02 a1 04    	add    %al,0x4a10226(%rip)        # 4a10454 <_license+0x4a0e027>
     22e:	09 28                	or     %ebp,(%rax)
     230:	05 20 0a 07 7d       	add    $0x7d070a20,%eax
     235:	01 00                	add    %eax,(%rax)
     237:	00 05 21 00 0a 09    	add    %al,0x90a0021(%rip)        # 90a025e <_license+0x909de31>
     23d:	60                   	(bad)
     23e:	02 00                	add    (%rax),%al
     240:	00 05 22 08 0a 0c    	add    %al,0xc0a0822(%rip)        # c0a0a68 <_license+0xc09e63b>
     246:	a8 02                	test   $0x2,%al
     248:	00 00                	add    %al,(%rax)
     24a:	05 23 10 0a 14       	add    $0x140a1023,%eax
     24f:	cc                   	int3
     250:	01 00                	add    %eax,(%rax)
     252:	00 05 24 18 0a 15    	add    %al,0x150a1824(%rip)        # 150a1a7c <_license+0x1509f64f>
     258:	2f                   	(bad)
     259:	01 00                	add    %eax,(%rax)
     25b:	00 05 25 20 00 0b    	add    %al,0xb002025(%rip)        # b002286 <_license+0xafffe59>
     261:	65 02 00             	add    %gs:(%rax),%al
     264:	00 0d 23 14 03 3e    	add    %cl,0x3e031423(%rip)        # 3e03168d <_license+0x3e02f260>
     26a:	0e                   	(bad)
     26b:	72 02                	jb     26f <balancer_ingress+0x26f>
     26d:	00 00                	add    %al,(%rax)
     26f:	03 3f                	add    (%rdi),%edi
     271:	00 0f                	add    %cl,(%rdi)
     273:	10 03                	adc    %al,(%rbx)
     275:	3f                   	(bad)
     276:	0a 1d b8 01 00 00    	or     0x1b8(%rip),%bl        # 434 <balancer_ingress+0x434>
     27c:	03 40 00             	add    0x0(%rax),%eax
     27f:	0a 1e                	or     (%rsi),%bl
     281:	c0 01 00             	rolb   $0x0,(%rcx)
     284:	00 03                	add    %al,(%rbx)
     286:	41 00 00             	add    %al,(%r8)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     289:	0a 1f                	or     (%rdi),%bl
     28b:	9c                   	pushf
     28c:	02 00                	add    (%rax),%al
     28e:	00 03                	add    %al,(%rbx)
     290:	43 10 0a             	rex.XB adc %cl,(%r10)
     293:	22 12                	and    (%rdx),%dl
     295:	01 00                	add    %eax,(%rax)
     297:	00 03                	add    %al,(%rbx)
     299:	44 12 00             	adc    (%rax),%r8b
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     29c:	0c a4                	or     $0xa4,%al
     29e:	02 00                	add    (%rax),%al
     2a0:	00 21                	add    %ah,(%rcx)
     2a2:	02 18                	add    (%rax),%bl
     2a4:	06                   	(bad)
     2a5:	20 07                	and    %al,(%rdi)
     2a7:	02 0b                	add    (%rbx),%cl
     2a9:	ad                   	lods   %ds:(%rsi),%eax
     2aa:	02 00                	add    (%rax),%al
  if (protocol == IPPROTO_ICMPV6) {
     2ac:	00 0d 26 08 03 48    	add    %cl,0x48030826(%rip)        # 48030ad8 <_license+0x4802e6ab>
     2b2:	0a 24 bb             	or     (%rbx,%rdi,4),%ah
  if (icmp_hdr + 1 > data_end) {
     2b5:	00 00                	add    %al,(%rax)
     2b7:	00 03                	add    %al,(%rbx)
     2b9:	49 00 0a             	rex.WB add %cl,(%r10)
     2bc:	25 bb 00 00 00       	and    $0xbb,%eax
  if (icmp_hdr->type == ICMP_ECHO) {
     2c1:	03 4a 04             	add    0x4(%rdx),%ecx
     2c4:	00 08                	add    %cl,(%rax)
     2c6:	27                   	(bad)
     2c7:	d0 02                	rolb   (%rdx)
     2c9:	00 00                	add    %al,(%rax)
     2cb:	05 2f 02 a1 05       	add    $0x5a1022f,%eax
     2d0:	09 28                	or     %ebp,(%rax)
     2d2:	05 29 0a 07 02       	add    $0x2070a29,%eax
     2d7:	03 00                	add    (%rax),%eax
     2d9:	00 05 2a 00 0a 09    	add    %al,0x90a002a(%rip)        # 90a0309 <_license+0x909dedc>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2df:	13 03                	adc    (%rbx),%eax
     2e1:	00 00                	add    %al,(%rax)
     2e3:	05 2b 08 0a 0c       	add    $0xc0a082b,%eax
     2e8:	90                   	nop
     2e9:	03 00                	add    (%rax),%eax
     2eb:	00 05 2c 10 0a 14    	add    %al,0x140a102c(%rip)        # 140a131d <_license+0x1409eef0>
  icmp_hdr->checksum += 0x0008;
     2f1:	ad                   	lods   %ds:(%rsi),%eax
     2f2:	03 00                	add    (%rax),%eax
     2f4:	00 05 2d 18 0a 15    	add    %al,0x150a182d(%rip)        # 150a1b27 <_license+0x1509f6fa>
  iph->daddr = iph->saddr;
     2fa:	2f                   	(bad)
     2fb:	01 00                	add    %eax,(%rax)
  tmp_addr = iph->daddr;
     2fd:	00 05 2e 20 00 0b    	add    %al,0xb00202e(%rip)        # b002331 <_license+0xaffff04>
  iph->saddr = tmp_addr;
     303:	07                   	(bad)
     304:	03 00                	add    (%rax),%eax
     306:	00 04 b2             	add    %al,(%rdx,%rsi,4)
     309:	00 00                	add    %al,(%rax)
     30b:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 371 <balancer_ingress+0x371>
     311:	09 00                	or     %eax,(%rax)
     313:	0b 18                	or     (%rax),%ebx
     315:	03 00                	add    (%rax),%eax
     317:	00 0d 2e 28 03 1a    	add    %cl,0x1a03282e(%rip)        # 1a032b4b <_license+0x1a03071e>
     31d:	0e                   	(bad)
     31e:	25 03 00 00 03       	and    $0x3000003,%eax
     323:	1b 00                	sbb    (%rax),%eax
     325:	0f 10 03             	movups (%rbx),%xmm0
     328:	1b 0a                	sbb    (%rdx),%ecx
     32a:	28 b8 01 00 00 03    	sub    %bh,0x3000001(%rax)
     330:	1c 00                	sbb    $0x0,%al
     332:	0a 29                	or     (%rcx),%ch
     334:	c0 01 00             	rolb   $0x0,(%rcx)
     337:	00 03                	add    %al,(%rbx)
     339:	1d 00 00 0e 44       	sbb    $0x440e0000,%eax
     33e:	03 00                	add    (%rax),%eax
     340:	00 03                	add    %al,(%rbx)
     342:	1f                   	(bad)
     343:	10 0f                	adc    %cl,(%rdi)
     345:	10 03                	adc    %al,(%rbx)
     347:	1f                   	(bad)
     348:	0a 2a                	or     (%rdx),%ch
     34a:	b8 01 00 00 03       	mov    $0x3000001,%eax
     34f:	20 00                	and    %al,(%rax)
     351:	0a 2b                	or     (%rbx),%ch
     353:	c0 01 00             	rolb   $0x0,(%rcx)
     356:	00 03                	add    %al,(%rbx)
     358:	21 00                	and    %eax,(%rax)
     35a:	00 0e                	add    %cl,(%rsi)
     35c:	63 03                	movsxd (%rbx),%eax
     35e:	00 00                	add    %al,(%rax)
     360:	03 23                	add    (%rbx),%esp
     362:	20 0f                	and    %cl,(%rdi)
     364:	04 03                	add    $0x3,%al
     366:	23 0a                	and    (%rdx),%ecx
     368:	2c bb                	sub    $0xbb,%al
     36a:	00 00                	add    %al,(%rax)
     36c:	00 03                	add    %al,(%rbx)
     36e:	24 00                	and    $0x0,%al
     370:	0a 2d 84 03 00 00    	or     0x384(%rip),%ch        # 6fa <balancer_ingress+0x6fa>
     376:	03 25 00 00 0a 22    	add    0x220a0000(%rip),%esp        # 220a037c <_license+0x2209df4f>
     37c:	12 01                	adc    (%rcx),%al
     37e:	00 00                	add    %al,(%rax)
     380:	03 27                	add    (%rdi),%esp
     382:	24 00                	and    $0x0,%al
     384:	04 9c                	add    $0x9c,%al
     386:	02 00                	add    (%rax),%al
     388:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 3ee <balancer_ingress+0x3ee>
     38e:	02 00                	add    (%rax),%al
     390:	0b 95 03 00 00 0d    	or     0xd000003(%rbp),%edx
     396:	31 10                	xor    %edx,(%rax)
     398:	03 4e 0a             	add    0xa(%rsi),%ecx
     39b:	2f                   	(bad)
     39c:	bb 00 00 00 03       	mov    $0x3000000,%ebx
     3a1:	4f 00 0a             	rex.WRXB add %r9b,(%r10)
     3a4:	30 fa                	xor    %bh,%dl
     3a6:	00 00                	add    %al,(%rax)
     3a8:	00 03                	add    %al,(%rbx)
     3aa:	50                   	push   %rax
     3ab:	08 00                	or     %al,(%rax)
     3ad:	0b b2 03 00 00 04    	or     0x4000003(%rdx),%esi
     3b3:	b2 00                	mov    $0x0,%dl
     3b5:	00 00                	add    %al,(%rax)
     3b7:	10 60 00             	adc    %ah,0x0(%rax)
     3ba:	00 00                	add    %al,(%rax)
     3bc:	e8 03 00 08 32       	call   320803c4 <_license+0x3207df97>
     3c1:	ca 03 00             	lret   $0x3
     3c4:	00 05 40 02 a1 06    	add    %al,0x6a10240(%rip)        # 6a1060a <_license+0x6a0e1dd>
     3ca:	09 28                	or     %ebp,(%rax)
     3cc:	05 32 0a 07 2e       	add    $0x2e070a32,%eax
     3d1:	04 00                	add    $0x0,%al
     3d3:	00 05 33 00 0a 09    	add    %al,0x90a0033(%rip)        # 90a040c <_license+0x909dfdf>
     3d9:	b6 00                	mov    $0x0,%dh
     3db:	00 00                	add    %al,(%rax)
     3dd:	05 34 08 0a 0c       	add    $0xc0a0834,%eax
     3e2:	b6 00                	mov    $0x0,%dh
  if (protocol == IPPROTO_IPIP) {
     3e4:	00 00                	add    %al,(%rax)
     3e6:	05 35 10 0a 14       	add    $0x140a1035,%eax
     3eb:	3f                   	(bad)
     3ec:	04 00                	add    $0x0,%al
     3ee:	00 05 36 18 0a 15    	add    %al,0x150a1836(%rip)        # 150a1c2a <_license+0x1509f7fd>
     3f4:	2f                   	(bad)
     3f5:	01 00                	add    %eax,(%rax)
     3f7:	00 05 37 20 0a 33    	add    %al,0x330a2037(%rip)        # 330a2434 <_license+0x330a0007>
  tcp = data + off;
     3fd:	50                   	push   %rax
     3fe:	04 00                	add    $0x0,%al
  if (is_ipv6) {
     400:	00 05 38 28 09 20    	add    %al,0x20092838(%rip)        # 20092c3e <_license+0x20090811>
  if (tcp + 1 > data_end) {
     406:	05 38 0a 07 02       	add    $0x2070a38,%eax
     40b:	03 00                	add    (%rax),%eax
     40d:	00 05 38 00 0a 09    	add    %al,0x90a0038(%rip)        # 90a044b <_license+0x909e01e>
  if (tcp->syn) {
     413:	13 03                	adc    (%rbx),%eax
     415:	00 00                	add    %al,(%rax)
     417:	05 38 08 0a 0c       	add    $0xc0a0838,%eax
     41c:	90                   	nop
    pckt->flags |= F_SYN_SET;
     41d:	03 00                	add    (%rax),%eax
     41f:	00 05 38 10 0a 14    	add    %al,0x140a1038(%rip)        # 140a145d <_license+0x1409f030>
     425:	ad                   	lods   %ds:(%rsi),%eax
      pckt->flow.src = iph->saddr;
     426:	03 00                	add    (%rax),%eax
     428:	00 05 38 18 00 00    	add    %al,0x1838(%rip)        # 1c66 <balancer_ingress+0x1c66>
      pckt->flow.dst = iph->daddr;
     42e:	0b 33                	or     (%rbx),%esi
     430:	04 00                	add    $0x0,%al
     432:	00 04 b2             	add    %al,(%rdx,%rsi,4)
  if (protocol == IPPROTO_ICMPV6) {
     435:	00 00                	add    %al,(%rax)
     437:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 49d <balancer_ingress+0x49d>
  if (icmp_hdr + 1 > data_end) {
     43d:	0c 00                	or     $0x0,%al
     43f:	0b 44 04 00          	or     0x0(%rsp,%rax,1),%eax
     443:	00 04 b2             	add    %al,(%rdx,%rsi,4)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     446:	00 00                	add    %al,(%rax)
     448:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 4ae <balancer_ingress+0x4ae>
     44e:	80 00 04             	addb   $0x4,(%rax)
     451:	5b                   	pop    %rbx
     452:	04 00                	add    $0x0,%al
     454:	00 11                	add    %dl,(%rcx)
     456:	60                   	(bad)
     457:	00 00                	add    %al,(%rax)
     459:	00 00                	add    %al,(%rax)
     45b:	0b 04 04             	or     (%rsp,%rax,1),%eax
     45e:	00 00                	add    %al,(%rax)
     460:	08 34 6b             	or     %dh,(%rbx,%rbp,2)
     463:	04 00                	add    $0x0,%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     465:	00 05 49 02 a1 07    	add    %al,0x7a10249(%rip)        # 7a106b4 <_license+0x7a0e287>
     46b:	09 28                	or     %ebp,(%rax)
     46d:	05 43 0a 07 a1       	add    $0xa1070a43,%eax
     472:	00 00                	add    %al,(%rax)
     474:	00 05 44 00 0a 09    	add    %al,0x90a0044(%rip)        # 90a04be <_license+0x909e091>
     47a:	b6 00                	mov    $0x0,%dh
     47c:	00 00                	add    %al,(%rax)
     47e:	05 45 08 0a 0c       	add    $0xc0a0845,%eax
     483:	b6 00                	mov    $0x0,%dh
     485:	00 00                	add    %al,(%rax)
     487:	05 46 10 0a 14       	add    $0x140a1046,%eax
     48c:	9d                   	popf
     48d:	04 00                	add    $0x0,%al
     48f:	00 05 47 18 0a 15    	add    %al,0x150a1847(%rip)        # 150a1cdc <_license+0x1509f8af>
     495:	2f                   	(bad)
     496:	01 00                	add    %eax,(%rax)
     498:	00 05 48 20 00 0b    	add    %al,0xb002048(%rip)        # b0024e6 <_license+0xb0000b9>
  tcp = data + off;
     49e:	a2 04 00 00 04 b2 00 	movabs %al,0xb204000004
     4a5:	00 00 
  if (tcp + 1 > data_end) {
     4a7:	12 60 00             	adc    0x0(%rax),%ah
     4aa:	00 00                	add    %al,(%rax)
     4ac:	00 02                	add    %al,(%rdx)
     4ae:	00 02                	add    %al,(%rdx)
     4b0:	00 08                	add    %cl,(%rax)
     4b2:	35 bc 04 00 00       	xor    $0x4bc,%eax
  if (tcp->syn) {
     4b7:	05 52 02 a1 08       	add    $0x8a10252,%eax
     4bc:	09 28                	or     %ebp,(%rax)
    pckt->flags |= F_SYN_SET;
     4be:	05 4c 0a 07 a1       	add    $0xa1070a4c,%eax
     4c3:	00 00                	add    %al,(%rax)
     4c5:	00 05 4d 00 0a 09    	add    %al,0x90a004d(%rip)        # 90a0518 <_license+0x909e0eb>
     4cb:	b6 00                	mov    $0x0,%dh
     4cd:	00 00                	add    %al,(%rax)
     4cf:	05 4e 08 0a 0c       	add    $0xc0a084e,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     4d4:	ee                   	out    %al,(%dx)
     4d5:	04 00                	add    $0x0,%al
     4d7:	00 05 4f 10 0a 14    	add    %al,0x140a104f(%rip)        # 140a152c <_license+0x1409f0ff>
     4dd:	21 05 00 00 05 50    	and    %eax,0x50050000(%rip)        # 500504e3 <_license+0x5004e0b6>
    if (!icmp_ptb_v6_stats) {
     4e3:	18 0a                	sbb    %cl,(%rdx)
     4e5:	15 2f 01 00 00       	adc    $0x12f,%eax
    icmp_ptb_v6_stats->v1 += 1;
     4ea:	05 51 20 00 0b       	add    $0xb002051,%eax
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4ef:	f3 04 00             	repz add $0x0,%al
     4f2:	00 0d 36 14 03 54    	add    %cl,0x54031436(%rip)        # 5403192e <_license+0x5402f501>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     4f8:	0e                   	(bad)
     4f9:	00 05 00 00 03 55    	add    %al,0x55030000(%rip)        # 550304ff <_license+0x5502e0d2>
      icmp_ptb_v6_stats->v2 += 1;
     4ff:	00 0f                	add    %cl,(%rdi)
  if (ip6h + 1 > data_end) {
     501:	10 03                	adc    %al,(%rbx)
     503:	55                   	push   %rbp
     504:	0a 2a                	or     (%rdx),%ch
     506:	b8 01 00 00 03       	mov    $0x3000001,%eax
     50b:	56                   	push   %rsi
     50c:	00 0a                	add    %cl,(%rdx)
  pckt->flow.proto = ip6h->nexthdr;
     50e:	2b c0                	sub    %eax,%eax
     510:	01 00                	add    %eax,(%rax)
     512:	00 03                	add    %al,(%rbx)
  pckt->flags |= F_ICMP;
     514:	57                   	push   %rdi
     515:	00 00                	add    %al,(%rax)
     517:	0a 24 12             	or     (%rdx,%rdx,1),%ah
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     51a:	01 00                	add    %eax,(%rax)
     51c:	00 03                	add    %al,(%rbx)
     51e:	59                   	pop    %rcx
     51f:	10 00                	adc    %al,(%rax)
     521:	0b 26                	or     (%rsi),%esp
     523:	05 00 00 04 b2       	add    $0xb2040000,%eax
     528:	00 00                	add    %al,(%rax)
     52a:	00 10                	add    %dl,(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     52c:	60                   	(bad)
     52d:	00 00                	add    %al,(%rax)
     52f:	00 00                	add    %al,(%rax)
     531:	10 00                	adc    %al,(%rax)
     533:	08 37                	or     %dh,(%rdi)
     535:	3e 05 00 00 05 5b    	ds add $0x5b050000,%eax
     53b:	02 a1 09 09 28 05    	add    0x5280909(%rcx),%ah
     541:	55                   	push   %rbp
     542:	0a 07                	or     (%rdi),%al
     544:	70 05                	jo     54b <balancer_ingress+0x54b>
     546:	00 00                	add    %al,(%rax)
     548:	05 56 00 0a 09       	add    $0x90a0056,%eax
     54d:	b6 00                	mov    $0x0,%dh
     54f:	00 00                	add    %al,(%rax)
     551:	05 57 08 0a 0c       	add    $0xc0a0857,%eax
     556:	81 05 00 00 05 58 10 	addl   $0x21140a10,0x58050000(%rip)        # 58050560 <_license+0x5804e133>
     55d:	0a 14 21 
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     560:	05 00 00 05 59       	add    $0x59050000,%eax
     565:	18 0a                	sbb    %cl,(%rdx)
     567:	15 2f 01 00 00       	adc    $0x12f,%eax
     56c:	05 5a 20 00 0b       	add    $0xb00205a,%eax
     571:	75 05                	jne    578 <balancer_ingress+0x578>
BPF_MAP_OPS_INLINE(void*,
     573:	00 00                	add    %al,(%rax)
     575:	04 b2                	add    $0xb2,%al
     577:	00 00                	add    %al,(%rax)
     579:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 5df <balancer_ingress+0x5df>
     57f:	06                   	(bad)
     580:	00 0b                	add    %cl,(%rbx)
     582:	86 05 00 00 0d 3a    	xchg   %al,0x3a0d0000(%rip)        # 3a0d0588 <_license+0x3a0ce15b>
     588:	10 03                	adc    %al,(%rbx)
  if (decap_dst_flags) {
     58a:	5d                   	pop    %rbp
     58b:	0a 38                	or     (%rax),%bh
     58d:	fa                   	cli
     58e:	00 00                	add    %al,(%rax)
     590:	00 03                	add    %al,(%rbx)
     592:	5e                   	pop    %rsi
     593:	00 0a                	add    %cl,(%rdx)
     595:	39 fa                	cmp    %edi,%edx
     597:	00 00                	add    %al,(%rax)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     599:	00 03                	add    %al,(%rbx)
     59b:	5f                   	pop    %rdi
     59c:	08 00                	or     %al,(%rax)
     59e:	08 3b                	or     %bh,(%rbx)
     5a0:	a9 05 00 00 05       	test   $0x5000005,%eax
     5a5:	64 02 a1 0a 09 28 05 	add    %fs:0x528090a(%rcx),%ah
    if (!data_stats) {
     5ac:	5e                   	pop    %rsi
     5ad:	0a 07                	or     (%rdi),%al
     5af:	70 05                	jo     5b6 <balancer_ingress+0x5b6>
     5b1:	00 00                	add    %al,(%rax)
    data_stats->v1 += 1;
     5b3:	05 5f 00 0a 09       	add    $0x90a005f,%eax
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5b8:	b6 00                	mov    $0x0,%dh
     5ba:	00 00                	add    %al,(%rax)
     5bc:	05 60 08 0a 0c       	add    $0xc0a0860,%eax
     5c1:	b6 00                	mov    $0x0,%dh
     5c3:	00 00                	add    %al,(%rax)
     5c5:	05 61 10 0a 14       	add    $0x140a1061,%eax
    if (!--ip6h->hop_limit) {
     5ca:	21 05 00 00 05 62    	and    %eax,0x62050000(%rip)        # 620505d0 <_license+0x6204e1a3>
     5d0:	18 0a                	sbb    %cl,(%rdx)
     5d2:	15 2f 01 00 00       	adc    $0x12f,%eax
     5d7:	05 63 20 00 08       	add    $0x8002063,%eax
     5dc:	3c e6                	cmp    $0xe6,%al
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5de:	05 00 00 05 6c       	add    $0x6c050000,%eax
     5e3:	02 a1 0b 09 28 05    	add    0x528090b(%rcx),%ah
     5e9:	66 0a 07             	data16 or (%rdi),%al
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     5ec:	a1 00 00 00 05 67 00 	movabs 0x90a006705000000,%eax
     5f3:	0a 09 
     5f5:	b6 00                	mov    $0x0,%dh
     5f7:	00 00                	add    %al,(%rax)
     5f9:	05 68 08 0a 0c       	add    $0xc0a0868,%eax
     5fe:	60                   	(bad)
     5ff:	02 00                	add    (%rax),%al
     601:	00 05 69 10 0a 14    	add    %al,0x140a1069(%rip)        # 140a1670 <_license+0x1409f243>
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     607:	7d 01                	jge    60a <balancer_ingress+0x60a>
     609:	00 00                	add    %al,(%rax)
     60b:	05 6a 18 0a 15       	add    $0x150a186a,%eax
     610:	2f                   	(bad)
     611:	01 00                	add    %eax,(%rax)
     613:	00 05 6b 20 00 08    	add    %al,0x800206b(%rip)        # 8002684 <_license+0x8000257>
     619:	3d 23 06 00 00       	cmp    $0x623,%eax
     61e:	05 75 02 a1 0c       	add    $0xca10275,%eax
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     623:	09 28                	or     %ebp,(%rax)
     625:	05 6f 0a 07 70       	add    $0x70070a6f,%eax
     62a:	05 00 00 05 70       	add    $0x70050000,%eax
     62f:	00 0a                	add    %cl,(%rdx)
  if (!data_stats) {
     631:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
     637:	71 08                	jno    641 <balancer_ingress+0x641>
     639:	0a 0c 81             	or     (%rcx,%rax,4),%cl
     63c:	05 00 00 05 72       	add    $0x72050000,%eax
  if (action >= 0) {
     641:	10 0a                	adc    %cl,(%rdx)
     643:	14 55                	adc    $0x55,%al
     645:	06                   	(bad)
     646:	00 00                	add    %al,(%rax)
     648:	05 73 18 0a 15       	add    $0x150a1873,%eax
  if (decap_dst_flags) {
     64d:	2f                   	(bad)
  if (action >= 0) {
     64e:	01 00                	add    %eax,(%rax)
     650:	00 05 74 20 00 0b    	add    %al,0xb002074(%rip)        # b0026ca <_license+0xb00029d>
     656:	5a                   	pop    %rdx
     657:	06                   	(bad)
     658:	00 00                	add    %al,(%rax)
     65a:	04 b2                	add    $0xb2,%al
     65c:	00 00                	add    %al,(%rax)
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     65e:	00 10                	add    %dl,(%rax)
     660:	60                   	(bad)
     661:	00 00                	add    %al,(%rax)
     663:	00 00                	add    %al,(%rax)
     665:	04 00                	add    $0x0,%al
     667:	08 3e                	or     %bh,(%rsi)
     669:	72 06                	jb     671 <balancer_ingress+0x671>
     66b:	00 00                	add    %al,(%rax)
    if (xpop_stats_data) {
     66d:	05 7e 02 a1 0d       	add    $0xda1027e,%eax
     672:	09 28                	or     %ebp,(%rax)
     674:	05 78 0a 07 70       	add    $0x70070a78,%eax
     679:	05 00 00 05 79       	add    $0x79050000,%eax
     67e:	00 0a                	add    %cl,(%rdx)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     680:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
     686:	7a 08                	jp     690 <balancer_ingress+0x690>
     688:	0a 0c a4             	or     (%rsp,%riz,4),%cl
     68b:	06                   	(bad)
     68c:	00 00                	add    %al,(%rax)
     68e:	05 7b 10 0a 14       	add    $0x140a107b,%eax
     693:	7d 01                	jge    696 <balancer_ingress+0x696>
     695:	00 00                	add    %al,(%rax)
     697:	05 7c 18 0a 15       	add    $0x150a187c,%eax
     69c:	2f                   	(bad)
     69d:	01 00                	add    %eax,(%rax)
     69f:	00 05 7d 20 00 0b    	add    %al,0xb00207d(%rip)        # b002722 <_license+0xb0002f5>
     6a5:	a9 06 00 00 0d       	test   $0xd000006,%eax
     6aa:	4c 68 03 8e 0a 3f    	rex.WR push $0x3f0a8e03
  if (decap_dst_flags) {
     6b0:	fa                   	cli
     6b1:	00 00                	add    %al,(%rax)
     6b3:	00 03                	add    %al,(%rbx)
     6b5:	8f 00                	pop    (%rax)
     6b7:	0a 40 fa             	or     -0x6(%rax),%al
     6ba:	00 00                	add    %al,(%rax)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     6bc:	00 03                	add    %al,(%rbx)
     6be:	90                   	nop
     6bf:	08 0a                	or     %cl,(%rdx)
     6c1:	41 fa                	rex.B cli
     6c3:	00 00                	add    %al,(%rax)
     6c5:	00 03                	add    %al,(%rbx)
     6c7:	91                   	xchg   %eax,%ecx
     6c8:	10 0a                	adc    %cl,(%rdx)
     6ca:	42 fa                	rex.X cli
    if (!data_stats) {
     6cc:	00 00                	add    %al,(%rax)
     6ce:	00 03                	add    %al,(%rbx)
     6d0:	92                   	xchg   %eax,%edx
     6d1:	18 0a                	sbb    %cl,(%rdx)
     6d3:	43 fa                	rex.XB cli
    data_stats->v1 += 1;
     6d5:	00 00                	add    %al,(%rax)
     6d7:	00 03                	add    %al,(%rbx)
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     6d9:	93                   	xchg   %eax,%ebx
     6da:	20 0a                	and    %cl,(%rdx)
     6dc:	44 fa                	rex.R cli
     6de:	00 00                	add    %al,(%rax)
     6e0:	00 03                	add    %al,(%rbx)
     6e2:	94                   	xchg   %eax,%esp
     6e3:	28 0a                	sub    %cl,(%rdx)
     6e5:	45 fa                	rex.RB cli
     6e7:	00 00                	add    %al,(%rax)
     6e9:	00 03                	add    %al,(%rbx)
     6eb:	95                   	xchg   %eax,%ebp
    csum = iph->check + 0x0001;
     6ec:	30 0a                	xor    %cl,(%rdx)
     6ee:	46 fa                	rex.RX cli
     6f0:	00 00                	add    %al,(%rax)
     6f2:	00 03                	add    %al,(%rbx)
    iph->check = (csum & 0xffff) + (csum >> 16);
     6f4:	96                   	xchg   %eax,%esi
     6f5:	38 0a                	cmp    %cl,(%rdx)
     6f7:	47 fa                	rex.RXB cli
     6f9:	00 00                	add    %al,(%rax)
     6fb:	00 03                	add    %al,(%rbx)
     6fd:	97                   	xchg   %eax,%edi
     6fe:	40 0a 48 fa          	rex or -0x6(%rax),%cl
    if (!--iph->ttl) {
     702:	00 00                	add    %al,(%rax)
     704:	00 03                	add    %al,(%rbx)
     706:	98                   	cwtl
     707:	48 0a 49 fa          	rex.W or -0x6(%rcx),%cl
     70b:	00 00                	add    %al,(%rax)
     70d:	00 03                	add    %al,(%rbx)
     70f:	99                   	cltd
     710:	50                   	push   %rax
     711:	0a 4a fa             	or     -0x6(%rdx),%cl
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     714:	00 00                	add    %al,(%rax)
     716:	00 03                	add    %al,(%rbx)
     718:	9a                   	(bad)
     719:	58                   	pop    %rax
     71a:	0a 4b fa             	or     -0x6(%rbx),%cl
     71d:	00 00                	add    %al,(%rax)
     71f:	00 03                	add    %al,(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     721:	9b                   	fwait
     722:	60                   	(bad)
     723:	00 08                	add    %cl,(%rax)
     725:	4d 2f                	rex.WRB (bad)
     727:	07                   	(bad)
     728:	00 00                	add    %al,(%rax)
     72a:	05 87 02 a1 0e       	add    $0xea10287,%eax
     72f:	09 28                	or     %ebp,(%rax)
     731:	05 81 0a 07 70       	add    $0x70070a81,%eax
     736:	05 00 00 05 82       	add    $0x82050000,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     73b:	00 0a                	add    %cl,(%rdx)
     73d:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
     743:	83 08 0a             	orl    $0xa,(%rax)
     746:	0c 61                	or     $0x61,%al
     748:	07                   	(bad)
     749:	00 00                	add    %al,(%rax)
     74b:	05 84 10 0a 14       	add    $0x140a1084,%eax
     750:	7d 01                	jge    753 <balancer_ingress+0x753>
     752:	00 00                	add    %al,(%rax)
     754:	05 85 18 0a 15       	add    $0x150a1885,%eax
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     759:	2f                   	(bad)
     75a:	01 00                	add    %eax,(%rax)
     75c:	00 05 86 20 00 0b    	add    %al,0xb002086(%rip)        # b0027e8 <_license+0xb0003bb>
     762:	66 07                	data16 (bad)
     764:	00 00                	add    %al,(%rax)
  if (!data_stats) {
     766:	0d 4f 28 03 a7       	or     $0xa703284f,%eax
     76b:	0a 3f                	or     (%rdi),%bh
     76d:	fa                   	cli
     76e:	00 00                	add    %al,(%rax)
     770:	00 03                	add    %al,(%rbx)
     772:	a8 00                	test   $0x0,%al
  if (action >= 0) {
     774:	0a 43 fa             	or     -0x6(%rbx),%al
     777:	00 00                	add    %al,(%rax)
     779:	00 03                	add    %al,(%rbx)
     77b:	a9 08 0a 41 fa       	test   $0xfa410a08,%eax
  if (decap_dst_flags) {
     780:	00 00                	add    %al,(%rax)
     782:	00 03                	add    %al,(%rbx)
  if (action >= 0) {
     784:	aa                   	stos   %al,%es:(%rdi)
     785:	10 0a                	adc    %cl,(%rdx)
     787:	44 fa                	rex.R cli
     789:	00 00                	add    %al,(%rax)
     78b:	00 03                	add    %al,(%rbx)
     78d:	ab                   	stos   %eax,%es:(%rdi)
     78e:	18 0a                	sbb    %cl,(%rdx)
     790:	4e fa                	rex.WRX cli
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     792:	00 00                	add    %al,(%rax)
     794:	00 03                	add    %al,(%rbx)
     796:	ac                   	lods   %ds:(%rsi),%al
     797:	20 00                	and    %al,(%rax)
     799:	08 50 a4             	or     %dl,-0x5c(%rax)
     79c:	07                   	(bad)
     79d:	00 00                	add    %al,(%rax)
     79f:	05 90 02 a1 0f       	add    $0xfa10290,%eax
    if (xpop_stats_data) {
     7a4:	09 28                	or     %ebp,(%rax)
     7a6:	05 8a 0a 07 70       	add    $0x70070a8a,%eax
     7ab:	05 00 00 05 8b       	add    $0x8b050000,%eax
  udp = data + off;
     7b0:	00 0a                	add    %cl,(%rdx)
     7b2:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
     7b8:	8c 08                	mov    %cs,(%rax)
  if (udp + 1 > data_end) {
     7ba:	0a 0c 81             	or     (%rcx,%rax,4),%cl
     7bd:	05 00 00 05 8d       	add    $0x8d050000,%eax
     7c2:	10 0a                	adc    %cl,(%rdx)
     7c4:	14 cc                	adc    $0xcc,%al
     7c6:	01 00                	add    %eax,(%rax)
     7c8:	00 05 8e 18 0a 15    	add    %al,0x150a188e(%rip)        # 150a205c <_license+0x1509fc2f>
     7ce:	2f                   	(bad)
     7cf:	01 00                	add    %eax,(%rax)
     7d1:	00 05 8f 20 00 08    	add    %al,0x800208f(%rip)        # 8002866 <_license+0x8000439>
     7d7:	51                   	push   %rcx
     7d8:	e1 07                	loope  7e1 <balancer_ingress+0x7e1>
     7da:	00 00                	add    %al,(%rax)
     7dc:	05 a3 02 a1 10       	add    $0x10a102a3,%eax
     7e1:	09 28                	or     %ebp,(%rax)
     7e3:	05 9d 0a 07 a1       	add    $0xa1070a9d,%eax
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     7e8:	00 00                	add    %al,(%rax)
     7ea:	00 05 9e 00 0a 09    	add    %al,0x90a009e(%rip)        # 90a088e <_license+0x909e461>
     7f0:	b6 00                	mov    $0x0,%dh
     7f2:	00 00                	add    %al,(%rax)
     7f4:	05 9f 08 0a 0c       	add    $0xc0a089f,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     7f9:	b6 00                	mov    $0x0,%dh
     7fb:	00 00                	add    %al,(%rax)
     7fd:	05 a0 10 0a 14       	add    $0x140a10a0,%eax
     802:	13 08                	adc    (%rax),%ecx
     804:	00 00                	add    %al,(%rax)
    if (!icmp_ptb_v4_stats) {
     806:	05 a1 18 0a 15       	add    $0x150a18a1,%eax
     80b:	2f                   	(bad)
     80c:	01 00                	add    %eax,(%rax)
     80e:	00 05 a2 20 00 0b    	add    %al,0xb0020a2(%rip)        # b0028b6 <_license+0xb000489>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     814:	18 08                	sbb    %cl,(%rax)
     816:	00 00                	add    %al,(%rax)
     818:	04 b2                	add    $0xb2,%al
      icmp_ptb_v4_stats->v2 += 1;
     81a:	00 00                	add    %al,(%rax)
     81c:	00 12                	add    %dl,(%rdx)
  if (iph + 1 > data_end) {
     81e:	60                   	(bad)
     81f:	00 00                	add    %al,(%rax)
     821:	00 fe                	add    %bh,%dh
     823:	ff                   	(bad)
     824:	ff 00                	incl   (%rax)
     826:	00 08                	add    %cl,(%rax)
     828:	52                   	push   %rdx
     829:	32 08                	xor    (%rax),%cl
  if (iph->ihl != 5) {
     82b:	00 00                	add    %al,(%rax)
     82d:	05 dc 02 a1 11       	add    $0x11a102dc,%eax
     832:	09 28                	or     %ebp,(%rax)
     834:	05 d6 0a 07 70       	add    $0x70070ad6,%eax
  pckt->flow.proto = iph->protocol;
     839:	05 00 00 05 d7       	add    $0xd7050000,%eax
  pckt->flags |= F_ICMP;
     83e:	00 0a                	add    %cl,(%rdx)
     840:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
  pckt->flow.src = iph->daddr;
     846:	d8 08                	fmuls  (%rax)
     848:	0a 0c 64             	or     (%rsp,%riz,2),%cl
  pckt->flow.dst = iph->saddr;
     84b:	08 00                	or     %al,(%rax)
     84d:	00 05 d9 10 0a 14    	add    %al,0x140a10d9(%rip)        # 140a192c <_license+0x1409f4ff>
     853:	7d 01                	jge    856 <balancer_ingress+0x856>
     855:	00 00                	add    %al,(%rax)
     857:	05 da 18 0a 15       	add    $0x150a18da,%eax
     85c:	2f                   	(bad)
     85d:	01 00                	add    %eax,(%rax)
     85f:	00 05 db 20 00 0b    	add    %al,0xb0020db(%rip)        # b002940 <_license+0xb000513>
     865:	69 08 00 00 0d 55    	imul   $0x550d0000,(%rax),%ecx
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     86b:	20 03                	and    %al,(%rbx)
     86d:	9f                   	lahf
     86e:	0a 3f                	or     (%rdi),%bh
     870:	fa                   	cli
     871:	00 00                	add    %al,(%rax)
     873:	00 03                	add    %al,(%rbx)
     875:	a0 00 0a 4a fa 00 00 	movabs 0x3000000fa4a0a00,%al
     87c:	00 03 
     87e:	a1 08 0a 53 fa 00 00 	movabs 0x3000000fa530a08,%eax
     885:	00 03 
  vip.port = pckt.flow.port16[1];
     887:	a2 10 0a 54 fa 00 00 	movabs %al,0x3000000fa540a10
     88e:	00 03 
  vip.proto = pckt.flow.proto;
     890:	a3 18 00 08 56 9e 08 	movabs %eax,0x89e56080018
     897:	00 00 
     899:	05 e4 02 a1 12       	add    $0x12a102e4,%eax
     89e:	09 28                	or     %ebp,(%rax)
     8a0:	05 de 0a 07 70       	add    $0x70070ade,%eax
     8a5:	05 00 00 05 df       	add    $0xdf050000,%eax
     8aa:	00 0a                	add    %cl,(%rdx)
  if (!vip_info) {
     8ac:	09 b6 00 00 00 05    	or     %esi,0x5000000(%rsi)
     8b2:	e0 08                	loopne 8bc <balancer_ingress+0x8bc>
     8b4:	0a 0c 81             	or     (%rcx,%rax,4),%cl
  if (data_end - data > MAX_PCKT_SIZE) {
     8b7:	05 00 00 05 e1       	add    $0xe1050000,%eax
     8bc:	10 0a                	adc    %cl,(%rdx)
     8be:	14 cc                	adc    $0xcc,%al
     8c0:	01 00                	add    %eax,(%rax)
     8c2:	00 05 e2 18 0a 15    	add    %al,0x150a18e2(%rip)        # 150a21aa <_license+0x1509fd7d>
     8c8:	2f                   	(bad)
     8c9:	01 00                	add    %eax,(%rax)
     8cb:	00 05 e3 20 00 08    	add    %al,0x80020e3(%rip)        # 80029b4 <_license+0x8000587>
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8d1:	57                   	push   %rdi
     8d2:	db 08                	fisttpl (%rax)
     8d4:	00 00                	add    %al,(%rax)
     8d6:	05 f8 02 a1 13       	add    $0x13a102f8,%eax
     8db:	09 28                	or     %ebp,(%rax)
     8dd:	05 e7 0a 07 48       	add    $0x48070ae7,%eax
  if (!data_stats) {
     8e2:	09 00                	or     %eax,(%rax)
     8e4:	00 05 e8 00 0a 09    	add    %al,0x90a00e8(%rip)        # 90a09d2 <_license+0x909e5a5>
  data_stats->v1 += 1;
     8ea:	60                   	(bad)
     8eb:	02 00                	add    (%rax),%al
     8ed:	00 05 e9 08 0a 0c    	add    %al,0xc0a08e9(%rip)        # c0a11dc <_license+0xc09edaf>
    pckt.flow.port16[0] = 0;
     8f3:	b6 00                	mov    $0x0,%dh
     8f5:	00 00                	add    %al,(%rax)
     8f7:	05 ea 10 0a 14       	add    $0x140a10ea,%eax
  vip_num = vip_info->vip_num;
     8fc:	cc                   	int3
     8fd:	01 00                	add    %eax,(%rax)
     8ff:	00 05 eb 18 0a 15    	add    %al,0x150a18eb(%rip)        # 150a21f0 <_license+0x1509fdc3>
  __u32 cpu_num = bpf_get_smp_processor_id();
     905:	7d 01                	jge    908 <balancer_ingress+0x908>
     907:	00 00                	add    %al,(%rax)
     909:	05 ec 20 0a 33       	add    $0x330a20ec,%eax
     90e:	59                   	pop    %rcx
     90f:	09 00                	or     %eax,(%rax)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     911:	00 05 ed 28 09 28    	add    %al,0x280928ed(%rip)        # 28093204 <_license+0x28090dd7>
     917:	05 ed 0a 07 7d       	add    $0x7d070aed,%eax
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     91c:	01 00                	add    %eax,(%rax)
     91e:	00 05 ed 00 0a 09    	add    %al,0x90a00ed(%rip)        # 90a0a11 <_license+0x909e5e4>
     924:	b6 00                	mov    $0x0,%dh
     926:	00 00                	add    %al,(%rax)
     928:	05 ed 08 0a 0c       	add    $0xc0a08ed,%eax
    if (!lru_stats) {
     92d:	69 09 00 00 05 ed    	imul   $0xed050000,(%rcx),%ecx
     933:	10 0a                	adc    %cl,(%rdx)
    lru_stats->v1 += 1;
     935:	14 21                	adc    $0x21,%al
     937:	05 00 00 05 ed       	add    $0xed050000,%eax
     93c:	18 0a                	sbb    %cl,(%rdx)
     93e:	15 7d 01 00 00       	adc    $0x17d,%eax
     943:	05 ed 20 00 00       	add    $0x20ed,%eax
     948:	0b 4d 09             	or     0x9(%rbp),%ecx
     94b:	00 00                	add    %al,(%rax)
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     94d:	04 b2                	add    $0xb2,%al
     94f:	00 00                	add    %al,(%rax)
     951:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 9b7 <balancer_ingress+0x9b7>
     957:	0d 00 04 64 09       	or     $0x9640400,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     95c:	00 00                	add    %al,(%rax)
     95e:	11 60 00             	adc    %esp,0x0(%rax)
     961:	00 00                	add    %al,(%rax)
     963:	00 0b                	add    %cl,(%rbx)
     965:	15 09 00 00 0b       	adc    $0xb000009,%eax
     96a:	12 01                	adc    (%rcx),%al
    if (!icmp_ptb_v4_stats) {
     96c:	00 00                	add    %al,(%rax)
     96e:	13 58 76             	adc    0x76(%rax),%ebx
     971:	09 00                	or     %eax,(%rax)
     973:	00 06                	add    %al,(%rsi)
    icmp_ptb_v4_stats->v1 += 1;
     975:	6c                   	insb   (%dx),%es:(%rdi)
     976:	0b 7b 09             	or     0x9(%rbx),%edi
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     979:	00 00                	add    %al,(%rax)
     97b:	14 b2                	adc    $0xb2,%al
     97d:	00 00                	add    %al,(%rax)
      icmp_ptb_v4_stats->v2 += 1;
     97f:	00 15 8b 09 00 00    	add    %dl,0x98b(%rip)        # 1310 <balancer_ingress+0x1310>
  if (iph + 1 > data_end) {
     985:	15 b2 00 00 00       	adc    $0xb2,%eax
     98a:	00 16                	add    %dl,(%rsi)
     98c:	13 59 94             	adc    -0x6c(%rcx),%ebx
     98f:	09 00                	or     %eax,(%rax)
  if (iph->ihl != 5) {
     991:	00 06                	add    %al,(%rsi)
     993:	38 0b                	cmp    %cl,(%rbx)
     995:	99                   	cltd
     996:	09 00                	or     %eax,(%rax)
     998:	00 17                	add    %dl,(%rdi)
     99a:	02 01                	add    (%rcx),%al
     99c:	00 00                	add    %al,(%rax)
  pckt->flow.proto = iph->protocol;
     99e:	18 c3                	sbb    %al,%bl
     9a0:	00 00                	add    %al,(%rax)
     9a2:	00 5f 04             	add    %bl,0x4(%rdi)
  pckt->flags |= F_ICMP;
     9a5:	07                   	(bad)
     9a6:	28 0c 19             	sub    %cl,(%rcx,%rbx,1)
  pckt->flow.src = iph->daddr;
     9a9:	5a                   	pop    %rdx
     9aa:	00 19                	add    %bl,(%rcx)
     9ac:	5b                   	pop    %rbx
     9ad:	01 19                	add    %ebx,(%rcx)
     9af:	5c                   	pop    %rsp
  pckt->flow.dst = iph->saddr;
     9b0:	02 19                	add    (%rcx),%bl
     9b2:	5d                   	pop    %rbp
     9b3:	03 19                	add    (%rcx),%ebx
     9b5:	5e                   	pop    %rsi
     9b6:	04 00                	add    $0x0,%al
     9b8:	1a c3                	sbb    %bl,%al
     9ba:	00 00                	add    %al,(%rax)
    vip.port = 0;
     9bc:	00 04 08             	add    %al,(%rax,%rcx,1)
     9bf:	1d 19 60 00 19       	sbb    $0x19006019,%eax
     9c4:	61                   	(bad)
     9c5:	01 19                	add    %ebx,(%rcx)
     9c7:	62 02                	(bad)
     9c9:	19 63 04             	sbb    %esp,0x4(%rbx)
     9cc:	19 64 06 19          	sbb    %esp,0x19(%rsi,%rax,1)
     9d0:	65 08 19             	or     %bl,%gs:(%rcx)
    if (!vip_info) {
     9d3:	66 0c 19             	data16 or $0x19,%al
     9d6:	67 11 19             	adc    %ebx,(%ecx)
     9d9:	68 16 19 69 1d       	push   $0x1d691916
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     9de:	19 6a 21             	sbb    %ebp,0x21(%rdx)
     9e1:	19 6b 29             	sbb    %ebp,0x29(%rbx)
     9e4:	19 6c 2e 19          	sbb    %ebp,0x19(%rsi,%rbp,1)
      pckt.flow.port16[1] = 0;
     9e8:	6d                   	insl   (%dx),%es:(%rdi)
     9e9:	2f                   	(bad)
     9ea:	19 6e 32             	sbb    %ebp,0x32(%rsi)
     9ed:	19 6f 33             	sbb    %ebp,0x33(%rdi)
     9f0:	19 70 5c             	sbb    %esi,0x5c(%rax)
  struct address dst_addr = {};
     9f3:	19 71 5e             	sbb    %esi,0x5e(%rcx)
     9f6:	19 72 62             	sbb    %esi,0x62(%rdx)
     9f9:	19 73 67             	sbb    %esi,0x67(%rbx)
     9fc:	19 74 6c 19          	sbb    %esi,0x19(%rsp,%rbp,2)
     a00:	75 73                	jne    a75 <balancer_ingress+0xa75>
     a02:	19 76 84             	sbb    %esi,-0x7c(%rsi)
    dst_addr.addr = pckt->flow.dst;
     a05:	01 19                	add    %ebx,(%rcx)
     a07:	77 88                	ja     991 <balancer_ingress+0x991>
     a09:	01 19                	add    %ebx,(%rcx)
     a0b:	78 89                	js     996 <balancer_ingress+0x996>
     a0d:	01 19                	add    %ebx,(%rcx)
     a0f:	79 8f                	jns    9a0 <balancer_ingress+0x9a0>
     a11:	01 19                	add    %ebx,(%rcx)
     a13:	7a 90                	jp     9a5 <balancer_ingress+0x9a5>
     a15:	01 19                	add    %ebx,(%rcx)
     a17:	7b ff                	jnp    a18 <balancer_ingress+0xa18>
     a19:	01 19                	add    %ebx,(%rcx)
     a1b:	7c 80                	jl     99d <balancer_ingress+0x99d>
     a1d:	02 19                	add    (%rcx),%bl
     a1f:	7d 86                	jge    9a7 <balancer_ingress+0x9a7>
     a21:	02 19                	add    (%rcx),%bl
  if (decap_dst_flags) {
     a23:	7e 87                	jle    9ac <balancer_ingress+0x9ac>
     a25:	02 00                	add    (%rax),%al
     a27:	06                   	(bad)
     a28:	7f 05                	jg     a2f <balancer_ingress+0xa2f>
     a2a:	08 0b                	or     %cl,(%rbx)
     a2c:	2e 02 00             	cs add (%rax),%al
     a2f:	00 0b                	add    %cl,(%rbx)
     a31:	fa                   	cli
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a32:	00 00                	add    %al,(%rax)
     a34:	00 0b                	add    %cl,(%rbx)
     a36:	5c                   	pop    %rsp
     a37:	00 00                	add    %al,(%rax)
     a39:	00 0b                	add    %cl,(%rbx)
     a3b:	23 06                	and    (%rsi),%eax
     a3d:	00 00                	add    %al,(%rax)
     a3f:	0b ca                	or     %edx,%ecx
     a41:	03 00                	add    (%rax),%eax
    if (!data_stats) {
     a43:	00 0b                	add    %cl,(%rbx)
     a45:	72 06                	jb     a4d <balancer_ingress+0xa4d>
     a47:	00 00                	add    %al,(%rax)
     a49:	0b e1                	or     %ecx,%esp
    data_stats->v1 += 1;
     a4b:	07                   	(bad)
     a4c:	00 00                	add    %al,(%rax)
     a4e:	0b bc 04 00 00 0b 6f 	or     0x6f0b0000(%rsp,%rax,1),%edi
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     a55:	00 00                	add    %al,(%rax)
     a57:	00 0b                	add    %cl,(%rbx)
     a59:	3e 05 00 00 0b 9c    	ds add $0x9c0b0000,%eax
     a5f:	02 00                	add    (%rax),%al
     a61:	00 0b                	add    %cl,(%rbx)
     a63:	4b 01 00             	rex.WXB add %rax,(%r8)
     a66:	00 0b                	add    %cl,(%rbx)
    csum = iph->check + 0x0001;
     a68:	6c                   	insb   (%dx),%es:(%rdi)
     a69:	0a 00                	or     (%rax),%al
     a6b:	00 0d 8f 28 09 76    	add    %cl,0x7609288f(%rip)        # 76093300 <_license+0x76090ed3>
    iph->check = (csum & 0xffff) + (csum >> 16);
     a71:	1b 80 12 01 00 00    	sbb    0x112(%rax),%eax
     a77:	09 78 01             	or     %edi,0x1(%rax)
    if (!--iph->ttl) {
     a7a:	04 04                	add    $0x4,%al
     a7c:	00 1b                	add    %bl,(%rbx)
     a7e:	81 12 01 00 00 09    	adcl   $0x9000001,(%rdx)
     a84:	79 01                	jns    a87 <balancer_ingress+0xa87>
     a86:	04 00                	add    $0x0,%al
     a88:	00 0a                	add    %cl,(%rdx)
     a8a:	82                   	(bad)
     a8b:	fa                   	cli
     a8c:	0a 00                	or     (%rax),%al
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     a8e:	00 09                	add    %cl,(%rcx)
     a90:	80 01 0a             	addb   $0xa,(%rcx)
     a93:	83 06 0b             	addl   $0xb,(%rsi)
     a96:	00 00                	add    %al,(%rax)
     a98:	09 82 04 0a 85 12    	or     %eax,0x12850a04(%rdx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     a9e:	01 00                	add    %eax,(%rax)
     aa0:	00 09                	add    %cl,(%rcx)
     aa2:	83 06 0a             	addl   $0xa,(%rsi)
     aa5:	86 12                	xchg   %dl,(%rdx)
  new_eth->h_proto = BE_ETH_P_IP;
     aa7:	01 00                	add    %eax,(%rax)
     aa9:	00 09                	add    %cl,(%rcx)
     aab:	84 07                	test   %al,(%rdi)
     aad:	0e                   	(bad)
     aae:	b5 0a                	mov    $0xa,%ch
     ab0:	00 00                	add    %al,(%rax)
     ab2:	09 86 08 0f 20 09    	or     %eax,0x9200f08(%rsi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     ab8:	86 0e                	xchg   %cl,(%rsi)
     aba:	c1 0a 00             	rorl   $0x0,(%rdx)
     abd:	00 09                	add    %cl,(%rcx)
     abf:	86 00                	xchg   %al,(%rax)
     ac1:	09 20                	or     %esp,(%rax)
     ac3:	09 86 0a 87 0e 0b    	or     %eax,0xb0e870a(%rsi)
     ac9:	00 00                	add    %al,(%rax)
     acb:	09 86 00 0a 8d 0e    	or     %eax,0xe8d0a00(%rsi)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     ad1:	0b 00                	or     (%rax),%eax
     ad3:	00 09                	add    %cl,(%rcx)
     ad5:	86 10                	xchg   %dl,(%rax)
     ad7:	00 0a                	add    %cl,(%rdx)
     ad9:	8e e1                	mov    %ecx,%fs
     adb:	0a 00                	or     (%rax),%al
     add:	00 09                	add    %cl,(%rcx)
     adf:	86 00                	xchg   %al,(%rax)
  if (!data_stats) {
     ae1:	09 20                	or     %esp,(%rax)
     ae3:	09 86 0a 87 0e 0b    	or     %eax,0xb0e870a(%rsi)
     ae9:	00 00                	add    %al,(%rax)
     aeb:	09 86 00 0a 8d 0e    	or     %eax,0xe8d0a00(%rsi)
  if (action >= 0) {
     af1:	0b 00                	or     (%rax),%eax
     af3:	00 09                	add    %cl,(%rcx)
     af5:	86 10                	xchg   %dl,(%rax)
     af7:	00 00                	add    %al,(%rax)
     af9:	00 04 12             	add    %al,(%rdx,%rdx,1)
  if (decap_dst_flags) {
     afc:	01 00                	add    %eax,(%rax)
  if (action >= 0) {
     afe:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # b64 <balancer_ingress+0xb64>
     b04:	03 00                	add    (%rax),%eax
     b06:	0c 9c                	or     $0x9c,%al
     b08:	02 00                	add    (%rax),%al
     b0a:	00 84 04 20 0d 8c 10 	add    %al,0x108c0d20(%rsp,%rax,1)
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b11:	0a 21                	or     (%rcx),%ah
     b13:	0a 88 1c 0b 00 00    	or     0xb1c(%rax),%cl
     b19:	0a 28                	or     (%rax),%ch
     b1b:	00 0f                	add    %cl,(%rdi)
    if (xpop_stats_data) {
     b1d:	10 0a                	adc    %cl,(%rdx)
     b1f:	22 0a                	and    (%rdx),%cl
     b21:	89 3d 0b 00 00 0a    	mov    %edi,0xa00000b(%rip)        # a000b32 <_license+0x9ffe705>
     b27:	23 00                	and    (%rax),%eax
     b29:	0a 8a 49 0b 00 00    	or     0xb49(%rdx),%cl
     b2f:	0a 25 00 0a 8b c0    	or     -0x3f74f600(%rip),%ah        # ffffffffc08b1535 <server_id_map+0x36fc77615535>
     b35:	01 00                	add    %eax,(%rax)
     b37:	00 0a                	add    %cl,(%rdx)
     b39:	26 00 00             	es add %al,(%rax)
     b3c:	00 04 12             	add    %al,(%rdx,%rdx,1)
     b3f:	01 00                	add    %eax,(%rax)
     b41:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # ba7 <balancer_ingress+0xba7>
     b47:	10 00                	adc    %al,(%rax)
     b49:	04 06                	add    $0x6,%al
     b4b:	0b 00                	or     (%rax),%eax
     b4d:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # bb3 <balancer_ingress+0xbb3>
     b53:	08 00                	or     %al,(%rax)
     b55:	0b 5a 0b             	or     0xb(%rdx),%ebx
        bpf_map_lookup_elem(&stats, &stats_key);
     b58:	00 00                	add    %al,(%rax)
     b5a:	0d 99 14 0b 57       	or     $0x570b1499,%eax
     b5f:	1b 90 12 01 00 00    	sbb    0x112(%rax),%edx
     b65:	0b 59 01             	or     0x1(%rcx),%ebx
    if (!icmp_ptb_v6_stats) {
     b68:	04 04                	add    $0x4,%al
     b6a:	00 1b                	add    %bl,(%rbx)
     b6c:	81 12 01 00 00 0b    	adcl   $0xb000001,(%rdx)
    icmp_ptb_v6_stats->v1 += 1;
     b72:	5a                   	pop    %rdx
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     b73:	01 04 00             	add    %eax,(%rax,%rax,1)
     b76:	00 0a                	add    %cl,(%rdx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     b78:	91                   	xchg   %eax,%ecx
     b79:	12 01                	adc    (%rcx),%al
     b7b:	00 00                	add    %al,(%rax)
     b7d:	0b 61 01             	or     0x1(%rcx),%esp
      icmp_ptb_v6_stats->v2 += 1;
     b80:	0a 92 06 0b 00 00    	or     0xb06(%rdx),%dl
  if (ip6h + 1 > data_end) {
     b86:	0b 62 02             	or     0x2(%rdx),%esp
     b89:	0a 93 06 0b 00 00    	or     0xb06(%rbx),%dl
     b8f:	0b 63 04             	or     0x4(%rbx),%esp
     b92:	0a 94 06 0b 00 00 0b 	or     0xb00000b(%rsi,%rax,1),%dl
  pckt->flow.proto = ip6h->nexthdr;
     b99:	64 06                	fs (bad)
     b9b:	0a 95 12 01 00 00    	or     0x112(%rbp),%dl
  pckt->flags |= F_ICMP;
     ba1:	0b 65 08             	or     0x8(%rbp),%esp
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     ba4:	0a 96 12 01 00 00    	or     0x112(%rsi),%dl
     baa:	0b 66 09             	or     0x9(%rsi),%esp
     bad:	0a 97 03 0c 00 00    	or     0xc03(%rdi),%dl
     bb3:	0b 67 0a             	or     0xa(%rdi),%esp
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     bb6:	0e                   	(bad)
     bb7:	be 0b 00 00 0b       	mov    $0xb00000b,%esi
     bbc:	68 0c 0f 08 0b       	push   $0xb080f0c
     bc1:	68 0e ca 0b 00       	push   $0xbca0e
     bc6:	00 0b                	add    %cl,(%rbx)
     bc8:	68 00 09 08 0b       	push   $0xb080900
  if (protocol == IPPROTO_IPIP) {
     bcd:	68 0a 87 b8 01       	push   $0x1b8870a
     bd2:	00 00                	add    %al,(%rax)
     bd4:	0b 68 00             	or     0x0(%rax),%ebp
     bd7:	0a 8d b8 01 00 00    	or     0x1b8(%rbp),%cl
     bdd:	0b 68 04             	or     0x4(%rax),%ebp
     be0:	00 0a                	add    %cl,(%rdx)
     be2:	8e ea                	mov    %edx,%gs
     be4:	0b 00                	or     (%rax),%eax
  struct address dst_addr = {};
     be6:	00 0b                	add    %cl,(%rbx)
     be8:	68 00 09 08 0b       	push   $0xb080900
     bed:	68 0a 87 b8 01       	push   $0x1b8870a
     bf2:	00 00                	add    %al,(%rax)
     bf4:	0b 68 00             	or     0x0(%rax),%ebp
    dst_addr.addr = pckt->flow.dst;
     bf7:	0a 8d b8 01 00 00    	or     0x1b8(%rbp),%cl
     bfd:	0b 68 04             	or     0x4(%rax),%ebp
     c00:	00 00                	add    %al,(%rax)
     c02:	00 0c 9c             	add    %cl,(%rsp,%rbx,4)
     c05:	02 00                	add    (%rax),%al
     c07:	00 98 04 26 0b 10    	add    %bl,0x100b2604(%rax)
     c0d:	0c 00                	or     $0x0,%al
     c0f:	00 14 b2             	add    %dl,(%rdx,%rsi,4)
     c12:	00 00                	add    %al,(%rax)
     c14:	00 15 8b 09 00 00    	add    %dl,0x98b(%rip)        # 15a5 <balancer_ingress+0x15a5>
  if (decap_dst_flags) {
     c1a:	00 0b                	add    %cl,(%rbx)
     c1c:	20 0c 00             	and    %cl,(%rax,%rax,1)
     c1f:	00 14 8b             	add    %dl,(%rbx,%rcx,4)
     c22:	09 00                	or     %eax,(%rax)
     c24:	00 15 8b 09 00 00    	add    %dl,0x98b(%rip)        # 15b5 <balancer_ingress+0x15b5>
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c2a:	15 8b 09 00 00       	adc    $0x98b,%eax
     c2f:	00 0b                	add    %cl,(%rbx)
     c31:	35 0c 00 00 0d       	xor    $0xd00000c,%eax
    if (!data_stats) {
     c36:	9c                   	pushf
     c37:	0e                   	(bad)
     c38:	0c 29                	or     $0x29,%al
     c3a:	0a 24 12             	or     (%rdx,%rdx,1),%ah
     c3d:	01 00                	add    %eax,(%rax)
    data_stats->v1 += 1;
     c3f:	00 0c 2a             	add    %cl,(%rdx,%rbp,1)
    if ((*data + offset) > *data_end) {
     c42:	00 0a                	add    %cl,(%rdx)
     c44:	81 bb 00 00 00 0c 2b 	cmpl   $0x9a0a012b,0xc000000(%rbx)
     c4b:	01 0a 9a 
     c4e:	12 01                	adc    (%rcx),%al
     c50:	00 00                	add    %al,(%rax)
     c52:	0c 2e                	or     $0x2e,%al
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     c54:	05 0a 9b 5f 0c       	add    $0xc5f9b0a,%eax
     c59:	00 00                	add    %al,(%rax)
     c5b:	0c 32                	or     $0x32,%al
     c5d:	06                   	(bad)
     c5e:	00 04 12             	add    %al,(%rdx,%rdx,1)
     c61:	01 00                	add    %eax,(%rax)
     c63:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # cc9 <balancer_ingress+0xcc9>
    if (!--ip6h->hop_limit) {
     c69:	08 00                	or     %al,(%rax)
     c6b:	0b 70 0c             	or     0xc(%rax),%esi
     c6e:	00 00                	add    %al,(%rax)
     c70:	0d 9e 09 0c 35       	or     $0x350c099e,%eax
     c75:	0a 24 12             	or     (%rdx,%rdx,1),%ah
     c78:	01 00                	add    %eax,(%rax)
     c7a:	00 0c 36             	add    %cl,(%rsi,%rsi,1)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     c7d:	00 0a                	add    %cl,(%rdx)
     c7f:	9d                   	popf
     c80:	5f                   	pop    %rdi
     c81:	0c 00                	or     $0x0,%al
     c83:	00 0c 37             	add    %cl,(%rdi,%rsi,1)
     c86:	01 00                	add    %eax,(%rax)
     c88:	0b 8d 0c 00 00 14    	or     0x1400000c(%rbp),%ecx
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     c8e:	b2 00                	mov    $0x0,%dl
     c90:	00 00                	add    %al,(%rax)
     c92:	15 8b 09 00 00       	adc    $0x98b,%eax
     c97:	15 8b 09 00 00       	adc    $0x98b,%eax
     c9c:	15 8b 09 00 00       	adc    $0x98b,%eax
     ca1:	15 02 01 00 00       	adc    $0x102,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     ca6:	00 0b                	add    %cl,(%rbx)
     ca8:	9e                   	sahf
     ca9:	08 00                	or     %al,(%rax)
     cab:	00 0b                	add    %cl,(%rbx)
     cad:	db 08                	fisttpl (%rax)
     caf:	00 00                	add    %al,(%rax)
     cb1:	0b 6b 04             	or     0x4(%rbx),%ebp
     cb4:	00 00                	add    %al,(%rax)
     cb6:	0b bb 0c 00 00 0c    	or     0xc00000c(%rbx),%edi
     cbc:	c3                   	ret
     cbd:	00 00                	add    %al,(%rax)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     cbf:	00 9f 0d 35 0b e6    	add    %bl,-0x19f4caf3(%rdi)
     cc5:	05 00 00 0b a9       	add    $0xa90b0000,%eax
     cca:	05 00 00 1c a0       	add    $0xa01c0000,%eax
  if (!data_stats) {
     ccf:	00 a8 02 b2 00 00    	add    %ch,0xb202(%rax)
     cd5:	00 1d a1 00 a8 02    	add    %bl,0x2a800a1(%rip)        # 2a80d7c <_license+0x2a7e94f>
     cdb:	84 10                	test   %dl,(%rax)
  if (action >= 0) {
     cdd:	00 00                	add    %al,(%rax)
     cdf:	1d ac 00 a8 02       	sbb    $0x2a800ac,%eax
     ce4:	fa                   	cli
     ce5:	00 00                	add    %al,(%rax)
     ce7:	00 1d ad 00 a8 02    	add    %bl,0x2a800ad(%rip)        # 2a80d9a <_license+0x2a7e96d>
     ced:	ee                   	out    %al,(%dx)
     cee:	10 00                	adc    %al,(%rax)
     cf0:	00 1e                	add    %bl,(%rsi)
     cf2:	af                   	scas   %es:(%rdi),%eax
     cf3:	00 ad 02 f2 10 00    	add    %ch,0x10f202(%rbp)
     cf9:	00 1e                	add    %bl,(%rsi)
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     cfb:	1d 00 ae 02 65       	sbb    $0x6502ae00,%eax
     d00:	02 00                	add    (%rax),%al
     d02:	00 1e                	add    %bl,(%rsi)
     d04:	a2 00 a9 02 8b 09 00 	movabs %al,0x1e0000098b02a900
     d0b:	00 1e 
    if (xpop_stats_data) {
     d0d:	a3 00 aa 02 8b 09 00 	movabs %eax,0x1e0000098b02aa00
     d14:	00 1e 
     d16:	2a 00                	sub    (%rax),%al
     d18:	ac                   	lods   %ds:(%rsi),%al
  udp = data + off;
     d19:	02 ee                	add    %dh,%ch
     d1b:	04 00                	add    $0x0,%al
  if (is_ipv6) {
     d1d:	00 1e                	add    %bl,(%rsi)
  udp = data + off;
     d1f:	b3 00                	mov    $0x0,%bl
     d21:	b7 02                	mov    $0x2,%bh
  if (udp + 1 > data_end) {
     d23:	bb 00 00 00 1e       	mov    $0x1e000000,%ebx
     d28:	b4 00                	mov    $0x0,%ah
     d2a:	b9 02 fa 00 00       	mov    $0xfa02,%ecx
     d2f:	00 1e                	add    %bl,(%rsi)
     d31:	b5 00                	mov    $0x0,%ch
     d33:	b5 02                	mov    $0x2,%ch
     d35:	b2 00                	mov    $0x0,%dl
     d37:	00 00                	add    %al,(%rax)
     d39:	1e                   	(bad)
     d3a:	96                   	xchg   %eax,%esi
     d3b:	00 b2 02 12 01 00    	add    %dh,0x11202(%rdx)
     d41:	00 1e                	add    %bl,(%rsi)
     d43:	b6 00                	mov    $0x0,%dh
     d45:	af                   	scas   %es:(%rdi),%eax
     d46:	02 a8 02 00 00 1e    	add    0x1e000002(%rax),%ch
     d4c:	b7 00                	mov    $0x0,%bh
     d4e:	35 03 bb 00 00       	xor    $0xbb03,%eax
     d53:	00 1e                	add    %bl,(%rsi)
     d55:	b8 00 b0 02 81       	mov    $0x8102b000,%eax
     d5a:	05 00 00 1e b9       	add    $0xb91e0000,%eax
     d5f:	00 45 03             	add    %al,0x3(%rbp)
    vip.vip = pckt.flow.dst;
     d62:	bb 00 00 00 1e       	mov    $0x1e000000,%ebx
     d67:	ba 00 46 03 8b       	mov    $0x8b034600,%edx
  vip.port = pckt.flow.port16[1];
     d6c:	09 00                	or     %eax,(%rax)
     d6e:	00 1e                	add    %bl,(%rsi)
     d70:	bb 00 b8 02 9c       	mov    $0x9c02b800,%ebx
  vip.proto = pckt.flow.proto;
     d75:	02 00                	add    (%rax),%al
     d77:	00 1e                	add    %bl,(%rsi)
     d79:	bc 00 b3 02 9c       	mov    $0x9c02b300,%esp
     d7e:	02 00                	add    (%rax),%al
     d80:	00 1e                	add    %bl,(%rsi)
     d82:	bd 00 ab 02 c7       	mov    $0xc702ab00,%ebp
     d87:	00 00                	add    %al,(%rax)
     d89:	00 1e                	add    %bl,(%rsi)
     d8b:	be 00 b1 02 fa       	mov    $0xfa02b100,%esi
     d90:	00 00                	add    %al,(%rax)
     d92:	00 1e                	add    %bl,(%rsi)
     d94:	25 00 b6 02 bb       	and    $0xbb02b600,%eax
  if (!vip_info) {
     d99:	00 00                	add    %al,(%rax)
     d9b:	00 1f                	add    %bl,(%rdi)
     d9d:	1e                   	(bad)
     d9e:	bf 00 e8 02 ee       	mov    $0xee02e800,%edi
  if (data_end - data > MAX_PCKT_SIZE) {
     da3:	10 00                	adc    %al,(%rax)
     da5:	00 00                	add    %al,(%rax)
     da7:	1f                   	(bad)
     da8:	1e                   	(bad)
     da9:	bf 00 e0 02 ee       	mov    $0xee02e000,%edi
     dae:	10 00                	adc    %al,(%rax)
     db0:	00 00                	add    %al,(%rax)
     db2:	1f                   	(bad)
     db3:	1e                   	(bad)
     db4:	c0 00 12             	rolb   $0x12,(%rax)
     db7:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     dbd:	07                   	(bad)
     dbe:	00 12                	add    %dl,(%rdx)
     dc0:	03 1c 11             	add    (%rcx,%rdx,1),%ebx
     dc3:	00 00                	add    %al,(%rax)
     dc5:	00 1f                	add    %bl,(%rdi)
     dc7:	1e                   	(bad)
     dc8:	c0 00 15             	rolb   $0x15,(%rax)
  if (!data_stats) {
     dcb:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
     dd1:	07                   	(bad)
     dd2:	00 15 03 1c 11 00    	add    %dl,0x111c03(%rip)        # 1129db <_license+0x1105ae>
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     dd8:	00 00                	add    %al,(%rax)
     dda:	1f                   	(bad)
     ddb:	1e                   	(bad)
     ddc:	c0 00 36             	rolb   $0x36,(%rax)
    pckt.flow.port16[0] = 0;
     ddf:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
  vip_num = vip_info->vip_num;
     de5:	07                   	(bad)
     de6:	00 36                	add    %dh,(%rsi)
     de8:	03 1c 11             	add    (%rcx,%rdx,1),%ebx
     deb:	00 00                	add    %al,(%rax)
     ded:	1f                   	(bad)
  __u32 cpu_num = bpf_get_smp_processor_id();
     dee:	1e                   	(bad)
     def:	c1 00 36             	roll   $0x36,(%rax)
     df2:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
     df8:	14 00                	adc    $0x0,%al
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     dfa:	36 03 21             	ss add (%rcx),%esp
     dfd:	11 00                	adc    %eax,(%rax)
     dff:	00 1e                	add    %bl,(%rsi)
     e01:	c2 00 36             	ret    $0x3600
     e04:	03 21                	add    (%rcx),%esp
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e06:	11 00                	adc    %eax,(%rax)
     e08:	00 00                	add    %al,(%rax)
     e0a:	00 1f                	add    %bl,(%rdi)
     e0c:	1e                   	(bad)
     e0d:	c3                   	ret
     e0e:	00 45 03             	add    %al,0x3(%rbp)
     e11:	fa                   	cli
     e12:	00 00                	add    %al,(%rax)
     e14:	00 00                	add    %al,(%rax)
    if (!lru_stats) {
     e16:	1f                   	(bad)
     e17:	1e                   	(bad)
     e18:	c0 00 46             	rolb   $0x46,(%rax)
     e1b:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
    lru_stats->v1 += 1;
     e21:	07                   	(bad)
     e22:	00 46 03             	add    %al,0x3(%rsi)
     e25:	1c 11                	sbb    $0x11,%al
     e27:	00 00                	add    %al,(%rax)
     e29:	1f                   	(bad)
     e2a:	1e                   	(bad)
     e2b:	c1 00 46             	roll   $0x46,(%rax)
     e2e:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
     e34:	14 00                	adc    $0x0,%al
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e36:	46 03 21             	rex.RX add (%rcx),%r12d
     e39:	11 00                	adc    %eax,(%rax)
     e3b:	00 1e                	add    %bl,(%rsi)
     e3d:	c2 00 46             	ret    $0x4600
     e40:	03 21                	add    (%rcx),%esp
     e42:	11 00                	adc    %eax,(%rax)
     e44:	00 00                	add    %al,(%rax)
     e46:	00 1f                	add    %bl,(%rdi)
     e48:	1e                   	(bad)
     e49:	c4                   	(bad)
     e4a:	00 49 03             	add    %cl,0x3(%rcx)
     e4d:	bb 00 00 00 1e       	mov    $0x1e000000,%ebx
  if (!lru_map) {
     e52:	c5 00 4a             	(bad)
     e55:	03 81 05 00 00 1f    	add    0x1f000005(%rcx),%eax
  if ((vip_info->flags & F_QUIC_VIP)) {
     e5b:	1e                   	(bad)
     e5c:	c0 00 4a             	rolb   $0x4a,(%rax)
     e5f:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
    bool is_icmp = (pckt.flags & F_ICMP);
     e65:	07                   	(bad)
    if (is_icmp) {
     e66:	00 4a 03             	add    %cl,0x3(%rdx)
     e69:	1c 11                	sbb    $0x11,%al
     e6b:	00 00                	add    %al,(%rax)
     e6d:	1f                   	(bad)
     e6e:	1e                   	(bad)
     e6f:	c1 00 4a             	roll   $0x4a,(%rax)
     e72:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     e78:	14 00                	adc    $0x0,%al
     e7a:	4a 03 21             	rex.WX add (%rcx),%rsp
     e7d:	11 00                	adc    %eax,(%rax)
     e7f:	00 1e                	add    %bl,(%rsi)
     e81:	c2 00 4a             	ret    $0x4a00
     e84:	03 21                	add    (%rcx),%esp
      if (!quic_packets_stats) {
     e86:	11 00                	adc    %eax,(%rax)
     e88:	00 00                	add    %al,(%rax)
     e8a:	00 00                	add    %al,(%rax)
     e8c:	1f                   	(bad)
     e8d:	1e                   	(bad)
     e8e:	c6 00 56             	movb   $0x56,(%rax)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e91:	03 ee                	add    %esi,%ebp
  bool is_icmp = (pckt->flags & F_ICMP);
     e93:	10 00                	adc    %al,(%rax)
     e95:	00 1f                	add    %bl,(%rdi)
     e97:	1e                   	(bad)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e98:	c7 00 69 03 bb 00    	movl   $0xbb0369,(%rax)
     e9e:	00 00                	add    %al,(%rax)
     ea0:	1e                   	(bad)
     ea1:	c8 00 6a 03          	enter  $0x6a00,$0x3
     ea5:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     ea6:	06                   	(bad)
     ea7:	00 00                	add    %al,(%rax)
     ea9:	1e                   	(bad)
     eaa:	c9                   	leave
     eab:	00 6f 03             	add    %ch,0x3(%rdi)
     eae:	26 11 00             	es adc %eax,(%rax)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     eb1:	00 1f                	add    %bl,(%rdi)
     eb3:	1e                   	(bad)
     eb4:	c0 00 6b             	rolb   $0x6b,(%rax)
     eb7:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     ebd:	07                   	(bad)
     ebe:	00 6b 03             	add    %ch,0x3(%rbx)
     ec1:	1c 11                	sbb    $0x11,%al
     ec3:	00 00                	add    %al,(%rax)
     ec5:	1f                   	(bad)
     ec6:	1e                   	(bad)
     ec7:	c1 00 6b             	roll   $0x6b,(%rax)
     eca:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
    vip.port = 0;
     ed0:	14 00                	adc    $0x0,%al
     ed2:	6b 03 21             	imul   $0x21,(%rbx),%eax
     ed5:	11 00                	adc    %eax,(%rax)
     ed7:	00 1e                	add    %bl,(%rsi)
     ed9:	c2 00 6b             	ret    $0x6b00
     edc:	03 21                	add    (%rcx),%esp
     ede:	11 00                	adc    %eax,(%rax)
     ee0:	00 00                	add    %al,(%rax)
     ee2:	00 1f                	add    %bl,(%rdi)
    if (!vip_info) {
     ee4:	1e                   	(bad)
     ee5:	09 00                	or     %eax,(%rax)
     ee7:	74 03                	je     eec <balancer_ingress+0xeec>
     ee9:	bb 00 00 00 1e       	mov    $0x1e000000,%ebx
     eee:	ce                   	(bad)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     eef:	00 75 03             	add    %dh,0x3(%rbp)
     ef2:	b6 00                	mov    $0x0,%dh
     ef4:	00 00                	add    %al,(%rax)
     ef6:	1f                   	(bad)
     ef7:	1e                   	(bad)
      pckt.flow.port16[1] = 0;
     ef8:	c0 00 75             	rolb   $0x75,(%rax)
     efb:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
     f01:	07                   	(bad)
     f02:	00 75 03             	add    %dh,0x3(%rbp)
     f05:	1c 11                	sbb    $0x11,%al
     f07:	00 00                	add    %al,(%rax)
     f09:	1f                   	(bad)
     f0a:	1e                   	(bad)
     f0b:	c1 00 75             	roll   $0x75,(%rax)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     f0e:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
     f14:	14 00                	adc    $0x0,%al
     f16:	75 03                	jne    f1b <balancer_ingress+0xf1b>
     f18:	21 11                	and    %edx,(%rcx)
     f1a:	00 00                	add    %al,(%rax)
     f1c:	1e                   	(bad)
     f1d:	c2 00 75             	ret    $0x7500
      if (!data_stats) {
     f20:	03 21                	add    (%rcx),%esp
     f22:	11 00                	adc    %eax,(%rax)
     f24:	00 00                	add    %al,(%rax)
     f26:	00 1f                	add    %bl,(%rdi)
      data_stats->v1 += 1;
     f28:	1e                   	(bad)
     f29:	cf                   	iret
     f2a:	00 89 03 b2 00 00    	add    %cl,0xb203(%rcx)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     f30:	00 1f                	add    %bl,(%rdi)
     f32:	1e                   	(bad)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     f33:	c0 00 81             	rolb   $0x81,(%rax)
     f36:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
        data_stats->v2 += 1;
     f3c:	07                   	(bad)
     f3d:	00 81 03 1c 11 00    	add    %al,0x111c03(%rcx)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     f43:	00 1f                	add    %bl,(%rdi)
     f45:	1e                   	(bad)
     f46:	c1 00 81             	roll   $0x81,(%rax)
     f49:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
     f4f:	14 00                	adc    $0x0,%al
     f51:	81 03 21 11 00 00    	addl   $0x1121,(%rbx)
     f57:	1e                   	(bad)
     f58:	c2 00 81             	ret    $0x8100
  if (!lru_map) {
     f5b:	03 21                	add    (%rcx),%esp
     f5d:	11 00                	adc    %eax,(%rax)
     f5f:	00 00                	add    %al,(%rax)
     f61:	00 00                	add    %al,(%rax)
     f63:	00 00                	add    %al,(%rax)
     f65:	1f                   	(bad)
     f66:	1e                   	(bad)
     f67:	b7 00                	mov    $0x0,%bh
     f69:	5e                   	pop    %rsi
     f6a:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
  if ((vip_info->flags & F_QUIC_VIP)) {
     f70:	b8 00 5f 03 81       	mov    $0x81035f00,%eax
     f75:	05 00 00 1f 1e       	add    $0x1e1f0000,%eax
    bool is_icmp = (pckt.flags & F_ICMP);
     f7a:	c0 00 5f             	rolb   $0x5f,(%rax)
     f7d:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
     f83:	07                   	(bad)
     f84:	00 5f 03             	add    %bl,0x3(%rdi)
     f87:	1c 11                	sbb    $0x11,%al
     f89:	00 00                	add    %al,(%rax)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     f8b:	1f                   	(bad)
     f8c:	1e                   	(bad)
     f8d:	c1 00 5f             	roll   $0x5f,(%rax)
     f90:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
     f96:	14 00                	adc    $0x0,%al
     f98:	5f                   	pop    %rdi
     f99:	03 21                	add    (%rcx),%esp
      if (!quic_packets_stats) {
     f9b:	11 00                	adc    %eax,(%rax)
     f9d:	00 1e                	add    %bl,(%rsi)
     f9f:	c2 00 5f             	ret    $0x5f00
     fa2:	03 21                	add    (%rcx),%esp
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fa4:	11 00                	adc    %eax,(%rax)
     fa6:	00 00                	add    %al,(%rax)
  bool is_icmp = (pckt->flags & F_ICMP);
     fa8:	00 00                	add    %al,(%rax)
     faa:	00 1f                	add    %bl,(%rdi)
     fac:	1e                   	(bad)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fad:	c4                   	(bad)
     fae:	00 e9                	add    %ch,%cl
     fb0:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
     fb6:	c5 00 ea             	(bad)
     fb9:	03 81 05 00 00 1f    	add    0x1f000005(%rcx),%eax
     fbf:	1e                   	(bad)
     fc0:	c0 00 eb             	rolb   $0xeb,(%rax)
     fc3:	03 8b 09 00 00 1e    	add    0x1e000009(%rbx),%ecx
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fc9:	07                   	(bad)
     fca:	00 eb                	add    %ch,%bl
     fcc:	03 1c 11             	add    (%rcx,%rdx,1),%ebx
     fcf:	00 00                	add    %al,(%rax)
     fd1:	1f                   	(bad)
     fd2:	1e                   	(bad)
     fd3:	c1 00 eb             	roll   $0xeb,(%rax)
     fd6:	03 bb 00 00 00 1e    	add    0x1e000000(%rbx),%edi
     fdc:	14 00                	adc    $0x0,%al
     fde:	eb 03                	jmp    fe3 <balancer_ingress+0xfe3>
      if (!data_stats) {
     fe0:	21 11                	and    %edx,(%rcx)
     fe2:	00 00                	add    %al,(%rax)
     fe4:	1e                   	(bad)
     fe5:	c2 00 eb             	ret    $0xeb00
      data_stats->v1 += 1;
     fe8:	03 21                	add    (%rcx),%esp
     fea:	11 00                	adc    %eax,(%rax)
     fec:	00 00                	add    %al,(%rax)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     fee:	00 00                	add    %al,(%rax)
     ff0:	1f                   	(bad)
     ff1:	1e                   	(bad)
     ff2:	c0 00 0e             	rolb   $0xe,(%rax)
     ff5:	04 8b                	add    $0x8b,%al
     ff7:	09 00                	or     %eax,(%rax)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     ff9:	00 1e                	add    %bl,(%rsi)
        data_stats->v2 += 1;
     ffb:	07                   	(bad)
     ffc:	00 0e                	add    %cl,(%rsi)
     ffe:	04 1c                	add    $0x1c,%al
    1000:	11 00                	adc    %eax,(%rax)
    1002:	00 1f                	add    %bl,(%rdi)
  original_sport = pckt.flow.port16[0];
    1004:	1e                   	(bad)
    1005:	14 00                	adc    $0x0,%al
    1007:	0e                   	(bad)
    1008:	04 21                	add    $0x21,%al
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    100a:	11 00                	adc    %eax,(%rax)
    100c:	00 1e                	add    %bl,(%rsi)
    100e:	c2 00 0e             	ret    $0xe00
        !(vip_info->flags & F_LRU_BYPASS)) {
    1011:	04 21                	add    $0x21,%al
    1013:	11 00                	adc    %eax,(%rax)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1015:	00 1e                	add    %bl,(%rsi)
    1017:	c1 00 0e             	roll   $0xe,(%rax)
    101a:	04 bb                	add    $0xbb,%al
    101c:	00 00                	add    %al,(%rax)
    101e:	00 00                	add    %al,(%rax)
    1020:	00 1f                	add    %bl,(%rdi)
    1022:	1e                   	(bad)
    1023:	c0 00 16             	rolb   $0x16,(%rax)
  if (!dst_lru) {
    1026:	04 8b                	add    $0x8b,%al
    1028:	09 00                	or     %eax,(%rax)
    102a:	00 1e                	add    %bl,(%rsi)
    102c:	07                   	(bad)
    102d:	00 16                	add    %dl,(%rsi)
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    102f:	04 1c                	add    $0x1c,%al
    1031:	11 00                	adc    %eax,(%rax)
    1033:	00 1f                	add    %bl,(%rdi)
    1035:	1e                   	(bad)
    1036:	14 00                	adc    $0x0,%al
    1038:	16                   	(bad)
    1039:	04 21                	add    $0x21,%al
    103b:	11 00                	adc    %eax,(%rax)
    103d:	00 1e                	add    %bl,(%rsi)
    103f:	c2 00 16             	ret    $0x1600
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1042:	04 21                	add    $0x21,%al
    1044:	11 00                	adc    %eax,(%rax)
    1046:	00 1e                	add    %bl,(%rsi)
    1048:	c1 00 16             	roll   $0x16,(%rax)
    104b:	04 bb                	add    $0xbb,%al
    104d:	00 00                	add    %al,(%rax)
    104f:	00 00                	add    %al,(%rax)
    1051:	00 1f                	add    %bl,(%rdi)
    1053:	1e                   	(bad)
    1054:	c0 00 08             	rolb   $0x8,(%rax)
    1057:	04 8b                	add    $0x8b,%al
    1059:	09 00                	or     %eax,(%rax)
    105b:	00 1e                	add    %bl,(%rsi)
    105d:	07                   	(bad)
    105e:	00 08                	add    %cl,(%rax)
    1060:	04 1c                	add    $0x1c,%al
    1062:	11 00                	adc    %eax,(%rax)
    1064:	00 1f                	add    %bl,(%rdi)
    1066:	1e                   	(bad)
    1067:	c1 00 08             	roll   $0x8,(%rax)
    106a:	04 bb                	add    $0xbb,%al
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    106c:	00 00                	add    %al,(%rax)
    106e:	00 1e                	add    %bl,(%rsi)
    1070:	14 00                	adc    $0x0,%al
    1072:	08 04 21             	or     %al,(%rcx,%riz,1)
    1075:	11 00                	adc    %eax,(%rax)
    1077:	00 1e                	add    %bl,(%rsi)
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1079:	c2 00 08             	ret    $0x800
    107c:	04 21                	add    $0x21,%al
    107e:	11 00                	adc    %eax,(%rax)
    1080:	00 00                	add    %al,(%rax)
        quic_packets_stats->cid_initial += 1;
    1082:	00 00                	add    %al,(%rax)
    1084:	0b 89 10 00 00 20    	or     0x20000010(%rcx),%ecx
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    108a:	ab                   	stos   %eax,%es:(%rdi)
    108b:	38 07                	cmp    %al,(%rdi)
    108d:	3f                   	(bad)
    108e:	0c 21                	or     $0x21,%al
    1090:	a2 8b 09 00 00 07 40 	movabs %al,0xc40070000098b
    1097:	0c 00 
    1099:	21 a3 8b 09 00 00    	and    %esp,0x98b(%rbx)
    109f:	07                   	(bad)
    10a0:	41 0c 08             	rex.B or $0x8,%al
    10a3:	21 a4 8b 09 00 00 07 	and    %esp,0x7000009(%rbx,%rcx,4)
    10aa:	42 0c 10             	rex.X or $0x10,%al
    10ad:	21 a5 8b 09 00 00    	and    %esp,0x98b(%rbp)
    10b3:	07                   	(bad)
    10b4:	43 0c 18             	rex.XB or $0x18,%al
    10b7:	21 a6 e0 10 00 00    	and    %esp,0x10e0(%rsi)
  if (!per_vip_stats) {
    10bd:	07                   	(bad)
    10be:	44 0c 20             	rex.R or $0x20,%al
    10c1:	21 a8 e7 10 00 00    	and    %ebp,0x10e7(%rax)
    10c7:	07                   	(bad)
    10c8:	45 0c 28             	rex.RB or $0x28,%al
    10cb:	21 aa bb 00 00 00    	and    %ebp,0xbb(%rdx)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    10d1:	07                   	(bad)
    10d2:	46 0c 30             	rex.RX or $0x30,%al
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    10d5:	21 24 bb             	and    %esp,(%rbx,%rdi,4)
    10d8:	00 00                	add    %al,(%rax)
    10da:	00 07                	add    %al,(%rdi)
    10dc:	47 0c 34             	rex.RXB or $0x34,%al
    10df:	00 0b                	add    %cl,(%rbx)
    10e1:	e5 10                	in     $0x10,%eax
  if (!connId) {
    10e3:	00 00                	add    %al,(%rax)
    10e5:	22 a7 0b ec 10 00    	and    0x10ec0b(%rdi),%ah
  __u8 connIdVersion = (connId[0] >> 6);
    10eb:	00 22                	add    %ah,(%rdx)
    10ed:	a9 06 ae 02 01       	test   $0x102ae06,%eax
    10f2:	0d b2 30 03 2b       	or     $0x2b0330b2,%eax
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10f7:	0a b0 18 03 00 00    	or     0x318(%rax),%dh
    10fd:	03 2c 00             	add    (%rax,%rax,1),%ebp
    1100:	0a b1 bb 00 00 00    	or     0xbb(%rcx),%dh
    1106:	03 2d 28 0a 24 12    	add    0x12240a28(%rip),%ebp        # 12241b34 <_license+0x1223f707>
    110c:	01 00                	add    %eax,(%rax)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    110e:	00 03                	add    %al,(%rbx)
    1110:	2e 2c 0a             	cs sub $0xa,%al
    1113:	91                   	xchg   %eax,%ecx
    1114:	12 01                	adc    (%rcx),%al
    1116:	00 00                	add    %al,(%rax)
    1118:	03 30                	add    (%rax),%esi
    111a:	2d 00 23 b2 00       	sub    $0xb22300,%eax
    111f:	00 00                	add    %al,(%rax)
    1121:	23 bb 00 00 00 0d    	and    0xd000000(%rbx),%edi
    1127:	cd 08                	int    $0x8
    1129:	0c 3a                	or     $0x3a,%al
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    112b:	0a ca                	or     %dl,%cl
    112d:	b2 00                	mov    $0x0,%dl
    112f:	00 00                	add    %al,(%rax)
    1131:	0c 3b                	or     $0x3b,%al
    1133:	00 0a                	add    %cl,(%rdx)
    1135:	cb                   	lret
    1136:	12 01                	adc    (%rcx),%al
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1138:	00 00                	add    %al,(%rax)
    113a:	0c 3c                	or     $0x3c,%al
    113c:	04 0a                	add    $0xa,%al
    113e:	cc                   	int3
    113f:	ee                   	out    %al,(%dx)
        quic_packets_stats->cid_initial += 1;
    1140:	10 00                	adc    %al,(%rax)
    1142:	00 0c 3d 05 00 1c d0 	add    %cl,-0x2fe3fffb(,%rdi,1)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1149:	0c c3                	or     $0xc3,%al
    114b:	01 b2 00 00 00 1d    	add    %esi,0x1d000000(%rdx)
    1151:	af                   	scas   %es:(%rdi),%eax
    1152:	0c c4                	or     $0xc4,%al
    1154:	01 b4 11 00 00 1d 96 	add    %esi,-0x69e30000(%rcx,%rdx,1)
    115b:	0c c5                	or     $0xc5,%al
    115d:	01 69 09             	add    %ebp,0x9(%rcx)
    1160:	00 00                	add    %al,(%rax)
    1162:	1d ac 0c c6 01       	sbb    $0x1c60cac,%eax
    1167:	fa                   	cli
    1168:	00 00                	add    %al,(%rax)
    116a:	00 1d b4 0c c7 01    	add    %bl,0x1c70cb4(%rip)        # 1c71e24 <_license+0x1c6f9f7>
    1170:	30 0a                	xor    %cl,(%rdx)
    1172:	00 00                	add    %al,(%rax)
    1174:	1d bb 0c c8 01       	sbb    $0x1c80cbb,%eax
    1179:	5d                   	pop    %rbp
    117a:	0a 00                	or     (%rax),%al
    117c:	00 1d a2 0c c9 01    	add    %bl,0x1c90ca2(%rip)        # 1c91e24 <_license+0x1c8f9f7>
  if (!per_vip_stats) {
    1182:	8b 09                	mov    (%rcx),%ecx
    1184:	00 00                	add    %al,(%rax)
    1186:	1d a3 0c ca 01       	sbb    $0x1ca0ca3,%eax
    118b:	8b 09                	mov    (%rcx),%ecx
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    118d:	00 00                	add    %al,(%rax)
    118f:	1d ad 0c cb 01       	sbb    $0x1cb0cad,%eax
    1194:	ee                   	out    %al,(%dx)
    1195:	10 00                	adc    %al,(%rax)
    1197:	00 1e                	add    %bl,(%rsi)
    1199:	d1 0c cd 01 55 0b 00 	rorl   0xb5501(,%rcx,8)
  if (!connId) {
    11a0:	00 1e                	add    %bl,(%rsi)
    11a2:	d2 0c ce             	rorb   %cl,(%rsi,%rcx,8)
    11a5:	01 67 0a             	add    %esp,0xa(%rdi)
  __u8 connIdVersion = (connId[0] >> 6);
    11a8:	00 00                	add    %al,(%rax)
    11aa:	1e                   	(bad)
    11ab:	be 0c cc 01 fa       	mov    $0xfa01cc0c,%esi
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    11b0:	00 00                	add    %al,(%rax)
    11b2:	00 00                	add    %al,(%rax)
    11b4:	0b f2                	or     %edx,%esi
    11b6:	10 00                	adc    %al,(%rax)
    11b8:	00 1c d3             	add    %bl,(%rbx,%rdx,8)
    11bb:	0e                   	(bad)
    11bc:	13 01                	adc    (%rcx),%eax
    11be:	b2 00                	mov    $0x0,%dl
    11c0:	00 00                	add    %al,(%rax)
    11c2:	1d a2 0e 14 01       	sbb    $0x1140ea2,%eax
    11c7:	8b 09                	mov    (%rcx),%ecx
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    11c9:	00 00                	add    %al,(%rax)
    11cb:	1d a3 0e 15 01       	sbb    $0x1150ea3,%eax
    11d0:	8b 09                	mov    (%rcx),%ecx
    11d2:	00 00                	add    %al,(%rax)
    11d4:	1d d4 0e 16 01       	sbb    $0x1160ed4,%eax
    11d9:	fa                   	cli
    11da:	00 00                	add    %al,(%rax)
    11dc:	00 1d af 0e 17 01    	add    %bl,0x1170eaf(%rip)        # 1172091 <_license+0x116fc64>
    11e2:	b4 11                	mov    $0x11,%ah
    11e4:	00 00                	add    %al,(%rax)
    dst_lru->atime = cur_time;
    11e6:	1e                   	(bad)
    11e7:	d5                   	(bad)
    11e8:	0e                   	(bad)
  key = dst_lru->pos;
    11e9:	18 01                	sbb    %al,(%rcx)
    11eb:	47 12 00             	rex.RXB adc (%r8),%r8b
    11ee:	00 1e                	add    %bl,(%rsi)
    11f0:	d1 0e                	rorl   (%rsi)
    11f2:	19 01                	sbb    %eax,(%rcx)
    11f4:	55                   	push   %rbp
  pckt->real_index = key;
    11f5:	0b 00                	or     (%rax),%eax
    11f7:	00 1f                	add    %bl,(%rdi)
  *real = bpf_map_lookup_elem(&reals, &key);
    11f9:	1e                   	(bad)
    11fa:	b7 0e                	mov    $0xe,%bh
    11fc:	26 01 bb 00 00 00 1e 	es add %edi,0x1e000000(%rbx)
    1203:	e1 0e                	loope  1213 <balancer_ingress+0x1213>
    1205:	27                   	(bad)
    1206:	01 81 05 00 00 1e    	add    %eax,0x1e000005(%rcx)
    120c:	de 0e                	fimuls (%rsi)
    120e:	2d 01 9c 02 00       	sub    $0x29c01,%eax
    1213:	00 1f                	add    %bl,(%rdi)
    1215:	1e                   	(bad)
    1216:	c0 0e 28             	rorb   $0x28,(%rsi)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1219:	01 8b 09 00 00 1e    	add    %ecx,0x1e000009(%rbx)
    121f:	07                   	(bad)
    1220:	0e                   	(bad)
    1221:	28 01                	sub    %al,(%rcx)
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1223:	1c 11                	sbb    $0x11,%al
    1225:	00 00                	add    %al,(%rax)
    1227:	1f                   	(bad)
    1228:	1e                   	(bad)
    1229:	c1 0e 28             	rorl   $0x28,(%rsi)
    122c:	01 bb 00 00 00 1e    	add    %edi,0x1e000000(%rbx)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1232:	14 0e                	adc    $0xe,%al
    1234:	28 01                	sub    %al,(%rcx)
    1236:	21 11                	and    %edx,(%rcx)
    1238:	00 00                	add    %al,(%rax)
    123a:	1e                   	(bad)
    123b:	c2 0e 28             	ret    $0x280e
    123e:	01 21                	add    %esp,(%rcx)
    1240:	11 00                	adc    %eax,(%rax)
    1242:	00 00                	add    %al,(%rax)
    1244:	00 00                	add    %al,(%rax)
    1246:	00 0b                	add    %cl,(%rbx)
  if (!conn_rate_stats) {
    1248:	4c 12 00             	rex.WR adc (%rax),%r8b
    124b:	00 0d e0 08 13 59    	add    %cl,0x591308e0(%rip)        # 59131b31 <_license+0x5912f704>
    1251:	0a 07                	or     (%rdi),%al
    1253:	12 01                	adc    (%rcx),%al
    1255:	00 00                	add    %al,(%rax)
  *cur_time = bpf_ktime_get_ns();
    1257:	13 5a 00             	adc    0x0(%rdx),%ebx
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    125a:	0a d6                	or     %dh,%dl
    125c:	12 01                	adc    (%rcx),%al
    125e:	00 00                	add    %al,(%rax)
    1260:	13 5b 01             	adc    0x1(%rbx),%ebx
    1263:	0a d7                	or     %bh,%dl
    1265:	03 0c 00             	add    (%rax,%rax,1),%ecx
    1268:	00 13                	add    %dl,(%rbx)
    conn_rate_stats->v1 = 1;
    126a:	5c                   	pop    %rsp
    126b:	02 0a                	add    (%rdx),%cl
    126d:	d8 75 12             	fdivs  0x12(%rbp)
    conn_rate_stats->v2 = *cur_time;
    1270:	00 00                	add    %al,(%rax)
    1272:	13 68 04             	adc    0x4(%rax),%ebp
    1275:	0f 04                	(bad)
    conn_rate_stats->v1 += 1;
    1277:	13 5d 0a             	adc    0xa(%rbp),%ebx
    127a:	d9 82 12 00 00 13    	flds   0x13000012(%rdx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1280:	61                   	(bad)
    1281:	00 09                	add    %cl,(%rcx)
    1283:	04 13                	add    $0x13,%al
    1285:	5e                   	pop    %rsi
    1286:	0a 93 06 0b 00 00    	or     0xb06(%rbx),%dl
    128c:	13 5f 00             	adc    0x0(%rdi),%ebx
    128f:	0a da                	or     %dl,%bl
    1291:	06                   	(bad)
    1292:	0b 00                	or     (%rax),%eax
    1294:	00 13                	add    %dl,(%rbx)
    1296:	60                   	(bad)
    1297:	02 00                	add    (%rax),%al
    1299:	0a db                	or     %bl,%bl
    129b:	b8 01 00 00 13       	mov    $0x13000001,%eax
    if (down_reals_map) {
    12a0:	62                   	(bad)
    12a1:	00 0a                	add    %cl,(%rdx)
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    12a3:	dc ab 12 00 00 13    	fsubrl 0x13000012(%rbx)
    12a9:	66 00 09             	data16 add %cl,(%rcx)
    12ac:	04 13                	add    $0x13,%al
    12ae:	63 0a                	movsxd (%rdx),%ecx
      if (down_real) {
    12b0:	dd 06                	fldl   (%rsi)
    12b2:	0b 00                	or     (%rax),%eax
    12b4:	00 13                	add    %dl,(%rbx)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    12b6:	64 00 0a             	add    %cl,%fs:(%rdx)
    12b9:	de 06                	fiadds (%rsi)
    12bb:	0b 00                	or     (%rax),%eax
    12bd:	00 13                	add    %dl,(%rbx)
    12bf:	65 02 00             	add    %gs:(%rax),%al
    12c2:	0a df                	or     %bh,%bl
    12c4:	cd 12                	int    $0x12
    12c6:	00 00                	add    %al,(%rax)
    12c8:	13 67 00             	adc    0x0(%rdi),%esp
    12cb:	00 00                	add    %al,(%rax)
    12cd:	04 12                	add    $0x12,%al
        if (stats_data) {
    12cf:	01 00                	add    %eax,(%rax)
    12d1:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 1337 <balancer_ingress+0x1337>
    12d7:	04 00                	add    $0x0,%al
          stats_data->v1 += 1;
    12d9:	1c e2                	sbb    $0xe2,%al
    12db:	0e                   	(bad)
    12dc:	53                   	push   %rbx
    12dd:	01 b2 00 00 00 1d    	add    %esi,0x1d000000(%rdx)
    if (!dst) {
    12e3:	a2 0e 54 01 8b 09 00 	movabs %al,0x1d0000098b01540e
    12ea:	00 1d 
    12ec:	a3 0e 55 01 8b 09 00 	movabs %eax,0x1d0000098b01550e
    12f3:	00 1d 
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    12f5:	d4                   	(bad)
    12f6:	0e                   	(bad)
    12f7:	56                   	push   %rsi
    12f8:	01 fa                	add    %edi,%edx
    12fa:	00 00                	add    %al,(%rax)
    12fc:	00 1d af 0e 57 01    	add    %bl,0x1570eaf(%rip)        # 15721b1 <_license+0x156fd84>
    1302:	b4 11                	mov    $0x11,%ah
    1304:	00 00                	add    %al,(%rax)
    1306:	1d 96 0e 58 01       	sbb    $0x1580e96,%eax
    130b:	12 01                	adc    (%rcx),%al
    130d:	00 00                	add    %al,(%rax)
    130f:	00 24 e3             	add    %ah,(%rbx,%riz,8)
    1312:	0e                   	(bad)
    1313:	3e b2 00             	ds mov $0x0,%dl
    1316:	00 00                	add    %al,(%rax)
    1318:	25 a2 0e 3f 8b       	and    $0x8b3f0ea2,%eax
  if (!data_stats) {
    131d:	09 00                	or     %eax,(%rax)
    131f:	00 25 a3 0e 40 8b    	add    %ah,-0x74bff15d(%rip)        # ffffffff8b4021c8 <server_id_map+0x36fc421661c8>
    1325:	09 00                	or     %eax,(%rax)
    1327:	00 26                	add    %ah,(%rsi)
    1329:	e4 0e                	in     $0xe,%al
    132b:	43 bb 00 00 00 26    	rex.XB mov $0x26000000,%r11d
  data_stats->v2 += pkt_bytes;
    1331:	e5 0e                	in     $0xe,%eax
    1333:	44 fa                	rex.R cli
    1335:	00 00                	add    %al,(%rax)
    1337:	00 26                	add    %ah,(%rsi)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1339:	d4                   	(bad)
    133a:	0e                   	(bad)
    133b:	45 fa                	rex.RB cli
    133d:	00 00                	add    %al,(%rax)
    133f:	00 26                	add    %ah,(%rsi)
    1341:	d5                   	(bad)
    1342:	0e                   	(bad)
    1343:	42                   	rex.X
    1344:	47 12 00             	rex.RXB adc (%r8),%r8b
    1347:	00 26                	add    %ah,(%rsi)
    1349:	d1 0e                	rorl   (%rsi)
    134b:	41 55                	push   %r13
    134d:	0b 00                	or     (%rax),%eax
    134f:	00 00                	add    %al,(%rax)
    1351:	27                   	(bad)
    1352:	e6 0f                	out    %al,$0xf
    1354:	32 25 d1 0f 33 8b    	xor    -0x74ccf02f(%rip),%ah        # ffffffff8b33232b <server_id_map+0x36fc4209632b>
    135a:	09 00                	or     %eax,(%rax)
    135c:	00 25 e5 0f 34 30    	add    %ah,0x30340fe5(%rip)        # 30342347 <_license+0x3033ff1a>
    1362:	0a 00                	or     (%rax),%al
  if (!data_stats) {
    1364:	00 26                	add    %ah,(%rsi)
    1366:	e7 0f                	out    %eax,$0xf
    1368:	35 5d 0a 00 00       	xor    $0xa5d,%eax
  data_stats->v1 += 1;
    136d:	1f                   	(bad)
    136e:	26 e8 0f 37 b2 00    	es call b24a83 <_license+0xb22656>
  data_stats->v2 += pkt_bytes;
    1374:	00 00                	add    %al,(%rax)
  pckt.flow.port16[0] = original_sport;
    1376:	00 00                	add    %al,(%rax)
    1378:	24 e9                	and    $0xe9,%al
    137a:	0e                   	(bad)
  if (dst->flags & F_IPV6) {
    137b:	e4 b2                	in     $0xb2,%al
    137d:	00 00                	add    %al,(%rax)
    137f:	00 25 a2 0e e5 8b    	add    %ah,-0x741af15e(%rip)        # ffffffff8be52227 <server_id_map+0x36fc42bb6227>
    1385:	09 00                	or     %eax,(%rax)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1387:	00 25 a3 0e e6 8b    	add    %ah,-0x7419f15d(%rip)        # ffffffff8be62230 <server_id_map+0x36fc42bc6230>
    138d:	09 00                	or     %eax,(%rax)
    138f:	00 25 d4 0e e7 fa    	add    %ah,-0x518f12c(%rip)        # fffffffffae72269 <server_id_map+0x36fcb1bd6269>
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1395:	00 00                	add    %al,(%rax)
    1397:	00 25 af 0e e8 b4    	add    %ah,-0x4b17f151(%rip)        # ffffffffb4e8224c <server_id_map+0x36fc6bbe624c>
    139d:	11 00                	adc    %eax,(%rax)
    139f:	00 26                	add    %ah,(%rsi)
    13a1:	d5                   	(bad)
    13a2:	0e                   	(bad)
    13a3:	e9 f8 13 00 00       	jmp    27a0 <_license+0x373>
  data = (void*)(long)xdp->data;
    13a8:	26 d2 0e             	es rorb %cl,(%rsi)
  data_end = (void*)(long)xdp->data_end;
    13ab:	ea                   	(bad)
    13ac:	67 0a 00             	or     (%eax),%al
  iph = data + sizeof(struct ethhdr);
    13af:	00 1f                	add    %bl,(%rdi)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    13b1:	26 b7 0e             	es mov $0xe,%bh
    13b4:	f8                   	clc
    13b5:	bb 00 00 00 28       	mov    $0x28000000,%ebx
    13ba:	02 01                	add    (%rcx),%al
    13bc:	0e                   	(bad)
    13bd:	f9                   	stc
    13be:	81 05 00 00 26 de 0e 	addl   $0xbbff0e,-0x21da0000(%rip)        # ffffffffde2613c8 <server_id_map+0x36fc94fc53c8>
    13c5:	ff bb 00 
    13c8:	00 00                	add    %al,(%rax)
    13ca:	1f                   	(bad)
    13cb:	26 c0 0e fa          	es rorb $0xfa,(%rsi)
    13cf:	8b 09                	mov    (%rcx),%ecx
    13d1:	00 00                	add    %al,(%rax)
    13d3:	26 07                	es (bad)
    13d5:	0e                   	(bad)
    13d6:	fa                   	cli
    13d7:	1c 11                	sbb    $0x11,%al
    13d9:	00 00                	add    %al,(%rax)
    13db:	1f                   	(bad)
    13dc:	26 c1 0e fa          	es rorl $0xfa,(%rsi)
    13e0:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    13e5:	14 0e                	adc    $0xe,%al
    13e7:	fa                   	cli
    13e8:	21 11                	and    %edx,(%rcx)
  memcpy(new_eth->h_dest, cval->mac, 6);
    13ea:	00 00                	add    %al,(%rax)
    13ec:	26 c2 0e fa          	es ret $0xfa0e
    13f0:	21 11                	and    %edx,(%rcx)
    13f2:	00 00                	add    %al,(%rax)
    13f4:	00 00                	add    %al,(%rax)
    13f6:	00 00                	add    %al,(%rax)
    13f8:	0b fd                	or     %ebp,%edi
    13fa:	13 00                	adc    (%rax),%eax
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    13fc:	00 29                	add    %ch,(%rcx)
    13fe:	01 01                	add    %eax,(%rcx)
    1400:	08 14 08             	or     %dl,(%rax,%rcx,1)
    1403:	0a ea                	or     %dl,%ch
    1405:	12 01                	adc    (%rcx),%al
    1407:	00 00                	add    %al,(%rax)
    1409:	14 0a                	adc    $0xa,%al
  new_eth->h_proto = BE_ETH_P_IP;
    140b:	00 0a                	add    %cl,(%rdx)
    140d:	eb 12                	jmp    1421 <balancer_ingress+0x1421>
    140f:	01 00                	add    %eax,(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1411:	00 14 0b             	add    %dl,(%rbx,%rcx,1)
    1414:	01 0a                	add    %ecx,(%rdx)
    1416:	ec                   	in     (%dx),%al
  iph->ihl = 5;
    1417:	03 0c 00             	add    (%rax,%rax,1),%ecx
    141a:	00 14 0c             	add    %dl,(%rsp,%rcx,1)
  iph->tos = tos;
    141d:	02 0a                	add    (%rdx),%cl
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    141f:	ed                   	in     (%dx),%eax
    1420:	27                   	(bad)
    1421:	14 00                	adc    $0x0,%al
    1423:	00 14 3f             	add    %dl,(%rdi,%rdi,1)
    1426:	04 0f                	add    $0xf,%al
    1428:	04 14                	add    $0x14,%al
  iph->id = 0;
    142a:	0f 0a                	(bad)
    142c:	ee                   	out    %al,(%dx)
    142d:	63 14 00             	movsxd (%rax,%rax,1),%edx
  iph->daddr = daddr;
    1430:	00 14 10             	add    %dl,(%rax,%rdx,1)
  iph->saddr = saddr;
    1433:	00 0a                	add    %cl,(%rdx)
    1435:	ef                   	out    %eax,(%dx)
  iph->ttl = DEFAULT_TTL;
    1436:	6f                   	outsl  %ds:(%rsi),(%dx)
    1437:	14 00                	adc    $0x0,%al
    1439:	00 14 11             	add    %dl,(%rcx,%rdx,1)
    143c:	00 0a                	add    %cl,(%rdx)
    143e:	f0 cd 12             	lock int $0x12
    1441:	00 00                	add    %al,(%rax)
    1443:	14 12                	adc    $0x12,%al
    1445:	00 0a                	add    %cl,(%rdx)
    1447:	f1                   	int1
    1448:	7b 14                	jnp    145e <balancer_ingress+0x145e>
    144a:	00 00                	add    %al,(%rax)
    144c:	14 17                	adc    $0x17,%al
    144e:	00 0a                	add    %cl,(%rdx)
    1450:	f4                   	hlt
    1451:	93                   	xchg   %eax,%ebx
    1452:	14 00                	adc    $0x0,%al
    1454:	00 14 28             	add    %dl,(%rax,%rbp,1)
    1457:	00 0a                	add    %cl,(%rdx)
      if (pckt.flow.proto == IPPROTO_TCP) {
    1459:	fa                   	cli
    145a:	d5                   	(bad)
    145b:	14 00                	adc    $0x0,%al
    145d:	00 14 3d 00 00 00 04 	add    %dl,0x4000000(,%rdi,1)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1464:	b8 01 00 00 05       	mov    $0x5000001,%eax
    1469:	60                   	(bad)
    146a:	00 00                	add    %al,(%rax)
    146c:	00 01                	add    %al,(%rcx)
    146e:	00 04 06             	add    %al,(%rsi,%rax,1)
    1471:	0b 00                	or     (%rax),%eax
    1473:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 14d9 <balancer_ingress+0x14d9>
    1479:	02 00                	add    (%rax),%al
        if (!lru_stats) {
    147b:	0d f3 04 14 14       	or     $0x141404f3,%eax
    1480:	0a f2                	or     %dl,%dh
    1482:	06                   	(bad)
        if (pckt.flags & F_SYN_SET) {
    1483:	0b 00                	or     (%rax),%eax
    1485:	00 14 15 00 0a da 06 	add    %dl,0x6da0a00(,%rdx,1)
    148c:	0b 00                	or     (%rax),%eax
    148e:	00 14 16             	add    %dl,(%rsi,%rdx,1)
    1491:	02 00                	add    (%rax),%al
    1493:	0d f9 04 14 19       	or     $0x191404f9,%eax
  struct real_pos_lru new_dst_lru = {};
    1498:	1b df                	sbb    %edi,%ebx
    149a:	bb 00 00 00 14       	mov    $0x14000000,%ebx
    149f:	1b 04 05 1b 00 1b f5 	sbb    -0xae4ffe5(,%rax,1),%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    14a6:	bb 00 00 00 14       	mov    $0x14000000,%ebx
    14ab:	1c 04                	sbb    $0x4,%al
    14ad:	01 1a                	add    %ebx,(%rdx)
    14af:	00 1b                	add    %bl,(%rbx)
    14b1:	f6 bb 00 00 00 14    	idivb  0x14000000(%rbx)
    14b7:	1d 04 01 19 00       	sbb    $0x190104,%eax
    14bc:	1b f7                	sbb    %edi,%esi
    14be:	bb 00 00 00 14       	mov    $0x14000000,%ebx
  if (!conn_rate_stats) {
    14c3:	1e                   	(bad)
    14c4:	04 01                	add    $0x1,%al
    14c6:	18 00                	sbb    %al,(%rax)
    14c8:	1b f8                	sbb    %eax,%edi
    14ca:	bb 00 00 00 14       	mov    $0x14000000,%ebx
  *cur_time = bpf_ktime_get_ns();
    14cf:	1f                   	(bad)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    14d0:	04 18                	add    $0x18,%al
    14d2:	00 00                	add    %al,(%rax)
    14d4:	00 29                	add    %ch,(%rcx)
    14d6:	00 01                	add    %al,(%rcx)
    14d8:	04 14                	add    $0x14,%al
    14da:	2a 0a                	sub    (%rdx),%cl
    14dc:	86 12                	xchg   %dl,(%rdx)
    14de:	01 00                	add    %eax,(%rax)
    conn_rate_stats->v1 = 1;
    14e0:	00 14 2b             	add    %dl,(%rbx,%rbp,1)
    14e3:	00 1b                	add    %bl,(%rbx)
    14e5:	df 12                	fists  (%rdx)
    14e7:	01 00                	add    %eax,(%rax)
    conn_rate_stats->v2 = *cur_time;
    14e9:	00 14 2d 01 03 05 01 	add    %dl,0x1050301(,%rbp,1)
    14f0:	1b fb                	sbb    %ebx,%edi
    conn_rate_stats->v1 += 1;
    14f2:	12 01                	adc    (%rcx),%al
    14f4:	00 00                	add    %al,(%rax)
    14f6:	14 2e                	adc    $0x2e,%al
    14f8:	01 02                	add    %eax,(%rdx)
    14fa:	03 01                	add    (%rcx),%eax
    14fc:	1b fc                	sbb    %esp,%edi
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    14fe:	12 01                	adc    (%rcx),%al
    1500:	00 00                	add    %al,(%rax)
    1502:	14 2f                	adc    $0x2f,%al
    1504:	01 01                	add    %eax,(%rcx)
    1506:	02 01                	add    (%rcx),%al
    1508:	1b fd                	sbb    %ebp,%edi
    150a:	12 01                	adc    (%rcx),%al
    150c:	00 00                	add    %al,(%rax)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    150e:	14 30                	adc    $0x30,%al
    1510:	01 01                	add    %eax,(%rcx)
    1512:	01 01                	add    %eax,(%rcx)
    1514:	1b fe                	sbb    %esi,%edi
    1516:	12 01                	adc    (%rcx),%al
    1518:	00 00                	add    %al,(%rax)
    151a:	14 31                	adc    $0x31,%al
    151c:	01 01                	add    %eax,(%rcx)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    151e:	00 01                	add    %al,(%rcx)
    1520:	0a ff                	or     %bh,%bh
    1522:	06                   	(bad)
    1523:	0b 00                	or     (%rax),%eax
    1525:	00 14 3c             	add    %dl,(%rsp,%rdi,1)
      memset(pckt->flow.srcv6, 0, 16);
    1528:	02 00                	add    (%rax),%al
    152a:	2a 03                	sub    (%rbx),%al
    152c:	01 0c 75 ee 10 00 00 	add    %ecx,0x10ee(,%rsi,2)
    1533:	25 a2 0c 76 8b       	and    $0x8b760ca2,%eax
    1538:	09 00                	or     %eax,(%rax)
    153a:	00 25 a3 0c 77 8b    	add    %ah,-0x7488f35d(%rip)        # ffffffff8b7721e3 <server_id_map+0x36fc424d61e3>
    1540:	09 00                	or     %eax,(%rax)
    1542:	00 25 ad 0c 78 ee    	add    %ah,-0x1187f353(%rip)        # ffffffffee7821f5 <server_id_map+0x36fca54e61f5>
    1548:	10 00                	adc    %al,(%rax)
    154a:	00 25 af 0c 79 b4    	add    %ah,-0x4b86f351(%rip)        # ffffffffb47921ff <server_id_map+0x36fc6b4f61ff>
  return (word << shift) | (word >> ((-shift) & 31));
    1550:	11 00                	adc    %eax,(%rax)
    1552:	00 26                	add    %ah,(%rsi)
    1554:	c6                   	(bad)
  __jhash_final(a, b, c);
    1555:	0c 7a                	or     $0x7a,%al
    1557:	ee                   	out    %al,(%dx)
    1558:	10 00                	adc    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    155a:	00 28                	add    %ch,(%rax)
    155c:	04 01                	add    $0x1,%al
  __jhash_final(a, b, c);
    155e:	0c 7c                	or     $0x7c,%al
    1560:	6d                   	insl   (%dx),%es:(%rdi)
    1561:	15 00 00 26 d4       	adc    $0xd4260000,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1566:	0c 7b                	or     $0x7b,%al
  __jhash_final(a, b, c);
    1568:	fa                   	cli
    1569:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    156b:	00 00                	add    %al,(%rax)
    156d:	0b 72 15             	or     0x15(%rdx),%esi
  __jhash_final(a, b, c);
    1570:	00 00                	add    %al,(%rax)
    1572:	29 16                	sub    %edx,(%rsi)
  return (word << shift) | (word >> ((-shift) & 31));
    1574:	01 14 15 19 2b 05 01 	add    %edx,0x1052b19(,%rdx,1)
  __jhash_final(a, b, c);
    157b:	06                   	(bad)
    157c:	0b 00                	or     (%rax),%eax
  return (word << shift) | (word >> ((-shift) & 31));
    157e:	00 15 1a 00 2b 06    	add    %dl,0x62b001a(%rip)        # 62b159e <_license+0x62af171>
    1584:	01 06                	add    %eax,(%rsi)
    1586:	0b 00                	or     (%rax),%eax
  __jhash_final(a, b, c);
    1588:	00 15 1b 02 2b 07    	add    %dl,0x72b021b(%rip)        # 72b17a9 <_license+0x72af37c>
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    158e:	01 b8 01 00 00 15    	add    %edi,0x15000001(%rax)
    1594:	1c 04                	sbb    $0x4,%al
    1596:	2b 08                	sub    (%rax),%ecx
    1598:	01 b8 01 00 00 15    	add    %edi,0x15000001(%rax)
    159e:	1d 08 2c 09 01       	sbb    $0x1092c08,%eax
    15a3:	9c                   	pushf
    key = RING_SIZE * (vip_info->vip_num) + hash;
    15a4:	02 00                	add    (%rax),%al
    15a6:	00 15 1f 02 01 0f    	add    %dl,0xf01021f(%rip)        # f0117cb <_license+0xf00f39e>
    15ac:	0c 2c                	or     $0x2c,%al
    15ae:	0a 01                	or     (%rcx),%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15b0:	9c                   	pushf
    15b1:	02 00                	add    (%rax),%al
    15b3:	00 15 20 02 03 0c    	add    %dl,0xc030220(%rip)        # c0317d9 <_license+0xc02f3ac>
    if (!real_pos) {
    15b9:	0c 2c                	or     $0x2c,%al
    15bb:	0b 01                	or     (%rcx),%eax
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15bd:	9c                   	pushf
    15be:	02 00                	add    (%rax),%al
    15c0:	00 15 21 02 04 08    	add    %dl,0x8040221(%rip)        # 80417e7 <_license+0x803f3ba>
    15c6:	0c 2c                	or     $0x2c,%al
    key = *real_pos;
    15c8:	0c 01                	or     $0x1,%al
    15ca:	9c                   	pushf
    15cb:	02 00                	add    (%rax),%al
    15cd:	00 15 22 02 01 07    	add    %dl,0x7010222(%rip)        # 70117f5 <_license+0x700f3c8>
    if (key == 0) {
    15d3:	0c 2c                	or     $0x2c,%al
  pckt->real_index = key;
    15d5:	0d 01 9c 02 00       	or     $0x29c01,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
    15da:	00 15 23 02 01 06    	add    %dl,0x6010223(%rip)        # 6011803 <_license+0x600f3d6>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    15e0:	0c 2c                	or     $0x2c,%al
    15e2:	0e                   	(bad)
    15e3:	01 9c 02 00 00 15 24 	add    %ebx,0x24150000(%rdx,%rax,1)
    15ea:	02 01                	add    (%rcx),%al
    15ec:	05 0c 2c 0f 01       	add    $0x10f2c0c,%eax
    15f1:	9c                   	pushf
    15f2:	02 00                	add    (%rax),%al
    15f4:	00 15 25 02 01 04    	add    %dl,0x4010225(%rip)        # 401181f <_license+0x400f3f2>
  if (!ch_drop_stats) {
    15fa:	0c 2c                	or     $0x2c,%al
    15fc:	10 01                	adc    %al,(%rcx)
    15fe:	9c                   	pushf
    15ff:	02 00                	add    (%rax),%al
    1601:	00 15 26 02 01 03    	add    %dl,0x3010226(%rip)        # 301182d <_license+0x300f400>
    1607:	0c 2c                	or     $0x2c,%al
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1609:	11 01                	adc    %eax,(%rcx)
    160b:	9c                   	pushf
    160c:	02 00                	add    (%rax),%al
    160e:	00 15 27 02 01 02    	add    %dl,0x2010227(%rip)        # 201183b <_license+0x200f40e>
    1614:	0c 2c                	or     $0x2c,%al
    1616:	12 01                	adc    (%rcx),%al
    1618:	9c                   	pushf
    1619:	02 00                	add    (%rax),%al
    161b:	00 15 28 02 01 01    	add    %dl,0x1010228(%rip)        # 1011849 <_license+0x100f41c>
    1621:	0c 2c                	or     $0x2c,%al
  if (!ch_drop_stats) {
    1623:	13 01                	adc    (%rcx),%eax
    1625:	9c                   	pushf
    1626:	02 00                	add    (%rax),%al
    1628:	00 15 29 02 01 00    	add    %dl,0x10229(%rip)        # 11857 <_license+0xf42a>
    162e:	0c 2b                	or     $0x2b,%al
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1630:	14 01                	adc    $0x1,%al
    1632:	06                   	(bad)
    1633:	0b 00                	or     (%rax),%eax
    1635:	00 15 39 0e 0a 97    	add    %dl,-0x68f5f1c7(%rip)        # ffffffff970a2474 <server_id_map+0x36fc4de06474>
    163b:	03 0c 00             	add    (%rax,%rax,1),%ecx
    163e:	00 15 3a 10 2b 15    	add    %dl,0x152b103a(%rip)        # 152b267e <_license+0x152b0251>
    1644:	01 06                	add    %eax,(%rsi)
    1646:	0b 00                	or     (%rax),%eax
    1648:	00 15 3b 12 00 2a    	add    %dl,0x2a00123b(%rip)        # 2a002889 <_license+0x2a00045c>
    164e:	17                   	(bad)
    164f:	01 0c 49             	add    %ecx,(%rcx,%rcx,2)
    1652:	fa                   	cli
    1653:	00 00                	add    %al,(%rax)
    1655:	00 25 ad 0c 4a ee    	add    %ah,-0x11b5f353(%rip)        # ffffffffee4a2308 <server_id_map+0x36fca5206308>
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    165b:	10 00                	adc    %al,(%rax)
    165d:	00 25 c6 0c 4b ee    	add    %ah,-0x11b4f33a(%rip)        # ffffffffee4b2329 <server_id_map+0x36fca5216329>
    1663:	10 00                	adc    %al,(%rax)
    1665:	00 26                	add    %ah,(%rsi)
    1667:	d4                   	(bad)
    1668:	0c 4c                	or     $0x4c,%al
    166a:	fa                   	cli
    166b:	00 00                	add    %al,(%rax)
  data = (void*)(long)xdp->data;
    166d:	00 00                	add    %al,(%rax)
    166f:	2a 18                	sub    (%rax),%bl
  data_end = (void*)(long)xdp->data_end;
    1671:	01 0e                	add    %ecx,(%rsi)
    1673:	5e                   	pop    %rsi
  ip6h = data + sizeof(struct ethhdr);
    1674:	b2 00                	mov    $0x0,%dl
    1676:	00 00                	add    %al,(%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1678:	25 a2 0e 5f 8b       	and    $0x8b5f0ea2,%eax
    167d:	09 00                	or     %eax,(%rax)
    167f:	00 25 a3 0e 60 8b    	add    %ah,-0x749ff15d(%rip)        # ffffffff8b602528 <server_id_map+0x36fc42366528>
    1685:	09 00                	or     %eax,(%rax)
    1687:	00 26                	add    %ah,(%rsi)
    1689:	e4 0e                	in     $0xe,%al
    168b:	63 c0                	movsxd %eax,%eax
    168d:	01 00                	add    %eax,(%rax)
    168f:	00 26                	add    %ah,(%rsi)
    1691:	d4                   	(bad)
    1692:	0e                   	(bad)
    1693:	64 fa                	fs cli
    1695:	00 00                	add    %al,(%rax)
    1697:	00 26                	add    %ah,(%rsi)
    1699:	d2 0e                	rorb   %cl,(%rsi)
    169b:	61                   	(bad)
    169c:	67 0a 00             	or     (%eax),%al
    169f:	00 26                	add    %ah,(%rsi)
    16a1:	d5                   	(bad)
  memcpy(new_eth->h_dest, cval->mac, 6);
    16a2:	0e                   	(bad)
    16a3:	62                   	(bad)
    16a4:	f8                   	clc
    16a5:	13 00                	adc    (%rax),%eax
    16a7:	00 00                	add    %al,(%rax)
    16a9:	2a 19                	sub    (%rcx),%bl
    16ab:	01 00                	add    %eax,(%rax)
    16ad:	cb                   	lret
    16ae:	b2 00                	mov    $0x0,%dl
    16b0:	00 00                	add    %al,(%rax)
    16b2:	25 af 00 cb b4       	and    $0xb4cb00af,%eax
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    16b7:	11 00                	adc    %eax,(%rax)
    16b9:	00 25 ad 00 cb ee    	add    %ah,-0x1134ff53(%rip)        # ffffffffeecb176c <server_id_map+0x36fca5a1576c>
    16bf:	10 00                	adc    %al,(%rax)
    16c1:	00 25 bf 00 cb 2d    	add    %ah,0x2dcb00bf(%rip)        # 2dcb1786 <_license+0x2dcaf359>
  new_eth->h_proto = BE_ETH_P_IPV6;
    16c7:	17                   	(bad)
    16c8:	00 00                	add    %al,(%rax)
    16ca:	28 1a                	sub    %bl,(%rdx)
    16cc:	01 00                	add    %eax,(%rax)
  saddr[3] = src ^ port;
    16ce:	cc                   	int3
    16cf:	93                   	xchg   %eax,%ebx
    16d0:	01 00                	add    %eax,(%rax)
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    16d2:	00 28                	add    %ch,(%rax)
    16d4:	1b 01                	sbb    (%rcx),%eax
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    16d6:	00 d5                	add    %dl,%ch
    16d8:	b6 00                	mov    $0x0,%dh
    16da:	00 00                	add    %al,(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    16dc:	26 b8 00 cd 81 05    	es mov $0x581cd00,%eax
    16e2:	00 00                	add    %al,(%rax)
    16e4:	1f                   	(bad)
    16e5:	26 c0 00 d5          	es rolb $0xd5,(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    16e9:	8b 09                	mov    (%rcx),%ecx
    16eb:	00 00                	add    %al,(%rax)
  ip6h->nexthdr = proto;
    16ed:	26 07                	es (bad)
    16ef:	00 d5                	add    %dl,%ch
    16f1:	1c 11                	sbb    $0x11,%al
  ip6h->payload_len = bpf_htons(payload_len);
    16f3:	00 00                	add    %al,(%rax)
    16f5:	00 1f                	add    %bl,(%rdi)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    16f7:	26 b7 00             	es mov $0x0,%bh
    16fa:	d9 bb 00 00 00 1f    	fnstcw 0x1f000000(%rbx)
    1700:	26 c0 00 da          	es rolb $0xda,(%rax)
    1704:	8b 09                	mov    (%rcx),%ecx
    1706:	00 00                	add    %al,(%rax)
    1708:	26 07                	es (bad)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    170a:	00 da                	add    %bl,%dl
    170c:	1c 11                	sbb    $0x11,%al
    170e:	00 00                	add    %al,(%rax)
    1710:	1f                   	(bad)
    1711:	26 c1 00 da          	es roll $0xda,(%rax)
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1715:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    171a:	14 00                	adc    $0x0,%al
    171c:	da 21                	fisubl (%rcx)
    171e:	11 00                	adc    %eax,(%rax)
    1720:	00 26                	add    %ah,(%rsi)
    1722:	c2 00 da             	ret    $0xda00
    1725:	21 11                	and    %edx,(%rcx)
    1727:	00 00                	add    %al,(%rax)
    1729:	00 00                	add    %al,(%rax)
    172b:	00 00                	add    %al,(%rax)
    172d:	0b ee                	or     %esi,%ebp
    172f:	10 00                	adc    %al,(%rax)
    1731:	00 2d 1c 01 06 9a    	add    %ch,-0x65f9fee4(%rip)        # ffffffff9a061853 <server_id_map+0x36fc50dc5853>
    1737:	01 8b 09 00 00 2e    	add    %ecx,0x2e000009(%rbx)
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    173d:	1d 01 06 9a 01       	sbb    $0x19a0601,%eax
    1742:	8b 09                	mov    (%rcx),%ecx
    1744:	00 00                	add    %al,(%rax)
    1746:	1d 09 06 9a 01       	sbb    $0x19a0609,%eax
    174b:	8b 09                	mov    (%rcx),%ecx
    174d:	00 00                	add    %al,(%rax)
    174f:	00 2a                	add    %ch,(%rdx)
    1751:	1e                   	(bad)
    1752:	01 10                	add    %edx,(%rax)
    1754:	55                   	push   %rbp
    1755:	b2 00                	mov    $0x0,%dl
    1757:	00 00                	add    %al,(%rax)
      if (qpr.server_id > 0) {
    1759:	25 a2 10 55 8b       	and    $0x8b5510a2,%eax
    175e:	09 00                	or     %eax,(%rax)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1760:	00 25 a3 10 55 8b    	add    %ah,-0x74aaef5d(%rip)        # ffffffff8b552809 <server_id_map+0x36fc422b6809>
    1766:	09 00                	or     %eax,(%rax)
    1768:	00 2f                	add    %ch,(%rdi)
    176a:	1f                   	(bad)
    176b:	01 10                	add    %edx,(%rax)
    176d:	55                   	push   %rbp
    176e:	b2 00                	mov    $0x0,%dl
    1770:	00 00                	add    %al,(%rax)
    1772:	25 ad 10 55 ee       	and    $0xee5510ad,%eax
    1777:	10 00                	adc    %al,(%rax)
    1779:	00 26                	add    %ah,(%rsi)
    177b:	d2 10                	rclb   %cl,(%rax)
    177d:	57                   	push   %rdi
    177e:	67 0a 00             	or     (%eax),%al
    1781:	00 26                	add    %ah,(%rsi)
    1783:	d1 10                	rcll   (%rax)
    if (pckt->flow.proto == IPPROTO_UDP) {
    1785:	56                   	push   %rsi
    1786:	55                   	push   %rbp
    1787:	0b 00                	or     (%rax),%eax
    1789:	00 1f                	add    %bl,(%rdi)
    178b:	26 e5 10             	es in  $0x10,%eax
      new_dst_lru.atime = cur_time;
    178e:	67 bb 00 00 00 00    	addr32 mov $0x0,%ebx
    new_dst_lru.pos = key;
    1794:	00 2d 20 01 00 2d    	add    %ch,0x2d000120(%rip)        # 2d0018ba <_license+0x2cfff48d>
BPF_MAP_OPS_INLINE(int,
    179a:	01 b2 00 00 00 1d    	add    %esi,0x1d000000(%rdx)
    17a0:	a2 00 2e 01 97 18 00 	movabs %al,0x1d00001897012e00
    17a7:	00 1d 
    17a9:	a3 00 2f 01 97 18 00 	movabs %eax,0x1d00001897012f00
    17b0:	00 1d 
    17b2:	a1 00 30 01 84 10 00 	movabs 0x1d00001084013000,%eax
    17b9:	00 1d 
    17bb:	ad                   	lods   %ds:(%rsi),%eax
    17bc:	00 31                	add    %dh,(%rcx)
    17be:	01 2d 17 00 00 1d    	add    %ebp,0x1d000017(%rip)        # 1d0017db <_license+0x1cfff3ae>
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17c4:	96                   	xchg   %eax,%esi
    17c5:	00 32                	add    %dh,(%rdx)
    17c7:	01 69 09             	add    %ebp,0x9(%rcx)
    17ca:	00 00                	add    %al,(%rax)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17cc:	1d bf 00 33 01       	sbb    $0x13300bf,%eax
    17d1:	ee                   	out    %al,(%dx)
    17d2:	10 00                	adc    %al,(%rax)
    17d4:	00 1e                	add    %bl,(%rsi)
    17d6:	b5 00                	mov    $0x0,%ch
    17d8:	34 01                	xor    $0x1,%al
  bool vip_match = address_match && port_match && proto_match;
    17da:	b2 00                	mov    $0x0,%dl
    17dc:	00 00                	add    %al,(%rax)
    17de:	1e                   	(bad)
    17df:	b7 00                	mov    $0x0,%bh
    17e1:	55                   	push   %rbp
    17e2:	01 bb 00 00 00 1e    	add    %edi,0x1e000000(%rbx)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17e8:	b8 00 56 01 81       	mov    $0x81015600,%eax
    17ed:	05 00 00 1f 30       	add    $0x301f0000,%eax
    17f2:	1f                   	(bad)
    17f3:	01 00                	add    %eax,(%rax)
    17f5:	4b 01 b2 00 00 00 00 	rex.WXB add %rsi,0x0(%r10)
    17fc:	1f                   	(bad)
    17fd:	30 1f                	xor    %bl,(%rdi)
    17ff:	01 00                	add    %eax,(%rax)
    1801:	37                   	(bad)
    1802:	01 b2 00 00 00 00    	add    %esi,0x0(%rdx)
    1808:	1f                   	(bad)
    1809:	30 1f                	xor    %bl,(%rdi)
    180b:	01 00                	add    %eax,(%rax)
    if (!lru_miss_stat) {
    180d:	41 01 b2 00 00 00 00 	add    %esi,0x0(%r10)
    1814:	1f                   	(bad)
    1815:	1e                   	(bad)
    *lru_miss_stat += 1;
    1816:	c0 00 56             	rolb   $0x56,(%rax)
    1819:	01 8b 09 00 00 1e    	add    %ecx,0x1e000009(%rbx)
    181f:	07                   	(bad)
    1820:	00 56 01             	add    %dl,0x1(%rsi)
    1823:	1c 11                	sbb    $0x11,%al
    1825:	00 00                	add    %al,(%rax)
    1827:	1f                   	(bad)
    1828:	1e                   	(bad)
    1829:	c1 00 56             	roll   $0x56,(%rax)
    182c:	01 bb 00 00 00 1e    	add    %edi,0x1e000000(%rbx)
    1832:	14 00                	adc    $0x0,%al
    1834:	56                   	push   %rsi
    1835:	01 21                	add    %esp,(%rcx)
    1837:	11 00                	adc    %eax,(%rax)
      data_stats->v2 += 1;
    1839:	00 1e                	add    %bl,(%rsi)
    183b:	c2 00 56             	ret    $0x5600
    183e:	01 21                	add    %esp,(%rcx)
    1840:	11 00                	adc    %eax,(%rax)
    1842:	00 00                	add    %al,(%rax)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1844:	00 1f                	add    %bl,(%rdi)
    1846:	30 21                	xor    %ah,(%rcx)
    1848:	01 00                	add    %eax,(%rax)
    184a:	68 01 bb 00 00       	push   $0xbb01
    184f:	00 30                	add    %dh,(%rax)
    1851:	22 01                	and    (%rcx),%al
    1853:	00 69 01             	add    %ch,0x1(%rcx)
  if (!connId) {
    1856:	81 05 00 00 30 23 01 	addl   $0x1670001,0x23300000(%rip)        # 23301860 <_license+0x232ff433>
    185d:	00 67 01 
    1860:	ee                   	out    %al,(%dx)
    1861:	10 00                	adc    %al,(%rax)
    1863:	00 1f                	add    %bl,(%rdi)
    1865:	1e                   	(bad)
    1866:	c0 00 6a             	rolb   $0x6a,(%rax)
    1869:	01 8b 09 00 00 1e    	add    %ecx,0x1e000009(%rbx)
    186f:	07                   	(bad)
    1870:	00 6a 01             	add    %ch,0x1(%rdx)
    1873:	1c 11                	sbb    $0x11,%al
    1875:	00 00                	add    %al,(%rax)
    1877:	1f                   	(bad)
    1878:	1e                   	(bad)
    1879:	c1 00 6a             	roll   $0x6a,(%rax)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    187c:	01 bb 00 00 00 1e    	add    %edi,0x1e000000(%rbx)
    1882:	14 00                	adc    $0x0,%al
    1884:	6a 01                	push   $0x1
    1886:	21 11                	and    %edx,(%rcx)
    1888:	00 00                	add    %al,(%rax)
    188a:	1e                   	(bad)
    188b:	c2 00 6a             	ret    $0x6a00
          key = *real_pos;
    188e:	01 21                	add    %esp,(%rcx)
    1890:	11 00                	adc    %eax,(%rax)
    1892:	00 00                	add    %al,(%rax)
    1894:	00 00                	add    %al,(%rax)
          if (key == 0) {
    1896:	00 0b                	add    %cl,(%rbx)
            pckt.real_index = key;
    1898:	8b 09                	mov    (%rcx),%ecx
    189a:	00 00                	add    %al,(%rax)
    189c:	2a 24 01             	sub    (%rcx,%rax,1),%ah
            dst = bpf_map_lookup_elem(&reals, &key);
    189f:	11 7d ee             	adc    %edi,-0x12(%rbp)
    18a2:	10 00                	adc    %al,(%rax)
    18a4:	00 25 a1 11 7d 84    	add    %ah,-0x7b82ee5f(%rip)        # ffffffff847d2a4b <server_id_map+0x36fc3b536a4b>
    18aa:	10 00                	adc    %al,(%rax)
    18ac:	00 25 a2 11 7d 97    	add    %ah,-0x6882ee5e(%rip)        # ffffffff977d2a54 <server_id_map+0x36fc4e536a54>
    18b2:	18 00                	sbb    %al,(%rax)
    18b4:	00 25 a3 11 7d 97    	add    %ah,-0x6882ee5d(%rip)        # ffffffff977d2a5d <server_id_map+0x36fc4e536a5d>
    18ba:	18 00                	sbb    %al,(%rax)
    18bc:	00 2f                	add    %ch,(%rdi)
            if (!dst) {
    18be:	25 01 11 7d ee       	and    $0xee7d1101,%eax
    18c3:	10 00                	adc    %al,(%rax)
    18c5:	00 28                	add    %ch,(%rax)
    18c7:	26 01 11             	es add %edx,(%rcx)
    18ca:	7f d9                	jg     18a5 <balancer_ingress+0x18a5>
    18cc:	18 00                	sbb    %al,(%rax)
    18ce:	00 28                	add    %ch,(%rax)
BPF_MAP_OPS_INLINE(void*,
    18d0:	2b 01                	sub    (%rcx),%eax
    18d2:	11 7e d9             	adc    %edi,-0x27(%rsi)
    18d5:	18 00                	sbb    %al,(%rax)
    18d7:	00 00                	add    %al,(%rax)
    18d9:	0b de                	or     %esi,%ebx
  if (dst_lru) {
    18db:	18 00                	sbb    %al,(%rax)
    18dd:	00 29                	add    %ch,(%rcx)
    18df:	2a 01                	sub    (%rcx),%al
    18e1:	0e                   	(bad)
    18e2:	16                   	(bad)
    if (dst_lru->pos == pckt->real_index) {
    18e3:	ad                   	lods   %ds:(%rsi),%eax
    18e4:	2b 27                	sub    (%rdi),%esp
    18e6:	01 03                	add    %eax,(%rbx)
    18e8:	19 00                	sbb    %eax,(%rax)
    18ea:	00 16                	add    %dl,(%rsi)
    18ec:	ae                   	scas   %es:(%rdi),%al
    18ed:	00 2b                	add    %ch,(%rbx)
              quic_packets_stats->dst_match_in_lru += 1;
    18ef:	28 01                	sub    %al,(%rcx)
    18f1:	03 19                	add    (%rcx),%ebx
    18f3:	00 00                	add    %al,(%rax)
    18f5:	16                   	(bad)
    18f6:	af                   	scas   %es:(%rdi),%eax
    18f7:	06                   	(bad)
    18f8:	2b 29                	sub    (%rcx),%ebp
    18fa:	01 06                	add    %eax,(%rsi)
    18fc:	0b 00                	or     (%rax),%eax
    18fe:	00 16                	add    %dl,(%rsi)
    1900:	b0 0c                	mov    $0xc,%al
    1902:	00 04 1a             	add    %al,(%rdx,%rbx,1)
    1905:	01 00                	add    %eax,(%rax)
    1907:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 196d <balancer_ingress+0x196d>
    190d:	06                   	(bad)
    190e:	00 2a                	add    %ch,(%rdx)
    1910:	2c 01                	sub    $0x1,%al
    1912:	0c 5b                	or     $0x5b,%al
    1914:	ee                   	out    %al,(%dx)
    1915:	10 00                	adc    %al,(%rax)
    1917:	00 25 a2 0c 5c 8b    	add    %ah,-0x74a3f35e(%rip)        # ffffffff8b5c25bf <server_id_map+0x36fc423265bf>
  original_sport = pckt.flow.port16[0];
    191d:	09 00                	or     %eax,(%rax)
    191f:	00 25 a3 0c 5d 8b    	add    %ah,-0x74a2f35d(%rip)        # ffffffff8b5d25c8 <server_id_map+0x36fc423365c8>
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1925:	09 00                	or     %eax,(%rax)
    1927:	00 25 ad 0c 5e ee    	add    %ah,-0x11a1f353(%rip)        # ffffffffee5e25da <server_id_map+0x36fca53465da>
        !(vip_info->flags & F_LRU_BYPASS)) {
    192d:	10 00                	adc    %al,(%rax)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    192f:	00 25 af 0c 5f b4    	add    %ah,-0x4ba0f351(%rip)        # ffffffffb45f25e4 <server_id_map+0x36fc6b3565e4>
    1935:	11 00                	adc    %eax,(%rax)
    1937:	00 26                	add    %ah,(%rsi)
    1939:	c6                   	(bad)
    193a:	0c 60                	or     $0x60,%al
    193c:	ee                   	out    %al,(%dx)
    193d:	10 00                	adc    %al,(%rax)
    193f:	00 28                	add    %ch,(%rax)
    1941:	2d 01 0c 62 52       	sub    $0x52620c01,%eax
    1946:	19 00                	sbb    %eax,(%rax)
    1948:	00 26                	add    %ah,(%rsi)
    194a:	d4                   	(bad)
  if (!dst_lru) {
    194b:	0c 61                	or     $0x61,%al
    194d:	fa                   	cli
    194e:	00 00                	add    %al,(%rax)
    1950:	00 00                	add    %al,(%rax)
    1952:	0b 57 19             	or     0x19(%rdi),%edx
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1955:	00 00                	add    %al,(%rax)
    1957:	29 2f                	sub    %ebp,(%rdi)
    1959:	01 08                	add    %ecx,(%rax)
    195b:	17                   	(bad)
    195c:	17                   	(bad)
    195d:	2b 05 01 06 0b 00    	sub    0xb0601(%rip),%eax        # b1f64 <_license+0xafb37>
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1963:	00 17                	add    %dl,(%rdi)
    1965:	18 00                	sbb    %al,(%rax)
    1967:	2b 06                	sub    (%rsi),%eax
    1969:	01 06                	add    %eax,(%rsi)
    196b:	0b 00                	or     (%rax),%eax
    196d:	00 17                	add    %dl,(%rdi)
    196f:	19 02                	sbb    %eax,(%rdx)
    1971:	2b 2e                	sub    (%rsi),%ebp
    1973:	01 06                	add    %eax,(%rsi)
    1975:	0b 00                	or     (%rax),%eax
    1977:	00 17                	add    %dl,(%rdi)
    1979:	1a 04 0a             	sbb    (%rdx,%rcx,1),%al
    197c:	97                   	xchg   %eax,%edi
    197d:	03 0c 00             	add    (%rax,%rax,1),%ecx
    1980:	00 17                	add    %dl,(%rdi)
    dst_lru->atime = cur_time;
    1982:	1b 06                	sbb    (%rsi),%eax
    1984:	00 2a                	add    %ch,(%rdx)
  key = dst_lru->pos;
    1986:	30 01                	xor    %al,(%rcx)
    1988:	11 92 ee 10 00 00    	adc    %edx,0x10ee(%rdx)
    198e:	25 a1 11 92 84       	and    $0x849211a1,%eax
  pckt->real_index = key;
    1993:	10 00                	adc    %al,(%rax)
  *real = bpf_map_lookup_elem(&reals, &key);
    1995:	00 25 a2 11 92 97    	add    %ah,-0x686dee5e(%rip)        # ffffffff97922b3d <server_id_map+0x36fc4e686b3d>
    199b:	18 00                	sbb    %al,(%rax)
    199d:	00 25 a3 11 92 97    	add    %ah,-0x686dee5d(%rip)        # ffffffff97922b46 <server_id_map+0x36fc4e686b46>
    19a3:	18 00                	sbb    %al,(%rax)
    19a5:	00 28                	add    %ch,(%rax)
    19a7:	26 01 11             	es add %edx,(%rcx)
    19aa:	94                   	xchg   %eax,%esp
    19ab:	d9 18                	fstps  (%rax)
    19ad:	00 00                	add    %al,(%rax)
    19af:	28 2b                	sub    %ch,(%rbx)
    19b1:	01 11                	add    %edx,(%rcx)
    19b3:	93                   	xchg   %eax,%ebx
    19b4:	d9 18                	fstps  (%rax)
    19b6:	00 00                	add    %al,(%rax)
    19b8:	00 2d 31 01 0c 53    	add    %ch,0x530c0131(%rip)        # 530c1aef <_license+0x530bf6c2>
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    19be:	01 26                	add    %esp,(%rsi)
    19c0:	11 00                	adc    %eax,(%rax)
    19c2:	00 1d a2 0c 54 01    	add    %bl,0x1540ca2(%rip)        # 154266a <_license+0x154023d>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    19c8:	8b 09                	mov    (%rcx),%ecx
    19ca:	00 00                	add    %al,(%rax)
    19cc:	1d a3 0c 55 01       	sbb    $0x1550ca3,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    19d1:	8b 09                	mov    (%rcx),%ecx
    19d3:	00 00                	add    %al,(%rax)
    19d5:	1d ad 0c 56 01       	sbb    $0x1560cad,%eax
    19da:	ee                   	out    %al,(%dx)
    19db:	10 00                	adc    %al,(%rax)
    19dd:	00 1d af 0c 57 01    	add    %bl,0x1570caf(%rip)        # 1572692 <_license+0x1570265>
  if (!conn_rate_stats) {
    19e3:	b4 11                	mov    $0x11,%ah
    19e5:	00 00                	add    %al,(%rax)
    19e7:	30 32                	xor    %dh,(%rdx)
    19e9:	01 0c 58             	add    %ecx,(%rax,%rbx,2)
    19ec:	01 26                	add    %esp,(%rsi)
    19ee:	11 00                	adc    %eax,(%rax)
    19f0:	00 30                	add    %dh,(%rax)
    19f2:	33 01                	xor    (%rcx),%eax
    19f4:	0c 67                	or     $0x67,%al
    19f6:	01 69 09             	add    %ebp,0x9(%rcx)
  *cur_time = bpf_ktime_get_ns();
    19f9:	00 00                	add    %al,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    19fb:	30 34 01             	xor    %dh,(%rcx,%rax,1)
    19fe:	0c 68                	or     $0x68,%al
    1a00:	01 69 09             	add    %ebp,0x9(%rcx)
    1a03:	00 00                	add    %al,(%rax)
    1a05:	30 35 01 0c 69 01    	xor    %dh,0x1690c01(%rip)        # 169260c <_license+0x16901df>
    conn_rate_stats->v1 = 1;
    1a0b:	69 09 00 00 30 36    	imul   $0x36300000,(%rcx),%ecx
    1a11:	01 0c 8c             	add    %ecx,(%rsp,%rcx,4)
    conn_rate_stats->v2 = *cur_time;
    1a14:	01 12                	add    %edx,(%rdx)
    1a16:	01 00                	add    %eax,(%rax)
    1a18:	00 1e                	add    %bl,(%rsi)
    conn_rate_stats->v1 += 1;
    1a1a:	c6                   	(bad)
    1a1b:	0c 5f                	or     $0x5f,%al
    1a1d:	01 ee                	add    %ebp,%esi
    1a1f:	10 00                	adc    %al,(%rax)
    1a21:	00 1e                	add    %bl,(%rsi)
    1a23:	d4                   	(bad)
    1a24:	0c 60                	or     $0x60,%al
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1a26:	01 fa                	add    %edi,%edx
    1a28:	00 00                	add    %al,(%rax)
    1a2a:	00 1f                	add    %bl,(%rdi)
    1a2c:	30 37                	xor    %dh,(%rdi)
    1a2e:	01 0c 7b             	add    %ecx,(%rbx,%rdi,2)
    1a31:	01 30                	add    %esi,(%rax)
    1a33:	0c 00                	or     $0x0,%al
    1a35:	00 00                	add    %al,(%rax)
    1a37:	00 2d 38 01 0e 44    	add    %ch,0x440e0138(%rip)        # 440e1b75 <_license+0x440df748>
    1a3d:	01 ee                	add    %ebp,%esi
    1a3f:	10 00                	adc    %al,(%rax)
    1a41:	00 1d a2 0e 44 01    	add    %bl,0x1440ea2(%rip)        # 14428e9 <_license+0x14404bc>
    1a47:	8b 09                	mov    (%rcx),%ecx
    1a49:	00 00                	add    %al,(%rax)
    1a4b:	1d a3 0e 44 01       	sbb    $0x1440ea3,%eax
    1a50:	8b 09                	mov    (%rcx),%ecx
    1a52:	00 00                	add    %al,(%rax)
    1a54:	1d ad 0e 44 01       	sbb    $0x1440ead,%eax
    1a59:	ee                   	out    %al,(%dx)
    1a5a:	10 00                	adc    %al,(%rax)
    1a5c:	00 1e                	add    %bl,(%rsi)
    1a5e:	d4                   	(bad)
    1a5f:	0e                   	(bad)
    1a60:	45 01 fa             	add    %r15d,%r10d
    1a63:	00 00                	add    %al,(%rax)
    1a65:	00 1f                	add    %bl,(%rdi)
    1a67:	1e                   	(bad)
    1a68:	d5                   	(bad)
    1a69:	0e                   	(bad)
    1a6a:	47 01 f8             	rex.RXB add %r15d,%r8d
    if (down_reals_map) {
    1a6d:	13 00                	adc    (%rax),%eax
    1a6f:	00 00                	add    %al,(%rax)
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1a71:	1f                   	(bad)
    1a72:	1e                   	(bad)
    1a73:	d5                   	(bad)
    1a74:	0e                   	(bad)
    1a75:	4c 01 47 12          	add    %r8,0x12(%rdi)
    1a79:	00 00                	add    %al,(%rax)
    1a7b:	00 00                	add    %al,(%rax)
    1a7d:	31 39                	xor    %edi,(%rcx)
    1a7f:	01 00                	add    %eax,(%rax)
    1a81:	b0 2f                	mov    $0x2f,%al
    1a83:	3a 01                	cmp    (%rcx),%al
    1a85:	00 b1 eb 1a 00 00    	add    %dh,0x1aeb(%rcx)
    1a8b:	25 af 00 b2 b4       	and    $0xb4b200af,%eax
    1a90:	11 00                	adc    %eax,(%rax)
    1a92:	00 25 ba 00 b3 8b    	add    %ah,-0x744cff46(%rip)        # ffffffff8bb31b52 <server_id_map+0x36fc42895b52>
      if (down_real) {
    1a98:	09 00                	or     %eax,(%rax)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1a9a:	00 2f                	add    %ch,(%rdi)
    1a9c:	3b 01                	cmp    (%rcx),%eax
    1a9e:	00 b4 ee 10 00 00 28 	add    %dh,0x28000010(%rsi,%rbp,8)
    1aa5:	3c 01                	cmp    $0x1,%al
    1aa7:	00 b5 90 03 00 00    	add    %dh,0x390(%rbp)
        if (stats_data) {
    1aad:	28 3d 01 00 b6 fa    	sub    %bh,-0x549ffff(%rip)        # fffffffffab61ab4 <server_id_map+0x36fcb18c5ab4>
          stats_data->v1 += 1;
    1ab3:	00 00                	add    %al,(%rax)
    1ab5:	00 26                	add    %ah,(%rsi)
    1ab7:	09 00                	or     %eax,(%rax)
    1ab9:	b7 bb                	mov    $0xbb,%bh
    if (!dst) {
    1abb:	00 00                	add    %al,(%rax)
    1abd:	00 1f                	add    %bl,(%rdi)
    1abf:	26 c0 00 c5          	es rolb $0xc5,(%rax)
    1ac3:	8b 09                	mov    (%rcx),%ecx
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1ac5:	00 00                	add    %al,(%rax)
    1ac7:	26 07                	es (bad)
    1ac9:	00 c5                	add    %al,%ch
    1acb:	1c 11                	sbb    $0x11,%al
    1acd:	00 00                	add    %al,(%rax)
    1acf:	1f                   	(bad)
    1ad0:	26 c1 00 c5          	es roll $0xc5,(%rax)
    1ad4:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    1ad9:	14 00                	adc    $0x0,%al
    1adb:	c5 21 11             	(bad)
    1ade:	00 00                	add    %al,(%rax)
    1ae0:	26 c2 00 c5          	es ret $0xc500
  if (!data_stats) {
    1ae4:	21 11                	and    %edx,(%rcx)
    1ae6:	00 00                	add    %al,(%rax)
    1ae8:	00 00                	add    %al,(%rax)
    1aea:	00 0b                	add    %cl,(%rbx)
    1aec:	ee                   	out    %al,(%dx)
    1aed:	04 00                	add    $0x0,%al
    1aef:	00 32                	add    %dh,(%rdx)
    1af1:	3e 01 00             	ds add %eax,(%rax)
  data_stats->v1 += 1;
    1af4:	7e 02                	jle    1af8 <balancer_ingress+0x1af8>
    1af6:	1d 25 00 7e 02       	sbb    $0x27e0025,%eax
  data_stats->v2 += pkt_bytes;
    1afb:	bb 00 00 00 2e       	mov    $0x2e000000,%ebx
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1b00:	3f                   	(bad)
    1b01:	01 00                	add    %eax,(%rax)
    1b03:	7e 02                	jle    1b07 <balancer_ingress+0x1b07>
    1b05:	ee                   	out    %al,(%dx)
    1b06:	10 00                	adc    %al,(%rax)
    1b08:	00 2e                	add    %ch,(%rsi)
    1b0a:	40 01 00             	rex add %eax,(%rax)
    1b0d:	7e 02                	jle    1b11 <balancer_ingress+0x1b11>
    1b0f:	ee                   	out    %al,(%dx)
    1b10:	10 00                	adc    %al,(%rax)
    1b12:	00 30                	add    %dh,(%rax)
    1b14:	41 01 00             	add    %eax,(%r8)
    1b17:	7f 02                	jg     1b1b <balancer_ingress+0x1b1b>
    1b19:	81 05 00 00 1f 1e c0 	addl   $0x28000c0,0x1e1f0000(%rip)        # 1e1f1b23 <_license+0x1e1ef6f6>
    1b20:	00 80 02 
    1b23:	8b 09                	mov    (%rcx),%ecx
    1b25:	00 00                	add    %al,(%rax)
    1b27:	1e                   	(bad)
    1b28:	07                   	(bad)
    1b29:	00 80 02 1c 11 00    	add    %al,0x111c02(%rax)
  if (!data_stats) {
    1b2f:	00 1f                	add    %bl,(%rdi)
    1b31:	1e                   	(bad)
    1b32:	14 00                	adc    $0x0,%al
    1b34:	80 02 21             	addb   $0x21,(%rdx)
  data_stats->v1 += 1;
    1b37:	11 00                	adc    %eax,(%rax)
  data_stats->v2 += pkt_bytes;
    1b39:	00 1e                	add    %bl,(%rsi)
    1b3b:	c2 00 80             	ret    $0x8000
    1b3e:	02 21                	add    (%rcx),%ah
    1b40:	11 00                	adc    %eax,(%rax)
    1b42:	00 1e                	add    %bl,(%rsi)
  pckt.flow.port16[0] = original_sport;
    1b44:	c1 00 80             	roll   $0x80,(%rax)
    1b47:	02 bb 00 00 00 00    	add    0x0(%rbx),%bh
  if (dst->flags & F_IPV6) {
    1b4d:	00 00                	add    %al,(%rax)
    1b4f:	2d 42 01 00 8c       	sub    $0x8c000142,%eax
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1b54:	02 b2 00 00 00 1d    	add    0x1d000000(%rdx),%dh
    1b5a:	2a 00                	sub    (%rax),%al
    1b5c:	8d 02                	lea    (%rdx),%eax
    1b5e:	eb 1a                	jmp    1b7a <balancer_ingress+0x1b7a>
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1b60:	00 00                	add    %al,(%rax)
    1b62:	1d af 00 8e 02       	sbb    $0x28e00af,%eax
    1b67:	b4 11                	mov    $0x11,%ah
    1b69:	00 00                	add    %al,(%rax)
    1b6b:	1d b6 00 8f 02       	sbb    $0x28f00b6,%eax
    1b70:	a8 02                	test   $0x2,%al
  data = (void*)(long)xdp->data;
    1b72:	00 00                	add    %al,(%rax)
    1b74:	1d 1d 00 90 02       	sbb    $0x290001d,%eax
  data_end = (void*)(long)xdp->data_end;
    1b79:	60                   	(bad)
  iph = data + sizeof(struct ethhdr);
    1b7a:	02 00                	add    (%rax),%al
    1b7c:	00 30                	add    %dh,(%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1b7e:	3d 01 00 91 02       	cmp    $0x2910001,%eax
    1b83:	fa                   	cli
    1b84:	00 00                	add    %al,(%rax)
    1b86:	00 1f                	add    %bl,(%rdi)
    1b88:	30 43 01             	xor    %al,0x1(%rbx)
    1b8b:	00 95 02 8b 09 00    	add    %dl,0x98b02(%rbp)
    1b91:	00 1f                	add    %bl,(%rdi)
    1b93:	1e                   	(bad)
    1b94:	c0 00 95             	rolb   $0x95,(%rax)
    1b97:	02 8b 09 00 00 1e    	add    0x1e000009(%rbx),%cl
    1b9d:	07                   	(bad)
    1b9e:	00 95 02 1c 11 00    	add    %dl,0x111c02(%rbp)
    1ba4:	00 00                	add    %al,(%rax)
    1ba6:	1f                   	(bad)
    1ba7:	30 44 01 00          	xor    %al,0x0(%rcx,%rax,1)
    1bab:	97                   	xchg   %eax,%edi
    1bac:	02 8b 09 00 00 1f    	add    0x1f000009(%rbx),%cl
    1bb2:	1e                   	(bad)
    1bb3:	b7 00                	mov    $0x0,%bh
    1bb5:	9c                   	pushf
    1bb6:	02 bb 00 00 00 30    	add    0x30000000(%rbx),%bh
  memcpy(new_eth->h_dest, cval->mac, 6);
    1bbc:	45 01 00             	add    %r8d,(%r8)
    1bbf:	9d                   	popf
    1bc0:	02 81 05 00 00 1f    	add    0x1f000005(%rcx),%al
    1bc6:	1e                   	(bad)
    1bc7:	c0 00 9d             	rolb   $0x9d,(%rax)
    1bca:	02 8b 09 00 00 1e    	add    0x1e000009(%rbx),%cl
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1bd0:	07                   	(bad)
    1bd1:	00 9d 02 1c 11 00    	add    %bl,0x111c02(%rbp)
    1bd7:	00 1f                	add    %bl,(%rdi)
    1bd9:	1e                   	(bad)
    1bda:	c1 00 9d             	roll   $0x9d,(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    1bdd:	02 bb 00 00 00 1e    	add    0x1e000000(%rbx),%bh
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1be3:	14 00                	adc    $0x0,%al
    1be5:	9d                   	popf
    1be6:	02 21                	add    (%rcx),%ah
    1be8:	11 00                	adc    %eax,(%rax)
  iph->ihl = 5;
    1bea:	00 1e                	add    %bl,(%rsi)
    1bec:	c2 00 9d             	ret    $0x9d00
  iph->tos = tos;
    1bef:	02 21                	add    (%rcx),%ah
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1bf1:	11 00                	adc    %eax,(%rax)
    1bf3:	00 00                	add    %al,(%rax)
    1bf5:	00 00                	add    %al,(%rax)
    1bf7:	00 00                	add    %al,(%rax)
    1bf9:	00 2a                	add    %ch,(%rdx)
    1bfb:	46 01 00             	rex.RX add %r8d,(%rax)
  iph->id = 0;
    1bfe:	26 ee                	es out %al,(%dx)
    1c00:	10 00                	adc    %al,(%rax)
    1c02:	00 2f                	add    %ch,(%rdi)
    1c04:	3d 01 00 27 30       	cmp    $0x30270001,%eax
  iph->saddr = saddr;
    1c09:	0a 00                	or     (%rax),%al
  iph->ttl = DEFAULT_TTL;
    1c0b:	00 28                	add    %ch,(%rax)
    1c0d:	47 01 00             	rex.RXB add %r8d,(%r8)
    1c10:	28 bb 00 00 00 28    	sub    %bh,0x28000000(%rbx)
    1c16:	48 01 00             	add    %rax,(%rax)
    1c19:	29 81 05 00 00 1f    	sub    %eax,0x1f000005(%rcx)
    1c1f:	26 c0 00 2a          	es rolb $0x2a,(%rax)
    1c23:	8b 09                	mov    (%rcx),%ecx
    1c25:	00 00                	add    %al,(%rax)
    1c27:	26 07                	es (bad)
    1c29:	00 2a                	add    %ch,(%rdx)
    1c2b:	1c 11                	sbb    $0x11,%al
    1c2d:	00 00                	add    %al,(%rax)
    1c2f:	1f                   	(bad)
    1c30:	26 c1 00 2a          	es roll $0x2a,(%rax)
    1c34:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    1c39:	14 00                	adc    $0x0,%al
    1c3b:	2a 21                	sub    (%rcx),%ah
    1c3d:	11 00                	adc    %eax,(%rax)
    1c3f:	00 26                	add    %ah,(%rsi)
    1c41:	c2 00 2a             	ret    $0x2a00
    1c44:	21 11                	and    %edx,(%rcx)
    1c46:	00 00                	add    %al,(%rax)
    1c48:	00 00                	add    %al,(%rax)
    1c4a:	00 2a                	add    %ch,(%rdx)
    1c4c:	49 01 11             	add    %rdx,(%r9)
    1c4f:	58                   	pop    %rax
    1c50:	ee                   	out    %al,(%dx)
    1c51:	10 00                	adc    %al,(%rax)
    1c53:	00 25 a1 11 59 84    	add    %ah,-0x7ba6ee5f(%rip)        # ffffffff84592dfa <server_id_map+0x36fc3b2f6dfa>
    1c59:	10 00                	adc    %al,(%rax)
    1c5b:	00 25 bd 11 5a c7    	add    %ah,-0x38a5ee43(%rip)        # ffffffffc75a2e1e <server_id_map+0x36fc7e306e1e>
    1c61:	00 00                	add    %al,(%rax)
    1c63:	00 25 af 11 5b b4    	add    %ah,-0x4ba4ee51(%rip)        # ffffffffb45b2e18 <server_id_map+0x36fc6b316e18>
    1c69:	11 00                	adc    %eax,(%rax)
    1c6b:	00 25 2a 11 5c ee    	add    %ah,-0x11a3eed6(%rip)        # ffffffffee5c2d9b <server_id_map+0x36fca5326d9b>
    1c71:	04 00                	add    $0x0,%al
    1c73:	00 25 bb 11 5d bb    	add    %ah,-0x44a2ee45(%rip)        # ffffffffbb5d2e34 <server_id_map+0x36fc72336e34>
    1c79:	00 00                	add    %al,(%rax)
    1c7b:	00 26                	add    %ah,(%rsi)
    1c7d:	d1 11                	rcll   (%rcx)
    1c7f:	60                   	(bad)
    1c80:	55                   	push   %rbp
    1c81:	0b 00                	or     (%rax),%eax
    1c83:	00 28                	add    %ch,(%rax)
    1c85:	4a 01 11             	rex.WX add %rdx,(%rcx)
    1c88:	63 bb 00 00 00 26    	movsxd 0x26000000(%rbx),%edi
    1c8e:	e5 11                	in     $0x11,%eax
    1c90:	64 fa                	fs cli
    1c92:	00 00                	add    %al,(%rax)
    1c94:	00 26                	add    %ah,(%rsi)
    1c96:	a2 11 5e 8b 09 00 00 	movabs %al,0xa3260000098b5e11
    1c9d:	26 a3 
    1c9f:	11 5f 8b             	adc    %ebx,-0x75(%rdi)
    1ca2:	09 00                	or     %eax,(%rax)
    1ca4:	00 28                	add    %ch,(%rax)
    1ca6:	2b 01                	sub    (%rcx),%eax
      if (pckt.flow.proto == IPPROTO_TCP) {
    1ca8:	11 61 d9             	adc    %esp,-0x27(%rcx)
    1cab:	18 00                	sbb    %al,(%rax)
    1cad:	00 28                	add    %ch,(%rax)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1caf:	26 01 11             	es add %edx,(%rcx)
    1cb2:	62                   	(bad)
    1cb3:	d9 18                	fstps  (%rax)
    1cb5:	00 00                	add    %al,(%rax)
    1cb7:	00 31                	add    %dh,(%rcx)
    1cb9:	4b 01 12             	rex.WXB add %rdx,(%r10)
    1cbc:	31 25 d1 12 32 55    	xor    %esp,0x553212d1(%rip)        # 55322f93 <_license+0x55320b66>
        if (!lru_stats) {
    1cc2:	0b 00                	or     (%rax),%eax
    1cc4:	00 25 91 12 33 12    	add    %ah,0x12331291(%rip)        # 12332f5b <_license+0x12330b2e>
        if (pckt.flags & F_SYN_SET) {
    1cca:	01 00                	add    %eax,(%rax)
    1ccc:	00 25 87 12 34 bb    	add    %ah,-0x44cbed79(%rip)        # ffffffffbb342f59 <server_id_map+0x36fc720a6f59>
    1cd2:	00 00                	add    %al,(%rax)
    1cd4:	00 25 8d 12 35 bb    	add    %ah,-0x44caed73(%rip)        # ffffffffbb352f67 <server_id_map+0x36fc720b6f67>
    1cda:	00 00                	add    %al,(%rax)
    1cdc:	00 25 bb 12 36 9c    	add    %ah,-0x63c9ed45(%rip)        # ffffffff9c362f9d <server_id_map+0x36fc530c6f9d>
  struct real_pos_lru new_dst_lru = {};
    1ce2:	02 00                	add    (%rax),%al
    1ce4:	00 25 22 12 37 12    	add    %ah,0x12371222(%rip)        # 12372f0c <_license+0x12370adf>
    1cea:	01 00                	add    %eax,(%rax)
    1cec:	00 26                	add    %ah,(%rsi)
    1cee:	e5 12                	in     $0x12,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1cf0:	38 fa                	cmp    %bh,%dl
    1cf2:	00 00                	add    %al,(%rax)
    1cf4:	00 00                	add    %al,(%rax)
    1cf6:	2a 4c 01 00          	sub    0x0(%rcx,%rax,1),%cl
    1cfa:	57                   	push   %rdi
    1cfb:	ee                   	out    %al,(%dx)
    1cfc:	10 00                	adc    %al,(%rax)
    1cfe:	00 2f                	add    %ch,(%rdi)
    1d00:	3a 01                	cmp    (%rcx),%al
  if (!conn_rate_stats) {
    1d02:	00 58 eb             	add    %bl,-0x15(%rax)
    1d05:	1a 00                	sbb    (%rax),%al
    1d07:	00 25 af 00 59 b4    	add    %ah,-0x4ba6ff51(%rip)        # ffffffffb4591dbc <server_id_map+0x36fc6b2f5dbc>
    1d0d:	11 00                	adc    %eax,(%rax)
    1d0f:	00 25 b6 00 5a a8    	add    %ah,-0x57a5ff4a(%rip)        # ffffffffa85a1dcb <server_id_map+0x36fc5f305dcb>
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1d15:	02 00                	add    (%rax),%al
    1d17:	00 25 ad 00 5b ee    	add    %ah,-0x11a4ff53(%rip)        # ffffffffee5b1dca <server_id_map+0x36fca5315dca>
    1d1d:	10 00                	adc    %al,(%rax)
    1d1f:	00 25 ba 00 5c 8b    	add    %ah,-0x74a3ff46(%rip)        # ffffffff8b5c1ddf <server_id_map+0x36fc42325ddf>
    conn_rate_stats->v1 = 1;
    1d25:	09 00                	or     %eax,(%rax)
    1d27:	00 28                	add    %ch,(%rax)
    1d29:	4d 01 00             	add    %r8,(%r8)
    conn_rate_stats->v2 = *cur_time;
    1d2c:	5e                   	pop    %rsi
    1d2d:	95                   	xchg   %eax,%ebp
    1d2e:	03 00                	add    (%rax),%eax
    1d30:	00 28                	add    %ch,(%rax)
    1d32:	4e 01 00             	rex.WRX add %r8,(%rax)
    conn_rate_stats->v1 += 1;
    1d35:	5f                   	pop    %rdi
    1d36:	ee                   	out    %al,(%dx)
    1d37:	10 00                	adc    %al,(%rax)
    1d39:	00 28                	add    %ch,(%rax)
    1d3b:	4f 01 00             	rex.WRXB add %r8,(%r8)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1d3e:	60                   	(bad)
    1d3f:	ee                   	out    %al,(%dx)
    1d40:	10 00                	adc    %al,(%rax)
    1d42:	00 28                	add    %ch,(%rax)
    1d44:	3d 01 00 62 fa       	cmp    $0xfa620001,%eax
    1d49:	00 00                	add    %al,(%rax)
    1d4b:	00 28                	add    %ch,(%rax)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1d4d:	50                   	push   %rax
    1d4e:	01 00                	add    %eax,(%rax)
    1d50:	63 bb 00 00 00 26    	movsxd 0x26000000(%rbx),%edi
    1d56:	09 00                	or     %eax,(%rax)
    1d58:	64 bb 00 00 00 26    	fs mov $0x26000000,%ebx
    c += *(u32*)(k + 8);
    1d5e:	ce                   	(bad)
    1d5f:	00 61 b6             	add    %ah,-0x4a(%rcx)
      a += (u32)k[3] << 24;
    1d62:	00 00                	add    %al,(%rax)
    1d64:	00 1f                	add    %bl,(%rdi)
      a += (u32)k[2] << 16;
    1d66:	28 51 01             	sub    %dl,0x1(%rcx)
    1d69:	00 86 ee 10 00 00    	add    %al,0x10ee(%rsi)
      a += (u32)k[1] << 8;
    1d6f:	1f                   	(bad)
      a += k[0];
    1d70:	26 c0 00 92          	es rolb $0x92,(%rax)
    1d74:	8b 09                	mov    (%rcx),%ecx
    1d76:	00 00                	add    %al,(%rax)
    1d78:	26 07                	es (bad)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1d7a:	00 92 1c 11 00 00    	add    %dl,0x111c(%rdx)
    1d80:	1f                   	(bad)
    1d81:	26 c1 00 92          	es roll $0x92,(%rax)
      memset(pckt->flow.srcv6, 0, 16);
    1d85:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    1d8a:	14 00                	adc    $0x0,%al
    1d8c:	92                   	xchg   %eax,%edx
    1d8d:	21 11                	and    %edx,(%rcx)
    1d8f:	00 00                	add    %al,(%rax)
    1d91:	26 c2 00 92          	es ret $0x9200
    1d95:	21 11                	and    %edx,(%rcx)
    1d97:	00 00                	add    %al,(%rax)
    1d99:	00 00                	add    %al,(%rax)
    1d9b:	00 1f                	add    %bl,(%rdi)
    1d9d:	26 c0 00 9f          	es rolb $0x9f,(%rax)
    1da1:	8b 09                	mov    (%rcx),%ecx
    1da3:	00 00                	add    %al,(%rax)
    1da5:	26 07                	es (bad)
    c += *(u32*)(k + 8);
    1da7:	00 9f 1c 11 00 00    	add    %bl,0x111c(%rdi)
    __jhash_mix(a, b, c);
    1dad:	1f                   	(bad)
    1dae:	26 c1 00 9f          	es roll $0x9f,(%rax)
    1db2:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    b += *(u32*)(k + 4);
    1db7:	14 00                	adc    $0x0,%al
    1db9:	9f                   	lahf
    1dba:	21 11                	and    %edx,(%rcx)
    __jhash_mix(a, b, c);
    1dbc:	00 00                	add    %al,(%rax)
    1dbe:	26 c2 00 9f          	es ret $0x9f00
    1dc2:	21 11                	and    %edx,(%rcx)
    1dc4:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1dc6:	00 00                	add    %al,(%rax)
    1dc8:	00 2a                	add    %ch,(%rdx)
    1dca:	52                   	push   %rdx
    __jhash_mix(a, b, c);
    1dcb:	01 0d 66 bb 0c 00    	add    %ecx,0xcbb66(%rip)        # cd937 <_license+0xcb50a>
  return (word << shift) | (word >> ((-shift) & 31));
    1dd1:	00 2f                	add    %ch,(%rdi)
    1dd3:	53                   	push   %rbx
    __jhash_mix(a, b, c);
    1dd4:	01 0d 66 bb 0c 00    	add    %ecx,0xcbb66(%rip)        # cd940 <_license+0xcb513>
    1dda:	00 2f                	add    %ch,(%rdi)
  return (word << shift) | (word >> ((-shift) & 31));
    1ddc:	54                   	push   %rsp
    1ddd:	01 0d 66 bb 0c 00    	add    %ecx,0xcbb66(%rip)        # cd949 <_license+0xcb51c>
    __jhash_mix(a, b, c);
    1de3:	00 2f                	add    %ch,(%rdi)
    1de5:	55                   	push   %rbp
    1de6:	01 0d 66 bb 0c 00    	add    %ecx,0xcbb66(%rip)        # cd952 <_license+0xcb525>
    1dec:	00 2f                	add    %ch,(%rdi)
    1dee:	56                   	push   %rsi
    1def:	01 0d 66 bb 0c 00    	add    %ecx,0xcbb66(%rip)        # cd95b <_license+0xcb52e>
  return (word << shift) | (word >> ((-shift) & 31));
    1df5:	00 00                	add    %al,(%rax)
    1df7:	2a 57 01             	sub    0x1(%rdi),%dl
    __jhash_mix(a, b, c);
    1dfa:	0d 6e bb 0c 00       	or     $0xcbb6e,%eax
      a += (u32)k[3] << 24;
    1dff:	00 2f                	add    %ch,(%rdi)
    1e01:	53                   	push   %rbx
      a += (u32)k[2] << 16;
    1e02:	01 0d 6e bb 0c 00    	add    %ecx,0xcbb6e(%rip)        # cd976 <_license+0xcb549>
    1e08:	00 2f                	add    %ch,(%rdi)
      a += (u32)k[3] << 24;
    1e0a:	54                   	push   %rsp
      a += (u32)k[1] << 8;
    1e0b:	01 0d 6e bb 0c 00    	add    %ecx,0xcbb6e(%rip)        # cd97f <_license+0xcb552>
    1e11:	00 2f                	add    %ch,(%rdi)
      a += (u32)k[2] << 16;
    1e13:	56                   	push   %rsi
      a += k[0];
    1e14:	01 0d 6e bb 0c 00    	add    %ecx,0xcbb6e(%rip)        # cd988 <_license+0xcb55b>
    1e1a:	00 00                	add    %al,(%rax)
    __jhash_mix(a, b, c);
    1e1c:	2a 58 01             	sub    0x1(%rax),%bl
      __jhash_final(a, b, c);
    1e1f:	00 19                	add    %bl,(%rcx)
  return (word << shift) | (word >> ((-shift) & 31));
    1e21:	bb 00 00 00 25       	mov    $0x25000000,%ebx
      __jhash_final(a, b, c);
    1e26:	af                   	scas   %es:(%rdi),%eax
    1e27:	00 1a                	add    %bl,(%rdx)
    1e29:	b4 11                	mov    $0x11,%ah
  return (word << shift) | (word >> ((-shift) & 31));
    1e2b:	00 00                	add    %al,(%rax)
    1e2d:	2f                   	(bad)
    1e2e:	51                   	push   %rcx
      __jhash_final(a, b, c);
    1e2f:	01 00                	add    %eax,(%rax)
    1e31:	1b ee                	sbb    %esi,%ebp
  return (word << shift) | (word >> ((-shift) & 31));
    1e33:	10 00                	adc    %al,(%rax)
    1e35:	00 00                	add    %al,(%rax)
    1e37:	2a 59 01             	sub    0x1(%rcx),%bl
      __jhash_final(a, b, c);
    1e3a:	0d 07 bb 00 00       	or     $0xbb07,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1e3f:	00 2f                	add    %ch,(%rdi)
      __jhash_final(a, b, c);
    1e41:	5a                   	pop    %rdx
    1e42:	01 0d 07 bb 00 00    	add    %ecx,0xbb07(%rip)        # d94f <_license+0xb522>
  return (word << shift) | (word >> ((-shift) & 31));
    1e48:	00 2f                	add    %ch,(%rdi)
      __jhash_final(a, b, c);
    1e4a:	5b                   	pop    %rbx
    1e4b:	01 0d 07 c3 00 00    	add    %ecx,0xc307(%rip)        # e158 <_license+0xbd2b>
    1e51:	00 00                	add    %al,(%rax)
    1e53:	33 5c 01 00          	xor    0x0(%rcx,%rax,1),%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1e57:	42 28 5d 01          	rex.X sub %bl,0x1(%rbp)
  a += initval;
    1e5b:	00 43 bb             	add    %al,-0x45(%rbx)
    1e5e:	00 00                	add    %al,(%rax)
  b += initval;
    1e60:	00 28                	add    %ch,(%rax)
    1e62:	5e                   	pop    %rsi
  a += initval;
    1e63:	01 00                	add    %eax,(%rax)
    1e65:	44 81 05 00 00 1f 26 	rex.R addl $0x8b4500c0,0x261f0000(%rip)        # 261f1e70 <_license+0x261efa43>
    1e6c:	c0 00 45 8b 
  __jhash_final(a, b, c);
    1e70:	09 00                	or     %eax,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1e72:	00 26                	add    %ah,(%rsi)
    1e74:	07                   	(bad)
    1e75:	00 45 1c             	add    %al,0x1c(%rbp)
  __jhash_final(a, b, c);
    1e78:	11 00                	adc    %eax,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1e7a:	00 1f                	add    %bl,(%rdi)
    1e7c:	26 c1 00 45          	es roll $0x45,(%rax)
  __jhash_final(a, b, c);
    1e80:	bb 00 00 00 26       	mov    $0x26000000,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1e85:	14 00                	adc    $0x0,%al
    1e87:	45 21 11             	and    %r10d,(%r9)
  __jhash_final(a, b, c);
    1e8a:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1e8c:	26 c2 00 45          	es ret $0x4500
    1e90:	21 11                	and    %edx,(%rcx)
  __jhash_final(a, b, c);
    1e92:	00 00                	add    %al,(%rax)
    1e94:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1e96:	00 33                	add    %dh,(%rbx)
    1e98:	5f                   	pop    %rdi
    1e99:	01 00                	add    %eax,(%rax)
  __jhash_final(a, b, c);
    1e9b:	4d 28 5d 01          	rex.WRB sub %r11b,0x1(%r13)
  return (word << shift) | (word >> ((-shift) & 31));
    1e9f:	00 4e bb             	add    %cl,-0x45(%rsi)
  __jhash_final(a, b, c);
    1ea2:	00 00                	add    %al,(%rax)
    1ea4:	00 28                	add    %ch,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    1ea6:	5e                   	pop    %rsi
    1ea7:	01 00                	add    %eax,(%rax)
  __jhash_final(a, b, c);
    1ea9:	4f 81 05 00 00 1f 26 	rex.WRXB addq $0xffffffff8b5000c0,0x261f0000(%rip)        # 261f1eb4 <_license+0x261efa87>
    1eb0:	c0 00 50 8b 
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1eb4:	09 00                	or     %eax,(%rax)
    1eb6:	00 26                	add    %ah,(%rsi)
    1eb8:	07                   	(bad)
    1eb9:	00 50 1c             	add    %dl,0x1c(%rax)
    1ebc:	11 00                	adc    %eax,(%rax)
    1ebe:	00 1f                	add    %bl,(%rdi)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1ec0:	26 c1 00 50          	es roll $0x50,(%rax)
    1ec4:	bb 00 00 00 26       	mov    $0x26000000,%ebx
    1ec9:	14 00                	adc    $0x0,%al
    1ecb:	50                   	push   %rax
    1ecc:	21 11                	and    %edx,(%rcx)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1ece:	00 00                	add    %al,(%rax)
    1ed0:	26 c2 00 50          	es ret $0x5000
    if (!real_pos) {
    1ed4:	21 11                	and    %edx,(%rcx)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1ed6:	00 00                	add    %al,(%rax)
    1ed8:	00 00                	add    %al,(%rax)
    1eda:	00 2a                	add    %ch,(%rdx)
    1edc:	60                   	(bad)
    1edd:	01 11                	add    %edx,(%rcx)
    1edf:	2a ee                	sub    %dh,%ch
    1ee1:	10 00                	adc    %al,(%rax)
    key = *real_pos;
    1ee3:	00 25 a1 11 2b 84    	add    %ah,-0x7bd4ee5f(%rip)        # ffffffff842b308a <server_id_map+0x36fc3b01708a>
    1ee9:	10 00                	adc    %al,(%rax)
    1eeb:	00 25 bd 11 2c c7    	add    %ah,-0x38d3ee43(%rip)        # ffffffffc72c30ae <server_id_map+0x36fc7e0270ae>
  pckt->real_index = key;
    1ef1:	00 00                	add    %al,(%rax)
  *real = bpf_map_lookup_elem(&reals, &key);
    1ef3:	00 25 ad 11 2d ee    	add    %ah,-0x11d2ee53(%rip)        # ffffffffee2d30a6 <server_id_map+0x36fca50370a6>
  if (!(*real)) {
    1ef9:	10 00                	adc    %al,(%rax)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1efb:	00 25 af 11 2e b4    	add    %ah,-0x4bd1ee51(%rip)        # ffffffffb42e30b0 <server_id_map+0x36fc6b0470b0>
    1f01:	11 00                	adc    %eax,(%rax)
    1f03:	00 25 2a 11 2f ee    	add    %ah,-0x11d0eed6(%rip)        # ffffffffee2f3033 <server_id_map+0x36fca5057033>
    1f09:	04 00                	add    $0x0,%al
    1f0b:	00 25 bb 11 30 bb    	add    %ah,-0x44cfee45(%rip)        # ffffffffbb3030cc <server_id_map+0x36fc720670cc>
    1f11:	00 00                	add    %al,(%rax)
    1f13:	00 26                	add    %ah,(%rsi)
  if (!ch_drop_stats) {
    1f15:	a2 11 31 8b 09 00 00 	movabs %al,0xa3260000098b3111
    1f1c:	26 a3 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1f1e:	11 32                	adc    %esi,(%rdx)
    1f20:	8b 09                	mov    (%rcx),%ecx
    1f22:	00 00                	add    %al,(%rax)
    1f24:	28 2b                	sub    %ch,(%rbx)
    1f26:	01 11                	add    %edx,(%rcx)
    1f28:	34 d9                	xor    $0xd9,%al
    1f2a:	18 00                	sbb    %al,(%rax)
    1f2c:	00 26                	add    %ah,(%rsi)
    1f2e:	d2 11                	rclb   %cl,(%rcx)
    1f30:	33 67 0a             	xor    0xa(%rdi),%esp
    1f33:	00 00                	add    %al,(%rax)
  if (!ch_drop_stats) {
    1f35:	28 26                	sub    %ah,(%rsi)
    1f37:	01 11                	add    %edx,(%rcx)
    1f39:	35 d9 18 00 00       	xor    $0x18d9,%eax
    1f3e:	26 22 11             	es and (%rcx),%dl
    1f41:	38 12                	cmp    %dl,(%rdx)
    1f43:	01 00                	add    %eax,(%rax)
    1f45:	00 26                	add    %ah,(%rsi)
}
    1f47:	87 11                	xchg   %edx,(%rcx)
    1f49:	37                   	(bad)
    1f4a:	57                   	push   %rdi
    1f4b:	1f                   	(bad)
    1f4c:	00 00                	add    %al,(%rax)
    1f4e:	26 83 11 36          	es adcl $0x36,(%rcx)
    1f52:	9c                   	pushf
    1f53:	02 00                	add    (%rax),%al
    1f55:	00 00                	add    %al,(%rax)
    1f57:	04 bb                	add    $0xbb,%al
    1f59:	00 00                	add    %al,(%rax)
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1f5b:	00 05 60 00 00 00    	add    %al,0x60(%rip)        # 1fc1 <balancer_ingress+0x1fc1>
    1f61:	04 00                	add    $0x0,%al
    1f63:	31 61 01             	xor    %esp,0x1(%rcx)
    1f66:	12 21                	adc    (%rcx),%ah
    1f68:	25 1f 12 21 9c       	and    $0x9c21121f,%eax
    1f6d:	02 00                	add    (%rax),%al
    1f6f:	00 25 28 12 21 b8    	add    %ah,-0x47deedd8(%rip)        # ffffffffb821319d <server_id_map+0x36fc6ef7719d>
    1f75:	01 00                	add    %eax,(%rax)
    1f77:	00 25 87 12 21 b6    	add    %ah,-0x49deed79(%rip)        # ffffffffb6213204 <server_id_map+0x36fc6cf77204>
    1f7d:	00 00                	add    %al,(%rax)
    1f7f:	00 00                	add    %al,(%rax)
    1f81:	31 62 01             	xor    %esp,0x1(%rdx)
    1f84:	12 4c 25 d2          	adc    -0x2e(%rbp,%riz,1),%cl
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1f88:	12 4d 67             	adc    0x67(%rbp),%cl
    1f8b:	0a 00                	or     (%rax),%al
    1f8d:	00 2f                	add    %ch,(%rdi)
    1f8f:	63 01                	movsxd (%rcx),%eax
    1f91:	12 4e 12             	adc    0x12(%rsi),%cl
  data = (void*)(long)xdp->data;
    1f94:	01 00                	add    %eax,(%rax)
    1f96:	00 25 87 12 4f b6    	add    %ah,-0x49b0ed79(%rip)        # ffffffffb64f3223 <server_id_map+0x36fc6d257223>
  ip6h = data + sizeof(struct ethhdr);
    1f9c:	00 00                	add    %al,(%rax)
    1f9e:	00 25 8d 12 50 b6    	add    %ah,-0x49afed73(%rip)        # ffffffffb6503231 <server_id_map+0x36fc6d267231>
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1fa4:	00 00                	add    %al,(%rax)
    1fa6:	00 25 83 12 51 9c    	add    %ah,-0x63aeed7d(%rip)        # ffffffff9c51322f <server_id_map+0x36fc5327722f>
    1fac:	02 00                	add    (%rax),%al
    1fae:	00 25 22 12 52 12    	add    %ah,0x12521222(%rip)        # 125231d6 <_license+0x12520da9>
    1fb4:	01 00                	add    %eax,(%rax)
    1fb6:	00 00                	add    %al,(%rax)
    1fb8:	32 64 01 00          	xor    0x0(%rcx,%rax,1),%ah
    1fbc:	35 02 1d c8 00       	xor    $0xc81d02,%eax
  memcpy(new_eth->h_dest, cval->mac, 6);
    1fc1:	36 02 a4 06 00 00 1d 	ss add -0x34e30000(%rsi,%rax,1),%ah
    1fc8:	cb 
    1fc9:	00 37                	add    %dh,(%rdi)
    1fcb:	02 12                	add    (%rdx),%dl
    1fcd:	01 00                	add    %eax,(%rax)
    1fcf:	00 00                	add    %al,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1fd1:	2d 65 01 06 9f       	sub    $0x9f060165,%eax
    1fd6:	01 b2 00 00 00 2e    	add    %esi,0x2e000000(%rdx)
    1fdc:	1d 01 06 9f 01       	sbb    $0x19f0601,%eax
  new_eth->h_proto = BE_ETH_P_IPV6;
    1fe1:	8b 09                	mov    (%rcx),%ecx
    1fe3:	00 00                	add    %al,(%rax)
    1fe5:	1d 09 06 9f 01       	sbb    $0x19f0609,%eax
  saddr[3] = src ^ port;
    1fea:	8b 09                	mov    (%rcx),%ecx
    1fec:	00 00                	add    %al,(%rax)
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    1fee:	1d 0c 06 9f 01       	sbb    $0x19f060c,%eax
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1ff3:	8b 09                	mov    (%rcx),%ecx
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1ff5:	00 00                	add    %al,(%rax)
    1ff7:	1d 24 06 9f 01       	sbb    $0x19f0624,%eax
  ip6h->priority = (tc & 0xF0) >> 4;
    1ffc:	02 01                	add    (%rcx),%al
    1ffe:	00 00                	add    %al,(%rax)
    2000:	00 2d 66 01 00 43    	add    %ch,0x43000166(%rip)        # 4300216c <_license+0x42fffd3f>
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    2006:	02 b2 00 00 00 1d    	add    0x1d000000(%rdx),%dh
  ip6h->nexthdr = proto;
    200c:	1d 00 44 02 60       	sbb    $0x60024400,%eax
    2011:	02 00                	add    (%rax),%al
  ip6h->payload_len = bpf_htons(payload_len);
    2013:	00 1d af 00 45 02    	add    %bl,0x24500af(%rip)        # 24520c8 <_license+0x244fc9b>
    2019:	b4 11                	mov    $0x11,%ah
    201b:	00 00                	add    %al,(%rax)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    201d:	1d b6 00 46 02       	sbb    $0x24600b6,%eax
    2022:	a8 02                	test   $0x2,%al
    2024:	00 00                	add    %al,(%rax)
    2026:	1d ad 00 47 02       	sbb    $0x24700ad,%eax
    202b:	ee                   	out    %al,(%dx)
    202c:	10 00                	adc    %al,(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    202e:	00 30                	add    %dh,(%rax)
    2030:	67 01 00             	add    %eax,(%eax)
    2033:	4a 02 60 02          	rex.WX add 0x2(%rax),%spl
    2037:	00 00                	add    %al,(%rax)
    2039:	30 68 01             	xor    %ch,0x1(%rax)
    203c:	00 49 02             	add    %cl,0x2(%rcx)
    203f:	bb 00 00 00 30       	mov    $0x30000000,%ebx
    if (pckt->flow.proto == IPPROTO_UDP) {
    2044:	69 01 00 4f 02 ee    	imul   $0xee024f00,(%rcx),%eax
      new_dst_lru.atime = cur_time;
    204a:	10 00                	adc    %al,(%rax)
    204c:	00 30                	add    %dh,(%rax)
    new_dst_lru.pos = key;
    204e:	6a 01                	push   $0x1
    2050:	00 55 02             	add    %dl,0x2(%rbp)
    2053:	ee                   	out    %al,(%dx)
    2054:	10 00                	adc    %al,(%rax)
    2056:	00 30                	add    %dh,(%rax)
BPF_MAP_OPS_INLINE(int,
    2058:	6b 01 00             	imul   $0x0,(%rcx),%eax
    205b:	56                   	push   %rsi
    205c:	02 ee                	add    %dh,%ch
    205e:	10 00                	adc    %al,(%rax)
    2060:	00 30                	add    %dh,(%rax)
    2062:	6c                   	insb   (%dx),%es:(%rdi)
    2063:	01 00                	add    %eax,(%rax)
    2065:	57                   	push   %rdi
    2066:	02 ee                	add    %dh,%ch
    2068:	10 00                	adc    %al,(%rax)
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    206a:	00 1f                	add    %bl,(%rdi)
    206c:	1e                   	(bad)
    206d:	c4                   	(bad)
    206e:	00 59 02             	add    %bl,0x2(%rcx)
    2071:	bb 00 00 00 30       	mov    $0x30000000,%ebx
    2076:	6d                   	insl   (%dx),%es:(%rdi)
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    2077:	01 00                	add    %eax,(%rax)
    2079:	5a                   	pop    %rdx
    207a:	02 b6 00 00 00 1f    	add    0x1f000000(%rsi),%dh
    2080:	1e                   	(bad)
    2081:	c0 00 5a             	rolb   $0x5a,(%rax)
    2084:	02 8b 09 00 00 1e    	add    0x1e000009(%rbx),%cl
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    208a:	07                   	(bad)
    208b:	00 5a 02             	add    %bl,0x2(%rdx)
    208e:	1c 11                	sbb    $0x11,%al
    2090:	00 00                	add    %al,(%rax)
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    2092:	1f                   	(bad)
    2093:	1e                   	(bad)
    2094:	c1 00 5a             	roll   $0x5a,(%rax)
    2097:	02 bb 00 00 00 1e    	add    0x1e000000(%rbx),%bh
    209d:	14 00                	adc    $0x0,%al
    209f:	5a                   	pop    %rdx
    20a0:	02 21                	add    (%rcx),%ah
    20a2:	11 00                	adc    %eax,(%rax)
    20a4:	00 1e                	add    %bl,(%rsi)
    20a6:	c2 00 5a             	ret    $0x5a00
    20a9:	02 21                	add    (%rcx),%ah
  bool port_match = lru_miss_stat_vip->port == vip->port;
    20ab:	11 00                	adc    %eax,(%rax)
    20ad:	00 00                	add    %al,(%rax)
    20af:	00 00                	add    %al,(%rax)
    20b1:	1f                   	(bad)
    20b2:	1e                   	(bad)
    20b3:	c0 00 4b             	rolb   $0x4b,(%rax)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    20b6:	02 8b 09 00 00 1e    	add    0x1e000009(%rbx),%cl
    20bc:	07                   	(bad)
    20bd:	00 4b 02             	add    %cl,0x2(%rbx)
  bool vip_match = address_match && port_match && proto_match;
    20c0:	1c 11                	sbb    $0x11,%al
    20c2:	00 00                	add    %al,(%rax)
    20c4:	1f                   	(bad)
    20c5:	1e                   	(bad)
    20c6:	c1 00 4b             	roll   $0x4b,(%rax)
    20c9:	02 bb 00 00 00 1e    	add    0x1e000000(%rbx),%bh
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    20cf:	14 00                	adc    $0x0,%al
    20d1:	4b 02 21             	rex.WXB add (%r9),%spl
    20d4:	11 00                	adc    %eax,(%rax)
    20d6:	00 1e                	add    %bl,(%rsi)
    20d8:	c2 00 4b             	ret    $0x4b00
    20db:	02 21                	add    (%rcx),%ah
    20dd:	11 00                	adc    %eax,(%rax)
    20df:	00 00                	add    %al,(%rax)
    20e1:	00 00                	add    %al,(%rax)
    20e3:	2d 6e 01 00 67       	sub    $0x6700016e,%eax
    20e8:	02 b2 00 00 00 1d    	add    0x1d000000(%rdx),%dh
    20ee:	af                   	scas   %es:(%rdi),%eax
    20ef:	00 68 02             	add    %ch,0x2(%rax)
    20f2:	b4 11                	mov    $0x11,%ah
    20f4:	00 00                	add    %al,(%rax)
    if (!lru_miss_stat) {
    20f6:	1d ba 00 69 02       	sbb    $0x26900ba,%eax
    20fb:	8b 09                	mov    (%rcx),%ecx
    20fd:	00 00                	add    %al,(%rax)
    *lru_miss_stat += 1;
    20ff:	30 4d 01             	xor    %cl,0x1(%rbp)
    2102:	00 77 02             	add    %dh,0x2(%rdi)
    2105:	95                   	xchg   %eax,%ebp
    2106:	03 00                	add    (%rax),%eax
    2108:	00 30                	add    %dh,(%rax)
    210a:	3c 01                	cmp    $0x1,%al
    210c:	00 6a 02             	add    %ch,0x2(%rdx)
    210f:	90                   	nop
    2110:	03 00                	add    (%rax),%eax
    2112:	00 30                	add    %dh,(%rax)
    2114:	3d 01 00 73 02       	cmp    $0x2730001,%eax
    2119:	fa                   	cli
    211a:	00 00                	add    %al,(%rax)
    211c:	00 00                	add    %al,(%rax)
    211e:	2a 6f 01             	sub    0x1(%rdi),%ch
      data_stats->v2 += 1;
    2121:	0d 37 bb 0c 00       	or     $0xcbb37,%eax
    2126:	00 25 09 0d 37 66    	add    %ah,0x66370d09(%rip)        # 66372e35 <_license+0x66370a08>
    212c:	21 00                	and    %eax,(%rax)
    212e:	00 2f                	add    %ch,(%rdi)
    2130:	70 01                	jo     2133 <balancer_ingress+0x2133>
    2132:	0d 37 bb 0c 00       	or     $0xcbb37,%eax
    2137:	00 2f                	add    %ch,(%rdi)
    2139:	56                   	push   %rsi
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    213a:	01 0d 37 bb 0c 00    	add    %ecx,0xcbb37(%rip)        # cdc77 <_license+0xcb84a>
    2140:	00 28                	add    %ch,(%rax)
    2142:	55                   	push   %rbp
    2143:	01 0d 38 bb 0c 00    	add    %ecx,0xcbb38(%rip)        # cdc81 <_license+0xcb854>
    2149:	00 28                	add    %ch,(%rax)
    214b:	53                   	push   %rbx
    214c:	01 0d 38 bb 0c 00    	add    %ecx,0xcbb38(%rip)        # cdc8a <_license+0xcb85d>
    2152:	00 28                	add    %ch,(%rax)
    2154:	54                   	push   %rsp
    2155:	01 0d 38 bb 0c 00    	add    %ecx,0xcbb38(%rip)        # cdc93 <_license+0xcb866>
    215b:	00 28                	add    %ch,(%rax)
    215d:	71 01                	jno    2160 <balancer_ingress+0x2160>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    215f:	0d 39 6c 21 00       	or     $0x216c39,%eax
    2164:	00 00                	add    %al,(%rax)
    2166:	0b 6b 21             	or     0x21(%rbx),%ebp
    2169:	00 00                	add    %al,(%rax)
    216b:	34 0b                	xor    $0xb,%al
    216d:	71 21                	jno    2190 <balancer_ingress+0x2190>
    216f:	00 00                	add    %al,(%rax)
    2171:	23 1a                	and    (%rdx),%ebx
    2173:	01 00                	add    %eax,(%rax)
    2175:	00 35 14 2d 24 00    	add    %dh,0x242d14(%rip)        # 244e8f <_license+0x242a62>
    217b:	00 01                	add    %al,(%rcx)
      if (qpr.server_id > 0) {
    217d:	57                   	push   %rdi
    217e:	77 01                	ja     2181 <balancer_ingress+0x2181>
    2180:	00 31                	add    %dh,(%rcx)
    2182:	04 b2                	add    $0xb2,%al
    2184:	00 00                	add    %al,(%rax)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    2186:	00 36                	add    %dh,(%rsi)
    2188:	00 78 01             	add    %bh,0x1(%rax)
    218b:	00 31                	add    %dh,(%rcx)
    218d:	04 84                	add    $0x84,%al
    218f:	10 00                	adc    %al,(%rax)
    2191:	00 37                	add    %dh,(%rdi)
    2193:	01 a2 00 32 04 8b    	add    %esp,-0x74fbce00(%rdx)
    2199:	09 00                	or     %eax,(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    219b:	00 37                	add    %dh,(%rdi)
    219d:	02 a3 00 33 04 8b    	add    -0x74fbcd00(%rbx),%ah
    21a3:	09 00                	or     %eax,(%rax)
    21a5:	00 38                	add    %bh,(%rax)
    21a7:	03 79 01             	add    0x1(%rcx),%edi
    21aa:	00 34 04             	add    %dh,(%rsp,%rax,1)
    21ad:	d9 18                	fstps  (%rax)
    21af:	00 00                	add    %al,(%rax)
    21b1:	37                   	(bad)
    21b2:	04 ac                	add    $0xac,%al
    21b4:	00 36                	add    %dh,(%rsi)
  if (!conn_rate_stats) {
    21b6:	04 bb                	add    $0xbb,%al
    21b8:	00 00                	add    %al,(%rax)
    21ba:	00 38                	add    %bh,(%rax)
    21bc:	05 7a 01 00 35       	add    $0x3500017a,%eax
    21c1:	04 bb                	add    $0xbb,%al
    21c3:	00 00                	add    %al,(%rax)
  *cur_time = bpf_ktime_get_ns();
    21c5:	00 39                	add    %bh,(%rcx)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    21c7:	cd 0c                	int    $0xc
    21c9:	00 00                	add    %al,(%rax)
    21cb:	00 00                	add    %al,(%rax)
    21cd:	41 04 0c             	rex.B add $0xc,%al
    21d0:	3a 06                	cmp    (%rsi),%al
    21d2:	d6                   	(bad)
    21d3:	0c 00                	or     $0x0,%al
    21d5:	00 3a                	add    %bh,(%rdx)
    21d7:	07                   	(bad)
    21d8:	df 0c 00             	fisttps (%rax,%rax,1)
    conn_rate_stats->v1 = 1;
    21db:	00 3a                	add    %bh,(%rdx)
    21dd:	08 e8                	or     %ch,%al
    21df:	0c 00                	or     $0x0,%al
    21e1:	00 3b                	add    %bh,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    21e3:	02 91 10 f1 0c 00    	add    0xcf110(%rcx),%dl
    21e9:	00 3b                	add    %bh,(%rbx)
    21eb:	03 91 e0 00 fa 0c    	add    0xcfa00e0(%rcx),%edx
    21f1:	00 00                	add    %al,(%rax)
    21f3:	3c 09                	cmp    $0x9,%al
    21f5:	03 0d 00 00 3c 0a    	add    0xa3c0000(%rip),%ecx        # a3c21fb <_license+0xa3bfdce>
    21fb:	0c 0d                	or     $0xd,%al
    21fd:	00 00                	add    %al,(%rax)
    21ff:	3c 0b                	cmp    $0xb,%al
    2201:	15 0d 00 00 3c       	adc    $0x3c00000d,%eax
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    2206:	0c 1e                	or     $0x1e,%al
    2208:	0d 00 00 3c 0d       	or     $0xd3c0000,%eax
    220d:	27                   	(bad)
    220e:	0d 00 00 3c 42       	or     $0x423c0000,%eax
    2213:	30 0d 00 00 3c 43    	xor    %cl,0x433c0000(%rip)        # 433c2219 <_license+0x433bfdec>
          key = *real_pos;
    2219:	39 0d 00 00 3c b2    	cmp    %ecx,-0x4dc40000(%rip)        # ffffffffb23c221f <server_id_map+0x36fc6912621f>
          if (key == 0) {
    221f:	01 42 0d             	add    %eax,0xd(%rdx)
            pckt.real_index = key;
    2222:	00 00                	add    %al,(%rax)
    2224:	3c b3                	cmp    $0xb3,%al
    2226:	01 4b 0d             	add    %ecx,0xd(%rbx)
            dst = bpf_map_lookup_elem(&reals, &key);
    2229:	00 00                	add    %al,(%rax)
    222b:	3c b5                	cmp    $0xb5,%al
    222d:	01 54 0d 00          	add    %edx,0x0(%rbp,%rcx,1)
    2231:	00 3c b7             	add    %bh,(%rdi,%rsi,4)
    2234:	01 5d 0d             	add    %ebx,0xd(%rbp)
    2237:	00 00                	add    %al,(%rax)
    2239:	3c bf                	cmp    $0xbf,%al
    223b:	01 66 0d             	add    %esp,0xd(%rsi)
    223e:	00 00                	add    %al,(%rax)
    2240:	3c f2                	cmp    $0xf2,%al
    2242:	01 6f 0d             	add    %ebp,0xd(%rdi)
    2245:	00 00                	add    %al,(%rax)
    2247:	3c 99                	cmp    $0x99,%al
            if (!dst) {
    2249:	03 78 0d             	add    0xd(%rax),%edi
    224c:	00 00                	add    %al,(%rax)
    224e:	39 47 11             	cmp    %eax,0x11(%rdi)
    2251:	00 00                	add    %al,(%rax)
BPF_MAP_OPS_INLINE(void*,
    2253:	01 00                	add    %eax,(%rax)
    2255:	ba 02 0c 3a 0e       	mov    $0xe3a0c02,%edx
    225a:	50                   	push   %rax
    225b:	11 00                	adc    %eax,(%rax)
  if (dst_lru) {
    225d:	00 3a                	add    %bh,(%rdx)
    225f:	0f 62 11             	punpckldq (%rcx),%mm2
    2262:	00 00                	add    %al,(%rax)
    2264:	3a 10                	cmp    (%rax),%dl
    if (dst_lru->pos == pckt->real_index) {
    2266:	7d 11                	jge    2279 <balancer_ingress+0x2279>
    2268:	00 00                	add    %al,(%rax)
    226a:	3a 11                	cmp    (%rcx),%dl
    226c:	86 11                	xchg   %dl,(%rcx)
    226e:	00 00                	add    %al,(%rax)
    2270:	3a 12                	cmp    (%rdx),%dl
              quic_packets_stats->dst_match_in_lru += 1;
    2272:	8f                   	(bad)
    2273:	11 00                	adc    %eax,(%rax)
    2275:	00 3c 13             	add    %bh,(%rbx,%rdx,1)
    2278:	98                   	cwtl
    2279:	11 00                	adc    %eax,(%rax)
    227b:	00 00                	add    %al,(%rax)
    227d:	39 d9                	cmp    %ebx,%ecx
    227f:	12 00                	adc    (%rax),%al
    2281:	00 02                	add    %al,(%rdx)
    2283:	00 bf 02 0c 3a 44    	add    %bh,0x443a0c02(%rdi)
    2289:	e2 12                	loop   229d <balancer_ingress+0x229d>
    228b:	00 00                	add    %al,(%rax)
    228d:	3a 45 eb             	cmp    -0x15(%rbp),%al
    2290:	12 00                	adc    (%rax),%al
    2292:	00 3a                	add    %bh,(%rdx)
    2294:	46 f4                	rex.RX hlt
    2296:	12 00                	adc    (%rax),%al
    2298:	00 3a                	add    %bh,(%rdx)
    229a:	47 fd                	rex.RXB std
    229c:	12 00                	adc    (%rax),%al
      dst_lru->pos = pckt->real_index;
    229e:	00 3a                	add    %bh,(%rdx)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    22a0:	48 06                	rex.W (bad)
    22a2:	13 00                	adc    (%rax),%eax
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    22a4:	00 39                	add    %bh,(%rcx)
    22a6:	b9 11 00 00 03       	mov    $0x3000011,%ecx
    22ab:	0e                   	(bad)
    22ac:	5c                   	pop    %rsp
    22ad:	01 0c 3a             	add    %ecx,(%rdx,%rdi,1)
    22b0:	14 c2                	adc    $0xc2,%al
    22b2:	11 00                	adc    %eax,(%rax)
    22b4:	00 3a                	add    %bh,(%rdx)
    22b6:	15 cb 11 00 00       	adc    $0x11cb,%eax
    22bb:	3a 16                	cmp    (%rsi),%dl
    22bd:	d4                   	(bad)
    22be:	11 00                	adc    %eax,(%rax)
    22c0:	00 3a                	add    %bh,(%rdx)
    22c2:	17                   	(bad)
    22c3:	dd 11                	fstl   (%rcx)
    22c5:	00 00                	add    %al,(%rax)
    22c7:	3c 18                	cmp    $0x18,%al
  if (!per_vip_stats) {
    22c9:	e6 11                	out    %al,$0x11
    22cb:	00 00                	add    %al,(%rax)
    per_vip_stats->v2 += 1;
    22cd:	3c 89                	cmp    $0x89,%al
    22cf:	01 ef                	add    %ebp,%edi
    22d1:	11 00                	adc    %eax,(%rax)
    conn_rate_stats->v1 += 1;
    22d3:	00 3d 10 13 00 00    	add    %bh,0x1310(%rip)        # 35e9 <_license+0x11bc>
    22d9:	15 51 00 00 00       	adc    $0x51,%eax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    22de:	0e                   	(bad)
    22df:	1f                   	(bad)
    22e0:	01 0c 3e             	add    %ecx,(%rsi,%rdi,1)
    22e3:	01 53 18             	add    %edx,0x18(%rbx)
  struct real_pos_lru new_dst_lru = {};
    22e6:	13 00                	adc    (%rax),%eax
    22e8:	00 3e                	add    %bh,(%rsi)
    22ea:	01 5c 20 13          	add    %ebx,0x13(%rax,%riz,1)
    22ee:	00 00                	add    %al,(%rax)
    22f0:	3c 19                	cmp    $0x19,%al
    22f2:	28 13                	sub    %dl,(%rbx)
    22f4:	00 00                	add    %al,(%rax)
    22f6:	3f                   	(bad)
  new_dst_lru.pos = pckt->real_index;
    22f7:	00 30                	add    %dh,(%rax)
    22f9:	13 00                	adc    (%rax),%eax
    22fb:	00 3f                	add    %bh,(%rdi)
    22fd:	22 38                	and    (%rax),%bh
    22ff:	13 00                	adc    (%rax),%eax
    2301:	00 3b                	add    %bh,(%rbx)
    2303:	01 5e 40             	add    %ebx,0x40(%rsi)
BPF_MAP_OPS_INLINE(int,
    2306:	13 00                	adc    (%rax),%eax
    2308:	00 40 51             	add    %al,0x51(%rax)
    230b:	13 00                	adc    (%rax),%eax
    230d:	00 16                	add    %dl,(%rsi)
    230f:	38 00                	cmp    %al,(%rax)
    2311:	00 00                	add    %al,(%rax)
    2313:	0e                   	(bad)
    2314:	59                   	pop    %rcx
    2315:	03 3c 1b             	add    (%rbx,%rbx,1),%edi
              quic_packets_stats->dst_not_found_in_lru += 1;
    2318:	65 13 00             	adc    %gs:(%rax),%eax
    231b:	00 41 16             	add    %al,0x16(%rcx)
    231e:	38 00                	cmp    %al,(%rax)
    2320:	00 00                	add    %al,(%rax)
            quic_packets_stats->cid_routed += 1;
    2322:	3c 1a                	cmp    $0x1a,%al
    2324:	6e                   	outsb  %ds:(%rsi),(%dx)
    2325:	13 00                	adc    (%rax),%eax
  original_sport = pckt.flow.port16[0];
    2327:	00 00                	add    %al,(%rax)
    2329:	00 00                	add    %al,(%rax)
    232b:	41 17                	rex.B (bad)
    232d:	28 00                	sub    %al,(%rax)
    232f:	00 00                	add    %al,(%rax)
    2331:	3f                   	(bad)
    2332:	8d 04 f9             	lea    (%rcx,%rdi,8),%eax
    2335:	11 00                	adc    %eax,(%rax)
    2337:	00 3c 88             	add    %bh,(%rax,%rcx,4)
    233a:	01 02                	add    %eax,(%rdx)
    233c:	12 00                	adc    (%rax),%al
    233e:	00 41 17             	add    %al,0x17(%rcx)
    2341:	10 00                	adc    %al,(%rax)
    2343:	00 00                	add    %al,(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2345:	3c 87                	cmp    $0x87,%al
    2347:	01 15 12 00 00 42    	add    %edx,0x42000012(%rip)        # 4200235f <_license+0x41ffff32>
    234d:	06                   	(bad)
    234e:	1e                   	(bad)
    234f:	12 00                	adc    (%rax),%al
    2351:	00 41 17             	add    %al,0x17(%rcx)
    2354:	10 00                	adc    %al,(%rax)
    2356:	00 00                	add    %al,(%rax)
    2358:	3f                   	(bad)
    2359:	8d 04 28             	lea    (%rax,%rbp,1),%eax
    235c:	12 00                	adc    (%rax),%al
  if (!conn_rate_stats) {
    235e:	00 3f                	add    %bh,(%rdi)
    2360:	80 08 31             	orb    $0x31,(%rax)
    2363:	12 00                	adc    (%rax),%al
    2365:	00 3f                	add    %bh,(%rdi)
    2367:	08 3a                	or     %bh,(%rdx)
    2369:	12 00                	adc    (%rax),%al
    236b:	00 00                	add    %al,(%rax)
    236d:	00 00                	add    %al,(%rax)
  *cur_time = bpf_ktime_get_ns();
    236f:	00 39                	add    %bh,(%rcx)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    2371:	78 13                	js     2386 <balancer_ingress+0x2386>
    2373:	00 00                	add    %al,(%rax)
    2375:	04 0e                	add    $0xe,%al
    2377:	5a                   	pop    %rdx
    2378:	01 0c 3a             	add    %ecx,(%rdx,%rdi,1)
    237b:	49 80 13 00          	rex.WB adcb $0x0,(%r11)
    237f:	00 3a                	add    %bh,(%rdx)
    conn_rate_stats->v1 = 1;
    2381:	4a 88 13             	rex.WX mov %dl,(%rbx)
    2384:	00 00                	add    %al,(%rax)
    2386:	3a 4b 90             	cmp    -0x70(%rbx),%cl
    conn_rate_stats->v2 = *cur_time;
    2389:	13 00                	adc    (%rax),%eax
    238b:	00 3a                	add    %bh,(%rdx)
      dst_lru->pos = pckt->real_index;
    238d:	4c 98                	rex.WR cltq
              quic_packets_stats->dst_mismatch_in_lru += 1;
    238f:	13 00                	adc    (%rax),%eax
    2391:	00 3c 4d a0 13 00 00 	add    %bh,0x13a0(,%rcx,2)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2398:	3c 9f                	cmp    $0x9f,%al
    239a:	01 a8 13 00 00 40    	add    %ebp,0x40000013(%rax)
    23a0:	6f                   	outsl  %ds:(%rsi),(%dx)
    23a1:	16                   	(bad)
    23a2:	00 00                	add    %al,(%rax)
    23a4:	18 17                	sbb    %dl,(%rdi)
    23a6:	00 00                	add    %al,(%rax)
    23a8:	00 0e                	add    %cl,(%rsi)
    23aa:	f0 0c 3e             	lock or $0x3e,%al
    23ad:	01 53 78             	add    %edx,0x78(%rbx)
    23b0:	16                   	(bad)
    23b1:	00 00                	add    %al,(%rax)
    23b3:	3e 01 5c 80 16       	ds add %ebx,0x16(%rax,%rax,4)
    23b8:	00 00                	add    %al,(%rax)
    23ba:	3b 03                	cmp    (%rbx),%eax
    23bc:	91                   	xchg   %eax,%ecx
    23bd:	c0 00 88             	rolb   $0x88,(%rax)
    23c0:	16                   	(bad)
    23c1:	00 00                	add    %al,(%rax)
    23c3:	3f                   	(bad)
  if (!per_vip_stats) {
    23c4:	00 90 16 00 00 00    	add    %dl,0x16(%rax)
    per_vip_stats->v2 += 1;
    23ca:	41 19 2f             	sbb    %ebp,(%r15)
    23cd:	00 00                	add    %al,(%rax)
    conn_rate_stats->v1 += 1;
    23cf:	00 3f                	add    %bh,(%rdi)
    23d1:	8c 04 b1             	mov    %es,(%rcx,%rsi,4)
    23d4:	13 00                	adc    (%rax),%eax
    23d6:	00 3c 9d 01 b9 13 00 	add    %bh,0x13b901(,%rbx,4)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    23dd:	00 3c 9e             	add    %bh,(%rsi,%rbx,4)
    23e0:	01 c2                	add    %eax,%edx
  struct real_pos_lru new_dst_lru = {};
    23e2:	13 00                	adc    (%rax),%eax
    23e4:	00 41 19             	add    %al,0x19(%rcx)
    23e7:	10 00                	adc    %al,(%rax)
    23e9:	00 00                	add    %al,(%rax)
    23eb:	3c 9c                	cmp    $0x9c,%al
    23ed:	01 cb                	add    %ecx,%ebx
    23ef:	13 00                	adc    (%rax),%eax
    23f1:	00 42 06             	add    %al,0x6(%rdx)
  new_dst_lru.pos = pckt->real_index;
    23f4:	d3 13                	rcll   %cl,(%rbx)
    23f6:	00 00                	add    %al,(%rax)
    23f8:	41 19 10             	sbb    %edx,(%r8)
    23fb:	00 00                	add    %al,(%rax)
    23fd:	00 3f                	add    %bh,(%rdi)
    23ff:	8c 04 dc             	mov    %es,(%rsp,%rbx,8)
    2402:	13 00                	adc    (%rax),%eax
    2404:	00 3f                	add    %bh,(%rdi)
    2406:	80 08 e4             	orb    $0xe4,(%rax)
    2409:	13 00                	adc    (%rax),%eax
    240b:	00 3f                	add    %bh,(%rdi)
    240d:	08 ec                	or     %ch,%ah
    240f:	13 00                	adc    (%rax),%eax
    2411:	00 00                	add    %al,(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    2413:	00 00                	add    %al,(%rax)
    2415:	00 00                	add    %al,(%rax)
    2417:	3d 2a 15 00 00       	cmp    $0x152a,%eax
    241c:	1a 2a                	sbb    (%rdx),%ch
            quic_packets_stats->cid_routed += 1;
    241e:	00 00                	add    %al,(%rax)
    2420:	00 00                	add    %al,(%rax)
  original_sport = pckt.flow.port16[0];
    2422:	f3 02 0a             	repz add (%rdx),%cl
    2425:	3e 01 53 33          	ds add %edx,0x33(%rbx)
    2429:	15 00 00 3e 01       	adc    $0x13e0000,%eax
    242e:	5c                   	pop    %rsp
    242f:	3b 15 00 00 3e 02    	cmp    0x23e0000(%rip),%edx        # 23e2435 <_license+0x23e0008>
    2435:	30 9f 43 15 00 00    	xor    %bl,0x1543(%rdi)
    243b:	3e 03 91 10 9f 4b 15 	ds add 0x154b9f10(%rcx),%edx
    2442:	00 00                	add    %al,(%rax)
    2444:	3b 11                	cmp    (%rcx),%edx
    2446:	72 00                	jb     2448 <_license+0x1b>
    2448:	10 ff                	adc    %bh,%bh
    244a:	01 1a                	add    %ebx,(%rdx)
    244c:	a8 ba                	test   $0xba,%al
    244e:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    2455:	00 9f 53 15 00 00    	add    %bl,0x1553(%rdi)
    245b:	3c 4e                	cmp    $0x4e,%al
    245d:	5b                   	pop    %rbx
    245e:	15 00 00 40 4d       	adc    $0x4d400000,%eax
    2463:	16                   	(bad)
    2464:	00 00                	add    %al,(%rax)
    2466:	1b 02                	sbb    (%rdx),%eax
    2468:	00 00                	add    %al,(%rax)
    246a:	00 0c 7b             	add    %cl,(%rbx,%rdi,2)
    246d:	0f 3e                	(bad)
    246f:	02 30                	add    (%rax),%dh
    2471:	9f                   	lahf
    2472:	56                   	push   %rsi
    2473:	16                   	(bad)
    2474:	00 00                	add    %al,(%rax)
    2476:	3e 11 72 00          	ds adc %esi,0x0(%rdx)
    247a:	10 ff                	adc    %bh,%bh
    247c:	01 1a                	add    %ebx,(%rdx)
    247e:	a8 ba                	test   $0xba,%al
    2480:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    2487:	00 9f 5e 16 00 00    	add    %bl,0x165e(%rdi)
    248d:	00 00                	add    %al,(%rax)
    248f:	3d 0f 19 00 00       	cmp    $0x190f,%eax
    2494:	1c 17                	sbb    $0x17,%al
    2496:	00 00                	add    %al,(%rax)
    2498:	00 00                	add    %al,(%rax)
    249a:	f7 02 0a 3e 01 53    	testl  $0x53013e0a,(%rdx)
    24a0:	18 19                	sbb    %bl,(%rcx)
    24a2:	00 00                	add    %al,(%rax)
    24a4:	3e 01 5c 20 19       	ds add %ebx,0x19(%rax,%riz,1)
    24a9:	00 00                	add    %al,(%rax)
    24ab:	3e 02 30             	ds add (%rax),%dh
    24ae:	9f                   	lahf
    24af:	28 19                	sub    %bl,(%rcx)
    24b1:	00 00                	add    %al,(%rax)
    24b3:	3e 03 91 10 9f 30 19 	ds add 0x19309f10(%rcx),%edx
    24ba:	00 00                	add    %al,(%rax)
    24bc:	3b 11                	cmp    (%rcx),%edx
    24be:	72 00                	jb     24c0 <_license+0x93>
    24c0:	10 ff                	adc    %bh,%bh
    24c2:	01 1a                	add    %ebx,(%rdx)
    24c4:	a8 ba                	test   $0xba,%al
    24c6:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    24cd:	00 9f 38 19 00 00    	add    %bl,0x1938(%rdi)
    24d3:	3c af                	cmp    $0xaf,%al
    24d5:	01 40 19             	add    %eax,0x19(%rax)
    24d8:	00 00                	add    %al,(%rax)
    24da:	40                   	rex
    24db:	4d 16                	rex.WRB (bad)
    24dd:	00 00                	add    %al,(%rax)
    24df:	1d 02 00 00 00       	sbb    $0x2,%eax
    24e4:	0c 61                	or     $0x61,%al
    24e6:	0f 3e                	(bad)
    24e8:	02 30                	add    (%rax),%dh
    24ea:	9f                   	lahf
    24eb:	56                   	push   %rsi
    24ec:	16                   	(bad)
    24ed:	00 00                	add    %al,(%rax)
    24ef:	3e 11 72 00          	ds adc %esi,0x0(%rdx)
    24f3:	10 ff                	adc    %bh,%bh
    24f5:	01 1a                	add    %ebx,(%rdx)
    24f7:	a8 ba                	test   $0xba,%al
    24f9:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    2500:	00 9f 5e 16 00 00    	add    %bl,0x165e(%rdi)
    2506:	00 00                	add    %al,(%rax)
    2508:	43 05 3c 8b 01 a8    	rex.XB add $0xa8018b3c,%eax
    250e:	0d 00 00 39 a9       	or     $0xa9390000,%eax
    2513:	16                   	(bad)
    2514:	00 00                	add    %al,(%rax)
    2516:	06                   	(bad)
    2517:	00 e1                	add    %ah,%cl
    2519:	02 0e                	add    (%rsi),%cl
    251b:	3a 8c 01 b2 16 00 00 	cmp    0x16b2(%rcx,%rax,1),%cl
    2522:	3a 8d 01 ba 16 00    	cmp    0x16ba01(%rbp),%cl
    2528:	00 3b                	add    %bh,(%rbx)
    252a:	03 91 c0 00 ca 16    	add    0x16ca00c0(%rcx),%edx
    2530:	00 00                	add    %al,(%rax)
    2532:	3c 91                	cmp    $0x91,%al
    2534:	01 d3                	add    %edx,%ebx
    2536:	16                   	(bad)
    2537:	00 00                	add    %al,(%rax)
    2539:	3c 93                	cmp    $0x93,%al
    253b:	01 dc                	add    %ebx,%esp
    253d:	16                   	(bad)
    253e:	00 00                	add    %al,(%rax)
    2540:	41 1e                	rex.B (bad)
    2542:	18 00                	sbb    %al,(%rax)
    2544:	00 00                	add    %al,(%rax)
    2546:	3c 8e                	cmp    $0x8e,%al
    2548:	01 e5                	add    %esp,%ebp
    254a:	16                   	(bad)
    254b:	00 00                	add    %al,(%rax)
    254d:	42 01 ed             	rex.X add %ebp,%ebp
    2550:	16                   	(bad)
    2551:	00 00                	add    %al,(%rax)
    2553:	40 32 17             	rex xor (%rdi),%dl
    2556:	00 00                	add    %al,(%rax)
    2558:	1e                   	(bad)
    2559:	18 00                	sbb    %al,(%rax)
    255b:	00 00                	add    %al,(%rax)
    255d:	00 d5                	add    %dl,%ch
    255f:	1c 3a                	sbb    $0x3a,%al
    2561:	8f 01                	pop    (%rcx)
    2563:	3c 17                	cmp    $0x17,%al
    2565:	00 00                	add    %al,(%rax)
    2567:	3a 90 01 46 17 00    	cmp    0x174601(%rax),%dl
    256d:	00 00                	add    %al,(%rax)
    256f:	00 41 1f             	add    %al,0x1f(%rcx)
    2572:	1d 00 00 00 3f       	sbb    $0x3f000000,%eax
    2577:	86 04 f7             	xchg   %al,(%rdi,%rsi,8)
    257a:	16                   	(bad)
    257b:	00 00                	add    %al,(%rax)
    257d:	41 1f                	rex.B (bad)
    257f:	10 00                	adc    %al,(%rax)
    2581:	00 00                	add    %al,(%rax)
    2583:	3c 92                	cmp    $0x92,%al
    2585:	01 00                	add    %eax,(%rax)
    2587:	17                   	(bad)
    2588:	00 00                	add    %al,(%rax)
    258a:	42 06                	rex.X (bad)
    258c:	08 17                	or     %dl,(%rdi)
    258e:	00 00                	add    %al,(%rax)
    2590:	41 1f                	rex.B (bad)
    2592:	10 00                	adc    %al,(%rax)
    2594:	00 00                	add    %al,(%rax)
    2596:	3f                   	(bad)
    2597:	86 04 11             	xchg   %al,(%rcx,%rdx,1)
    259a:	17                   	(bad)
    259b:	00 00                	add    %al,(%rax)
    259d:	3f                   	(bad)
    259e:	80 08 19             	orb    $0x19,(%rax)
    25a1:	17                   	(bad)
    25a2:	00 00                	add    %al,(%rax)
    25a4:	3f                   	(bad)
    25a5:	08 21                	or     %ah,(%rcx)
    25a7:	17                   	(bad)
    25a8:	00 00                	add    %al,(%rax)
    25aa:	00 00                	add    %al,(%rax)
    25ac:	00 00                	add    %al,(%rax)
    25ae:	39 95 17 00 00 07    	cmp    %edx,0x7000017(%rbp)
    25b4:	00 e5                	add    %ah,%ch
    25b6:	02 0c 3e             	add    (%rsi,%rdi,1),%cl
    25b9:	01 5d b1             	add    %ebx,-0x4f(%rbp)
    25bc:	17                   	(bad)
    25bd:	00 00                	add    %al,(%rax)
    25bf:	3c 95                	cmp    $0x95,%al
    25c1:	01 d5                	add    %edx,%ebp
    25c3:	17                   	(bad)
    25c4:	00 00                	add    %al,(%rax)
    25c6:	3c 97                	cmp    $0x97,%al
    25c8:	01 de                	add    %ebx,%esi
    25ca:	17                   	(bad)
    25cb:	00 00                	add    %al,(%rax)
    25cd:	3c 99                	cmp    $0x99,%al
    25cf:	01 e7                	add    %esp,%edi
    25d1:	17                   	(bad)
    25d2:	00 00                	add    %al,(%rax)
    25d4:	41 20 73 00          	and    %sil,0x0(%r11)
    25d8:	00 00                	add    %al,(%rax)
    25da:	42 22 09             	rex.X and (%rcx),%cl
    25dd:	18 00                	sbb    %al,(%rax)
    25df:	00 3d 50 17 00 00    	add    %bh,0x1750(%rip)        # 3d35 <_license+0x1908>
    25e5:	20 3a                	and    %bh,(%rdx)
    25e7:	00 00                	add    %al,(%rax)
    25e9:	00 00                	add    %al,(%rax)
    25eb:	45 01 10             	add    %r10d,(%r8)
    25ee:	3e 01 53 59          	ds add %edx,0x59(%rbx)
    25f2:	17                   	(bad)
    25f3:	00 00                	add    %al,(%rax)
    25f5:	3e 01 5c 61 17       	ds add %ebx,0x17(%rcx,%riz,2)
    25fa:	00 00                	add    %al,(%rax)
    25fc:	44 22 69 17          	and    0x17(%rcx),%r13b
    2600:	00 00                	add    %al,(%rax)
    2602:	3e 02 30             	ds add (%rax),%dh
    2605:	9f                   	lahf
    2606:	72 17                	jb     261f <_license+0x1f2>
    2608:	00 00                	add    %al,(%rax)
    260a:	41 20 3a             	and    %dil,(%r10)
    260d:	00 00                	add    %al,(%rax)
    260f:	00 3c 94             	add    %bh,(%rsp,%rdx,4)
    2612:	01 8b 17 00 00 00    	add    %ecx,0x17(%rbx)
    2618:	00 3d 85 19 00 00    	add    %bh,0x1985(%rip)        # 3fa3 <_license+0x1b76>
    261e:	21 39                	and    %edi,(%rcx)
    2620:	00 00                	add    %al,(%rax)
    2622:	00 00                	add    %al,(%rax)
    2624:	46 01 0c 3e          	add    %r9d,(%rsi,%r15,1)
    2628:	01 5d 8e             	add    %ebx,-0x72(%rbp)
    262b:	19 00                	sbb    %eax,(%rax)
    262d:	00 3b                	add    %bh,(%rbx)
    262f:	01 53 a6             	add    %edx,-0x5a(%rbx)
    2632:	19 00                	sbb    %eax,(%rax)
    2634:	00 3c 96             	add    %bh,(%rsi,%rdx,4)
    2637:	01 af 19 00 00 00    	add    %ebp,0x19(%rdi)
    263d:	00 41 22             	add    %al,0x22(%rcx)
    2640:	10 00                	adc    %al,(%rax)
    2642:	00 00                	add    %al,(%rax)
    2644:	3c 98                	cmp    $0x98,%al
    2646:	01 15 18 00 00 42    	add    %edx,0x42000018(%rip)        # 42002664 <_license+0x42000237>
    264c:	06                   	(bad)
    264d:	1e                   	(bad)
    264e:	18 00                	sbb    %al,(%rax)
    2650:	00 41 22             	add    %al,0x22(%rcx)
    2653:	10 00                	adc    %al,(%rax)
    2655:	00 00                	add    %al,(%rax)
    2657:	3f                   	(bad)
    2658:	8a 04 28             	mov    (%rax,%rbp,1),%al
    265b:	18 00                	sbb    %al,(%rax)
    265d:	00 3f                	add    %bh,(%rdi)
    265f:	80 08 31             	orb    $0x31,(%rax)
    2662:	18 00                	sbb    %al,(%rax)
    2664:	00 3f                	add    %bh,(%rdi)
    2666:	08 3a                	or     %bh,(%rdx)
    2668:	18 00                	sbb    %al,(%rax)
    266a:	00 00                	add    %al,(%rax)
    266c:	00 41 23             	add    %al,0x23(%rcx)
    266f:	15 00 00 00 3f       	adc    $0x3f000000,%eax
    2674:	8e 04 46             	mov    (%rsi,%rax,2),%es
    2677:	18 00                	sbb    %al,(%rax)
    2679:	00 3c 9b             	add    %bh,(%rbx,%rbx,4)
    267c:	01 50 18             	add    %edx,0x18(%rax)
    267f:	00 00                	add    %al,(%rax)
    2681:	41 23 10             	and    (%r8),%edx
    2684:	00 00                	add    %al,(%rax)
    2686:	00 3c 9a             	add    %bh,(%rdx,%rbx,4)
    2689:	01 65 18             	add    %esp,0x18(%rbp)
    268c:	00 00                	add    %al,(%rax)
    268e:	42 06                	rex.X (bad)
    2690:	6e                   	outsb  %ds:(%rsi),(%dx)
    2691:	18 00                	sbb    %al,(%rax)
    2693:	00 41 23             	add    %al,0x23(%rcx)
    2696:	10 00                	adc    %al,(%rax)
    2698:	00 00                	add    %al,(%rax)
    269a:	3f                   	(bad)
    269b:	8e 04 78             	mov    (%rax,%rdi,2),%es
    269e:	18 00                	sbb    %al,(%rax)
    26a0:	00 3f                	add    %bh,(%rdi)
    26a2:	80 08 81             	orb    $0x81,(%rax)
    26a5:	18 00                	sbb    %al,(%rax)
    26a7:	00 3f                	add    %bh,(%rdi)
    26a9:	08 8a 18 00 00 00    	or     %cl,0x18(%rdx)
    26af:	00 00                	add    %al,(%rax)
    26b1:	00 00                	add    %al,(%rax)
    26b3:	41 24 34             	rex.B and $0x34,%al
    26b6:	01 00                	add    %eax,(%rax)
    26b8:	00 3c a0             	add    %bh,(%rax,%riz,4)
    26bb:	01 9d 0d 00 00 39    	add    %ebx,0x3900000d(%rbp)
    26c1:	a9 16 00 00 08       	test   $0x8000016,%eax
    26c6:	00 e9                	add    %ch,%cl
    26c8:	02 0e                	add    (%rsi),%cl
    26ca:	3a a1 01 b2 16 00    	cmp    0x16b201(%rcx),%ah
    26d0:	00 3a                	add    %bh,(%rdx)
    26d2:	a2 01 ba 16 00 00 3b 	movabs %al,0x91033b000016ba01
    26d9:	03 91 
    26db:	c0 00 ca             	rolb   $0xca,(%rax)
    26de:	16                   	(bad)
    26df:	00 00                	add    %al,(%rax)
    26e1:	3c a6                	cmp    $0xa6,%al
    26e3:	01 d3                	add    %edx,%ebx
    26e5:	16                   	(bad)
    26e6:	00 00                	add    %al,(%rax)
    26e8:	3c a8                	cmp    $0xa8,%al
    26ea:	01 dc                	add    %ebx,%esp
    26ec:	16                   	(bad)
    26ed:	00 00                	add    %al,(%rax)
    26ef:	41 25 18 00 00 00    	rex.B and $0x18,%eax
    26f5:	3c a3                	cmp    $0xa3,%al
    26f7:	01 e5                	add    %esp,%ebp
    26f9:	16                   	(bad)
    26fa:	00 00                	add    %al,(%rax)
    26fc:	42 01 ed             	rex.X add %ebp,%ebp
    26ff:	16                   	(bad)
    2700:	00 00                	add    %al,(%rax)
    2702:	40 32 17             	rex xor (%rdi),%dl
    2705:	00 00                	add    %al,(%rax)
    2707:	25 18 00 00 00       	and    $0x18,%eax
    270c:	00 d5                	add    %dl,%ch
    270e:	1c 3a                	sbb    $0x3a,%al
    2710:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    2711:	01 3c 17             	add    %edi,(%rdi,%rdx,1)
    2714:	00 00                	add    %al,(%rax)
    2716:	3a a5 01 46 17 00    	cmp    0x174601(%rbp),%ah
    271c:	00 00                	add    %al,(%rax)
    271e:	00 41 26             	add    %al,0x26(%rcx)
    2721:	1d 00 00 00 3f       	sbb    $0x3f000000,%eax
    2726:	86 04 f7             	xchg   %al,(%rdi,%rsi,8)
    2729:	16                   	(bad)
    272a:	00 00                	add    %al,(%rax)
    272c:	41                   	rex.B
    272d:	26 10 00             	es adc %al,(%rax)
    2730:	00 00                	add    %al,(%rax)
    2732:	3c a7                	cmp    $0xa7,%al
    2734:	01 00                	add    %eax,(%rax)
    2736:	17                   	(bad)
    2737:	00 00                	add    %al,(%rax)
    2739:	42 06                	rex.X (bad)
    273b:	08 17                	or     %dl,(%rdi)
    273d:	00 00                	add    %al,(%rax)
    273f:	41                   	rex.B
    2740:	26 10 00             	es adc %al,(%rax)
    2743:	00 00                	add    %al,(%rax)
    2745:	3f                   	(bad)
    2746:	86 04 11             	xchg   %al,(%rcx,%rdx,1)
    2749:	17                   	(bad)
    274a:	00 00                	add    %al,(%rax)
    274c:	3f                   	(bad)
    274d:	80 08 19             	orb    $0x19,(%rax)
    2750:	17                   	(bad)
    2751:	00 00                	add    %al,(%rax)
    2753:	3f                   	(bad)
    2754:	08 21                	or     %ah,(%rcx)
    2756:	17                   	(bad)
    2757:	00 00                	add    %al,(%rax)
    2759:	00 00                	add    %al,(%rax)
    275b:	00 00                	add    %al,(%rax)
    275d:	39 95 17 00 00 09    	cmp    %edx,0x9000017(%rbp)
    2763:	00 ed                	add    %ch,%ch
    2765:	02 0c 3e             	add    (%rsi,%rdi,1),%cl
    2768:	01 5d b1             	add    %ebx,-0x4f(%rbp)
    276b:	17                   	(bad)
    276c:	00 00                	add    %al,(%rax)
    276e:	3c a9                	cmp    $0xa9,%al
    2770:	01 d5                	add    %edx,%ebp
    2772:	17                   	(bad)
    2773:	00 00                	add    %al,(%rax)
    2775:	3c aa                	cmp    $0xaa,%al
    2777:	01 de                	add    %ebx,%esi
    2779:	17                   	(bad)
    277a:	00 00                	add    %al,(%rax)
    277c:	3c ac                	cmp    $0xac,%al
    277e:	01 e7                	add    %esp,%edi
    2780:	17                   	(bad)
    2781:	00 00                	add    %al,(%rax)
    2783:	41 27                	rex.B (bad)
    2785:	73 00                	jae    2787 <_license+0x35a>
    2787:	00 00                	add    %al,(%rax)
    2789:	42                   	rex.X
    278a:	36 f1                	ss int1
    278c:	17                   	(bad)
    278d:	00 00                	add    %al,(%rax)
    278f:	3d 50 17 00 00       	cmp    $0x1750,%eax
    2794:	28 27                	sub    %ah,(%rdi)
    2796:	00 00                	add    %al,(%rax)
    2798:	00 00                	add    %al,(%rax)
    279a:	4f 01 0e             	rex.WRXB add %r9,(%r14)
    279d:	3e 01 53 59          	ds add %edx,0x59(%rbx)
    27a1:	17                   	(bad)
    27a2:	00 00                	add    %al,(%rax)
    27a4:	3e 01 5c 61 17       	ds add %ebx,0x17(%rcx,%riz,2)
    27a9:	00 00                	add    %al,(%rax)
    27ab:	44                   	rex.R
    27ac:	36 69 17 00 00 3e 02 	ss imul $0x23e0000,(%rdi),%edx
    27b3:	31 9f 72 17 00 00    	xor    %ebx,0x1772(%rdi)
    27b9:	45 7a 17             	rex.RB jp 27d3 <_license+0x3a6>
    27bc:	00 00                	add    %al,(%rax)
    27be:	00 3d 9c 18 00 00    	add    %bh,0x189c(%rip)        # 4060 <_license+0x1c33>
    27c4:	29 3a                	sub    %edi,(%rdx)
    27c6:	00 00                	add    %al,(%rax)
    27c8:	00 00                	add    %al,(%rax)
    27ca:	50                   	push   %rax
    27cb:	01 0a                	add    %ecx,(%rdx)
    27cd:	3e 01 5d a5          	ds add %ebx,-0x5b(%rbp)
    27d1:	18 00                	sbb    %al,(%rax)
    27d3:	00 3e                	add    %bh,(%rsi)
    27d5:	02 30                	add    (%rax),%dh
    27d7:	9f                   	lahf
    27d8:	bd 18 00 00 3b       	mov    $0x3b000018,%ebp
    27dd:	01 53 c6             	add    %edx,-0x3a(%rbx)
    27e0:	18 00                	sbb    %al,(%rax)
    27e2:	00 3b                	add    %bh,(%rbx)
    27e4:	03 73 28             	add    0x28(%rbx),%esi
    27e7:	9f                   	lahf
    27e8:	cf                   	iret
    27e9:	18 00                	sbb    %al,(%rax)
    27eb:	00 00                	add    %al,(%rax)
    27ed:	00 41 2a             	add    %al,0x2a(%rcx)
    27f0:	10 00                	adc    %al,(%rax)
    27f2:	00 00                	add    %al,(%rax)
    27f4:	3c ab                	cmp    $0xab,%al
    27f6:	01 15 18 00 00 42    	add    %edx,0x42000018(%rip)        # 42002814 <_license+0x420003e7>
    27fc:	06                   	(bad)
    27fd:	1e                   	(bad)
    27fe:	18 00                	sbb    %al,(%rax)
    2800:	00 41 2a             	add    %al,0x2a(%rcx)
    2803:	10 00                	adc    %al,(%rax)
    2805:	00 00                	add    %al,(%rax)
    2807:	3f                   	(bad)
    2808:	8a 04 28             	mov    (%rax,%rbp,1),%al
    280b:	18 00                	sbb    %al,(%rax)
    280d:	00 3f                	add    %bh,(%rdi)
    280f:	80 08 31             	orb    $0x31,(%rax)
    2812:	18 00                	sbb    %al,(%rax)
    2814:	00 3f                	add    %bh,(%rdi)
    2816:	08 3a                	or     %bh,(%rdx)
    2818:	18 00                	sbb    %al,(%rax)
    281a:	00 00                	add    %al,(%rax)
    281c:	00 41 2b             	add    %al,0x2b(%rcx)
    281f:	1e                   	(bad)
    2820:	00 00                	add    %al,(%rax)
    2822:	00 3f                	add    %bh,(%rdi)
    2824:	8e 04 46             	mov    (%rsi,%rax,2),%es
    2827:	18 00                	sbb    %al,(%rax)
    2829:	00 3c ae             	add    %bh,(%rsi,%rbp,4)
    282c:	01 50 18             	add    %edx,0x18(%rax)
    282f:	00 00                	add    %al,(%rax)
    2831:	41 2b 10             	sub    (%r8),%edx
    2834:	00 00                	add    %al,(%rax)
    2836:	00 3c ad 01 65 18 00 	add    %bh,0x186501(,%rbp,4)
    283d:	00 42 06             	add    %al,0x6(%rdx)
    2840:	6e                   	outsb  %ds:(%rsi),(%dx)
    2841:	18 00                	sbb    %al,(%rax)
    2843:	00 41 2b             	add    %al,0x2b(%rcx)
    2846:	10 00                	adc    %al,(%rax)
    2848:	00 00                	add    %al,(%rax)
    284a:	3f                   	(bad)
    284b:	8e 04 78             	mov    (%rax,%rdi,2),%es
    284e:	18 00                	sbb    %al,(%rax)
    2850:	00 3f                	add    %bh,(%rdi)
    2852:	80 08 81             	orb    $0x81,(%rax)
    2855:	18 00                	sbb    %al,(%rax)
    2857:	00 3f                	add    %bh,(%rdi)
    2859:	08 8a 18 00 00 00    	or     %cl,0x18(%rdx)
    285f:	00 00                	add    %al,(%rax)
    2861:	00 00                	add    %al,(%rax)
    2863:	41 2c 1b             	rex.B sub $0x1b,%al
    2866:	00 00                	add    %al,(%rax)
    2868:	00 3c b0             	add    %bh,(%rax,%rsi,4)
    286b:	01 b3 0d 00 00 42    	add    %esi,0x4200000d(%rbx)
    2871:	01 bc 0d 00 00 3d 32 	add    %edi,0x323d0000(%rbp,%rcx,1)
    2878:	17                   	(bad)
    2879:	00 00                	add    %al,(%rax)
    287b:	2c 1b                	sub    $0x1b,%al
    287d:	00 00                	add    %al,(%rax)
    287f:	00 00                	add    %al,(%rax)
    2881:	12 03                	adc    (%rbx),%al
    2883:	0e                   	(bad)
    2884:	3a b1 01 3c 17 00    	cmp    0x173c01(%rcx),%dh
    288a:	00 00                	add    %al,(%rax)
    288c:	00 41 2d             	add    %al,0x2d(%rcx)
    288f:	0e                   	(bad)
    2890:	00 00                	add    %al,(%rax)
    2892:	00 3c ca             	add    %bh,(%rdx,%rcx,8)
    2895:	01 c7                	add    %eax,%edi
    2897:	0d 00 00 42 01       	or     $0x1420000,%eax
    289c:	d0 0d 00 00 46 32    	rorb   0x32460000(%rip)        # 324628a2 <_license+0x32460475>
    28a2:	17                   	(bad)
    28a3:	00 00                	add    %al,(%rax)
    28a5:	2d 0e 00 00 00       	sub    $0xe,%eax
    28aa:	00 15 03 10 00 41    	add    %dl,0x41001003(%rip)        # 410038b3 <_license+0x41001486>
    28b0:	2e 10 00             	cs adc %al,(%rax)
    28b3:	00 00                	add    %al,(%rax)
    28b5:	3c b4                	cmp    $0xb4,%al
    28b7:	01 db                	add    %ebx,%ebx
    28b9:	0d 00 00 42 06       	or     $0x6420000,%eax
    28be:	e4 0d                	in     $0xd,%al
    28c0:	00 00                	add    %al,(%rax)
    28c2:	41                   	rex.B
    28c3:	2e 10 00             	cs adc %al,(%rax)
    28c6:	00 00                	add    %al,(%rax)
    28c8:	3f                   	(bad)
    28c9:	80 04 ee 0d          	addb   $0xd,(%rsi,%rbp,8)
    28cd:	00 00                	add    %al,(%rax)
    28cf:	3f                   	(bad)
    28d0:	80 08 f7             	orb    $0xf7,(%rax)
    28d3:	0d 00 00 3f 08       	or     $0x83f0000,%eax
    28d8:	00 0e                	add    %cl,(%rsi)
    28da:	00 00                	add    %al,(%rax)
    28dc:	00 00                	add    %al,(%rax)
    28de:	41 2f                	rex.B (bad)
    28e0:	0c 00                	or     $0x0,%al
    28e2:	00 00                	add    %al,(%rax)
    28e4:	3c b6                	cmp    $0xb6,%al
    28e6:	01 0c 0e             	add    %ecx,(%rsi,%rcx,1)
    28e9:	00 00                	add    %al,(%rax)
    28eb:	00 43 0a             	add    %al,0xa(%rbx)
    28ee:	3c b9                	cmp    $0xb9,%al
    28f0:	01 17                	add    %edx,(%rdi)
    28f2:	0e                   	(bad)
    28f3:	00 00                	add    %al,(%rax)
    28f5:	3c ba                	cmp    $0xba,%al
    28f7:	01 20                	add    %esp,(%rax)
    28f9:	0e                   	(bad)
    28fa:	00 00                	add    %al,(%rax)
    28fc:	43 0b 3c b8          	or     (%r8,%r15,4),%edi
    2900:	01 2a                	add    %ebp,(%rdx)
    2902:	0e                   	(bad)
    2903:	00 00                	add    %al,(%rax)
    2905:	3c bb                	cmp    $0xbb,%al
    2907:	01 33                	add    %esi,(%rbx)
    2909:	0e                   	(bad)
    290a:	00 00                	add    %al,(%rax)
    290c:	3c bc                	cmp    $0xbc,%al
    290e:	01 3c 0e             	add    %edi,(%rsi,%rcx,1)
    2911:	00 00                	add    %al,(%rax)
    2913:	00 00                	add    %al,(%rax)
    2915:	41 30 31             	xor    %sil,(%r9)
    2918:	00 00                	add    %al,(%rax)
    291a:	00 3f                	add    %bh,(%rdi)
    291c:	83 04 48 0e          	addl   $0xe,(%rax,%rcx,2)
    2920:	00 00                	add    %al,(%rax)
    2922:	3c be                	cmp    $0xbe,%al
    2924:	01 51 0e             	add    %edx,0xe(%rcx)
    2927:	00 00                	add    %al,(%rax)
    2929:	41 30 10             	xor    %dl,(%r8)
    292c:	00 00                	add    %al,(%rax)
    292e:	00 3c bd 01 5b 0e 00 	add    %bh,0xe5b01(,%rdi,4)
    2935:	00 42 06             	add    %al,0x6(%rdx)
    2938:	64 0e                	fs (bad)
    293a:	00 00                	add    %al,(%rax)
    293c:	41 30 10             	xor    %dl,(%r8)
    293f:	00 00                	add    %al,(%rax)
    2941:	00 3f                	add    %bh,(%rdi)
    2943:	83 04 6e 0e          	addl   $0xe,(%rsi,%rbp,2)
    2947:	00 00                	add    %al,(%rax)
    2949:	3f                   	(bad)
    294a:	80 08 77             	orb    $0x77,(%rax)
    294d:	0e                   	(bad)
    294e:	00 00                	add    %al,(%rax)
    2950:	3f                   	(bad)
    2951:	08 80 0e 00 00 00    	or     %al,0xe(%rax)
    2957:	00 00                	add    %al,(%rax)
    2959:	43 0c 3c             	rex.XB or $0x3c,%al
    295c:	cd 01                	int    $0x1
    295e:	97                   	xchg   %eax,%edi
    295f:	0e                   	(bad)
    2960:	00 00                	add    %al,(%rax)
    2962:	3c cf                	cmp    $0xcf,%al
    2964:	01 a0 0e 00 00 3c    	add    %esp,0x3c00000e(%rax)
    296a:	81 03 a9 0e 00 00    	addl   $0xea9,(%rbx)
    2970:	41 31 10             	xor    %edx,(%r8)
    2973:	00 00                	add    %al,(%rax)
    2975:	00 3c ce             	add    %bh,(%rsi,%rcx,8)
    2978:	01 b3 0e 00 00 42    	add    %esi,0x4200000e(%rbx)
    297e:	06                   	(bad)
    297f:	bc 0e 00 00 41       	mov    $0x4100000e,%esp
    2984:	31 10                	xor    %edx,(%rax)
    2986:	00 00                	add    %al,(%rax)
    2988:	00 3f                	add    %bh,(%rdi)
    298a:	00 c6                	add    %al,%dh
    298c:	0e                   	(bad)
    298d:	00 00                	add    %al,(%rax)
    298f:	3f                   	(bad)
    2990:	01 cf                	add    %ecx,%edi
    2992:	0e                   	(bad)
    2993:	00 00                	add    %al,(%rax)
    2995:	3f                   	(bad)
    2996:	08 d8                	or     %bl,%al
    2998:	0e                   	(bad)
    2999:	00 00                	add    %al,(%rax)
    299b:	00 00                	add    %al,(%rax)
    299d:	39 b9 19 00 00 0d    	cmp    %edi,0xd000019(%rcx)
    29a3:	00 6f 03             	add    %ch,0x3(%rdi)
    29a6:	26 3a d0             	es cmp %al,%dl
    29a9:	01 c3                	add    %eax,%ebx
    29ab:	19 00                	sbb    %eax,(%rax)
    29ad:	00 3a                	add    %bh,(%rdx)
    29af:	d1 01                	roll   (%rcx)
    29b1:	cc                   	int3
    29b2:	19 00                	sbb    %eax,(%rax)
    29b4:	00 3a                	add    %bh,(%rdx)
    29b6:	d2 01                	rolb   %cl,(%rcx)
    29b8:	d5                   	(bad)
    29b9:	19 00                	sbb    %eax,(%rax)
    29bb:	00 3c d3             	add    %bh,(%rbx,%rdx,8)
    29be:	01 e7                	add    %esp,%edi
    29c0:	19 00                	sbb    %eax,(%rax)
    29c2:	00 3c dd 01 f1 19 00 	add    %bh,0x19f101(,%rbx,8)
    29c9:	00 3c de             	add    %bh,(%rsi,%rbx,8)
    29cc:	01 fb                	add    %edi,%ebx
    29ce:	19 00                	sbb    %eax,(%rax)
    29d0:	00 3c df             	add    %bh,(%rdi,%rbx,8)
    29d3:	01 05 1a 00 00 3c    	add    %eax,0x3c00001a(%rip)        # 3c0029f3 <_license+0x3c0005c6>
    29d9:	e0 01                	loopne 29dc <_license+0x5af>
    29db:	0f 1a 00             	bndldx (%rax),%bnd0
    29de:	00 43 0e             	add    %al,0xe(%rbx)
    29e1:	3c ab                	cmp    $0xab,%al
    29e3:	02 2c 1a             	add    (%rdx,%rbx,1),%ch
    29e6:	00 00                	add    %al,(%rax)
    29e8:	00 00                	add    %al,(%rax)
    29ea:	3d f0 1a 00 00       	cmp    $0x1af0,%eax
    29ef:	32 47 00             	xor    0x0(%rdi),%al
    29f2:	00 00                	add    %al,(%rax)
    29f4:	00 a1 03 09 3e 02    	add    %ah,0x23e0903(%rcx)
    29fa:	31 9f ff 1a 00 00    	xor    %ebx,0x1aff(%rdi)
    2a00:	3e 02 30             	ds add (%rax),%dh
    2a03:	9f                   	lahf
    2a04:	09 1b                	or     %ebx,(%rbx)
    2a06:	00 00                	add    %al,(%rax)
    2a08:	3c e2                	cmp    $0xe2,%al
    2a0a:	01 13                	add    %edx,(%rbx)
    2a0c:	1b 00                	sbb    (%rax),%eax
    2a0e:	00 41 32             	add    %al,0x32(%rcx)
    2a11:	39 00                	cmp    %eax,(%rax)
    2a13:	00 00                	add    %al,(%rax)
    2a15:	3c e1                	cmp    $0xe1,%al
    2a17:	01 1e                	add    %ebx,(%rsi)
    2a19:	1b 00                	sbb    (%rax),%eax
    2a1b:	00 42 06             	add    %al,0x6(%rdx)
    2a1e:	27                   	(bad)
    2a1f:	1b 00                	sbb    (%rax),%eax
    2a21:	00 41 32             	add    %al,0x32(%rcx)
    2a24:	39 00                	cmp    %eax,(%rax)
    2a26:	00 00                	add    %al,(%rax)
    2a28:	3f                   	(bad)
    2a29:	80 04 31 1b          	addb   $0x1b,(%rcx,%rsi,1)
    2a2d:	00 00                	add    %al,(%rax)
    2a2f:	3f                   	(bad)
    2a30:	08 3a                	or     %bh,(%rdx)
    2a32:	1b 00                	sbb    (%rax),%eax
    2a34:	00 00                	add    %al,(%rax)
    2a36:	00 00                	add    %al,(%rax)
    2a38:	43 0f 3c             	rex.XB (bad)
    2a3b:	87 03                	xchg   %eax,(%rbx)
    2a3d:	e4 0e                	in     $0xe,%al
    2a3f:	00 00                	add    %al,(%rax)
    2a41:	39 b8 1f 00 00 10    	cmp    %edi,0x1000001f(%rax)
    2a47:	00 73 03             	add    %dh,0x3(%rbx)
    2a4a:	09 3a                	or     %edi,(%rdx)
    2a4c:	82                   	(bad)
    2a4d:	03 be 1f 00 00 3a    	add    0x3a00001f(%rsi),%edi
    2a53:	83 03 c7             	addl   $0xffffffc7,(%rbx)
    2a56:	1f                   	(bad)
    2a57:	00 00                	add    %al,(%rax)
    2a59:	00 41 33             	add    %al,0x33(%rcx)
    2a5c:	05 00 00 00 3c       	add    $0x3c000000,%eax
    2a61:	88 03                	mov    %al,(%rbx)
    2a63:	f7 0e 00 00 42 02    	testl  $0x2420000,(%rsi)
    2a69:	00 0f                	add    %cl,(%rdi)
    2a6b:	00 00                	add    %al,(%rax)
    2a6d:	41 33 05 00 00 00 3b 	xor    0x3b000000(%rip),%eax        # 3b002a74 <_license+0x3b000647>
    2a74:	01 50 0a             	add    %edx,0xa(%rax)
    2a77:	0f 00 00             	sldt   (%rax)
    2a7a:	3f                   	(bad)
    2a7b:	fe                   	(bad)
    2a7c:	ff                   	(bad)
    2a7d:	ff 07                	incl   (%rdi)
    2a7f:	13 0f                	adc    (%rdi),%ecx
    2a81:	00 00                	add    %al,(%rax)
    2a83:	3f                   	(bad)
    2a84:	08 1c 0f             	or     %bl,(%rdi,%rcx,1)
    2a87:	00 00                	add    %al,(%rax)
    2a89:	00 00                	add    %al,(%rax)
    2a8b:	43 11 3c 8e          	adc    %edi,(%r14,%r9,4)
    2a8f:	03 28                	add    (%rax),%ebp
    2a91:	0f 00 00             	sldt   (%rax)
    2a94:	41 34 20             	rex.B xor $0x20,%al
    2a97:	00 00                	add    %al,(%rax)
    2a99:	00 3c 89             	add    %bh,(%rcx,%rcx,4)
    2a9c:	03 32                	add    (%rdx),%esi
    2a9e:	0f 00 00             	sldt   (%rax)
    2aa1:	42 02 3b             	rex.X add (%rbx),%dil
    2aa4:	0f 00 00             	sldt   (%rax)
    2aa7:	41 34 20             	rex.B xor $0x20,%al
    2aaa:	00 00                	add    %al,(%rax)
    2aac:	00 3c 8a             	add    %bh,(%rdx,%rcx,4)
    2aaf:	03 45 0f             	add    0xf(%rbp),%eax
    2ab2:	00 00                	add    %al,(%rax)
    2ab4:	3f                   	(bad)
    2ab5:	80 20 4e             	andb   $0x4e,(%rax)
    2ab8:	0f 00 00             	sldt   (%rax)
    2abb:	3f                   	(bad)
    2abc:	18 57 0f             	sbb    %dl,0xf(%rdi)
    2abf:	00 00                	add    %al,(%rax)
    2ac1:	00 00                	add    %al,(%rax)
    2ac3:	39 e3                	cmp    %esp,%ebx
    2ac5:	20 00                	and    %al,(%rax)
    2ac7:	00 12                	add    %dl,(%rdx)
    2ac9:	00 89 03 17 3a 8b    	add    %cl,-0x74c5e8fd(%rcx)
    2acf:	03 ed                	add    %ebp,%ebp
    2ad1:	20 00                	and    %al,(%rax)
    2ad3:	00 3a                	add    %bh,(%rdx)
    2ad5:	8c 03                	mov    %es,(%rbx)
    2ad7:	f6 20                	mulb   (%rax)
    2ad9:	00 00                	add    %al,(%rax)
    2adb:	3b 03                	cmp    (%rbx),%eax
    2add:	91                   	xchg   %eax,%ecx
    2ade:	c0 00 ff             	rolb   $0xff,(%rax)
    2ae1:	20 00                	and    %al,(%rax)
    2ae3:	00 3c 8d 03 09 21 00 	add    %bh,0x210903(,%rcx,4)
    2aea:	00 3d 32 17 00 00    	add    %bh,0x1732(%rip)        # 4222 <_license+0x1df5>
    2af0:	35 0b 00 00 00       	xor    $0xb,%eax
    2af5:	00 6a 02             	add    %ch,0x2(%rdx)
    2af8:	22 3e                	and    (%rsi),%bh
    2afa:	01 55 3c             	add    %edx,0x3c(%rbp)
    2afd:	17                   	(bad)
    2afe:	00 00                	add    %al,(%rax)
    2b00:	00 39                	add    %bh,(%rcx)
    2b02:	fa                   	cli
    2b03:	1b 00                	sbb    (%rax),%eax
    2b05:	00 13                	add    %dl,(%rbx)
    2b07:	00 74 02 07          	add    %dh,0x7(%rdx,%rax,1)
    2b0b:	3c 93                	cmp    $0x93,%al
    2b0d:	03 0c 1c             	add    (%rsp,%rbx,1),%ecx
    2b10:	00 00                	add    %al,(%rax)
    2b12:	3c 95                	cmp    $0x95,%al
    2b14:	03 15 1c 00 00 41    	add    0x4100001c(%rip),%edx        # 41002b36 <_license+0x41000709>
    2b1a:	36 1a 00             	ss sbb (%rax),%al
    2b1d:	00 00                	add    %al,(%rax)
    2b1f:	3c 94                	cmp    $0x94,%al
    2b21:	03 1f                	add    (%rdi),%ebx
    2b23:	1c 00                	sbb    $0x0,%al
    2b25:	00 42 06             	add    %al,0x6(%rdx)
    2b28:	27                   	(bad)
    2b29:	1c 00                	sbb    $0x0,%al
    2b2b:	00 41 36             	add    %al,0x36(%rcx)
    2b2e:	1a 00                	sbb    (%rax),%al
    2b30:	00 00                	add    %al,(%rax)
    2b32:	3f                   	(bad)
    2b33:	82                   	(bad)
    2b34:	04 30                	add    $0x30,%al
    2b36:	1c 00                	sbb    $0x0,%al
    2b38:	00 3f                	add    %bh,(%rdi)
    2b3a:	80 08 38             	orb    $0x38,(%rax)
    2b3d:	1c 00                	sbb    $0x0,%al
    2b3f:	00 3f                	add    %bh,(%rdi)
    2b41:	08 40 1c             	or     %al,0x1c(%rax)
    2b44:	00 00                	add    %al,(%rax)
    2b46:	00 00                	add    %al,(%rax)
    2b48:	00 3d d1 1f 00 00    	add    %bh,0x1fd1(%rip)        # 4b1f <_license+0x26f2>
    2b4e:	37                   	(bad)
    2b4f:	12 00                	adc    (%rax),%al
    2b51:	00 00                	add    %al,(%rax)
    2b53:	00 79 02             	add    %bh,0x2(%rcx)
    2b56:	03 3e                	add    (%rsi),%edi
    2b58:	01 55 db             	add    %edx,-0x25(%rbp)
    2b5b:	1f                   	(bad)
    2b5c:	00 00                	add    %al,(%rax)
    2b5e:	47 e5 1f             	rex.RXB in $0x1f,%eax
    2b61:	00 00                	add    %al,(%rax)
    2b63:	3a 98 03 ee 1f 00    	cmp    0x1fee03(%rax),%bl
    2b69:	00 48 00             	add    %cl,0x0(%rax)
    2b6c:	f7 1f                	negl   (%rdi)
    2b6e:	00 00                	add    %al,(%rax)
    2b70:	00 00                	add    %al,(%rax)
    2b72:	3d f0 1a 00 00       	cmp    $0x1af0,%eax
    2b77:	38 3b                	cmp    %bh,(%rbx)
    2b79:	00 00                	add    %al,(%rax)
    2b7b:	00 00                	add    %al,(%rax)
    2b7d:	8e 03                	mov    (%rbx),%es
    2b7f:	0f 3e                	(bad)
    2b81:	02 30                	add    (%rax),%dh
    2b83:	9f                   	lahf
    2b84:	ff 1a                	lcall  *(%rdx)
    2b86:	00 00                	add    %al,(%rax)
    2b88:	3e 02 31             	ds add (%rcx),%dh
    2b8b:	9f                   	lahf
    2b8c:	09 1b                	or     %ebx,(%rbx)
    2b8e:	00 00                	add    %al,(%rax)
    2b90:	3c 97                	cmp    $0x97,%al
    2b92:	03 13                	add    (%rbx),%edx
    2b94:	1b 00                	sbb    (%rax),%eax
    2b96:	00 41 38             	add    %al,0x38(%rcx)
    2b99:	30 00                	xor    %al,(%rax)
    2b9b:	00 00                	add    %al,(%rax)
    2b9d:	3c 96                	cmp    $0x96,%al
    2b9f:	03 1e                	add    (%rsi),%ebx
    2ba1:	1b 00                	sbb    (%rax),%eax
    2ba3:	00 42 06             	add    %al,0x6(%rdx)
    2ba6:	27                   	(bad)
    2ba7:	1b 00                	sbb    (%rax),%eax
    2ba9:	00 41 38             	add    %al,0x38(%rcx)
    2bac:	30 00                	xor    %al,(%rax)
    2bae:	00 00                	add    %al,(%rax)
    2bb0:	3f                   	(bad)
    2bb1:	80 04 31 1b          	addb   $0x1b,(%rcx,%rsi,1)
    2bb5:	00 00                	add    %al,(%rax)
    2bb7:	3f                   	(bad)
    2bb8:	08 3a                	or     %bh,(%rdx)
    2bba:	1b 00                	sbb    (%rax),%eax
    2bbc:	00 00                	add    %al,(%rax)
    2bbe:	00 00                	add    %al,(%rax)
    2bc0:	00 00                	add    %al,(%rax)
    2bc2:	00 41 39             	add    %al,0x39(%rcx)
    2bc5:	3a 00                	cmp    (%rax),%al
    2bc7:	00 00                	add    %al,(%rax)
    2bc9:	3f                   	(bad)
    2bca:	8b 04 66             	mov    (%rsi,%riz,2),%eax
    2bcd:	0f 00 00             	sldt   (%rax)
    2bd0:	3c d5                	cmp    $0xd5,%al
    2bd2:	01 6f 0f             	add    %ebp,0xf(%rdi)
    2bd5:	00 00                	add    %al,(%rax)
    2bd7:	41 39 1a             	cmp    %ebx,(%r10)
    2bda:	00 00                	add    %al,(%rax)
    2bdc:	00 3c d4             	add    %bh,(%rsp,%rdx,8)
    2bdf:	01 79 0f             	add    %edi,0xf(%rcx)
    2be2:	00 00                	add    %al,(%rax)
    2be4:	42 06                	rex.X (bad)
    2be6:	82                   	(bad)
    2be7:	0f 00 00             	sldt   (%rax)
    2bea:	41 39 1a             	cmp    %ebx,(%r10)
    2bed:	00 00                	add    %al,(%rax)
    2bef:	00 3f                	add    %bh,(%rdi)
    2bf1:	8b 04 8c             	mov    (%rsp,%rcx,4),%eax
    2bf4:	0f 00 00             	sldt   (%rax)
    2bf7:	3f                   	(bad)
    2bf8:	80 08 95             	orb    $0x95,(%rax)
    2bfb:	0f 00 00             	sldt   (%rax)
    2bfe:	3f                   	(bad)
    2bff:	08 9e 0f 00 00 00    	or     %bl,0xf(%rsi)
    2c05:	00 3d 38 1a 00 00    	add    %bh,0x1a38(%rip)        # 4643 <_license+0x2216>
    2c0b:	3a 0c 00             	cmp    (%rax,%rax,1),%cl
    2c0e:	00 00                	add    %al,(%rax)
    2c10:	00 65 03             	add    %ah,0x3(%rbp)
    2c13:	0b 3e                	or     (%rsi),%edi
    2c15:	01 53 42             	add    %edx,0x42(%rbx)
    2c18:	1a 00                	sbb    (%rax),%al
    2c1a:	00 3e                	add    %bh,(%rsi)
    2c1c:	02 30                	add    (%rax),%dh
    2c1e:	9f                   	lahf
    2c1f:	54                   	push   %rsp
    2c20:	1a 00                	sbb    (%rax),%al
    2c22:	00 3f                	add    %bh,(%rdi)
    2c24:	0e                   	(bad)
    2c25:	5d                   	pop    %rbp
    2c26:	1a 00                	sbb    (%rax),%al
    2c28:	00 41 3a             	add    %al,0x3a(%rcx)
    2c2b:	0c 00                	or     $0x0,%al
    2c2d:	00 00                	add    %al,(%rax)
    2c2f:	3b 03                	cmp    (%rbx),%eax
    2c31:	73 22                	jae    2c55 <_license+0x828>
    2c33:	9f                   	lahf
    2c34:	72 1a                	jb     2c50 <_license+0x823>
    2c36:	00 00                	add    %al,(%rax)
    2c38:	00 00                	add    %al,(%rax)
    2c3a:	00 39                	add    %bh,(%rcx)
    2c3c:	7d 1a                	jge    2c58 <_license+0x82b>
    2c3e:	00 00                	add    %al,(%rax)
    2c40:	14 00                	adc    $0x0,%al
    2c42:	d7                   	xlat   %ds:(%rbx)
    2c43:	03 07                	add    (%rdi),%eax
    2c45:	3a d6                	cmp    %dh,%dl
    2c47:	01 8b 1a 00 00 3a    	add    %ecx,0x3a00001a(%rbx)
    2c4d:	d7                   	xlat   %ds:(%rbx)
    2c4e:	01 93 1a 00 00 3a    	add    %edx,0x3a00001a(%rbx)
    2c54:	d8 01                	fadds  (%rcx)
    2c56:	9b                   	fwait
    2c57:	1a 00                	sbb    (%rax),%al
    2c59:	00 3c d9             	add    %bh,(%rcx,%rbx,8)
    2c5c:	01 a4 1a 00 00 3c da 	add    %esp,-0x25c40000(%rdx,%rbx,1)
    2c63:	01 ad 1a 00 00 3c    	add    %ebp,0x3c00001a(%rbp)
    2c69:	e5 01                	in     $0x1,%eax
    2c6b:	b6 1a                	mov    $0x1a,%dh
    2c6d:	00 00                	add    %al,(%rax)
    2c6f:	40 32 17             	rex xor (%rdi),%dl
    2c72:	00 00                	add    %al,(%rax)
    2c74:	3b 0b                	cmp    (%rbx),%ecx
    2c76:	00 00                	add    %al,(%rax)
    2c78:	00 00                	add    %al,(%rax)
    2c7a:	b8 0d 3e 01 55       	mov    $0x55013e0d,%eax
    2c7f:	3c 17                	cmp    $0x17,%al
    2c81:	00 00                	add    %al,(%rax)
    2c83:	00 41 3c             	add    %al,0x3c(%rcx)
    2c86:	1a 00                	sbb    (%rax),%al
    2c88:	00 00                	add    %al,(%rax)
    2c8a:	3c e7                	cmp    $0xe7,%al
    2c8c:	01 bf 1a 00 00 42    	add    %edi,0x4200001a(%rdi)
    2c92:	02 c7                	add    %bh,%al
    2c94:	1a 00                	sbb    (%rax),%al
    2c96:	00 41 3c             	add    %al,0x3c(%rcx)
    2c99:	1a 00                	sbb    (%rax),%al
    2c9b:	00 00                	add    %al,(%rax)
    2c9d:	3c e6                	cmp    $0xe6,%al
    2c9f:	01 d0                	add    %edx,%eax
    2ca1:	1a 00                	sbb    (%rax),%al
    2ca3:	00 3f                	add    %bh,(%rdi)
    2ca5:	80 20 d8             	andb   $0xd8,(%rax)
    2ca8:	1a 00                	sbb    (%rax),%al
    2caa:	00 3f                	add    %bh,(%rdi)
    2cac:	18 e0                	sbb    %ah,%al
    2cae:	1a 00                	sbb    (%rax),%al
    2cb0:	00 00                	add    %al,(%rax)
    2cb2:	00 00                	add    %al,(%rax)
    2cb4:	3d 4f 1b 00 00       	cmp    $0x1b4f,%eax
    2cb9:	3d c9 00 00 00       	cmp    $0xc9,%eax
    2cbe:	00 e4                	add    %ah,%ah
    2cc0:	03 05 3e 03 91 10    	add    0x1091033e(%rip),%eax        # 10913004 <_license+0x10910bd7>
    2cc6:	9f                   	lahf
    2cc7:	62                   	(bad)
    2cc8:	1b 00                	sbb    (%rax),%eax
    2cca:	00 3a                	add    %bh,(%rdx)
    2ccc:	e8 01 6b 1b 00       	call   1b97d2 <_license+0x1b73a5>
    2cd1:	00 3e                	add    %bh,(%rsi)
    2cd3:	04 91                	add    $0x91,%al
    2cd5:	e0 00                	loopne 2cd7 <_license+0x8aa>
    2cd7:	9f                   	lahf
    2cd8:	74 1b                	je     2cf5 <_license+0x8c8>
    2cda:	00 00                	add    %al,(%rax)
    2cdc:	3d fa 1b 00 00       	cmp    $0x1bfa,%eax
    2ce1:	3e 5b                	ds pop %rbx
    2ce3:	00 00                	add    %al,(%rax)
    2ce5:	00 00                	add    %al,(%rax)
    2ce7:	93                   	xchg   %eax,%ebx
    2ce8:	02 32                	add    (%rdx),%dh
    2cea:	3f                   	(bad)
    2ceb:	82                   	(bad)
    2cec:	04 0c                	add    $0xc,%al
    2cee:	1c 00                	sbb    $0x0,%al
    2cf0:	00 3c ea             	add    %bh,(%rdx,%rbp,8)
    2cf3:	01 15 1c 00 00 41    	add    %edx,0x4100001c(%rip)        # 41002d15 <_license+0x410008e8>
    2cf9:	3e 1a 00             	ds sbb (%rax),%al
    2cfc:	00 00                	add    %al,(%rax)
    2cfe:	3c e9                	cmp    $0xe9,%al
    2d00:	01 1f                	add    %ebx,(%rdi)
    2d02:	1c 00                	sbb    $0x0,%al
    2d04:	00 42 06             	add    %al,0x6(%rdx)
    2d07:	27                   	(bad)
    2d08:	1c 00                	sbb    $0x0,%al
    2d0a:	00 41 3e             	add    %al,0x3e(%rcx)
    2d0d:	1a 00                	sbb    (%rax),%al
    2d0f:	00 00                	add    %al,(%rax)
    2d11:	3f                   	(bad)
    2d12:	82                   	(bad)
    2d13:	04 30                	add    $0x30,%al
    2d15:	1c 00                	sbb    $0x0,%al
    2d17:	00 3f                	add    %bh,(%rdi)
    2d19:	80 08 38             	orb    $0x38,(%rax)
    2d1c:	1c 00                	sbb    $0x0,%al
    2d1e:	00 3f                	add    %bh,(%rdi)
    2d20:	08 40 1c             	or     %al,0x1c(%rax)
    2d23:	00 00                	add    %al,(%rax)
    2d25:	00 00                	add    %al,(%rax)
    2d27:	00 41 3f             	add    %al,0x3f(%rcx)
    2d2a:	59                   	pop    %rcx
    2d2b:	00 00                	add    %al,(%rax)
    2d2d:	00 3c ed 01 88 1b 00 	add    %bh,0x1b8801(,%rbp,8)
    2d34:	00 41 3f             	add    %al,0x3f(%rcx)
    2d37:	15 00 00 00 3c       	adc    $0x3c000000,%eax
    2d3c:	eb 01                	jmp    2d3f <_license+0x912>
    2d3e:	93                   	xchg   %eax,%ebx
    2d3f:	1b 00                	sbb    (%rax),%eax
    2d41:	00 42 0d             	add    %al,0xd(%rdx)
    2d44:	9c                   	pushf
    2d45:	1b 00                	sbb    (%rax),%eax
    2d47:	00 3d 32 17 00 00    	add    %bh,0x1732(%rip)        # 447f <_license+0x2052>
    2d4d:	3f                   	(bad)
    2d4e:	15 00 00 00 00       	adc    $0x0,%eax
    2d53:	95                   	xchg   %eax,%ebp
    2d54:	02 1c 3a             	add    (%rdx,%rdi,1),%bl
    2d57:	ec                   	in     (%dx),%al
    2d58:	01 3c 17             	add    %edi,(%rdi,%rdx,1)
    2d5b:	00 00                	add    %al,(%rax)
    2d5d:	00 00                	add    %al,(%rax)
    2d5f:	41                   	rex.B
    2d60:	40 3f                	rex (bad)
    2d62:	00 00                	add    %al,(%rax)
    2d64:	00 3c ee             	add    %bh,(%rsi,%rbp,8)
    2d67:	01 a7 1b 00 00 3d    	add    %esp,0x3d00001b(%rdi)
    2d6d:	32 17                	xor    (%rdi),%dl
    2d6f:	00 00                	add    %al,(%rax)
    2d71:	41 09 00             	or     %eax,(%r8)
    2d74:	00 00                	add    %al,(%rax)
    2d76:	00 97 02 19 3e 01    	add    %dl,0x13e1902(%rdi)
    2d7c:	50                   	push   %rax
    2d7d:	3c 17                	cmp    $0x17,%al
    2d7f:	00 00                	add    %al,(%rax)
    2d81:	3e 01 54 46 17       	ds add %edx,0x17(%rsi,%rax,2)
    2d86:	00 00                	add    %al,(%rax)
    2d88:	00 41 42             	add    %al,0x42(%rcx)
    2d8b:	2c 00                	sub    $0x0,%al
    2d8d:	00 00                	add    %al,(%rax)
    2d8f:	3f                   	(bad)
    2d90:	8f 04 b2             	pop    (%rdx,%rsi,4)
    2d93:	1b 00                	sbb    (%rax),%eax
    2d95:	00 3c f0             	add    %bh,(%rax,%rsi,8)
    2d98:	01 bb 1b 00 00 41    	add    %edi,0x4100001b(%rbx)
    2d9e:	42 1a 00             	rex.X sbb (%rax),%al
    2da1:	00 00                	add    %al,(%rax)
    2da3:	3c ef                	cmp    $0xef,%al
    2da5:	01 c6                	add    %eax,%esi
    2da7:	1b 00                	sbb    (%rax),%eax
    2da9:	00 42 06             	add    %al,0x6(%rdx)
    2dac:	cf                   	iret
    2dad:	1b 00                	sbb    (%rax),%eax
    2daf:	00 41 42             	add    %al,0x42(%rcx)
    2db2:	1a 00                	sbb    (%rax),%al
    2db4:	00 00                	add    %al,(%rax)
    2db6:	3f                   	(bad)
    2db7:	8f 04 d9             	pop    (%rcx,%rbx,8)
    2dba:	1b 00                	sbb    (%rax),%eax
    2dbc:	00 3f                	add    %bh,(%rdi)
    2dbe:	80 08 e2             	orb    $0xe2,(%rax)
    2dc1:	1b 00                	sbb    (%rax),%eax
    2dc3:	00 3f                	add    %bh,(%rdi)
    2dc5:	08 eb                	or     %ch,%bl
    2dc7:	1b 00                	sbb    (%rax),%eax
    2dc9:	00 00                	add    %al,(%rax)
    2dcb:	00 00                	add    %al,(%rax)
    2dcd:	00 00                	add    %al,(%rax)
    2dcf:	00 41 43             	add    %al,0x43(%rcx)
    2dd2:	34 00                	xor    $0x0,%al
    2dd4:	00 00                	add    %al,(%rax)
    2dd6:	3f                   	(bad)
    2dd7:	81 04 ac 0f 00 00 3c 	addl   $0x3c00000f,(%rsp,%rbp,4)
    2dde:	84 02                	test   %al,(%rdx)
    2de0:	b5 0f                	mov    $0xf,%ch
    2de2:	00 00                	add    %al,(%rax)
    2de4:	41                   	rex.B
    2de5:	43 1a 00             	rex.XB sbb (%r8),%al
    2de8:	00 00                	add    %al,(%rax)
    2dea:	3c 83                	cmp    $0x83,%al
    2dec:	02 bf 0f 00 00 42    	add    0x4200000f(%rdi),%bh
    2df2:	06                   	(bad)
    2df3:	c8 0f 00 00          	enter  $0xf,$0x0
    2df7:	41                   	rex.B
    2df8:	43 1a 00             	rex.XB sbb (%r8),%al
    2dfb:	00 00                	add    %al,(%rax)
    2dfd:	3f                   	(bad)
    2dfe:	81 04 d2 0f 00 00 3f 	addl   $0x3f00000f,(%rdx,%rdx,8)
    2e05:	80 08 db             	orb    $0xdb,(%rax)
    2e08:	0f 00 00             	sldt   (%rax)
    2e0b:	3f                   	(bad)
    2e0c:	08 e4                	or     %ah,%ah
    2e0e:	0f 00 00             	sldt   (%rax)
    2e11:	00 00                	add    %al,(%rax)
    2e13:	00 39                	add    %bh,(%rcx)
    2e15:	f6 1c 00             	negb   (%rax,%rax,1)
    2e18:	00 15 00 fa 03 0c    	add    %dl,0xc03fa00(%rip)        # c04281e <_license+0xc0403f1>
    2e1e:	3a 85 02 08 1d 00    	cmp    0x1d0802(%rbp),%al
    2e24:	00 3a                	add    %bh,(%rdx)
    2e26:	86 02                	xchg   %al,(%rdx)
    2e28:	10 1d 00 00 3a 87    	adc    %bl,-0x78c60000(%rip)        # ffffffff873a2e2e <server_id_map+0x36fc3e106e2e>
    2e2e:	02 18                	add    (%rax),%bl
    2e30:	1d 00 00 3a 88       	sbb    $0x883a0000,%eax
    2e35:	02 20                	add    (%rax),%ah
    2e37:	1d 00 00 3b 03       	sbb    $0x33b0000,%eax
    2e3c:	91                   	xchg   %eax,%ecx
    2e3d:	c0 00 28             	rolb   $0x28,(%rax)
    2e40:	1d 00 00 3c 89       	sbb    $0x893c0000,%eax
    2e45:	02 31                	add    (%rcx),%dh
    2e47:	1d 00 00 3c 8a       	sbb    $0x8a3c0000,%eax
    2e4c:	02 3a                	add    (%rdx),%bh
    2e4e:	1d 00 00 3c 8b       	sbb    $0x8b3c0000,%eax
    2e53:	02 43 1d             	add    0x1d(%rbx),%al
    2e56:	00 00                	add    %al,(%rax)
    2e58:	3c 92                	cmp    $0x92,%al
    2e5a:	02 4c 1d 00          	add    0x0(%rbp,%rbx,1),%cl
    2e5e:	00 3c 93             	add    %bh,(%rbx,%rdx,4)
    2e61:	02 55 1d             	add    0x1d(%rbp),%dl
    2e64:	00 00                	add    %al,(%rax)
    2e66:	40 fa                	rex cli
    2e68:	1b 00                	sbb    (%rax),%eax
    2e6a:	00 44 61 00          	add    %al,0x0(%rcx,%riz,2)
    2e6e:	00 00                	add    %al,(%rax)
    2e70:	00 66 11             	add    %ah,0x11(%rsi)
    2e73:	3f                   	(bad)
    2e74:	82                   	(bad)
    2e75:	04 0c                	add    $0xc,%al
    2e77:	1c 00                	sbb    $0x0,%al
    2e79:	00 3c 8d 02 15 1c 00 	add    %bh,0x1c1502(,%rcx,4)
    2e80:	00 41 44             	add    %al,0x44(%rcx)
    2e83:	1c 00                	sbb    $0x0,%al
    2e85:	00 00                	add    %al,(%rax)
    2e87:	3c 8c                	cmp    $0x8c,%al
    2e89:	02 1f                	add    (%rdi),%bl
    2e8b:	1c 00                	sbb    $0x0,%al
    2e8d:	00 42 06             	add    %al,0x6(%rdx)
    2e90:	27                   	(bad)
    2e91:	1c 00                	sbb    $0x0,%al
    2e93:	00 41 44             	add    %al,0x44(%rcx)
    2e96:	1c 00                	sbb    $0x0,%al
    2e98:	00 00                	add    %al,(%rax)
    2e9a:	3f                   	(bad)
    2e9b:	82                   	(bad)
    2e9c:	04 30                	add    $0x30,%al
    2e9e:	1c 00                	sbb    $0x0,%al
    2ea0:	00 3f                	add    %bh,(%rdi)
    2ea2:	80 08 38             	orb    $0x38,(%rax)
    2ea5:	1c 00                	sbb    $0x0,%al
    2ea7:	00 3f                	add    %bh,(%rdi)
    2ea9:	08 40 1c             	or     %al,0x1c(%rax)
    2eac:	00 00                	add    %al,(%rax)
    2eae:	00 00                	add    %al,(%rax)
    2eb0:	00 43 16             	add    %al,0x16(%rbx)
    2eb3:	3c 8e                	cmp    $0x8e,%al
    2eb5:	02 66 1d             	add    0x1d(%rsi),%ah
    2eb8:	00 00                	add    %al,(%rax)
    2eba:	40 1c 1e             	rex sbb $0x1e,%al
    2ebd:	00 00                	add    %al,(%rax)
    2ebf:	45                   	rex.RB
    2ec0:	4a 00 00             	rex.WX add %al,(%rax)
    2ec3:	00 00                	add    %al,(%rax)
    2ec5:	8f                   	(bad)
    2ec6:	0c 3e                	or     $0x3e,%al
    2ec8:	03 91 10 9f 25 1e    	add    0x1e259f10(%rcx),%edx
    2ece:	00 00                	add    %al,(%rax)
    2ed0:	3e 02 30             	ds add (%rax),%dh
    2ed3:	9f                   	lahf
    2ed4:	2d 1e 00 00 40       	sub    $0x4000001e,%eax
    2ed9:	f7 1d 00 00 45 4a    	negl   0x4a450000(%rip)        # 4a452edf <_license+0x4a450ab2>
    2edf:	00 00                	add    %al,(%rax)
    2ee1:	00 00                	add    %al,(%rax)
    2ee3:	22 0c 48             	and    (%rax,%rcx,2),%cl
    2ee6:	80 84 80 10 12 1e 00 	addb   $0x0,0x1e1210(%rax,%rax,4)
    2eed:	00 
    2eee:	40 c9                	rex leave
    2ef0:	1d 00 00 45 4a       	sbb    $0x4a450000,%eax
    2ef5:	00 00                	add    %al,(%rax)
    2ef7:	00 0d 6f 0a 3a 91    	add    %cl,-0x6ec5f591(%rip)        # ffffffff913a396c <server_id_map+0x36fc4810796c>
    2efd:	02 d2                	add    %dl,%dl
    2eff:	1d 00 00 3a 8f       	sbb    $0x8f3a0000,%eax
    2f04:	02 db                	add    %bl,%bl
    2f06:	1d 00 00 3a 90       	sbb    $0x903a0000,%eax
    2f0b:	02 e4                	add    %ah,%ah
    2f0d:	1d 00 00 48 f7       	sbb    $0xf7480000,%eax
    2f12:	81 b7 85 fe ff ff ff 	xorl   $0xed01ffff,-0x17b(%rdi)
    2f19:	ff 01 ed 
    2f1c:	1d 00 00 40 37       	sbb    $0x37400000,%eax
    2f21:	1e                   	(bad)
    2f22:	00 00                	add    %al,(%rax)
    2f24:	46 05 00 00 00 0d    	rex.RX add $0xd000000,%eax
    2f2a:	6a 03                	push   $0x3
    2f2c:	3e 01 54 40 1e       	ds add %edx,0x1e(%rax,%rax,2)
    2f31:	00 00                	add    %al,(%rax)
    2f33:	48 0e                	rex.W (bad)
    2f35:	49 1e                	rex.WB (bad)
    2f37:	00 00                	add    %al,(%rax)
    2f39:	00 40 37             	add    %al,0x37(%rax)
    2f3c:	1e                   	(bad)
    2f3d:	00 00                	add    %al,(%rax)
    2f3f:	47 05 00 00 00 0d    	rex.RXB add $0xd000000,%eax
    2f45:	6a 03                	push   $0x3
    2f47:	3e 01 52 40          	ds add %edx,0x40(%rdx)
    2f4b:	1e                   	(bad)
    2f4c:	00 00                	add    %al,(%rax)
    2f4e:	48 0b 49 1e          	or     0x1e(%rcx),%rcx
    2f52:	00 00                	add    %al,(%rax)
    2f54:	00 40 37             	add    %al,0x37(%rax)
    2f57:	1e                   	(bad)
    2f58:	00 00                	add    %al,(%rax)
    2f5a:	48 05 00 00 00 0d    	add    $0xd000000,%rax
    2f60:	6a 03                	push   $0x3
    2f62:	3e 01 51 40          	ds add %edx,0x40(%rcx)
    2f66:	1e                   	(bad)
    2f67:	00 00                	add    %al,(%rax)
    2f69:	48 19 49 1e          	sbb    %rcx,0x1e(%rcx)
    2f6d:	00 00                	add    %al,(%rax)
    2f6f:	00 40 37             	add    %al,0x37(%rax)
    2f72:	1e                   	(bad)
    2f73:	00 00                	add    %al,(%rax)
    2f75:	49 05 00 00 00 0d    	rex.WB add $0xd000000,%rax
    2f7b:	6a 03                	push   $0x3
    2f7d:	3e 01 54 40 1e       	ds add %edx,0x1e(%rax,%rax,2)
    2f82:	00 00                	add    %al,(%rax)
    2f84:	48 10 49 1e          	rex.W adc %cl,0x1e(%rcx)
    2f88:	00 00                	add    %al,(%rax)
    2f8a:	00 40 37             	add    %al,0x37(%rax)
    2f8d:	1e                   	(bad)
    2f8e:	00 00                	add    %al,(%rax)
    2f90:	4a 05 00 00 00 0d    	rex.WX add $0xd000000,%rax
    2f96:	6a 03                	push   $0x3
    2f98:	3e 01 52 40          	ds add %edx,0x40(%rdx)
    2f9c:	1e                   	(bad)
    2f9d:	00 00                	add    %al,(%rax)
    2f9f:	48 04 49             	rex.W add $0x49,%al
    2fa2:	1e                   	(bad)
    2fa3:	00 00                	add    %al,(%rax)
    2fa5:	00 40 37             	add    %al,0x37(%rax)
    2fa8:	1e                   	(bad)
    2fa9:	00 00                	add    %al,(%rax)
    2fab:	4b 03 00             	rex.WXB add (%r8),%rax
    2fae:	00 00                	add    %al,(%rax)
    2fb0:	0d 6a 03 3e 01       	or     $0x13e036a,%eax
    2fb5:	51                   	push   %rcx
    2fb6:	40 1e                	rex (bad)
    2fb8:	00 00                	add    %al,(%rax)
    2fba:	48 0e                	rex.W (bad)
    2fbc:	49 1e                	rex.WB (bad)
    2fbe:	00 00                	add    %al,(%rax)
    2fc0:	00 40 37             	add    %al,0x37(%rax)
    2fc3:	1e                   	(bad)
    2fc4:	00 00                	add    %al,(%rax)
    2fc6:	4c 03 00             	add    (%rax),%r8
    2fc9:	00 00                	add    %al,(%rax)
    2fcb:	0d 6a 03 3e 01       	or     $0x13e036a,%eax
    2fd0:	54                   	push   %rsp
    2fd1:	40 1e                	rex (bad)
    2fd3:	00 00                	add    %al,(%rax)
    2fd5:	48 18 49 1e          	rex.W sbb %cl,0x1e(%rcx)
    2fd9:	00 00                	add    %al,(%rax)
    2fdb:	00 00                	add    %al,(%rax)
    2fdd:	00 00                	add    %al,(%rax)
    2fdf:	43 17                	rex.XB (bad)
    2fe1:	3c 94                	cmp    $0x94,%al
    2fe3:	02 70 1d             	add    0x1d(%rax),%dh
    2fe6:	00 00                	add    %al,(%rax)
    2fe8:	42 02 78 1d          	rex.X add 0x1d(%rax),%dil
    2fec:	00 00                	add    %al,(%rax)
    2fee:	43 18 3b             	rex.XB sbb %dil,(%r11)
    2ff1:	01 51 81             	add    %edx,-0x7f(%rcx)
    2ff4:	1d 00 00 3f 80       	sbb    $0x803f0000,%eax
    2ff9:	84 80 10 89 1d 00    	test   %al,0x1d8910(%rax)
    2fff:	00 3f                	add    %bh,(%rdi)
    3001:	08 91 1d 00 00 00    	or     %dl,0x1d(%rcx)
    3007:	00 40 97             	add    %al,-0x69(%rax)
    300a:	1e                   	(bad)
    300b:	00 00                	add    %al,(%rax)
    300d:	4d 28 00             	rex.WRB sub %r8b,(%r8)
    3010:	00 00                	add    %al,(%rax)
    3012:	00 9a 07 3f 89 04    	add    %bl,0x4893f07(%rdx)
    3018:	9c                   	pushf
    3019:	1e                   	(bad)
    301a:	00 00                	add    %al,(%rax)
    301c:	3c 99                	cmp    $0x99,%al
    301e:	02 a5 1e 00 00 41    	add    0x4100001e(%rbp),%ah
    3024:	4d 1a 00             	rex.WRB sbb (%r8),%r8b
    3027:	00 00                	add    %al,(%rax)
    3029:	3c 98                	cmp    $0x98,%al
    302b:	02 af 1e 00 00 42    	add    0x4200001e(%rdi),%ch
    3031:	06                   	(bad)
    3032:	b7 1e                	mov    $0x1e,%bh
    3034:	00 00                	add    %al,(%rax)
    3036:	41                   	rex.B
    3037:	4d 1a 00             	rex.WRB sbb (%r8),%r8b
    303a:	00 00                	add    %al,(%rax)
    303c:	3f                   	(bad)
    303d:	89 04 c0             	mov    %eax,(%rax,%rax,8)
    3040:	1e                   	(bad)
    3041:	00 00                	add    %al,(%rax)
    3043:	3f                   	(bad)
    3044:	80 08 c8             	orb    $0xc8,(%rax)
    3047:	1e                   	(bad)
    3048:	00 00                	add    %al,(%rax)
    304a:	3f                   	(bad)
    304b:	08 d0                	or     %dl,%al
    304d:	1e                   	(bad)
    304e:	00 00                	add    %al,(%rax)
    3050:	00 00                	add    %al,(%rax)
    3052:	00 00                	add    %al,(%rax)
    3054:	41                   	rex.B
    3055:	4e 06                	rex.WRX (bad)
    3057:	00 00                	add    %al,(%rax)
    3059:	00 3c 95 02 9d 1d 00 	add    %bh,0x1d9d02(,%rdx,4)
    3060:	00 42 02             	add    %al,0x2(%rdx)
    3063:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    3064:	1d 00 00 41 4e       	sbb    $0x4e410000,%eax
    3069:	06                   	(bad)
    306a:	00 00                	add    %al,(%rax)
    306c:	00 3b                	add    %bh,(%rbx)
    306e:	01 56 ae             	add    %edx,-0x52(%rsi)
    3071:	1d 00 00 3f 80       	sbb    $0x803f0000,%eax
    3076:	20 b6 1d 00 00 3f    	and    %dh,0x3f00001d(%rsi)
    307c:	18 be 1d 00 00 00    	sbb    %bh,0x1d(%rsi)
    3082:	00 40 53             	add    %al,0x53(%rax)
    3085:	1e                   	(bad)
    3086:	00 00                	add    %al,(%rax)
    3088:	4f 28 00             	rex.WRXB sub %r8b,(%r8)
    308b:	00 00                	add    %al,(%rax)
    308d:	00 a3 05 3f 89 04    	add    %ah,0x4893f05(%rbx)
    3093:	58                   	pop    %rax
    3094:	1e                   	(bad)
    3095:	00 00                	add    %al,(%rax)
    3097:	3c 97                	cmp    $0x97,%al
    3099:	02 61 1e             	add    0x1e(%rcx),%ah
    309c:	00 00                	add    %al,(%rax)
    309e:	41                   	rex.B
    309f:	4f 1a 00             	rex.WRXB sbb (%r8),%r8b
    30a2:	00 00                	add    %al,(%rax)
    30a4:	3c 96                	cmp    $0x96,%al
    30a6:	02 6b 1e             	add    0x1e(%rbx),%ch
    30a9:	00 00                	add    %al,(%rax)
    30ab:	42 06                	rex.X (bad)
    30ad:	73 1e                	jae    30cd <_license+0xca0>
    30af:	00 00                	add    %al,(%rax)
    30b1:	41                   	rex.B
    30b2:	4f 1a 00             	rex.WRXB sbb (%r8),%r8b
    30b5:	00 00                	add    %al,(%rax)
    30b7:	3f                   	(bad)
    30b8:	89 04 7c             	mov    %eax,(%rsp,%rdi,2)
    30bb:	1e                   	(bad)
    30bc:	00 00                	add    %al,(%rax)
    30be:	3f                   	(bad)
    30bf:	80 08 84             	orb    $0x84,(%rax)
    30c2:	1e                   	(bad)
    30c3:	00 00                	add    %al,(%rax)
    30c5:	3f                   	(bad)
    30c6:	08 8c 1e 00 00 00 00 	or     %cl,0x0(%rsi,%rbx,1)
    30cd:	00 40 d1             	add    %al,-0x2f(%rax)
    30d0:	1f                   	(bad)
    30d1:	00 00                	add    %al,(%rax)
    30d3:	50                   	push   %rax
    30d4:	12 00                	adc    (%rax),%al
    30d6:	00 00                	add    %al,(%rax)
    30d8:	00 ab 05 3e 01 55    	add    %ch,0x55013e05(%rbx)
    30de:	db 1f                	fistpl (%rdi)
    30e0:	00 00                	add    %al,(%rax)
    30e2:	48 00 f7             	rex.W add %sil,%dil
    30e5:	1f                   	(bad)
    30e6:	00 00                	add    %al,(%rax)
    30e8:	00 00                	add    %al,(%rax)
    30ea:	3d 01 20 00 00       	cmp    $0x2001,%eax
    30ef:	51                   	push   %rcx
    30f0:	5f                   	pop    %rdi
    30f1:	00 00                	add    %al,(%rax)
    30f3:	00 00                	add    %al,(%rax)
    30f5:	ff 03                	incl   (%rbx)
    30f7:	0b 3e                	or     (%rsi),%edi
    30f9:	04 91                	add    $0x91,%al
    30fb:	e0 00                	loopne 30fd <_license+0xcd0>
    30fd:	9f                   	lahf
    30fe:	0b 20                	or     (%rax),%esp
    3100:	00 00                	add    %al,(%rax)
    3102:	3e 02 30             	ds add (%rax),%dh
    3105:	9f                   	lahf
    3106:	26 20 00             	es and %al,(%rax)
    3109:	00 3b                	add    %bh,(%rbx)
    310b:	04 75                	add    $0x75,%al
    310d:	80 02 9f             	addb   $0x9f,(%rdx)
    3110:	2f                   	(bad)
    3111:	20 00                	and    %al,(%rax)
    3113:	00 3f                	add    %bh,(%rdi)
    3115:	00 39                	add    %bh,(%rcx)
    3117:	20 00                	and    %al,(%rax)
    3119:	00 41 52             	add    %al,0x52(%rcx)
    311c:	34 00                	xor    $0x0,%al
    311e:	00 00                	add    %al,(%rax)
    3120:	3c a7                	cmp    $0xa7,%al
    3122:	02 6c 20 00          	add    0x0(%rax,%riz,1),%ch
    3126:	00 3c aa             	add    %bh,(%rdx,%rbp,4)
    3129:	02 75 20             	add    0x20(%rbp),%dh
    312c:	00 00                	add    %al,(%rax)
    312e:	41 52                	push   %r10
    3130:	28 00                	sub    %al,(%rax)
    3132:	00 00                	add    %al,(%rax)
    3134:	3c a8                	cmp    $0xa8,%al
    3136:	02 80 20 00 00 42    	add    0x42000020(%rax),%al
    313c:	06                   	(bad)
    313d:	89 20                	mov    %esp,(%rax)
    313f:	00 00                	add    %al,(%rax)
    3141:	41 52                	push   %r10
    3143:	28 00                	sub    %al,(%rax)
    3145:	00 00                	add    %al,(%rax)
    3147:	3c a9                	cmp    $0xa9,%al
    3149:	02 93 20 00 00 3f    	add    0x3f000020(%rbx),%dl
    314f:	80 20 9c             	andb   $0x9c,(%rax)
    3152:	20 00                	and    %al,(%rax)
    3154:	00 3f                	add    %bh,(%rdi)
    3156:	08 a5 20 00 00 00    	or     %ah,0x20(%rbp)
    315c:	00 00                	add    %al,(%rax)
    315e:	00 41 53             	add    %al,0x53(%rcx)
    3161:	27                   	(bad)
    3162:	00 00                	add    %al,(%rax)
    3164:	00 3c f1             	add    %bh,(%rcx,%rsi,8)
    3167:	01 f1                	add    %esi,%ecx
    3169:	0f 00 00             	sldt   (%rax)
    316c:	42 06                	rex.X (bad)
    316e:	fa                   	cli
    316f:	0f 00 00             	sldt   (%rax)
    3172:	41 53                	push   %r11
    3174:	27                   	(bad)
    3175:	00 00                	add    %al,(%rax)
    3177:	00 3f                	add    %bh,(%rdi)
    3179:	80 08 04             	orb    $0x4,(%rax)
    317c:	10 00                	adc    %al,(%rax)
    317e:	00 3f                	add    %bh,(%rdi)
    3180:	08 0d 10 00 00 00    	or     %cl,0x10(%rip)        # 3196 <_license+0xd69>
    3186:	00 41 54             	add    %al,0x54(%rcx)
    3189:	2c 00                	sub    $0x0,%al
    318b:	00 00                	add    %al,(%rax)
    318d:	3c f3                	cmp    $0xf3,%al
    318f:	01 22                	add    %esp,(%rdx)
    3191:	10 00                	adc    %al,(%rax)
    3193:	00 42 06             	add    %al,0x6(%rdx)
    3196:	2b 10                	sub    (%rax),%edx
    3198:	00 00                	add    %al,(%rax)
    319a:	41 54                	push   %r12
    319c:	2c 00                	sub    $0x0,%al
    319e:	00 00                	add    %al,(%rax)
    31a0:	3c f4                	cmp    $0xf4,%al
    31a2:	01 35 10 00 00 3c    	add    %esi,0x3c000010(%rip)        # 3c0031b8 <_license+0x3c000d8b>
    31a8:	f5                   	cmc
    31a9:	01 3e                	add    %edi,(%rsi)
    31ab:	10 00                	adc    %al,(%rax)
    31ad:	00 00                	add    %al,(%rax)
    31af:	00 3d 4b 1c 00 00    	add    %bh,0x1c4b(%rip)        # 4e00 <_license+0x29d3>
    31b5:	55                   	push   %rbp
    31b6:	d3 00                	roll   %cl,(%rax)
    31b8:	00 00                	add    %al,(%rax)
    31ba:	00 28                	add    %ch,(%rax)
    31bc:	04 0a                	add    $0xa,%al
    31be:	3e 01 5d 54          	ds add %ebx,0x54(%rbp)
    31c2:	1c 00                	sbb    $0x0,%al
    31c4:	00 3e                	add    %bh,(%rsi)
    31c6:	03 91 10 9f 64 1c    	add    0x1c649f10(%rcx),%edx
    31cc:	00 00                	add    %al,(%rax)
    31ce:	3e 01 5e 6c          	ds add %ebx,0x6c(%rsi)
    31d2:	1c 00                	sbb    $0x0,%al
    31d4:	00 3a                	add    %bh,(%rdx)
    31d6:	f6 01 74             	testb  $0x74,(%rcx)
    31d9:	1c 00                	sbb    $0x0,%al
    31db:	00 3c f7             	add    %bh,(%rdi,%rsi,8)
    31de:	01 84 1c 00 00 3c f8 	add    %eax,-0x7c40000(%rsp,%rbx,1)
    31e5:	01 8d 1c 00 00 3c    	add    %ecx,0x3c00001c(%rbp)
    31eb:	f9                   	stc
    31ec:	01 95 1c 00 00 3c    	add    %edx,0x3c00001c(%rbp)
    31f2:	fa                   	cli
    31f3:	01 9d 1c 00 00 3c    	add    %ebx,0x3c00001c(%rbp)
    31f9:	fb                   	sti
    31fa:	01 a5 1c 00 00 3c    	add    %esp,0x3c00001c(%rbp)
    3200:	fc                   	cld
    3201:	01 7c 1c 00          	add    %edi,0x0(%rsp,%rbx,1)
    3205:	00 3c fd 01 ae 1c 00 	add    %bh,0x1cae01(,%rdi,8)
    320c:	00 40 b8             	add    %al,-0x48(%rax)
    320f:	1c 00                	sbb    $0x0,%al
    3211:	00 56 42             	add    %dl,0x42(%rsi)
    3214:	00 00                	add    %al,(%rax)
    3216:	00 11                	add    %dl,(%rcx)
    3218:	75 03                	jne    321d <_license+0xdf0>
    321a:	3a 80 02 c5 1c 00    	cmp    0x1cc502(%rax),%al
    3220:	00 3a                	add    %bh,(%rdx)
    3222:	fe 01                	incb   (%rcx)
    3224:	cd 1c                	int    $0x1c
    3226:	00 00                	add    %al,(%rax)
    3228:	3e 01 52 d5          	ds add %edx,-0x2b(%rdx)
    322c:	1c 00                	sbb    $0x0,%al
    322e:	00 3a                	add    %bh,(%rdx)
    3230:	ff 01                	incl   (%rcx)
    3232:	dd 1c 00             	fstpl  (%rax,%rax,1)
    3235:	00 48 04             	add    %cl,0x4(%rax)
    3238:	e5 1c                	in     $0x1c,%eax
    323a:	00 00                	add    %al,(%rax)
    323c:	3f                   	(bad)
    323d:	00 ed                	add    %ch,%ch
    323f:	1c 00                	sbb    $0x0,%al
    3241:	00 40 51             	add    %al,0x51(%rax)
    3244:	13 00                	adc    (%rax),%eax
    3246:	00 57 1d             	add    %dl,0x1d(%rdi)
    3249:	00 00                	add    %al,(%rax)
    324b:	00 12                	add    %dl,(%rdx)
    324d:	48 03 3e             	add    (%rsi),%rdi
    3250:	03 70 0e             	add    0xe(%rax),%esi
    3253:	9f                   	lahf
    3254:	55                   	push   %rbp
    3255:	13 00                	adc    (%rax),%eax
    3257:	00 3c 82             	add    %bh,(%rdx,%rax,4)
    325a:	02 65 13             	add    0x13(%rbp),%ah
    325d:	00 00                	add    %al,(%rax)
    325f:	41 57                	push   %r15
    3261:	1d 00 00 00 3c       	sbb    $0x3c000000,%eax
    3266:	81 02 6e 13 00 00    	addl   $0x136e,(%rdx)
    326c:	00 00                	add    %al,(%rax)
    326e:	00 00                	add    %al,(%rax)
    3270:	3d db 1e 00 00       	cmp    $0x1edb,%eax
    3275:	58                   	pop    %rax
    3276:	bb 00 00 00 00       	mov    $0x0,%ebx
    327b:	24 04                	and    $0x4,%al
    327d:	0a 3e                	or     (%rsi),%bh
    327f:	01 5d e4             	add    %ebx,-0x1c(%rbp)
    3282:	1e                   	(bad)
    3283:	00 00                	add    %al,(%rax)
    3285:	3e 02 30             	ds add (%rax),%dh
    3288:	9f                   	lahf
    3289:	f4                   	hlt
    328a:	1e                   	(bad)
    328b:	00 00                	add    %al,(%rax)
    328d:	3e 03 91 10 9f fc 1e 	ds add 0x1efc9f10(%rcx),%edx
    3294:	00 00                	add    %al,(%rax)
    3296:	3e 01 5e 04          	ds add %ebx,0x4(%rsi)
    329a:	1f                   	(bad)
    329b:	00 00                	add    %al,(%rax)
    329d:	3a 9a 02 0c 1f 00    	cmp    0x1f0c02(%rdx),%bl
    32a3:	00 3c 9b             	add    %bh,(%rbx,%rbx,4)
    32a6:	02 14 1f             	add    (%rdi,%rbx,1),%dl
    32a9:	00 00                	add    %al,(%rax)
    32ab:	3c 9c                	cmp    $0x9c,%al
    32ad:	02 1c 1f             	add    (%rdi,%rbx,1),%bl
    32b0:	00 00                	add    %al,(%rax)
    32b2:	3c 9d                	cmp    $0x9d,%al
    32b4:	02 24 1f             	add    (%rdi,%rbx,1),%ah
    32b7:	00 00                	add    %al,(%rax)
    32b9:	3c 9e                	cmp    $0x9e,%al
    32bb:	02 2d 1f 00 00 3c    	add    0x3c00001f(%rip),%ch        # 3c0032e0 <_license+0x3c000eb3>
    32c1:	9f                   	lahf
    32c2:	02 35 1f 00 00 3c    	add    0x3c00001f(%rip),%dh        # 3c0032e7 <_license+0x3c000eba>
    32c8:	a0 02 3e 1f 00 00 3c 	movabs 0x2a13c00001f3e02,%al
    32cf:	a1 02 
    32d1:	46 1f                	rex.RX (bad)
    32d3:	00 00                	add    %al,(%rax)
    32d5:	3c a2                	cmp    $0xa2,%al
    32d7:	02 4e 1f             	add    0x1f(%rsi),%cl
    32da:	00 00                	add    %al,(%rax)
    32dc:	49 63 1f             	movslq (%r15),%rbx
    32df:	00 00                	add    %al,(%rax)
    32e1:	59                   	pop    %rcx
    32e2:	04 00                	add    $0x0,%al
    32e4:	00 00                	add    %al,(%rax)
    32e6:	11 4f 05             	adc    %ecx,0x5(%rdi)
    32e9:	40 81 1f 00 00 5a 3f 	rex sbbl $0x3f5a0000,(%rdi)
    32f0:	00 00                	add    %al,(%rax)
    32f2:	00 11                	add    %dl,(%rcx)
    32f4:	53                   	push   %rbx
    32f5:	03 3a                	add    (%rdx),%edi
    32f7:	a3 02 8e 1f 00 00 3e 	movabs %eax,0x5e013e00001f8e02
    32fe:	01 5e 
    3300:	9f                   	lahf
    3301:	1f                   	(bad)
    3302:	00 00                	add    %al,(%rax)
    3304:	48 04 af             	rex.W add $0xaf,%al
    3307:	1f                   	(bad)
    3308:	00 00                	add    %al,(%rax)
    330a:	00 00                	add    %al,(%rax)
    330c:	00 39                	add    %bh,(%rcx)
    330e:	cd 0c                	int    $0xc
    3310:	00 00                	add    %al,(%rax)
    3312:	19 00                	sbb    %eax,(%rax)
    3314:	43 04 0c             	rex.XB add $0xc,%al
    3317:	3a 1c d6             	cmp    (%rsi,%rdx,8),%bl
    331a:	0c 00                	or     $0x0,%al
    331c:	00 3a                	add    %bh,(%rdx)
    331e:	1d df 0c 00 00       	sbb    $0xcdf,%eax
    3323:	3a 1e                	cmp    (%rsi),%bl
    3325:	e8 0c 00 00 3b       	call   3b003336 <_license+0x3b000f09>
    332a:	02 91 10 f1 0c 00    	add    0xcf110(%rcx),%dl
    3330:	00 3b                	add    %bh,(%rbx)
    3332:	03 91 e0 00 fa 0c    	add    0xcfa00e0(%rcx),%edx
    3338:	00 00                	add    %al,(%rax)
    333a:	3c 1f                	cmp    $0x1f,%al
    333c:	03 0d 00 00 3c 20    	add    0x203c0000(%rip),%ecx        # 203c3342 <_license+0x203c0f15>
    3342:	0c 0d                	or     $0xd,%al
    3344:	00 00                	add    %al,(%rax)
    3346:	3c 21                	cmp    $0x21,%al
    3348:	15 0d 00 00 3c       	adc    $0x3c00000d,%eax
    334d:	22 1e                	and    (%rsi),%bl
    334f:	0d 00 00 3c 23       	or     $0x233c0000,%eax
    3354:	27                   	(bad)
    3355:	0d 00 00 3c 2f       	or     $0x2f3c0000,%eax
    335a:	30 0d 00 00 3c 30    	xor    %cl,0x303c0000(%rip)        # 303c3360 <_license+0x303c0f33>
    3360:	39 0d 00 00 3c 79    	cmp    %ecx,0x793c0000(%rip)        # 793c3366 <_license+0x793c0f39>
    3366:	42 0d 00 00 3c 7a    	rex.X or $0x7a3c0000,%eax
    336c:	4b 0d 00 00 3c 7c    	rex.WXB or $0x7c3c0000,%rax
    3372:	54                   	push   %rsp
    3373:	0d 00 00 3c 7e       	or     $0x7e3c0000,%eax
    3378:	5d                   	pop    %rbp
    3379:	0d 00 00 3c 86       	or     $0x863c0000,%eax
    337e:	01 66 0d             	add    %esp,0xd(%rsi)
    3381:	00 00                	add    %al,(%rax)
    3383:	3c 92                	cmp    $0x92,%al
    3385:	03 78 0d             	add    0xd(%rax),%edi
    3388:	00 00                	add    %al,(%rax)
    338a:	39 47 11             	cmp    %eax,0x11(%rdi)
    338d:	00 00                	add    %al,(%rax)
    338f:	1a 00                	sbb    (%rax),%al
    3391:	ba 02 0c 3a 24       	mov    $0x243a0c02,%edx
    3396:	50                   	push   %rax
    3397:	11 00                	adc    %eax,(%rax)
    3399:	00 3a                	add    %bh,(%rdx)
    339b:	25 62 11 00 00       	and    $0x1162,%eax
    33a0:	3a 26                	cmp    (%rsi),%ah
    33a2:	7d 11                	jge    33b5 <_license+0xf88>
    33a4:	00 00                	add    %al,(%rax)
    33a6:	3a 27                	cmp    (%rdi),%ah
    33a8:	86 11                	xchg   %dl,(%rcx)
    33aa:	00 00                	add    %al,(%rax)
    33ac:	3a 28                	cmp    (%rax),%ch
    33ae:	8f                   	(bad)
    33af:	11 00                	adc    %eax,(%rax)
    33b1:	00 3c 29             	add    %bh,(%rcx,%rbp,1)
    33b4:	a1 11 00 00 3c 2a aa 	movabs 0x11aa2a3c000011,%eax
    33bb:	11 00 
    33bd:	00 00                	add    %al,(%rax)
    33bf:	39 d9                	cmp    %ebx,%ecx
    33c1:	12 00                	adc    (%rax),%al
    33c3:	00 1b                	add    %bl,(%rbx)
    33c5:	00 bf 02 0c 3a 31    	add    %bh,0x313a0c02(%rdi)
    33cb:	e2 12                	loop   33df <_license+0xfb2>
    33cd:	00 00                	add    %al,(%rax)
    33cf:	3a 32                	cmp    (%rdx),%dh
    33d1:	eb 12                	jmp    33e5 <_license+0xfb8>
    33d3:	00 00                	add    %al,(%rax)
    33d5:	3a 33                	cmp    (%rbx),%dh
    33d7:	f4                   	hlt
    33d8:	12 00                	adc    (%rax),%al
    33da:	00 3a                	add    %bh,(%rdx)
    33dc:	34 fd                	xor    $0xfd,%al
    33de:	12 00                	adc    (%rax),%al
    33e0:	00 3a                	add    %bh,(%rdx)
    33e2:	35 06 13 00 00       	xor    $0x1306,%eax
    33e7:	39 78 13             	cmp    %edi,0x13(%rax)
    33ea:	00 00                	add    %al,(%rax)
    33ec:	1c 0e                	sbb    $0xe,%al
    33ee:	5a                   	pop    %rdx
    33ef:	01 0c 3a             	add    %ecx,(%rdx,%rdi,1)
    33f2:	2b 80 13 00 00 3a    	sub    0x3a000013(%rax),%eax
    33f8:	2c 88                	sub    $0x88,%al
    33fa:	13 00                	adc    (%rax),%eax
    33fc:	00 3a                	add    %bh,(%rdx)
    33fe:	52                   	push   %rdx
    33ff:	90                   	nop
    3400:	13 00                	adc    (%rax),%eax
    3402:	00 3a                	add    %bh,(%rdx)
    3404:	2d 98 13 00 00       	sub    $0x1398,%eax
    3409:	3c 2e                	cmp    $0x2e,%al
    340b:	a0 13 00 00 3c 53 a8 	movabs 0x13a8533c000013,%al
    3412:	13 00 
    3414:	00 41 5b             	add    %al,0x5b(%rcx)
    3417:	2f                   	(bad)
    3418:	00 00                	add    %al,(%rax)
    341a:	00 3f                	add    %bh,(%rdi)
    341c:	8c 04 b1             	mov    %es,(%rcx,%rsi,4)
    341f:	13 00                	adc    (%rax),%eax
    3421:	00 3c 50             	add    %bh,(%rax,%rdx,2)
    3424:	b9 13 00 00 3c       	mov    $0x3c000013,%ecx
    3429:	51                   	push   %rcx
    342a:	c2 13 00             	ret    $0x13
    342d:	00 41 5b             	add    %al,0x5b(%rcx)
    3430:	10 00                	adc    %al,(%rax)
    3432:	00 00                	add    %al,(%rax)
    3434:	3c 4f                	cmp    $0x4f,%al
    3436:	cb                   	lret
    3437:	13 00                	adc    (%rax),%eax
    3439:	00 42 06             	add    %al,0x6(%rdx)
    343c:	d3 13                	rcll   %cl,(%rbx)
    343e:	00 00                	add    %al,(%rax)
    3440:	41 5b                	pop    %r11
    3442:	10 00                	adc    %al,(%rax)
    3444:	00 00                	add    %al,(%rax)
    3446:	3f                   	(bad)
    3447:	8c 04 dc             	mov    %es,(%rsp,%rbx,8)
    344a:	13 00                	adc    (%rax),%eax
    344c:	00 3f                	add    %bh,(%rdi)
    344e:	80 08 e4             	orb    $0xe4,(%rax)
    3451:	13 00                	adc    (%rax),%eax
    3453:	00 3f                	add    %bh,(%rdi)
    3455:	08 ec                	or     %ch,%ah
    3457:	13 00                	adc    (%rax),%eax
    3459:	00 00                	add    %al,(%rax)
    345b:	00 00                	add    %al,(%rax)
    345d:	00 39                	add    %bh,(%rcx)
    345f:	b9 11 00 00 1d       	mov    $0x1d000011,%ecx
    3464:	0e                   	(bad)
    3465:	5c                   	pop    %rsp
    3466:	01 0c 3a             	add    %ecx,(%rdx,%rdi,1)
    3469:	36 c2 11 00          	ss ret $0x11
    346d:	00 3a                	add    %bh,(%rdx)
    346f:	37                   	(bad)
    3470:	cb                   	lret
    3471:	11 00                	adc    %eax,(%rax)
    3473:	00 3a                	add    %bh,(%rdx)
    3475:	38 d4                	cmp    %dl,%ah
    3477:	11 00                	adc    %eax,(%rax)
    3479:	00 3a                	add    %bh,(%rdx)
    347b:	39 dd                	cmp    %ebx,%ebp
    347d:	11 00                	adc    %eax,(%rax)
    347f:	00 3c 3a             	add    %bh,(%rdx,%rdi,1)
    3482:	e6 11                	out    %al,$0x11
    3484:	00 00                	add    %al,(%rax)
    3486:	3c 76                	cmp    $0x76,%al
    3488:	ef                   	out    %eax,(%dx)
    3489:	11 00                	adc    %eax,(%rax)
    348b:	00 3d 10 13 00 00    	add    %bh,0x1310(%rip)        # 47a1 <_license+0x2374>
    3491:	5c                   	pop    %rsp
    3492:	67 00 00             	add    %al,(%eax)
    3495:	00 0e                	add    %cl,(%rsi)
    3497:	1f                   	(bad)
    3498:	01 0c 3e             	add    %ecx,(%rsi,%rdi,1)
    349b:	01 53 18             	add    %edx,0x18(%rbx)
    349e:	13 00                	adc    (%rax),%eax
    34a0:	00 3e                	add    %bh,(%rsi)
    34a2:	01 5c 20 13          	add    %ebx,0x13(%rax,%riz,1)
    34a6:	00 00                	add    %al,(%rax)
    34a8:	3c 3b                	cmp    $0x3b,%al
    34aa:	28 13                	sub    %dl,(%rbx)
    34ac:	00 00                	add    %al,(%rax)
    34ae:	3f                   	(bad)
    34af:	00 30                	add    %dh,(%rax)
    34b1:	13 00                	adc    (%rax),%eax
    34b3:	00 3c 3c             	add    %bh,(%rsp,%rdi,1)
    34b6:	38 13                	cmp    %dl,(%rbx)
    34b8:	00 00                	add    %al,(%rax)
    34ba:	3c 3d                	cmp    $0x3d,%al
    34bc:	40 13 00             	rex adc (%rax),%eax
    34bf:	00 40 51             	add    %al,0x51(%rax)
    34c2:	13 00                	adc    (%rax),%eax
    34c4:	00 5d 3c             	add    %bl,0x3c(%rbp)
    34c7:	00 00                	add    %al,(%rax)
    34c9:	00 0e                	add    %cl,(%rsi)
    34cb:	59                   	pop    %rcx
    34cc:	03 3c 3f             	add    (%rdi,%rdi,1),%edi
    34cf:	65 13 00             	adc    %gs:(%rax),%eax
    34d2:	00 41 5d             	add    %al,0x5d(%rcx)
    34d5:	3c 00                	cmp    $0x0,%al
    34d7:	00 00                	add    %al,(%rax)
    34d9:	3c 3e                	cmp    $0x3e,%al
    34db:	6e                   	outsb  %ds:(%rsi),(%dx)
    34dc:	13 00                	adc    (%rax),%eax
    34de:	00 00                	add    %al,(%rax)
    34e0:	00 00                	add    %al,(%rax)
    34e2:	41 5e                	pop    %r14
    34e4:	28 00                	sub    %al,(%rax)
    34e6:	00 00                	add    %al,(%rax)
    34e8:	3f                   	(bad)
    34e9:	8d 04 f9             	lea    (%rcx,%rdi,8),%eax
    34ec:	11 00                	adc    %eax,(%rax)
    34ee:	00 3c 75 02 12 00 00 	add    %bh,0x1202(,%rsi,2)
    34f5:	41 5e                	pop    %r14
    34f7:	10 00                	adc    %al,(%rax)
    34f9:	00 00                	add    %al,(%rax)
    34fb:	3c 74                	cmp    $0x74,%al
    34fd:	15 12 00 00 42       	adc    $0x42000012,%eax
    3502:	06                   	(bad)
    3503:	1e                   	(bad)
    3504:	12 00                	adc    (%rax),%al
    3506:	00 41 5e             	add    %al,0x5e(%rcx)
    3509:	10 00                	adc    %al,(%rax)
    350b:	00 00                	add    %al,(%rax)
    350d:	3f                   	(bad)
    350e:	8d 04 28             	lea    (%rax,%rbp,1),%eax
    3511:	12 00                	adc    (%rax),%al
    3513:	00 3f                	add    %bh,(%rdi)
    3515:	80 08 31             	orb    $0x31,(%rax)
    3518:	12 00                	adc    (%rax),%al
    351a:	00 3f                	add    %bh,(%rdi)
    351c:	08 3a                	or     %bh,(%rdx)
    351e:	12 00                	adc    (%rax),%al
    3520:	00 00                	add    %al,(%rax)
    3522:	00 00                	add    %al,(%rax)
    3524:	00 00                	add    %al,(%rax)
    3526:	3d 2a 15 00 00       	cmp    $0x152a,%eax
    352b:	5f                   	pop    %rdi
    352c:	2a 00                	sub    (%rax),%al
    352e:	00 00                	add    %al,(%rax)
    3530:	00 f3                	add    %dh,%bl
    3532:	02 0a                	add    (%rdx),%cl
    3534:	3e 01 53 33          	ds add %edx,0x33(%rbx)
    3538:	15 00 00 3e 01       	adc    $0x13e0000,%eax
    353d:	5c                   	pop    %rsp
    353e:	3b 15 00 00 3e 02    	cmp    0x23e0000(%rip),%edx        # 23e3544 <_license+0x23e1117>
    3544:	31 9f 43 15 00 00    	xor    %ebx,0x1543(%rdi)
    354a:	3e 03 91 10 9f 4b 15 	ds add 0x154b9f10(%rcx),%edx
    3551:	00 00                	add    %al,(%rax)
    3553:	3b 11                	cmp    (%rcx),%edx
    3555:	72 00                	jb     3557 <_license+0x112a>
    3557:	10 ff                	adc    %bh,%bh
    3559:	01 1a                	add    %ebx,(%rdx)
    355b:	a8 ba                	test   $0xba,%al
    355d:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    3564:	00 9f 53 15 00 00    	add    %bl,0x1553(%rdi)
    356a:	3c 41                	cmp    $0x41,%al
    356c:	5b                   	pop    %rbx
    356d:	15 00 00 40 4d       	adc    $0x4d400000,%eax
    3572:	16                   	(bad)
    3573:	00 00                	add    %al,(%rax)
    3575:	60                   	(bad)
    3576:	02 00                	add    (%rax),%al
    3578:	00 00                	add    %al,(%rax)
    357a:	0c 7b                	or     $0x7b,%al
    357c:	0f 3e                	(bad)
    357e:	02 31                	add    (%rcx),%dh
    3580:	9f                   	lahf
    3581:	56                   	push   %rsi
    3582:	16                   	(bad)
    3583:	00 00                	add    %al,(%rax)
    3585:	3e 11 72 00          	ds adc %esi,0x0(%rdx)
    3589:	10 ff                	adc    %bh,%bh
    358b:	01 1a                	add    %ebx,(%rdx)
    358d:	a8 ba                	test   $0xba,%al
    358f:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    3596:	00 9f 5e 16 00 00    	add    %bl,0x165e(%rdi)
    359c:	00 00                	add    %al,(%rax)
    359e:	3d 0f 19 00 00       	cmp    $0x190f,%eax
    35a3:	61                   	(bad)
    35a4:	17                   	(bad)
    35a5:	00 00                	add    %al,(%rax)
    35a7:	00 00                	add    %al,(%rax)
    35a9:	f7 02 0a 3e 01 53    	testl  $0x53013e0a,(%rdx)
    35af:	18 19                	sbb    %bl,(%rcx)
    35b1:	00 00                	add    %al,(%rax)
    35b3:	3e 01 5c 20 19       	ds add %ebx,0x19(%rax,%riz,1)
    35b8:	00 00                	add    %al,(%rax)
    35ba:	3e 02 31             	ds add (%rcx),%dh
    35bd:	9f                   	lahf
    35be:	28 19                	sub    %bl,(%rcx)
    35c0:	00 00                	add    %al,(%rax)
    35c2:	3e 03 91 10 9f 30 19 	ds add 0x19309f10(%rcx),%edx
    35c9:	00 00                	add    %al,(%rax)
    35cb:	3b 11                	cmp    (%rcx),%edx
    35cd:	72 00                	jb     35cf <_license+0x11a2>
    35cf:	10 ff                	adc    %bh,%bh
    35d1:	01 1a                	add    %ebx,(%rdx)
    35d3:	a8 ba                	test   $0xba,%al
    35d5:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    35dc:	00 9f 38 19 00 00    	add    %bl,0x1938(%rdi)
    35e2:	3c 73                	cmp    $0x73,%al
    35e4:	40 19 00             	rex sbb %eax,(%rax)
    35e7:	00 40 4d             	add    %al,0x4d(%rax)
    35ea:	16                   	(bad)
    35eb:	00 00                	add    %al,(%rax)
    35ed:	62 02                	(bad)
    35ef:	00 00                	add    %al,(%rax)
    35f1:	00 0c 61             	add    %cl,(%rcx,%riz,2)
    35f4:	0f 3e                	(bad)
    35f6:	02 31                	add    (%rcx),%dh
    35f8:	9f                   	lahf
    35f9:	56                   	push   %rsi
    35fa:	16                   	(bad)
    35fb:	00 00                	add    %al,(%rax)
    35fd:	3e 11 72 00          	ds adc %esi,0x0(%rdx)
    3601:	10 ff                	adc    %bh,%bh
    3603:	01 1a                	add    %ebx,(%rdx)
    3605:	a8 ba                	test   $0xba,%al
    3607:	80 80 00 a8 bf 80 80 	addb   $0x80,-0x7f405800(%rax)
    360e:	00 9f 5e 16 00 00    	add    %bl,0x165e(%rdi)
    3614:	00 00                	add    %al,(%rax)
    3616:	41 63 18             	movsxd (%r8),%ebx
    3619:	01 00                	add    %eax,(%rax)
    361b:	00 3c 54             	add    %bh,(%rsp,%rdx,2)
    361e:	9d                   	popf
    361f:	0d 00 00 39 a9       	or     $0xa9390000,%eax
    3624:	16                   	(bad)
    3625:	00 00                	add    %al,(%rax)
    3627:	1e                   	(bad)
    3628:	00 e9                	add    %ch,%cl
    362a:	02 0e                	add    (%rsi),%cl
    362c:	3a 55 b2             	cmp    -0x4e(%rbp),%dl
    362f:	16                   	(bad)
    3630:	00 00                	add    %al,(%rax)
    3632:	3a 56 ba             	cmp    -0x46(%rsi),%dl
    3635:	16                   	(bad)
    3636:	00 00                	add    %al,(%rax)
    3638:	3b 03                	cmp    (%rbx),%eax
    363a:	91                   	xchg   %eax,%ecx
    363b:	c0 00 ca             	rolb   $0xca,(%rax)
    363e:	16                   	(bad)
    363f:	00 00                	add    %al,(%rax)
    3641:	3c 5a                	cmp    $0x5a,%al
    3643:	d3 16                	rcll   %cl,(%rsi)
    3645:	00 00                	add    %al,(%rax)
    3647:	3c 5c                	cmp    $0x5c,%al
    3649:	dc 16                	fcoml  (%rsi)
    364b:	00 00                	add    %al,(%rax)
    364d:	41                   	rex.B
    364e:	64 18 00             	sbb    %al,%fs:(%rax)
    3651:	00 00                	add    %al,(%rax)
    3653:	3c 57                	cmp    $0x57,%al
    3655:	e5 16                	in     $0x16,%eax
    3657:	00 00                	add    %al,(%rax)
    3659:	42 01 ed             	rex.X add %ebp,%ebp
    365c:	16                   	(bad)
    365d:	00 00                	add    %al,(%rax)
    365f:	40 32 17             	rex xor (%rdi),%dl
    3662:	00 00                	add    %al,(%rax)
    3664:	64 18 00             	sbb    %al,%fs:(%rax)
    3667:	00 00                	add    %al,(%rax)
    3669:	00 d5                	add    %dl,%ch
    366b:	1c 3a                	sbb    $0x3a,%al
    366d:	58                   	pop    %rax
    366e:	3c 17                	cmp    $0x17,%al
    3670:	00 00                	add    %al,(%rax)
    3672:	3a 59 46             	cmp    0x46(%rcx),%bl
    3675:	17                   	(bad)
    3676:	00 00                	add    %al,(%rax)
    3678:	00 00                	add    %al,(%rax)
    367a:	41                   	rex.B
    367b:	65 1d 00 00 00 3f    	gs sbb $0x3f000000,%eax
    3681:	86 04 f7             	xchg   %al,(%rdi,%rsi,8)
    3684:	16                   	(bad)
    3685:	00 00                	add    %al,(%rax)
    3687:	41                   	rex.B
    3688:	65 10 00             	adc    %al,%gs:(%rax)
    368b:	00 00                	add    %al,(%rax)
    368d:	3c 5b                	cmp    $0x5b,%al
    368f:	00 17                	add    %dl,(%rdi)
    3691:	00 00                	add    %al,(%rax)
    3693:	42 06                	rex.X (bad)
    3695:	08 17                	or     %dl,(%rdi)
    3697:	00 00                	add    %al,(%rax)
    3699:	41                   	rex.B
    369a:	65 10 00             	adc    %al,%gs:(%rax)
    369d:	00 00                	add    %al,(%rax)
    369f:	3f                   	(bad)
    36a0:	86 04 11             	xchg   %al,(%rcx,%rdx,1)
    36a3:	17                   	(bad)
    36a4:	00 00                	add    %al,(%rax)
    36a6:	3f                   	(bad)
    36a7:	80 08 19             	orb    $0x19,(%rax)
    36aa:	17                   	(bad)
    36ab:	00 00                	add    %al,(%rax)
    36ad:	3f                   	(bad)
    36ae:	08 21                	or     %ah,(%rcx)
    36b0:	17                   	(bad)
    36b1:	00 00                	add    %al,(%rax)
    36b3:	00 00                	add    %al,(%rax)
    36b5:	00 00                	add    %al,(%rax)
    36b7:	39 95 17 00 00 1f    	cmp    %edx,0x1f000017(%rbp)
    36bd:	00 ed                	add    %ch,%ch
    36bf:	02 0c 3e             	add    (%rsi,%rdi,1),%cl
    36c2:	01 5d b1             	add    %ebx,-0x4f(%rbp)
    36c5:	17                   	(bad)
    36c6:	00 00                	add    %al,(%rax)
    36c8:	3c 5d                	cmp    $0x5d,%al
    36ca:	d5                   	(bad)
    36cb:	17                   	(bad)
    36cc:	00 00                	add    %al,(%rax)
    36ce:	3c 5e                	cmp    $0x5e,%al
    36d0:	de 17                	ficoms (%rdi)
    36d2:	00 00                	add    %al,(%rax)
    36d4:	3c 60                	cmp    $0x60,%al
    36d6:	e7 17                	out    %eax,$0x17
    36d8:	00 00                	add    %al,(%rax)
    36da:	41                   	rex.B
    36db:	66 61                	data16 (bad)
    36dd:	00 00                	add    %al,(%rax)
    36df:	00 42 36             	add    %al,0x36(%rdx)
    36e2:	f1                   	int1
    36e3:	17                   	(bad)
    36e4:	00 00                	add    %al,(%rax)
    36e6:	3d 50 17 00 00       	cmp    $0x1750,%eax
    36eb:	66 27                	data16 (bad)
    36ed:	00 00                	add    %al,(%rax)
    36ef:	00 00                	add    %al,(%rax)
    36f1:	4f 01 0e             	rex.WRXB add %r9,(%r14)
    36f4:	3e 01 53 59          	ds add %edx,0x59(%rbx)
    36f8:	17                   	(bad)
    36f9:	00 00                	add    %al,(%rax)
    36fb:	3e 01 5c 61 17       	ds add %ebx,0x17(%rcx,%riz,2)
    3700:	00 00                	add    %al,(%rax)
    3702:	44                   	rex.R
    3703:	36 69 17 00 00 3e 02 	ss imul $0x23e0000,(%rdi),%edx
    370a:	31 9f 72 17 00 00    	xor    %ebx,0x1772(%rdi)
    3710:	00 3d 9c 18 00 00    	add    %bh,0x189c(%rip)        # 4fb2 <_license+0x2b85>
    3716:	67 3a 00             	cmp    (%eax),%al
    3719:	00 00                	add    %al,(%rax)
    371b:	00 50 01             	add    %dl,0x1(%rax)
    371e:	0a 3e                	or     (%rsi),%bh
    3720:	01 5d a5             	add    %ebx,-0x5b(%rbp)
    3723:	18 00                	sbb    %al,(%rax)
    3725:	00 3e                	add    %bh,(%rsi)
    3727:	02 30                	add    (%rax),%dh
    3729:	9f                   	lahf
    372a:	bd 18 00 00 3b       	mov    $0x3b000018,%ebp
    372f:	01 53 c6             	add    %edx,-0x3a(%rbx)
    3732:	18 00                	sbb    %al,(%rax)
    3734:	00 3b                	add    %bh,(%rbx)
    3736:	03 73 28             	add    0x28(%rbx),%esi
    3739:	9f                   	lahf
    373a:	cf                   	iret
    373b:	18 00                	sbb    %al,(%rax)
    373d:	00 00                	add    %al,(%rax)
    373f:	00 41 68             	add    %al,0x68(%rcx)
    3742:	10 00                	adc    %al,(%rax)
    3744:	00 00                	add    %al,(%rax)
    3746:	3c 5f                	cmp    $0x5f,%al
    3748:	15 18 00 00 42       	adc    $0x42000018,%eax
    374d:	06                   	(bad)
    374e:	1e                   	(bad)
    374f:	18 00                	sbb    %al,(%rax)
    3751:	00 41 68             	add    %al,0x68(%rcx)
    3754:	10 00                	adc    %al,(%rax)
    3756:	00 00                	add    %al,(%rax)
    3758:	3f                   	(bad)
    3759:	8a 04 28             	mov    (%rax,%rbp,1),%al
    375c:	18 00                	sbb    %al,(%rax)
    375e:	00 3f                	add    %bh,(%rdi)
    3760:	80 08 31             	orb    $0x31,(%rax)
    3763:	18 00                	sbb    %al,(%rax)
    3765:	00 3f                	add    %bh,(%rdi)
    3767:	08 3a                	or     %bh,(%rdx)
    3769:	18 00                	sbb    %al,(%rax)
    376b:	00 00                	add    %al,(%rax)
    376d:	00 41 69             	add    %al,0x69(%rcx)
    3770:	19 00                	sbb    %eax,(%rax)
    3772:	00 00                	add    %al,(%rax)
    3774:	3f                   	(bad)
    3775:	8e 04 46             	mov    (%rsi,%rax,2),%es
    3778:	18 00                	sbb    %al,(%rax)
    377a:	00 3c 62             	add    %bh,(%rdx,%riz,2)
    377d:	50                   	push   %rax
    377e:	18 00                	sbb    %al,(%rax)
    3780:	00 41 69             	add    %al,0x69(%rcx)
    3783:	10 00                	adc    %al,(%rax)
    3785:	00 00                	add    %al,(%rax)
    3787:	3c 61                	cmp    $0x61,%al
    3789:	65 18 00             	sbb    %al,%gs:(%rax)
    378c:	00 42 06             	add    %al,0x6(%rdx)
    378f:	6e                   	outsb  %ds:(%rsi),(%dx)
    3790:	18 00                	sbb    %al,(%rax)
    3792:	00 41 69             	add    %al,0x69(%rcx)
    3795:	10 00                	adc    %al,(%rax)
    3797:	00 00                	add    %al,(%rax)
    3799:	3f                   	(bad)
    379a:	8e 04 78             	mov    (%rax,%rdi,2),%es
    379d:	18 00                	sbb    %al,(%rax)
    379f:	00 3f                	add    %bh,(%rdi)
    37a1:	80 08 81             	orb    $0x81,(%rax)
    37a4:	18 00                	sbb    %al,(%rax)
    37a6:	00 3f                	add    %bh,(%rdi)
    37a8:	08 8a 18 00 00 00    	or     %cl,0x18(%rdx)
    37ae:	00 00                	add    %al,(%rax)
    37b0:	00 00                	add    %al,(%rax)
    37b2:	41 6a 30             	rex.B push $0x30
    37b5:	01 00                	add    %eax,(%rax)
    37b7:	00 3c 63             	add    %bh,(%rbx,%riz,2)
    37ba:	a8 0d                	test   $0xd,%al
    37bc:	00 00                	add    %al,(%rax)
    37be:	39 a9 16 00 00 20    	cmp    %ebp,0x20000016(%rcx)
    37c4:	00 e1                	add    %ah,%cl
    37c6:	02 0e                	add    (%rsi),%cl
    37c8:	3a 64 b2 16          	cmp    0x16(%rdx,%rsi,4),%ah
    37cc:	00 00                	add    %al,(%rax)
    37ce:	3a 65 ba             	cmp    -0x46(%rbp),%ah
    37d1:	16                   	(bad)
    37d2:	00 00                	add    %al,(%rax)
    37d4:	3b 03                	cmp    (%rbx),%eax
    37d6:	91                   	xchg   %eax,%ecx
    37d7:	c0 00 ca             	rolb   $0xca,(%rax)
    37da:	16                   	(bad)
    37db:	00 00                	add    %al,(%rax)
    37dd:	3c 69                	cmp    $0x69,%al
    37df:	d3 16                	rcll   %cl,(%rsi)
    37e1:	00 00                	add    %al,(%rax)
    37e3:	3c 6b                	cmp    $0x6b,%al
    37e5:	dc 16                	fcoml  (%rsi)
    37e7:	00 00                	add    %al,(%rax)
    37e9:	41 6b 18 00          	imul   $0x0,(%r8),%ebx
    37ed:	00 00                	add    %al,(%rax)
    37ef:	3c 66                	cmp    $0x66,%al
    37f1:	e5 16                	in     $0x16,%eax
    37f3:	00 00                	add    %al,(%rax)
    37f5:	42 01 ed             	rex.X add %ebp,%ebp
    37f8:	16                   	(bad)
    37f9:	00 00                	add    %al,(%rax)
    37fb:	40 32 17             	rex xor (%rdi),%dl
    37fe:	00 00                	add    %al,(%rax)
    3800:	6b 18 00             	imul   $0x0,(%rax),%ebx
    3803:	00 00                	add    %al,(%rax)
    3805:	00 d5                	add    %dl,%ch
    3807:	1c 3a                	sbb    $0x3a,%al
    3809:	67 3c 17             	addr32 cmp $0x17,%al
    380c:	00 00                	add    %al,(%rax)
    380e:	3a 68 46             	cmp    0x46(%rax),%ch
    3811:	17                   	(bad)
    3812:	00 00                	add    %al,(%rax)
    3814:	00 00                	add    %al,(%rax)
    3816:	41 6c                	rex.B insb (%dx),%es:(%rdi)
    3818:	1d 00 00 00 3f       	sbb    $0x3f000000,%eax
    381d:	86 04 f7             	xchg   %al,(%rdi,%rsi,8)
    3820:	16                   	(bad)
    3821:	00 00                	add    %al,(%rax)
    3823:	41 6c                	rex.B insb (%dx),%es:(%rdi)
    3825:	10 00                	adc    %al,(%rax)
    3827:	00 00                	add    %al,(%rax)
    3829:	3c 6a                	cmp    $0x6a,%al
    382b:	00 17                	add    %dl,(%rdi)
    382d:	00 00                	add    %al,(%rax)
    382f:	42 06                	rex.X (bad)
    3831:	08 17                	or     %dl,(%rdi)
    3833:	00 00                	add    %al,(%rax)
    3835:	41 6c                	rex.B insb (%dx),%es:(%rdi)
    3837:	10 00                	adc    %al,(%rax)
    3839:	00 00                	add    %al,(%rax)
    383b:	3f                   	(bad)
    383c:	86 04 11             	xchg   %al,(%rcx,%rdx,1)
    383f:	17                   	(bad)
    3840:	00 00                	add    %al,(%rax)
    3842:	3f                   	(bad)
    3843:	80 08 19             	orb    $0x19,(%rax)
    3846:	17                   	(bad)
    3847:	00 00                	add    %al,(%rax)
    3849:	3f                   	(bad)
    384a:	08 21                	or     %ah,(%rcx)
    384c:	17                   	(bad)
    384d:	00 00                	add    %al,(%rax)
    384f:	00 00                	add    %al,(%rax)
    3851:	00 00                	add    %al,(%rax)
    3853:	39 95 17 00 00 21    	cmp    %edx,0x21000017(%rbp)
    3859:	00 e5                	add    %ah,%ch
    385b:	02 0c 3e             	add    (%rsi,%rdi,1),%cl
    385e:	01 5d b1             	add    %ebx,-0x4f(%rbp)
    3861:	17                   	(bad)
    3862:	00 00                	add    %al,(%rax)
    3864:	3c 6d                	cmp    $0x6d,%al
    3866:	d5                   	(bad)
    3867:	17                   	(bad)
    3868:	00 00                	add    %al,(%rax)
    386a:	3c 6e                	cmp    $0x6e,%al
    386c:	de 17                	ficoms (%rdi)
    386e:	00 00                	add    %al,(%rax)
    3870:	3c 70                	cmp    $0x70,%al
    3872:	e7 17                	out    %eax,$0x17
    3874:	00 00                	add    %al,(%rax)
    3876:	41 6d                	rex.B insl (%dx),%es:(%rdi)
    3878:	74 00                	je     387a <_license+0x144d>
    387a:	00 00                	add    %al,(%rax)
    387c:	42                   	rex.X
    387d:	36 fd                	ss std
    387f:	17                   	(bad)
    3880:	00 00                	add    %al,(%rax)
    3882:	3d 50 17 00 00       	cmp    $0x1750,%eax
    3887:	6d                   	insl   (%dx),%es:(%rdi)
    3888:	3a 00                	cmp    (%rax),%al
    388a:	00 00                	add    %al,(%rax)
    388c:	00 3b                	add    %bh,(%rbx)
    388e:	01 10                	add    %edx,(%rax)
    3890:	3e 01 53 59          	ds add %edx,0x59(%rbx)
    3894:	17                   	(bad)
    3895:	00 00                	add    %al,(%rax)
    3897:	3e 01 5c 61 17       	ds add %ebx,0x17(%rcx,%riz,2)
    389c:	00 00                	add    %al,(%rax)
    389e:	44                   	rex.R
    389f:	36 69 17 00 00 3e 02 	ss imul $0x23e0000,(%rdi),%edx
    38a6:	30 9f 72 17 00 00    	xor    %bl,0x1772(%rdi)
    38ac:	41 6d                	rex.B insl (%dx),%es:(%rdi)
    38ae:	3a 00                	cmp    (%rax),%al
    38b0:	00 00                	add    %al,(%rax)
    38b2:	3c 6c                	cmp    $0x6c,%al
    38b4:	8b 17                	mov    (%rdi),%edx
    38b6:	00 00                	add    %al,(%rax)
    38b8:	00 00                	add    %al,(%rax)
    38ba:	3d 9c 18 00 00       	cmp    $0x189c,%eax
    38bf:	6e                   	outsb  %ds:(%rsi),(%dx)
    38c0:	3a 00                	cmp    (%rax),%al
    38c2:	00 00                	add    %al,(%rax)
    38c4:	00 3c 01             	add    %bh,(%rcx,%rax,1)
    38c7:	0c 3e                	or     $0x3e,%al
    38c9:	01 5d a5             	add    %ebx,-0x5b(%rbp)
    38cc:	18 00                	sbb    %al,(%rax)
    38ce:	00 3e                	add    %bh,(%rsi)
    38d0:	02 31                	add    (%rcx),%dh
    38d2:	9f                   	lahf
    38d3:	bd 18 00 00 3b       	mov    $0x3b000018,%ebp
    38d8:	01 53 c6             	add    %edx,-0x3a(%rbx)
    38db:	18 00                	sbb    %al,(%rax)
    38dd:	00 3b                	add    %bh,(%rbx)
    38df:	03 73 28             	add    0x28(%rbx),%esi
    38e2:	9f                   	lahf
    38e3:	cf                   	iret
    38e4:	18 00                	sbb    %al,(%rax)
    38e6:	00 00                	add    %al,(%rax)
    38e8:	00 41 6f             	add    %al,0x6f(%rcx)
    38eb:	10 00                	adc    %al,(%rax)
    38ed:	00 00                	add    %al,(%rax)
    38ef:	3c 6f                	cmp    $0x6f,%al
    38f1:	15 18 00 00 42       	adc    $0x42000018,%eax
    38f6:	06                   	(bad)
    38f7:	1e                   	(bad)
    38f8:	18 00                	sbb    %al,(%rax)
    38fa:	00 41 6f             	add    %al,0x6f(%rcx)
    38fd:	10 00                	adc    %al,(%rax)
    38ff:	00 00                	add    %al,(%rax)
    3901:	3f                   	(bad)
    3902:	8a 04 28             	mov    (%rax,%rbp,1),%al
    3905:	18 00                	sbb    %al,(%rax)
    3907:	00 3f                	add    %bh,(%rdi)
    3909:	80 08 31             	orb    $0x31,(%rax)
    390c:	18 00                	sbb    %al,(%rax)
    390e:	00 3f                	add    %bh,(%rdi)
    3910:	08 3a                	or     %bh,(%rdx)
    3912:	18 00                	sbb    %al,(%rax)
    3914:	00 00                	add    %al,(%rax)
    3916:	00 41 70             	add    %al,0x70(%rcx)
    3919:	1e                   	(bad)
    391a:	00 00                	add    %al,(%rax)
    391c:	00 3f                	add    %bh,(%rdi)
    391e:	8e 04 46             	mov    (%rsi,%rax,2),%es
    3921:	18 00                	sbb    %al,(%rax)
    3923:	00 3c 72             	add    %bh,(%rdx,%rsi,2)
    3926:	50                   	push   %rax
    3927:	18 00                	sbb    %al,(%rax)
    3929:	00 41 70             	add    %al,0x70(%rcx)
    392c:	10 00                	adc    %al,(%rax)
    392e:	00 00                	add    %al,(%rax)
    3930:	3c 71                	cmp    $0x71,%al
    3932:	65 18 00             	sbb    %al,%gs:(%rax)
    3935:	00 42 06             	add    %al,0x6(%rdx)
    3938:	6e                   	outsb  %ds:(%rsi),(%dx)
    3939:	18 00                	sbb    %al,(%rax)
    393b:	00 41 70             	add    %al,0x70(%rcx)
    393e:	10 00                	adc    %al,(%rax)
    3940:	00 00                	add    %al,(%rax)
    3942:	3f                   	(bad)
    3943:	8e 04 78             	mov    (%rax,%rdi,2),%es
    3946:	18 00                	sbb    %al,(%rax)
    3948:	00 3f                	add    %bh,(%rdi)
    394a:	80 08 81             	orb    $0x81,(%rax)
    394d:	18 00                	sbb    %al,(%rax)
    394f:	00 3f                	add    %bh,(%rdi)
    3951:	08 8a 18 00 00 00    	or     %cl,0x18(%rdx)
    3957:	00 00                	add    %al,(%rax)
    3959:	00 00                	add    %al,(%rax)
    395b:	41 71 1b             	rex.B jno 3979 <_license+0x154c>
    395e:	00 00                	add    %al,(%rax)
    3960:	00 3c 77             	add    %bh,(%rdi,%rsi,2)
    3963:	b3 0d                	mov    $0xd,%bl
    3965:	00 00                	add    %al,(%rax)
    3967:	42 01 bc 0d 00 00 3d 	add    %edi,0x323d0000(%rbp,%r9,1)
    396e:	32 
    396f:	17                   	(bad)
    3970:	00 00                	add    %al,(%rax)
    3972:	71 1b                	jno    398f <_license+0x1562>
    3974:	00 00                	add    %al,(%rax)
    3976:	00 00                	add    %al,(%rax)
    3978:	12 03                	adc    (%rbx),%al
    397a:	0e                   	(bad)
    397b:	3a 78 3c             	cmp    0x3c(%rax),%bh
    397e:	17                   	(bad)
    397f:	00 00                	add    %al,(%rax)
    3981:	00 00                	add    %al,(%rax)
    3983:	41 72 0e             	rex.B jb 3994 <_license+0x1567>
    3986:	00 00                	add    %al,(%rax)
    3988:	00 3c 8a             	add    %bh,(%rdx,%rcx,4)
    398b:	01 c7                	add    %eax,%edi
    398d:	0d 00 00 42 01       	or     $0x1420000,%eax
    3992:	d0 0d 00 00 46 32    	rorb   0x32460000(%rip)        # 32463998 <_license+0x3246156b>
    3998:	17                   	(bad)
    3999:	00 00                	add    %al,(%rax)
    399b:	72 0e                	jb     39ab <_license+0x157e>
    399d:	00 00                	add    %al,(%rax)
    399f:	00 00                	add    %al,(%rax)
    39a1:	15 03 10 00 41       	adc    $0x41001003,%eax
    39a6:	73 10                	jae    39b8 <_license+0x158b>
    39a8:	00 00                	add    %al,(%rax)
    39aa:	00 3c 7b             	add    %bh,(%rbx,%rdi,2)
    39ad:	db 0d 00 00 42 06    	fisttpl 0x6420000(%rip)        # 64239b3 <_license+0x6421586>
    39b3:	e4 0d                	in     $0xd,%al
    39b5:	00 00                	add    %al,(%rax)
    39b7:	41 73 10             	rex.B jae 39ca <_license+0x159d>
    39ba:	00 00                	add    %al,(%rax)
    39bc:	00 3f                	add    %bh,(%rdi)
    39be:	80 04 ee 0d          	addb   $0xd,(%rsi,%rbp,8)
    39c2:	00 00                	add    %al,(%rax)
    39c4:	3f                   	(bad)
    39c5:	80 08 f7             	orb    $0xf7,(%rax)
    39c8:	0d 00 00 3f 08       	or     $0x83f0000,%eax
    39cd:	00 0e                	add    %cl,(%rsi)
    39cf:	00 00                	add    %al,(%rax)
    39d1:	00 00                	add    %al,(%rax)
    39d3:	41 74 0c             	rex.B je 39e2 <_license+0x15b5>
    39d6:	00 00                	add    %al,(%rax)
    39d8:	00 3c 7d 0c 0e 00 00 	add    %bh,0xe0c(,%rdi,2)
    39df:	00 43 22             	add    %al,0x22(%rbx)
    39e2:	3c 80                	cmp    $0x80,%al
    39e4:	01 17                	add    %edx,(%rdi)
    39e6:	0e                   	(bad)
    39e7:	00 00                	add    %al,(%rax)
    39e9:	3c 81                	cmp    $0x81,%al
    39eb:	01 20                	add    %esp,(%rax)
    39ed:	0e                   	(bad)
    39ee:	00 00                	add    %al,(%rax)
    39f0:	43 23 3c 7f          	and    (%r15,%r15,2),%edi
    39f4:	2a 0e                	sub    (%rsi),%cl
    39f6:	00 00                	add    %al,(%rax)
    39f8:	3c 82                	cmp    $0x82,%al
    39fa:	01 33                	add    %esi,(%rbx)
    39fc:	0e                   	(bad)
    39fd:	00 00                	add    %al,(%rax)
    39ff:	3c 83                	cmp    $0x83,%al
    3a01:	01 3c 0e             	add    %edi,(%rsi,%rcx,1)
    3a04:	00 00                	add    %al,(%rax)
    3a06:	00 00                	add    %al,(%rax)
    3a08:	41 75 31             	rex.B jne 3a3c <_license+0x160f>
    3a0b:	00 00                	add    %al,(%rax)
    3a0d:	00 3f                	add    %bh,(%rdi)
    3a0f:	83 04 48 0e          	addl   $0xe,(%rax,%rcx,2)
    3a13:	00 00                	add    %al,(%rax)
    3a15:	3c 85                	cmp    $0x85,%al
    3a17:	01 51 0e             	add    %edx,0xe(%rcx)
    3a1a:	00 00                	add    %al,(%rax)
    3a1c:	41 75 10             	rex.B jne 3a2f <_license+0x1602>
    3a1f:	00 00                	add    %al,(%rax)
    3a21:	00 3c 84             	add    %bh,(%rsp,%rax,4)
    3a24:	01 5b 0e             	add    %ebx,0xe(%rbx)
    3a27:	00 00                	add    %al,(%rax)
    3a29:	42 06                	rex.X (bad)
    3a2b:	64 0e                	fs (bad)
    3a2d:	00 00                	add    %al,(%rax)
    3a2f:	41 75 10             	rex.B jne 3a42 <_license+0x1615>
    3a32:	00 00                	add    %al,(%rax)
    3a34:	00 3f                	add    %bh,(%rdi)
    3a36:	83 04 6e 0e          	addl   $0xe,(%rsi,%rbp,2)
    3a3a:	00 00                	add    %al,(%rax)
    3a3c:	3f                   	(bad)
    3a3d:	80 08 77             	orb    $0x77,(%rax)
    3a40:	0e                   	(bad)
    3a41:	00 00                	add    %al,(%rax)
    3a43:	3f                   	(bad)
    3a44:	08 80 0e 00 00 00    	or     %al,0xe(%rax)
    3a4a:	00 00                	add    %al,(%rax)
    3a4c:	43 24 3c             	rex.XB and $0x3c,%al
    3a4f:	c0 01 97             	rolb   $0x97,(%rcx)
    3a52:	0e                   	(bad)
    3a53:	00 00                	add    %al,(%rax)
    3a55:	3c c2                	cmp    $0xc2,%al
    3a57:	01 a0 0e 00 00 3c    	add    %esp,0x3c00000e(%rax)
    3a5d:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    3a5e:	02 a9 0e 00 00 41    	add    0x4100000e(%rcx),%ch
    3a64:	76 10                	jbe    3a76 <_license+0x1649>
    3a66:	00 00                	add    %al,(%rax)
    3a68:	00 3c c1             	add    %bh,(%rcx,%rax,8)
    3a6b:	01 b3 0e 00 00 42    	add    %esi,0x4200000e(%rbx)
    3a71:	06                   	(bad)
    3a72:	bc 0e 00 00 41       	mov    $0x4100000e,%esp
    3a77:	76 10                	jbe    3a89 <_license+0x165c>
    3a79:	00 00                	add    %al,(%rax)
    3a7b:	00 3f                	add    %bh,(%rdi)
    3a7d:	00 c6                	add    %al,%dh
    3a7f:	0e                   	(bad)
    3a80:	00 00                	add    %al,(%rax)
    3a82:	3f                   	(bad)
    3a83:	01 cf                	add    %ecx,%edi
    3a85:	0e                   	(bad)
    3a86:	00 00                	add    %al,(%rax)
    3a88:	3f                   	(bad)
    3a89:	08 d8                	or     %bl,%al
    3a8b:	0e                   	(bad)
    3a8c:	00 00                	add    %al,(%rax)
    3a8e:	00 00                	add    %al,(%rax)
    3a90:	39 b9 19 00 00 25    	cmp    %edi,0x25000019(%rcx)
    3a96:	00 6f 03             	add    %ch,0x3(%rdi)
    3a99:	26 3a c3             	es cmp %bl,%al
    3a9c:	01 c3                	add    %eax,%ebx
    3a9e:	19 00                	sbb    %eax,(%rax)
    3aa0:	00 3a                	add    %bh,(%rdx)
    3aa2:	c4 01 cc 19          	(bad)
    3aa6:	00 00                	add    %al,(%rax)
    3aa8:	3a c5                	cmp    %ch,%al
    3aaa:	01 d5                	add    %edx,%ebp
    3aac:	19 00                	sbb    %eax,(%rax)
    3aae:	00 3c c6             	add    %bh,(%rsi,%rax,8)
    3ab1:	01 e7                	add    %esp,%edi
    3ab3:	19 00                	sbb    %eax,(%rax)
    3ab5:	00 3c c7             	add    %bh,(%rdi,%rax,8)
    3ab8:	01 f1                	add    %esi,%ecx
    3aba:	19 00                	sbb    %eax,(%rax)
    3abc:	00 3c c8             	add    %bh,(%rax,%rcx,8)
    3abf:	01 fb                	add    %edi,%ebx
    3ac1:	19 00                	sbb    %eax,(%rax)
    3ac3:	00 3c c9             	add    %bh,(%rcx,%rcx,8)
    3ac6:	01 05 1a 00 00 3c    	add    %eax,0x3c00001a(%rip)        # 3c003ae6 <_license+0x3c0016b9>
    3acc:	e4 01                	in     $0x1,%al
    3ace:	0f 1a 00             	bndldx (%rax),%bnd0
    3ad1:	00 43 26             	add    %al,0x26(%rbx)
    3ad4:	3c e3                	cmp    $0xe3,%al
    3ad6:	01 2c 1a             	add    %ebp,(%rdx,%rbx,1)
    3ad9:	00 00                	add    %al,(%rax)
    3adb:	00 00                	add    %al,(%rax)
    3add:	3d f0 1a 00 00       	cmp    $0x1af0,%eax
    3ae2:	77 3f                	ja     3b23 <_license+0x16f6>
    3ae4:	00 00                	add    %al,(%rax)
    3ae6:	00 00                	add    %al,(%rax)
    3ae8:	a1 03 09 3e 02 31 9f 	movabs 0x1aff9f31023e0903,%eax
    3aef:	ff 1a 
    3af1:	00 00                	add    %al,(%rax)
    3af3:	3e 02 30             	ds add (%rax),%dh
    3af6:	9f                   	lahf
    3af7:	09 1b                	or     %ebx,(%rbx)
    3af9:	00 00                	add    %al,(%rax)
    3afb:	3c dc                	cmp    $0xdc,%al
    3afd:	01 13                	add    %edx,(%rbx)
    3aff:	1b 00                	sbb    (%rax),%eax
    3b01:	00 41 77             	add    %al,0x77(%rcx)
    3b04:	31 00                	xor    %eax,(%rax)
    3b06:	00 00                	add    %al,(%rax)
    3b08:	3c db                	cmp    $0xdb,%al
    3b0a:	01 1e                	add    %ebx,(%rsi)
    3b0c:	1b 00                	sbb    (%rax),%eax
    3b0e:	00 42 06             	add    %al,0x6(%rdx)
    3b11:	27                   	(bad)
    3b12:	1b 00                	sbb    (%rax),%eax
    3b14:	00 41 77             	add    %al,0x77(%rcx)
    3b17:	31 00                	xor    %eax,(%rax)
    3b19:	00 00                	add    %al,(%rax)
    3b1b:	3f                   	(bad)
    3b1c:	80 04 31 1b          	addb   $0x1b,(%rcx,%rsi,1)
    3b20:	00 00                	add    %al,(%rax)
    3b22:	3f                   	(bad)
    3b23:	08 3a                	or     %bh,(%rdx)
    3b25:	1b 00                	sbb    (%rax),%eax
    3b27:	00 00                	add    %al,(%rax)
    3b29:	00 00                	add    %al,(%rax)
    3b2b:	43 27                	rex.XB (bad)
    3b2d:	3c ac                	cmp    $0xac,%al
    3b2f:	02 e4                	add    %ah,%ah
    3b31:	0e                   	(bad)
    3b32:	00 00                	add    %al,(%rax)
    3b34:	39 b8 1f 00 00 28    	cmp    %edi,0x2800001f(%rax)
    3b3a:	00 73 03             	add    %dh,0x3(%rbx)
    3b3d:	09 3a                	or     %edi,(%rdx)
    3b3f:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    3b40:	02 be 1f 00 00 3a    	add    0x3a00001f(%rsi),%bh
    3b46:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    3b47:	02 c7                	add    %bh,%al
    3b49:	1f                   	(bad)
    3b4a:	00 00                	add    %al,(%rax)
    3b4c:	00 41 78             	add    %al,0x78(%rcx)
    3b4f:	05 00 00 00 3c       	add    $0x3c000000,%eax
    3b54:	ad                   	lods   %ds:(%rsi),%eax
    3b55:	02 f7                	add    %bh,%dh
    3b57:	0e                   	(bad)
    3b58:	00 00                	add    %al,(%rax)
    3b5a:	42 02 00             	rex.X add (%rax),%al
    3b5d:	0f 00 00             	sldt   (%rax)
    3b60:	41 78 05             	rex.B js 3b68 <_license+0x173b>
    3b63:	00 00                	add    %al,(%rax)
    3b65:	00 3b                	add    %bh,(%rbx)
    3b67:	01 50 0a             	add    %edx,0xa(%rax)
    3b6a:	0f 00 00             	sldt   (%rax)
    3b6d:	3f                   	(bad)
    3b6e:	fe                   	(bad)
    3b6f:	ff                   	(bad)
    3b70:	ff 07                	incl   (%rdi)
    3b72:	13 0f                	adc    (%rdi),%ecx
    3b74:	00 00                	add    %al,(%rax)
    3b76:	3f                   	(bad)
    3b77:	08 1c 0f             	or     %bl,(%rdi,%rcx,1)
    3b7a:	00 00                	add    %al,(%rax)
    3b7c:	00 00                	add    %al,(%rax)
    3b7e:	43 29 3c b3          	sub    %edi,(%r11,%r14,4)
    3b82:	02 28                	add    (%rax),%ch
    3b84:	0f 00 00             	sldt   (%rax)
    3b87:	41 79 20             	rex.B jns 3baa <_license+0x177d>
    3b8a:	00 00                	add    %al,(%rax)
    3b8c:	00 3c ae             	add    %bh,(%rsi,%rbp,4)
    3b8f:	02 32                	add    (%rdx),%dh
    3b91:	0f 00 00             	sldt   (%rax)
    3b94:	42 02 3b             	rex.X add (%rbx),%dil
    3b97:	0f 00 00             	sldt   (%rax)
    3b9a:	41 79 20             	rex.B jns 3bbd <_license+0x1790>
    3b9d:	00 00                	add    %al,(%rax)
    3b9f:	00 3c af             	add    %bh,(%rdi,%rbp,4)
    3ba2:	02 45 0f             	add    0xf(%rbp),%al
    3ba5:	00 00                	add    %al,(%rax)
    3ba7:	3f                   	(bad)
    3ba8:	80 20 4e             	andb   $0x4e,(%rax)
    3bab:	0f 00 00             	sldt   (%rax)
    3bae:	3f                   	(bad)
    3baf:	18 57 0f             	sbb    %dl,0xf(%rdi)
    3bb2:	00 00                	add    %al,(%rax)
    3bb4:	00 00                	add    %al,(%rax)
    3bb6:	39 e3                	cmp    %esp,%ebx
    3bb8:	20 00                	and    %al,(%rax)
    3bba:	00 2a                	add    %ch,(%rdx)
    3bbc:	00 89 03 17 3a b0    	add    %cl,-0x4fc5e8fd(%rcx)
    3bc2:	02 ed                	add    %ch,%ch
    3bc4:	20 00                	and    %al,(%rax)
    3bc6:	00 3a                	add    %bh,(%rdx)
    3bc8:	b1 02                	mov    $0x2,%cl
    3bca:	f6 20                	mulb   (%rax)
    3bcc:	00 00                	add    %al,(%rax)
    3bce:	3b 03                	cmp    (%rbx),%eax
    3bd0:	91                   	xchg   %eax,%ecx
    3bd1:	c0 00 ff             	rolb   $0xff,(%rax)
    3bd4:	20 00                	and    %al,(%rax)
    3bd6:	00 3c b2             	add    %bh,(%rdx,%rsi,4)
    3bd9:	02 09                	add    (%rcx),%cl
    3bdb:	21 00                	and    %eax,(%rax)
    3bdd:	00 3d 32 17 00 00    	add    %bh,0x1732(%rip)        # 5315 <_license+0x2ee8>
    3be3:	7a 0b                	jp     3bf0 <_license+0x17c3>
    3be5:	00 00                	add    %al,(%rax)
    3be7:	00 00                	add    %al,(%rax)
    3be9:	6a 02                	push   $0x2
    3beb:	22 3e                	and    (%rsi),%bh
    3bed:	01 55 3c             	add    %edx,0x3c(%rbp)
    3bf0:	17                   	(bad)
    3bf1:	00 00                	add    %al,(%rax)
    3bf3:	00 39                	add    %bh,(%rcx)
    3bf5:	fa                   	cli
    3bf6:	1b 00                	sbb    (%rax),%eax
    3bf8:	00 2b                	add    %ch,(%rbx)
    3bfa:	00 74 02 07          	add    %dh,0x7(%rdx,%rax,1)
    3bfe:	3c 84                	cmp    $0x84,%al
    3c00:	03 0c 1c             	add    (%rsp,%rbx,1),%ecx
    3c03:	00 00                	add    %al,(%rax)
    3c05:	3c 86                	cmp    $0x86,%al
    3c07:	03 15 1c 00 00 41    	add    0x4100001c(%rip),%edx        # 41003c29 <_license+0x410017fc>
    3c0d:	7b 1a                	jnp    3c29 <_license+0x17fc>
    3c0f:	00 00                	add    %al,(%rax)
    3c11:	00 3c 85 03 1f 1c 00 	add    %bh,0x1c1f03(,%rax,4)
    3c18:	00 42 06             	add    %al,0x6(%rdx)
    3c1b:	27                   	(bad)
    3c1c:	1c 00                	sbb    $0x0,%al
    3c1e:	00 41 7b             	add    %al,0x7b(%rcx)
    3c21:	1a 00                	sbb    (%rax),%al
    3c23:	00 00                	add    %al,(%rax)
    3c25:	3f                   	(bad)
    3c26:	82                   	(bad)
    3c27:	04 30                	add    $0x30,%al
    3c29:	1c 00                	sbb    $0x0,%al
    3c2b:	00 3f                	add    %bh,(%rdi)
    3c2d:	80 08 38             	orb    $0x38,(%rax)
    3c30:	1c 00                	sbb    $0x0,%al
    3c32:	00 3f                	add    %bh,(%rdi)
    3c34:	08 40 1c             	or     %al,0x1c(%rax)
    3c37:	00 00                	add    %al,(%rax)
    3c39:	00 00                	add    %al,(%rax)
    3c3b:	00 3d d1 1f 00 00    	add    %bh,0x1fd1(%rip)        # 5c12 <_license+0x37e5>
    3c41:	7c 12                	jl     3c55 <_license+0x1828>
    3c43:	00 00                	add    %al,(%rax)
    3c45:	00 00                	add    %al,(%rax)
    3c47:	79 02                	jns    3c4b <_license+0x181e>
    3c49:	03 3e                	add    (%rsi),%edi
    3c4b:	01 55 db             	add    %edx,-0x25(%rbp)
    3c4e:	1f                   	(bad)
    3c4f:	00 00                	add    %al,(%rax)
    3c51:	47 e5 1f             	rex.RXB in $0x1f,%eax
    3c54:	00 00                	add    %al,(%rax)
    3c56:	3a 91 03 ee 1f 00    	cmp    0x1fee03(%rcx),%dl
    3c5c:	00 48 00             	add    %cl,0x0(%rax)
    3c5f:	f7 1f                	negl   (%rdi)
    3c61:	00 00                	add    %al,(%rax)
    3c63:	00 00                	add    %al,(%rax)
    3c65:	3d f0 1a 00 00       	cmp    $0x1af0,%eax
    3c6a:	7d 2f                	jge    3c9b <_license+0x186e>
    3c6c:	00 00                	add    %al,(%rax)
    3c6e:	00 00                	add    %al,(%rax)
    3c70:	8e 03                	mov    (%rbx),%es
    3c72:	0f 3e                	(bad)
    3c74:	02 30                	add    (%rax),%dh
    3c76:	9f                   	lahf
    3c77:	ff 1a                	lcall  *(%rdx)
    3c79:	00 00                	add    %al,(%rax)
    3c7b:	3e 02 31             	ds add (%rcx),%dh
    3c7e:	9f                   	lahf
    3c7f:	09 1b                	or     %ebx,(%rbx)
    3c81:	00 00                	add    %al,(%rax)
    3c83:	3c 90                	cmp    $0x90,%al
    3c85:	03 13                	add    (%rbx),%edx
    3c87:	1b 00                	sbb    (%rax),%eax
    3c89:	00 41 7d             	add    %al,0x7d(%rcx)
    3c8c:	24 00                	and    $0x0,%al
    3c8e:	00 00                	add    %al,(%rax)
    3c90:	3c 8f                	cmp    $0x8f,%al
    3c92:	03 1e                	add    (%rsi),%ebx
    3c94:	1b 00                	sbb    (%rax),%eax
    3c96:	00 42 06             	add    %al,0x6(%rdx)
    3c99:	27                   	(bad)
    3c9a:	1b 00                	sbb    (%rax),%eax
    3c9c:	00 41 7d             	add    %al,0x7d(%rcx)
    3c9f:	24 00                	and    $0x0,%al
    3ca1:	00 00                	add    %al,(%rax)
    3ca3:	3f                   	(bad)
    3ca4:	80 04 31 1b          	addb   $0x1b,(%rcx,%rsi,1)
    3ca8:	00 00                	add    %al,(%rax)
    3caa:	3f                   	(bad)
    3cab:	08 3a                	or     %bh,(%rdx)
    3cad:	1b 00                	sbb    (%rax),%eax
    3caf:	00 00                	add    %al,(%rax)
    3cb1:	00 00                	add    %al,(%rax)
    3cb3:	00 00                	add    %al,(%rax)
    3cb5:	00 41 7e             	add    %al,0x7e(%rcx)
    3cb8:	34 00                	xor    $0x0,%al
    3cba:	00 00                	add    %al,(%rax)
    3cbc:	3f                   	(bad)
    3cbd:	8b 04 66             	mov    (%rsi,%riz,2),%eax
    3cc0:	0f 00 00             	sldt   (%rax)
    3cc3:	3c cc                	cmp    $0xcc,%al
    3cc5:	01 6f 0f             	add    %ebp,0xf(%rdi)
    3cc8:	00 00                	add    %al,(%rax)
    3cca:	41 7e 10             	rex.B jle 3cdd <_license+0x18b0>
    3ccd:	00 00                	add    %al,(%rax)
    3ccf:	00 3c cb             	add    %bh,(%rbx,%rcx,8)
    3cd2:	01 79 0f             	add    %edi,0xf(%rcx)
    3cd5:	00 00                	add    %al,(%rax)
    3cd7:	42 06                	rex.X (bad)
    3cd9:	82                   	(bad)
    3cda:	0f 00 00             	sldt   (%rax)
    3cdd:	41 7e 10             	rex.B jle 3cf0 <_license+0x18c3>
    3ce0:	00 00                	add    %al,(%rax)
    3ce2:	00 3f                	add    %bh,(%rdi)
    3ce4:	8b 04 8c             	mov    (%rsp,%rcx,4),%eax
    3ce7:	0f 00 00             	sldt   (%rax)
    3cea:	3f                   	(bad)
    3ceb:	80 08 95             	orb    $0x95,(%rax)
    3cee:	0f 00 00             	sldt   (%rax)
    3cf1:	3f                   	(bad)
    3cf2:	08 9e 0f 00 00 00    	or     %bl,0xf(%rsi)
    3cf8:	00 3d 38 1a 00 00    	add    %bh,0x1a38(%rip)        # 5736 <_license+0x3309>
    3cfe:	7f 07                	jg     3d07 <_license+0x18da>
    3d00:	00 00                	add    %al,(%rax)
    3d02:	00 00                	add    %al,(%rax)
    3d04:	65 03 0b             	add    %gs:(%rbx),%ecx
    3d07:	3e 01 53 42          	ds add %edx,0x42(%rbx)
    3d0b:	1a 00                	sbb    (%rax),%al
    3d0d:	00 3e                	add    %bh,(%rsi)
    3d0f:	02 31                	add    (%rcx),%dh
    3d11:	9f                   	lahf
    3d12:	54                   	push   %rsp
    3d13:	1a 00                	sbb    (%rax),%al
    3d15:	00 3f                	add    %bh,(%rdi)
    3d17:	0e                   	(bad)
    3d18:	5d                   	pop    %rbp
    3d19:	1a 00                	sbb    (%rax),%al
    3d1b:	00 41 7f             	add    %al,0x7f(%rcx)
    3d1e:	07                   	(bad)
    3d1f:	00 00                	add    %al,(%rax)
    3d21:	00 3b                	add    %bh,(%rbx)
    3d23:	03 73 36             	add    0x36(%rbx),%esi
    3d26:	9f                   	lahf
    3d27:	67 1a 00             	sbb    (%eax),%al
    3d2a:	00 00                	add    %al,(%rax)
    3d2c:	00 00                	add    %al,(%rax)
    3d2e:	3d 7d 1a 00 00       	cmp    $0x1a7d,%eax
    3d33:	80 01 6e             	addb   $0x6e,(%rcx)
    3d36:	00 00                	add    %al,(%rax)
    3d38:	00 00                	add    %al,(%rax)
    3d3a:	d7                   	xlat   %ds:(%rbx)
    3d3b:	03 07                	add    (%rdi),%eax
    3d3d:	3a b4 02 8b 1a 00 00 	cmp    0x1a8b(%rdx,%rax,1),%dh
    3d44:	3a b5 02 93 1a 00    	cmp    0x1a9302(%rbp),%dh
    3d4a:	00 3a                	add    %bh,(%rdx)
    3d4c:	b6 02                	mov    $0x2,%dh
    3d4e:	9b                   	fwait
    3d4f:	1a 00                	sbb    (%rax),%al
    3d51:	00 3c b7             	add    %bh,(%rdi,%rsi,4)
    3d54:	02 a4 1a 00 00 3c b8 	add    -0x47c40000(%rdx,%rbx,1),%ah
    3d5b:	02 ad 1a 00 00 3c    	add    0x3c00001a(%rbp),%ch
    3d61:	b9 02 b6 1a 00       	mov    $0x1ab602,%ecx
    3d66:	00 40 32             	add    %al,0x32(%rax)
    3d69:	17                   	(bad)
    3d6a:	00 00                	add    %al,(%rax)
    3d6c:	80 01 0b             	addb   $0xb,(%rcx)
    3d6f:	00 00                	add    %al,(%rax)
    3d71:	00 00                	add    %al,(%rax)
    3d73:	b8 0d 3e 01 55       	mov    $0x55013e0d,%eax
    3d78:	3c 17                	cmp    $0x17,%al
    3d7a:	00 00                	add    %al,(%rax)
    3d7c:	00 41 81             	add    %al,-0x7f(%rcx)
    3d7f:	01 1a                	add    %ebx,(%rdx)
    3d81:	00 00                	add    %al,(%rax)
    3d83:	00 3c bb             	add    %bh,(%rbx,%rdi,4)
    3d86:	02 bf 1a 00 00 42    	add    0x4200001a(%rdi),%bh
    3d8c:	02 c7                	add    %bh,%al
    3d8e:	1a 00                	sbb    (%rax),%al
    3d90:	00 41 81             	add    %al,-0x7f(%rcx)
    3d93:	01 1a                	add    %ebx,(%rdx)
    3d95:	00 00                	add    %al,(%rax)
    3d97:	00 3c ba             	add    %bh,(%rdx,%rdi,4)
    3d9a:	02 d0                	add    %al,%dl
    3d9c:	1a 00                	sbb    (%rax),%al
    3d9e:	00 3f                	add    %bh,(%rdi)
    3da0:	80 20 d8             	andb   $0xd8,(%rax)
    3da3:	1a 00                	sbb    (%rax),%al
    3da5:	00 3f                	add    %bh,(%rdi)
    3da7:	18 e0                	sbb    %ah,%al
    3da9:	1a 00                	sbb    (%rax),%al
    3dab:	00 00                	add    %al,(%rax)
    3dad:	00 00                	add    %al,(%rax)
    3daf:	3d 4f 1b 00 00       	cmp    $0x1b4f,%eax
    3db4:	82                   	(bad)
    3db5:	01 02                	add    %eax,(%rdx)
    3db7:	01 00                	add    %eax,(%rax)
    3db9:	00 00                	add    %al,(%rax)
    3dbb:	e4 03                	in     $0x3,%al
    3dbd:	05 3e 03 91 10       	add    $0x1091033e,%eax
    3dc2:	9f                   	lahf
    3dc3:	62                   	(bad)
    3dc4:	1b 00                	sbb    (%rax),%eax
    3dc6:	00 3a                	add    %bh,(%rdx)
    3dc8:	bc 02 6b 1b 00       	mov    $0x1b6b02,%esp
    3dcd:	00 3e                	add    %bh,(%rsi)
    3dcf:	04 91                	add    $0x91,%al
    3dd1:	e0 00                	loopne 3dd3 <_license+0x19a6>
    3dd3:	9f                   	lahf
    3dd4:	74 1b                	je     3df1 <_license+0x19c4>
    3dd6:	00 00                	add    %al,(%rax)
    3dd8:	3d fa 1b 00 00       	cmp    $0x1bfa,%eax
    3ddd:	83 01 74             	addl   $0x74,(%rcx)
    3de0:	00 00                	add    %al,(%rax)
    3de2:	00 00                	add    %al,(%rax)
    3de4:	93                   	xchg   %eax,%ebx
    3de5:	02 32                	add    (%rdx),%dh
    3de7:	3f                   	(bad)
    3de8:	82                   	(bad)
    3de9:	04 0c                	add    $0xc,%al
    3deb:	1c 00                	sbb    $0x0,%al
    3ded:	00 3c be             	add    %bh,(%rsi,%rdi,4)
    3df0:	02 15 1c 00 00 41    	add    0x4100001c(%rip),%dl        # 41003e12 <_license+0x410019e5>
    3df6:	83 01 10             	addl   $0x10,(%rcx)
    3df9:	00 00                	add    %al,(%rax)
    3dfb:	00 3c bd 02 1f 1c 00 	add    %bh,0x1c1f02(,%rdi,4)
    3e02:	00 42 06             	add    %al,0x6(%rdx)
    3e05:	27                   	(bad)
    3e06:	1c 00                	sbb    $0x0,%al
    3e08:	00 41 83             	add    %al,-0x7d(%rcx)
    3e0b:	01 10                	add    %edx,(%rax)
    3e0d:	00 00                	add    %al,(%rax)
    3e0f:	00 3f                	add    %bh,(%rdi)
    3e11:	82                   	(bad)
    3e12:	04 30                	add    $0x30,%al
    3e14:	1c 00                	sbb    $0x0,%al
    3e16:	00 3f                	add    %bh,(%rdi)
    3e18:	80 08 38             	orb    $0x38,(%rax)
    3e1b:	1c 00                	sbb    $0x0,%al
    3e1d:	00 3f                	add    %bh,(%rdi)
    3e1f:	08 40 1c             	or     %al,0x1c(%rax)
    3e22:	00 00                	add    %al,(%rax)
    3e24:	00 00                	add    %al,(%rax)
    3e26:	00 41 84             	add    %al,-0x7c(%rcx)
    3e29:	01 79 00             	add    %edi,0x0(%rcx)
    3e2c:	00 00                	add    %al,(%rax)
    3e2e:	3c c1                	cmp    $0xc1,%al
    3e30:	02 88 1b 00 00 41    	add    0x4100001b(%rax),%cl
    3e36:	84 01                	test   %al,(%rcx)
    3e38:	2a 00                	sub    (%rax),%al
    3e3a:	00 00                	add    %al,(%rax)
    3e3c:	3c bf                	cmp    $0xbf,%al
    3e3e:	02 93 1b 00 00 42    	add    0x4200001b(%rbx),%dl
    3e44:	0d 9c 1b 00 00       	or     $0x1b9c,%eax
    3e49:	3d 32 17 00 00       	cmp    $0x1732,%eax
    3e4e:	84 01                	test   %al,(%rcx)
    3e50:	2a 00                	sub    (%rax),%al
    3e52:	00 00                	add    %al,(%rax)
    3e54:	00 95 02 1c 3a c0    	add    %dl,-0x3fc5e3fe(%rbp)
    3e5a:	02 3c 17             	add    (%rdi,%rdx,1),%bh
    3e5d:	00 00                	add    %al,(%rax)
    3e5f:	00 00                	add    %al,(%rax)
    3e61:	41 85 01             	test   %eax,(%r9)
    3e64:	4a 00 00             	rex.WX add %al,(%rax)
    3e67:	00 3c c4             	add    %bh,(%rsp,%rax,8)
    3e6a:	02 a7 1b 00 00 3d    	add    0x3d00001b(%rdi),%ah
    3e70:	32 17                	xor    (%rdi),%dl
    3e72:	00 00                	add    %al,(%rax)
    3e74:	86 01                	xchg   %al,(%rcx)
    3e76:	1e                   	(bad)
    3e77:	00 00                	add    %al,(%rax)
    3e79:	00 00                	add    %al,(%rax)
    3e7b:	97                   	xchg   %eax,%edi
    3e7c:	02 19                	add    (%rcx),%bl
    3e7e:	3a c2                	cmp    %dl,%al
    3e80:	02 3c 17             	add    (%rdi,%rdx,1),%bh
    3e83:	00 00                	add    %al,(%rax)
    3e85:	3a c3                	cmp    %bl,%al
    3e87:	02 46 17             	add    0x17(%rsi),%al
    3e8a:	00 00                	add    %al,(%rax)
    3e8c:	00 41 87             	add    %al,-0x79(%rcx)
    3e8f:	01 22                	add    %esp,(%rdx)
    3e91:	00 00                	add    %al,(%rax)
    3e93:	00 3f                	add    %bh,(%rdi)
    3e95:	8f 04 b2             	pop    (%rdx,%rsi,4)
    3e98:	1b 00                	sbb    (%rax),%eax
    3e9a:	00 3c c6             	add    %bh,(%rsi,%rax,8)
    3e9d:	02 bb 1b 00 00 41    	add    0x4100001b(%rbx),%bh
    3ea3:	87 01                	xchg   %eax,(%rcx)
    3ea5:	10 00                	adc    %al,(%rax)
    3ea7:	00 00                	add    %al,(%rax)
    3ea9:	3c c5                	cmp    $0xc5,%al
    3eab:	02 c6                	add    %dh,%al
    3ead:	1b 00                	sbb    (%rax),%eax
    3eaf:	00 42 06             	add    %al,0x6(%rdx)
    3eb2:	cf                   	iret
    3eb3:	1b 00                	sbb    (%rax),%eax
    3eb5:	00 41 87             	add    %al,-0x79(%rcx)
    3eb8:	01 10                	add    %edx,(%rax)
    3eba:	00 00                	add    %al,(%rax)
    3ebc:	00 3f                	add    %bh,(%rdi)
    3ebe:	8f 04 d9             	pop    (%rcx,%rbx,8)
    3ec1:	1b 00                	sbb    (%rax),%eax
    3ec3:	00 3f                	add    %bh,(%rdi)
    3ec5:	80 08 e2             	orb    $0xe2,(%rax)
    3ec8:	1b 00                	sbb    (%rax),%eax
    3eca:	00 3f                	add    %bh,(%rdi)
    3ecc:	08 eb                	or     %ch,%bl
    3ece:	1b 00                	sbb    (%rax),%eax
    3ed0:	00 00                	add    %al,(%rax)
    3ed2:	00 00                	add    %al,(%rax)
    3ed4:	00 00                	add    %al,(%rax)
    3ed6:	00 41 88             	add    %al,-0x78(%rcx)
    3ed9:	01 2a                	add    %ebp,(%rdx)
    3edb:	00 00                	add    %al,(%rax)
    3edd:	00 3f                	add    %bh,(%rdi)
    3edf:	81 04 ac 0f 00 00 3c 	addl   $0x3c00000f,(%rsp,%rbp,4)
    3ee6:	d6                   	(bad)
    3ee7:	02 b5 0f 00 00 41    	add    0x4100000f(%rbp),%dh
    3eed:	88 01                	mov    %al,(%rcx)
    3eef:	10 00                	adc    %al,(%rax)
    3ef1:	00 00                	add    %al,(%rax)
    3ef3:	3c d5                	cmp    $0xd5,%al
    3ef5:	02 bf 0f 00 00 42    	add    0x4200000f(%rdi),%bh
    3efb:	06                   	(bad)
    3efc:	c8 0f 00 00          	enter  $0xf,$0x0
    3f00:	41 88 01             	mov    %al,(%r9)
    3f03:	10 00                	adc    %al,(%rax)
    3f05:	00 00                	add    %al,(%rax)
    3f07:	3f                   	(bad)
    3f08:	81 04 d2 0f 00 00 3f 	addl   $0x3f00000f,(%rdx,%rdx,8)
    3f0f:	80 08 db             	orb    $0xdb,(%rax)
    3f12:	0f 00 00             	sldt   (%rax)
    3f15:	3f                   	(bad)
    3f16:	08 e4                	or     %ah,%ah
    3f18:	0f 00 00             	sldt   (%rax)
    3f1b:	00 00                	add    %al,(%rax)
    3f1d:	00 39                	add    %bh,(%rcx)
    3f1f:	f6 1c 00             	negb   (%rax,%rax,1)
    3f22:	00 2c 00             	add    %ch,(%rax,%rax,1)
    3f25:	fa                   	cli
    3f26:	03 0c 3a             	add    (%rdx,%rdi,1),%ecx
    3f29:	d7                   	xlat   %ds:(%rbx)
    3f2a:	02 08                	add    (%rax),%cl
    3f2c:	1d 00 00 3a d8       	sbb    $0xd83a0000,%eax
    3f31:	02 18                	add    (%rax),%bl
    3f33:	1d 00 00 3a d9       	sbb    $0xd93a0000,%eax
    3f38:	02 20                	add    (%rax),%ah
    3f3a:	1d 00 00 3b 03       	sbb    $0x33b0000,%eax
    3f3f:	91                   	xchg   %eax,%ecx
    3f40:	c0 00 28             	rolb   $0x28,(%rax)
    3f43:	1d 00 00 3c da       	sbb    $0xda3c0000,%eax
    3f48:	02 31                	add    (%rcx),%dh
    3f4a:	1d 00 00 3c db       	sbb    $0xdb3c0000,%eax
    3f4f:	02 3a                	add    (%rdx),%bh
    3f51:	1d 00 00 3c dc       	sbb    $0xdc3c0000,%eax
    3f56:	02 43 1d             	add    0x1d(%rbx),%al
    3f59:	00 00                	add    %al,(%rax)
    3f5b:	3c ea                	cmp    $0xea,%al
    3f5d:	02 4c 1d 00          	add    0x0(%rbp,%rbx,1),%cl
    3f61:	00 3c eb             	add    %bh,(%rbx,%rbp,8)
    3f64:	02 55 1d             	add    0x1d(%rbp),%dl
    3f67:	00 00                	add    %al,(%rax)
    3f69:	40 fa                	rex cli
    3f6b:	1b 00                	sbb    (%rax),%eax
    3f6d:	00 89 01 58 00 00    	add    %cl,0x5801(%rcx)
    3f73:	00 00                	add    %al,(%rax)
    3f75:	66 11 3f             	adc    %di,(%rdi)
    3f78:	82                   	(bad)
    3f79:	04 0c                	add    $0xc,%al
    3f7b:	1c 00                	sbb    $0x0,%al
    3f7d:	00 3c de             	add    %bh,(%rsi,%rbx,8)
    3f80:	02 15 1c 00 00 41    	add    0x4100001c(%rip),%dl        # 41003fa2 <_license+0x41001b75>
    3f86:	89 01                	mov    %eax,(%rcx)
    3f88:	13 00                	adc    (%rax),%eax
    3f8a:	00 00                	add    %al,(%rax)
    3f8c:	3c dd                	cmp    $0xdd,%al
    3f8e:	02 1f                	add    (%rdi),%bl
    3f90:	1c 00                	sbb    $0x0,%al
    3f92:	00 42 06             	add    %al,0x6(%rdx)
    3f95:	27                   	(bad)
    3f96:	1c 00                	sbb    $0x0,%al
    3f98:	00 41 89             	add    %al,-0x77(%rcx)
    3f9b:	01 13                	add    %edx,(%rbx)
    3f9d:	00 00                	add    %al,(%rax)
    3f9f:	00 3f                	add    %bh,(%rdi)
    3fa1:	82                   	(bad)
    3fa2:	04 30                	add    $0x30,%al
    3fa4:	1c 00                	sbb    $0x0,%al
    3fa6:	00 3f                	add    %bh,(%rdi)
    3fa8:	80 08 38             	orb    $0x38,(%rax)
    3fab:	1c 00                	sbb    $0x0,%al
    3fad:	00 3f                	add    %bh,(%rdi)
    3faf:	08 40 1c             	or     %al,0x1c(%rax)
    3fb2:	00 00                	add    %al,(%rax)
    3fb4:	00 00                	add    %al,(%rax)
    3fb6:	00 43 2d             	add    %al,0x2d(%rbx)
    3fb9:	3c df                	cmp    $0xdf,%al
    3fbb:	02 66 1d             	add    0x1d(%rsi),%ah
    3fbe:	00 00                	add    %al,(%rax)
    3fc0:	4a 1c 1e             	rex.WX sbb $0x1e,%al
    3fc3:	00 00                	add    %al,(%rax)
    3fc5:	2e 00 8f 0c 3a e2 02 	cs add %cl,0x2e23a0c(%rdi)
    3fcc:	25 1e 00 00 3a       	and    $0x3a00001e,%eax
    3fd1:	e3 02                	jrcxz  3fd5 <_license+0x1ba8>
    3fd3:	2d 1e 00 00 4a       	sub    $0x4a00001e,%eax
    3fd8:	1e                   	(bad)
    3fd9:	21 00                	and    %eax,(%rax)
    3fdb:	00 2f                	add    %ch,(%rdi)
    3fdd:	00 1e                	add    %bl,(%rsi)
    3fdf:	09 3a                	or     %edi,(%rdx)
    3fe1:	e4 02                	in     $0x2,%al
    3fe3:	38 21                	cmp    %ah,(%rcx)
    3fe5:	00 00                	add    %al,(%rax)
    3fe7:	3c e0                	cmp    $0xe0,%al
    3fe9:	02 41 21             	add    0x21(%rcx),%al
    3fec:	00 00                	add    %al,(%rax)
    3fee:	3c e1                	cmp    $0xe1,%al
    3ff0:	02 4a 21             	add    0x21(%rdx),%cl
    3ff3:	00 00                	add    %al,(%rax)
    3ff5:	3c e5                	cmp    $0xe5,%al
    3ff7:	02 53 21             	add    0x21(%rbx),%dl
    3ffa:	00 00                	add    %al,(%rax)
    3ffc:	3c e6                	cmp    $0xe6,%al
    3ffe:	02 5c 21 00          	add    0x0(%rcx,%riz,1),%bl
    4002:	00 40 37             	add    %al,0x37(%rax)
    4005:	1e                   	(bad)
    4006:	00 00                	add    %al,(%rax)
    4008:	8a 01                	mov    (%rcx),%al
    400a:	03 00                	add    (%rax),%eax
    400c:	00 00                	add    %al,(%rax)
    400e:	0d 41 05 3e 01       	or     $0x13e0541,%eax
    4013:	53                   	push   %rbx
    4014:	40 1e                	rex (bad)
    4016:	00 00                	add    %al,(%rax)
    4018:	48 04 49             	rex.W add $0x49,%al
    401b:	1e                   	(bad)
    401c:	00 00                	add    %al,(%rax)
    401e:	00 40 37             	add    %al,0x37(%rax)
    4021:	1e                   	(bad)
    4022:	00 00                	add    %al,(%rax)
    4024:	8b 01                	mov    (%rcx),%eax
    4026:	05 00 00 00 0d       	add    $0xd000000,%eax
    402b:	41 05 3e 01 53 40    	rex.B add $0x4053013e,%eax
    4031:	1e                   	(bad)
    4032:	00 00                	add    %al,(%rax)
    4034:	48 06                	rex.W (bad)
    4036:	49 1e                	rex.WB (bad)
    4038:	00 00                	add    %al,(%rax)
    403a:	00 40 37             	add    %al,0x37(%rax)
    403d:	1e                   	(bad)
    403e:	00 00                	add    %al,(%rax)
    4040:	8c 01                	mov    %es,(%rcx)
    4042:	05 00 00 00 0d       	add    $0xd000000,%eax
    4047:	41 05 3e 01 55 40    	rex.B add $0x4055013e,%eax
    404d:	1e                   	(bad)
    404e:	00 00                	add    %al,(%rax)
    4050:	48 08 49 1e          	rex.W or %cl,0x1e(%rcx)
    4054:	00 00                	add    %al,(%rax)
    4056:	00 40 37             	add    %al,0x37(%rax)
    4059:	1e                   	(bad)
    405a:	00 00                	add    %al,(%rax)
    405c:	8d 01                	lea    (%rcx),%eax
    405e:	05 00 00 00 0d       	add    $0xd000000,%eax
    4063:	41 05 3e 01 52 40    	rex.B add $0x4052013e,%eax
    4069:	1e                   	(bad)
    406a:	00 00                	add    %al,(%rax)
    406c:	48 10 49 1e          	rex.W adc %cl,0x1e(%rcx)
    4070:	00 00                	add    %al,(%rax)
    4072:	00 40 37             	add    %al,0x37(%rax)
    4075:	1e                   	(bad)
    4076:	00 00                	add    %al,(%rax)
    4078:	8e 01                	mov    (%rcx),%es
    407a:	05 00 00 00 0d       	add    $0xd000000,%eax
    407f:	41 05 3e 01 54 40    	rex.B add $0x4054013e,%eax
    4085:	1e                   	(bad)
    4086:	00 00                	add    %al,(%rax)
    4088:	48 13 49 1e          	adc    0x1e(%rcx),%rcx
    408c:	00 00                	add    %al,(%rax)
    408e:	00 40 37             	add    %al,0x37(%rax)
    4091:	1e                   	(bad)
    4092:	00 00                	add    %al,(%rax)
    4094:	8f 01                	pop    (%rcx)
    4096:	07                   	(bad)
    4097:	00 00                	add    %al,(%rax)
    4099:	00 0d 41 05 3e 01    	add    %cl,0x13e0541(%rip)        # 13e45e0 <_license+0x13e21b3>
    409f:	53                   	push   %rbx
    40a0:	40 1e                	rex (bad)
    40a2:	00 00                	add    %al,(%rax)
    40a4:	48 04 49             	rex.W add $0x49,%al
    40a7:	1e                   	(bad)
    40a8:	00 00                	add    %al,(%rax)
    40aa:	00 40 37             	add    %al,0x37(%rax)
    40ad:	1e                   	(bad)
    40ae:	00 00                	add    %al,(%rax)
    40b0:	90                   	nop
    40b1:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d0040b7 <_license+0xd001c8a>
    40b7:	5e                   	pop    %rsi
    40b8:	07                   	(bad)
    40b9:	3e 01 53 40          	ds add %edx,0x40(%rbx)
    40bd:	1e                   	(bad)
    40be:	00 00                	add    %al,(%rax)
    40c0:	48 0e                	rex.W (bad)
    40c2:	49 1e                	rex.WB (bad)
    40c4:	00 00                	add    %al,(%rax)
    40c6:	00 40 37             	add    %al,0x37(%rax)
    40c9:	1e                   	(bad)
    40ca:	00 00                	add    %al,(%rax)
    40cc:	91                   	xchg   %eax,%ecx
    40cd:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d0040d3 <_license+0xd001ca6>
    40d3:	5e                   	pop    %rsi
    40d4:	07                   	(bad)
    40d5:	3e 01 52 40          	ds add %edx,0x40(%rdx)
    40d9:	1e                   	(bad)
    40da:	00 00                	add    %al,(%rax)
    40dc:	48 0b 49 1e          	or     0x1e(%rcx),%rcx
    40e0:	00 00                	add    %al,(%rax)
    40e2:	00 40 37             	add    %al,0x37(%rax)
    40e5:	1e                   	(bad)
    40e6:	00 00                	add    %al,(%rax)
    40e8:	92                   	xchg   %eax,%edx
    40e9:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d0040ef <_license+0xd001cc2>
    40ef:	5e                   	pop    %rsi
    40f0:	07                   	(bad)
    40f1:	3e 01 51 40          	ds add %edx,0x40(%rcx)
    40f5:	1e                   	(bad)
    40f6:	00 00                	add    %al,(%rax)
    40f8:	48 19 49 1e          	sbb    %rcx,0x1e(%rcx)
    40fc:	00 00                	add    %al,(%rax)
    40fe:	00 40 37             	add    %al,0x37(%rax)
    4101:	1e                   	(bad)
    4102:	00 00                	add    %al,(%rax)
    4104:	93                   	xchg   %eax,%ebx
    4105:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d00410b <_license+0xd001cde>
    410b:	5e                   	pop    %rsi
    410c:	07                   	(bad)
    410d:	3e 01 53 40          	ds add %edx,0x40(%rbx)
    4111:	1e                   	(bad)
    4112:	00 00                	add    %al,(%rax)
    4114:	48 10 49 1e          	rex.W adc %cl,0x1e(%rcx)
    4118:	00 00                	add    %al,(%rax)
    411a:	00 40 37             	add    %al,0x37(%rax)
    411d:	1e                   	(bad)
    411e:	00 00                	add    %al,(%rax)
    4120:	94                   	xchg   %eax,%esp
    4121:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d004127 <_license+0xd001cfa>
    4127:	5e                   	pop    %rsi
    4128:	07                   	(bad)
    4129:	3e 01 52 40          	ds add %edx,0x40(%rdx)
    412d:	1e                   	(bad)
    412e:	00 00                	add    %al,(%rax)
    4130:	48 04 49             	rex.W add $0x49,%al
    4133:	1e                   	(bad)
    4134:	00 00                	add    %al,(%rax)
    4136:	00 40 37             	add    %al,0x37(%rax)
    4139:	1e                   	(bad)
    413a:	00 00                	add    %al,(%rax)
    413c:	95                   	xchg   %eax,%ebp
    413d:	01 03                	add    %eax,(%rbx)
    413f:	00 00                	add    %al,(%rax)
    4141:	00 0d 5e 07 3e 01    	add    %cl,0x13e075e(%rip)        # 13e48a5 <_license+0x13e2478>
    4147:	51                   	push   %rcx
    4148:	40 1e                	rex (bad)
    414a:	00 00                	add    %al,(%rax)
    414c:	48 0e                	rex.W (bad)
    414e:	49 1e                	rex.WB (bad)
    4150:	00 00                	add    %al,(%rax)
    4152:	00 40 37             	add    %al,0x37(%rax)
    4155:	1e                   	(bad)
    4156:	00 00                	add    %al,(%rax)
    4158:	96                   	xchg   %eax,%esi
    4159:	01 03                	add    %eax,(%rbx)
    415b:	00 00                	add    %al,(%rax)
    415d:	00 0d 5e 07 3e 01    	add    %cl,0x13e075e(%rip)        # 13e48c1 <_license+0x13e2494>
    4163:	53                   	push   %rbx
    4164:	40 1e                	rex (bad)
    4166:	00 00                	add    %al,(%rax)
    4168:	48 18 49 1e          	rex.W sbb %cl,0x1e(%rcx)
    416c:	00 00                	add    %al,(%rax)
    416e:	00 00                	add    %al,(%rax)
    4170:	40 f7 1d 00 00 97 01 	rex negl 0x1970000(%rip)        # 1974177 <_license+0x1971d4a>
    4177:	57                   	push   %rdi
    4178:	00 00                	add    %al,(%rax)
    417a:	00 00                	add    %al,(%rax)
    417c:	1d 0c 48 80 84       	sbb    $0x8480480c,%eax
    4181:	80 10 12             	adcb   $0x12,(%rax)
    4184:	1e                   	(bad)
    4185:	00 00                	add    %al,(%rax)
    4187:	40 c9                	rex leave
    4189:	1d 00 00 97 01       	sbb    $0x1970000,%eax
    418e:	57                   	push   %rdi
    418f:	00 00                	add    %al,(%rax)
    4191:	00 0d 6f 0a 3a e7    	add    %cl,-0x18c5f591(%rip)        # ffffffffe73a4c06 <server_id_map+0x36fc9e108c06>
    4197:	02 d2                	add    %dl,%dl
    4199:	1d 00 00 3a e8       	sbb    $0xe83a0000,%eax
    419e:	02 db                	add    %bl,%bl
    41a0:	1d 00 00 3a e9       	sbb    $0xe93a0000,%eax
    41a5:	02 e4                	add    %ah,%ah
    41a7:	1d 00 00 48 f7       	sbb    $0xf7480000,%eax
    41ac:	81 b7 85 fe ff ff ff 	xorl   $0xed01ffff,-0x17b(%rdi)
    41b3:	ff 01 ed 
    41b6:	1d 00 00 40 37       	sbb    $0x37400000,%eax
    41bb:	1e                   	(bad)
    41bc:	00 00                	add    %al,(%rax)
    41be:	98                   	cwtl
    41bf:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d0041c5 <_license+0xd001d98>
    41c5:	6a 03                	push   $0x3
    41c7:	3e 01 54 40 1e       	ds add %edx,0x1e(%rax,%rax,2)
    41cc:	00 00                	add    %al,(%rax)
    41ce:	48 0e                	rex.W (bad)
    41d0:	49 1e                	rex.WB (bad)
    41d2:	00 00                	add    %al,(%rax)
    41d4:	00 40 37             	add    %al,0x37(%rax)
    41d7:	1e                   	(bad)
    41d8:	00 00                	add    %al,(%rax)
    41da:	99                   	cltd
    41db:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d0041e1 <_license+0xd001db4>
    41e1:	6a 03                	push   $0x3
    41e3:	3e 01 51 40          	ds add %edx,0x40(%rcx)
    41e7:	1e                   	(bad)
    41e8:	00 00                	add    %al,(%rax)
    41ea:	48 0b 49 1e          	or     0x1e(%rcx),%rcx
    41ee:	00 00                	add    %al,(%rax)
    41f0:	00 40 37             	add    %al,0x37(%rax)
    41f3:	1e                   	(bad)
    41f4:	00 00                	add    %al,(%rax)
    41f6:	9a                   	(bad)
    41f7:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d0041fd <_license+0xd001dd0>
    41fd:	6a 03                	push   $0x3
    41ff:	3e 01 52 40          	ds add %edx,0x40(%rdx)
    4203:	1e                   	(bad)
    4204:	00 00                	add    %al,(%rax)
    4206:	48 19 49 1e          	sbb    %rcx,0x1e(%rcx)
    420a:	00 00                	add    %al,(%rax)
    420c:	00 40 37             	add    %al,0x37(%rax)
    420f:	1e                   	(bad)
    4210:	00 00                	add    %al,(%rax)
    4212:	9b                   	fwait
    4213:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d004219 <_license+0xd001dec>
    4219:	6a 03                	push   $0x3
    421b:	3e 01 54 40 1e       	ds add %edx,0x1e(%rax,%rax,2)
    4220:	00 00                	add    %al,(%rax)
    4222:	48 10 49 1e          	rex.W adc %cl,0x1e(%rcx)
    4226:	00 00                	add    %al,(%rax)
    4228:	00 40 37             	add    %al,0x37(%rax)
    422b:	1e                   	(bad)
    422c:	00 00                	add    %al,(%rax)
    422e:	9c                   	pushf
    422f:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d004235 <_license+0xd001e08>
    4235:	6a 03                	push   $0x3
    4237:	3e 01 51 40          	ds add %edx,0x40(%rcx)
    423b:	1e                   	(bad)
    423c:	00 00                	add    %al,(%rax)
    423e:	48 04 49             	rex.W add $0x49,%al
    4241:	1e                   	(bad)
    4242:	00 00                	add    %al,(%rax)
    4244:	00 40 37             	add    %al,0x37(%rax)
    4247:	1e                   	(bad)
    4248:	00 00                	add    %al,(%rax)
    424a:	9d                   	popf
    424b:	01 03                	add    %eax,(%rbx)
    424d:	00 00                	add    %al,(%rax)
    424f:	00 0d 6a 03 3e 01    	add    %cl,0x13e036a(%rip)        # 13e45bf <_license+0x13e2192>
    4255:	52                   	push   %rdx
    4256:	40 1e                	rex (bad)
    4258:	00 00                	add    %al,(%rax)
    425a:	48 0e                	rex.W (bad)
    425c:	49 1e                	rex.WB (bad)
    425e:	00 00                	add    %al,(%rax)
    4260:	00 40 37             	add    %al,0x37(%rax)
    4263:	1e                   	(bad)
    4264:	00 00                	add    %al,(%rax)
    4266:	9e                   	sahf
    4267:	01 03                	add    %eax,(%rbx)
    4269:	00 00                	add    %al,(%rax)
    426b:	00 0d 6a 03 3e 01    	add    %cl,0x13e036a(%rip)        # 13e45db <_license+0x13e21ae>
    4271:	54                   	push   %rsp
    4272:	40 1e                	rex (bad)
    4274:	00 00                	add    %al,(%rax)
    4276:	48 18 49 1e          	rex.W sbb %cl,0x1e(%rcx)
    427a:	00 00                	add    %al,(%rax)
    427c:	00 00                	add    %al,(%rax)
    427e:	00 00                	add    %al,(%rax)
    4280:	43 30 3c ed 02 70 1d 	xor    %dil,0x1d7002(,%r13,8)
    4287:	00 
    4288:	00 42 02             	add    %al,0x2(%rdx)
    428b:	78 1d                	js     42aa <_license+0x1e7d>
    428d:	00 00                	add    %al,(%rax)
    428f:	43 31 3c ec          	xor    %edi,(%r12,%r13,8)
    4293:	02 81 1d 00 00 3f    	add    0x3f00001d(%rcx),%al
    4299:	80 84 80 10 89 1d 00 	addb   $0x0,0x1d8910(%rax,%rax,4)
    42a0:	00 
    42a1:	3f                   	(bad)
    42a2:	08 91 1d 00 00 00    	or     %dl,0x1d(%rcx)
    42a8:	00 40 97             	add    %al,-0x69(%rax)
    42ab:	1e                   	(bad)
    42ac:	00 00                	add    %al,(%rax)
    42ae:	9f                   	lahf
    42af:	01 1f                	add    %ebx,(%rdi)
    42b1:	00 00                	add    %al,(%rax)
    42b3:	00 00                	add    %al,(%rax)
    42b5:	9a                   	(bad)
    42b6:	07                   	(bad)
    42b7:	3f                   	(bad)
    42b8:	89 04 9c             	mov    %eax,(%rsp,%rbx,4)
    42bb:	1e                   	(bad)
    42bc:	00 00                	add    %al,(%rax)
    42be:	3c f2                	cmp    $0xf2,%al
    42c0:	02 a5 1e 00 00 41    	add    0x4100001e(%rbp),%ah
    42c6:	9f                   	lahf
    42c7:	01 1a                	add    %ebx,(%rdx)
    42c9:	00 00                	add    %al,(%rax)
    42cb:	00 3c f1             	add    %bh,(%rcx,%rsi,8)
    42ce:	02 af 1e 00 00 42    	add    0x4200001e(%rdi),%ch
    42d4:	06                   	(bad)
    42d5:	b7 1e                	mov    $0x1e,%bh
    42d7:	00 00                	add    %al,(%rax)
    42d9:	41 9f                	rex.B lahf
    42db:	01 1a                	add    %ebx,(%rdx)
    42dd:	00 00                	add    %al,(%rax)
    42df:	00 3f                	add    %bh,(%rdi)
    42e1:	89 04 c0             	mov    %eax,(%rax,%rax,8)
    42e4:	1e                   	(bad)
    42e5:	00 00                	add    %al,(%rax)
    42e7:	3f                   	(bad)
    42e8:	80 08 c8             	orb    $0xc8,(%rax)
    42eb:	1e                   	(bad)
    42ec:	00 00                	add    %al,(%rax)
    42ee:	3f                   	(bad)
    42ef:	08 d0                	or     %dl,%al
    42f1:	1e                   	(bad)
    42f2:	00 00                	add    %al,(%rax)
    42f4:	00 00                	add    %al,(%rax)
    42f6:	00 00                	add    %al,(%rax)
    42f8:	41 a0 01 06 00 00 00 	rex.B movabs 0x2ee3c0000000601,%al
    42ff:	3c ee 02 
    4302:	9d                   	popf
    4303:	1d 00 00 42 02       	sbb    $0x2420000,%eax
    4308:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    4309:	1d 00 00 41 a0       	sbb    $0xa0410000,%eax
    430e:	01 06                	add    %eax,(%rsi)
    4310:	00 00                	add    %al,(%rax)
    4312:	00 3b                	add    %bh,(%rbx)
    4314:	01 56 ae             	add    %edx,-0x52(%rsi)
    4317:	1d 00 00 3f 80       	sbb    $0x803f0000,%eax
    431c:	20 b6 1d 00 00 3f    	and    %dh,0x3f00001d(%rsi)
    4322:	18 be 1d 00 00 00    	sbb    %bh,0x1d(%rsi)
    4328:	00 40 53             	add    %al,0x53(%rax)
    432b:	1e                   	(bad)
    432c:	00 00                	add    %al,(%rax)
    432e:	a1 01 21 00 00 00 00 	movabs 0x5a3000000002101,%eax
    4335:	a3 05 
    4337:	3f                   	(bad)
    4338:	89 04 58             	mov    %eax,(%rax,%rbx,2)
    433b:	1e                   	(bad)
    433c:	00 00                	add    %al,(%rax)
    433e:	3c f0                	cmp    $0xf0,%al
    4340:	02 61 1e             	add    0x1e(%rcx),%ah
    4343:	00 00                	add    %al,(%rax)
    4345:	41 a1 01 1a 00 00 00 	rex.B movabs 0x2ef3c0000001a01,%eax
    434c:	3c ef 02 
    434f:	6b 1e 00             	imul   $0x0,(%rsi),%ebx
    4352:	00 42 06             	add    %al,0x6(%rdx)
    4355:	73 1e                	jae    4375 <_license+0x1f48>
    4357:	00 00                	add    %al,(%rax)
    4359:	41 a1 01 1a 00 00 00 	rex.B movabs 0x4893f0000001a01,%eax
    4360:	3f 89 04 
    4363:	7c 1e                	jl     4383 <_license+0x1f56>
    4365:	00 00                	add    %al,(%rax)
    4367:	3f                   	(bad)
    4368:	80 08 84             	orb    $0x84,(%rax)
    436b:	1e                   	(bad)
    436c:	00 00                	add    %al,(%rax)
    436e:	3f                   	(bad)
    436f:	08 8c 1e 00 00 00 00 	or     %cl,0x0(%rsi,%rbx,1)
    4376:	00 40 d1             	add    %al,-0x2f(%rax)
    4379:	1f                   	(bad)
    437a:	00 00                	add    %al,(%rax)
    437c:	a2 01 12 00 00 00 00 	movabs %al,0x5ab000000001201
    4383:	ab 05 
    4385:	3e 01 55 db          	ds add %edx,-0x25(%rbp)
    4389:	1f                   	(bad)
    438a:	00 00                	add    %al,(%rax)
    438c:	48 00 f7             	rex.W add %sil,%dil
    438f:	1f                   	(bad)
    4390:	00 00                	add    %al,(%rax)
    4392:	00 00                	add    %al,(%rax)
    4394:	3d 01 20 00 00       	cmp    $0x2001,%eax
    4399:	a3 01 8a 00 00 00 00 	movabs %eax,0x3ff000000008a01
    43a0:	ff 03 
    43a2:	0b 3e                	or     (%rsi),%edi
    43a4:	04 91                	add    $0x91,%al
    43a6:	e0 00                	loopne 43a8 <_license+0x1f7b>
    43a8:	9f                   	lahf
    43a9:	0b 20                	or     (%rax),%esp
    43ab:	00 00                	add    %al,(%rax)
    43ad:	3e 02 31             	ds add (%rcx),%dh
    43b0:	9f                   	lahf
    43b1:	26 20 00             	es and %al,(%rax)
    43b4:	00 3f                	add    %bh,(%rdi)
    43b6:	00 39                	add    %bh,(%rcx)
    43b8:	20 00                	and    %al,(%rax)
    43ba:	00 41 a4             	add    %al,-0x5c(%rcx)
    43bd:	01 34 00             	add    %esi,(%rax,%rax,1)
    43c0:	00 00                	add    %al,(%rax)
    43c2:	3c fd                	cmp    $0xfd,%al
    43c4:	02 6c 20 00          	add    0x0(%rax,%riz,1),%ch
    43c8:	00 3c 80             	add    %bh,(%rax,%rax,4)
    43cb:	03 75 20             	add    0x20(%rbp),%esi
    43ce:	00 00                	add    %al,(%rax)
    43d0:	41 a4                	rex.B movsb %ds:(%rsi),%es:(%rdi)
    43d2:	01 28                	add    %ebp,(%rax)
    43d4:	00 00                	add    %al,(%rax)
    43d6:	00 3c fe             	add    %bh,(%rsi,%rdi,8)
    43d9:	02 80 20 00 00 42    	add    0x42000020(%rax),%al
    43df:	06                   	(bad)
    43e0:	89 20                	mov    %esp,(%rax)
    43e2:	00 00                	add    %al,(%rax)
    43e4:	41 a4                	rex.B movsb %ds:(%rsi),%es:(%rdi)
    43e6:	01 28                	add    %ebp,(%rax)
    43e8:	00 00                	add    %al,(%rax)
    43ea:	00 3c ff             	add    %bh,(%rdi,%rdi,8)
    43ed:	02 93 20 00 00 3f    	add    0x3f000020(%rbx),%dl
    43f3:	80 20 9c             	andb   $0x9c,(%rax)
    43f6:	20 00                	and    %al,(%rax)
    43f8:	00 3f                	add    %bh,(%rdi)
    43fa:	08 a5 20 00 00 00    	or     %ah,0x20(%rbp)
    4400:	00 00                	add    %al,(%rax)
    4402:	00 41 a5             	add    %al,-0x5b(%rcx)
    4405:	01 1d 00 00 00 3c    	add    %ebx,0x3c000000(%rip)        # 3c00440b <_license+0x3c001fde>
    440b:	c7 02 f1 0f 00 00    	movl   $0xff1,(%rdx)
    4411:	42 06                	rex.X (bad)
    4413:	fa                   	cli
    4414:	0f 00 00             	sldt   (%rax)
    4417:	41 a5                	rex.B movsl %ds:(%rsi),%es:(%rdi)
    4419:	01 1d 00 00 00 3f    	add    %ebx,0x3f000000(%rip)        # 3f00441f <_license+0x3f001ff2>
    441f:	80 08 04             	orb    $0x4,(%rax)
    4422:	10 00                	adc    %al,(%rax)
    4424:	00 3f                	add    %bh,(%rdi)
    4426:	08 0d 10 00 00 00    	or     %cl,0x10(%rip)        # 443c <_license+0x200f>
    442c:	00 41 a6             	add    %al,-0x5a(%rcx)
    442f:	01 2c 00             	add    %ebp,(%rax,%rax,1)
    4432:	00 00                	add    %al,(%rax)
    4434:	3c c8                	cmp    $0xc8,%al
    4436:	02 22                	add    (%rdx),%ah
    4438:	10 00                	adc    %al,(%rax)
    443a:	00 42 06             	add    %al,0x6(%rdx)
    443d:	2b 10                	sub    (%rax),%edx
    443f:	00 00                	add    %al,(%rax)
    4441:	41 a6                	rex.B cmpsb %es:(%rdi),%ds:(%rsi)
    4443:	01 2c 00             	add    %ebp,(%rax,%rax,1)
    4446:	00 00                	add    %al,(%rax)
    4448:	3c c9                	cmp    $0xc9,%al
    444a:	02 35 10 00 00 3c    	add    0x3c000010(%rip),%dh        # 3c004460 <_license+0x3c002033>
    4450:	ca 02 3e             	lret   $0x3e02
    4453:	10 00                	adc    %al,(%rax)
    4455:	00 00                	add    %al,(%rax)
    4457:	00 3d 4b 1c 00 00    	add    %bh,0x1c4b(%rip)        # 60a8 <_license+0x3c7b>
    445d:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    445e:	01 d7                	add    %edx,%edi
    4460:	00 00                	add    %al,(%rax)
    4462:	00 00                	add    %al,(%rax)
    4464:	28 04 0a             	sub    %al,(%rdx,%rcx,1)
    4467:	3e 01 5d 54          	ds add %ebx,0x54(%rbp)
    446b:	1c 00                	sbb    $0x0,%al
    446d:	00 3e                	add    %bh,(%rsi)
    446f:	03 91 10 9f 64 1c    	add    0x1c649f10(%rcx),%edx
    4475:	00 00                	add    %al,(%rax)
    4477:	3e 01 53 6c          	ds add %edx,0x6c(%rbx)
    447b:	1c 00                	sbb    $0x0,%al
    447d:	00 3c 40             	add    %bh,(%rax,%rax,2)
    4480:	7c 1c                	jl     449e <_license+0x2071>
    4482:	00 00                	add    %al,(%rax)
    4484:	3c cb                	cmp    $0xcb,%al
    4486:	02 84 1c 00 00 3c cc 	add    -0x33c40000(%rsp,%rbx,1),%al
    448d:	02 8d 1c 00 00 3c    	add    0x3c00001c(%rbp),%cl
    4493:	cd 02                	int    $0x2
    4495:	95                   	xchg   %eax,%ebp
    4496:	1c 00                	sbb    $0x0,%al
    4498:	00 3c ce             	add    %bh,(%rsi,%rcx,8)
    449b:	02 9d 1c 00 00 3c    	add    0x3c00001c(%rbp),%bl
    44a1:	cf                   	iret
    44a2:	02 a5 1c 00 00 3c    	add    0x3c00001c(%rbp),%ah
    44a8:	d0 02                	rolb   (%rdx)
    44aa:	ae                   	scas   %es:(%rdi),%al
    44ab:	1c 00                	sbb    $0x0,%al
    44ad:	00 40 b8             	add    %al,-0x48(%rax)
    44b0:	1c 00                	sbb    $0x0,%al
    44b2:	00 a8 01 41 00 00    	add    %ch,0x4101(%rax)
    44b8:	00 11                	add    %dl,(%rcx)
    44ba:	75 03                	jne    44bf <_license+0x2092>
    44bc:	3a d2                	cmp    %dl,%dl
    44be:	02 c5                	add    %ch,%al
    44c0:	1c 00                	sbb    $0x0,%al
    44c2:	00 3a                	add    %bh,(%rdx)
    44c4:	d1 02                	roll   (%rdx)
    44c6:	cd 1c                	int    $0x1c
    44c8:	00 00                	add    %al,(%rax)
    44ca:	3e 01 52 d5          	ds add %edx,-0x2b(%rdx)
    44ce:	1c 00                	sbb    $0x0,%al
    44d0:	00 48 04             	add    %cl,0x4(%rax)
    44d3:	e5 1c                	in     $0x1c,%eax
    44d5:	00 00                	add    %al,(%rax)
    44d7:	3f                   	(bad)
    44d8:	00 ed                	add    %ch,%ch
    44da:	1c 00                	sbb    $0x0,%al
    44dc:	00 40 51             	add    %al,0x51(%rax)
    44df:	13 00                	adc    (%rax),%eax
    44e1:	00 a9 01 19 00 00    	add    %ch,0x1901(%rcx)
    44e7:	00 12                	add    %dl,(%rdx)
    44e9:	48 03 3e             	add    (%rsi),%rdi
    44ec:	03 70 0e             	add    0xe(%rax),%esi
    44ef:	9f                   	lahf
    44f0:	55                   	push   %rbp
    44f1:	13 00                	adc    (%rax),%eax
    44f3:	00 3c d4             	add    %bh,(%rsp,%rdx,8)
    44f6:	02 65 13             	add    0x13(%rbp),%ah
    44f9:	00 00                	add    %al,(%rax)
    44fb:	41 a9 01 19 00 00    	rex.B test $0x1901,%eax
    4501:	00 3c d3             	add    %bh,(%rbx,%rdx,8)
    4504:	02 6e 13             	add    0x13(%rsi),%ch
    4507:	00 00                	add    %al,(%rax)
    4509:	00 00                	add    %al,(%rax)
    450b:	00 00                	add    %al,(%rax)
    450d:	3d db 1e 00 00       	cmp    $0x1edb,%eax
    4512:	aa                   	stos   %al,%es:(%rdi)
    4513:	01 af 00 00 00 00    	add    %ebp,0x0(%rdi)
    4519:	24 04                	and    $0x4,%al
    451b:	0a 3e                	or     (%rsi),%bh
    451d:	01 5d e4             	add    %ebx,-0x1c(%rbp)
    4520:	1e                   	(bad)
    4521:	00 00                	add    %al,(%rax)
    4523:	3e 02 31             	ds add (%rcx),%dh
    4526:	9f                   	lahf
    4527:	f4                   	hlt
    4528:	1e                   	(bad)
    4529:	00 00                	add    %al,(%rax)
    452b:	3e 03 91 10 9f fc 1e 	ds add 0x1efc9f10(%rcx),%edx
    4532:	00 00                	add    %al,(%rax)
    4534:	3e 01 53 04          	ds add %edx,0x4(%rbx)
    4538:	1f                   	(bad)
    4539:	00 00                	add    %al,(%rax)
    453b:	3c f3                	cmp    $0xf3,%al
    453d:	02 14 1f             	add    (%rdi,%rbx,1),%dl
    4540:	00 00                	add    %al,(%rax)
    4542:	3c f4                	cmp    $0xf4,%al
    4544:	02 1c 1f             	add    (%rdi,%rbx,1),%bl
    4547:	00 00                	add    %al,(%rax)
    4549:	3c f5                	cmp    $0xf5,%al
    454b:	02 24 1f             	add    (%rdi,%rbx,1),%ah
    454e:	00 00                	add    %al,(%rax)
    4550:	3c f6                	cmp    $0xf6,%al
    4552:	02 2d 1f 00 00 3c    	add    0x3c00001f(%rip),%ch        # 3c004577 <_license+0x3c00214a>
    4558:	f7 02 35 1f 00 00    	testl  $0x1f35,(%rdx)
    455e:	3c f8                	cmp    $0xf8,%al
    4560:	02 3e                	add    (%rsi),%bh
    4562:	1f                   	(bad)
    4563:	00 00                	add    %al,(%rax)
    4565:	3c f9                	cmp    $0xf9,%al
    4567:	02 46 1f             	add    0x1f(%rsi),%al
    456a:	00 00                	add    %al,(%rax)
    456c:	3c fa                	cmp    $0xfa,%al
    456e:	02 4e 1f             	add    0x1f(%rsi),%cl
    4571:	00 00                	add    %al,(%rax)
    4573:	49 63 1f             	movslq (%r15),%rbx
    4576:	00 00                	add    %al,(%rax)
    4578:	ab                   	stos   %eax,%es:(%rdi)
    4579:	01 04 00             	add    %eax,(%rax,%rax,1)
    457c:	00 00                	add    %al,(%rax)
    457e:	11 4b 05             	adc    %ecx,0x5(%rbx)
    4581:	40 81 1f 00 00 ac 01 	rex sbbl $0x1ac0000,(%rdi)
    4588:	40 00 00             	rex add %al,(%rax)
    458b:	00 11                	add    %dl,(%rcx)
    458d:	53                   	push   %rbx
    458e:	03 3a                	add    (%rdx),%edi
    4590:	fc                   	cld
    4591:	02 8e 1f 00 00 3e    	add    0x3e00001f(%rsi),%cl
    4597:	01 53 9f             	add    %edx,-0x61(%rbx)
    459a:	1f                   	(bad)
    459b:	00 00                	add    %al,(%rax)
    459d:	3a fb                	cmp    %bl,%bh
    459f:	02 a7 1f 00 00 48    	add    0x4800001f(%rdi),%ah
    45a5:	29 af 1f 00 00 00    	sub    %ebp,0x1f(%rdi)
    45ab:	00 00                	add    %al,(%rax)
    45ad:	4b 01 50 ad          	rex.WXB add %rdx,-0x53(%r8)
    45b1:	01 4b 01             	add    %ecx,0x1(%rbx)
    45b4:	50                   	push   %rax
    45b5:	ae                   	scas   %es:(%rdi),%al
    45b6:	01 4b 01             	add    %ecx,0x1(%rbx)
    45b9:	50                   	push   %rax
    45ba:	af                   	scas   %es:(%rdi),%eax
    45bb:	01 4b 01             	add    %ecx,0x1(%rbx)
    45be:	50                   	push   %rax
    45bf:	b0 01                	mov    $0x1,%al
    45c1:	4b 01 50 b1          	rex.WXB add %rdx,-0x4f(%r8)
    45c5:	01 4b 01             	add    %ecx,0x1(%rbx)
    45c8:	50                   	push   %rax
    45c9:	b2 01                	mov    $0x1,%dl
    45cb:	4b 01 50 b3          	rex.WXB add %rdx,-0x4d(%r8)
    45cf:	01 4b 01             	add    %ecx,0x1(%rbx)
    45d2:	50                   	push   %rax
    45d3:	b4 01                	mov    $0x1,%ah
    45d5:	4b 01 52 b5          	rex.WXB add %rdx,-0x4b(%r10)
    45d9:	01 4b 01             	add    %ecx,0x1(%rbx)
    45dc:	50                   	push   %rax
    45dd:	b6 01                	mov    $0x1,%dh
    45df:	4b 01 50 b7          	rex.WXB add %rdx,-0x49(%r8)
    45e3:	01 4b 01             	add    %ecx,0x1(%rbx)
    45e6:	50                   	push   %rax
    45e7:	b8 01 4b 01 50       	mov    $0x50014b01,%eax
    45ec:	b9 01 4b 01 50       	mov    $0x50014b01,%ecx
    45f1:	ba 01 4b 01 50       	mov    $0x50014b01,%edx
    45f6:	bb 01 4b 01 50       	mov    $0x50014b01,%ebx
    45fb:	bc 01 4b 01 50       	mov    $0x50014b01,%esp
    4600:	bd 01 4b 01 52       	mov    $0x52014b01,%ebp
    4605:	be 01 4b 01 50       	mov    $0x50014b01,%esi
    460a:	bf 01 4b 01 50       	mov    $0x50014b01,%edi
    460f:	c0 01 4b             	rolb   $0x4b,(%rcx)
    4612:	01 50 c1             	add    %edx,-0x3f(%rax)
    4615:	01 4b 01             	add    %ecx,0x1(%rbx)
    4618:	50                   	push   %rax
    4619:	c2 01 4b             	ret    $0x4b01
    461c:	01 50 c3             	add    %edx,-0x3d(%rax)
    461f:	01 4b 01             	add    %ecx,0x1(%rbx)
    4622:	50                   	push   %rax
    4623:	c4 01 4b 01          	(bad)
    4627:	50                   	push   %rax
    4628:	c5 01 4b             	(bad)
    462b:	01 50 c6             	add    %edx,-0x3a(%rax)
    462e:	01 4b 01             	add    %ecx,0x1(%rbx)
    4631:	50                   	push   %rax
    4632:	c7 01 4b 01 52 c8    	movl   $0xc852014b,(%rcx)
    4638:	01 4b 01             	add    %ecx,0x1(%rbx)
    463b:	50                   	push   %rax
    463c:	c9                   	leave
    463d:	01 4b 01             	add    %ecx,0x1(%rbx)
    4640:	50                   	push   %rax
    4641:	ca 01 4b             	lret   $0x4b01
    4644:	01 50 cb             	add    %edx,-0x35(%rax)
    4647:	01 4b 01             	add    %ecx,0x1(%rbx)
    464a:	50                   	push   %rax
    464b:	cc                   	int3
    464c:	01 4b 01             	add    %ecx,0x1(%rbx)
    464f:	50                   	push   %rax
    4650:	cd 01                	int    $0x1
    4652:	4b 01 50 ce          	rex.WXB add %rdx,-0x32(%r8)
    4656:	01 4b 01             	add    %ecx,0x1(%rbx)
    4659:	50                   	push   %rax
    465a:	cf                   	iret
    465b:	01 4b 01             	add    %ecx,0x1(%rbx)
    465e:	50                   	push   %rax
    465f:	d0 01                	rolb   (%rcx)
    4661:	4b 01 50 d1          	rex.WXB add %rdx,-0x2f(%r8)
    4665:	01 00                	add    %eax,(%rax)
	...

Disassembly of section .debug_rnglists:

0000000000000000 <.debug_rnglists>:
  void* data = (void*)(long)ctx->data;
   0:	03 04 00             	add    (%rax,%rax,1),%eax
   3:	00 05 00 08 00 32    	add    %al,0x32000800(%rip)        # 32000809 <_license+0x31ffe3dc>
   9:	00 00                	add    %al,(%rax)
   b:	00 c8                	add    %cl,%al
   d:	00 00                	add    %al,(%rax)
   f:	00 09                	add    %cl,(%rcx)
  11:	01 00                	add    %eax,(%rax)
  13:	00 19                	add    %bl,(%rcx)
  15:	01 00                	add    %eax,(%rax)
  17:	00 33                	add    %dh,(%rbx)
  void* data_end = (void*)(long)ctx->data_end;
  19:	01 00                	add    %eax,(%rax)
  1b:	00 3e                	add    %bh,(%rsi)
  if (data + nh_off > data_end) {
  1d:	01 00                	add    %eax,(%rax)
  1f:	00 4e 01             	add    %cl,0x1(%rsi)
  22:	00 00                	add    %al,(%rax)
  24:	59                   	pop    %rcx
  25:	01 00                	add    %eax,(%rax)
  27:	00 64 01 00          	add    %ah,0x0(%rcx,%rax,1)
  2b:	00 6f 01             	add    %ch,0x1(%rdi)
  2e:	00 00                	add    %al,(%rax)
  30:	7a 01                	jp     33 <balancer_ingress+0x33>
  eth_proto = eth->h_proto;
  32:	00 00                	add    %al,(%rax)
  34:	85 01                	test   %eax,(%rcx)
  if (eth_proto == BE_ETH_P_IP) {
  36:	00 00                	add    %al,(%rax)
  38:	90                   	nop
  39:	01 00                	add    %eax,(%rax)
  3b:	00 9b 01 00 00 ba    	add    %bl,-0x45ffffff(%rbx)
  41:	01 00                	add    %eax,(%rax)
  43:	00 cf                	add    %cl,%bh
  45:	01 00                	add    %eax,(%rax)
  47:	00 da                	add    %bl,%dl
  49:	01 00                	add    %eax,(%rax)
  4b:	00 ea                	add    %ch,%dl
  4d:	01 00                	add    %eax,(%rax)
  4f:	00 f5                	add    %dh,%ch
  struct packet_description pckt = {};
  51:	01 00                	add    %eax,(%rax)
  53:	00 00                	add    %al,(%rax)
  55:	02 00                	add    (%rax),%al
  57:	00 10                	add    %dl,(%rax)
  59:	02 00                	add    (%rax),%al
  5b:	00 1b                	add    %bl,(%rbx)
  5d:	02 00                	add    (%rax),%al
  5f:	00 26                	add    %ah,(%rsi)
  61:	02 00                	add    (%rax),%al
  63:	00 31                	add    %dh,(%rcx)
  65:	02 00                	add    (%rax),%al
  67:	00 3c 02             	add    %bh,(%rdx,%rax,1)
  6a:	00 00                	add    %al,(%rax)
  6c:	47 02 00             	rex.RXB add (%r8),%r8b
  6f:	00 52 02             	add    %dl,0x2(%rdx)
  72:	00 00                	add    %al,(%rax)
  74:	a8 02                	test   $0x2,%al
  76:	00 00                	add    %al,(%rax)
  78:	b3 02                	mov    $0x2,%bl
  7a:	00 00                	add    %al,(%rax)
  7c:	c8 02 00 00          	enter  $0x2,$0x0
  80:	d3 02                	roll   %cl,(%rdx)
  82:	00 00                	add    %al,(%rax)
  84:	de 02                	fiadds (%rdx)
  struct vip_definition vip = {};
  86:	00 00                	add    %al,(%rax)
  88:	e9 02 00 00 f4       	jmp    fffffffff400008f <server_id_map+0x36fcaad6408f>
  8d:	02 00                	add    (%rax),%al
  8f:	00 ff                	add    %bh,%bh
  91:	02 00                	add    (%rax),%al
  93:	00 0a                	add    %cl,(%rdx)
  95:	03 00                	add    (%rax),%eax
  97:	00 15 03 00 00 20    	add    %dl,0x20000003(%rip)        # 200000a0 <_license+0x1fffdc73>
  9d:	03 00                	add    (%rax),%eax
  9f:	00 44 03 00          	add    %al,0x0(%rbx,%rax,1)
    if (iph + 1 > data_end) {
  a3:	00 59 03             	add    %bl,0x3(%rcx)
  a6:	00 00                	add    %al,(%rax)
  a8:	64 03 00             	add    %fs:(%rax),%eax
  ab:	00 79 03             	add    %bh,0x3(%rcx)
    if (iph->ihl != 5) {
  ae:	00 00                	add    %al,(%rax)
  b0:	84 03                	test   %al,(%rbx)
  b2:	00 00                	add    %al,(%rax)
  b4:	94                   	xchg   %eax,%esp
  b5:	03 00                	add    (%rax),%eax
  b7:	00 a9 03 00 00 b4    	add    %ch,-0x4bfffffd(%rcx)
    pckt->tos = iph->tos;
  bd:	03 00                	add    (%rax),%eax
  bf:	00 c4                	add    %al,%ah
    *protocol = iph->protocol;
  c1:	03 00                	add    (%rax),%eax
    pckt->flow.proto = *protocol;
  c3:	00 cf                	add    %cl,%bh
  c5:	03 00                	add    (%rax),%eax
    if (iph->frag_off & PCKT_FRAGMENTED) {
  c7:	00 da                	add    %bl,%dl
  c9:	03 00                	add    (%rax),%eax
  cb:	00 e5                	add    %ah,%ch
  cd:	03 00                	add    (%rax),%eax
  cf:	00 f0                	add    %dh,%al
  d1:	03 00                	add    (%rax),%eax
  d3:	00 04 50             	add    %al,(%rax,%rdx,2)
  d6:	df 02                	filds  (%rdx)
  d8:	04 a6                	add    $0xa6,%al
  da:	08 c7                	or     %al,%bh
    if (*protocol == IPPROTO_ICMP) {
  dc:	09 04 cc             	or     %eax,(%rsp,%rcx,8)
  df:	12 bc 13 04 f2 13 a1 	adc    -0x5eec0dfc(%rbx,%rdx,1),%bh
  if (icmp_hdr + 1 > data_end) {
  e6:	16                   	(bad)
  e7:	04 d6                	add    $0xd6,%al
  e9:	16                   	(bad)
  ea:	b6 1c                	mov    $0x1c,%dh
  ec:	04 ce                	add    $0xce,%al
  ee:	1d 84 1e 04 c2       	sbb    $0xc2041e84,%eax
  if (icmp_hdr->type == ICMP_ECHO) {
  f3:	1e                   	(bad)
  f4:	dc 20                	fsubl  (%rax)
  f6:	04 c9                	add    $0xc9,%al
  f8:	21 8c 23 04 e5 23 95 	and    %ecx,-0x6adc1afc(%rbx,%riz,1)
  ff:	2e 04 85             	cs add $0x85,%al
 102:	2f                   	(bad)
 103:	e2 30                	loop   135 <balancer_ingress+0x135>
 105:	04 ba                	add    $0xba,%al
 107:	42 94                	rex.X xchg %eax,%esp
 109:	43 04 fe             	rex.XB add $0xfe,%al
 10c:	43 93                	rex.XB xchg %eax,%r11d
  icmp_hdr->type = ICMP_ECHOREPLY;
 10e:	45 04 c4             	rex.RB add $0xc4,%al
 111:	46 ad                	rex.RX lods %ds:(%rsi),%eax
  icmp_hdr->checksum += 0x0008;
 113:	48 00 04 a0          	rex.W add %al,(%rax,%riz,4)
  iph->ttl = DEFAULT_TTL;
 117:	01 d7                	add    %edx,%edi
 119:	01 04 db             	add    %eax,(%rbx,%rbx,8)
  iph->daddr = iph->saddr;
 11c:	01 e3                	add    %esp,%ebx
  tmp_addr = iph->daddr;
 11e:	01 04 a6             	add    %eax,(%rsi,%riz,4)
  iph->daddr = iph->saddr;
 121:	08 b4 08 00 04 e3 01 	or     %dh,0x1e30400(%rax,%rcx,1)
 128:	df 02                	filds  (%rdx)
 12a:	04 b4                	add    $0xb4,%al
 12c:	08 fc                	or     %bh,%ah
 12e:	08 04 cc             	or     %al,(%rsp,%rcx,8)
 131:	12 bc 13 04 d6 16 92 	adc    -0x6de929fc(%rbx,%rdx,1),%bh
 138:	17                   	(bad)
 139:	04 97                	add    $0x97,%al
 13b:	17                   	(bad)
 13c:	c4                   	(bad)
 13d:	17                   	(bad)
 13e:	00 04 e3             	add    %al,(%rbx,%riz,8)
 141:	01 df                	add    %ebx,%edi
 143:	02 04 cc             	add    (%rsp,%rcx,8),%al
 146:	12 bc 13 00 04 b8 08 	adc    0x8b80400(%rbx,%rdx,1),%bh
 14d:	fc                   	cld
 14e:	08 04 d6             	or     %al,(%rsi,%rdx,8)
 151:	16                   	(bad)
 152:	92                   	xchg   %eax,%edx
 153:	17                   	(bad)
 154:	04 97                	add    $0x97,%al
 156:	17                   	(bad)
 157:	c4                   	(bad)
 158:	17                   	(bad)
 159:	00 04 f2             	add    %al,(%rdx,%rsi,8)
 15c:	13 cf                	adc    %edi,%ecx
 15e:	14 04                	adc    $0x4,%al
  struct packet_description pckt = {};
 160:	d3 14 a1             	rcll   %cl,(%rcx,%riz,4)
 163:	16                   	(bad)
 164:	00 04 f2             	add    %al,(%rdx,%rsi,8)
 167:	13 cf                	adc    %edi,%ecx
 169:	14 04                	adc    $0x4,%al
 16b:	fa                   	cli
 16c:	15 fd 15 00 04       	adc    $0x40015fd,%eax
 171:	d3 14 fa             	rcll   %cl,(%rdx,%rdi,8)
 174:	15 04 fd 15 a1       	adc    $0xa115fd04,%eax
 179:	16                   	(bad)
 17a:	00 04 e5 17 c2 18 04 	add    %al,0x418c217(,%riz,8)
 181:	e9 19 ec 19 00       	jmp    19ed9f <_license+0x19c972>
 186:	04 c2                	add    $0xc2,%al
 188:	18 e9                	sbb    %ch,%cl
 18a:	19 04 ec             	sbb    %eax,(%rsp,%rbp,8)
 18d:	19 99 1a 00 04 fa    	sbb    %ebx,-0x5fbffe6(%rcx)
 193:	1b 85 1c 04 c2 1e    	sbb    0x1ec2041c(%rbp),%eax
  struct vip_definition vip = {};
 199:	db 1e                	fistpl (%rsi)
 19b:	00 04 fa             	add    %al,(%rdx,%rdi,8)
 19e:	1b 85 1c 04 c2 1e    	sbb    0x1ec2041c(%rbp),%eax
 1a4:	db 1e                	fistpl (%rsi)
 1a6:	00 04 8b             	add    %al,(%rbx,%rcx,4)
 1a9:	1f                   	(bad)
 1aa:	be 1f 04 c9 21       	mov    $0x21c9041f,%esi
    if (ip6h + 1 > data_end) {
 1af:	8c 23                	mov    %fs,(%rbx)
 1b1:	04 c3                	add    $0xc3,%al
 1b3:	30 e2                	xor    %ah,%dl
 1b5:	30 04 ba             	xor    %al,(%rdx,%rdi,4)
 1b8:	42 94                	rex.X xchg %eax,%esp
 1ba:	43 04 fe             	rex.XB add $0xfe,%al
    *protocol = ip6h->nexthdr;
 1bd:	43 93                	rex.XB xchg %eax,%r11d
    pckt->flow.proto = *protocol;
 1bf:	45 04 c4             	rex.RB add $0xc4,%al
 1c2:	46 a2 48 00 04 a4 1f 	rex.RX movabs %al,0x41fbe1fa4040048
 1c9:	be 1f 04 
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1cc:	c9                   	leave
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1cd:	21 c0                	and    %eax,%eax
 1cf:	22 04 c3             	and    (%rbx,%rax,8),%al
 1d2:	30 e2                	xor    %ah,%dl
 1d4:	30 04 ba             	xor    %al,(%rdx,%rdi,4)
 1d7:	42 fd                	rex.X std
    if (*protocol == IPPROTO_FRAGMENT) {
 1d9:	42 00 04 aa          	add    %al,(%rdx,%r13,4)
 1dd:	22 c0                	and    %al,%al
 1df:	22 04 c3             	and    (%rbx,%rax,8),%al
 1e2:	30 cd                	xor    %cl,%ch
 1e4:	30 00                	xor    %al,(%rax)
 1e6:	04 85                	add    $0x85,%al
 1e8:	43 94                	rex.XB xchg %eax,%r12d
 1ea:	43 04 fe             	rex.XB add $0xfe,%al
  if (icmp_hdr + 1 > data_end) {
 1ed:	43 93                	rex.XB xchg %eax,%r11d
 1ef:	45 04 c4             	rex.RB add $0xc4,%al
 1f2:	46 a2 48 00 04 85 43 	rex.RX movabs %al,0x443944385040048
 1f9:	94 43 04 
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 1fc:	fe 43 84             	incb   -0x7c(%rbx)
 1ff:	44 00 04 a1          	add    %r8b,(%rcx,%riz,4)
 203:	44 fe 44 04 c4       	rex.R incb -0x3c(%rsp,%rax,1)
 208:	46 a2 48 00 04 d2 44 	rex.RX movabs %al,0x444f244d2040048
 20f:	f2 44 04 
 212:	c4                   	(bad)
 213:	46 8f 47 04          	rex.RX pop 0x4(%rdi)
 217:	cf                   	iret
 218:	47 92                	rex.RXB xchg %eax,%r10d
 21a:	48 00 04 c4          	rex.W add %al,(%rsp,%rax,8)
 21e:	46 8d 47 04          	rex.RX lea 0x4(%rdi),%r8d
 222:	cf                   	iret
 223:	47 e1 47             	rex.RXB loope 26d <balancer_ingress+0x26d>
 226:	00 04 9b             	add    %al,(%rbx,%rbx,4)
 229:	20 dc                	and    %bl,%ah
 22b:	20 04 e5 23 93 24 00 	and    %al,0x249323(,%riz,8)
 232:	04 94                	add    $0x94,%al
 234:	29 cc                	sub    %ecx,%esp
 236:	2c 04                	sub    $0x4,%al
 238:	85 2f                	test   %ebp,(%rdi)
 23a:	ac                   	lods   %ds:(%rsi),%al
 23b:	2f                   	(bad)
 23c:	00 04 8e             	add    %al,(%rsi,%rcx,4)
 23f:	2a d4                	sub    %ah,%dl
 241:	2b 04 88             	sub    (%rax,%rcx,4),%eax
 244:	2c b0                	sub    $0xb0,%al
 246:	2c 00                	sub    $0x0,%al
 248:	04 b0                	add    $0xb0,%al
 24a:	2b b6 2b 04 bc 2b    	sub    0x2bbc042b(%rsi),%esi
 250:	c8 2b 00 04          	enter  $0x2b,$0x4
 254:	b0 2b                	mov    $0x2b,%al
 256:	b6 2b                	mov    $0x2b,%dh
 258:	04 bc                	add    $0xbc,%al
 25a:	2b c8                	sub    %eax,%ecx
 25c:	2b 00                	sub    (%rax),%eax
 25e:	04 df                	add    $0xdf,%al
 260:	02 9a 04 04 88 05    	add    0x5880404(%rdx),%bl
 266:	c2 06 04             	ret    $0x406
 269:	e4 07                	in     $0x7,%al
 26b:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
 26c:	08 04 d1             	or     %al,(%rcx,%rdx,8)
 26f:	09 f6                	or     %esi,%esi
 271:	0c 04                	or     $0x4,%al
 273:	80 0d cc 12 04 bc 13 	orb    $0x13,-0x43fbed34(%rip)        # ffffffffbc041546 <server_id_map+0x36fc72da5546>
 27a:	f2 13 04 b6          	repnz adc (%rsi,%rsi,4),%eax
 27e:	1c ce                	sbb    $0xce,%al
 280:	1d 04 8e 1e c2       	sbb    $0xc21e8e04,%eax
 285:	1e                   	(bad)
 286:	04 ec                	add    $0xec,%al
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 288:	20 c9                	and    %cl,%cl
 28a:	21 04 8c             	and    %eax,(%rsp,%rcx,4)
 28d:	23 e5                	and    %ebp,%esp
 28f:	23 04 95 2e fb 2e 04 	and    0x42efb2e(,%rdx,4),%eax
 296:	f5                   	cmc
 297:	30 aa 38 04 a7 39    	xor    %ch,0x39a70438(%rdx)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 29d:	ba 3e 04 db 3e       	mov    $0x3edb043e,%edx
 2a2:	b5 40                	mov    $0x40,%ch
 2a4:	04 c2                	add    $0xc2,%al
 2a6:	40 ba 42 04 9b 43    	rex mov $0x439b0442,%edx
  if (protocol == IPPROTO_ICMPV6) {
 2ac:	eb 43                	jmp    2f1 <balancer_ingress+0x2f1>
 2ae:	04 9d                	add    $0x9d,%al
 2b0:	45 c4                	rex.RB (bad)
 2b2:	46 00 04 af          	add    %r8b,(%rdi,%r13,4)
  if (icmp_hdr + 1 > data_end) {
 2b6:	03 ed                	add    %ebp,%ebp
 2b8:	03 04 88             	add    (%rax,%rcx,4),%eax
 2bb:	05 ac 05 00 04       	add    $0x40005ac,%eax
 2c0:	ed                   	in     (%dx),%eax
  if (icmp_hdr->type == ICMP_ECHO) {
 2c1:	03 9a 04 04 ac 05    	add    0x5ac0404(%rdx),%ebx
 2c7:	c2 06 04             	ret    $0x406
 2ca:	d1 09                	rorl   (%rcx)
 2cc:	bd 0a 04 e6 0f       	mov    $0xfe6040a,%ebp
 2d1:	d6                   	(bad)
 2d2:	10 00                	adc    %al,(%rax)
 2d4:	04 ed                	add    $0xed,%al
 2d6:	03 9a 04 04 d1 09    	add    0x9d10404(%rdx),%ebx
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2dc:	bd 0a 00 04 b4       	mov    $0xb404000a,%ebp
 2e1:	05 c2 06 04 e6       	add    $0xe60406c2,%eax
       sizeof(struct icmphdr)) > data_end) {
 2e6:	0f d6                	(bad)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2e8:	10 00                	adc    %al,(%rax)
 2ea:	04 de                	add    $0xde,%al
 2ec:	0a b6 0b 04 cb 0c    	or     0xccb040b(%rsi),%dh
  icmp_hdr->checksum += 0x0008;
 2f2:	ce                   	(bad)
 2f3:	0c 00                	or     $0x0,%al
 2f5:	04 b6                	add    $0xb6,%al
  iph->ttl = DEFAULT_TTL;
 2f7:	0b cb                	or     %ebx,%ecx
 2f9:	0c 04                	or     $0x4,%al
  iph->daddr = iph->saddr;
 2fb:	ce                   	(bad)
 2fc:	0c f6                	or     $0xf6,%al
  tmp_addr = iph->daddr;
 2fe:	0c 00                	or     $0x0,%al
  iph->daddr = iph->saddr;
 300:	04 80                	add    $0x80,%al
 302:	0d d8 0d 04 80       	or     $0x80040dd8,%eax
 307:	0f 83 0f 00 04 d8    	jae    ffffffffd804031c <server_id_map+0x36fc8eda431c>
 30d:	0d 80 0f 04 83       	or     $0x83040f80,%eax
 312:	0f b0 0f             	cmpxchg %cl,(%rdi)
 315:	00 04 90             	add    %al,(%rax,%rdx,4)
 318:	12 9b 12 04 b6 1c    	adc    0x1cb60412(%rbx),%bl
 31e:	cf                   	iret
 31f:	1c 00                	sbb    $0x0,%al
 321:	04 90                	add    $0x90,%al
 323:	12 9b 12 04 b6 1c    	adc    0x1cb60412(%rbx),%bl
 329:	cf                   	iret
 32a:	1c 00                	sbb    $0x0,%al
 32c:	04 f6                	add    $0xf6,%al
 32e:	1c ce                	sbb    $0xce,%al
 330:	1d 04 ec 20 c9       	sbb    $0xc920ec04,%eax
 335:	21 04 8c             	and    %eax,(%rsp,%rcx,4)
 338:	23 e5                	and    %ebp,%esp
 33a:	23 04 95 2e fb 2e 04 	and    0x42efb2e(,%rdx,4),%eax
 341:	f5                   	cmc
 342:	30 86 32 04 9b 43    	xor    %al,0x439b0432(%rsi)
 348:	eb 43                	jmp    38d <balancer_ingress+0x38d>
 34a:	04 9d                	add    $0x9d,%al
 34c:	45 a6                	rex.RB cmpsb %es:(%rdi),%ds:(%rsi)
 34e:	46 00 04 8f          	add    %r8b,(%rdi,%r9,4)
 352:	1d ce 1d 04 ec       	sbb    $0xec041dce,%eax
 357:	20 82 21 04 8c 23    	and    %al,0x238c0421(%rdx)
 35d:	e5 23                	in     $0x23,%eax
 35f:	04 95                	add    $0x95,%al
 361:	2e d8 2e             	cs fsubrs (%rsi)
 364:	00 04 ec             	add    %al,(%rsp,%rbp,8)
 367:	20 82 21 04 8c 23    	and    %al,0x238c0421(%rdx)
 36d:	96                   	xchg   %eax,%esi
 36e:	23 00                	and    (%rax),%eax
 370:	04 e0                	add    $0xe0,%al
 372:	2e fb                	cs sti
 374:	2e 04 f5             	cs add $0xf5,%al
 377:	30 86 32 04 9b 43    	xor    %al,0x439b0432(%rsi)
 37d:	eb 43                	jmp    3c2 <balancer_ingress+0x3c2>
 37f:	04 9d                	add    $0x9d,%al
 381:	45 a6                	rex.RB cmpsb %es:(%rdi),%ds:(%rsi)
 383:	46 00 04 e0          	add    %r8b,(%rax,%r12,8)
 387:	2e fb                	cs sti
 389:	2e 04 f5             	cs add $0xf5,%al
 38c:	30 fb                	xor    %bh,%bl
 38e:	30 00                	xor    %al,(%rax)
 390:	04 98                	add    $0x98,%al
 392:	31 fb                	xor    %edi,%ebx
 394:	31 04 9b             	xor    %eax,(%rbx,%rbx,4)
 397:	43 eb 43             	rex.XB jmp 3dd <balancer_ingress+0x3dd>
 39a:	04 9d                	add    $0x9d,%al
 39c:	45 a6                	rex.RB cmpsb %es:(%rdi),%ds:(%rsi)
 39e:	46 00 04 cf          	add    %r8b,(%rdi,%r9,8)
 3a2:	31 ef                	xor    %ebp,%edi
 3a4:	31 04 9b             	xor    %eax,(%rbx,%rbx,4)
 3a7:	43 eb 43             	rex.XB jmp 3ed <balancer_ingress+0x3ed>
 3aa:	04 9d                	add    $0x9d,%al
 3ac:	45 9f                	rex.RB lahf
 3ae:	45 04 d3             	rex.RB add $0xd3,%al
 3b1:	45 96                	rex.RB xchg %eax,%r14d
 3b3:	46 00 04 9b          	add    %r8b,(%rbx,%r11,4)
 3b7:	43 eb 43             	rex.XB jmp 3fd <balancer_ingress+0x3fd>
 3ba:	04 d3                	add    $0xd3,%al
 3bc:	45 e5 45             	rex.RB in $0x45,%eax
 3bf:	00 04 dd 39 ba 3e 04 	add    %al,0x43eba39(,%rbx,8)
 3c6:	db 3e                	fstpt  (%rsi)
 3c8:	f8                   	clc
 3c9:	3e 04 c2             	ds add $0xc2,%al
 3cc:	40 e9 40 00 04 cd    	rex jmp ffffffffcd040412 <server_id_map+0x36fc83da4412>
 3d2:	3a ee                	cmp    %dh,%ch
 3d4:	3d 04 9b 3e ba       	cmp    $0xba3e9b04,%eax
 3d9:	3e 00 04 d5 3a f7 3a 	ds add %al,0x43af73a(,%rdx,8)
 3e0:	04 
 3e1:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
 3e2:	3b af 3d 00 04 d9    	cmp    -0x26fbffc3(%rdi),%ebp
  if (protocol == IPPROTO_IPIP) {
 3e8:	3a f7                	cmp    %bh,%dh
 3ea:	3a 04 a7             	cmp    (%rdi,%riz,4),%al
 3ed:	3b d8                	cmp    %eax,%ebx
 3ef:	3c 00                	cmp    $0x0,%al
 3f1:	04 ce                	add    $0xce,%al
 3f3:	3d d4 3d 04 d6       	cmp    $0xd6043dd4,%eax
 3f8:	3d e2 3d 00 04       	cmp    $0x4003de2,%eax
  tcp = data + off;
 3fd:	ce                   	(bad)
 3fe:	3d d4 3d 04 d6       	cmp    $0xd6043dd4,%eax
 403:	3d                   	.byte 0x3d
 404:	e2 3d                	loop   443 <balancer_ingress+0x443>
	...

Disassembly of section .debug_str_offsets:

0000000000000000 <.debug_str_offsets>:
  void* data = (void*)(long)ctx->data;
   0:	f0 05 00 00 05 00    	lock add $0x50000,%eax
   6:	00 00                	add    %al,(%rax)
   8:	00 00                	add    %al,(%rax)
   a:	00 00                	add    %al,(%rax)
   c:	1c 00                	sbb    $0x0,%al
   e:	00 00                	add    %al,(%rax)
  10:	3a 00                	cmp    (%rax),%al
  12:	00 00                	add    %al,(%rax)
  14:	65 00 00             	add    %al,%gs:(%rax)
  17:	00 cd                	add    %cl,%ch
  void* data_end = (void*)(long)ctx->data_end;
  19:	00 00                	add    %al,(%rax)
  1b:	00 6e 00             	add    %ch,0x0(%rsi)
  if (data + nh_off > data_end) {
  1e:	00 00                	add    %al,(%rax)
  20:	82                   	(bad)
  21:	00 00                	add    %al,(%rax)
  23:	00 ef                	add    %ch,%bh
  25:	08 00                	or     %al,(%rax)
  27:	00 95 00 00 00 3c    	add    %dl,0x3c000000(%rbp)
  2d:	0c 00                	or     $0x0,%al
  2f:	00 8c 00 00 00 99 00 	add    %cl,0x990000(%rax,%rax,1)
  if (eth_proto == BE_ETH_P_IP) {
  36:	00 00                	add    %al,(%rax)
  38:	db 00                	fildl  (%rax)
  3a:	00 00                	add    %al,(%rax)
  3c:	9f                   	lahf
  3d:	00 00                	add    %al,(%rax)
  3f:	00 b2 00 00 00 b8    	add    %dh,-0x48000000(%rdx)
  45:	00 00                	add    %al,(%rax)
  47:	00 c0                	add    %al,%al
  49:	00 00                	add    %al,(%rax)
  4b:	00 c4                	add    %al,%ah
  4d:	00 00                	add    %al,(%rax)
  4f:	00 d2                	add    %dl,%dl
  struct packet_description pckt = {};
  51:	00 00                	add    %al,(%rax)
  53:	00 d7                	add    %dl,%bh
  55:	00 00                	add    %al,(%rax)
  57:	00 e1                	add    %ah,%cl
  59:	00 00                	add    %al,(%rax)
  5b:	00 ed                	add    %ch,%ch
  5d:	00 00                	add    %al,(%rax)
  5f:	00 65 0a             	add    %ah,0xa(%rbp)
  62:	00 00                	add    %al,(%rax)
  64:	ec                   	in     (%dx),%al
  65:	05 00 00 f7 00       	add    $0xf70000,%eax
  6a:	00 00                	add    %al,(%rax)
  6c:	fe 00                	incb   (%rax)
  6e:	00 00                	add    %al,(%rax)
  70:	05 01 00 00 0d       	add    $0xd000001,%eax
  75:	01 00                	add    %eax,(%rax)
  77:	00 19                	add    %bl,(%rcx)
  79:	01 00                	add    %eax,(%rax)
  7b:	00 c7                	add    %al,%bh
  7d:	0d 00 00 21 01       	or     $0x1210000,%eax
  82:	00 00                	add    %al,(%rax)
  84:	69 07 00 00 27 01    	imul   $0x1270000,(%rdi),%eax
  struct vip_definition vip = {};
  8a:	00 00                	add    %al,(%rax)
  8c:	36 01 00             	ss add %eax,(%rax)
  8f:	00 c1                	add    %al,%cl
  91:	0e                   	(bad)
  92:	00 00                	add    %al,(%rax)
  94:	3c 01                	cmp    $0x1,%al
  96:	00 00                	add    %al,(%rax)
  98:	f1                   	int1
  99:	00 00                	add    %al,(%rax)
  9b:	00 4b 01             	add    %cl,0x1(%rbx)
  9e:	00 00                	add    %al,(%rax)
    if (iph + 1 > data_end) {
  a0:	53                   	push   %rbx
  a1:	01 00                	add    %eax,(%rax)
  a3:	00 5c 01 00          	add    %bl,0x0(%rcx,%rax,1)
  a7:	00 55 0d             	add    %dl,0xd(%rbp)
  aa:	00 00                	add    %al,(%rax)
  ac:	6b 01 00             	imul   $0x0,(%rcx),%eax
    if (iph->ihl != 5) {
  af:	00 6b 0a             	add    %ch,0xa(%rbx)
  b2:	00 00                	add    %al,(%rax)
  b4:	71 01                	jno    b7 <balancer_ingress+0xb7>
  b6:	00 00                	add    %al,(%rax)
  b8:	77 01                	ja     bb <balancer_ingress+0xbb>
    pckt->tos = iph->tos;
  ba:	00 00                	add    %al,(%rax)
  bc:	7d 01                	jge    bf <balancer_ingress+0xbf>
  be:	00 00                	add    %al,(%rax)
    *protocol = iph->protocol;
  c0:	84 01                	test   %al,(%rcx)
  c2:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
  c4:	0a 08                	or     (%rax),%cl
  c6:	00 00                	add    %al,(%rax)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  c8:	8d 01                	lea    (%rcx),%eax
  ca:	00 00                	add    %al,(%rax)
  cc:	93                   	xchg   %eax,%ebx
  cd:	01 00                	add    %eax,(%rax)
  cf:	00 a0 01 00 00 ac    	add    %ah,-0x53ffffff(%rax)
  d5:	01 00                	add    %eax,(%rax)
  d7:	00 b3 01 00 00 bc    	add    %dh,-0x43ffffff(%rbx)
    if (*protocol == IPPROTO_ICMP) {
  dd:	01 00                	add    %eax,(%rax)
  df:	00 c2                	add    %al,%dl
  e1:	01 00                	add    %eax,(%rax)
  if (icmp_hdr + 1 > data_end) {
  e3:	00 d2                	add    %dl,%dl
  e5:	01 00                	add    %eax,(%rax)
  e7:	00 7d 02             	add    %bh,0x2(%rbp)
  ea:	00 00                	add    %al,(%rax)
  ec:	84 02                	test   %al,(%rdx)
  ee:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
  f0:	de 01                	fiadds (%rcx)
  f2:	00 00                	add    %al,(%rax)
  f4:	aa                   	stos   %al,%es:(%rdi)
  f5:	0d 00 00 e7 01       	or     $0x1e70000,%eax
  fa:	00 00                	add    %al,(%rax)
  fc:	89 08                	mov    %ecx,(%rax)
  fe:	00 00                	add    %al,(%rax)
 100:	f6 01 00             	testb  $0x0,(%rcx)
 103:	00 05 02 00 00 0f    	add    %al,0xf000002(%rip)        # f00010b <_license+0xeffdcde>
 109:	02 00                	add    (%rax),%al
 10b:	00 1b                	add    %bl,(%rbx)
 10d:	02 00                	add    (%rax),%al
  icmp_hdr->type = ICMP_ECHOREPLY;
 10f:	00 31                	add    %dh,(%rcx)
 111:	02 00                	add    (%rax),%al
  icmp_hdr->checksum += 0x0008;
 113:	00 4e 02             	add    %cl,0x2(%rsi)
 116:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 118:	59                   	pop    %rcx
 119:	02 00                	add    (%rax),%al
  iph->daddr = iph->saddr;
 11b:	00 72 02             	add    %dh,0x2(%rdx)
  tmp_addr = iph->daddr;
 11e:	00 00                	add    %al,(%rax)
 120:	79 02                	jns    124 <balancer_ingress+0x124>
  iph->daddr = iph->saddr;
 122:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
 124:	80 02 00             	addb   $0x0,(%rdx)
 127:	00 87 02 00 00 8e    	add    %al,-0x71fffffe(%rdi)
 12d:	02 00                	add    (%rax),%al
 12f:	00 9f 02 00 00 b3    	add    %bl,-0x4cfffffe(%rdi)
 135:	02 00                	add    (%rax),%al
 137:	00 c8                	add    %cl,%al
 139:	02 00                	add    (%rax),%al
 13b:	00 de                	add    %bl,%dh
 13d:	02 00                	add    (%rax),%al
 13f:	00 ee                	add    %ch,%dh
 141:	02 00                	add    (%rax),%al
 143:	00 02                	add    %al,(%rdx)
 145:	03 00                	add    (%rax),%eax
 147:	00 1d 03 00 00 2d    	add    %bl,0x2d000003(%rip)        # 2d000150 <_license+0x2cffdd23>
 14d:	03 00                	add    (%rax),%eax
 14f:	00 3b                	add    %bh,(%rbx)
 151:	03 00                	add    (%rax),%eax
 153:	00 49 03             	add    %cl,0x3(%rcx)
 156:	00 00                	add    %al,(%rax)
 158:	54                   	push   %rsp
 159:	03 00                	add    (%rax),%eax
 15b:	00 5c 03 00          	add    %bl,0x0(%rbx,%rax,1)
  struct packet_description pckt = {};
 15f:	00 71 03             	add    %dh,0x3(%rcx)
 162:	00 00                	add    %al,(%rax)
 164:	81 03 00 00 97 03    	addl   $0x3970000,(%rbx)
 16a:	00 00                	add    %al,(%rax)
 16c:	ab                   	stos   %eax,%es:(%rdi)
 16d:	03 00                	add    (%rax),%eax
 16f:	00 bc 03 00 00 c8 03 	add    %bh,0x3c80000(%rbx,%rax,1)
 176:	00 00                	add    %al,(%rax)
 178:	d1 03                	roll   (%rbx)
 17a:	00 00                	add    %al,(%rax)
 17c:	da 03                	fiaddl (%rbx)
 17e:	00 00                	add    %al,(%rax)
 180:	e1 03                	loope  185 <balancer_ingress+0x185>
 182:	00 00                	add    %al,(%rax)
 184:	ee                   	out    %al,(%dx)
 185:	03 00                	add    (%rax),%eax
 187:	00 f9                	add    %bh,%cl
 189:	03 00                	add    (%rax),%eax
 18b:	00 04 04             	add    %al,(%rsp,%rax,1)
 18e:	00 00                	add    %al,(%rax)
 190:	11 04 00             	adc    %eax,(%rax,%rax,1)
 193:	00 1e                	add    %bl,(%rsi)
  struct vip_definition vip = {};
 195:	04 00                	add    $0x0,%al
 197:	00 2b                	add    %ch,(%rbx)
 199:	04 00                	add    $0x0,%al
 19b:	00 37                	add    %dh,(%rdi)
 19d:	04 00                	add    $0x0,%al
 19f:	00 43 04             	add    %al,0x4(%rbx)
 1a2:	00 00                	add    %al,(%rax)
 1a4:	4f 04 00             	rex.WRXB add $0x0,%al
 1a7:	00 5b 04             	add    %bl,0x4(%rbx)
 1aa:	00 00                	add    %al,(%rax)
 1ac:	67 04 00             	addr32 add $0x0,%al
    if (ip6h + 1 > data_end) {
 1af:	00 72 04             	add    %dh,0x4(%rdx)
 1b2:	00 00                	add    %al,(%rax)
 1b4:	7f 04                	jg     1ba <balancer_ingress+0x1ba>
 1b6:	00 00                	add    %al,(%rax)
 1b8:	8c 04 00             	mov    %es,(%rax,%rax,1)
 1bb:	00 99 04 00 00 a5    	add    %bl,-0x5afffffc(%rcx)
    pckt->flow.proto = *protocol;
 1c1:	04 00                	add    $0x0,%al
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1c3:	00 b1 04 00 00 bc    	add    %dh,-0x43fffffc(%rcx)
 1c9:	04 00                	add    $0x0,%al
 1cb:	00 c8                	add    %cl,%al
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1cd:	04 00                	add    $0x0,%al
 1cf:	00 d7                	add    %dl,%bh
 1d1:	04 00                	add    $0x0,%al
 1d3:	00 e5                	add    %ah,%ch
 1d5:	04 00                	add    $0x0,%al
 1d7:	00 f1                	add    %dh,%cl
    if (*protocol == IPPROTO_FRAGMENT) {
 1d9:	04 00                	add    $0x0,%al
 1db:	00 fe                	add    %bh,%dh
 1dd:	04 00                	add    $0x0,%al
 1df:	00 0b                	add    %cl,(%rbx)
 1e1:	05 00 00 18 05       	add    $0x5180000,%eax
 1e6:	00 00                	add    %al,(%rax)
 1e8:	28 05 00 00 35 05    	sub    %al,0x5350000(%rip)        # 53501ee <_license+0x534ddc1>
  if (icmp_hdr + 1 > data_end) {
 1ee:	00 00                	add    %al,(%rax)
 1f0:	46 05 00 00 56 05    	rex.RX add $0x5560000,%eax
 1f6:	00 00                	add    %al,(%rax)
 1f8:	62 05                	(bad)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 1fa:	00 00                	add    %al,(%rax)
 1fc:	6e                   	outsb  %ds:(%rsi),(%dx)
 1fd:	05 00 00 7c 05       	add    $0x57c0000,%eax
 202:	00 00                	add    %al,(%rax)
 204:	ad                   	lods   %ds:(%rsi),%eax
 205:	00 00                	add    %al,(%rax)
 207:	00 88 05 00 00 e0    	add    %cl,-0x1ffffffb(%rax)
 20d:	07                   	(bad)
 20e:	00 00                	add    %al,(%rax)
 210:	91                   	xchg   %eax,%ecx
 211:	05 00 00 9a 05       	add    $0x59a0000,%eax
 216:	00 00                	add    %al,(%rax)
 218:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
 219:	05 00 00 ad 05       	add    $0x5ad0000,%eax
 21e:	00 00                	add    %al,(%rax)
 220:	b5 05                	mov    $0x5,%ch
 222:	00 00                	add    %al,(%rax)
 224:	bf 05 00 00 c5       	mov    $0xc5000005,%edi
 229:	05 00 00 cb 05       	add    $0x5cb0000,%eax
 22e:	00 00                	add    %al,(%rax)
 230:	d4                   	(bad)
 231:	05 00 00 de 05       	add    $0x5de0000,%eax
 236:	00 00                	add    %al,(%rax)
 238:	e8 05 00 00 f1       	call   fffffffff1000242 <server_id_map+0x36fca7d64242>
 23d:	05 00 00 f7 05       	add    $0x5f70000,%eax
 242:	00 00                	add    %al,(%rax)
 244:	fd                   	std
 245:	05 00 00 05 06       	add    $0x6050000,%eax
 24a:	00 00                	add    %al,(%rax)
 24c:	09 06                	or     %eax,(%rsi)
 24e:	00 00                	add    %al,(%rax)
 250:	0d 06 00 00 57       	or     $0x57000006,%eax
 255:	06                   	(bad)
 256:	00 00                	add    %al,(%rax)
 258:	15 06 00 00 ab       	adc    $0xab000006,%eax
 25d:	0a 00                	or     (%rax),%al
 25f:	00 1e                	add    %bl,(%rsi)
 261:	06                   	(bad)
 262:	00 00                	add    %al,(%rax)
 264:	27                   	(bad)
 265:	06                   	(bad)
 266:	00 00                	add    %al,(%rax)
 268:	2d 06 00 00 35       	sub    $0x35000006,%eax
 26d:	06                   	(bad)
 26e:	00 00                	add    %al,(%rax)
 270:	3b 06                	cmp    (%rsi),%eax
 272:	00 00                	add    %al,(%rax)
 274:	48 06                	rex.W (bad)
 276:	00 00                	add    %al,(%rax)
 278:	5a                   	pop    %rdx
 279:	06                   	(bad)
 27a:	00 00                	add    %al,(%rax)
 27c:	4c 06                	rex.WR (bad)
 27e:	00 00                	add    %al,(%rax)
 280:	6b 06 00             	imul   $0x0,(%rsi),%eax
 283:	00 9b 00 00 00 7d    	add    %bl,0x7d000000(%rbx)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 289:	06                   	(bad)
 28a:	00 00                	add    %al,(%rax)
 28c:	8c 06                	mov    %es,(%rsi)
 28e:	00 00                	add    %al,(%rax)
 290:	56                   	push   %rsi
 291:	0b 00                	or     (%rax),%eax
 293:	00 90 06 00 00 99    	add    %dl,-0x66fffffa(%rax)
 299:	06                   	(bad)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 29a:	00 00                	add    %al,(%rax)
 29c:	a3 06 00 00 b3 06 00 	movabs %eax,0xb7000006b3000006
 2a3:	00 b7 
 2a5:	06                   	(bad)
 2a6:	00 00                	add    %al,(%rax)
 2a8:	c4                   	(bad)
 2a9:	06                   	(bad)
 2aa:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 2ac:	c8 06 00 00          	enter  $0x6,$0x0
 2b0:	d5                   	(bad)
 2b1:	06                   	(bad)
 2b2:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 2b4:	de 06                	fiadds (%rsi)
 2b6:	00 00                	add    %al,(%rax)
 2b8:	e5 06                	in     $0x6,%eax
 2ba:	00 00                	add    %al,(%rax)
 2bc:	ec                   	in     (%dx),%al
 2bd:	06                   	(bad)
 2be:	00 00                	add    %al,(%rax)
 2c0:	f4                   	hlt
  if (icmp_hdr->type == ICMP_ECHO) {
 2c1:	06                   	(bad)
 2c2:	00 00                	add    %al,(%rax)
 2c4:	c4                   	(bad)
 2c5:	0a 00                	or     (%rax),%al
 2c7:	00 fa                	add    %bh,%dl
 2c9:	06                   	(bad)
 2ca:	00 00                	add    %al,(%rax)
 2cc:	ff 06                	incl   (%rsi)
 2ce:	00 00                	add    %al,(%rax)
 2d0:	0a 07                	or     (%rdi),%al
 2d2:	00 00                	add    %al,(%rax)
 2d4:	1d 07 00 00 2a       	sbb    $0x2a000007,%eax
 2d9:	07                   	(bad)
 2da:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2dc:	f2 03 00             	repnz add (%rax),%eax
 2df:	00 31                	add    %dh,(%rcx)
 2e1:	07                   	(bad)
 2e2:	00 00                	add    %al,(%rax)
       sizeof(struct icmphdr)) > data_end) {
 2e4:	ce                   	(bad)
 2e5:	0a 00                	or     (%rax),%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2e7:	00 3a                	add    %bh,(%rdx)
 2e9:	07                   	(bad)
 2ea:	00 00                	add    %al,(%rax)
 2ec:	45 07                	rex.RB (bad)
  icmp_hdr->type = ICMP_ECHOREPLY;
 2ee:	00 00                	add    %al,(%rax)
 2f0:	4d 07                	rex.WRB (bad)
  icmp_hdr->checksum += 0x0008;
 2f2:	00 00                	add    %al,(%rax)
 2f4:	55                   	push   %rbp
 2f5:	07                   	(bad)
  iph->ttl = DEFAULT_TTL;
 2f6:	00 00                	add    %al,(%rax)
 2f8:	5f                   	pop    %rdi
 2f9:	07                   	(bad)
  iph->daddr = iph->saddr;
 2fa:	00 00                	add    %al,(%rax)
 2fc:	6e                   	outsb  %ds:(%rsi),(%dx)
  tmp_addr = iph->daddr;
 2fd:	07                   	(bad)
 2fe:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
 300:	73 07                	jae    309 <balancer_ingress+0x309>
 302:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
 304:	7b 07                	jnp    30d <balancer_ingress+0x30d>
 306:	00 00                	add    %al,(%rax)
 308:	80 07 00             	addb   $0x0,(%rdi)
 30b:	00 87 07 00 00 8b    	add    %al,-0x74fffff9(%rdi)
 311:	07                   	(bad)
 312:	00 00                	add    %al,(%rax)
 314:	95                   	xchg   %eax,%ebp
 315:	07                   	(bad)
 316:	00 00                	add    %al,(%rax)
 318:	a1 07 00 00 af 07 00 	movabs 0xb9000007af000007,%eax
 31f:	00 b9 
 321:	07                   	(bad)
 322:	00 00                	add    %al,(%rax)
 324:	c1 07 00             	roll   $0x0,(%rdi)
 327:	00 cb                	add    %cl,%bl
 329:	02 00                	add    (%rax),%al
 32b:	00 d8                	add    %bl,%al
 32d:	07                   	(bad)
 32e:	00 00                	add    %al,(%rax)
 330:	27                   	(bad)
 331:	02 00                	add    (%rax),%al
 333:	00 dc                	add    %bl,%ah
 335:	07                   	(bad)
 336:	00 00                	add    %al,(%rax)
 338:	e8 07 00 00 f3       	call   fffffffff3000344 <server_id_map+0x36fca9d64344>
 33d:	07                   	(bad)
 33e:	00 00                	add    %al,(%rax)
 340:	05 08 00 00 0e       	add    $0xe000008,%eax
 345:	08 00                	or     %al,(%rax)
 347:	00 12                	add    %dl,(%rdx)
 349:	08 00                	or     %al,(%rax)
 34b:	00 23                	add    %ah,(%rbx)
 34d:	08 00                	or     %al,(%rax)
 34f:	00 27                	add    %ah,(%rdi)
 351:	08 00                	or     %al,(%rax)
 353:	00 2c 08             	add    %ch,(%rax,%rcx,1)
 356:	00 00                	add    %al,(%rax)
 358:	1a 06                	sbb    (%rsi),%al
 35a:	00 00                	add    %al,(%rax)
 35c:	37                   	(bad)
 35d:	08 00                	or     %al,(%rax)
 35f:	00 fa                	add    %bh,%dl
 361:	08 00                	or     %al,(%rax)
 363:	00 40 08             	add    %al,0x8(%rax)
 366:	00 00                	add    %al,(%rax)
 368:	15 09 00 00 4e       	adc    $0x4e000009,%eax
 36d:	09 00                	or     %eax,(%rax)
 36f:	00 49 08             	add    %cl,0x8(%rcx)
 372:	00 00                	add    %al,(%rax)
 374:	52                   	push   %rdx
 375:	08 00                	or     %al,(%rax)
 377:	00 5a 08             	add    %bl,0x8(%rdx)
 37a:	00 00                	add    %al,(%rax)
 37c:	5f                   	pop    %rdi
 37d:	08 00                	or     %al,(%rax)
 37f:	00 68 08             	add    %ch,0x8(%rax)
 382:	00 00                	add    %al,(%rax)
 384:	6c                   	insb   (%dx),%es:(%rdi)
 385:	08 00                	or     %al,(%rax)
 387:	00 75 08             	add    %dh,0x8(%rbp)
 38a:	00 00                	add    %al,(%rax)
 38c:	7d 08                	jge    396 <balancer_ingress+0x396>
 38e:	00 00                	add    %al,(%rax)
 390:	8f 08 00 00          	(bad)
 394:	9e                   	sahf
 395:	08 00                	or     %al,(%rax)
 397:	00 ae 08 00 00 b7    	add    %ch,-0x48fffff8(%rsi)
 39d:	08 00                	or     %al,(%rax)
 39f:	00 bc 08 00 00 cd 08 	add    %bh,0x8cd0000(%rax,%rcx,1)
 3a6:	00 00                	add    %al,(%rax)
 3a8:	da 08                	fimull (%rax)
 3aa:	00 00                	add    %al,(%rax)
 3ac:	dc 08                	fmull  (%rax)
 3ae:	00 00                	add    %al,(%rax)
 3b0:	e9 08 00 00 f4       	jmp    fffffffff40003bd <server_id_map+0x36fcaad643bd>
 3b5:	08 00                	or     %al,(%rax)
 3b7:	00 ff                	add    %bh,%bh
 3b9:	08 00                	or     %al,(%rax)
 3bb:	00 0b                	add    %cl,(%rbx)
 3bd:	09 00                	or     %eax,(%rax)
 3bf:	00 18                	add    %bl,(%rax)
 3c1:	09 00                	or     %eax,(%rax)
 3c3:	00 22                	add    %ah,(%rdx)
 3c5:	09 00                	or     %eax,(%rax)
 3c7:	00 2c 09             	add    %ch,(%rcx,%rcx,1)
 3ca:	00 00                	add    %al,(%rax)
 3cc:	35 09 00 00 3c       	xor    $0x3c000009,%eax
 3d1:	09 00                	or     %eax,(%rax)
 3d3:	00 47 09             	add    %al,0x9(%rdi)
 3d6:	00 00                	add    %al,(%rax)
 3d8:	53                   	push   %rbx
 3d9:	09 00                	or     %eax,(%rax)
 3db:	00 5d 09             	add    %bl,0x9(%rbp)
 3de:	00 00                	add    %al,(%rax)
 3e0:	66 09 00             	or     %ax,(%rax)
 3e3:	00 70 09             	add    %dh,0x9(%rax)
  if (protocol == IPPROTO_IPIP) {
 3e6:	00 00                	add    %al,(%rax)
 3e8:	77 09                	ja     3f3 <balancer_ingress+0x3f3>
 3ea:	00 00                	add    %al,(%rax)
 3ec:	81 09 00 00 90 09    	orl    $0x9900000,(%rcx)
 3f2:	00 00                	add    %al,(%rax)
 3f4:	98                   	cwtl
 3f5:	09 00                	or     %eax,(%rax)
 3f7:	00 a4 09 00 00 af 09 	add    %ah,0x9af0000(%rcx,%rcx,1)
  tcp = data + off;
 3fe:	00 00                	add    %al,(%rax)
  if (is_ipv6) {
 400:	b5 09                	mov    $0x9,%ch
  tcp = data + off;
 402:	00 00                	add    %al,(%rax)
 404:	bd 09 00 00 c9       	mov    $0xc9000009,%ebp
  if (tcp + 1 > data_end) {
 409:	09 00                	or     %eax,(%rax)
 40b:	00 d6                	add    %dl,%dh
 40d:	09 00                	or     %eax,(%rax)
 40f:	00 df                	add    %bl,%bh
 411:	09 00                	or     %eax,(%rax)
  if (tcp->syn) {
 413:	00 f1                	add    %dh,%cl
 415:	09 00                	or     %eax,(%rax)
 417:	00 f7                	add    %dh,%bh
 419:	09 00                	or     %eax,(%rax)
 41b:	00 16                	add    %dl,(%rsi)
    pckt->flags |= F_SYN_SET;
 41d:	0b 00                	or     (%rax),%eax
 41f:	00 0f                	add    %cl,(%rdi)
 421:	0b 00                	or     (%rax),%eax
 423:	00 ff                	add    %bh,%bh
 425:	09 00                	or     %eax,(%rax)
      pckt->flow.src = iph->saddr;
 427:	00 fb                	add    %bh,%bl
 429:	09 00                	or     %eax,(%rax)
 42b:	00 03                	add    %al,(%rbx)
      pckt->flow.dst = iph->daddr;
 42d:	0a 00                	or     (%rax),%al
 42f:	00 06                	add    %al,(%rsi)
 431:	0a 00                	or     (%rax),%al
 433:	00 0b                	add    %cl,(%rbx)
  if (protocol == IPPROTO_ICMPV6) {
 435:	0a 00                	or     (%rax),%al
 437:	00 10                	add    %dl,(%rax)
  if (icmp_hdr + 1 > data_end) {
 439:	0a 00                	or     (%rax),%al
 43b:	00 58 03             	add    %bl,0x3(%rax)
 43e:	00 00                	add    %al,(%rax)
 440:	14 0a                	adc    $0xa,%al
 442:	00 00                	add    %al,(%rax)
 444:	18 0a                	sbb    %cl,(%rdx)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 446:	00 00                	add    %al,(%rax)
 448:	1c 0a                	sbb    $0xa,%al
 44a:	00 00                	add    %al,(%rax)
 44c:	20 0a                	and    %cl,(%rdx)
 44e:	00 00                	add    %al,(%rax)
 450:	24 0a                	and    $0xa,%al
 452:	00 00                	add    %al,(%rax)
 454:	28 0a                	sub    %cl,(%rdx)
 456:	00 00                	add    %al,(%rax)
 458:	2c 0a                	sub    $0xa,%al
 45a:	00 00                	add    %al,(%rax)
 45c:	33 0a                	xor    (%rdx),%ecx
 45e:	00 00                	add    %al,(%rax)
 460:	3b 0a                	cmp    (%rdx),%ecx
 462:	00 00                	add    %al,(%rax)
 464:	42 0a 00             	rex.X or (%rax),%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 467:	00 4e 0a             	add    %cl,0xa(%rsi)
 46a:	00 00                	add    %al,(%rax)
 46c:	5f                   	pop    %rdi
 46d:	0a 00                	or     (%rax),%al
       sizeof(struct icmp6hdr)) > data_end) {
 46f:	00 6f 0a             	add    %ch,0xa(%rdi)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 472:	00 00                	add    %al,(%rax)
 474:	78 0a                	js     480 <balancer_ingress+0x480>
 476:	00 00                	add    %al,(%rax)
 478:	88 0a                	mov    %cl,(%rdx)
 47a:	00 00                	add    %al,(%rax)
 47c:	37                   	(bad)
 47d:	03 00                	add    (%rax),%eax
 47f:	00 a1 0a 00 00 47    	add    %ah,0x4700000a(%rcx)
 485:	0a 00                	or     (%rax),%al
 487:	00 af 0a 00 00 c9    	add    %ch,-0x36fffff6(%rdi)
 48d:	0a 00                	or     (%rax),%al
 48f:	00 d8                	add    %bl,%al
 491:	0a 00                	or     (%rax),%al
 493:	00 e8                	add    %ch,%al
 495:	0a 00                	or     (%rax),%al
 497:	00 f3                	add    %dh,%bl
 499:	0a 00                	or     (%rax),%al
 49b:	00 fc                	add    %bh,%ah
  tcp = data + off;
 49d:	0a 00                	or     (%rax),%al
 49f:	00 05 0b 00 00 0d    	add    %al,0xd00000b(%rip)        # d0004b0 <_license+0xcffe083>
 4a5:	0b 00                	or     (%rax),%eax
  if (tcp + 1 > data_end) {
 4a7:	00 14 0b             	add    %dl,(%rbx,%rcx,1)
 4aa:	00 00                	add    %al,(%rax)
 4ac:	bf 0e 00 00 1d       	mov    $0x1d00000e,%edi
 4b1:	0b 00                	or     (%rax),%eax
 4b3:	00 24 0b             	add    %ah,(%rbx,%rcx,1)
  if (tcp->syn) {
 4b6:	00 00                	add    %al,(%rax)
 4b8:	2c 0b                	sub    $0xb,%al
 4ba:	00 00                	add    %al,(%rax)
 4bc:	32 0b                	xor    (%rbx),%cl
    pckt->flags |= F_SYN_SET;
 4be:	00 00                	add    %al,(%rax)
 4c0:	a2 05 00 00 36 0b 00 	movabs %al,0x3d00000b36000005
 4c7:	00 3d 
 4c9:	0b 00                	or     (%rax),%eax
 4cb:	00 46 0b             	add    %al,0xb(%rsi)
 4ce:	00 00                	add    %al,(%rax)
 4d0:	fe 07                	incb   (%rdi)
        bpf_map_lookup_elem(&stats, &stats_key);
 4d2:	00 00                	add    %al,(%rax)
 4d4:	51                   	push   %rcx
 4d5:	0b 00                	or     (%rax),%eax
 4d7:	00 5b 0b             	add    %bl,0xb(%rbx)
 4da:	00 00                	add    %al,(%rax)
 4dc:	64 0b 00             	or     %fs:(%rax),%eax
 4df:	00 6b 0b             	add    %ch,0xb(%rbx)
    if (!icmp_ptb_v6_stats) {
 4e2:	00 00                	add    %al,(%rax)
 4e4:	5f                   	pop    %rdi
 4e5:	06                   	(bad)
 4e6:	00 00                	add    %al,(%rax)
 4e8:	79 0b                	jns    4f5 <balancer_ingress+0x4f5>
    icmp_ptb_v6_stats->v1 += 1;
 4ea:	00 00                	add    %al,(%rax)
 4ec:	92                   	xchg   %eax,%edx
 4ed:	0b 00                	or     (%rax),%eax
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 4ef:	00 1e                	add    %bl,(%rsi)
 4f1:	0c 00                	or     $0x0,%al
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 4f3:	00 aa 0b 00 00 81    	add    %ch,-0x7efffff5(%rdx)
 4f9:	0c 00                	or     $0x0,%al
      icmp_ptb_v6_stats->v2 += 1;
 4fb:	00 b6 0b 00 00 bf    	add    %dh,-0x40fffff5(%rsi)
  if (ip6h + 1 > data_end) {
 501:	0b 00                	or     (%rax),%eax
 503:	00 dc                	add    %bl,%ah
 505:	0b 00                	or     (%rax),%eax
 507:	00 e4                	add    %ah,%ah
 509:	0b 00                	or     (%rax),%eax
 50b:	00 f2                	add    %dh,%dl
  pckt->flow.proto = ip6h->nexthdr;
 50d:	0b 00                	or     (%rax),%eax
 50f:	00 00                	add    %al,(%rax)
 511:	0c 00                	or     $0x0,%al
 513:	00 88 03 00 00 19    	add    %cl,0x19000003(%rax)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 519:	0c 00                	or     $0x0,%al
 51b:	00 dd                	add    %bl,%ch
 51d:	0a 00                	or     (%rax),%al
 51f:	00 23                	add    %ah,(%rbx)
 521:	0c 00                	or     $0x0,%al
 523:	00 32                	add    %dh,(%rdx)
 525:	0c 00                	or     $0x0,%al
 527:	00 40 0c             	add    %al,0xc(%rax)
 52a:	00 00                	add    %al,(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 52c:	50                   	push   %rax
 52d:	0c 00                	or     $0x0,%al
 52f:	00 59 0c             	add    %bl,0xc(%rcx)
 532:	00 00                	add    %al,(%rax)
 534:	60                   	(bad)
 535:	0c 00                	or     $0x0,%al
 537:	00 6e 0c             	add    %ch,0xc(%rsi)
 53a:	00 00                	add    %al,(%rax)
 53c:	7d 0c                	jge    54a <balancer_ingress+0x54a>
 53e:	00 00                	add    %al,(%rax)
 540:	26 0c 00             	es or  $0x0,%al
 543:	00 89 0c 00 00 d1    	add    %cl,-0x2efffff4(%rcx)
 549:	0c 00                	or     $0x0,%al
 54b:	00 93 0c 00 00 a0    	add    %dl,-0x5ffffff4(%rbx)
 551:	0c 00                	or     $0x0,%al
 553:	00 d4                	add    %dl,%ah
 555:	09 00                	or     %eax,(%rax)
 557:	00 af 0c 00 00 38    	add    %ch,0x3800000c(%rdi)
 55d:	00 00                	add    %al,(%rax)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 55f:	00 b1 0c 00 00 b9    	add    %dh,-0x46fffff4(%rcx)
 565:	0c 00                	or     $0x0,%al
 567:	00 c6                	add    %al,%dh
 569:	0c 00                	or     $0x0,%al
 56b:	00 d6                	add    %dl,%dh
 56d:	0c 00                	or     $0x0,%al
 56f:	00 dc                	add    %bl,%ah
 571:	0c 00                	or     $0x0,%al
BPF_MAP_OPS_INLINE(void*,
 573:	00 e1                	add    %ah,%cl
 575:	0c 00                	or     $0x0,%al
 577:	00 e7                	add    %ah,%bh
 579:	0c 00                	or     $0x0,%al
 57b:	00 01                	add    %al,(%rcx)
 57d:	0d 00 00 13 0d       	or     $0xd130000,%eax
 582:	00 00                	add    %al,(%rax)
 584:	21 0d 00 00 3a 0d    	and    %ecx,0xd3a0000(%rip)        # d3a058a <_license+0xd39e15d>
  if (decap_dst_flags) {
 58a:	00 00                	add    %al,(%rax)
 58c:	43 0d 00 00 59 0d    	rex.XB or $0xd590000,%eax
 592:	00 00                	add    %al,(%rax)
 594:	67 0d 00 00 6a 0d    	addr32 or $0xd6a0000,%eax
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 59a:	00 00                	add    %al,(%rax)
 59c:	8b 0d 00 00 9f 0d    	mov    0xd9f0000(%rip),%ecx        # d9f05a2 <_license+0xd9ee175>
 5a2:	00 00                	add    %al,(%rax)
 5a4:	b9 0d 00 00 cb       	mov    $0xcb00000d,%ecx
    if (!data_stats) {
 5a9:	0d 00 00 de 0d       	or     $0xdde0000,%eax
 5ae:	00 00                	add    %al,(%rax)
 5b0:	ec                   	in     (%dx),%al
 5b1:	0d 00 00 f7 0d       	or     $0xdf70000,%eax
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
 5b6:	00 00                	add    %al,(%rax)
 5b8:	03 0e                	add    (%rsi),%ecx
 5ba:	00 00                	add    %al,(%rax)
 5bc:	0d 0e 00 00 1b       	or     $0x1b00000e,%eax
 5c1:	0e                   	(bad)
 5c2:	00 00                	add    %al,(%rax)
 5c4:	3e 0e                	ds (bad)
 5c6:	00 00                	add    %al,(%rax)
 5c8:	44 0e                	rex.R (bad)
    if (!--ip6h->hop_limit) {
 5ca:	00 00                	add    %al,(%rax)
 5cc:	1e                   	(bad)
 5cd:	0a 00                	or     (%rax),%al
 5cf:	00 4b 0e             	add    %cl,0xe(%rbx)
 5d2:	00 00                	add    %al,(%rax)
 5d4:	5d                   	pop    %rbp
 5d5:	0e                   	(bad)
 5d6:	00 00                	add    %al,(%rax)
 5d8:	6f                   	outsl  %ds:(%rsi),(%dx)
 5d9:	0e                   	(bad)
 5da:	00 00                	add    %al,(%rax)
 5dc:	82                   	(bad)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
 5dd:	0e                   	(bad)
 5de:	00 00                	add    %al,(%rax)
 5e0:	95                   	xchg   %eax,%ebp
 5e1:	0e                   	(bad)
 5e2:	00 00                	add    %al,(%rax)
 5e4:	a8 0e                	test   $0xe,%al
 5e6:	00 00                	add    %al,(%rax)
 5e8:	b9 0e 00 00 09       	mov    $0x900000e,%ecx
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 5ed:	0b 00                	or     (%rax),%eax
 5ef:	00                   	.byte 0x0
 5f0:	bd                   	.byte 0xbd
 5f1:	0e                   	(bad)
	...

Disassembly of section .debug_str:

0000000000000000 <.debug_str>:
  void* data = (void*)(long)ctx->data;
   0:	44                   	rex.R
   1:	65 62                	gs (bad)
   3:	69 61 6e 20 63 6c 61 	imul   $0x616c6320,0x6e(%rcx),%esp
   a:	6e                   	outsb  %ds:(%rsi),(%dx)
   b:	67 20 76 65          	and    %dh,0x65(%esi)
   f:	72 73                	jb     84 <balancer_ingress+0x84>
  11:	69 6f 6e 20 31 34 2e 	imul   $0x2e343120,0x6e(%rdi),%ebp
  void* data_end = (void*)(long)ctx->data_end;
  18:	30 2e                	xor    %ch,(%rsi)
  1a:	36 00 6b 61          	ss add %ch,0x61(%rbx)
  if (data + nh_off > data_end) {
  1e:	74 72                	je     92 <balancer_ingress+0x92>
  20:	61                   	(bad)
  21:	6e                   	outsb  %ds:(%rsi),(%dx)
  22:	2f                   	(bad)
  23:	6c                   	insb   (%dx),%es:(%rdi)
  24:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
  2b:	62 61 6c 61 6e       	(bad)
  30:	63 65 72             	movsxd 0x72(%rbp),%esp
  eth_proto = eth->h_proto;
  33:	2e 62                	cs (bad)
  if (eth_proto == BE_ETH_P_IP) {
  35:	70 66                	jo     9d <balancer_ingress+0x9d>
  37:	2e 63 00             	cs movsxd (%rax),%eax
  3a:	2f                   	(bad)
  3b:	72 6f                	jb     ac <balancer_ingress+0xac>
  3d:	6f                   	outsl  %ds:(%rsi),(%dx)
  3e:	74 2f                	je     6f <balancer_ingress+0x6f>
  40:	57                   	push   %rdi
  41:	6f                   	outsl  %ds:(%rsi),(%dx)
  42:	72 6b                	jb     af <balancer_ingress+0xaf>
  44:	73 70                	jae    b6 <balancer_ingress+0xb6>
  46:	61                   	(bad)
  47:	63 65 2f             	movsxd 0x2f(%rbp),%esp
  4a:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  4e:	61                   	(bad)
  4f:	6e                   	outsb  %ds:(%rsi),(%dx)
  struct packet_description pckt = {};
  50:	2f                   	(bad)
  51:	5f                   	pop    %rdi
  52:	62 75                	(bad)
  54:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
  5b:	73 
  5c:	2f                   	(bad)
  5d:	62                   	(bad)
  5e:	70 66                	jo     c6 <balancer_ingress+0xc6>
  60:	70 72                	jo     d4 <balancer_ingress+0xd4>
  62:	6f                   	outsl  %ds:(%rsi),(%dx)
  63:	67 00 5f 6c          	add    %bl,0x6c(%edi)
  67:	69 63 65 6e 73 65 00 	imul   $0x65736e,0x65(%rbx),%esp
  6e:	5f                   	pop    %rdi
  6f:	5f                   	pop    %rdi
  70:	41 52                	push   %r10
  72:	52                   	push   %rdx
  73:	41 59                	pop    %r9
  75:	5f                   	pop    %rdi
  76:	53                   	push   %rbx
  77:	49 5a                	rex.WB pop %r10
  79:	45 5f                	rex.RB pop %r15
  7b:	54                   	push   %rsp
  7c:	59                   	pop    %rcx
  7d:	50                   	push   %rax
  7e:	45 5f                	rex.RB pop %r15
  80:	5f                   	pop    %rdi
  81:	00 63 74             	add    %ah,0x74(%rbx)
  84:	6c                   	insb   (%dx),%es:(%rdi)
  85:	5f                   	pop    %rdi
  struct vip_definition vip = {};
  86:	61                   	(bad)
  87:	72 72                	jb     fb <balancer_ingress+0xfb>
  89:	61                   	(bad)
  8a:	79 00                	jns    8c <balancer_ingress+0x8c>
  8c:	75 6e                	jne    fc <balancer_ingress+0xfc>
  8e:	73 69                	jae    f9 <balancer_ingress+0xf9>
  90:	67 6e                	outsb  %ds:(%esi),(%dx)
  92:	65 64 20 69 6e       	gs and %ch,%fs:0x6e(%rcx)
  97:	74 00                	je     99 <balancer_ingress+0x99>
  99:	5f                   	pop    %rdi
  9a:	5f                   	pop    %rdi
  9b:	75 33                	jne    d0 <balancer_ingress+0xd0>
  9d:	32 00                	xor    (%rax),%al
  9f:	75 6e                	jne    10f <balancer_ingress+0x10f>
    if (iph + 1 > data_end) {
  a1:	73 69                	jae    10c <balancer_ingress+0x10c>
  a3:	67 6e                	outsb  %ds:(%esi),(%dx)
  a5:	65 64 20 6c 6f 6e    	gs and %ch,%fs:0x6e(%rdi,%rbp,2)
  ab:	67 20 6c 6f 6e       	and    %ch,0x6e(%edi,%ebp,2)
    if (iph->ihl != 5) {
  b0:	67 00 5f 5f          	add    %bl,0x5f(%edi)
  b4:	75 36                	jne    ec <balancer_ingress+0xec>
  b6:	34 00                	xor    $0x0,%al
  b8:	69 66 69 6e 64 65 78 	imul   $0x7865646e,0x69(%rsi),%esp
    pckt->tos = iph->tos;
  bf:	00 6d 61             	add    %ch,0x61(%rbp)
    *protocol = iph->protocol;
  c2:	63 00                	movsxd (%rax),%eax
    pckt->flow.proto = *protocol;
  c4:	75 6e                	jne    134 <balancer_ingress+0x134>
  c6:	73 69                	jae    131 <balancer_ingress+0x131>
    if (iph->frag_off & PCKT_FRAGMENTED) {
  c8:	67 6e                	outsb  %ds:(%esi),(%dx)
  ca:	65 64 20 63 68       	gs and %ah,%fs:0x68(%rbx)
  cf:	61                   	(bad)
  d0:	72 00                	jb     d2 <balancer_ingress+0xd2>
  d2:	5f                   	pop    %rdi
  d3:	5f                   	pop    %rdi
  d4:	75 38                	jne    10e <balancer_ingress+0x10e>
  d6:	00 63 74             	add    %ah,0x74(%rbx)
  d9:	6c                   	insb   (%dx),%es:(%rdi)
  da:	5f                   	pop    %rdi
    if (*protocol == IPPROTO_ICMP) {
  db:	76 61                	jbe    13e <balancer_ingress+0x13e>
  dd:	6c                   	insb   (%dx),%es:(%rdi)
  de:	75 65                	jne    145 <balancer_ingress+0x145>
  e0:	00 6d 61             	add    %ch,0x61(%rbp)
  if (icmp_hdr + 1 > data_end) {
  e3:	78 5f                	js     144 <balancer_ingress+0x144>
  e5:	65 6e                	outsb  %gs:(%rsi),(%dx)
  e7:	74 72                	je     15b <balancer_ingress+0x15b>
  e9:	69 65 73 00 6d 61 70 	imul   $0x70616d00,0x73(%rbp),%esp
  if (icmp_hdr->type == ICMP_ECHO) {
  f0:	5f                   	pop    %rdi
  f1:	66 6c                	data16 insb (%dx),%es:(%rdi)
  f3:	61                   	(bad)
  f4:	67 73 00             	addr32 jae f7 <balancer_ingress+0xf7>
  f7:	5f                   	pop    %rdi
  f8:	5f                   	pop    %rdi
  f9:	62 65                	(bad)
  fb:	33 32                	xor    (%rdx),%esi
  fd:	00 61 64             	add    %ah,0x64(%rcx)
 100:	64 72 76             	fs jb  179 <balancer_ingress+0x179>
 103:	36 00 61 64          	ss add %ah,0x64(%rcx)
 107:	64 72 65             	fs jb  16f <balancer_ingress+0x16f>
 10a:	73 73                	jae    17f <balancer_ingress+0x17f>
 10c:	00 73 75             	add    %dh,0x75(%rbx)
  icmp_hdr->type = ICMP_ECHOREPLY;
 10f:	62                   	(bad)
 110:	70 72                	jo     184 <balancer_ingress+0x184>
  icmp_hdr->checksum += 0x0008;
 112:	6f                   	outsl  %ds:(%rsi),(%dx)
 113:	67 72 61             	addr32 jb 177 <balancer_ingress+0x177>
 116:	6d                   	insl   (%dx),%es:(%rdi)
  iph->ttl = DEFAULT_TTL;
 117:	73 00                	jae    119 <balancer_ingress+0x119>
 119:	76 69                	jbe    184 <balancer_ingress+0x184>
  iph->daddr = iph->saddr;
 11b:	70 5f                	jo     17c <balancer_ingress+0x17c>
 11d:	6d                   	insl   (%dx),%es:(%rdi)
  tmp_addr = iph->daddr;
 11e:	61                   	(bad)
 11f:	70 00                	jo     121 <balancer_ingress+0x121>
  iph->daddr = iph->saddr;
 121:	76 69                	jbe    18c <balancer_ingress+0x18c>
 123:	70 76                	jo     19b <balancer_ingress+0x19b>
  iph->saddr = tmp_addr;
 125:	36 00 75 6e          	ss add %dh,0x6e(%rbp)
 129:	73 69                	jae    194 <balancer_ingress+0x194>
 12b:	67 6e                	outsb  %ds:(%esi),(%dx)
 12d:	65 64 20 73 68       	gs and %dh,%fs:0x68(%rbx)
 132:	6f                   	outsl  %ds:(%rsi),(%dx)
 133:	72 74                	jb     1a9 <balancer_ingress+0x1a9>
 135:	00 5f 5f             	add    %bl,0x5f(%rdi)
 138:	75 31                	jne    16b <balancer_ingress+0x16b>
 13a:	36 00 76 69          	ss add %dh,0x69(%rsi)
 13e:	70 5f                	jo     19f <balancer_ingress+0x19f>
 140:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
 147:	69 
 148:	6f                   	outsl  %ds:(%rsi),(%dx)
 149:	6e                   	outsb  %ds:(%rsi),(%dx)
 14a:	00 76 69             	add    %dh,0x69(%rsi)
 14d:	70 5f                	jo     1ae <balancer_ingress+0x1ae>
 14f:	6e                   	outsb  %ds:(%rsi),(%dx)
 150:	75 6d                	jne    1bf <balancer_ingress+0x1bf>
 152:	00 76 69             	add    %dh,0x69(%rsi)
 155:	70 5f                	jo     1b6 <balancer_ingress+0x1b6>
 157:	6d                   	insl   (%dx),%es:(%rdi)
 158:	65 74 61             	gs je  1bc <balancer_ingress+0x1bc>
 15b:	00 66 61             	add    %ah,0x61(%rsi)
 15e:	6c                   	insb   (%dx),%es:(%rdi)
  struct packet_description pckt = {};
 15f:	6c                   	insb   (%dx),%es:(%rdi)
 160:	62 61                	(bad)
 162:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 165:	63 61 63             	movsxd 0x63(%rcx),%esp
 168:	68 65 00 73 72       	push   $0x72730065
 16d:	63 76 36             	movsxd 0x36(%rsi),%esi
 170:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 174:	76 36                	jbe    1ac <balancer_ingress+0x1ac>
 176:	00 70 6f             	add    %dh,0x6f(%rax)
 179:	72 74                	jb     1ef <balancer_ingress+0x1ef>
 17b:	73 00                	jae    17d <balancer_ingress+0x17d>
 17d:	70 6f                	jo     1ee <balancer_ingress+0x1ee>
 17f:	72 74                	jb     1f5 <balancer_ingress+0x1f5>
 181:	31 36                	xor    %esi,(%rsi)
 183:	00 66 6c             	add    %ah,0x6c(%rsi)
 186:	6f                   	outsl  %ds:(%rsi),(%dx)
 187:	77 5f                	ja     1e8 <balancer_ingress+0x1e8>
 189:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 18d:	61                   	(bad)
 18e:	74 69                	je     1f9 <balancer_ingress+0x1f9>
 190:	6d                   	insl   (%dx),%es:(%rdi)
 191:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
  struct vip_definition vip = {};
 195:	61                   	(bad)
 196:	6c                   	insb   (%dx),%es:(%rdi)
 197:	5f                   	pop    %rdi
 198:	70 6f                	jo     209 <balancer_ingress+0x209>
 19a:	73 5f                	jae    1fb <balancer_ingress+0x1fb>
 19c:	6c                   	insb   (%dx),%es:(%rdi)
 19d:	72 75                	jb     214 <balancer_ingress+0x214>
 19f:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
 1a3:	5f                   	pop    %rdi
 1a4:	6d                   	insl   (%dx),%es:(%rdi)
 1a5:	61                   	(bad)
 1a6:	70 70                	jo     218 <balancer_ingress+0x218>
 1a8:	69 6e 67 00 76 61 6c 	imul   $0x6c617600,0x67(%rsi),%ebp
    if (ip6h + 1 > data_end) {
 1af:	75 65                	jne    216 <balancer_ingress+0x216>
 1b1:	73 00                	jae    1b3 <balancer_ingress+0x1b3>
 1b3:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 1b6:	72 69                	jb     221 <balancer_ingress+0x221>
 1b8:	6e                   	outsb  %ds:(%rsi),(%dx)
 1b9:	67 73 00             	addr32 jae 1bc <balancer_ingress+0x1bc>
    *protocol = ip6h->nexthdr;
 1bc:	72 65                	jb     223 <balancer_ingress+0x223>
 1be:	61                   	(bad)
    pckt->flow.proto = *protocol;
 1bf:	6c                   	insb   (%dx),%es:(%rdi)
 1c0:	73 00                	jae    1c2 <balancer_ingress+0x1c2>
 1c2:	72 65                	jb     229 <balancer_ingress+0x229>
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1c4:	61                   	(bad)
 1c5:	6c                   	insb   (%dx),%es:(%rdi)
 1c6:	5f                   	pop    %rdi
 1c7:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
 1ce:	69 
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1cf:	6f                   	outsl  %ds:(%rsi),(%dx)
 1d0:	6e                   	outsb  %ds:(%rsi),(%dx)
 1d1:	00 72 65             	add    %dh,0x65(%rdx)
 1d4:	61                   	(bad)
 1d5:	6c                   	insb   (%dx),%es:(%rdi)
 1d6:	73 5f                	jae    237 <balancer_ingress+0x237>
 1d8:	73 74                	jae    24e <balancer_ingress+0x24e>
    if (*protocol == IPPROTO_FRAGMENT) {
 1da:	61                   	(bad)
 1db:	74 73                	je     250 <balancer_ingress+0x250>
 1dd:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 1e1:	73 74                	jae    257 <balancer_ingress+0x257>
 1e3:	61                   	(bad)
 1e4:	74 73                	je     259 <balancer_ingress+0x259>
 1e6:	00 76 69             	add    %dh,0x69(%rsi)
 1e9:	70 5f                	jo     24a <balancer_ingress+0x24a>
 1eb:	6d                   	insl   (%dx),%es:(%rdi)
 1ec:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
  if (icmp_hdr + 1 > data_end) {
 1f3:	74 73                	je     268 <balancer_ingress+0x268>
 1f5:	00 71 75             	add    %dh,0x75(%rcx)
 1f8:	69 63 5f 73 74 61 74 	imul   $0x74617473,0x5f(%rbx),%esp
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 1ff:	73 5f                	jae    260 <balancer_ingress+0x260>
 201:	6d                   	insl   (%dx),%es:(%rdi)
 202:	61                   	(bad)
 203:	70 00                	jo     205 <balancer_ingress+0x205>
 205:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 208:	72 6f                	jb     279 <balancer_ingress+0x279>
 20a:	75 74                	jne    280 <balancer_ingress+0x280>
 20c:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 211:	64 5f                	fs pop %rdi
 213:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
 21a:	00 63 69             	add    %ah,0x69(%rbx)
 21d:	64 5f                	fs pop %rdi
 21f:	69 6e 76 61 6c 69 64 	imul   $0x64696c61,0x76(%rsi),%ebp
 226:	5f                   	pop    %rdi
 227:	73 65                	jae    28e <balancer_ingress+0x28e>
 229:	72 76                	jb     2a1 <balancer_ingress+0x2a1>
 22b:	65 72 5f             	gs jb  28d <balancer_ingress+0x28d>
 22e:	69 64 00 63 69 64 5f 	imul   $0x695f6469,0x63(%rax,%rax,1),%esp
 235:	69 
 236:	6e                   	outsb  %ds:(%rsi),(%dx)
 237:	76 61                	jbe    29a <balancer_ingress+0x29a>
 239:	6c                   	insb   (%dx),%es:(%rdi)
 23a:	69 64 5f 73 65 72 76 	imul   $0x65767265,0x73(%rdi,%rbx,2),%esp
 241:	65 
 242:	72 5f                	jb     2a3 <balancer_ingress+0x2a3>
 244:	69 64 5f 73 61 6d 70 	imul   $0x6c706d61,0x73(%rdi,%rbx,2),%esp
 24b:	6c 
 24c:	65 00 63 69          	add    %ah,%gs:0x69(%rbx)
 250:	64 5f                	fs pop %rdi
 252:	72 6f                	jb     2c3 <balancer_ingress+0x2c3>
 254:	75 74                	jne    2ca <balancer_ingress+0x2ca>
 256:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 25b:	64 5f                	fs pop %rdi
 25d:	75 6e                	jne    2cd <balancer_ingress+0x2cd>
 25f:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
 263:	6e                   	outsb  %ds:(%rsi),(%dx)
 264:	5f                   	pop    %rdi
 265:	72 65                	jb     2cc <balancer_ingress+0x2cc>
 267:	61                   	(bad)
 268:	6c                   	insb   (%dx),%es:(%rdi)
 269:	5f                   	pop    %rdi
 26a:	64 72 6f             	fs jb  2dc <balancer_ingress+0x2dc>
 26d:	70 70                	jo     2df <balancer_ingress+0x2df>
 26f:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 274:	64 5f                	fs pop %rdi
 276:	76 30                	jbe    2a8 <balancer_ingress+0x2a8>
 278:	00 63 69             	add    %ah,0x69(%rbx)
 27b:	64 5f                	fs pop %rdi
 27d:	76 31                	jbe    2b0 <balancer_ingress+0x2b0>
 27f:	00 63 69             	add    %ah,0x69(%rbx)
 282:	64 5f                	fs pop %rdi
 284:	76 32                	jbe    2b8 <balancer_ingress+0x2b8>
 286:	00 63 69             	add    %ah,0x69(%rbx)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 289:	64 5f                	fs pop %rdi
 28b:	76 33                	jbe    2c0 <balancer_ingress+0x2c0>
 28d:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 291:	5f                   	pop    %rdi
 292:	6d                   	insl   (%dx),%es:(%rdi)
 293:	61                   	(bad)
 294:	74 63                	je     2f9 <balancer_ingress+0x2f9>
 296:	68 5f 69 6e 5f       	push   $0x5f6e695f
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 29b:	6c                   	insb   (%dx),%es:(%rdi)
 29c:	72 75                	jb     313 <balancer_ingress+0x313>
 29e:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 2a2:	5f                   	pop    %rdi
 2a3:	6d                   	insl   (%dx),%es:(%rdi)
 2a4:	69 73 6d 61 74 63 68 	imul   $0x68637461,0x6d(%rbx),%esi
 2ab:	5f                   	pop    %rdi
  if (protocol == IPPROTO_ICMPV6) {
 2ac:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
 2b3:	64 73 74             	fs jae 32a <balancer_ingress+0x32a>
  if (icmp_hdr + 1 > data_end) {
 2b6:	5f                   	pop    %rdi
 2b7:	6e                   	outsb  %ds:(%rsi),(%dx)
 2b8:	6f                   	outsl  %ds:(%rsi),(%dx)
 2b9:	74 5f                	je     31a <balancer_ingress+0x31a>
 2bb:	66 6f                	outsw  %ds:(%rsi),(%dx)
 2bd:	75 6e                	jne    32d <balancer_ingress+0x32d>
 2bf:	64 5f                	fs pop %rdi
  if (icmp_hdr->type == ICMP_ECHO) {
 2c1:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
 2c8:	6c                   	insb   (%dx),%es:(%rdi)
 2c9:	62                   	(bad)
 2ca:	5f                   	pop    %rdi
 2cb:	71 75                	jno    342 <balancer_ingress+0x342>
 2cd:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
 2d4:	65 74 73             	gs je  34a <balancer_ingress+0x34a>
 2d7:	5f                   	pop    %rdi
 2d8:	73 74                	jae    34e <balancer_ingress+0x34e>
 2da:	61                   	(bad)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2db:	74 73                	je     350 <balancer_ingress+0x350>
 2dd:	00 73 74             	add    %dh,0x74(%rbx)
 2e0:	61                   	(bad)
 2e1:	62                   	(bad)
 2e2:	6c                   	insb   (%dx),%es:(%rdi)
 2e3:	65 5f                	gs pop %rdi
       sizeof(struct icmphdr)) > data_end) {
 2e5:	72 74                	jb     35b <balancer_ingress+0x35b>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2e7:	5f                   	pop    %rdi
 2e8:	73 74                	jae    35e <balancer_ingress+0x35e>
 2ea:	61                   	(bad)
 2eb:	74 73                	je     360 <balancer_ingress+0x360>
  icmp_hdr->type = ICMP_ECHOREPLY;
 2ed:	00 69 6e             	add    %ch,0x6e(%rcx)
 2f0:	76 61                	jbe    353 <balancer_ingress+0x353>
  icmp_hdr->checksum += 0x0008;
 2f2:	6c                   	insb   (%dx),%es:(%rdi)
 2f3:	69 64 5f 70 61 63 6b 	imul   $0x656b6361,0x70(%rdi,%rbx,2),%esp
 2fa:	65 
  iph->daddr = iph->saddr;
 2fb:	74 5f                	je     35c <balancer_ingress+0x35c>
  tmp_addr = iph->daddr;
 2fd:	74 79                	je     378 <balancer_ingress+0x378>
 2ff:	70 65                	jo     366 <balancer_ingress+0x366>
  iph->daddr = iph->saddr;
 301:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
  iph->saddr = tmp_addr;
 305:	73 74                	jae    37b <balancer_ingress+0x37b>
 307:	61                   	(bad)
 308:	62                   	(bad)
 309:	6c                   	insb   (%dx),%es:(%rdi)
 30a:	65 5f                	gs pop %rdi
 30c:	72 74                	jb     382 <balancer_ingress+0x382>
 30e:	5f                   	pop    %rdi
 30f:	70 61                	jo     372 <balancer_ingress+0x372>
 311:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 314:	74 73                	je     389 <balancer_ingress+0x389>
 316:	5f                   	pop    %rdi
 317:	73 74                	jae    38d <balancer_ingress+0x38d>
 319:	61                   	(bad)
 31a:	74 73                	je     38f <balancer_ingress+0x38f>
 31c:	00 64 65 63          	add    %ah,0x63(%rbp,%riz,2)
 320:	61                   	(bad)
 321:	70 5f                	jo     382 <balancer_ingress+0x382>
 323:	76 69                	jbe    38e <balancer_ingress+0x38e>
 325:	70 5f                	jo     386 <balancer_ingress+0x386>
 327:	73 74                	jae    39d <balancer_ingress+0x39d>
 329:	61                   	(bad)
 32a:	74 73                	je     39f <balancer_ingress+0x39f>
 32c:	00 73 65             	add    %dh,0x65(%rbx)
 32f:	72 76                	jb     3a7 <balancer_ingress+0x3a7>
 331:	65 72 5f             	gs jb  393 <balancer_ingress+0x393>
 334:	69 64 5f 6d 61 70 00 	imul   $0x74007061,0x6d(%rdi,%rbx,2),%esp
 33b:	74 
 33c:	70 72                	jo     3b0 <balancer_ingress+0x3b0>
 33e:	5f                   	pop    %rdi
 33f:	73 74                	jae    3b5 <balancer_ingress+0x3b5>
 341:	61                   	(bad)
 342:	74 73                	je     3b7 <balancer_ingress+0x3b7>
 344:	5f                   	pop    %rdi
 345:	6d                   	insl   (%dx),%es:(%rdi)
 346:	61                   	(bad)
 347:	70 00                	jo     349 <balancer_ingress+0x349>
 349:	73 69                	jae    3b4 <balancer_ingress+0x3b4>
 34b:	64 5f                	fs pop %rdi
 34d:	72 6f                	jb     3be <balancer_ingress+0x3be>
 34f:	75 74                	jne    3c5 <balancer_ingress+0x3c5>
 351:	65 64 00 74 63 70    	gs add %dh,%fs:0x70(%rbx,%riz,2)
 357:	5f                   	pop    %rdi
 358:	73 79                	jae    3d3 <balancer_ingress+0x3d3>
 35a:	6e                   	outsb  %ds:(%rsi),(%dx)
 35b:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 35f:	74 70                	je     3d1 <balancer_ingress+0x3d1>
 361:	72 5f                	jb     3c2 <balancer_ingress+0x3c2>
 363:	70 61                	jo     3c6 <balancer_ingress+0x3c6>
 365:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 368:	74 73                	je     3dd <balancer_ingress+0x3dd>
 36a:	5f                   	pop    %rdi
 36b:	73 74                	jae    3e1 <balancer_ingress+0x3e1>
 36d:	61                   	(bad)
 36e:	74 73                	je     3e3 <balancer_ingress+0x3e3>
 370:	00 73 65             	add    %dh,0x65(%rbx)
 373:	72 76                	jb     3eb <balancer_ingress+0x3eb>
 375:	65 72 5f             	gs jb  3d7 <balancer_ingress+0x3d7>
 378:	69 64 5f 73 74 61 74 	imul   $0x73746174,0x73(%rdi,%rbx,2),%esp
 37f:	73 
 380:	00 76 69             	add    %dh,0x69(%rsi)
 383:	70 5f                	jo     3e4 <balancer_ingress+0x3e4>
 385:	74 6f                	je     3f6 <balancer_ingress+0x3f6>
 387:	5f                   	pop    %rdi
 388:	64 6f                	outsl  %fs:(%rsi),(%dx)
 38a:	77 6e                	ja     3fa <balancer_ingress+0x3fa>
 38c:	5f                   	pop    %rdi
 38d:	72 65                	jb     3f4 <balancer_ingress+0x3f4>
 38f:	61                   	(bad)
 390:	6c                   	insb   (%dx),%es:(%rdi)
 391:	73 5f                	jae    3f2 <balancer_ingress+0x3f2>
 393:	6d                   	insl   (%dx),%es:(%rdi)
 394:	61                   	(bad)
 395:	70 00                	jo     397 <balancer_ingress+0x397>
 397:	62                   	(bad)
 398:	70 66                	jo     400 <balancer_ingress+0x400>
 39a:	5f                   	pop    %rdi
 39b:	78 64                	js     401 <balancer_ingress+0x401>
 39d:	70 5f                	jo     3fe <balancer_ingress+0x3fe>
 39f:	61                   	(bad)
 3a0:	64 6a 75             	fs push $0x75
 3a3:	73 74                	jae    419 <balancer_ingress+0x419>
 3a5:	5f                   	pop    %rdi
 3a6:	68 65 61 64 00       	push   $0x646165
 3ab:	62                   	(bad)
 3ac:	70 66                	jo     414 <balancer_ingress+0x414>
 3ae:	5f                   	pop    %rdi
 3af:	6b 74 69 6d 65       	imul   $0x65,0x6d(%rcx,%rbp,2),%esi
 3b4:	5f                   	pop    %rdi
 3b5:	67 65 74 5f          	addr32 gs je 418 <balancer_ingress+0x418>
 3b9:	6e                   	outsb  %ds:(%rsi),(%dx)
 3ba:	73 00                	jae    3bc <balancer_ingress+0x3bc>
 3bc:	58                   	pop    %rax
 3bd:	44 50                	rex.R push %rax
 3bf:	5f                   	pop    %rdi
 3c0:	41                   	rex.B
 3c1:	42                   	rex.X
 3c2:	4f 52                	rex.WRXB push %r10
 3c4:	54                   	push   %rsp
 3c5:	45                   	rex.RB
 3c6:	44 00 58 44          	add    %r11b,0x44(%rax)
 3ca:	50                   	push   %rax
 3cb:	5f                   	pop    %rdi
 3cc:	44 52                	rex.R push %rdx
 3ce:	4f 50                	rex.WRXB push %r8
 3d0:	00 58 44             	add    %bl,0x44(%rax)
 3d3:	50                   	push   %rax
 3d4:	5f                   	pop    %rdi
 3d5:	50                   	push   %rax
 3d6:	41 53                	push   %r11
 3d8:	53                   	push   %rbx
 3d9:	00 58 44             	add    %bl,0x44(%rax)
 3dc:	50                   	push   %rax
 3dd:	5f                   	pop    %rdi
 3de:	54                   	push   %rsp
 3df:	58                   	pop    %rax
 3e0:	00 58 44             	add    %bl,0x44(%rax)
 3e3:	50                   	push   %rax
  if (protocol == IPPROTO_IPIP) {
 3e4:	5f                   	pop    %rdi
 3e5:	52                   	push   %rdx
 3e6:	45                   	rex.RB
 3e7:	44                   	rex.R
 3e8:	49 52                	rex.WB push %r10
 3ea:	45                   	rex.RB
 3eb:	43 54                	rex.XB push %r12
 3ed:	00 78 64             	add    %bh,0x64(%rax)
 3f0:	70 5f                	jo     451 <balancer_ingress+0x451>
 3f2:	61                   	(bad)
 3f3:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
 3f7:	6e                   	outsb  %ds:(%rsi),(%dx)
 3f8:	00 49 50             	add    %cl,0x50(%rcx)
 3fb:	50                   	push   %rax
  tcp = data + off;
 3fc:	52                   	push   %rdx
 3fd:	4f 54                	rex.WRXB push %r12
 3ff:	4f 5f                	rex.WRXB pop %r15
  if (is_ipv6) {
 401:	49 50                	rex.WB push %r8
  tcp = data + off;
 403:	00 49 50             	add    %cl,0x50(%rcx)
  if (tcp + 1 > data_end) {
 406:	50                   	push   %rax
 407:	52                   	push   %rdx
 408:	4f 54                	rex.WRXB push %r12
 40a:	4f 5f                	rex.WRXB pop %r15
 40c:	49                   	rex.WB
 40d:	43                   	rex.XB
 40e:	4d 50                	rex.WRB push %r8
 410:	00 49 50             	add    %cl,0x50(%rcx)
  if (tcp->syn) {
 413:	50                   	push   %rax
 414:	52                   	push   %rdx
 415:	4f 54                	rex.WRXB push %r12
 417:	4f 5f                	rex.WRXB pop %r15
 419:	49                   	rex.WB
 41a:	47                   	rex.RXB
 41b:	4d 50                	rex.WRB push %r8
    pckt->flags |= F_SYN_SET;
 41d:	00 49 50             	add    %cl,0x50(%rcx)
 420:	50                   	push   %rax
 421:	52                   	push   %rdx
 422:	4f 54                	rex.WRXB push %r12
 424:	4f 5f                	rex.WRXB pop %r15
      pckt->flow.src = iph->saddr;
 426:	49 50                	rex.WB push %r8
 428:	49 50                	rex.WB push %r8
 42a:	00 49 50             	add    %cl,0x50(%rcx)
      pckt->flow.dst = iph->daddr;
 42d:	50                   	push   %rax
 42e:	52                   	push   %rdx
 42f:	4f 54                	rex.WRXB push %r12
 431:	4f 5f                	rex.WRXB pop %r15
 433:	54                   	push   %rsp
  if (protocol == IPPROTO_ICMPV6) {
 434:	43 50                	rex.XB push %r8
 436:	00 49 50             	add    %cl,0x50(%rcx)
  if (icmp_hdr + 1 > data_end) {
 439:	50                   	push   %rax
 43a:	52                   	push   %rdx
 43b:	4f 54                	rex.WRXB push %r12
 43d:	4f 5f                	rex.WRXB pop %r15
 43f:	45                   	rex.RB
 440:	47 50                	rex.RXB push %r8
 442:	00 49 50             	add    %cl,0x50(%rcx)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 445:	50                   	push   %rax
 446:	52                   	push   %rdx
 447:	4f 54                	rex.WRXB push %r12
 449:	4f 5f                	rex.WRXB pop %r15
 44b:	50                   	push   %rax
 44c:	55                   	push   %rbp
 44d:	50                   	push   %rax
 44e:	00 49 50             	add    %cl,0x50(%rcx)
 451:	50                   	push   %rax
 452:	52                   	push   %rdx
 453:	4f 54                	rex.WRXB push %r12
 455:	4f 5f                	rex.WRXB pop %r15
 457:	55                   	push   %rbp
 458:	44 50                	rex.R push %rax
 45a:	00 49 50             	add    %cl,0x50(%rcx)
 45d:	50                   	push   %rax
 45e:	52                   	push   %rdx
 45f:	4f 54                	rex.WRXB push %r12
 461:	4f 5f                	rex.WRXB pop %r15
 463:	49                   	rex.WB
 464:	44 50                	rex.R push %rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 466:	00 49 50             	add    %cl,0x50(%rcx)
 469:	50                   	push   %rax
 46a:	52                   	push   %rdx
 46b:	4f 54                	rex.WRXB push %r12
 46d:	4f 5f                	rex.WRXB pop %r15
       sizeof(struct icmp6hdr)) > data_end) {
 46f:	54                   	push   %rsp
 470:	50                   	push   %rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 471:	00 49 50             	add    %cl,0x50(%rcx)
 474:	50                   	push   %rax
 475:	52                   	push   %rdx
 476:	4f 54                	rex.WRXB push %r12
 478:	4f 5f                	rex.WRXB pop %r15
 47a:	44                   	rex.R
 47b:	43                   	rex.XB
 47c:	43 50                	rex.XB push %r8
 47e:	00 49 50             	add    %cl,0x50(%rcx)
 481:	50                   	push   %rax
 482:	52                   	push   %rdx
 483:	4f 54                	rex.WRXB push %r12
 485:	4f 5f                	rex.WRXB pop %r15
 487:	49 50                	rex.WB push %r8
 489:	56                   	push   %rsi
 48a:	36 00 49 50          	ss add %cl,0x50(%rcx)
 48e:	50                   	push   %rax
 48f:	52                   	push   %rdx
 490:	4f 54                	rex.WRXB push %r12
 492:	4f 5f                	rex.WRXB pop %r15
 494:	52                   	push   %rdx
 495:	53                   	push   %rbx
 496:	56                   	push   %rsi
 497:	50                   	push   %rax
 498:	00 49 50             	add    %cl,0x50(%rcx)
 49b:	50                   	push   %rax
 49c:	52                   	push   %rdx
  tcp = data + off;
 49d:	4f 54                	rex.WRXB push %r12
 49f:	4f 5f                	rex.WRXB pop %r15
  if (is_ipv6) {
 4a1:	47 52                	rex.RXB push %r10
  tcp = data + off;
 4a3:	45 00 49 50          	add    %r9b,0x50(%r9)
  if (tcp + 1 > data_end) {
 4a7:	50                   	push   %rax
 4a8:	52                   	push   %rdx
 4a9:	4f 54                	rex.WRXB push %r12
 4ab:	4f 5f                	rex.WRXB pop %r15
 4ad:	45 53                	rex.RB push %r11
 4af:	50                   	push   %rax
 4b0:	00 49 50             	add    %cl,0x50(%rcx)
 4b3:	50                   	push   %rax
  if (tcp->syn) {
 4b4:	52                   	push   %rdx
 4b5:	4f 54                	rex.WRXB push %r12
 4b7:	4f 5f                	rex.WRXB pop %r15
 4b9:	41                   	rex.B
 4ba:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
    pckt->flags |= F_SYN_SET;
 4be:	50                   	push   %rax
 4bf:	52                   	push   %rdx
 4c0:	4f 54                	rex.WRXB push %r12
 4c2:	4f 5f                	rex.WRXB pop %r15
 4c4:	4d 54                	rex.WRB push %r12
 4c6:	50                   	push   %rax
 4c7:	00 49 50             	add    %cl,0x50(%rcx)
 4ca:	50                   	push   %rax
 4cb:	52                   	push   %rdx
 4cc:	4f 54                	rex.WRXB push %r12
 4ce:	4f 5f                	rex.WRXB pop %r15
 4d0:	42                   	rex.X
        bpf_map_lookup_elem(&stats, &stats_key);
 4d1:	45                   	rex.RB
 4d2:	45 54                	rex.RB push %r12
 4d4:	50                   	push   %rax
 4d5:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
 4d9:	50                   	push   %rax
 4da:	52                   	push   %rdx
 4db:	4f 54                	rex.WRXB push %r12
 4dd:	4f 5f                	rex.WRXB pop %r15
 4df:	45                   	rex.RB
 4e0:	4e                   	rex.WRX
    if (!icmp_ptb_v6_stats) {
 4e1:	43                   	rex.XB
 4e2:	41 50                	push   %r8
 4e4:	00 49 50             	add    %cl,0x50(%rcx)
 4e7:	50                   	push   %rax
 4e8:	52                   	push   %rdx
 4e9:	4f 54                	rex.WRXB push %r12
    icmp_ptb_v6_stats->v1 += 1;
 4eb:	4f 5f                	rex.WRXB pop %r15
 4ed:	50                   	push   %rax
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 4ee:	49                   	rex.WB
 4ef:	4d 00 49 50          	rex.WRB add %r9b,0x50(%r9)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 4f3:	50                   	push   %rax
 4f4:	52                   	push   %rdx
 4f5:	4f 54                	rex.WRXB push %r12
 4f7:	4f 5f                	rex.WRXB pop %r15
 4f9:	43                   	rex.XB
 4fa:	4f                   	rex.WRXB
      icmp_ptb_v6_stats->v2 += 1;
 4fb:	4d 50                	rex.WRB push %r8
 4fd:	00 49 50             	add    %cl,0x50(%rcx)
  if (ip6h + 1 > data_end) {
 500:	50                   	push   %rax
 501:	52                   	push   %rdx
 502:	4f 54                	rex.WRXB push %r12
 504:	4f 5f                	rex.WRXB pop %r15
 506:	4c 32 54 50 00       	rex.WR xor 0x0(%rax,%rdx,2),%r10b
 50b:	49 50                	rex.WB push %r8
  pckt->flow.proto = ip6h->nexthdr;
 50d:	50                   	push   %rax
 50e:	52                   	push   %rdx
 50f:	4f 54                	rex.WRXB push %r12
 511:	4f 5f                	rex.WRXB pop %r15
 513:	53                   	push   %rbx
  pckt->flags |= F_ICMP;
 514:	43 54                	rex.XB push %r12
 516:	50                   	push   %rax
 517:	00 49 50             	add    %cl,0x50(%rcx)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 51a:	50                   	push   %rax
 51b:	52                   	push   %rdx
 51c:	4f 54                	rex.WRXB push %r12
 51e:	4f 5f                	rex.WRXB pop %r15
 520:	55                   	push   %rbp
 521:	44 50                	rex.R push %rax
 523:	4c                   	rex.WR
 524:	49 54                	rex.WB push %r12
 526:	45 00 49 50          	add    %r9b,0x50(%r9)
 52a:	50                   	push   %rax
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 52b:	52                   	push   %rdx
 52c:	4f 54                	rex.WRXB push %r12
 52e:	4f 5f                	rex.WRXB pop %r15
 530:	4d 50                	rex.WRB push %r8
 532:	4c 53                	rex.WR push %rbx
 534:	00 49 50             	add    %cl,0x50(%rcx)
 537:	50                   	push   %rax
 538:	52                   	push   %rdx
 539:	4f 54                	rex.WRXB push %r12
 53b:	4f 5f                	rex.WRXB pop %r15
 53d:	45 54                	rex.RB push %r12
 53f:	48                   	rex.W
 540:	45 52                	rex.RB push %r10
 542:	4e                   	rex.WRX
 543:	45 54                	rex.RB push %r12
 545:	00 49 50             	add    %cl,0x50(%rcx)
 548:	50                   	push   %rax
 549:	52                   	push   %rdx
 54a:	4f 54                	rex.WRXB push %r12
 54c:	4f 5f                	rex.WRXB pop %r15
 54e:	41                   	rex.B
 54f:	47                   	rex.RXB
 550:	47                   	rex.RXB
 551:	46 52                	rex.RX push %rdx
 553:	41                   	rex.B
 554:	47 00 49 50          	rex.RXB add %r9b,0x50(%r9)
 558:	50                   	push   %rax
 559:	52                   	push   %rdx
 55a:	4f 54                	rex.WRXB push %r12
 55c:	4f 5f                	rex.WRXB pop %r15
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 55e:	52                   	push   %rdx
 55f:	41 57                	push   %r15
 561:	00 49 50             	add    %cl,0x50(%rcx)
 564:	50                   	push   %rax
 565:	52                   	push   %rdx
 566:	4f 54                	rex.WRXB push %r12
 568:	4f 5f                	rex.WRXB pop %r15
 56a:	53                   	push   %rbx
 56b:	4d                   	rex.WRB
 56c:	43 00 49 50          	rex.XB add %cl,0x50(%r9)
 570:	50                   	push   %rax
 571:	52                   	push   %rdx
 572:	4f 54                	rex.WRXB push %r12
 574:	4f 5f                	rex.WRXB pop %r15
 576:	4d 50                	rex.WRB push %r8
 578:	54                   	push   %rsp
 579:	43 50                	rex.XB push %r8
 57b:	00 49 50             	add    %cl,0x50(%rcx)
 57e:	50                   	push   %rax
 57f:	52                   	push   %rdx
 580:	4f 54                	rex.WRXB push %r12
 582:	4f 5f                	rex.WRXB pop %r15
 584:	4d                   	rex.WRB
 585:	41 58                	pop    %r8
 587:	00 70 72             	add    %dh,0x72(%rax)
  if (decap_dst_flags) {
 58a:	69 6f 72 69 74 79 00 	imul   $0x797469,0x72(%rdi),%ebp
 591:	66 6c                	data16 insb (%dx),%es:(%rdi)
 593:	6f                   	outsl  %ds:(%rsi),(%dx)
 594:	77 5f                	ja     5f5 <balancer_ingress+0x5f5>
 596:	6c                   	insb   (%dx),%es:(%rdi)
 597:	62                   	(bad)
 598:	6c                   	insb   (%dx),%es:(%rdi)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 599:	00 70 61             	add    %dh,0x61(%rax)
 59c:	79 6c                	jns    60a <balancer_ingress+0x60a>
 59e:	6f                   	outsl  %ds:(%rsi),(%dx)
 59f:	61                   	(bad)
 5a0:	64 5f                	fs pop %rdi
 5a2:	6c                   	insb   (%dx),%es:(%rdi)
 5a3:	65 6e                	outsb  %gs:(%rsi),(%dx)
 5a5:	00 5f 5f             	add    %bl,0x5f(%rdi)
 5a8:	62 65                	(bad)
    if (!data_stats) {
 5aa:	31 36                	xor    %esi,(%rsi)
 5ac:	00 6e 65             	add    %ch,0x65(%rsi)
 5af:	78 74                	js     625 <balancer_ingress+0x625>
 5b1:	68 64 72 00 68       	push   $0x68007264
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
 5b6:	6f                   	outsl  %ds:(%rsi),(%dx)
 5b7:	70 5f                	jo     618 <balancer_ingress+0x618>
 5b9:	6c                   	insb   (%dx),%es:(%rdi)
 5ba:	69 6d 69 74 00 73 61 	imul   $0x61730074,0x69(%rbp),%ebp
 5c1:	64 64 72 00          	fs fs jb 5c5 <balancer_ingress+0x5c5>
 5c5:	69 6e 36 5f 75 00 75 	imul   $0x7500755f,0x36(%rsi),%ebp
    if (!--ip6h->hop_limit) {
 5cc:	36 5f                	ss pop %rdi
 5ce:	61                   	(bad)
 5cf:	64 64 72 38          	fs fs jb 60b <balancer_ingress+0x60b>
 5d3:	00 75 36             	add    %dh,0x36(%rbp)
 5d6:	5f                   	pop    %rdi
 5d7:	61                   	(bad)
 5d8:	64 64 72 31          	fs fs jb 60d <balancer_ingress+0x60d>
 5dc:	36 00 75 36          	ss add %dh,0x36(%rbp)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
 5e0:	5f                   	pop    %rdi
 5e1:	61                   	(bad)
 5e2:	64 64 72 33          	fs fs jb 619 <balancer_ingress+0x619>
 5e6:	32 00                	xor    (%rax),%al
 5e8:	69 6e 36 5f 61 64 64 	imul   $0x6464615f,0x36(%rsi),%ebp
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 5ef:	72 00                	jb     5f1 <balancer_ingress+0x5f1>
 5f1:	64 61                	fs (bad)
 5f3:	64 64 72 00          	fs fs jb 5f7 <balancer_ingress+0x5f7>
 5f7:	61                   	(bad)
 5f8:	64 64 72 73          	fs fs jb 66f <balancer_ingress+0x66f>
 5fc:	00 69 70             	add    %ch,0x70(%rcx)
 5ff:	76 36                	jbe    637 <balancer_ingress+0x637>
 601:	68 64 72 00 69       	push   $0x69007264
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
 606:	68 6c 00 74 6f       	push   $0x6f74006c
 60b:	73 00                	jae    60d <balancer_ingress+0x60d>
 60d:	74 6f                	je     67e <balancer_ingress+0x67e>
 60f:	74 5f                	je     670 <balancer_ingress+0x670>
 611:	6c                   	insb   (%dx),%es:(%rdi)
 612:	65 6e                	outsb  %gs:(%rsi),(%dx)
 614:	00 66 72             	add    %ah,0x72(%rsi)
 617:	61                   	(bad)
 618:	67 5f                	addr32 pop %rdi
 61a:	6f                   	outsl  %ds:(%rsi),(%dx)
 61b:	66 66 00 70 72       	data16 data16 add %dh,0x72(%rax)
 620:	6f                   	outsl  %ds:(%rsi),(%dx)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 621:	74 6f                	je     692 <balancer_ingress+0x692>
 623:	63 6f 6c             	movsxd 0x6c(%rdi),%ebp
 626:	00 63 68             	add    %ah,0x68(%rbx)
 629:	65 63 6b 00          	movsxd %gs:0x0(%rbx),%ebp
 62d:	5f                   	pop    %rdi
 62e:	5f                   	pop    %rdi
 62f:	73 75                	jae    6a6 <balancer_ingress+0x6a6>
  if (!data_stats) {
 631:	6d                   	insl   (%dx),%es:(%rdi)
 632:	31 36                	xor    %esi,(%rsi)
 634:	00 69 70             	add    %ch,0x70(%rcx)
 637:	68 64 72 00 63       	push   $0x63007264
 63c:	6f                   	outsl  %ds:(%rsi),(%dx)
 63d:	6e                   	outsb  %ds:(%rsi),(%dx)
 63e:	6e                   	outsb  %ds:(%rsi),(%dx)
  if (action >= 0) {
 63f:	5f                   	pop    %rdi
 640:	69 64 5f 6c 65 6e 73 	imul   $0x736e65,0x6c(%rdi,%rbx,2),%esp
 647:	00 
 648:	64 73 74             	fs jae 6bf <balancer_ingress+0x6bf>
  if (decap_dst_flags) {
 64b:	5f                   	pop    %rdi
 64c:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
  if (action >= 0) {
 64f:	6e                   	outsb  %ds:(%rsi),(%dx)
 650:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
 655:	6e                   	outsb  %ds:(%rsi),(%dx)
 656:	5f                   	pop    %rdi
 657:	69 64 00 71 75 69 63 	imul   $0x5f636975,0x71(%rax,%rax,1),%esp
 65e:	5f 
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
 65f:	6c                   	insb   (%dx),%es:(%rdi)
 660:	6f                   	outsl  %ds:(%rsi),(%dx)
 661:	6e                   	outsb  %ds:(%rsi),(%dx)
 662:	67 5f                	addr32 pop %rdi
 664:	68 65 61 64 65       	push   $0x65646165
 669:	72 00                	jb     66b <balancer_ingress+0x66b>
 66b:	71 75                	jno    6e2 <balancer_ingress+0x6e2>
    if (xpop_stats_data) {
 66d:	69 63 5f 73 68 6f 72 	imul   $0x726f6873,0x5f(%rbx),%esp
 674:	74 5f                	je     6d5 <balancer_ingress+0x6d5>
 676:	68 65 61 64 65       	push   $0x65646165
 67b:	72 00                	jb     67d <balancer_ingress+0x67d>
 67d:	70 72                	jo     6f1 <balancer_ingress+0x6f1>
 67f:	6f                   	outsl  %ds:(%rsi),(%dx)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 680:	63 65 73             	movsxd 0x73(%rbp),%esp
 683:	73 5f                	jae    6e4 <balancer_ingress+0x6e4>
 685:	70 61                	jo     6e8 <balancer_ingress+0x6e8>
 687:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 68a:	74 00                	je     68c <balancer_ingress+0x68c>
 68c:	78 64                	js     6f2 <balancer_ingress+0x6f2>
 68e:	70 00                	jo     690 <balancer_ingress+0x690>
 690:	64 61                	fs (bad)
 692:	74 61                	je     6f5 <balancer_ingress+0x6f5>
 694:	5f                   	pop    %rdi
 695:	65 6e                	outsb  %gs:(%rsi),(%dx)
 697:	64 00 64 61 74       	add    %ah,%fs:0x74(%rcx,%riz,2)
 69c:	61                   	(bad)
 69d:	5f                   	pop    %rdi
 69e:	6d                   	insl   (%dx),%es:(%rdi)
 69f:	65 74 61             	gs je  703 <balancer_ingress+0x703>
 6a2:	00 64 61 74          	add    %ah,0x74(%rcx,%riz,2)
 6a6:	61                   	(bad)
 6a7:	5f                   	pop    %rdi
 6a8:	68 61 72 64 5f       	push   $0x5f647261
  if (decap_dst_flags) {
 6ad:	73 74                	jae    723 <balancer_ingress+0x723>
 6af:	61                   	(bad)
 6b0:	72 74                	jb     726 <balancer_ingress+0x726>
 6b2:	00 72 78             	add    %dh,0x78(%rdx)
 6b5:	71 00                	jno    6b7 <balancer_ingress+0x6b7>
 6b7:	78 64                	js     71d <balancer_ingress+0x71d>
 6b9:	70 5f                	jo     71a <balancer_ingress+0x71a>
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 6bb:	72 78                	jb     735 <balancer_ingress+0x735>
 6bd:	71 5f                	jno    71e <balancer_ingress+0x71e>
 6bf:	69 6e 66 6f 00 74 78 	imul   $0x7874006f,0x66(%rsi),%ebp
 6c6:	71 00                	jno    6c8 <balancer_ingress+0x6c8>
 6c8:	78 64                	js     72e <balancer_ingress+0x72e>
 6ca:	70 5f                	jo     72b <balancer_ingress+0x72b>
    if (!data_stats) {
 6cc:	74 78                	je     746 <balancer_ingress+0x746>
 6ce:	71 5f                	jno    72f <balancer_ingress+0x72f>
 6d0:	69 6e 66 6f 00 66 72 	imul   $0x7266006f,0x66(%rsi),%ebp
    data_stats->v1 += 1;
 6d7:	61                   	(bad)
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
 6d8:	6d                   	insl   (%dx),%es:(%rdi)
 6d9:	65 5f                	gs pop %rdi
 6db:	73 7a                	jae    757 <balancer_ingress+0x757>
 6dd:	00 78 64             	add    %bh,0x64(%rax)
 6e0:	70 5f                	jo     741 <balancer_ingress+0x741>
 6e2:	6d                   	insl   (%dx),%es:(%rdi)
 6e3:	64 00 6e 68          	add    %ch,%fs:0x68(%rsi)
 6e7:	5f                   	pop    %rdi
 6e8:	6f                   	outsl  %ds:(%rsi),(%dx)
 6e9:	66 66 00 69 73       	data16 data16 add %ch,0x73(%rcx)
    csum = iph->check + 0x0001;
 6ee:	5f                   	pop    %rdi
 6ef:	69 70 76 36 00 5f 42 	imul   $0x425f0036,0x76(%rax),%esi
    iph->check = (csum & 0xffff) + (csum >> 16);
 6f6:	6f                   	outsl  %ds:(%rsi),(%dx)
 6f7:	6f                   	outsl  %ds:(%rsi),(%dx)
 6f8:	6c                   	insb   (%dx),%es:(%rdi)
 6f9:	00 66 6c             	add    %ah,0x6c(%rsi)
 6fc:	6f                   	outsl  %ds:(%rsi),(%dx)
 6fd:	77 00                	ja     6ff <balancer_ingress+0x6ff>
    if (!--iph->ttl) {
 6ff:	72 65                	jb     766 <balancer_ingress+0x766>
 701:	61                   	(bad)
 702:	6c                   	insb   (%dx),%es:(%rdi)
 703:	5f                   	pop    %rdi
 704:	69 6e 64 65 78 00 70 	imul   $0x70007865,0x64(%rsi),%ebp
 70b:	61                   	(bad)
 70c:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 70f:	74 5f                	je     770 <balancer_ingress+0x770>
 711:	64 65 73 63          	fs gs jae 778 <balancer_ingress+0x778>
  memcpy(new_eth->h_source, old_eth->h_source, 6);
 715:	72 69                	jb     780 <balancer_ingress+0x780>
 717:	70 74                	jo     78d <balancer_ingress+0x78d>
 719:	69 6f 6e 00 6d 61 63 	imul   $0x63616d00,0x6e(%rdi),%ebp
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 720:	5f                   	pop    %rdi
 721:	61                   	(bad)
 722:	64 64 72 5f          	fs fs jb 785 <balancer_ingress+0x785>
 726:	70 6f                	jo     797 <balancer_ingress+0x797>
 728:	73 00                	jae    72a <balancer_ingress+0x72a>
 72a:	74 68                	je     794 <balancer_ingress+0x794>
 72c:	5f                   	pop    %rdi
 72d:	6f                   	outsl  %ds:(%rsi),(%dx)
 72e:	66 66 00 76 69       	data16 data16 add %dh,0x69(%rsi)
 733:	70 5f                	jo     794 <balancer_ingress+0x794>
 735:	69 6e 66 6f 00 64 61 	imul   $0x6164006f,0x66(%rsi),%ebp
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
 73c:	74 61                	je     79f <balancer_ingress+0x79f>
 73e:	5f                   	pop    %rdi
 73f:	73 74                	jae    7b5 <balancer_ingress+0x7b5>
 741:	61                   	(bad)
 742:	74 73                	je     7b7 <balancer_ingress+0x7b7>
 744:	00 63 70             	add    %ah,0x70(%rbx)
 747:	75 5f                	jne    7a8 <balancer_ingress+0x7a8>
 749:	6e                   	outsb  %ds:(%rsi),(%dx)
 74a:	75 6d                	jne    7b9 <balancer_ingress+0x7b9>
 74c:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
 750:	5f                   	pop    %rdi
 751:	6d                   	insl   (%dx),%es:(%rdi)
 752:	61                   	(bad)
 753:	70 00                	jo     755 <balancer_ingress+0x755>
 755:	70 6b                	jo     7c2 <balancer_ingress+0x7c2>
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 757:	74 5f                	je     7b8 <balancer_ingress+0x7b8>
 759:	62                   	(bad)
 75a:	79 74                	jns    7d0 <balancer_ingress+0x7d0>
 75c:	65 73 00             	gs jae 75f <balancer_ingress+0x75f>
 75f:	6f                   	outsl  %ds:(%rsi),(%dx)
 760:	72 69                	jb     7cb <balancer_ingress+0x7cb>
 762:	67 69 6e 61 6c 5f 73 	imul   $0x70735f6c,0x61(%esi),%ebp
 769:	70 
  if (!data_stats) {
 76a:	6f                   	outsl  %ds:(%rsi),(%dx)
 76b:	72 74                	jb     7e1 <balancer_ingress+0x7e1>
 76d:	00 63 76             	add    %ah,0x76(%rbx)
 770:	61                   	(bad)
 771:	6c                   	insb   (%dx),%es:(%rdi)
 772:	00 69 70             	add    %ch,0x70(%rcx)
  if (action >= 0) {
 775:	68 5f 6c 65 6e       	push   $0x6e656c5f
 77a:	00 70 61             	add    %dh,0x61(%rax)
 77d:	73 73                	jae    7f2 <balancer_ingress+0x7f2>
 77f:	00 5f 5f             	add    %bl,0x5f(%rdi)
  if (decap_dst_flags) {
 782:	65 6c                	gs insb (%dx),%es:(%rdi)
  if (action >= 0) {
 784:	65 6d                	gs insl (%dx),%es:(%rdi)
 786:	00 69 64             	add    %ch,0x64(%rcx)
 789:	78 00                	js     78b <balancer_ingress+0x78b>
 78b:	65 6c                	gs insb (%dx),%es:(%rdi)
 78d:	65 6d                	gs insl (%dx),%es:(%rdi)
 78f:	5f                   	pop    %rdi
 790:	73 69                	jae    7fb <balancer_ingress+0x7fb>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
 792:	7a 65                	jp     7f9 <balancer_ingress+0x7f9>
 794:	00 5f 5f             	add    %bl,0x5f(%rdi)
 797:	70 65                	jo     7fe <balancer_ingress+0x7fe>
 799:	72 63                	jb     7fe <balancer_ingress+0x7fe>
 79b:	70 75                	jo     812 <balancer_ingress+0x812>
 79d:	5f                   	pop    %rdi
 79e:	69 64 00 6c 72 75 5f 	imul   $0x735f7572,0x6c(%rax,%rax,1),%esp
 7a5:	73 
    if (xpop_stats_data) {
 7a6:	74 61                	je     809 <balancer_ingress+0x809>
 7a8:	74 73                	je     81d <balancer_ingress+0x81d>
 7aa:	5f                   	pop    %rdi
 7ab:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 7af:	6c                   	insb   (%dx),%es:(%rdi)
  udp = data + off;
 7b0:	72 75                	jb     827 <balancer_ingress+0x827>
 7b2:	5f                   	pop    %rdi
 7b3:	73 74                	jae    829 <balancer_ingress+0x829>
  if (is_ipv6) {
 7b5:	61                   	(bad)
  udp = data + off;
 7b6:	74 73                	je     82b <balancer_ingress+0x82b>
 7b8:	00 69 73             	add    %ch,0x73(%rcx)
  if (udp + 1 > data_end) {
 7bb:	5f                   	pop    %rdi
 7bc:	69 63 6d 70 00 71 75 	imul   $0x75710070,0x6d(%rbx),%esp
 7c3:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
 7ca:	65 74 73             	gs je  840 <balancer_ingress+0x840>
 7cd:	5f                   	pop    %rdi
 7ce:	73 74                	jae    844 <balancer_ingress+0x844>
 7d0:	61                   	(bad)
 7d1:	74 73                	je     846 <balancer_ingress+0x846>
 7d3:	5f                   	pop    %rdi
 7d4:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 7d8:	71 70                	jno    84a <balancer_ingress+0x84a>
 7da:	72 00                	jb     7dc <balancer_ingress+0x7dc>
 7dc:	63 69 64             	movsxd 0x64(%rcx),%ebp
 7df:	5f                   	pop    %rdi
 7e0:	76 65                	jbe    847 <balancer_ingress+0x847>
 7e2:	72 73                	jb     857 <balancer_ingress+0x857>
 7e4:	69 6f 6e 00 69 73 5f 	imul   $0x5f736900,0x6e(%rdi),%ebp
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 7eb:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
 7f2:	00 71 75             	add    %dh,0x75(%rcx)
 7f5:	69 63 5f 70 61 72 73 	imul   $0x73726170,0x5f(%rbx),%esp
        bpf_map_lookup_elem(&stats, &stats_key);
 7fc:	65 5f                	gs pop %rdi
 7fe:	72 65                	jb     865 <balancer_ingress+0x865>
 800:	73 75                	jae    877 <balancer_ingress+0x877>
 802:	6c                   	insb   (%dx),%es:(%rdi)
 803:	74 00                	je     805 <balancer_ingress+0x805>
 805:	72 65                	jb     86c <balancer_ingress+0x86c>
    if (!icmp_ptb_v4_stats) {
 807:	61                   	(bad)
 808:	6c                   	insb   (%dx),%es:(%rdi)
 809:	5f                   	pop    %rdi
 80a:	70 6f                	jo     87b <balancer_ingress+0x87b>
 80c:	73 00                	jae    80e <balancer_ingress+0x80e>
 80e:	72 65                	jb     875 <balancer_ingress+0x875>
    icmp_ptb_v4_stats->v1 += 1;
 810:	73 00                	jae    812 <balancer_ingress+0x812>
 812:	70 61                	jo     875 <balancer_ingress+0x875>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 814:	72 73                	jb     889 <balancer_ingress+0x889>
 816:	65 5f                	gs pop %rdi
 818:	6c                   	insb   (%dx),%es:(%rdi)
      icmp_ptb_v4_stats->v2 += 1;
 819:	33 5f 68             	xor    0x68(%rdi),%ebx
 81c:	65 61                	gs (bad)
  if (iph + 1 > data_end) {
 81e:	64 65 72 73          	fs gs jb 895 <balancer_ingress+0x895>
 822:	00 69 70             	add    %ch,0x70(%rcx)
 825:	68 00 69 70 36       	push   $0x36706900
 82a:	68 00 70 61 72       	push   $0x72617000
  if (iph->ihl != 5) {
 82f:	73 65                	jae    896 <balancer_ingress+0x896>
 831:	5f                   	pop    %rdi
 832:	69 63 6d 70 00 69 63 	imul   $0x63690070,0x6d(%rbx),%esp
  pckt->flow.proto = iph->protocol;
 839:	6d                   	insl   (%dx),%es:(%rdi)
 83a:	70 5f                	jo     89b <balancer_ingress+0x89b>
 83c:	68 64 72 00 63       	push   $0x63007264
  pckt->flags |= F_ICMP;
 841:	68 65 63 6b 73       	push   $0x736b6365
  pckt->flow.src = iph->daddr;
 846:	75 6d                	jne    8b5 <balancer_ingress+0x8b5>
 848:	00 73 65             	add    %dh,0x65(%rbx)
  pckt->flow.dst = iph->saddr;
 84b:	71 75                	jno    8c2 <balancer_ingress+0x8c2>
 84d:	65 6e                	outsb  %gs:(%rsi),(%dx)
 84f:	63 65 00             	movsxd 0x0(%rbp),%esp
 852:	67 61                	addr32 (bad)
 854:	74 65                	je     8bb <balancer_ingress+0x8bb>
 856:	77 61                	ja     8b9 <balancer_ingress+0x8b9>
 858:	79 00                	jns    85a <balancer_ingress+0x85a>
 85a:	66 72 61             	data16 jb 8be <balancer_ingress+0x8be>
 85d:	67 00 5f 5f          	add    %bl,0x5f(%edi)
 861:	75 6e                	jne    8d1 <balancer_ingress+0x8d1>
 863:	75 73                	jne    8d8 <balancer_ingress+0x8d8>
 865:	65 64 00 6d 74       	gs add %ch,%fs:0x74(%rbp)
 86a:	75 00                	jne    86c <balancer_ingress+0x86c>
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
 86c:	72 65                	jb     8d3 <balancer_ingress+0x8d3>
 86e:	73 65                	jae    8d5 <balancer_ingress+0x8d5>
 870:	72 76                	jb     8e8 <balancer_ingress+0x8e8>
 872:	65 64 00 69 63       	gs add %ch,%fs:0x63(%rcx)
 877:	6d                   	insl   (%dx),%es:(%rdi)
 878:	70 68                	jo     8e2 <balancer_ingress+0x8e2>
 87a:	64 72 00             	fs jb  87d <balancer_ingress+0x87d>
 87d:	69 63 6d 70 5f 70 74 	imul   $0x74705f70,0x6d(%rbx),%esp
  vip.port = pckt.flow.port16[1];
 884:	62                   	(bad)
 885:	5f                   	pop    %rdi
 886:	76 34                	jbe    8bc <balancer_ingress+0x8bc>
 888:	5f                   	pop    %rdi
  vip.proto = pckt.flow.proto;
 889:	73 74                	jae    8ff <balancer_ingress+0x8ff>
 88b:	61                   	(bad)
 88c:	74 73                	je     901 <balancer_ingress+0x901>
 88e:	00 68 61             	add    %ch,0x61(%rax)
 891:	6e                   	outsb  %ds:(%rsi),(%dx)
 892:	64 6c                	fs insb (%dx),%es:(%rdi)
 894:	65 5f                	gs pop %rdi
 896:	69 66 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rsi),%esp
 89d:	00 73 65             	add    %dh,0x65(%rbx)
 8a0:	6e                   	outsb  %ds:(%rsi),(%dx)
 8a1:	64 5f                	fs pop %rdi
 8a3:	69 63 6d 70 5f 72 65 	imul   $0x65725f70,0x6d(%rbx),%esp
 8aa:	70 6c                	jo     918 <balancer_ingress+0x918>
  if (!vip_info) {
 8ac:	79 00                	jns    8ae <balancer_ingress+0x8ae>
 8ae:	74 6d                	je     91d <balancer_ingress+0x91d>
 8b0:	70 5f                	jo     911 <balancer_ingress+0x911>
 8b2:	61                   	(bad)
 8b3:	64 64 72 00          	fs fs jb 8b7 <balancer_ingress+0x8b7>
  if (data_end - data > MAX_PCKT_SIZE) {
 8b7:	63 73 75             	movsxd 0x75(%rbx),%esi
 8ba:	6d                   	insl   (%dx),%es:(%rdi)
 8bb:	00 69 70             	add    %ch,0x70(%rcx)
 8be:	76 34                	jbe    8f4 <balancer_ingress+0x8f4>
 8c0:	5f                   	pop    %rdi
 8c1:	63 73 75             	movsxd 0x75(%rbx),%esi
 8c4:	6d                   	insl   (%dx),%es:(%rdi)
 8c5:	5f                   	pop    %rdi
 8c6:	69 6e 6c 69 6e 65 00 	imul   $0x656e69,0x6c(%rsi),%ebp
 8cd:	6e                   	outsb  %ds:(%rsi),(%dx)
 8ce:	65 78 74             	gs js  945 <balancer_ingress+0x945>
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 8d1:	5f                   	pop    %rdi
 8d2:	69 70 68 5f 75 31 36 	imul   $0x3631755f,0x68(%rax),%esi
 8d9:	00 69 00             	add    %ch,0x0(%rcx)
 8dc:	70 61                	jo     93f <balancer_ingress+0x93f>
 8de:	72 73                	jb     953 <balancer_ingress+0x953>
 8e0:	65 5f                	gs pop %rdi
  if (!data_stats) {
 8e2:	69 63 6d 70 76 36 00 	imul   $0x367670,0x6d(%rbx),%esp
 8e9:	69 63 6d 70 36 5f 74 	imul   $0x745f3670,0x6d(%rbx),%esp
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 8f0:	79 70                	jns    962 <balancer_ingress+0x962>
 8f2:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
    pckt.flow.port16[0] = 0;
 8f6:	6d                   	insl   (%dx),%es:(%rdi)
 8f7:	70 36                	jo     92f <balancer_ingress+0x92f>
 8f9:	5f                   	pop    %rdi
  vip_num = vip_info->vip_num;
 8fa:	63 6f 64             	movsxd 0x64(%rdi),%ebp
 8fd:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
 901:	6d                   	insl   (%dx),%es:(%rdi)
 902:	70 36                	jo     93a <balancer_ingress+0x93a>
  __u32 cpu_num = bpf_get_smp_processor_id();
 904:	5f                   	pop    %rdi
 905:	63 6b 73             	movsxd 0x73(%rbx),%ebp
 908:	75 6d                	jne    977 <balancer_ingress+0x977>
 90a:	00 69 63             	add    %ch,0x63(%rcx)
 90d:	6d                   	insl   (%dx),%es:(%rdi)
 90e:	70 36                	jo     946 <balancer_ingress+0x946>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 910:	5f                   	pop    %rdi
 911:	64 61                	fs (bad)
 913:	74 61                	je     976 <balancer_ingress+0x976>
 915:	75 6e                	jne    985 <balancer_ingress+0x985>
 917:	00 75 6e             	add    %dh,0x6e(%rbp)
 91a:	5f                   	pop    %rdi
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
 91b:	64 61                	fs (bad)
 91d:	74 61                	je     980 <balancer_ingress+0x980>
 91f:	33 32                	xor    (%rdx),%esi
 921:	00 75 6e             	add    %dh,0x6e(%rbp)
 924:	5f                   	pop    %rdi
 925:	64 61                	fs (bad)
 927:	74 61                	je     98a <balancer_ingress+0x98a>
 929:	31 36                	xor    %esi,(%rsi)
    if (!lru_stats) {
 92b:	00 75 6e             	add    %dh,0x6e(%rbp)
 92e:	5f                   	pop    %rdi
 92f:	64 61                	fs (bad)
 931:	74 61                	je     994 <balancer_ingress+0x994>
 933:	38 00                	cmp    %al,(%rax)
    lru_stats->v1 += 1;
 935:	75 5f                	jne    996 <balancer_ingress+0x996>
 937:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
 93b:	00 69 64             	add    %ch,0x64(%rcx)
 93e:	65 6e                	outsb  %gs:(%rsi),(%dx)
 940:	74 69                	je     9ab <balancer_ingress+0x9ab>
 942:	66 69 65 72 00 69    	imul   $0x6900,0x72(%rbp),%sp
 948:	63 6d 70             	movsxd 0x70(%rbp),%ebp
 94b:	76 36                	jbe    983 <balancer_ingress+0x983>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 94d:	5f                   	pop    %rdi
 94e:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
 952:	00 75 5f             	add    %dh,0x5f(%rbp)
 955:	6e                   	outsb  %ds:(%rsi),(%dx)
 956:	64 5f                	fs pop %rdi
 958:	61                   	(bad)
 959:	64 76 74             	fs jbe 9d0 <balancer_ingress+0x9d0>
        bpf_map_lookup_elem(&stats, &stats_key);
 95c:	00 6f 76             	add    %ch,0x76(%rdi)
 95f:	65 72 72             	gs jb  9d4 <balancer_ingress+0x9d4>
 962:	69 64 65 00 73 6f 6c 	imul   $0x696c6f73,0x0(%rbp,%riz,2),%esp
 969:	69 
 96a:	63 69 74             	movsxd 0x74(%rcx),%ebp
    if (!icmp_ptb_v4_stats) {
 96d:	65 64 00 72 6f       	gs add %dh,%fs:0x6f(%rdx)
 972:	75 74                	jne    9e8 <balancer_ingress+0x9e8>
 974:	65 72 00             	gs jb  977 <balancer_ingress+0x977>
    icmp_ptb_v4_stats->v1 += 1;
 977:	72 65                	jb     9de <balancer_ingress+0x9de>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 979:	73 65                	jae    9e0 <balancer_ingress+0x9e0>
 97b:	72 76                	jb     9f3 <balancer_ingress+0x9f3>
 97d:	65 64 32 00          	gs xor %fs:(%rax),%al
      icmp_ptb_v4_stats->v2 += 1;
 981:	69 63 6d 70 76 36 5f 	imul   $0x5f367670,0x6d(%rbx),%esp
  if (iph + 1 > data_end) {
 988:	6e                   	outsb  %ds:(%rsi),(%dx)
 989:	64 5f                	fs pop %rdi
 98b:	61                   	(bad)
 98c:	64 76 74             	fs jbe a03 <balancer_ingress+0xa03>
 98f:	00 75 5f             	add    %dh,0x5f(%rbp)
  if (iph->ihl != 5) {
 992:	6e                   	outsb  %ds:(%rsi),(%dx)
 993:	64 5f                	fs pop %rdi
 995:	72 61                	jb     9f8 <balancer_ingress+0x9f8>
 997:	00 72 6f             	add    %dh,0x6f(%rdx)
 99a:	75 74                	jne    a10 <balancer_ingress+0xa10>
 99c:	65 72 5f             	gs jb  9fe <balancer_ingress+0x9fe>
  pckt->flow.proto = iph->protocol;
 99f:	70 72                	jo     a13 <balancer_ingress+0xa13>
 9a1:	65 66 00 68 6f       	data16 add %ch,%gs:0x6f(%rax)
  pckt->flags |= F_ICMP;
 9a6:	6d                   	insl   (%dx),%es:(%rdi)
 9a7:	65 5f                	gs pop %rdi
  pckt->flow.src = iph->daddr;
 9a9:	61                   	(bad)
 9aa:	67 65 6e             	outsb  %gs:(%esi),(%dx)
 9ad:	74 00                	je     9af <balancer_ingress+0x9af>
 9af:	6f                   	outsl  %ds:(%rsi),(%dx)
  pckt->flow.dst = iph->saddr;
 9b0:	74 68                	je     a1a <balancer_ingress+0xa1a>
 9b2:	65 72 00             	gs jb  9b5 <balancer_ingress+0x9b5>
 9b5:	6d                   	insl   (%dx),%es:(%rdi)
 9b6:	61                   	(bad)
 9b7:	6e                   	outsb  %ds:(%rsi),(%dx)
 9b8:	61                   	(bad)
 9b9:	67 65 64 00 72 74    	gs add %dh,%fs:0x74(%edx)
    vip.port = 0;
 9bf:	5f                   	pop    %rdi
 9c0:	6c                   	insb   (%dx),%es:(%rdi)
 9c1:	69 66 65 74 69 6d 65 	imul   $0x656d6974,0x65(%rsi),%esp
 9c8:	00 69 63             	add    %ch,0x63(%rcx)
 9cb:	6d                   	insl   (%dx),%es:(%rdi)
 9cc:	70 76                	jo     a44 <balancer_ingress+0xa44>
 9ce:	36 5f                	ss pop %rdi
 9d0:	6e                   	outsb  %ds:(%rsi),(%dx)
    if (!vip_info) {
 9d1:	64 5f                	fs pop %rdi
 9d3:	72 61                	jb     a36 <balancer_ingress+0xa36>
 9d5:	00 69 63             	add    %ch,0x63(%rcx)
 9d8:	6d                   	insl   (%dx),%es:(%rdi)
 9d9:	70 36                	jo     a11 <balancer_ingress+0xa11>
 9db:	68 64 72 00 69       	push   $0x69007264
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 9e0:	63 6d 70             	movsxd 0x70(%rbp),%ebp
 9e3:	5f                   	pop    %rdi
 9e4:	70 74                	jo     a5a <balancer_ingress+0xa5a>
      pckt.flow.port16[1] = 0;
 9e6:	62                   	(bad)
 9e7:	5f                   	pop    %rdi
 9e8:	76 36                	jbe    a20 <balancer_ingress+0xa20>
 9ea:	5f                   	pop    %rdi
 9eb:	73 74                	jae    a61 <balancer_ingress+0xa61>
 9ed:	61                   	(bad)
 9ee:	74 73                	je     a63 <balancer_ingress+0xa63>
 9f0:	00 70 61             	add    %dh,0x61(%rax)
  struct address dst_addr = {};
 9f3:	72 73                	jb     a68 <balancer_ingress+0xa68>
 9f5:	65 5f                	gs pop %rdi
 9f7:	74 63                	je     a5c <balancer_ingress+0xa5c>
 9f9:	70 00                	jo     9fb <balancer_ingress+0x9fb>
 9fb:	61                   	(bad)
 9fc:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 9ff:	73 65                	jae    a66 <balancer_ingress+0xa66>
 a01:	71 00                	jno    a03 <balancer_ingress+0xa03>
    dst_addr.addr = pckt->flow.dst;
 a03:	61                   	(bad)
 a04:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
 a08:	73 31                	jae    a3b <balancer_ingress+0xa3b>
 a0a:	00 64 6f 66          	add    %ah,0x66(%rdi,%rbp,2)
 a0e:	66 00 66 69          	data16 add %ah,0x69(%rsi)
 a12:	6e                   	outsb  %ds:(%rsi),(%dx)
 a13:	00 72 73             	add    %dh,0x73(%rdx)
 a16:	74 00                	je     a18 <balancer_ingress+0xa18>
 a18:	70 73                	jo     a8d <balancer_ingress+0xa8d>
 a1a:	68 00 61 63 6b       	push   $0x6b636100
 a1f:	00 75 72             	add    %dh,0x72(%rbp)
 a22:	67 00 65 63          	add    %ah,0x63(%ebp)
  if (decap_dst_flags) {
 a26:	65 00 63 77          	add    %ah,%gs:0x77(%rbx)
 a2a:	72 00                	jb     a2c <balancer_ingress+0xa2c>
 a2c:	77 69                	ja     a97 <balancer_ingress+0xa97>
 a2e:	6e                   	outsb  %ds:(%rsi),(%dx)
 a2f:	64 6f                	outsl  %fs:(%rsi),(%dx)
 a31:	77 00                	ja     a33 <balancer_ingress+0xa33>
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 a33:	75 72                	jne    aa7 <balancer_ingress+0xaa7>
 a35:	67 5f                	addr32 pop %rdi
 a37:	70 74                	jo     aad <balancer_ingress+0xaad>
 a39:	72 00                	jb     a3b <balancer_ingress+0xa3b>
 a3b:	74 63                	je     aa0 <balancer_ingress+0xaa0>
 a3d:	70 68                	jo     aa7 <balancer_ingress+0xaa7>
 a3f:	64 72 00             	fs jb  a42 <balancer_ingress+0xa42>
    if (!data_stats) {
 a42:	63 61 6c             	movsxd 0x6c(%rcx),%esp
 a45:	63 5f 6f             	movsxd 0x6f(%rdi),%ebx
 a48:	66 66 73 65          	data16 data16 jae ab1 <balancer_ingress+0xab1>
    data_stats->v1 += 1;
 a4c:	74 00                	je     a4e <balancer_ingress+0xa4e>
 a4e:	73 65                	jae    ab5 <balancer_ingress+0xab5>
 a50:	6e                   	outsb  %ds:(%rsi),(%dx)
 a51:	64 5f                	fs pop %rdi
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
 a53:	69 63 6d 70 36 5f 72 	imul   $0x725f3670,0x6d(%rbx),%esp
 a5a:	65 70 6c             	gs jo  ac9 <balancer_ingress+0xac9>
 a5d:	79 00                	jns    a5f <balancer_ingress+0xa5f>
 a5f:	63 68 65             	movsxd 0x65(%rax),%ebp
 a62:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 a65:	64 65 63 61 70       	fs movsxd %gs:0x70(%rcx),%esp
    csum = iph->check + 0x0001;
 a6a:	5f                   	pop    %rdi
 a6b:	64 73 74             	fs jae ae2 <balancer_ingress+0xae2>
    iph->check = (csum & 0xffff) + (csum >> 16);
 a6e:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 a72:	5f                   	pop    %rdi
 a73:	61                   	(bad)
 a74:	64 64 72 00          	fs fs jb a78 <balancer_ingress+0xa78>
 a78:	64 65 63 61 70       	fs movsxd %gs:0x70(%rcx),%esp
    if (!--iph->ttl) {
 a7d:	5f                   	pop    %rdi
 a7e:	64 73 74             	fs jae af5 <balancer_ingress+0xaf5>
 a81:	5f                   	pop    %rdi
 a82:	66 6c                	data16 insb (%dx),%es:(%rdi)
 a84:	61                   	(bad)
 a85:	67 73 00             	addr32 jae a88 <balancer_ingress+0xa88>
 a88:	72 65                	jb     aef <balancer_ingress+0xaef>
 a8a:	61                   	(bad)
 a8b:	6c                   	insb   (%dx),%es:(%rdi)
 a8c:	5f                   	pop    %rdi
  memcpy(new_eth->h_source, old_eth->h_source, 6);
 a8d:	62                   	(bad)
 a8e:	70 66                	jo     af6 <balancer_ingress+0xaf6>
 a90:	5f                   	pop    %rdi
 a91:	6d                   	insl   (%dx),%es:(%rdi)
 a92:	61                   	(bad)
 a93:	70 5f                	jo     af4 <balancer_ingress+0xaf4>
 a95:	6c                   	insb   (%dx),%es:(%rdi)
 a96:	6f                   	outsl  %ds:(%rsi),(%dx)
 a97:	6f                   	outsl  %ds:(%rsi),(%dx)
 a98:	6b 75 70 5f          	imul   $0x5f,0x70(%rbp),%esi
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 a9c:	65 6c                	gs insb (%dx),%es:(%rdi)
 a9e:	65 6d                	gs insl (%dx),%es:(%rdi)
 aa0:	00 64 65 63          	add    %ah,0x63(%rbp,%riz,2)
 aa4:	72 65                	jb     b0b <balancer_ingress+0xb0b>
 aa6:	6d                   	insl   (%dx),%es:(%rdi)
  new_eth->h_proto = BE_ETH_P_IP;
 aa7:	65 6e                	outsb  %gs:(%rsi),(%dx)
 aa9:	74 5f                	je     b0a <balancer_ingress+0xb0a>
 aab:	74 74                	je     b21 <balancer_ingress+0xb21>
 aad:	6c                   	insb   (%dx),%es:(%rdi)
 aae:	00 70 72             	add    %dh,0x72(%rax)
 ab1:	6f                   	outsl  %ds:(%rsi),(%dx)
 ab2:	63 65 73             	movsxd 0x73(%rbp),%esp
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
 ab5:	73 5f                	jae    b16 <balancer_ingress+0xb16>
 ab7:	65 6e                	outsb  %gs:(%rsi),(%dx)
 ab9:	63 61 70             	movsxd 0x70(%rcx),%esp
 abc:	65 64 5f             	gs fs pop %rdi
 abf:	69 70 69 70 5f 70 63 	imul   $0x63705f70,0x69(%rax),%esi
 ac6:	6b 74 00 78 70       	imul   $0x70,0x78(%rax,%rax,1),%esi
 acb:	6f                   	outsl  %ds:(%rsi),(%dx)
 acc:	70 5f                	jo     b2d <balancer_ingress+0xb2d>
 ace:	73 74                	jae    b44 <balancer_ingress+0xb44>
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 ad0:	61                   	(bad)
 ad1:	74 73                	je     b46 <balancer_ingress+0xb46>
 ad3:	5f                   	pop    %rdi
 ad4:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 ad8:	78 70                	js     b4a <balancer_ingress+0xb4a>
 ada:	6f                   	outsl  %ds:(%rsi),(%dx)
 adb:	70 5f                	jo     b3c <balancer_ingress+0xb3c>
 add:	73 74                	jae    b53 <balancer_ingress+0xb53>
 adf:	61                   	(bad)
  if (!data_stats) {
 ae0:	74 73                	je     b55 <balancer_ingress+0xb55>
 ae2:	5f                   	pop    %rdi
 ae3:	64 61                	fs (bad)
 ae5:	74 61                	je     b48 <balancer_ingress+0xb48>
 ae7:	00 69 6e             	add    %ch,0x6e(%rcx)
 aea:	6e                   	outsb  %ds:(%rsi),(%dx)
 aeb:	65 72 5f             	gs jb  b4d <balancer_ingress+0xb4d>
  if (action >= 0) {
 aee:	69 70 76 36 00 64 65 	imul   $0x65640036,0x76(%rax),%esi
 af5:	63 61 70             	movsxd 0x70(%rcx),%esp
 af8:	5f                   	pop    %rdi
 af9:	76 36                	jbe    b31 <balancer_ingress+0xb31>
  if (decap_dst_flags) {
 afb:	00 69 6e             	add    %ch,0x6e(%rcx)
  if (action >= 0) {
 afe:	6e                   	outsb  %ds:(%rsi),(%dx)
 aff:	65 72 5f             	gs jb  b61 <balancer_ingress+0xb61>
 b02:	76 34                	jbe    b38 <balancer_ingress+0xb38>
 b04:	00 6f 6c             	add    %ch,0x6c(%rdi)
 b07:	64 5f                	fs pop %rdi
 b09:	65 74 68             	gs je  b74 <balancer_ingress+0xb74>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
 b0c:	00 68 5f             	add    %ch,0x5f(%rax)
 b0f:	64 65 73 74          	fs gs jae b87 <balancer_ingress+0xb87>
 b13:	00 68 5f             	add    %ch,0x5f(%rax)
 b16:	73 6f                	jae    b87 <balancer_ingress+0xb87>
 b18:	75 72                	jne    b8c <balancer_ingress+0xb8c>
 b1a:	63 65 00             	movsxd 0x0(%rbp),%esp
    if (xpop_stats_data) {
 b1d:	65 74 68             	gs je  b88 <balancer_ingress+0xb88>
 b20:	68 64 72 00 6e       	push   $0x6e007264
 b25:	65 77 5f             	gs ja  b87 <balancer_ingress+0xb87>
 b28:	65 74 68             	gs je  b93 <balancer_ingress+0xb93>
 b2b:	00 70 61             	add    %dh,0x61(%rax)
 b2e:	72 73                	jb     ba3 <balancer_ingress+0xba3>
 b30:	65 5f                	gs pop %rdi
 b32:	75 64                	jne    b98 <balancer_ingress+0xb98>
 b34:	70 00                	jo     b36 <balancer_ingress+0xb36>
 b36:	75 64                	jne    b9c <balancer_ingress+0xb9c>
 b38:	70 68                	jo     ba2 <balancer_ingress+0xba2>
 b3a:	64 72 00             	fs jb  b3d <balancer_ingress+0xb3d>
 b3d:	64 65 63 61 70       	fs movsxd %gs:0x70(%rcx),%esp
 b42:	5f                   	pop    %rdi
 b43:	76 34                	jbe    b79 <balancer_ingress+0xb79>
 b45:	00 70 61             	add    %dh,0x61(%rax)
 b48:	72 73                	jb     bbd <balancer_ingress+0xbbd>
 b4a:	65 5f                	gs pop %rdi
 b4c:	71 75                	jno    bc3 <balancer_ingress+0xbc3>
 b4e:	69 63 00 71 75 69 63 	imul   $0x63697571,0x0(%rbx),%esp
 b55:	5f                   	pop    %rdi
        bpf_map_lookup_elem(&stats, &stats_key);
 b56:	64 61                	fs (bad)
 b58:	74 61                	je     bbb <balancer_ingress+0xbbb>
 b5a:	00 70 6b             	add    %dh,0x6b(%rax)
 b5d:	74 5f                	je     bbe <balancer_ingress+0xbbe>
 b5f:	74 79                	je     bda <balancer_ingress+0xbda>
 b61:	70 65                	jo     bc8 <balancer_ingress+0xbc8>
 b63:	00 63 6f             	add    %ah,0x6f(%rbx)
    if (!icmp_ptb_v6_stats) {
 b66:	6e                   	outsb  %ds:(%rsi),(%dx)
 b67:	6e                   	outsb  %ds:(%rsi),(%dx)
 b68:	49                   	rex.WB
 b69:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
 b6d:	6e                   	outsb  %ds:(%rsi),(%dx)
 b6e:	6e                   	outsb  %ds:(%rsi),(%dx)
    icmp_ptb_v6_stats->v1 += 1;
 b6f:	49                   	rex.WB
 b70:	64 56                	fs push %rsi
 b72:	65 72 73             	gs jb  be8 <balancer_ingress+0xbe8>
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 b75:	69 6f 6e 00 69 67 6e 	imul   $0x6e676900,0x6e(%rdi),%ebp
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 b7c:	6f                   	outsl  %ds:(%rsi),(%dx)
 b7d:	72 61                	jb     be0 <balancer_ingress+0xbe0>
 b7f:	62                   	(bad)
      icmp_ptb_v6_stats->v2 += 1;
 b80:	6c                   	insb   (%dx),%es:(%rdi)
 b81:	65 5f                	gs pop %rdi
 b83:	71 75                	jno    bfa <balancer_ingress+0xbfa>
  if (ip6h + 1 > data_end) {
 b85:	69 63 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rbx),%esp
 b8c:	5f                   	pop    %rdi
 b8d:	63 6f 64             	movsxd 0x64(%rdi),%ebp
 b90:	65 00 63 6f          	add    %ah,%gs:0x6f(%rbx)
 b94:	6e                   	outsb  %ds:(%rsi),(%dx)
 b95:	6e                   	outsb  %ds:(%rsi),(%dx)
 b96:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
  pckt->flow.proto = ip6h->nexthdr;
 b9b:	6e                   	outsb  %ds:(%rsi),(%dx)
 b9c:	5f                   	pop    %rdi
 b9d:	74 61                	je     c00 <balancer_ingress+0xc00>
  pckt->flags |= F_ICMP;
 b9f:	62                   	(bad)
 ba0:	6c                   	insb   (%dx),%es:(%rdi)
 ba1:	65 5f                	gs pop %rdi
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 ba3:	6c                   	insb   (%dx),%es:(%rdi)
 ba4:	6f                   	outsl  %ds:(%rsi),(%dx)
 ba5:	6f                   	outsl  %ds:(%rsi),(%dx)
 ba6:	6b 75 70 00          	imul   $0x0,0x70(%rbp),%esi
 baa:	69 73 47 6c 6f 62 61 	imul   $0x61626f6c,0x47(%rbx),%esi
 bb1:	6c                   	insb   (%dx),%es:(%rdi)
 bb2:	4c 72 75             	rex.WR jb c2a <balancer_ingress+0xc2a>
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 bb5:	00 63 75             	add    %ah,0x75(%rbx)
 bb8:	72 5f                	jb     c19 <balancer_ingress+0xc19>
 bba:	74 69                	je     c25 <balancer_ingress+0xc25>
 bbc:	6d                   	insl   (%dx),%es:(%rdi)
 bbd:	65 00 69 6e          	add    %ch,%gs:0x6e(%rcx)
 bc1:	63 72 5f             	movsxd 0x5f(%rdx),%esi
 bc4:	73 65                	jae    c2b <balancer_ingress+0xc2b>
 bc6:	72 76                	jb     c3e <balancer_ingress+0xc3e>
 bc8:	65 72 5f             	gs jb  c2a <balancer_ingress+0xc2a>
 bcb:	69 64 5f 72 6f 75 74 	imul   $0x6974756f,0x72(%rdi,%rbx,2),%esp
 bd2:	69 
  if (protocol == IPPROTO_IPIP) {
 bd3:	6e                   	outsb  %ds:(%rsi),(%dx)
 bd4:	67 5f                	addr32 pop %rdi
 bd6:	73 74                	jae    c4c <balancer_ingress+0xc4c>
 bd8:	61                   	(bad)
 bd9:	74 73                	je     c4e <balancer_ingress+0xc4e>
 bdb:	00 6e 65             	add    %ch,0x65(%rsi)
 bde:	77 43                	ja     c23 <balancer_ingress+0xc23>
 be0:	6f                   	outsl  %ds:(%rsi),(%dx)
 be1:	6e                   	outsb  %ds:(%rsi),(%dx)
 be2:	6e                   	outsb  %ds:(%rsi),(%dx)
 be3:	00 6d 69             	add    %ch,0x69(%rbp)
  struct address dst_addr = {};
 be6:	73 4d                	jae    c35 <balancer_ingress+0xc35>
 be8:	61                   	(bad)
 be9:	74 63                	je     c4e <balancer_ingress+0xc4e>
 beb:	68 49 6e 4c 52       	push   $0x524c6e49
 bf0:	55                   	push   %rbp
 bf1:	00 70 65             	add    %dh,0x65(%rax)
 bf4:	72 5f                	jb     c55 <balancer_ingress+0xc55>
    dst_addr.addr = pckt->flow.dst;
 bf6:	76 69                	jbe    c61 <balancer_ingress+0xc61>
 bf8:	70 5f                	jo     c59 <balancer_ingress+0xc59>
 bfa:	73 74                	jae    c70 <balancer_ingress+0xc70>
 bfc:	61                   	(bad)
 bfd:	74 73                	je     c72 <balancer_ingress+0xc72>
 bff:	00 63 68             	add    %ah,0x68(%rbx)
 c02:	65 63 6b 5f          	movsxd %gs:0x5f(%rbx),%ebp
 c06:	75 64                	jne    c6c <balancer_ingress+0xc6c>
 c08:	70 5f                	jo     c69 <balancer_ingress+0xc69>
 c0a:	66 6c                	data16 insb (%dx),%es:(%rdi)
 c0c:	6f                   	outsl  %ds:(%rsi),(%dx)
 c0d:	77 5f                	ja     c6e <balancer_ingress+0xc6e>
 c0f:	6d                   	insl   (%dx),%es:(%rdi)
 c10:	69 67 72 61 74 69 6f 	imul   $0x6f697461,0x72(%rdi),%esp
  if (decap_dst_flags) {
 c17:	6e                   	outsb  %ds:(%rsi),(%dx)
 c18:	00 64 6f 77          	add    %ah,0x77(%rdi,%rbp,2)
 c1c:	6e                   	outsb  %ds:(%rsi),(%dx)
 c1d:	5f                   	pop    %rdi
 c1e:	72 65                	jb     c85 <balancer_ingress+0xc85>
 c20:	61                   	(bad)
 c21:	6c                   	insb   (%dx),%es:(%rdi)
 c22:	00 69 73             	add    %ch,0x73(%rcx)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 c25:	5f                   	pop    %rdi
 c26:	75 6e                	jne    c96 <balancer_ingress+0xc96>
 c28:	64 65 72 5f          	fs gs jb c8b <balancer_ingress+0xc8b>
 c2c:	66 6c                	data16 insb (%dx),%es:(%rdi)
 c2e:	6f                   	outsl  %ds:(%rsi),(%dx)
 c2f:	6f                   	outsl  %ds:(%rsi),(%dx)
 c30:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
 c34:	6e                   	outsb  %ds:(%rsi),(%dx)
    if (!data_stats) {
 c35:	6e                   	outsb  %ds:(%rsi),(%dx)
 c36:	5f                   	pop    %rdi
 c37:	72 61                	jb     c9a <balancer_ingress+0xc9a>
 c39:	74 65                	je     ca0 <balancer_ingress+0xca0>
 c3b:	5f                   	pop    %rdi
 c3c:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
    data_stats->v1 += 1;
 c40:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
    if ((*data + offset) > *data_end) {
 c43:	6e                   	outsb  %ds:(%rsi),(%dx)
 c44:	5f                   	pop    %rdi
 c45:	72 61                	jb     ca8 <balancer_ingress+0xca8>
 c47:	74 65                	je     cae <balancer_ingress+0xcae>
 c49:	5f                   	pop    %rdi
 c4a:	73 74                	jae    cc0 <balancer_ingress+0xcc0>
 c4c:	61                   	(bad)
 c4d:	74 73                	je     cc2 <balancer_ingress+0xcc2>
 c4f:	00 65 6e             	add    %ah,0x6e(%rbp)
 c52:	63 61 70             	movsxd 0x70(%rcx),%esp
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
 c55:	5f                   	pop    %rdi
 c56:	76 34                	jbe    c8c <balancer_ingress+0xc8c>
 c58:	00 69 70             	add    %ch,0x70(%rcx)
 c5b:	5f                   	pop    %rdi
 c5c:	73 72                	jae    cd0 <balancer_ingress+0xcd0>
 c5e:	63 00                	movsxd (%rax),%eax
 c60:	63 72 65             	movsxd 0x65(%rdx),%esi
 c63:	61                   	(bad)
 c64:	74 65                	je     ccb <balancer_ingress+0xccb>
 c66:	5f                   	pop    %rdi
 c67:	76 34                	jbe    c9d <balancer_ingress+0xc9d>
    if (!--ip6h->hop_limit) {
 c69:	5f                   	pop    %rdi
 c6a:	68 64 72 00 67       	push   $0x67007264
 c6f:	65 74 5f             	gs je  cd1 <balancer_ingress+0xcd1>
 c72:	70 61                	jo     cd5 <balancer_ingress+0xcd5>
 c74:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 c77:	74 5f                	je     cd8 <balancer_ingress+0xcd8>
 c79:	64 73 74             	fs jae cf0 <balancer_ingress+0xcf0>
  memcpy(new_eth->h_source, old_eth->h_source, 6);
 c7c:	00 6e 65             	add    %ch,0x65(%rsi)
 c7f:	77 5f                	ja     ce0 <balancer_ingress+0xce0>
 c81:	64 73 74             	fs jae cf8 <balancer_ingress+0xcf8>
 c84:	5f                   	pop    %rdi
 c85:	6c                   	insb   (%dx),%es:(%rdi)
 c86:	72 75                	jb     cfd <balancer_ingress+0xcfd>
 c88:	00 73 72             	add    %dh,0x72(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 c8b:	63 5f 66             	movsxd 0x66(%rdi),%ebx
 c8e:	6f                   	outsl  %ds:(%rsi),(%dx)
 c8f:	75 6e                	jne    cff <balancer_ingress+0xcff>
 c91:	64 00 68 61          	add    %ch,%fs:0x61(%rax)
 c95:	73 68                	jae    cff <balancer_ingress+0xcff>
 c97:	5f                   	pop    %rdi
 c98:	31 36                	xor    %esi,(%rsi)
 c9a:	62                   	(bad)
 c9b:	79 74                	jns    d11 <balancer_ingress+0xd11>
 c9d:	65 73 00             	gs jae ca0 <balancer_ingress+0xca0>
 ca0:	5f                   	pop    %rdi
 ca1:	5f                   	pop    %rdi
 ca2:	6a 68                	push   $0x68
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
 ca4:	61                   	(bad)
 ca5:	73 68                	jae    d0f <balancer_ingress+0xd0f>
 ca7:	5f                   	pop    %rdi
 ca8:	6e                   	outsb  %ds:(%rsi),(%dx)
 ca9:	77 6f                	ja     d1a <balancer_ingress+0xd1a>
 cab:	72 64                	jb     d11 <balancer_ingress+0xd11>
 cad:	73 00                	jae    caf <balancer_ingress+0xcaf>
 caf:	62                   	(bad)
 cb0:	00 69 6e             	add    %ch,0x6e(%rcx)
 cb3:	69 74 76 61 6c 00 6a 	imul   $0x686a006c,0x61(%rsi,%rsi,2),%esi
 cba:	68 
 cbb:	61                   	(bad)
 cbc:	73 68                	jae    d26 <balancer_ingress+0xd26>
 cbe:	5f                   	pop    %rdi
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 cbf:	32 77 6f             	xor    0x6f(%rdi),%dh
 cc2:	72 64                	jb     d28 <balancer_ingress+0xd28>
 cc4:	73 00                	jae    cc6 <balancer_ingress+0xcc6>
 cc6:	67 65 74 5f          	addr32 gs je d29 <balancer_ingress+0xd29>
 cca:	70 61                	jo     d2d <balancer_ingress+0xd2d>
 ccc:	63 6b 65             	movsxd 0x65(%rbx),%ebp
  if (!data_stats) {
 ccf:	74 5f                	je     d30 <balancer_ingress+0xd30>
 cd1:	68 61 73 68 00       	push   $0x687361
 cd6:	72 6f                	jb     d47 <balancer_ingress+0xd47>
 cd8:	6c                   	insb   (%dx),%es:(%rdi)
 cd9:	33 32                	xor    (%rdx),%esi
 cdb:	00 77 6f             	add    %dh,0x6f(%rdi)
  if (action >= 0) {
 cde:	72 64                	jb     d44 <balancer_ingress+0xd44>
 ce0:	00 73 68             	add    %dh,0x68(%rbx)
 ce3:	69 66 74 00 69 6e 63 	imul   $0x636e6900,0x74(%rsi),%esp
  if (decap_dst_flags) {
 cea:	72 65                	jb     d51 <balancer_ingress+0xd51>
  if (action >= 0) {
 cec:	6d                   	insl   (%dx),%es:(%rdi)
 ced:	65 6e                	outsb  %gs:(%rsi),(%dx)
 cef:	74 5f                	je     d50 <balancer_ingress+0xd50>
 cf1:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 cf4:	64 72 6f             	fs jb  d66 <balancer_ingress+0xd66>
 cf7:	70 5f                	jo     d58 <balancer_ingress+0xd58>
 cf9:	6e                   	outsb  %ds:(%rsi),(%dx)
 cfa:	6f                   	outsl  %ds:(%rsi),(%dx)
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
 cfb:	5f                   	pop    %rdi
 cfc:	72 65                	jb     d63 <balancer_ingress+0xd63>
 cfe:	61                   	(bad)
 cff:	6c                   	insb   (%dx),%es:(%rdi)
 d00:	00 63 68             	add    %ah,0x68(%rbx)
 d03:	5f                   	pop    %rdi
 d04:	64 72 6f             	fs jb  d76 <balancer_ingress+0xd76>
 d07:	70 5f                	jo     d68 <balancer_ingress+0xd68>
 d09:	73 74                	jae    d7f <balancer_ingress+0xd7f>
    if (xpop_stats_data) {
 d0b:	61                   	(bad)
 d0c:	74 73                	je     d81 <balancer_ingress+0xd81>
 d0e:	5f                   	pop    %rdi
 d0f:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 d13:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 d16:	64 72 6f             	fs jb  d88 <balancer_ingress+0xd88>
  udp = data + off;
 d19:	70 5f                	jo     d7a <balancer_ingress+0xd7a>
 d1b:	73 74                	jae    d91 <balancer_ingress+0xd91>
  if (is_ipv6) {
 d1d:	61                   	(bad)
 d1e:	74 73                	je     d93 <balancer_ingress+0xd93>
  udp = data + off;
 d20:	00 69 6e             	add    %ch,0x6e(%rcx)
  if (udp + 1 > data_end) {
 d23:	63 72 65             	movsxd 0x65(%rdx),%esi
 d26:	6d                   	insl   (%dx),%es:(%rdi)
 d27:	65 6e                	outsb  %gs:(%rsi),(%dx)
 d29:	74 5f                	je     d8a <balancer_ingress+0xd8a>
 d2b:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 d2e:	64 72 6f             	fs jb  da0 <balancer_ingress+0xda0>
 d31:	70 5f                	jo     d92 <balancer_ingress+0xd92>
 d33:	72 65                	jb     d9a <balancer_ingress+0xd9a>
 d35:	61                   	(bad)
 d36:	6c                   	insb   (%dx),%es:(%rdi)
 d37:	5f                   	pop    %rdi
 d38:	30 00                	xor    %al,(%rax)
 d3a:	65 6e                	outsb  %gs:(%rsi),(%dx)
 d3c:	63 61 70             	movsxd 0x70(%rcx),%esp
 d3f:	5f                   	pop    %rdi
 d40:	76 36                	jbe    d78 <balancer_ingress+0xd78>
 d42:	00 63 72             	add    %ah,0x72(%rbx)
 d45:	65 61                	gs (bad)
 d47:	74 65                	je     dae <balancer_ingress+0xdae>
 d49:	5f                   	pop    %rdi
 d4a:	65 6e                	outsb  %gs:(%rsi),(%dx)
 d4c:	63 61 70             	movsxd 0x70(%rcx),%esp
 d4f:	5f                   	pop    %rdi
 d50:	69 70 76 36 5f 73 72 	imul   $0x72735f36,0x76(%rax),%esi
 d57:	63 00                	movsxd (%rax),%eax
 d59:	63 72 65             	movsxd 0x65(%rdx),%esi
 d5c:	61                   	(bad)
 d5d:	74 65                	je     dc4 <balancer_ingress+0xdc4>
 d5f:	5f                   	pop    %rdi
 d60:	76 36                	jbe    d98 <balancer_ingress+0xd98>
    vip.vip = pckt.flow.dst;
 d62:	5f                   	pop    %rdi
 d63:	68 64 72 00 74       	push   $0x74007264
 d68:	63 00                	movsxd (%rax),%eax
  vip.port = pckt.flow.port16[1];
 d6a:	69 6e 63 72 65 6d 65 	imul   $0x656d6572,0x63(%rsi),%ebp
 d71:	6e                   	outsb  %ds:(%rsi),(%dx)
 d72:	74 5f                	je     dd3 <balancer_ingress+0xdd3>
  vip.proto = pckt.flow.proto;
 d74:	71 75                	jno    deb <balancer_ingress+0xdeb>
 d76:	69 63 5f 63 69 64 5f 	imul   $0x5f646963,0x5f(%rbx),%esp
 d7d:	76 65                	jbe    de4 <balancer_ingress+0xde4>
 d7f:	72 73                	jb     df4 <balancer_ingress+0xdf4>
 d81:	69 6f 6e 5f 73 74 61 	imul   $0x6174735f,0x6e(%rdi),%ebp
 d88:	74 73                	je     dfd <balancer_ingress+0xdfd>
 d8a:	00 62 70             	add    %ah,0x70(%rdx)
 d8d:	66 5f                	pop    %di
 d8f:	6d                   	insl   (%dx),%es:(%rdi)
 d90:	61                   	(bad)
 d91:	70 5f                	jo     df2 <balancer_ingress+0xdf2>
 d93:	75 70                	jne    e05 <balancer_ingress+0xe05>
 d95:	64 61                	fs (bad)
  if (!vip_info) {
 d97:	74 65                	je     dfe <balancer_ingress+0xdfe>
 d99:	5f                   	pop    %rdi
 d9a:	65 6c                	gs insb (%dx),%es:(%rdi)
 d9c:	65 6d                	gs insl (%dx),%es:(%rdi)
 d9e:	00 75 70             	add    %dh,0x70(%rbp)
  if (data_end - data > MAX_PCKT_SIZE) {
 da1:	64 61                	fs (bad)
 da3:	74 65                	je     e0a <balancer_ingress+0xe0a>
 da5:	5f                   	pop    %rdi
 da6:	76 69                	jbe    e11 <balancer_ingress+0xe11>
 da8:	70 5f                	jo     e09 <balancer_ingress+0xe09>
 daa:	6c                   	insb   (%dx),%es:(%rdi)
 dab:	72 75                	jb     e22 <balancer_ingress+0xe22>
 dad:	5f                   	pop    %rdi
 dae:	6d                   	insl   (%dx),%es:(%rdi)
 daf:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 db6:	74 73                	je     e2b <balancer_ingress+0xe2b>
 db8:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 dbc:	5f                   	pop    %rdi
 dbd:	6d                   	insl   (%dx),%es:(%rdi)
 dbe:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 dc5:	74 5f                	je     e26 <balancer_ingress+0xe26>
 dc7:	76 69                	jbe    e32 <balancer_ingress+0xe32>
 dc9:	70 00                	jo     dcb <balancer_ingress+0xdcb>
  if (!data_stats) {
 dcb:	76 69                	jbe    e36 <balancer_ingress+0xe36>
 dcd:	70 5f                	jo     e2e <balancer_ingress+0xe2e>
 dcf:	6d                   	insl   (%dx),%es:(%rdi)
 dd0:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
  data_stats->v1 += 1;
 dd7:	74 73                	je     e4c <balancer_ingress+0xe4c>
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 dd9:	5f                   	pop    %rdi
 dda:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
    pckt.flow.port16[0] = 0;
 dde:	61                   	(bad)
 ddf:	64 64 72 65          	fs fs jb e48 <balancer_ingress+0xe48>
 de3:	73 73                	jae    e58 <balancer_ingress+0xe58>
  vip_num = vip_info->vip_num;
 de5:	5f                   	pop    %rdi
 de6:	6d                   	insl   (%dx),%es:(%rdi)
 de7:	61                   	(bad)
 de8:	74 63                	je     e4d <balancer_ingress+0xe4d>
 dea:	68 00 70 6f 72       	push   $0x726f7000
  __u32 cpu_num = bpf_get_smp_processor_id();
 def:	74 5f                	je     e50 <balancer_ingress+0xe50>
 df1:	6d                   	insl   (%dx),%es:(%rdi)
 df2:	61                   	(bad)
 df3:	74 63                	je     e58 <balancer_ingress+0xe58>
 df5:	68 00 70 72 6f       	push   $0x6f727000
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 dfa:	74 6f                	je     e6b <balancer_ingress+0xe6b>
 dfc:	5f                   	pop    %rdi
 dfd:	6d                   	insl   (%dx),%es:(%rdi)
 dfe:	61                   	(bad)
 dff:	74 63                	je     e64 <balancer_ingress+0xe64>
 e01:	68 00 76 69 70       	push   $0x70697600
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
 e06:	5f                   	pop    %rdi
 e07:	6d                   	insl   (%dx),%es:(%rdi)
 e08:	61                   	(bad)
 e09:	74 63                	je     e6e <balancer_ingress+0xe6e>
 e0b:	68 00 6c 72 75       	push   $0x75726c00
 e10:	5f                   	pop    %rdi
 e11:	6d                   	insl   (%dx),%es:(%rdi)
 e12:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
    if (!lru_stats) {
 e19:	74 00                	je     e1b <balancer_ingress+0xe1b>
 e1b:	63 68 65             	movsxd 0x65(%rax),%ebp
    lru_stats->v1 += 1;
 e1e:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 e21:	61                   	(bad)
 e22:	6e                   	outsb  %ds:(%rsi),(%dx)
 e23:	64 5f                	fs pop %rdi
 e25:	75 70                	jne    e97 <balancer_ingress+0xe97>
 e27:	64 61                	fs (bad)
 e29:	74 65                	je     e90 <balancer_ingress+0xe90>
 e2b:	5f                   	pop    %rdi
 e2c:	72 65                	jb     e93 <balancer_ingress+0xe93>
 e2e:	61                   	(bad)
 e2f:	6c                   	insb   (%dx),%es:(%rdi)
 e30:	5f                   	pop    %rdi
 e31:	69 6e 64 65 78 5f 69 	imul   $0x695f7865,0x64(%rsi),%ebp
 e38:	6e                   	outsb  %ds:(%rsi),(%dx)
 e39:	5f                   	pop    %rdi
 e3a:	6c                   	insb   (%dx),%es:(%rdi)
 e3b:	72 75                	jb     eb2 <balancer_ingress+0xeb2>
 e3d:	00 6a 68             	add    %ch,0x68(%rdx)
 e40:	61                   	(bad)
 e41:	73 68                	jae    eab <balancer_ingress+0xeab>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 e43:	00 6c 65 6e          	add    %ch,0x6e(%rbp,%riz,2)
 e47:	67 74 68             	addr32 je eb2 <balancer_ingress+0xeb2>
 e4a:	00 44 57 5f          	add    %al,0x5f(%rdi,%rdx,2)
 e4e:	41 54                	push   %r12
  if (!lru_map) {
 e50:	45 5f                	rex.RB pop %r15
 e52:	75 6e                	jne    ec2 <balancer_ingress+0xec2>
 e54:	73 69                	jae    ebf <balancer_ingress+0xebf>
 e56:	67 6e                	outsb  %ds:(%esi),(%dx)
  if ((vip_info->flags & F_QUIC_VIP)) {
 e58:	65 64 5f             	gs fs pop %rdi
 e5b:	38 00                	cmp    %al,(%rax)
 e5d:	44 57                	rex.R push %rdi
 e5f:	5f                   	pop    %rdi
 e60:	41 54                	push   %r12
    bool is_icmp = (pckt.flags & F_ICMP);
 e62:	45 5f                	rex.RB pop %r15
 e64:	75 6e                	jne    ed4 <balancer_ingress+0xed4>
    if (is_icmp) {
 e66:	73 69                	jae    ed1 <balancer_ingress+0xed1>
 e68:	67 6e                	outsb  %ds:(%esi),(%dx)
 e6a:	65 64 5f             	gs fs pop %rdi
 e6d:	31 00                	xor    %eax,(%rax)
 e6f:	44 57                	rex.R push %rdi
 e71:	5f                   	pop    %rdi
 e72:	41 54                	push   %r12
 e74:	45 5f                	rex.RB pop %r15
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
 e76:	75 6e                	jne    ee6 <balancer_ingress+0xee6>
 e78:	73 69                	jae    ee3 <balancer_ingress+0xee3>
 e7a:	67 6e                	outsb  %ds:(%esi),(%dx)
 e7c:	65 64 5f             	gs fs pop %rdi
 e7f:	36 34 00             	ss xor $0x0,%al
 e82:	44 57                	rex.R push %rdi
 e84:	5f                   	pop    %rdi
 e85:	41 54                	push   %r12
      if (!quic_packets_stats) {
 e87:	45 5f                	rex.RB pop %r15
 e89:	75 6e                	jne    ef9 <balancer_ingress+0xef9>
 e8b:	73 69                	jae    ef6 <balancer_ingress+0xef6>
 e8d:	67 6e                	outsb  %ds:(%esi),(%dx)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
 e8f:	65 64 5f             	gs fs pop %rdi
 e92:	33 32                	xor    (%rdx),%esi
  bool is_icmp = (pckt->flags & F_ICMP);
 e94:	00 44 57 5f          	add    %al,0x5f(%rdi,%rdx,2)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
 e98:	41 54                	push   %r12
 e9a:	45 5f                	rex.RB pop %r15
 e9c:	75 6e                	jne    f0c <balancer_ingress+0xf0c>
 e9e:	73 69                	jae    f09 <balancer_ingress+0xf09>
 ea0:	67 6e                	outsb  %ds:(%esi),(%dx)
 ea2:	65 64 5f             	gs fs pop %rdi
 ea5:	31 36                	xor    %esi,(%rsi)
 ea7:	00 62 61             	add    %ah,0x61(%rdx)
 eaa:	6c                   	insb   (%dx),%es:(%rdi)
 eab:	61                   	(bad)
 eac:	6e                   	outsb  %ds:(%rsi),(%dx)
 ead:	63 65 72             	movsxd 0x72(%rbp),%esp
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
 eb0:	5f                   	pop    %rdi
 eb1:	69 6e 67 72 65 73 73 	imul   $0x73736572,0x67(%rsi),%ebp
 eb8:	00 63 74             	add    %ah,0x74(%rbx)
 ebb:	78 00                	js     ebd <balancer_ingress+0xebd>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
 ebd:	65 74 68             	gs je  f28 <balancer_ingress+0xf28>
 ec0:	5f                   	pop    %rdi
 ec1:	70 72                	jo     f35 <balancer_ingress+0xf35>
 ec3:	6f                   	outsl  %ds:(%rsi),(%dx)
 ec4:	74 6f                	je     f35 <balancer_ingress+0xf35>
	...

Disassembly of section .debug_addr:

0000000000000000 <.debug_addr>:
  void* data = (void*)(long)ctx->data;
   0:	94                   	xchg   %eax,%esp
   1:	06                   	(bad)
   2:	00 00                	add    %al,(%rax)
   4:	05 00 08 00 2d       	add    $0x2d000800,%eax
   9:	24 00                	and    $0x0,%al
   b:	00 00                	add    %al,(%rax)
   d:	00 00                	add    %al,(%rax)
   f:	00 00                	add    %al,(%rax)
  11:	e8 fd 6d 81 88       	call   ffffffff88816e13 <server_id_map+0x36fc3f57ae13>
  16:	ff                   	(bad)
  17:	ff 00                	incl   (%rax)
  void* data_end = (void*)(long)ctx->data_end;
  19:	d0 0c 05 81 88 ff ff 	rorb   -0x777f(,%rax,1)
  if (data + nh_off > data_end) {
  20:	00 f8                	add    %bh,%al
  22:	fd                   	std
  23:	6d                   	insl   (%dx),%es:(%rdi)
  24:	81 88 ff ff 00 c8 0c 	orl    $0x8881050c,-0x37ff0001(%rax)
  2b:	05 81 88 
  2e:	ff                   	(bad)
  2f:	ff 00                	incl   (%rax)
  eth_proto = eth->h_proto;
  31:	f8                   	clc
  32:	0c 05                	or     $0x5,%al
  34:	81 88 ff ff 00 10 f4 	orl    $0x888150f4,0x1000ffff(%rax)
  3b:	50 81 88 
  if (eth_proto == BE_ETH_P_IP) {
  3e:	ff                   	(bad)
  3f:	ff 00                	incl   (%rax)
  41:	b0 26                	mov    $0x26,%al
  43:	39 03                	cmp    %eax,(%rbx)
  45:	c9                   	leave
  46:	ff                   	(bad)
  47:	ff 00                	incl   (%rax)
  49:	e0 26                	loopne 71 <balancer_ingress+0x71>
  4b:	49 03 c9             	add    %r9,%rcx
  4e:	ff                   	(bad)
  4f:	ff 00                	incl   (%rax)
  struct packet_description pckt = {};
  51:	80 28 49             	subb   $0x49,(%rax)
  54:	03 c9                	add    %ecx,%ecx
  56:	ff                   	(bad)
  57:	ff 00                	incl   (%rax)
  59:	20 29                	and    %ch,(%rcx)
  5b:	49 03 c9             	add    %r9,%rcx
  5e:	ff                   	(bad)
  5f:	ff 00                	incl   (%rax)
  61:	e0 fd                	loopne 60 <balancer_ingress+0x60>
  63:	6d                   	insl   (%dx),%es:(%rdi)
  64:	81 88 ff ff 00 40 77 	orl    $0x88813d77,0x4000ffff(%rax)
  6b:	3d 81 88 
  6e:	ff                   	(bad)
  6f:	ff 00                	incl   (%rax)
  71:	ec                   	in     (%dx),%al
  72:	fd                   	std
  73:	6d                   	insl   (%dx),%es:(%rdi)
  74:	81 88 ff ff 00 e4 fd 	orl    $0x88816dfd,-0x1bff0001(%rax)
  7b:	6d 81 88 
  7e:	ff                   	(bad)
  7f:	ff 00                	incl   (%rax)
  81:	80 a4 4b 81 88 ff ff 	andb   $0x0,-0x777f(%rbx,%rcx,2)
  88:	00 
  struct vip_definition vip = {};
  89:	c0 29 49             	shrb   $0x49,(%rcx)
  8c:	03 c9                	add    %ecx,%ecx
  8e:	ff                   	(bad)
  8f:	ff 00                	incl   (%rax)
  91:	b0 4d                	mov    $0x4d,%al
  93:	08 81 88 ff ff 00    	or     %al,0xffff88(%rcx)
  99:	c0 a4 4b 81 88 ff ff 	shlb   $0x0,-0x777f(%rbx,%rcx,2)
  a0:	00 
    if (iph + 1 > data_end) {
  a1:	b0 fc                	mov    $0xfc,%al
  a3:	4b 81 88 ff ff 00 00 	rex.WXB orq $0x0,0xffff(%r8)
  aa:	00 00 00 00 
    if (iph->ihl != 5) {
  ae:	00 00                	add    %al,(%rax)
  b0:	0e                   	(bad)
  b1:	01 00                	add    %eax,(%rax)
  b3:	00 00                	add    %al,(%rax)
  b5:	00 00                	add    %al,(%rax)
  b7:	00 27                	add    %ah,(%rdi)
    pckt->tos = iph->tos;
  b9:	01 00                	add    %eax,(%rax)
  bb:	00 00                	add    %al,(%rax)
  bd:	00 00                	add    %al,(%rax)
  bf:	00 5c 09 00          	add    %bl,0x0(%rcx,%rcx,1)
    pckt->flow.proto = *protocol;
  c3:	00 00                	add    %al,(%rax)
  c5:	00 00                	add    %al,(%rax)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  c7:	00 65 04             	add    %ah,0x4(%rbp)
  ca:	00 00                	add    %al,(%rax)
  cc:	00 00                	add    %al,(%rax)
  ce:	00 00                	add    %al,(%rax)
  d0:	56                   	push   %rsi
  d1:	0b 00                	or     (%rax),%eax
  d3:	00 00                	add    %al,(%rax)
  d5:	00 00                	add    %al,(%rax)
  d7:	00 9d 04 00 00 00    	add    %bl,0x4(%rbp)
    if (*protocol == IPPROTO_ICMP) {
  dd:	00 00                	add    %al,(%rax)
  df:	00 a1 04 00 00 00    	add    %ah,0x4(%rcx)
  if (icmp_hdr + 1 > data_end) {
  e5:	00 00                	add    %al,(%rax)
  e7:	00 19                	add    %bl,(%rcx)
  e9:	0d 00 00 00 00       	or     $0x0,%eax
  ee:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
  f0:	1d 0d 00 00 00       	sbb    $0xd,%eax
  f5:	00 00                	add    %al,(%rax)
  f7:	00 0b                	add    %cl,(%rbx)
  f9:	0a 00                	or     (%rax),%al
  fb:	00 00                	add    %al,(%rax)
  fd:	00 00                	add    %al,(%rax)
  ff:	00 32                	add    %dh,(%rdx)
 101:	0a 00                	or     (%rax),%al
 103:	00 00                	add    %al,(%rax)
 105:	00 00                	add    %al,(%rax)
 107:	00 53 0a             	add    %dl,0xa(%rbx)
 10a:	00 00                	add    %al,(%rax)
 10c:	00 00                	add    %al,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
 10e:	00 00                	add    %al,(%rax)
 110:	8d 0a                	lea    (%rdx),%ecx
  icmp_hdr->checksum += 0x0008;
 112:	00 00                	add    %al,(%rax)
 114:	00 00                	add    %al,(%rax)
 116:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 118:	d0 0a                	rorb   (%rdx)
 11a:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
 11c:	00 00                	add    %al,(%rax)
  tmp_addr = iph->daddr;
 11e:	00 00                	add    %al,(%rax)
 120:	0c 0b                	or     $0xb,%al
  iph->daddr = iph->saddr;
 122:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
 124:	00 00                	add    %al,(%rax)
 126:	00 00                	add    %al,(%rax)
 128:	e5 0b                	in     $0xb,%eax
 12a:	00 00                	add    %al,(%rax)
 12c:	00 00                	add    %al,(%rax)
 12e:	00 00                	add    %al,(%rax)
 130:	fe 0b                	decb   (%rbx)
 132:	00 00                	add    %al,(%rax)
 134:	00 00                	add    %al,(%rax)
 136:	00 00                	add    %al,(%rax)
 138:	25 0c 00 00 00       	and    $0xc,%eax
 13d:	00 00                	add    %al,(%rax)
 13f:	00 42 0c             	add    %al,0xc(%rdx)
 142:	00 00                	add    %al,(%rax)
 144:	00 00                	add    %al,(%rax)
 146:	00 00                	add    %al,(%rax)
 148:	54                   	push   %rsp
 149:	0c 00                	or     $0x0,%al
 14b:	00 00                	add    %al,(%rax)
 14d:	00 00                	add    %al,(%rax)
 14f:	00 7b 0c             	add    %bh,0xc(%rbx)
 152:	00 00                	add    %al,(%rax)
 154:	00 00                	add    %al,(%rax)
 156:	00 00                	add    %al,(%rax)
 158:	bf 0c 00 00 00       	mov    $0xc,%edi
 15d:	00 00                	add    %al,(%rax)
  struct packet_description pckt = {};
 15f:	00 fb                	add    %bh,%bl
 161:	0c 00                	or     $0x0,%al
 163:	00 00                	add    %al,(%rax)
 165:	00 00                	add    %al,(%rax)
 167:	00 7b 0d             	add    %bh,0xd(%rbx)
 16a:	00 00                	add    %al,(%rax)
 16c:	00 00                	add    %al,(%rax)
 16e:	00 00                	add    %al,(%rax)
 170:	d5                   	(bad)
 171:	0e                   	(bad)
 172:	00 00                	add    %al,(%rax)
 174:	00 00                	add    %al,(%rax)
 176:	00 00                	add    %al,(%rax)
 178:	bb 0d 00 00 00       	mov    $0xd,%ebx
 17d:	00 00                	add    %al,(%rax)
 17f:	00 ee                	add    %ch,%dh
 181:	0d 00 00 00 00       	or     $0x0,%eax
 186:	00 00                	add    %al,(%rax)
 188:	05 0e 00 00 00       	add    $0xe,%eax
 18d:	00 00                	add    %al,(%rax)
 18f:	00 8b 0f 00 00 00    	add    %cl,0xf(%rbx)
  struct vip_definition vip = {};
 195:	00 00                	add    %al,(%rax)
 197:	00 45 11             	add    %al,0x11(%rbp)
 19a:	00 00                	add    %al,(%rax)
 19c:	00 00                	add    %al,(%rax)
 19e:	00 00                	add    %al,(%rax)
 1a0:	04 22                	add    $0x22,%al
 1a2:	00 00                	add    %al,(%rax)
 1a4:	00 00                	add    %al,(%rax)
 1a6:	00 00                	add    %al,(%rax)
 1a8:	28 22                	sub    %ah,(%rdx)
 1aa:	00 00                	add    %al,(%rax)
 1ac:	00 00                	add    %al,(%rax)
 1ae:	00 00                	add    %al,(%rax)
    if (ip6h + 1 > data_end) {
 1b0:	52                   	push   %rdx
 1b1:	22 00                	and    (%rax),%al
 1b3:	00 00                	add    %al,(%rax)
 1b5:	00 00                	add    %al,(%rax)
 1b7:	00 44 23 00          	add    %al,0x0(%rbx,%riz,1)
 1bb:	00 00                	add    %al,(%rax)
    *protocol = ip6h->nexthdr;
 1bd:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
 1bf:	00 00                	add    %al,(%rax)
 1c1:	24 00                	and    $0x0,%al
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1c3:	00 00                	add    %al,(%rax)
 1c5:	00 00                	add    %al,(%rax)
 1c7:	00 94 23 00 00 00 00 	add    %dl,0x0(%rbx,%riz,1)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1ce:	00 00                	add    %al,(%rax)
 1d0:	c5 0f 00             	(bad)
 1d3:	00 00                	add    %al,(%rax)
 1d5:	00 00                	add    %al,(%rax)
 1d7:	00 ed                	add    %ch,%ch
    if (*protocol == IPPROTO_FRAGMENT) {
 1d9:	0f 00 00             	sldt   (%rax)
 1dc:	00 00                	add    %al,(%rax)
 1de:	00 00                	add    %al,(%rax)
 1e0:	1b 10                	sbb    (%rax),%edx
 1e2:	00 00                	add    %al,(%rax)
 1e4:	00 00                	add    %al,(%rax)
 1e6:	00 00                	add    %al,(%rax)
 1e8:	f9                   	stc
 1e9:	11 00                	adc    %eax,(%rax)
 1eb:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 1ed:	00 00                	add    %al,(%rax)
 1ef:	00 18                	add    %bl,(%rax)
 1f1:	12 00                	adc    (%rax),%al
 1f3:	00 00                	add    %al,(%rax)
 1f5:	00 00                	add    %al,(%rax)
 1f7:	00 2d 12 00 00 00    	add    %ch,0x12(%rip)        # 20f <balancer_ingress+0x20f>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 1fd:	00 00                	add    %al,(%rax)
 1ff:	00 88 12 00 00 00    	add    %cl,0x12(%rax)
 205:	00 00                	add    %al,(%rax)
 207:	00 a2 12 00 00 00    	add    %ah,0x12(%rdx)
 20d:	00 00                	add    %al,(%rax)
 20f:	00 a7 12 00 00 00    	add    %ah,0x12(%rdi)
 215:	00 00                	add    %al,(%rax)
 217:	00 b5 12 00 00 00    	add    %dh,0x12(%rbp)
 21d:	00 00                	add    %al,(%rax)
 21f:	00 60 14             	add    %ah,0x14(%rax)
 222:	00 00                	add    %al,(%rax)
 224:	00 00                	add    %al,(%rax)
 226:	00 00                	add    %al,(%rax)
 228:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
 229:	14 00                	adc    $0x0,%al
 22b:	00 00                	add    %al,(%rax)
 22d:	00 00                	add    %al,(%rax)
 22f:	00 44 15 00          	add    %al,0x0(%rbp,%rdx,1)
 233:	00 00                	add    %al,(%rax)
 235:	00 00                	add    %al,(%rax)
 237:	00 50 15             	add    %dl,0x15(%rax)
 23a:	00 00                	add    %al,(%rax)
 23c:	00 00                	add    %al,(%rax)
 23e:	00 00                	add    %al,(%rax)
 240:	59                   	pop    %rcx
 241:	15 00 00 00 00       	adc    $0x0,%eax
 246:	00 00                	add    %al,(%rax)
 248:	62 15                	(bad)
 24a:	00 00                	add    %al,(%rax)
 24c:	00 00                	add    %al,(%rax)
 24e:	00 00                	add    %al,(%rax)
 250:	6b 15 00 00 00 00 00 	imul   $0x0,0x0(%rip),%edx        # 257 <balancer_ingress+0x257>
 257:	00 74 15 00          	add    %dh,0x0(%rbp,%rdx,1)
 25b:	00 00                	add    %al,(%rax)
 25d:	00 00                	add    %al,(%rax)
 25f:	00 7d 15             	add    %bh,0x15(%rbp)
 262:	00 00                	add    %al,(%rax)
 264:	00 00                	add    %al,(%rax)
 266:	00 00                	add    %al,(%rax)
 268:	84 15 00 00 00 00    	test   %dl,0x0(%rip)        # 26e <balancer_ingress+0x26e>
 26e:	00 00                	add    %al,(%rax)
 270:	08 16                	or     %dl,(%rsi)
 272:	00 00                	add    %al,(%rax)
 274:	00 00                	add    %al,(%rax)
 276:	00 00                	add    %al,(%rax)
 278:	d8 15 00 00 00 00    	fcoms  0x0(%rip)        # 27e <balancer_ingress+0x27e>
 27e:	00 00                	add    %al,(%rax)
 280:	e0 15                	loopne 297 <balancer_ingress+0x297>
 282:	00 00                	add    %al,(%rax)
 284:	00 00                	add    %al,(%rax)
 286:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 288:	9a                   	(bad)
 289:	17                   	(bad)
 28a:	00 00                	add    %al,(%rax)
 28c:	00 00                	add    %al,(%rax)
 28e:	00 00                	add    %al,(%rax)
 290:	ba 17 00 00 00       	mov    $0x17,%edx
 295:	00 00                	add    %al,(%rax)
 297:	00 e5                	add    %ah,%ch
 299:	17                   	(bad)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 29a:	00 00                	add    %al,(%rax)
 29c:	00 00                	add    %al,(%rax)
 29e:	00 00                	add    %al,(%rax)
 2a0:	f2 12 00             	repnz adc (%rax),%al
 2a3:	00 00                	add    %al,(%rax)
 2a5:	00 00                	add    %al,(%rax)
 2a7:	00 38                	add    %bh,(%rax)
 2a9:	13 00                	adc    (%rax),%eax
 2ab:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 2ad:	00 00                	add    %al,(%rax)
 2af:	00 86 13 00 00 00    	add    %al,0x13(%rsi)
  if (icmp_hdr + 1 > data_end) {
 2b5:	00 00                	add    %al,(%rax)
 2b7:	00 17                	add    %dl,(%rdi)
 2b9:	14 00                	adc    $0x0,%al
 2bb:	00 00                	add    %al,(%rax)
 2bd:	00 00                	add    %al,(%rax)
 2bf:	00 3c 14             	add    %bh,(%rsp,%rdx,1)
  if (icmp_hdr->type == ICMP_ECHO) {
 2c2:	00 00                	add    %al,(%rax)
 2c4:	00 00                	add    %al,(%rax)
 2c6:	00 00                	add    %al,(%rax)
 2c8:	5a                   	pop    %rdx
 2c9:	16                   	(bad)
 2ca:	00 00                	add    %al,(%rax)
 2cc:	00 00                	add    %al,(%rax)
 2ce:	00 00                	add    %al,(%rax)
 2d0:	ce                   	(bad)
 2d1:	16                   	(bad)
 2d2:	00 00                	add    %al,(%rax)
 2d4:	00 00                	add    %al,(%rax)
 2d6:	00 00                	add    %al,(%rax)
 2d8:	d6                   	(bad)
 2d9:	16                   	(bad)
 2da:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2dc:	00 00                	add    %al,(%rax)
 2de:	00 00                	add    %al,(%rax)
 2e0:	d1 04 00             	roll   (%rax,%rax,1)
 2e3:	00 00                	add    %al,(%rax)
       sizeof(struct icmphdr)) > data_end) {
 2e5:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 2e7:	00 db                	add    %bl,%bl
 2e9:	02 00                	add    (%rax),%al
 2eb:	00 00                	add    %al,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
 2ed:	00 00                	add    %al,(%rax)
 2ef:	00 06                	add    %al,(%rsi)
  icmp_hdr->checksum += 0x0008;
 2f1:	03 00                	add    (%rax),%eax
 2f3:	00 00                	add    %al,(%rax)
 2f5:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 2f7:	00 f6                	add    %dh,%dh
 2f9:	07                   	(bad)
  iph->daddr = iph->saddr;
 2fa:	00 00                	add    %al,(%rax)
 2fc:	00 00                	add    %al,(%rax)
  tmp_addr = iph->daddr;
 2fe:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
 300:	fc                   	cld
 301:	03 00                	add    (%rax),%eax
  iph->saddr = tmp_addr;
 303:	00 00                	add    %al,(%rax)
 305:	00 00                	add    %al,(%rax)
 307:	00 00                	add    %al,(%rax)
 309:	04 00                	add    $0x0,%al
 30b:	00 00                	add    %al,(%rax)
 30d:	00 00                	add    %al,(%rax)
 30f:	00 b0 07 00 00 00    	add    %dh,0x7(%rax)
 315:	00 00                	add    %al,(%rax)
 317:	00 b4 07 00 00 00 00 	add    %dh,0x0(%rdi,%rax,1)
 31e:	00 00                	add    %al,(%rax)
 320:	5e                   	pop    %rsi
 321:	05 00 00 00 00       	add    $0x0,%eax
 326:	00 00                	add    %al,(%rax)
 328:	72 05                	jb     32f <balancer_ingress+0x32f>
 32a:	00 00                	add    %al,(%rax)
 32c:	00 00                	add    %al,(%rax)
 32e:	00 00                	add    %al,(%rax)
 330:	99                   	cltd
 331:	05 00 00 00 00       	add    $0x0,%eax
 336:	00 00                	add    %al,(%rax)
 338:	b6 05                	mov    $0x5,%dh
 33a:	00 00                	add    %al,(%rax)
 33c:	00 00                	add    %al,(%rax)
 33e:	00 00                	add    %al,(%rax)
 340:	dd 05 00 00 00 00    	fldl   0x0(%rip)        # 346 <balancer_ingress+0x346>
 346:	00 00                	add    %al,(%rax)
 348:	21 06                	and    %eax,(%rsi)
 34a:	00 00                	add    %al,(%rax)
 34c:	00 00                	add    %al,(%rax)
 34e:	00 00                	add    %al,(%rax)
 350:	5d                   	pop    %rbp
 351:	06                   	(bad)
 352:	00 00                	add    %al,(%rax)
 354:	00 00                	add    %al,(%rax)
 356:	00 00                	add    %al,(%rax)
 358:	80 06 00             	addb   $0x0,(%rsi)
 35b:	00 00                	add    %al,(%rax)
 35d:	00 00                	add    %al,(%rax)
 35f:	00 94 06 00 00 00 00 	add    %dl,0x0(%rsi,%rax,1)
 366:	00 00                	add    %al,(%rax)
 368:	bb 06 00 00 00       	mov    $0x6,%ebx
 36d:	00 00                	add    %al,(%rax)
 36f:	00 d8                	add    %bl,%al
 371:	06                   	(bad)
 372:	00 00                	add    %al,(%rax)
 374:	00 00                	add    %al,(%rax)
 376:	00 00                	add    %al,(%rax)
 378:	12 07                	adc    (%rdi),%al
 37a:	00 00                	add    %al,(%rax)
 37c:	00 00                	add    %al,(%rax)
 37e:	00 00                	add    %al,(%rax)
 380:	56                   	push   %rsi
 381:	07                   	(bad)
 382:	00 00                	add    %al,(%rax)
 384:	00 00                	add    %al,(%rax)
 386:	00 00                	add    %al,(%rax)
 388:	92                   	xchg   %eax,%edx
 389:	07                   	(bad)
 38a:	00 00                	add    %al,(%rax)
 38c:	00 00                	add    %al,(%rax)
 38e:	00 00                	add    %al,(%rax)
 390:	91                   	xchg   %eax,%ecx
 391:	08 00                	or     %al,(%rax)
 393:	00 00                	add    %al,(%rax)
 395:	00 00                	add    %al,(%rax)
 397:	00 c3                	add    %al,%bl
 399:	09 00                	or     %eax,(%rax)
 39b:	00 00                	add    %al,(%rax)
 39d:	00 00                	add    %al,(%rax)
 39f:	00 d1                	add    %dl,%cl
 3a1:	08 00                	or     %al,(%rax)
 3a3:	00 00                	add    %al,(%rax)
 3a5:	00 00                	add    %al,(%rax)
 3a7:	00 04 09             	add    %al,(%rcx,%rcx,1)
 3aa:	00 00                	add    %al,(%rax)
 3ac:	00 00                	add    %al,(%rax)
 3ae:	00 00                	add    %al,(%rax)
 3b0:	1b 09                	sbb    (%rcx),%ecx
 3b2:	00 00                	add    %al,(%rax)
 3b4:	00 00                	add    %al,(%rax)
 3b6:	00 00                	add    %al,(%rax)
 3b8:	76 0e                	jbe    3c8 <balancer_ingress+0x3c8>
 3ba:	00 00                	add    %al,(%rax)
 3bc:	00 00                	add    %al,(%rax)
 3be:	00 00                	add    %al,(%rax)
 3c0:	8a 10                	mov    (%rax),%dl
 3c2:	00 00                	add    %al,(%rax)
 3c4:	00 00                	add    %al,(%rax)
 3c6:	00 00                	add    %al,(%rax)
 3c8:	7b 18                	jnp    3e2 <balancer_ingress+0x3e2>
 3ca:	00 00                	add    %al,(%rax)
 3cc:	00 00                	add    %al,(%rax)
 3ce:	00 00                	add    %al,(%rax)
 3d0:	9e                   	sahf
 3d1:	18 00                	sbb    %al,(%rax)
 3d3:	00 00                	add    %al,(%rax)
 3d5:	00 00                	add    %al,(%rax)
 3d7:	00 cf                	add    %cl,%bh
 3d9:	18 00                	sbb    %al,(%rax)
 3db:	00 00                	add    %al,(%rax)
 3dd:	00 00                	add    %al,(%rax)
 3df:	00 9b 21 00 00 00    	add    %bl,0x21(%rbx)
  if (protocol == IPPROTO_IPIP) {
 3e5:	00 00                	add    %al,(%rax)
 3e7:	00 04 23             	add    %al,(%rbx,%riz,1)
 3ea:	00 00                	add    %al,(%rax)
 3ec:	00 00                	add    %al,(%rax)
 3ee:	00 00                	add    %al,(%rax)
 3f0:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
 3f1:	22 00                	and    (%rax),%al
 3f3:	00 00                	add    %al,(%rax)
 3f5:	00 00                	add    %al,(%rax)
 3f7:	00 0e                	add    %cl,(%rsi)
 3f9:	0f 00 00             	sldt   (%rax)
  tcp = data + off;
 3fc:	00 00                	add    %al,(%rax)
 3fe:	00 00                	add    %al,(%rax)
  if (is_ipv6) {
 400:	2c 0f                	sub    $0xf,%al
  tcp = data + off;
 402:	00 00                	add    %al,(%rax)
 404:	00 00                	add    %al,(%rax)
  if (tcp + 1 > data_end) {
 406:	00 00                	add    %al,(%rax)
 408:	40 19 00             	rex sbb %eax,(%rax)
 40b:	00 00                	add    %al,(%rax)
 40d:	00 00                	add    %al,(%rax)
 40f:	00 94 19 00 00 00 00 	add    %dl,0x0(%rcx,%rbx,1)
  if (tcp->syn) {
 416:	00 00                	add    %al,(%rax)
 418:	b9 19 00 00 00       	mov    $0x19,%ecx
    pckt->flags |= F_SYN_SET;
 41d:	00 00                	add    %al,(%rax)
 41f:	00 ce                	add    %cl,%dh
 421:	19 00                	sbb    %eax,(%rax)
 423:	00 00                	add    %al,(%rax)
 425:	00 00                	add    %al,(%rax)
      pckt->flow.src = iph->saddr;
 427:	00 42 1a             	add    %al,0x1a(%rdx)
 42a:	00 00                	add    %al,(%rax)
 42c:	00 00                	add    %al,(%rax)
      pckt->flow.dst = iph->daddr;
 42e:	00 00                	add    %al,(%rax)
 430:	71 1a                	jno    44c <balancer_ingress+0x44c>
 432:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 434:	00 00                	add    %al,(%rax)
 436:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 438:	76 1a                	jbe    454 <balancer_ingress+0x454>
 43a:	00 00                	add    %al,(%rax)
 43c:	00 00                	add    %al,(%rax)
 43e:	00 00                	add    %al,(%rax)
 440:	99                   	cltd
 441:	1a 00                	sbb    (%rax),%al
 443:	00 00                	add    %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 445:	00 00                	add    %al,(%rax)
 447:	00 ae 1c 00 00 00    	add    %ch,0x1c(%rsi)
 44d:	00 00                	add    %al,(%rax)
 44f:	00 ef                	add    %ch,%bh
 451:	1c 00                	sbb    $0x0,%al
 453:	00 00                	add    %al,(%rax)
 455:	00 00                	add    %al,(%rax)
 457:	00 af 1d 00 00 00    	add    %ch,0x1d(%rdi)
 45d:	00 00                	add    %al,(%rax)
 45f:	00 c6                	add    %al,%dh
 461:	1d 00 00 00 00       	sbb    $0x0,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 466:	00 00                	add    %al,(%rax)
 468:	cf                   	iret
 469:	1d 00 00 00 00       	sbb    $0x0,%eax
       sizeof(struct icmp6hdr)) > data_end) {
 46e:	00 00                	add    %al,(%rax)
 470:	dc 1d 00 00 00 00    	fcompl 0x0(%rip)        # 476 <balancer_ingress+0x476>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 476:	00 00                	add    %al,(%rax)
 478:	e7 1d                	out    %eax,$0x1d
 47a:	00 00                	add    %al,(%rax)
 47c:	00 00                	add    %al,(%rax)
 47e:	00 00                	add    %al,(%rax)
 480:	f2 1d 00 00 00 00    	repnz sbb $0x0,%eax
 486:	00 00                	add    %al,(%rax)
 488:	21 1e                	and    %ebx,(%rsi)
 48a:	00 00                	add    %al,(%rax)
 48c:	00 00                	add    %al,(%rax)
 48e:	00 00                	add    %al,(%rax)
 490:	2a 1e                	sub    (%rsi),%bl
 492:	00 00                	add    %al,(%rax)
 494:	00 00                	add    %al,(%rax)
 496:	00 00                	add    %al,(%rax)
 498:	33 1e                	xor    (%rsi),%ebx
 49a:	00 00                	add    %al,(%rax)
 49c:	00 00                	add    %al,(%rax)
  tcp = data + off;
 49e:	00 00                	add    %al,(%rax)
 4a0:	3c 1e                	cmp    $0x1e,%al
  if (is_ipv6) {
 4a2:	00 00                	add    %al,(%rax)
  tcp = data + off;
 4a4:	00 00                	add    %al,(%rax)
 4a6:	00 00                	add    %al,(%rax)
  if (tcp + 1 > data_end) {
 4a8:	45 1e                	rex.RB (bad)
 4aa:	00 00                	add    %al,(%rax)
 4ac:	00 00                	add    %al,(%rax)
 4ae:	00 00                	add    %al,(%rax)
 4b0:	4e 1e                	rex.WRX (bad)
 4b2:	00 00                	add    %al,(%rax)
  if (tcp->syn) {
 4b4:	00 00                	add    %al,(%rax)
 4b6:	00 00                	add    %al,(%rax)
 4b8:	55                   	push   %rbp
 4b9:	1e                   	(bad)
 4ba:	00 00                	add    %al,(%rax)
 4bc:	00 00                	add    %al,(%rax)
    pckt->flags |= F_SYN_SET;
 4be:	00 00                	add    %al,(%rax)
 4c0:	58                   	pop    %rax
 4c1:	1e                   	(bad)
 4c2:	00 00                	add    %al,(%rax)
 4c4:	00 00                	add    %al,(%rax)
 4c6:	00 00                	add    %al,(%rax)
 4c8:	71 1e                	jno    4e8 <balancer_ingress+0x4e8>
 4ca:	00 00                	add    %al,(%rax)
 4cc:	00 00                	add    %al,(%rax)
 4ce:	00 00                	add    %al,(%rax)
 4d0:	7a 1e                	jp     4f0 <balancer_ingress+0x4f0>
        bpf_map_lookup_elem(&stats, &stats_key);
 4d2:	00 00                	add    %al,(%rax)
 4d4:	00 00                	add    %al,(%rax)
 4d6:	00 00                	add    %al,(%rax)
 4d8:	83 1e 00             	sbbl   $0x0,(%rsi)
 4db:	00 00                	add    %al,(%rax)
 4dd:	00 00                	add    %al,(%rax)
 4df:	00 8c 1e 00 00 00 00 	add    %cl,0x0(%rsi,%rbx,1)
    if (!icmp_ptb_v6_stats) {
 4e6:	00 00                	add    %al,(%rax)
 4e8:	95                   	xchg   %eax,%ebp
 4e9:	1e                   	(bad)
    icmp_ptb_v6_stats->v1 += 1;
 4ea:	00 00                	add    %al,(%rax)
 4ec:	00 00                	add    %al,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 4ee:	00 00                	add    %al,(%rax)
 4f0:	9e                   	sahf
 4f1:	1e                   	(bad)
 4f2:	00 00                	add    %al,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 4f4:	00 00                	add    %al,(%rax)
 4f6:	00 00                	add    %al,(%rax)
 4f8:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
 4f9:	1e                   	(bad)
 4fa:	00 00                	add    %al,(%rax)
      icmp_ptb_v6_stats->v2 += 1;
 4fc:	00 00                	add    %al,(%rax)
 4fe:	00 00                	add    %al,(%rax)
  if (ip6h + 1 > data_end) {
 500:	1b 1f                	sbb    (%rdi),%ebx
 502:	00 00                	add    %al,(%rax)
 504:	00 00                	add    %al,(%rax)
 506:	00 00                	add    %al,(%rax)
 508:	f2 1e                	repnz (bad)
 50a:	00 00                	add    %al,(%rax)
 50c:	00 00                	add    %al,(%rax)
  pckt->flow.proto = ip6h->nexthdr;
 50e:	00 00                	add    %al,(%rax)
 510:	fa                   	cli
 511:	1e                   	(bad)
 512:	00 00                	add    %al,(%rax)
  pckt->flags |= F_ICMP;
 514:	00 00                	add    %al,(%rax)
 516:	00 00                	add    %al,(%rax)
 518:	57                   	push   %rdi
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 519:	20 00                	and    %al,(%rax)
 51b:	00 00                	add    %al,(%rax)
 51d:	00 00                	add    %al,(%rax)
 51f:	00 77 20             	add    %dh,0x20(%rdi)
 522:	00 00                	add    %al,(%rax)
 524:	00 00                	add    %al,(%rax)
 526:	00 00                	add    %al,(%rax)
 528:	cd 20                	int    $0x20
 52a:	00 00                	add    %al,(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 52c:	00 00                	add    %al,(%rax)
 52e:	00 00                	add    %al,(%rax)
 530:	c4                   	(bad)
 531:	1a 00                	sbb    (%rax),%al
 533:	00 00                	add    %al,(%rax)
 535:	00 00                	add    %al,(%rax)
 537:	00 00                	add    %al,(%rax)
 539:	1b 00                	sbb    (%rax),%eax
 53b:	00 00                	add    %al,(%rax)
 53d:	00 00                	add    %al,(%rax)
 53f:	00 53 1b             	add    %dl,0x1b(%rbx)
 542:	00 00                	add    %al,(%rax)
 544:	00 00                	add    %al,(%rax)
 546:	00 00                	add    %al,(%rax)
 548:	e9 1b 00 00 00       	jmp    568 <balancer_ingress+0x568>
 54d:	00 00                	add    %al,(%rax)
 54f:	00 11                	add    %dl,(%rcx)
 551:	1c 00                	sbb    $0x0,%al
 553:	00 00                	add    %al,(%rax)
 555:	00 00                	add    %al,(%rax)
 557:	00 86 1f 00 00 00    	add    %al,0x1f(%rsi)
 55d:	00 00                	add    %al,(%rax)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 55f:	00 e9                	add    %ch,%cl
 561:	1f                   	(bad)
 562:	00 00                	add    %al,(%rax)
 564:	00 00                	add    %al,(%rax)
 566:	00 00                	add    %al,(%rax)
 568:	f5                   	cmc
 569:	1f                   	(bad)
 56a:	00 00                	add    %al,(%rax)
 56c:	00 00                	add    %al,(%rax)
 56e:	00 00                	add    %al,(%rax)
 570:	87 05 00 00 00 00    	xchg   %eax,0x0(%rip)        # 576 <balancer_ingress+0x576>
 576:	00 00                	add    %al,(%rax)
 578:	0f 06                	clts
 57a:	00 00                	add    %al,(%rax)
 57c:	00 00                	add    %al,(%rax)
 57e:	00 00                	add    %al,(%rax)
 580:	a9 06 00 00 00       	test   $0x6,%eax
 585:	00 00                	add    %al,(%rax)
 587:	00 44 07 00          	add    %al,0x0(%rdi,%rax,1)
  if (decap_dst_flags) {
 58b:	00 00                	add    %al,(%rax)
 58d:	00 00                	add    %al,(%rax)
 58f:	00 a9 08 00 00 00    	add    %ch,0x8(%rcx)
 595:	00 00                	add    %al,(%rax)
 597:	00 d1                	add    %dl,%cl
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 599:	09 00                	or     %eax,(%rax)
 59b:	00 00                	add    %al,(%rax)
 59d:	00 00                	add    %al,(%rax)
 59f:	00 20                	add    %ah,(%rax)
 5a1:	0a 00                	or     (%rax),%al
 5a3:	00 00                	add    %al,(%rax)
 5a5:	00 00                	add    %al,(%rax)
 5a7:	00 be 0a 00 00 00    	add    %bh,0xa(%rsi)
    if (!data_stats) {
 5ad:	00 00                	add    %al,(%rax)
 5af:	00 45 0b             	add    %al,0xb(%rbp)
    data_stats->v1 += 1;
 5b2:	00 00                	add    %al,(%rax)
 5b4:	00 00                	add    %al,(%rax)
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
 5b6:	00 00                	add    %al,(%rax)
 5b8:	13 0c 00             	adc    (%rax,%rax,1),%ecx
 5bb:	00 00                	add    %al,(%rax)
 5bd:	00 00                	add    %al,(%rax)
 5bf:	00 ad 0c 00 00 00    	add    %ch,0xc(%rbp)
 5c5:	00 00                	add    %al,(%rax)
 5c7:	00 93 0d 00 00 00    	add    %dl,0xd(%rbx)
    if (!--ip6h->hop_limit) {
 5cd:	00 00                	add    %al,(%rax)
 5cf:	00 e3                	add    %ah,%bl
 5d1:	0e                   	(bad)
 5d2:	00 00                	add    %al,(%rax)
 5d4:	00 00                	add    %al,(%rax)
 5d6:	00 00                	add    %al,(%rax)
 5d8:	26 10 00             	es adc %al,(%rax)
 5db:	00 00                	add    %al,(%rax)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
 5dd:	00 00                	add    %al,(%rax)
 5df:	00 42 10             	add    %al,0x10(%rdx)
 5e2:	00 00                	add    %al,(%rax)
 5e4:	00 00                	add    %al,(%rax)
 5e6:	00 00                	add    %al,(%rax)
 5e8:	59                   	pop    %rcx
 5e9:	12 00                	adc    (%rax),%al
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 5eb:	00 00                	add    %al,(%rax)
 5ed:	00 00                	add    %al,(%rax)
 5ef:	00 9d 12 00 00 00    	add    %bl,0x12(%rbp)
 5f5:	00 00                	add    %al,(%rax)
 5f7:	00 b0 12 00 00 00    	add    %dh,0x12(%rax)
 5fd:	00 00                	add    %al,(%rax)
 5ff:	00 9d 13 00 00 00    	add    %bl,0x13(%rbp)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
 605:	00 00                	add    %al,(%rax)
 607:	00 d0                	add    %dl,%al
 609:	14 00                	adc    $0x0,%al
 60b:	00 00                	add    %al,(%rax)
 60d:	00 00                	add    %al,(%rax)
 60f:	00 64 16 00          	add    %ah,0x0(%rsi,%rdx,1)
 613:	00 00                	add    %al,(%rax)
 615:	00 00                	add    %al,(%rax)
 617:	00 ac 17 00 00 00 00 	add    %ch,0x0(%rdi,%rdx,1)
 61e:	00 00                	add    %al,(%rax)
 620:	da 18                	ficompl (%rax)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 622:	00 00                	add    %al,(%rax)
 624:	00 00                	add    %al,(%rax)
 626:	00 00                	add    %al,(%rax)
 628:	4b 19 00             	rex.WXB sbb %rax,(%r8)
 62b:	00 00                	add    %al,(%rax)
 62d:	00 00                	add    %al,(%rax)
 62f:	00 63 19             	add    %ah,0x19(%rbx)
  if (!data_stats) {
 632:	00 00                	add    %al,(%rax)
 634:	00 00                	add    %al,(%rax)
 636:	00 00                	add    %al,(%rax)
 638:	fb                   	sti
 639:	19 00                	sbb    %eax,(%rax)
 63b:	00 00                	add    %al,(%rax)
 63d:	00 00                	add    %al,(%rax)
  if (action >= 0) {
 63f:	00 57 1a             	add    %dl,0x1a(%rdi)
 642:	00 00                	add    %al,(%rax)
 644:	00 00                	add    %al,(%rax)
 646:	00 00                	add    %al,(%rax)
 648:	7f 1a                	jg     664 <balancer_ingress+0x664>
 64a:	00 00                	add    %al,(%rax)
  if (decap_dst_flags) {
 64c:	00 00                	add    %al,(%rax)
  if (action >= 0) {
 64e:	00 00                	add    %al,(%rax)
 650:	6a 1b                	push   $0x1b
 652:	00 00                	add    %al,(%rax)
 654:	00 00                	add    %al,(%rax)
 656:	00 00                	add    %al,(%rax)
 658:	13 1d 00 00 00 00    	adc    0x0(%rip),%ebx        # 65e <balancer_ingress+0x65e>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
 65e:	00 00                	add    %al,(%rax)
 660:	90                   	nop
 661:	1f                   	(bad)
 662:	00 00                	add    %al,(%rax)
 664:	00 00                	add    %al,(%rax)
 666:	00 00                	add    %al,(%rax)
 668:	69 20 00 00 00 00    	imul   $0x0,(%rax),%esp
    if (xpop_stats_data) {
 66e:	00 00                	add    %al,(%rax)
 670:	c7                   	(bad)
 671:	21 00                	and    %eax,(%rax)
 673:	00 00                	add    %al,(%rax)
 675:	00 00                	add    %al,(%rax)
 677:	00 5d 22             	add    %bl,0x22(%rbp)
 67a:	00 00                	add    %al,(%rax)
 67c:	00 00                	add    %al,(%rax)
 67e:	00 00                	add    %al,(%rax)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 680:	16                   	(bad)
 681:	23 00                	and    (%rax),%eax
 683:	00 00                	add    %al,(%rax)
 685:	00 00                	add    %al,(%rax)
 687:	00 70 23             	add    %dh,0x23(%rax)
 68a:	00 00                	add    %al,(%rax)
 68c:	00 00                	add    %al,(%rax)
 68e:	00 00                	add    %al,(%rax)
 690:	12 24 00             	adc    (%rax,%rax,1),%ah
 693:	00 00                	add    %al,(%rax)
 695:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_line:

0000000000000000 <.debug_line>:
  void* data = (void*)(long)ctx->data;
       0:	ae                   	scas   %es:(%rdi),%al
       1:	18 00                	sbb    %al,(%rax)
       3:	00 05 00 08 00 2e    	add    %al,0x2e000800(%rip)        # 2e000809 <_license+0x2dffe3dc>
       9:	02 00                	add    (%rax),%al
       b:	00 01                	add    %al,(%rcx)
       d:	01 01                	add    %eax,(%rcx)
       f:	fb                   	sti
      10:	0e                   	(bad)
      11:	0d 00 01 01 01       	or     $0x1010100,%eax
      16:	01 00                	add    %eax,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
      18:	00 00                	add    %al,(%rax)
      1a:	01 00                	add    %eax,(%rax)
  if (data + nh_off > data_end) {
      1c:	00 01                	add    %al,(%rcx)
      1e:	01 01                	add    %eax,(%rcx)
      20:	1f                   	(bad)
      21:	06                   	(bad)
      22:	00 00                	add    %al,(%rax)
      24:	00 00                	add    %al,(%rax)
      26:	2b 00                	sub    (%rax),%eax
      28:	00 00                	add    %al,(%rax)
      2a:	3c 00                	cmp    $0x0,%al
      2c:	00 00                	add    %al,(%rax)
      2e:	55                   	push   %rbp
      2f:	00 00                	add    %al,(%rax)
  eth_proto = eth->h_proto;
      31:	00 68 00             	add    %ch,0x0(%rax)
      34:	00 00                	add    %al,(%rax)
  if (eth_proto == BE_ETH_P_IP) {
      36:	97                   	xchg   %eax,%edi
      37:	00 00                	add    %al,(%rax)
      39:	00 03                	add    %al,(%rbx)
      3b:	01 1f                	add    %ebx,(%rdi)
      3d:	02 0f                	add    (%rdi),%cl
      3f:	05 1e 18 b3 00       	add    $0xb3181e,%eax
      44:	00 00                	add    %al,(%rax)
      46:	00 39                	add    %bh,(%rcx)
      48:	2e 99                	cs cltd
      4a:	fa                   	cli
      4b:	1b 10                	sbb    (%rax),%edx
      4d:	0d 65 32 f5 42       	or     $0x42f53265,%eax
  struct packet_description pckt = {};
      52:	17                   	(bad)
      53:	ea                   	(bad)
      54:	9c                   	pushf
      55:	ae                   	scas   %es:(%rdi),%al
      56:	2f                   	(bad)
      57:	d1 00                	roll   (%rax)
      59:	00 00                	add    %al,(%rax)
      5b:	01 5b e9             	add    %ebx,-0x17(%rbx)
      5e:	d1 d0                	rcl    %eax
      60:	ad                   	lods   %ds:(%rsi),%eax
      61:	34 bd                	xor    $0xbd,%al
      63:	71 a1                	jno    6 <balancer_ingress+0x6>
      65:	66 7a 92             	data16 jp fffffffffffffffa <server_id_map+0x36fcb6d63ffa>
      68:	98                   	cwtl
      69:	70 c0                	jo     2b <balancer_ingress+0x2b>
      6b:	11 e5                	adc    %esp,%ebp
      6d:	00 00                	add    %al,(%rax)
      6f:	00 02                	add    %al,(%rdx)
      71:	b8 10 f2 70 73       	mov    $0x7370f210,%eax
      76:	3e 10 63 19          	ds adc %ah,0x19(%rbx)
      7a:	b6 7e                	mov    $0x7e,%dh
      7c:	f5                   	cmc
      7d:	12 c6                	adc    %dh,%al
      7f:	24 6e                	and    $0x6e,%al
      81:	f0 00 00             	lock add %al,(%rax)
      84:	00 01                	add    %al,(%rcx)
  struct vip_definition vip = {};
      86:	bc 5f e5 9e a4       	mov    $0xa49ee55f,%esp
      8b:	ca 18 d4             	lret   $0xd418
      8e:	61                   	(bad)
      8f:	6a 93                	push   $0xffffffffffffff93
      91:	aa                   	stos   %al,%es:(%rdi)
      92:	35 0e 3d 0b 03       	xor    $0x30b3d0e,%eax
      97:	01 00                	add    %eax,(%rax)
      99:	00 03                	add    %al,(%rbx)
      9b:	c0 ad e1 a1 a3 09 d6 	shrb   $0xd6,0x9a3a1e1(%rbp)
    if (iph + 1 > data_end) {
      a2:	89 6c e6 08          	mov    %ebp,0x8(%rsi,%riz,8)
      a6:	0a 51 a2             	or     -0x5e(%rcx),%dl
      a9:	d1 05 0b 01 00 00    	roll   0x10b(%rip)        # 1ba <balancer_ingress+0x1ba>
    if (iph->ihl != 5) {
      af:	01 b5 26 23 e8 bc    	add    %esi,-0x4317dcda(%rbp)
      b5:	42 2f                	rex.X (bad)
      b7:	8a 08                	mov    (%rax),%cl
    pckt->tos = iph->tos;
      b9:	35 23 90 b1 84       	xor    $0x84b19023,%eax
      be:	d4                   	(bad)
      bf:	30 1b                	xor    %bl,(%rbx)
    *protocol = iph->protocol;
      c1:	01 00                	add    %eax,(%rax)
    pckt->flow.proto = *protocol;
      c3:	00 04 fd 05 b8 e8 10 	add    %al,0x10e8b805(,%rdi,8)
    if (iph->frag_off & PCKT_FRAGMENTED) {
      ca:	6f                   	outsl  %ds:(%rsi),(%dx)
      cb:	04 23                	add    $0x23,%al
      cd:	e1 fb                	loope  ca <balancer_ingress+0xca>
      cf:	dc 35 4a 8e 38 aa    	fdivl  -0x55c771b6(%rip)        # ffffffffaa388f1f <server_id_map+0x36fc610ecf1f>
      d5:	29 01                	sub    %eax,(%rcx)
      d7:	00 00                	add    %al,(%rax)
      d9:	04 1a                	add    $0x1a,%al
    if (*protocol == IPPROTO_ICMP) {
      db:	44 71 1e             	rex.R jno fc <balancer_ingress+0xfc>
      de:	c9                   	leave
      df:	6a fe                	push   $0xfffffffffffffffe
      e1:	11 5d c1             	adc    %ebx,-0x3f(%rbp)
  if (icmp_hdr + 1 > data_end) {
      e4:	30 dc                	xor    %bl,%ah
      e6:	e0 25                	loopne 10d <balancer_ingress+0x10d>
      e8:	7a 60                	jp     14a <balancer_ingress+0x14a>
      ea:	2f                   	(bad)
      eb:	01 00                	add    %eax,(%rax)
      ed:	00 03                	add    %al,(%rbx)
      ef:	fc                   	cld
  if (icmp_hdr->type == ICMP_ECHO) {
      f0:	de 28                	fisubrs (%rax)
      f2:	42 9f                	rex.X lahf
      f4:	cb                   	lret
      f5:	e6 6e                	out    %al,$0x6e
      f7:	10 9e 5f e5 b9 9c    	adc    %bl,-0x63461aa1(%rsi)
      fd:	cd 45                	int    $0x45
      ff:	34 01                	xor    $0x1,%al
     101:	00 00                	add    %al,(%rax)
     103:	03 d2                	add    %edx,%edx
     105:	88 e3                	mov    %ah,%bl
     107:	08 e1                	or     %ah,%cl
     109:	42 e5 1c             	rex.X in $0x1c,%eax
     10c:	48 e7 42             	rex.W out %eax,$0x42
  icmp_hdr->type = ICMP_ECHOREPLY;
     10f:	2f                   	(bad)
     110:	4f bb aa 3f 3b 01 00 	rex.WRXB movabs $0xfc030000013b3faa,%r11
     117:	00 03 fc 
  iph->ttl = DEFAULT_TTL;
     11a:	a1 88 9f 02 74 df 06 	movabs 0x496e06df74029f88,%eax
     121:	6e 49 
  iph->daddr = iph->saddr;
     123:	cf                   	iret
  iph->saddr = tmp_addr;
     124:	4d 8d b8 01 1e 41 01 	lea    0x1411e01(%r8),%r15
     12b:	00 00                	add    %al,(%rax)
     12d:	03 5c 58 d0          	add    -0x30(%rax,%rbx,2),%ebx
     131:	77 e9                	ja     11c <balancer_ingress+0x11c>
     133:	10 b6 c2 58 85 5d    	adc    %dh,0x5d8558c2(%rsi)
     139:	ca 54 d0             	lret   $0xd054
     13c:	ec                   	in     (%dx),%al
     13d:	22 46 01             	and    0x1(%rsi),%al
     140:	00 00                	add    %al,(%rax)
     142:	01 dd                	add    %ebx,%ebp
     144:	5f                   	pop    %rdi
     145:	2d 0c a8 b9 51       	sub    $0x51b9a80c,%eax
     14a:	1e                   	(bad)
     14b:	8f a8 d1 c6          	(bad)
     14f:	4e d3 b3 ac 55 01 00 	rex.WRX shlq %cl,0x155ac(%rbx)
     156:	00 05 02 65 bf 5d    	add    %al,0x5dbf6502(%rip)        # 5dbf665e <_license+0x5dbf4231>
     15c:	da 79 6c             	fidivrl 0x6c(%rcx)
  struct packet_description pckt = {};
     15f:	c0 b0 02 70 b2 7d c7 	shlb   $0xc7,0x7db27002(%rax)
     166:	a1 8e 5d 01 00 00 01 	movabs 0x5c24010000015d8e,%eax
     16d:	24 5c 
     16f:	80 12 ea             	adcb   $0xea,(%rdx)
     172:	92                   	xchg   %eax,%edx
     173:	00 48 b4             	add    %cl,-0x4c(%rax)
     176:	e4 bf                	in     $0xbf,%al
     178:	3b 10                	cmp    (%rax),%edx
     17a:	c5 7e 15             	(bad)
     17d:	6b 01 00             	imul   $0x0,(%rcx),%eax
     180:	00 01                	add    %al,(%rcx)
     182:	f0 b1 d3             	lock mov $0xd3,%cl
     185:	dc 61 ec             	fsubl  -0x14(%rcx)
     188:	02 2c e5 2a 49 e7 c4 	add    -0x3b18b6d6(,%riz,8),%ch
     18f:	a9 2a d6 7a 01       	test   $0x17ad62a,%eax
     194:	00 00                	add    %al,(%rax)
  struct vip_definition vip = {};
     196:	01 75 b7             	add    %esi,-0x49(%rbp)
     199:	ee                   	out    %al,(%dx)
     19a:	85 ad 3d 58 f4 a4    	test   %ebp,-0x5b0ba7c3(%rbp)
     1a0:	79 2b                	jns    1cd <balancer_ingress+0x1cd>
     1a2:	e6 16                	out    %al,$0x16
     1a4:	28 46 ca             	sub    %al,-0x36(%rsi)
     1a7:	8d 01                	lea    (%rcx),%eax
     1a9:	00 00                	add    %al,(%rax)
     1ab:	01 5a 90             	add    %ebx,-0x70(%rdx)
     1ae:	58                   	pop    %rax
    if (ip6h + 1 > data_end) {
     1af:	46 07                	rex.RX (bad)
     1b1:	61                   	(bad)
     1b2:	27                   	(bad)
     1b3:	c3                   	ret
     1b4:	c1 4a e0 0e          	rorl   $0xe,-0x20(%rdx)
     1b8:	b0 62                	mov    $0x62,%al
     1ba:	0c ca                	or     $0xca,%al
    *protocol = ip6h->nexthdr;
     1bc:	9a                   	(bad)
     1bd:	01 00                	add    %eax,(%rax)
    pckt->flow.proto = *protocol;
     1bf:	00 01                	add    %al,(%rcx)
     1c1:	8a eb                	mov    %bl,%ch
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1c3:	55                   	push   %rbp
     1c4:	f9                   	stc
     1c5:	37                   	(bad)
     1c6:	57                   	push   %rdi
     1c7:	66 5e                	pop    %si
     1c9:	31 61 34             	xor    %esp,0x34(%rcx)
     1cc:	d7                   	xlat   %ds:(%rbx)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1cd:	5b                   	pop    %rbx
     1ce:	72 4a                	jb     21a <balancer_ingress+0x21a>
     1d0:	48                   	rex.W
     1d1:	64 01 00             	add    %eax,%fs:(%rax)
     1d4:	00 03                	add    %al,(%rbx)
     1d6:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     1d7:	05 63 28 98 dc       	add    $0xdc982863,%eax
    if (*protocol == IPPROTO_FRAGMENT) {
     1dc:	e5 46                	in     $0x46,%eax
     1de:	63 8b 33 44 62 7d    	movsxd 0x7d624433(%rbx),%ecx
     1e4:	33 4b aa             	xor    -0x56(%rbx),%ecx
     1e7:	01 00                	add    %eax,(%rax)
     1e9:	00 03                	add    %al,(%rbx)
     1eb:	c5 73 77             	(bad)
  if (icmp_hdr + 1 > data_end) {
     1ee:	4d 0b 3c 9a          	or     (%r10,%rbx,4),%r15
     1f2:	61                   	(bad)
     1f3:	b5 51                	mov    $0x51,%ch
     1f5:	0b e7                	or     %edi,%esp
     1f7:	5a                   	pop    %rdx
     1f8:	6f                   	outsl  %ds:(%rsi),(%dx)
     1f9:	f3 74 b3             	repz je 1af <balancer_ingress+0x1af>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1fc:	01 00                	add    %eax,(%rax)
     1fe:	00 03                	add    %al,(%rbx)
     200:	5c                   	pop    %rsp
     201:	57                   	push   %rdi
     202:	70 df                	jo     1e3 <balancer_ingress+0x1e3>
     204:	b5 68                	mov    $0x68,%ch
     206:	97                   	xchg   %eax,%edi
     207:	d0 23                	shlb   (%rbx)
     209:	c1 9c 17 13 f3 42 24 	rcrl   $0xb9,0x2442f313(%rdi,%rdx,1)
     210:	b9 
     211:	01 00                	add    %eax,(%rax)
     213:	00 03                	add    %al,(%rbx)
     215:	16                   	(bad)
     216:	3f                   	(bad)
     217:	54                   	push   %rsp
     218:	fb                   	sti
     219:	1a f2                	sbb    %dl,%dh
     21b:	e2 1f                	loop   23c <balancer_ingress+0x23c>
     21d:	ea                   	(bad)
     21e:	41 0f 14 eb          	unpcklps %xmm11,%xmm5
     222:	18 fa                	sbb    %bh,%dl
     224:	76 c4                	jbe    1ea <balancer_ingress+0x1ea>
     226:	01 00                	add    %eax,(%rax)
     228:	00 03                	add    %al,(%rbx)
     22a:	45 bc 38 cb 16 db    	rex.RB mov $0xdb16cb38,%r12d
     230:	bc 75 84 26 5a       	mov    $0x5a268475,%esp
     235:	fc                   	cld
     236:	29 89 c9 cc 04 00    	sub    %ecx,0x4ccc9(%rcx)
     23c:	00 09                	add    %cl,(%rcx)
     23e:	02 00                	add    (%rax),%al
     240:	00 00                	add    %al,(%rax)
     242:	00 00                	add    %al,(%rax)
     244:	00 00                	add    %al,(%rax)
     246:	00 03                	add    %al,(%rbx)
     248:	b0 08                	mov    $0x8,%al
     24a:	01 05 22 0a 13 05    	add    %eax,0x5130a22(%rip)        # 5130c72 <_license+0x512e845>
     250:	26 08 75 05          	es or  %dh,0x5(%rbp)
     254:	0c 50                	or     $0x50,%al
     256:	05 15 06 90 05       	add    $0x5900615,%eax
     25b:	07                   	(bad)
     25c:	3c 03                	cmp    $0x3,%al
     25e:	c7                   	(bad)
     25f:	77 66                	ja     2c7 <balancer_ingress+0x2c7>
     261:	05 14 06 03 be       	add    $0xbe030614,%eax
     266:	08 3c 05 07 4c 06 03 	or     %bh,0x3064c07(,%rax,1)
     26d:	c0 77 ba 03          	shlb   $0x3,-0x46(%rdi)
     271:	c0 08 58             	rorb   $0x58,(%rax)
     274:	05 1d 06 03 ed       	add    $0xed03061d,%eax
     279:	7c 9e                	jl     219 <balancer_ingress+0x219>
     27b:	05 19 02 36 13       	add    $0x13360219,%eax
     280:	04 0c                	add    $0xc,%al
     282:	05 0d 03 bc 7e       	add    $0x7ebc030d,%eax
     287:	08 90 05 11 06 4a    	or     %dl,0x4a061105(%rax)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     28d:	05 09 3c 05 0e       	add    $0xe053c09,%eax
     292:	06                   	(bad)
     293:	6a 05                	push   $0x5
     295:	12 06                	adc    (%rsi),%al
     297:	4a 05 09 2e 05 16    	rex.WX add $0x16052e09,%rax
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     29d:	06                   	(bad)
     29e:	6b 05 0f 06 3c 05 16 	imul   $0x16,0x53c060f(%rip),%eax        # 53c08b4 <_license+0x53be487>
     2a5:	06                   	(bad)
     2a6:	4b 3d 05 0e 4e 05    	rex.WXB cmp $0x54e0e05,%rax
  if (protocol == IPPROTO_ICMPV6) {
     2ac:	17                   	(bad)
     2ad:	06                   	(bad)
     2ae:	4a 05 09 66 04 00    	rex.WX add $0x46609,%rax
  if (icmp_hdr + 1 > data_end) {
     2b4:	05 00 03 87 7c       	add    $0x7c870300,%eax
     2b9:	66 04 0c             	data16 add $0xc,%al
     2bc:	05 13 06 03 fd       	add    $0xfd030613,%eax
  if (icmp_hdr->type == ICMP_ECHO) {
     2c1:	03 4a 05             	add    0x5(%rdx),%ecx
     2c4:	09 06                	or     %eax,(%rsi)
     2c6:	2e 04 0e             	cs add $0xe,%al
     2c9:	05 10 06 03 9e       	add    $0x9e030610,%eax
     2ce:	7e 66                	jle    336 <balancer_ingress+0x336>
     2d0:	05 14 06 4a 05       	add    $0x54a0614,%eax
     2d5:	07                   	(bad)
     2d6:	3c 05                	cmp    $0x5,%al
     2d8:	11 06                	adc    %eax,(%rsi)
     2da:	69 05 07 06 3c 03 e2 	imul   $0x3907de2,0x33c0607(%rip),%eax        # 33c08eb <_license+0x33be4be>
     2e1:	7d 90 03 
       sizeof(struct icmphdr)) > data_end) {
     2e4:	9e                   	sahf
     2e5:	02 58 03             	add    0x3(%rax),%bl
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2e8:	e2 7d                	loop   367 <balancer_ingress+0x367>
     2ea:	90                   	nop
     2eb:	05 12 06 03 cf       	add    $0xcf030612,%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
     2f0:	00 4a 05             	add    %cl,0x5(%rdx)
  icmp_hdr->checksum += 0x0008;
     2f3:	16                   	(bad)
     2f4:	4e 05 0c 59 05 15    	rex.WRX add $0x1505590c,%rax
  iph->daddr = iph->saddr;
     2fa:	4c 05 13 3b 05 0e    	rex.WR add $0xe053b13,%rax
     300:	3d 3d 04 0f 03       	cmp    $0x30f043d,%eax
  iph->saddr = tmp_addr;
     305:	61                   	(bad)
     306:	3c 05                	cmp    $0x5,%al
     308:	0b 06                	or     (%rsi),%eax
     30a:	08 3c 05 0e 3c 05 0b 	or     %bh,0xb053c0e(,%rax,1)
     311:	3c 05                	cmp    $0x5,%al
     313:	0e                   	(bad)
     314:	3c 05                	cmp    $0x5,%al
     316:	0b 4a 04             	or     0x4(%rdx),%ecx
     319:	00 05 1d 06 03 f5    	add    %al,-0xafcf9e3(%rip)        # fffffffff503093c <server_id_map+0x36fcabd9493c>
     31f:	04 08                	add    $0x8,%al
     321:	66 05 19 02          	add    $0x219,%ax
     325:	36 13 04 0c          	ss adc (%rsp,%rcx,1),%eax
     329:	05 0e 03 a3 7e       	add    $0x7ea3030e,%eax
     32e:	08 90 05 12 06 4a    	or     %dl,0x4a061205(%rax)
     334:	05 09 3c 05 17       	add    $0x17053c09,%eax
     339:	06                   	(bad)
     33a:	6b 05 16 3d 05 18 4d 	imul   $0x4d,0x18053d16(%rip),%eax        # 18054057 <_license+0x18051c2a>
     341:	05 21 06 3c 05       	add    $0x53c0621,%eax
     346:	0f 3c                	(bad)
     348:	05 1f 06 4b 05       	add    $0x54b061f,%eax
     34d:	1b 06                	sbb    (%rsi),%eax
     34f:	3c 05                	cmp    $0x5,%al
     351:	0f 58 05 09 06 4e 05 	addps  0x54e0609(%rip),%xmm0        # 54e0961 <_license+0x54de534>
     358:	00 06                	add    %al,(%rsi)
     35a:	03 a1 7c 82 05 09    	add    0x905827c(%rcx),%esp
     360:	03 df                	add    %edi,%ebx
     362:	03 4a 04             	add    0x4(%rdx),%ecx
     365:	0e                   	(bad)
     366:	05 10 06 03 8d       	add    $0x8d030610,%eax
     36b:	7e 82                	jle    2ef <balancer_ingress+0x2ef>
     36d:	05 14 06 4a 05       	add    $0x54a0614,%eax
     372:	07                   	(bad)
     373:	3c 05                	cmp    $0x5,%al
     375:	11 06                	adc    %eax,(%rsi)
     377:	69 05 07 06 3c 03 91 	imul   $0x3f27e91,0x33c0607(%rip),%eax        # 33c0988 <_license+0x33be55b>
     37e:	7e f2 03 
     381:	ef                   	out    %eax,(%dx)
     382:	01 58 04             	add    %ebx,0x4(%rax)
     385:	00 05 00 03 91 7e    	add    %al,0x7e910300(%rip)        # 7e91068b <_license+0x7e90e25e>
     38b:	82                   	(bad)
     38c:	04 0c                	add    $0xc,%al
     38e:	05 07 06 03 e5       	add    $0xe5030607,%eax
     393:	03 02                	add    (%rdx),%eax
     395:	6e                   	outsb  %ds:(%rsi),(%dx)
     396:	01 08                	add    %ecx,(%rax)
     398:	21 04 0e             	and    %eax,(%rsi,%rcx,1)
     39b:	03 f3                	add    %ebx,%esi
     39d:	7e 08                	jle    3a7 <balancer_ingress+0x3a7>
     39f:	20 05 10 03 42 82    	and    %al,-0x7dbdfcf0(%rip)        # ffffffff824206b5 <server_id_map+0x36fc391846b5>
     3a5:	05 14 06 4a 05       	add    $0x54a0614,%eax
     3aa:	07                   	(bad)
     3ab:	3c 05                	cmp    $0x5,%al
     3ad:	11 06                	adc    %eax,(%rsi)
     3af:	69 05 07 06 3c 03 e2 	imul   $0x3907de2,0x33c0607(%rip),%eax        # 33c09c0 <_license+0x33be593>
     3b6:	7d 90 03 
     3b9:	9e                   	sahf
     3ba:	02 58 05             	add    0x5(%rax),%bl
     3bd:	3c 06                	cmp    $0x6,%al
     3bf:	03 a9 7e 90 05 20    	add    0x2005907e(%rcx),%ebp
     3c5:	91                   	xchg   %eax,%ecx
     3c6:	05 07 3b 05 12       	add    $0x12053b07,%eax
     3cb:	6e                   	outsb  %ds:(%rsi),(%dx)
     3cc:	05 16 4e 05 0c       	add    $0xc054e16,%eax
     3d1:	59                   	pop    %rcx
     3d2:	05 15 4c 05 13       	add    $0x13054c15,%eax
     3d7:	3b 05 0e 3d 3d 04    	cmp    0x43d3d0e(%rip),%eax        # 43d40eb <_license+0x43d1cbe>
     3dd:	0f 03 61 3c          	lsl    0x3c(%rcx),%esp
     3e1:	05 0b 06 08 ba       	add    $0xba08060b,%eax
  if (protocol == IPPROTO_IPIP) {
     3e6:	05 0e 3c 05 0b       	add    $0xb053c0e,%eax
     3eb:	3c 05                	cmp    $0x5,%al
     3ed:	0e                   	(bad)
     3ee:	3c 05                	cmp    $0x5,%al
     3f0:	0b 4a 04             	or     0x4(%rdx),%ecx
     3f3:	00 05 00 03 48 08    	add    %al,0x8480300(%rip)        # 84806f9 <_license+0x847e2cc>
     3f9:	20 05 07 06 03 df    	and    %al,-0x20fcf9f9(%rip)        # ffffffffdf030a06 <server_id_map+0x36fc95d94a06>
  tcp = data + off;
     3ff:	05 02 a2 01 01       	add    $0x101a202,%eax
     404:	04 0c                	add    $0xc,%al
  if (tcp + 1 > data_end) {
     406:	05 0e 03 9e 7b       	add    $0x7b9e030e,%eax
     40b:	08 74 05 07          	or     %dh,0x7(%rbp,%rax,1)
     40f:	03 50 4a             	add    0x4a(%rax),%edx
     412:	05 0e 03 30 2e       	add    $0x2e30030e,%eax
  if (tcp->syn) {
     417:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
     41c:	06                   	(bad)
    pckt->flags |= F_SYN_SET;
     41d:	4a 05 07 3c 06 6a    	rex.WX add $0x6a063c07,%rax
     423:	06                   	(bad)
     424:	4a 05 11 06 67 05    	rex.WX add $0x5670611,%rax
      pckt->flow.src = iph->saddr;
     42a:	1d 03 fc 02 90       	sbb    $0x9002fc03,%eax
      pckt->flow.dst = iph->daddr;
     42f:	05 16 06 3c 05       	add    $0x53c0616,%eax
  if (protocol == IPPROTO_ICMPV6) {
     434:	1d 06 4b 05 16       	sbb    $0x16054b06,%eax
  if (icmp_hdr + 1 > data_end) {
     439:	06                   	(bad)
     43a:	3c 04                	cmp    $0x4,%al
     43c:	0e                   	(bad)
     43d:	05 07 06 03 d8       	add    $0xd8030607,%eax
     442:	7e 4a                	jle    48e <balancer_ingress+0x48e>
     444:	05 10 03 93 7f       	add    $0x7f930310,%eax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     449:	4a 05 14 06 4a 05    	rex.WX add $0x54a0614,%rax
     44f:	07                   	(bad)
     450:	3c 05                	cmp    $0x5,%al
     452:	11 06                	adc    %eax,(%rsi)
     454:	69 05 07 06 3c 03 91 	imul   $0x3f27e91,0x33c0607(%rip),%eax        # 33c0a65 <_license+0x33be638>
     45b:	7e f2 03 
     45e:	ef                   	out    %eax,(%dx)
     45f:	01 58 05             	add    %ebx,0x5(%rax)
     462:	3e 06                	ds (bad)
     464:	03 f6                	add    %esi,%esi
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     466:	7e 82                	jle    3ea <balancer_ingress+0x3ea>
     468:	05 21 91 05 07       	add    $0x7059121,%eax
     46d:	3b 06                	cmp    (%rsi),%eax
       sizeof(struct icmp6hdr)) > data_end) {
     46f:	03 9b 7f ac 04 00    	add    0x4ac7f(%rbx),%ebx
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     475:	06                   	(bad)
     476:	03 df                	add    %edi,%ebx
     478:	05 90 04 0c 05       	add    $0x50c0490,%eax
     47d:	0e                   	(bad)
     47e:	03 9e 7b 08 74 05    	add    0x574087b(%rsi),%ebx
     484:	07                   	(bad)
     485:	03 50 4a             	add    0x4a(%rax),%edx
     488:	05 0e 03 30 2e       	add    $0x2e30030e,%eax
     48d:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
     492:	06                   	(bad)
     493:	4a 05 07 3c 06 6a    	rex.WX add $0x6a063c07,%rax
     499:	06                   	(bad)
     49a:	4a 05 11 06 67 06    	rex.WX add $0x6670611,%rax
  tcp = data + off;
     4a0:	03 fc                	add    %esp,%edi
  if (is_ipv6) {
     4a2:	7e 90                	jle    434 <balancer_ingress+0x434>
  tcp = data + off;
     4a4:	04 0e                	add    $0xe,%al
     4a6:	05 09 06 03 fa       	add    $0xfa030609,%eax
  if (tcp + 1 > data_end) {
     4ab:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
     4b1:	09 06                	or     %eax,(%rsi)
     4b3:	3c 05                	cmp    $0x5,%al
  if (tcp->syn) {
     4b5:	1b 06                	sbb    (%rsi),%eax
     4b7:	69 05 11 4b 05 0d 59 	imul   $0x6090559,0xd054b11(%rip),%eax        # d054fd2 <_license+0xd052ba5>
     4be:	05 09 06 
    pckt->flags |= F_SYN_SET;
     4c1:	66 05 1d 06          	add    $0x61d,%ax
     4c5:	2f                   	(bad)
     4c6:	05 0c 60 05 10       	add    $0x1005600c,%eax
     4cb:	06                   	(bad)
     4cc:	4a 05 07 3c 05 1c    	rex.WX add $0x1c053c07,%rax
        bpf_map_lookup_elem(&stats, &stats_key);
     4d2:	06                   	(bad)
     4d3:	69 05 14 06 3c 05 0f 	imul   $0x54b060f,0x53c0614(%rip),%eax        # 53c0af1 <_license+0x53be6c4>
     4da:	06 4b 05 
     4dd:	03 59 08             	add    0x8(%rcx),%ebx
     4e0:	21 06                	and    %eax,(%rsi)
    if (!icmp_ptb_v6_stats) {
     4e2:	03 f1                	add    %ecx,%esi
     4e4:	7d 08                	jge    4ee <balancer_ingress+0x4ee>
     4e6:	20 04 00             	and    %al,(%rax,%rax,1)
     4e9:	05 07 06 03 df       	add    $0xdf030607,%eax
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4ee:	05 90 05 05 03       	add    $0x3050590,%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     4f3:	f2 7b 08             	bnd jnp 4fe <balancer_ingress+0x4fe>
     4f6:	74 04                	je     4fc <balancer_ingress+0x4fc>
     4f8:	06                   	(bad)
     4f9:	05 01 03 c9 01       	add    $0x1c90301,%eax
      icmp_ptb_v6_stats->v2 += 1;
     4fe:	08 3c 04             	or     %bh,(%rsp,%rax,1)
  if (ip6h + 1 > data_end) {
     501:	00 05 07 03 bd 7e    	add    %al,0x7ebd0307(%rip)        # 7ebd080e <_license+0x7ebce3e1>
     507:	08 74 06 3c          	or     %dh,0x3c(%rsi,%rax,1)
     50b:	03 a9 7e 2e 05 12    	add    0x12052e7e(%rcx),%ebp
  pckt->flow.proto = ip6h->nexthdr;
     511:	06                   	(bad)
     512:	03 da                	add    %edx,%ebx
  pckt->flags |= F_ICMP;
     514:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     51a:	09 06                	or     %eax,(%rsi)
     51c:	3c 05                	cmp    $0x5,%al
     51e:	14 06                	adc    $0x6,%al
     520:	69 04 10 05 18 03 fc 	imul   $0xfc031805,(%rax,%rdx,1),%eax
     527:	7e 4a                	jle    573 <balancer_ingress+0x573>
     529:	05 32 06 e4 05       	add    $0x5e40632,%eax
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     52e:	09 3c 05 0a 06 32 05 	or     %edi,0x532060a(,%rax,1)
     535:	09 06                	or     %eax,(%rsi)
     537:	e4 04                	in     $0x4,%al
     539:	11 05 03 06 03 24    	adc    %eax,0x24030603(%rip)        # 24030b42 <_license+0x2402e715>
     53f:	4a d7                	rex.WX xlat %ds:(%rbx)
     541:	05 00 06 03 fd       	add    $0xfd030600,%eax
     546:	7e c8                	jle    510 <balancer_ingress+0x510>
     548:	05 07 06 03 89       	add    $0x89030607,%eax
     54d:	01 c8                	add    %ecx,%eax
     54f:	06                   	(bad)
     550:	ba 03 f7 7e 66       	mov    $0x667ef703,%edx
     555:	04 00                	add    $0x0,%al
     557:	05 21 06 03 d6       	add    $0xd6030621,%eax
     55c:	02 9e 05 08 f3 05    	add    0x5f30805(%rsi),%bl
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     562:	07                   	(bad)
     563:	06                   	(bad)
     564:	3c 05                	cmp    $0x5,%al
     566:	00 03                	add    %al,(%rbx)
     568:	a9 7d 66 05 0e       	test   $0xe05667d,%eax
     56d:	06                   	(bad)
     56e:	03 df                	add    %edi,%ebx
     570:	02 58 05             	add    0x5(%rax),%bl
     573:	07                   	(bad)
     574:	06                   	(bad)
     575:	82                   	(bad)
     576:	06                   	(bad)
     577:	03 f8                	add    %eax,%edi
     579:	7e 4a                	jle    5c5 <balancer_ingress+0x5c5>
     57b:	03 88 01 3c 05 09    	add    0x9053c01(%rax),%ecx
     581:	03 0b                	add    (%rbx),%ecx
     583:	e4 f3                	in     $0xf3,%al
     585:	06                   	(bad)
     586:	3c 05                	cmp    $0x5,%al
     588:	00 03                	add    %al,(%rbx)
  if (decap_dst_flags) {
     58a:	95                   	xchg   %eax,%ebp
     58b:	7d 66                	jge    5f3 <balancer_ingress+0x5f3>
     58d:	05 05 06 03 d1       	add    $0xd1030605,%eax
     592:	01 9e 04 06 05 01    	add    %ebx,0x1050604(%rsi)
     598:	03 c9                	add    %ecx,%ecx
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     59a:	01 08                	add    %ecx,(%rax)
     59c:	3c 04                	cmp    $0x4,%al
     59e:	00 05 07 03 bd 7e    	add    %al,0x7ebd0307(%rip)        # 7ebd08ab <_license+0x7ebce47e>
     5a4:	08 74 06 3c          	or     %dh,0x3c(%rsi,%rax,1)
     5a8:	03 a9 7e 2e 05 12    	add    0x12052e7e(%rcx),%ebp
    if (!data_stats) {
     5ae:	06                   	(bad)
     5af:	03 da                	add    %edx,%ebx
     5b1:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5b7:	09 06                	or     %eax,(%rsi)
     5b9:	3c 05                	cmp    $0x5,%al
     5bb:	14 06                	adc    $0x6,%al
     5bd:	69 04 10 05 18 03 85 	imul   $0x85031805,(%rax,%rdx,1),%eax
     5c4:	7f 4a                	jg     610 <balancer_ingress+0x610>
     5c6:	05 30 06 e4 05       	add    $0x5e40630,%eax
    if (!--ip6h->hop_limit) {
     5cb:	09 3c 05 11 06 33 05 	or     %edi,0x5330611(,%rax,1)
     5d2:	17                   	(bad)
     5d3:	06                   	(bad)
     5d4:	4a 05 2a 06 3d 05    	rex.WX add $0x53d062a,%rax
     5da:	22 06                	and    (%rsi),%al
     5dc:	3c 05                	cmp    $0x5,%al
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5de:	10 58 05             	adc    %bl,0x5(%rax)
     5e1:	0a 06                	or     (%rsi),%al
     5e3:	4b 04 11             	rex.WXB add $0x11,%al
     5e6:	05 03 03 18 08       	add    $0x8180303,%eax
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     5eb:	2e d7                	xlat   %ds:(%rbx)
     5ed:	05 00 06 03 fd       	add    $0xfd030600,%eax
     5f2:	7e c8                	jle    5bc <balancer_ingress+0x5bc>
     5f4:	05 07 06 03 89       	add    $0x89030607,%eax
     5f9:	01 c8                	add    %ecx,%eax
     5fb:	06                   	(bad)
     5fc:	ba 03 f7 7e 66       	mov    $0x667ef703,%edx
     601:	04 00                	add    $0x0,%al
     603:	05 21 06 03 d6       	add    $0xd6030621,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     608:	02 9e 05 08 f3 05    	add    0x5f30805(%rsi),%bl
     60e:	07                   	(bad)
     60f:	06                   	(bad)
     610:	3c 05                	cmp    $0x5,%al
     612:	00 03                	add    %al,(%rbx)
     614:	a9 7d 66 05 0e       	test   $0xe05667d,%eax
     619:	06                   	(bad)
     61a:	03 df                	add    %edi,%ebx
     61c:	02 58 05             	add    0x5(%rax),%bl
     61f:	07                   	(bad)
     620:	06                   	(bad)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     621:	82                   	(bad)
     622:	06                   	(bad)
     623:	03 f8                	add    %eax,%edi
     625:	7e 4a                	jle    671 <balancer_ingress+0x671>
     627:	03 88 01 3c 05 09    	add    0x9053c01(%rax),%ecx
     62d:	03 0b                	add    (%rbx),%ecx
     62f:	e4 f3                	in     $0xf3,%al
  if (!data_stats) {
     631:	04 0c                	add    $0xc,%al
     633:	05 0e 03 f8 7d       	add    $0x7df8030e,%eax
     638:	d6                   	(bad)
     639:	05 07 03 6a 4a       	add    $0x4a6a0307,%eax
     63e:	05 0e 03 16 2e       	add    $0x2e16030e,%eax
  if (action >= 0) {
     643:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
     648:	06                   	(bad)
     649:	4a 05 07 3c 04 00    	rex.WX add $0x43c07,%rax
     64f:	05 00 03 9b 7f       	add    $0x7f9b0300,%eax
     654:	66 04 0e             	data16 add $0xe,%al
     657:	05 16 06 03 a5       	add    $0xa5030616,%eax
     65c:	02 08                	add    (%rax),%cl
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     65e:	d6                   	(bad)
     65f:	05 07 06 4a 03       	add    $0x34a0607,%eax
     664:	db 7d 2e             	fstpt  0x2e(%rbp)
     667:	05 09 06 03 a8       	add    $0xa8030609,%eax
     66c:	02 9e 05 0a f3 05    	add    0x5f30a05(%rsi),%bl
    if (xpop_stats_data) {
     672:	09 06                	or     %eax,(%rsi)
     674:	3c 05                	cmp    $0x5,%al
     676:	1b 06                	sbb    (%rsi),%eax
     678:	69 05 0d 4c 05 09 06 	imul   $0x1d054a06,0x9054c0d(%rip),%eax        # 905528f <_license+0x9052e62>
     67f:	4a 05 1d 
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     682:	06                   	(bad)
     683:	2f                   	(bad)
     684:	05 0b 5e 05 0f       	add    $0xf055e0b,%eax
     689:	06                   	(bad)
     68a:	4a 05 07 3c 05 0c    	rex.WX add $0xc053c07,%rax
     690:	06                   	(bad)
     691:	69 05 10 06 4a 05 07 	imul   $0x1b052e07,0x54a0610(%rip),%eax        # 54a0cab <_license+0x549e87e>
     698:	2e 05 1b 
     69b:	06                   	(bad)
     69c:	69 05 14 06 3c 05 0f 	imul   $0x54b060f,0x53c0614(%rip),%eax        # 53c0cba <_license+0x53be88d>
     6a3:	06 4b 05 
     6a6:	19 59 05             	sbb    %ebx,0x5(%rcx)
     6a9:	12 06                	adc    (%rsi),%al
     6ab:	3c 05                	cmp    $0x5,%al
  if (decap_dst_flags) {
     6ad:	19 06                	sbb    %eax,(%rsi)
     6af:	4b 05 12 06 3c 04    	rex.WXB add $0x43c0612,%rax
     6b5:	00 05 00 03 c2 7d    	add    %al,0x7dc20300(%rip)        # 7dc209bb <_license+0x7dc1e58e>
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     6bb:	90                   	nop
     6bc:	05 05 06 03 8b       	add    $0x8b030605,%eax
     6c1:	06                   	(bad)
     6c2:	08 4a 05             	or     %cl,0x5(%rdx)
     6c5:	0e                   	(bad)
     6c6:	08 41 05             	or     %al,0x5(%rcx)
     6c9:	0c 06                	or     $0x6,%al
    if (!data_stats) {
     6cb:	58                   	pop    %rax
     6cc:	05 19 06 59 05       	add    $0x5590619,%eax
     6d1:	0d 06 4a 04 06       	or     $0x6044a06,%eax
    data_stats->v1 += 1;
     6d6:	05 01 06 03 89       	add    $0x89030601,%eax
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     6db:	7d 4a                	jge    727 <balancer_ingress+0x727>
     6dd:	04 00                	add    $0x0,%al
     6df:	05 08 03 f9 02       	add    $0x2f90308,%eax
     6e4:	08 9e 05 07 06 3c    	or     %bl,0x3c060705(%rsi)
     6ea:	05 10 06 03 0f       	add    $0xf030610,%eax
    csum = iph->check + 0x0001;
     6ef:	66 05 17 06          	add    $0x617,%ax
    iph->check = (csum & 0xffff) + (csum >> 16);
     6f3:	66 05 07 66          	add    $0x6607,%ax
     6f7:	03 de                	add    %esi,%ebx
     6f9:	79 66                	jns    761 <balancer_ingress+0x761>
     6fb:	05 10 06 03 b6       	add    $0xb6030610,%eax
    if (!--iph->ttl) {
     700:	06                   	(bad)
     701:	9e                   	sahf
     702:	05 08 f3 05 07       	add    $0x705f308,%eax
     707:	06                   	(bad)
     708:	3c 05                	cmp    $0x5,%al
     70a:	12 06                	adc    (%rsi),%al
     70c:	6b 05 18 4c 05 07 06 	imul   $0x6,0x7054c18(%rip),%eax        # 705532b <_license+0x7052efe>
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     713:	3c 05                	cmp    $0x5,%al
     715:	19 06                	sbb    %eax,(%rsi)
     717:	31 05 17 77 05 13    	xor    %eax,0x13057717(%rip)        # 13057e34 <_license+0x13055a07>
     71d:	9f                   	lahf
     71e:	bb 06 58 05 22       	mov    $0x22055806,%ebx
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     723:	06                   	(bad)
     724:	6a 05                	push   $0x5
     726:	0a f3                	or     %bl,%dh
     728:	05 09 06 3c 05       	add    $0x53c0609,%eax
     72d:	13 06                	adc    (%rsi),%eax
     72f:	6c                   	insb   (%dx),%es:(%rdi)
     730:	06                   	(bad)
     731:	03 af 79 d6 04 0e    	add    0xe04d679(%rdi),%ebp
     737:	05 16 06 03 a5       	add    $0xa5030616,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     73c:	02 9e 05 07 06 4a    	add    0x4a060705(%rsi),%bl
     742:	03 db                	add    %ebx,%ebx
     744:	7d 2e                	jge    774 <balancer_ingress+0x774>
     746:	05 09 06 03 a8       	add    $0xa8030609,%eax
     74b:	02 9e 05 0a f3 05    	add    0x5f30a05(%rsi),%bl
     751:	09 06                	or     %eax,(%rsi)
     753:	3c 05                	cmp    $0x5,%al
     755:	1b 06                	sbb    (%rsi),%eax
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     757:	69 05 0d 4c 05 09 06 	imul   $0x1d054a06,0x9054c0d(%rip),%eax        # 905536e <_license+0x9052f41>
     75e:	4a 05 1d 
     761:	06                   	(bad)
     762:	2f                   	(bad)
     763:	05 0b 5e 05 0f       	add    $0xf055e0b,%eax
  if (!data_stats) {
     768:	06                   	(bad)
     769:	4a 05 07 3c 05 0c    	rex.WX add $0xc053c07,%rax
     76f:	06                   	(bad)
     770:	69 05 10 06 4a 05 07 	imul   $0x1b052e07,0x54a0610(%rip),%eax        # 54a0d8a <_license+0x549e95d>
     777:	2e 05 1b 
  if (action >= 0) {
     77a:	06                   	(bad)
     77b:	69 05 14 06 3c 05 0f 	imul   $0x54b060f,0x53c0614(%rip),%eax        # 53c0d99 <_license+0x53be96c>
     782:	06 4b 05 
     785:	19 59 05             	sbb    %ebx,0x5(%rcx)
     788:	12 06                	adc    (%rsi),%al
     78a:	3c 05                	cmp    $0x5,%al
     78c:	19 06                	sbb    %eax,(%rsi)
     78e:	4b 05 12 06 3c 04    	rex.WXB add $0x43c0612,%rax
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     794:	00 05 0e 06 03 d6    	add    %al,-0x29fcf9f2(%rip)        # ffffffffd6030da8 <server_id_map+0x36fc8cd94da8>
     79a:	03 90 04 06 05 01    	add    0x1050604(%rax),%edx
     7a0:	03 86 7d 74 04 00    	add    0x4747d(%rsi),%eax
    if (xpop_stats_data) {
     7a6:	05 0a 03 fc 02       	add    $0x2fc030a,%eax
     7ab:	d6                   	(bad)
     7ac:	05 09 06 3c 05       	add    $0x53c0609,%eax
  udp = data + off;
     7b1:	00 03                	add    %al,(%rbx)
     7b3:	ea                   	(bad)
  if (is_ipv6) {
     7b4:	79 66                	jns    81c <balancer_ingress+0x81c>
  udp = data + off;
     7b6:	05 30 06 03 9a       	add    $0x9a030630,%eax
  if (udp + 1 > data_end) {
     7bb:	06                   	(bad)
     7bc:	3c 05                	cmp    $0x5,%al
     7be:	1b 94 05 12 03 ae 7b 	sbb    0x7bae0312(%rbp,%rax,1),%edx
     7c5:	ba 05 20 08 19       	mov    $0x19082005,%edx
     7ca:	05 13 06 4a 04       	add    $0x44a0613,%eax
     7cf:	06                   	(bad)
     7d0:	05 01 06 03 c7       	add    $0xc7030601,%eax
     7d5:	01 4a 04             	add    %ecx,0x4(%rdx)
     7d8:	00 05 07 03 bd 7e    	add    %al,0x7ebd0307(%rip)        # 7ebd0ae5 <_license+0x7ebce6b8>
     7de:	08 74 06 3c          	or     %dh,0x3c(%rsi,%rax,1)
     7e2:	03 a9 7e 2e 05 12    	add    0x12052e7e(%rcx),%ebp
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     7e8:	06                   	(bad)
     7e9:	03 da                	add    %edx,%ebx
     7eb:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
     7f1:	09 06                	or     %eax,(%rsi)
     7f3:	3c 05                	cmp    $0x5,%al
     7f5:	14 06                	adc    $0x6,%al
        bpf_map_lookup_elem(&stats, &stats_key);
     7f7:	69 05 00 06 03 a2 7e 	imul   $0x10044a7e,-0x5dfcfa00(%rip),%eax        # ffffffffa2030e01 <server_id_map+0x36fc58d94e01>
     7fe:	4a 04 10 
     801:	05 18 06 03 e3       	add    $0xe3030618,%eax
    if (!icmp_ptb_v4_stats) {
     806:	00 4a 05             	add    %cl,0x5(%rdx)
     809:	30 06                	xor    %al,(%rsi)
     80b:	e4 05                	in     $0x5,%al
     80d:	09 3c 05 11 06 33 05 	or     %edi,0x5330611(,%rax,1)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     814:	17                   	(bad)
     815:	06                   	(bad)
     816:	4a 05 2a 06 3d 05    	rex.WX add $0x53d062a,%rax
      icmp_ptb_v4_stats->v2 += 1;
     81c:	22 06                	and    (%rsi),%al
  if (iph + 1 > data_end) {
     81e:	3c 05                	cmp    $0x5,%al
     820:	10 58 05             	adc    %bl,0x5(%rax)
     823:	0a 06                	or     (%rsi),%al
     825:	4b 04 11             	rex.WXB add $0x11,%al
     828:	05 03 03 2d 08       	add    $0x82d0303,%eax
  if (iph->ihl != 5) {
     82d:	2e d7                	xlat   %ds:(%rbx)
     82f:	05 14 bb 05 07       	add    $0x705bb14,%eax
     834:	c9                   	leave
     835:	06                   	(bad)
     836:	ba 03 e6 7e 66       	mov    $0x667ee603,%edx
  pckt->flow.proto = iph->protocol;
     83b:	04 00                	add    $0x0,%al
     83d:	05 21 06 03 d6       	add    $0xd6030621,%eax
  pckt->flags |= F_ICMP;
     842:	02 9e 05 08 f3 05    	add    0x5f30805(%rsi),%bl
  pckt->flow.src = iph->daddr;
     848:	07                   	(bad)
     849:	06                   	(bad)
  pckt->flow.dst = iph->saddr;
     84a:	3c 05                	cmp    $0x5,%al
     84c:	00 03                	add    %al,(%rbx)
     84e:	a9 7d 66 05 0e       	test   $0xe05667d,%eax
     853:	06                   	(bad)
     854:	03 df                	add    %edi,%ebx
     856:	02 58 05             	add    0x5(%rax),%bl
     859:	07                   	(bad)
     85a:	06                   	(bad)
     85b:	82                   	(bad)
     85c:	06                   	(bad)
     85d:	03 f8                	add    %eax,%edi
     85f:	7e 4a                	jle    8ab <balancer_ingress+0x8ab>
     861:	03 88 01 3c 05 09    	add    0x9053c01(%rax),%ecx
     867:	03 0b                	add    (%rbx),%ecx
     869:	e4 f3                	in     $0xf3,%al
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     86b:	06                   	(bad)
     86c:	3c 05                	cmp    $0x5,%al
     86e:	00 03                	add    %al,(%rbx)
     870:	95                   	xchg   %eax,%ebp
     871:	7d 2e                	jge    8a1 <balancer_ingress+0x8a1>
     873:	04 0e                	add    $0xe,%al
     875:	05 09 06 03 fa       	add    $0xfa030609,%eax
     87a:	01 02                	add    %eax,(%rdx)
     87c:	35 01 05 0a f3       	xor    $0xf30a0501,%eax
  vip.port = pckt.flow.port16[1];
     881:	05 09 06 3c 05       	add    $0x53c0609,%eax
     886:	1b 06                	sbb    (%rsi),%eax
     888:	69 05 11 4b 05 0d 59 	imul   $0x6090559,0xd054b11(%rip),%eax        # d0553a3 <_license+0xd052f76>
     88f:	05 09 06 
     892:	66 05 1d 06          	add    $0x61d,%ax
     896:	2f                   	(bad)
     897:	05 0c 60 05 10       	add    $0x1005600c,%eax
     89c:	06                   	(bad)
     89d:	4a 05 07 3c 04 00    	rex.WX add $0x43c07,%rax
     8a3:	05 00 03 f7 7d       	add    $0x7df70300,%eax
     8a8:	66 04 0e             	data16 add $0xe,%al
     8ab:	05 1c 06 03 8c       	add    $0x8c03061c,%eax
  if (!vip_info) {
     8b0:	02 58 05             	add    0x5(%rax),%bl
     8b3:	14 06                	adc    $0x6,%al
  if (data_end - data > MAX_PCKT_SIZE) {
     8b5:	3c 05                	cmp    $0x5,%al
     8b7:	0f 06                	clts
     8b9:	4b 05 03 59 08 21    	rex.WXB add $0x21085903,%rax
     8bf:	06                   	(bad)
     8c0:	03 f1                	add    %ecx,%esi
     8c2:	7d e4                	jge    8a8 <balancer_ingress+0x8a8>
     8c4:	04 00                	add    $0x0,%al
     8c6:	05 07 06 03 df       	add    $0xdf030607,%eax
     8cb:	05 90 05 12 03       	add    $0x3120590,%eax
     8d0:	ed                   	in     (%dx),%eax
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8d1:	7b 08                	jnp    8db <balancer_ingress+0x8db>
     8d3:	74 05                	je     8da <balancer_ingress+0x8da>
     8d5:	20 08                	and    %cl,(%rax)
     8d7:	19 05 13 06 4a 04    	sbb    %eax,0x44a0613(%rip)        # 44a0ef0 <_license+0x449eac3>
     8dd:	06                   	(bad)
     8de:	05 01 06 03 c7       	add    $0xc7030601,%eax
  if (!data_stats) {
     8e3:	01 4a 04             	add    %ecx,0x4(%rdx)
     8e6:	00 05 07 03 bd 7e    	add    %al,0x7ebd0307(%rip)        # 7ebd0bf3 <_license+0x7ebce7c6>
  data_stats->v1 += 1;
     8ec:	08 74 06 3c          	or     %dh,0x3c(%rsi,%rax,1)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     8f0:	03 a9 7e 2e 05 12    	add    0x12052e7e(%rcx),%ebp
    pckt.flow.port16[0] = 0;
     8f6:	06                   	(bad)
     8f7:	03 da                	add    %edx,%ebx
     8f9:	01 9e 05 0a f3 05    	add    %ebx,0x5f30a05(%rsi)
  vip_num = vip_info->vip_num;
     8ff:	09 06                	or     %eax,(%rsi)
     901:	3c 05                	cmp    $0x5,%al
     903:	14 06                	adc    $0x6,%al
  __u32 cpu_num = bpf_get_smp_processor_id();
     905:	69 05 10 03 ee 00 4a 	imul   $0x61a054a,0xee0310(%rip),%eax        # ee0c1f <_license+0xede7f2>
     90c:	05 1a 06 
     90f:	90                   	nop
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     910:	05 09 3c 04 10       	add    $0x10043c09,%eax
     915:	05 18 06 03 8e       	add    $0x8e030618,%eax
     91a:	7e 66                	jle    982 <balancer_ingress+0x982>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     91c:	05 32 06 e4 05       	add    $0x5e40632,%eax
     921:	09 3c 05 0a 06 32 05 	or     %edi,0x532060a(,%rax,1)
     928:	09 06                	or     %eax,(%rsi)
     92a:	e4 04                	in     $0x4,%al
    if (!lru_stats) {
     92c:	11 05 03 06 03 24    	adc    %eax,0x24030603(%rip)        # 24030f35 <_license+0x2402eb08>
     932:	4a d7                	rex.WX xlat %ds:(%rbx)
    lru_stats->v1 += 1;
     934:	05 00 06 03 fd       	add    $0xfd030600,%eax
     939:	7e c8                	jle    903 <balancer_ingress+0x903>
     93b:	05 07 06 03 89       	add    $0x89030607,%eax
     940:	01 c8                	add    %ecx,%eax
     942:	06                   	(bad)
     943:	ba 03 f7 7e 66       	mov    $0x667ef703,%edx
     948:	04 00                	add    $0x0,%al
     94a:	05 21 06 03 d6       	add    $0xd6030621,%eax
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     94f:	02 9e 05 08 f3 05    	add    0x5f30805(%rsi),%bl
     955:	07                   	(bad)
     956:	06                   	(bad)
     957:	3c 05                	cmp    $0x5,%al
     959:	00 03                	add    %al,(%rbx)
     95b:	a9 7d 66 05 0e       	test   $0xe05667d,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     960:	06                   	(bad)
     961:	03 df                	add    %edi,%ebx
     963:	02 58 05             	add    0x5(%rax),%bl
     966:	07                   	(bad)
     967:	06                   	(bad)
     968:	82                   	(bad)
     969:	06                   	(bad)
     96a:	03 f8                	add    %eax,%edi
    if (!icmp_ptb_v4_stats) {
     96c:	7e 4a                	jle    9b8 <balancer_ingress+0x9b8>
     96e:	03 88 01 3c 05 09    	add    0x9053c01(%rax),%ecx
     974:	03 0b                	add    (%rbx),%ecx
    icmp_ptb_v4_stats->v1 += 1;
     976:	e4 f3                	in     $0xf3,%al
     978:	06                   	(bad)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     979:	3c 04                	cmp    $0x4,%al
     97b:	0c 05                	or     $0x5,%al
     97d:	0e                   	(bad)
     97e:	06                   	(bad)
      icmp_ptb_v4_stats->v2 += 1;
     97f:	03 f8                	add    %eax,%edi
     981:	7d ac                	jge    92f <balancer_ingress+0x92f>
     983:	05 07 03 6a 4a       	add    $0x4a6a0307,%eax
  if (iph + 1 > data_end) {
     988:	05 0e 03 16 2e       	add    $0x2e16030e,%eax
     98d:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
  if (iph->ihl != 5) {
     992:	06                   	(bad)
     993:	4a 05 07 3c 04 00    	rex.WX add $0x43c07,%rax
     999:	05 00 03 9b 7f       	add    $0x7f9b0300,%eax
  pckt->flow.proto = iph->protocol;
     99e:	66 05 19 06          	add    $0x619,%ax
     9a2:	03 8d 06 02 31 01    	add    0x1310206(%rbp),%ecx
  pckt->flags |= F_ICMP;
     9a8:	05 0d 06 4a 05       	add    $0x54a060d,%eax
  pckt->flow.src = iph->daddr;
     9ad:	0e                   	(bad)
     9ae:	06                   	(bad)
     9af:	4d 05 0c 06 58 05    	rex.WRB add $0x558060c,%rax
  pckt->flow.dst = iph->saddr;
     9b5:	19 06                	sbb    %eax,(%rsi)
     9b7:	59                   	pop    %rcx
     9b8:	05 0d 06 4a 04       	add    $0x44a060d,%eax
    vip.port = 0;
     9bd:	06                   	(bad)
     9be:	05 01 06 03 89       	add    $0x89030601,%eax
     9c3:	7d 4a                	jge    a0f <balancer_ingress+0xa0f>
     9c5:	04 00                	add    $0x0,%al
     9c7:	05 08 03 f9 02       	add    $0x2f90308,%eax
     9cc:	08 9e 05 07 06 3c    	or     %bl,0x3c060705(%rsi)
    if (!vip_info) {
     9d2:	05 10 06 03 0f       	add    $0xf030610,%eax
     9d7:	66 05 17 06          	add    $0x617,%ax
     9db:	66 05 07 66          	add    $0x6607,%ax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     9df:	03 de                	add    %esi,%ebx
     9e1:	79 66                	jns    a49 <balancer_ingress+0xa49>
     9e3:	05 10 06 03 b6       	add    $0xb6030610,%eax
      pckt.flow.port16[1] = 0;
     9e8:	06                   	(bad)
     9e9:	9e                   	sahf
     9ea:	05 08 f3 05 07       	add    $0x705f308,%eax
     9ef:	06                   	(bad)
     9f0:	3c 05                	cmp    $0x5,%al
  struct address dst_addr = {};
     9f2:	12 06                	adc    (%rsi),%al
     9f4:	6b 05 18 4c 05 07 06 	imul   $0x6,0x7054c18(%rip),%eax        # 7055613 <_license+0x70531e6>
     9fb:	3c 05                	cmp    $0x5,%al
     9fd:	19 06                	sbb    %eax,(%rsi)
     9ff:	31 05 17 77 05 13    	xor    %eax,0x13057717(%rip)        # 1305811c <_license+0x13055cef>
    dst_addr.addr = pckt->flow.dst;
     a05:	9f                   	lahf
     a06:	bb 06 58 05 22       	mov    $0x22055806,%ebx
     a0b:	06                   	(bad)
     a0c:	6a 05                	push   $0x5
     a0e:	0a f3                	or     %bl,%dh
     a10:	05 09 06 3c 05       	add    $0x53c0609,%eax
     a15:	13 06                	adc    (%rsi),%eax
     a17:	6c                   	insb   (%dx),%es:(%rdi)
     a18:	06                   	(bad)
     a19:	03 af 79 d6 06 03    	add    0x306d679(%rdi),%ebp
     a1f:	c6 06 9e             	movb   $0x9e,(%rsi)
     a22:	06                   	(bad)
  if (decap_dst_flags) {
     a23:	03 ba 79 2e 03 c6    	add    -0x39fcd187(%rdx),%edi
     a29:	06                   	(bad)
     a2a:	9e                   	sahf
     a2b:	03 ba 79 82 05 08    	add    0x8058279(%rdx),%edi
     a31:	06                   	(bad)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a32:	03 c7                	add    %edi,%eax
     a34:	06                   	(bad)
     a35:	58                   	pop    %rax
     a36:	05 07 06 3c 05       	add    $0x53c0607,%eax
     a3b:	18 06                	sbb    %al,(%rsi)
     a3d:	03 0e                	add    (%rsi),%ecx
     a3f:	66 05 07 06          	add    $0x607,%ax
    if (!data_stats) {
     a43:	3c 05                	cmp    $0x5,%al
     a45:	14 06                	adc    $0x6,%al
     a47:	67 05 09 59 06 03    	addr32 add $0x3065909,%eax
    data_stats->v1 += 1;
     a4d:	a9 79 66 05 0b       	test   $0xb056679,%eax
     a52:	06                   	(bad)
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     a53:	03 eb                	add    %ebx,%ebp
     a55:	06                   	(bad)
     a56:	9e                   	sahf
     a57:	05 0c f3 05 0b       	add    $0xb05f30c,%eax
     a5c:	06                   	(bad)
     a5d:	3c 04                	cmp    $0x4,%al
     a5f:	0c 05                	or     $0x5,%al
     a61:	0d 06 03 f7 7b       	or     $0x7bf70306,%eax
     a66:	66 05 12 46          	add    $0x4612,%ax
    csum = iph->check + 0x0001;
     a6a:	05 0d 5c 05 2b       	add    $0x2b055c0d,%eax
    iph->check = (csum & 0xffff) + (csum >> 16);
     a6f:	06                   	(bad)
     a70:	4a 05 3b 4a 05 07    	rex.WX add $0x7054a3b,%rax
     a76:	3c 03                	cmp    $0x3,%al
     a78:	9d                   	popf
     a79:	7d 66                	jge    ae1 <balancer_ingress+0xae1>
    if (!--iph->ttl) {
     a7b:	05 08 06 03 ef       	add    $0xef030608,%eax
     a80:	02 74 05 26          	add    0x26(%rbp,%rax,1),%dh
     a84:	06                   	(bad)
     a85:	3c 05                	cmp    $0x5,%al
     a87:	07                   	(bad)
     a88:	3c 05                	cmp    $0x5,%al
     a8a:	13 06                	adc    (%rsi),%eax
     a8c:	03 14 66             	add    (%rsi,%riz,2),%edx
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     a8f:	05 36 06 4a 05       	add    $0x54a0636,%eax
     a94:	09 3c 04             	or     %edi,(%rsp,%rax,1)
     a97:	00 05 0e 06 03 91    	add    %al,-0x6efcf9f2(%rip)        # ffffffff910310ab <server_id_map+0x36fc47d950ab>
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     a9d:	03 ac 04 06 05 01 03 	add    0x3010506(%rsp,%rax,1),%ebp
     aa4:	86 7d 74             	xchg   %bh,0x74(%rbp)
  new_eth->h_proto = BE_ETH_P_IP;
     aa7:	04 00                	add    $0x0,%al
     aa9:	05 0a 03 fc 02       	add    $0x2fc030a,%eax
     aae:	d6                   	(bad)
     aaf:	05 09 06 3c 05       	add    $0x53c0609,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     ab4:	00 03                	add    %al,(%rbx)
     ab6:	ea                   	(bad)
     ab7:	79 66                	jns    b1f <balancer_ingress+0xb1f>
     ab9:	05 30 06 03 9a       	add    $0x9a030630,%eax
     abe:	06                   	(bad)
     abf:	3c 05                	cmp    $0x5,%al
     ac1:	1b 94 06 03 e2 79 ba 	sbb    -0x45861dfd(%rsi,%rax,1),%edx
     ac8:	05 25 06 03 df       	add    $0xdf030625,%eax
     acd:	06                   	(bad)
     ace:	9e                   	sahf
     acf:	05 0c f3 05 0b       	add    $0xb05f30c,%eax
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     ad4:	06                   	(bad)
     ad5:	3c 05                	cmp    $0x5,%al
     ad7:	16                   	(bad)
     ad8:	06                   	(bad)
     ad9:	69 04 0e 05 14 03 e6 	imul   $0xe6031405,(%rsi,%rcx,1),%eax
  if (!data_stats) {
     ae0:	7b 58                	jnp    b3a <balancer_ingress+0xb3a>
     ae2:	05 37 06 3c 04       	add    $0x43c0637,%eax
     ae7:	00 05 0b 06 03 9c    	add    %al,-0x63fcf9f5(%rip)        # ffffffff9c0310f8 <server_id_map+0x36fc52d950f8>
     aed:	04 4a                	add    $0x4a,%al
  if (action >= 0) {
     aef:	05 15 67 06 03       	add    $0x3066715,%eax
     af4:	9a                   	(bad)
     af5:	79 4a                	jns    b41 <balancer_ingress+0xb41>
     af7:	05 13 06 03 c6       	add    $0xc6030613,%eax
  if (decap_dst_flags) {
     afc:	06                   	(bad)
  if (action >= 0) {
     afd:	58                   	pop    %rax
     afe:	06                   	(bad)
     aff:	03 ba 79 2e 03 c6    	add    -0x39fcd187(%rdx),%edi
     b05:	06                   	(bad)
     b06:	9e                   	sahf
     b07:	03 ba 79 82 05 08    	add    0x8058279(%rdx),%edi
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b0d:	06                   	(bad)
     b0e:	03 c7                	add    %edi,%eax
     b10:	06                   	(bad)
     b11:	58                   	pop    %rax
     b12:	05 07 06 3c 03       	add    $0x33c0607,%eax
     b17:	b9 79 66 05 18       	mov    $0x18056679,%ecx
    if (xpop_stats_data) {
     b1c:	06                   	(bad)
     b1d:	03 d5                	add    %ebp,%edx
     b1f:	06                   	(bad)
     b20:	82                   	(bad)
     b21:	05 07 06 82 05       	add    $0x5820607,%eax
     b26:	14 06                	adc    $0x6,%al
     b28:	67 05 09 59 06 03    	addr32 add $0x3065909,%eax
     b2e:	a9 79 2e 05 0b       	test   $0xb052e79,%eax
     b33:	06                   	(bad)
     b34:	03 eb                	add    %ebx,%ebp
     b36:	06                   	(bad)
     b37:	9e                   	sahf
     b38:	05 0c f3 05 0b       	add    $0xb05f30c,%eax
     b3d:	06                   	(bad)
     b3e:	3c 04                	cmp    $0x4,%al
     b40:	0c 05                	or     $0x5,%al
     b42:	0d 06 03 f7 7b       	or     $0x7bf70306,%eax
     b47:	66 05 12 46          	add    $0x4612,%ax
     b4b:	05 0d 5c 05 2b       	add    $0x2b055c0d,%eax
     b50:	06                   	(bad)
     b51:	4a 05 3b 4a 05 07    	rex.WX add $0x7054a3b,%rax
        bpf_map_lookup_elem(&stats, &stats_key);
     b57:	3c 03                	cmp    $0x3,%al
     b59:	9d                   	popf
     b5a:	7d 66                	jge    bc2 <balancer_ingress+0xbc2>
     b5c:	04 00                	add    $0x0,%al
     b5e:	05 25 06 03 df       	add    $0xdf030625,%eax
     b63:	06                   	(bad)
     b64:	74 05                	je     b6b <balancer_ingress+0xb6b>
    if (!icmp_ptb_v6_stats) {
     b66:	0c 08                	or     $0x8,%al
     b68:	91                   	xchg   %eax,%ecx
     b69:	05 0b 06 3c 05       	add    $0x53c060b,%eax
     b6e:	16                   	(bad)
    icmp_ptb_v6_stats->v1 += 1;
     b6f:	06                   	(bad)
     b70:	69 04 0e 05 14 03 eb 	imul   $0xeb031405,(%rsi,%rcx,1),%eax
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     b77:	7b 58                	jnp    bd1 <balancer_ingress+0xbd1>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     b79:	05 2f 06 3c 04       	add    $0x43c062f,%eax
     b7e:	00 05 0b 06 03 97    	add    %al,-0x68fcf9f5(%rip)        # ffffffff9703118f <server_id_map+0x36fc4dd9518f>
      icmp_ptb_v6_stats->v2 += 1;
     b84:	04 90                	add    $0x90,%al
  if (ip6h + 1 > data_end) {
     b86:	05 15 2f 05 00       	add    $0x52f15,%eax
     b8b:	06                   	(bad)
     b8c:	03 9a 79 4a 05 14    	add    0x14054a79(%rdx),%ebx
     b92:	06                   	(bad)
     b93:	03 af 07 58 05 1e    	add    0x1e055807(%rdi),%ebp
  pckt->flow.proto = ip6h->nexthdr;
     b99:	03 26                	add    (%rsi),%esp
     b9b:	66 05 2b 06          	add    $0x62b,%ax
  pckt->flags |= F_ICMP;
     b9f:	58                   	pop    %rax
     ba0:	05 1b 06 2f 05       	add    $0x52f061b,%eax
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     ba5:	09 3b                	or     %edi,(%rbx)
     ba7:	06                   	(bad)
     ba8:	03 ab 78 2e 04 06    	add    0x6042e78(%rbx),%ebp
     bae:	05 01 06 03 9a       	add    $0x9a030601,%eax
     bb3:	03 58 04             	add    0x4(%rax),%ebx
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     bb6:	00 05 08 03 9f 7e    	add    %al,0x7e9f0308(%rip)        # 7e9f0ec4 <_license+0x7e9eea97>
     bbc:	ac                   	lods   %ds:(%rsi),%al
     bbd:	05 07 06 3c 05       	add    $0x53c0607,%eax
     bc2:	00 03                	add    %al,(%rbx)
     bc4:	c7                   	(bad)
     bc5:	7e 2e                	jle    bf5 <balancer_ingress+0xbf5>
     bc7:	05 28 06 03 bc       	add    $0xbc030628,%eax
     bcc:	01 3c 05 07 06 58 03 	add    %edi,0x3580607(,%rax,1)
  if (protocol == IPPROTO_IPIP) {
     bd3:	c4                   	(bad)
     bd4:	7e 66                	jle    c3c <balancer_ingress+0xc3c>
     bd6:	05 10 06 03 bd       	add    $0xbd030610,%eax
     bdb:	01 74 05 12          	add    %esi,0x12(%rbp,%rax,1)
     bdf:	2f                   	(bad)
     be0:	05 23 06 08 12       	add    $0x12080623,%eax
  struct address dst_addr = {};
     be5:	05 09 3c 03 c2       	add    $0xc2033c09,%eax
     bea:	7e 66                	jle    c52 <balancer_ingress+0xc52>
     bec:	04 0c                	add    $0xc,%al
     bee:	05 13 06 03 f1       	add    $0xf1030613,%eax
     bf3:	02 f2                	add    %dl,%dh
     bf5:	05 35 06 4a 05       	add    $0x54a0635,%eax
    dst_addr.addr = pckt->flow.dst;
     bfa:	09 3c 05 2d 06 69 05 	or     %edi,0x569062d(,%rax,1)
     c01:	09 06                	or     %eax,(%rsi)
     c03:	3c 04                	cmp    $0x4,%al
     c05:	00 05 29 06 03 ac    	add    %al,-0x53fcf9d7(%rip)        # ffffffffac031234 <server_id_map+0x36fc62d95234>
     c0b:	04 66                	add    $0x66,%al
     c0d:	06                   	(bad)
     c0e:	03 e0                	add    %eax,%esp
     c10:	78 58                	js     c6a <balancer_ingress+0xc6a>
     c12:	05 07 06 03 80       	add    $0x80030607,%eax
  if (decap_dst_flags) {
     c17:	05 3c 06 03 80       	add    $0x8003063c,%eax
     c1c:	7b 66                	jnp    c84 <balancer_ingress+0xc84>
     c1e:	03 80 05 9e 03 80    	add    -0x7ffc61fb(%rax),%eax
     c24:	7b 66                	jnp    c8c <balancer_ingress+0xc8c>
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c26:	03 80 05 9e 05 08    	add    0x8059e05(%rax),%eax
     c2c:	06                   	(bad)
     c2d:	08 13                	or     %dl,(%rbx)
     c2f:	05 07 06 3c 04       	add    $0x43c0607,%eax
     c34:	0c 05                	or     $0x5,%al
    if (!data_stats) {
     c36:	00 03                	add    %al,(%rbx)
     c38:	ff                   	(bad)
     c39:	7a ac                	jp     be7 <balancer_ingress+0xbe7>
     c3b:	05 08 06 03 ef       	add    $0xef030608,%eax
    data_stats->v1 += 1;
     c40:	02 4a 05             	add    0x5(%rdx),%cl
    if ((*data + offset) > *data_end) {
     c43:	26 06                	es (bad)
     c45:	3c 05                	cmp    $0x5,%al
     c47:	07                   	(bad)
     c48:	3c 05                	cmp    $0x5,%al
     c4a:	13 06                	adc    (%rsi),%eax
     c4c:	03 14 2e             	add    (%rsi,%rbp,1),%edx
     c4f:	05 36 06 4a 05       	add    $0x54a0636,%eax
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     c54:	09 3c 05 08 06 6b 05 	or     %edi,0x56b0608(,%rax,1)
     c5b:	07                   	(bad)
     c5c:	06                   	(bad)
     c5d:	3c 05                	cmp    $0x5,%al
     c5f:	19 06                	sbb    %eax,(%rsi)
     c61:	6a 05                	push   $0x5
     c63:	23 06                	and    (%rsi),%eax
     c65:	3c 05                	cmp    $0x5,%al
     c67:	07                   	(bad)
    if (!--ip6h->hop_limit) {
     c68:	06                   	(bad)
     c69:	5a                   	pop    %rdx
     c6a:	05 15 08 a2 05       	add    $0x5a20815,%eax
     c6f:	1d 06 3c 05 27       	sbb    $0x27053c06,%eax
     c74:	4a 05 24 4a 05 3a    	rex.WX add $0x3a054a24,%rax
     c7a:	4a 05 44 3c 05 13    	rex.WX add $0x13053c44,%rax
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     c80:	06                   	(bad)
     c81:	03 5f 9e             	add    -0x62(%rdi),%ebx
     c84:	05 35 06 4a 05       	add    $0x54a0635,%eax
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     c89:	09 3c 05 2d 06 69 05 	or     %edi,0x569062d(,%rax,1)
     c90:	09 06                	or     %eax,(%rsi)
     c92:	3c 04                	cmp    $0x4,%al
     c94:	00 05 29 06 03 ac    	add    %al,-0x53fcf9d7(%rip)        # ffffffffac0312c3 <server_id_map+0x36fc62d952c3>
     c9a:	04 66                	add    $0x66,%al
     c9c:	05 07 03 e0 7d       	add    $0x7de00307,%eax
     ca1:	58                   	pop    %rax
     ca2:	06                   	(bad)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     ca3:	03 80 7b ac 03 80    	add    -0x7ffc5385(%rax),%eax
     ca9:	05 58 03 80 7b       	add    $0x7b800358,%eax
     cae:	66 03 80 05 08 20 05 	add    0x5200805(%rax),%ax
     cb5:	08 06                	or     %al,(%rsi)
     cb7:	08 13                	or     %dl,(%rbx)
     cb9:	05 07 06 3c 04       	add    $0x43c0607,%eax
     cbe:	0c 05                	or     $0x5,%al
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     cc0:	23 06                	and    (%rsi),%eax
     cc2:	03 fc                	add    %esp,%edi
     cc4:	7d ac                	jge    c72 <balancer_ingress+0xc72>
     cc6:	06                   	(bad)
     cc7:	03 83 7d 4a 05 08    	add    0x8054a7d(%rbx),%eax
     ccd:	06                   	(bad)
     cce:	03 88 03 c8 05 07    	add    0x705c803(%rax),%ecx
  if (!data_stats) {
     cd4:	06                   	(bad)
     cd5:	3c 05                	cmp    $0x5,%al
     cd7:	19 06                	sbb    %eax,(%rsi)
     cd9:	6a 05                	push   $0x5
     cdb:	23 06                	and    (%rsi),%eax
  if (action >= 0) {
     cdd:	3c 05                	cmp    $0x5,%al
     cdf:	07                   	(bad)
     ce0:	06                   	(bad)
     ce1:	5a                   	pop    %rdx
     ce2:	05 15 08 a2 05       	add    $0x5a20815,%eax
     ce7:	1d 06 3c 05 27       	sbb    $0x27053c06,%eax
     cec:	4a 05 24 4a 05 3a    	rex.WX add $0x3a054a24,%rax
     cf2:	4a 05 44 3c 04 00    	rex.WX add $0x43c44,%rax
     cf8:	05 14 06 03 af       	add    $0xaf030614,%eax
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     cfd:	7e 9e                	jle    c9d <balancer_ingress+0xc9d>
     cff:	05 12 4c 06 03       	add    $0x3064c12,%eax
     d04:	bd 7e 3c 03 c3       	mov    $0xc3033c7e,%ebp
     d09:	01 3c 05 14 06 67 05 	add    %edi,0x5670614(,%rax,1)
    if (xpop_stats_data) {
     d10:	0b 4b 06             	or     0x6(%rbx),%ecx
     d13:	03 bb 7e 4a 03 c5    	add    -0x3afcb582(%rbx),%edi
  udp = data + off;
     d19:	01 9e 03 bb 7e ba    	add    %ebx,-0x458144fd(%rsi)
     d1f:	05 1f 06 03 92       	add    $0x9203061f,%eax
  if (udp + 1 > data_end) {
     d24:	05 58 05 2e 06       	add    $0x62e0558,%eax
     d29:	58                   	pop    %rax
     d2a:	05 17 06 67 05       	add    $0x5670617,%eax
     d2f:	2e 06                	cs (bad)
     d31:	4a 05 07 06 03 97    	rex.WX add $0xffffffff97030607,%rax
     d37:	7b 66                	jnp    d9f <balancer_ingress+0xd9f>
     d39:	05 08 08 91 05       	add    $0x5910808,%eax
     d3e:	07                   	(bad)
     d3f:	06                   	(bad)
     d40:	3c 03                	cmp    $0x3,%al
     d42:	55                   	push   %rbp
     d43:	66 05 0f 06          	add    $0x60f,%ax
     d47:	03 2e                	add    (%rsi),%ebp
     d49:	74 05                	je     d50 <balancer_ingress+0xd50>
     d4b:	12 32                	adc    (%rdx),%dh
     d4d:	05 29 06 74 05       	add    $0x5740629,%eax
     d52:	07                   	(bad)
     d53:	74 05                	je     d5a <balancer_ingress+0xd5a>
     d55:	19 06                	sbb    %eax,(%rsi)
     d57:	30 75 68             	xor    %dh,0x68(%rbp)
     d5a:	05 1d 9f 05 09       	add    $0x9059f1d,%eax
     d5f:	06                   	(bad)
     d60:	66 04 06             	data16 add $0x6,%al
    vip.vip = pckt.flow.dst;
     d63:	05 01 06 03 e2       	add    $0xe2030601,%eax
     d68:	02 2e                	add    (%rsi),%ch
  vip.port = pckt.flow.port16[1];
     d6a:	04 00                	add    $0x0,%al
     d6c:	05 09 03 fc 01       	add    $0x1fc0309,%eax
     d71:	08 4a 06             	or     %cl,0x6(%rdx)
  vip.proto = pckt.flow.proto;
     d74:	3c 05                	cmp    $0x5,%al
     d76:	19 06                	sbb    %eax,(%rsi)
     d78:	2f                   	(bad)
     d79:	04 06                	add    $0x6,%al
     d7b:	05 01 03 83 7e       	add    $0x7e830301,%eax
     d80:	58                   	pop    %rax
     d81:	04 00                	add    $0x0,%al
     d83:	05 0b 03 fe 01       	add    $0x1fe030b,%eax
     d88:	90                   	nop
     d89:	06                   	(bad)
     d8a:	3c 05                	cmp    $0x5,%al
     d8c:	27                   	(bad)
     d8d:	06                   	(bad)
     d8e:	33 05 0d 08 91 06    	xor    0x691080d(%rip),%eax        # 69115a1 <_license+0x690f174>
     d94:	3c 05                	cmp    $0x5,%al
  if (!vip_info) {
     d96:	1a 06                	sbb    (%rsi),%al
     d98:	67 05 0a 03 c8 02    	addr32 add $0x2c8030a,%eax
     d9e:	90                   	nop
  if (data_end - data > MAX_PCKT_SIZE) {
     d9f:	05 09 06 3c 03       	add    $0x33c0609,%eax
     da4:	99                   	cltd
     da5:	78 66                	js     e0d <balancer_ingress+0xe0d>
     da7:	05 10 06 03 8e       	add    $0x8e030610,%eax
     dac:	08 82 06 66 66 05    	or     %al,0x5666606(%rdx)
     db2:	08 06                	or     %al,(%rsi)
     db4:	08 9f 05 07 06 3c    	or     %bl,0x3c060705(%rdi)
     dba:	03 f1                	add    %ecx,%esi
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     dbc:	77 66                	ja     e24 <balancer_ingress+0xe24>
     dbe:	05 12 06 03 92       	add    $0x92030612,%eax
     dc3:	08 ac 05 15 4b 05 12 	or     %ch,0x12054b15(%rbp,%rax,1)
     dca:	06                   	(bad)
  if (!data_stats) {
     dcb:	3c 05                	cmp    $0x5,%al
     dcd:	10 06                	adc    %al,(%rsi)
     dcf:	4d 06                	rex.WRB (bad)
     dd1:	03 ea                	add    %edx,%ebp
     dd3:	77 08                	ja     ddd <balancer_ingress+0xddd>
  data_stats->v1 += 1;
     dd5:	12 03                	adc    (%rbx),%al
     dd7:	96                   	xchg   %eax,%esi
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     dd8:	08 9e 05 08 06 08    	or     %bl,0x8060805(%rsi)
    pckt.flow.port16[0] = 0;
     dde:	13 05 07 06 3c 05    	adc    0x53c0607(%rip),%eax        # 53c13eb <_license+0x53befbe>
  vip_num = vip_info->vip_num;
     de4:	12 06                	adc    (%rsi),%al
     de6:	69 4b 05 17 51 05 12 	imul   $0x12055117,0x5(%rbx),%ecx
     ded:	67 05 07 06 58 04    	addr32 add $0x4580607,%eax
  __u32 cpu_num = bpf_get_smp_processor_id();
     df3:	11 05 49 06 03 c0    	adc    %eax,-0x3ffcf9b7(%rip)        # ffffffffc0031442 <server_id_map+0x36fc76d95442>
     df9:	78 66                	js     e61 <balancer_ingress+0xe61>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     dfb:	06                   	(bad)
     dfc:	03 9d 7f 66 05 07    	add    0x705667f(%rbp),%ebx
     e02:	06                   	(bad)
     e03:	03 e6                	add    %esi,%esp
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e05:	00 74 06 ba          	add    %dh,-0x46(%rsi,%rax,1)
     e09:	05 1c 06 69 05       	add    $0x569061c,%eax
     e0e:	20 4b 05             	and    %cl,0x5(%rbx)
     e11:	0e                   	(bad)
     e12:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
    if (!lru_stats) {
     e18:	06                   	(bad)
     e19:	3c 03                	cmp    $0x3,%al
     e1b:	92                   	xchg   %eax,%edx
     e1c:	7f 66                	jg     e84 <balancer_ingress+0xe84>
    lru_stats->v1 += 1;
     e1e:	03 ee                	add    %esi,%ebp
     e20:	00 90 03 92 7f 90    	add    %dl,-0x6f806dfd(%rax)
     e26:	05 03 06 03 f1       	add    $0xf1030603,%eax
     e2b:	00 08                	add    %cl,(%rax)
     e2d:	ba 08 2f 05 14       	mov    $0x14052f08,%edx
     e32:	d7                   	xlat   %ds:(%rbx)
     e33:	05 1c 68 05 2e       	add    $0x2e05681c,%eax
     e38:	06                   	(bad)
     e39:	4a 04 12             	rex.WX add $0x12,%al
     e3c:	05 0c 06 03 45       	add    $0x4503060c,%eax
     e41:	3c 4f                	cmp    $0x4f,%al
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e43:	05 12 40 05 10       	add    $0x10054012,%eax
     e48:	06                   	(bad)
     e49:	74 05                	je     e50 <balancer_ingress+0xe50>
     e4b:	0b 06                	or     (%rsi),%eax
     e4d:	4b 05 0e 75 3d 05    	rex.WXB add $0x53d750e,%rax
  if (!lru_map) {
     e53:	0c 3d                	or     $0x3d,%al
     e55:	04 0f                	add    $0xf,%al
     e57:	05 0e 03 71 66       	add    $0x6671030e,%eax
  if ((vip_info->flags & F_QUIC_VIP)) {
     e5c:	05 0b 06 e4 05       	add    $0x5e4060b,%eax
    bool is_icmp = (pckt.flags & F_ICMP);
     e61:	0e                   	(bad)
     e62:	3c 05                	cmp    $0x5,%al
     e64:	0b 3c 04             	or     (%rsp,%rax,1),%edi
    if (is_icmp) {
     e67:	00 05 1b 06 03 b0    	add    %al,-0x4ffcf9e5(%rip)        # ffffffffb0031488 <server_id_map+0x36fc66d95488>
     e6d:	07                   	(bad)
     e6e:	82                   	(bad)
     e6f:	05 0b 06 58 05       	add    $0x558060b,%eax
     e74:	0d 06 31 05 0e       	or     $0xe053106,%eax
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     e79:	08 91 05 0d 06 3c    	or     %dl,0x3c060d05(%rcx)
     e7f:	06                   	(bad)
     e80:	69 05 00 06 03 91 78 	imul   $0x1705ba78,-0x6efcfa00(%rip),%eax        # ffffffff9103148a <server_id_map+0x36fc47d9548a>
     e87:	ba 05 17 
      if (!quic_packets_stats) {
     e8a:	06                   	(bad)
     e8b:	03 de                	add    %esi,%ebx
     e8d:	00 58 05             	add    %bl,0x5(%rax)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e90:	07                   	(bad)
     e91:	03 4c 08 20          	add    0x20(%rax,%rcx,1),%ecx
  bool is_icmp = (pckt->flags & F_ICMP);
     e95:	06                   	(bad)
     e96:	03 56 08             	add    0x8(%rsi),%edx
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     e99:	90                   	nop
     e9a:	05 08 06 03 2b       	add    $0x2b030608,%eax
     e9f:	2e 05 07 06 3c 03    	cs add $0x33c0607,%eax
     ea5:	55                   	push   %rbp
     ea6:	2e 05 0f 06 03 2e    	cs add $0x2e03060f,%eax
     eac:	74 05                	je     eb3 <balancer_ingress+0xeb3>
     eae:	12 32                	adc    (%rdx),%dh
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     eb0:	05 29 06 74 05       	add    $0x5740629,%eax
     eb5:	07                   	(bad)
     eb6:	74 05                	je     ebd <balancer_ingress+0xebd>
     eb8:	19 06                	sbb    %eax,(%rsi)
     eba:	30 83 06 03 4b 66    	xor    %al,0x664b0306(%rbx)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     ec0:	06                   	(bad)
     ec1:	03 37                	add    (%rdi),%esi
     ec3:	4a 05 1d bb 05 09    	rex.WX add $0x905bb1d,%rax
     ec9:	06                   	(bad)
     eca:	74 03                	je     ecf <balancer_ingress+0xecf>
     ecc:	48                   	rex.W
     ecd:	2e 05 19 06 03 88    	cs add $0x88030619,%eax
    vip.port = 0;
     ed3:	01 74 05 09          	add    %esi,0x9(%rbp,%rax,1)
     ed7:	06                   	(bad)
     ed8:	3c 03                	cmp    $0x3,%al
     eda:	f8                   	clc
     edb:	7e 2e                	jle    f0b <balancer_ingress+0xf0b>
     edd:	03 88 01 58 05 1e    	add    0x1e055801(%rax),%ecx
    if (!vip_info) {
     ee3:	06                   	(bad)
     ee4:	6a 05                	push   $0x5
     ee6:	1c 06                	sbb    $0x6,%al
     ee8:	58                   	pop    %rax
     ee9:	05 07 06 59 06       	add    $0x6590607,%eax
     eee:	03 f3                	add    %ebx,%esi
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     ef0:	7e 08                	jle    efa <balancer_ingress+0xefa>
     ef2:	66 04 0d             	data16 add $0xd,%al
     ef5:	05 05 06 03 e8       	add    $0xe8030605,%eax
      pckt.flow.port16[1] = 0;
     efa:	00 58 05             	add    %bl,0x5(%rax)
     efd:	03 4c 05 1a          	add    0x1a(%rbp,%rax,1),%ecx
     f01:	03 9e 7f 82 05 03    	add    0x305827f(%rsi),%ebx
     f07:	03 e2                	add    %edx,%esp
     f09:	00 58 05             	add    %bl,0x5(%rax)
     f0c:	1a 03                	sbb    (%rbx),%al
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     f0e:	9e                   	sahf
     f0f:	7f 4a                	jg     f5b <balancer_ingress+0xf5b>
     f11:	05 03 03 e2 00       	add    $0xe20303,%eax
     f16:	58                   	pop    %rax
     f17:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
     f1c:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
      if (!data_stats) {
     f22:	58                   	pop    %rax
     f23:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
      data_stats->v1 += 1;
     f28:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     f2e:	58                   	pop    %rax
     f2f:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     f34:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
        data_stats->v2 += 1;
     f3a:	58                   	pop    %rax
     f3b:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
     f40:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
     f46:	3c 05                	cmp    $0x5,%al
     f48:	1a 03                	sbb    (%rbx),%al
     f4a:	9e                   	sahf
     f4b:	7f 4a                	jg     f97 <balancer_ingress+0xf97>
     f4d:	05 03 03 e2 00       	add    $0xe20303,%eax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     f52:	3c 06                	cmp    $0x6,%al
     f54:	03 96 7f 2e 04 00    	add    0x42e7f(%rsi),%edx
     f5a:	05 30 06 03 8f       	add    $0x8f030630,%eax
  if (!lru_map) {
     f5f:	01 58 06             	add    %ebx,0x6(%rax)
     f62:	03 f1                	add    %ecx,%esi
     f64:	7e 08                	jle    f6e <balancer_ingress+0xf6e>
     f66:	12 05 22 06 03 90    	adc    -0x6ffcf9de(%rip),%al        # ffffffff9003158e <server_id_map+0x36fc46d9558e>
  if ((vip_info->flags & F_QUIC_VIP)) {
     f6c:	01 58 05             	add    %ebx,0x5(%rax)
     f6f:	15 06 3c 05 2b       	adc    $0x2b053c06,%eax
     f74:	74 05                	je     f7b <balancer_ingress+0xf7b>
     f76:	10 06                	adc    %al,(%rsi)
     f78:	30 05 09 67 05 10    	xor    %al,0x10056709(%rip)        # 10057687 <_license+0x1005525a>
    bool is_icmp = (pckt.flags & F_ICMP);
     f7e:	65 06                	gs (bad)
    if (is_icmp) {
     f80:	03 ee                	add    %esi,%ebp
     f82:	7e 2e                	jle    fb2 <balancer_ingress+0xfb2>
     f84:	05 0b 06 03 96       	add    $0x9603060b,%eax
     f89:	01 9e 05 09 9f 05    	add    %ebx,0x59f0905(%rsi)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     f8f:	14 35                	adc    $0x35,%al
     f91:	05 0b 4b 05 07       	add    $0x7054b0b,%eax
     f96:	67 03 a5 7f 2e 05 08 	add    0x8052e7f(%ebp),%esp
      if (!quic_packets_stats) {
     f9d:	08 91 05 07 06 3c    	or     %dl,0x3c060705(%rcx)
     fa3:	06                   	(bad)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fa4:	03 0a                	add    (%rdx),%ecx
     fa6:	ac                   	lods   %ds:(%rsi),%al
     fa7:	05 08 08 91 05       	add    $0x5910808,%eax
  bool is_icmp = (pckt->flags & F_ICMP);
     fac:	07                   	(bad)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fad:	06                   	(bad)
     fae:	3c 06                	cmp    $0x6,%al
     fb0:	03 d5                	add    %ebp,%edx
     fb2:	00 ac 05 0f 06 66 03 	add    %ch,0x366060f(%rbp,%rax,1)
     fb9:	da 7e 2e             	fidivrl 0x2e(%rsi)
     fbc:	05 24 03 a6 01       	add    $0x1a60324,%eax
     fc1:	58                   	pop    %rax
     fc2:	05 34 74 03 da       	add    $0xda037434,%eax
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fc7:	7e 82                	jle    f4b <balancer_ingress+0xf4b>
     fc9:	04 11                	add    $0x11,%al
     fcb:	05 07 06 03 3a       	add    $0x3a030607,%eax
     fd0:	d6                   	(bad)
     fd1:	06                   	(bad)
     fd2:	ba 05 1c 06 69       	mov    $0x69061c05,%edx
     fd7:	05 20 4b 05 0f       	add    $0xf054b20,%eax
     fdc:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
      if (!data_stats) {
     fe2:	06                   	(bad)
     fe3:	3c 03                	cmp    $0x3,%al
     fe5:	be 7f 66 03 c2       	mov    $0xc203667f,%esi
      data_stats->v1 += 1;
     fea:	00 90 03 be 7f d6    	add    %dl,-0x298041fd(%rax)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     ff0:	05 03 06 03 c5       	add    $0xc5030603,%eax
     ff5:	00 9e 08 2f 05 14    	add    %bl,0x14052f08(%rsi)
        data_stats->v2 += 1;
     ffb:	d7                   	xlat   %ds:(%rbx)
     ffc:	05 00 06 03 b9       	add    $0xb9030600,%eax
    1001:	7f 66                	jg     1069 <balancer_ingress+0x1069>
    1003:	04 12                	add    $0x12,%al
  original_sport = pckt.flow.port16[0];
    1005:	05 12 06 03 25       	add    $0x25030612,%eax
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    100a:	58                   	pop    %rax
    100b:	04 11                	add    $0x11,%al
    100d:	05 1d 03 2e 4a       	add    $0x4a2e031d,%eax
        !(vip_info->flags & F_LRU_BYPASS)) {
    1012:	04 12                	add    $0x12,%al
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1014:	05 03 4b 05 20       	add    $0x20054b03,%eax
    1019:	68 05 12 06 58       	push   $0x58061205
    101e:	05 23 06 67 05       	add    $0x5670623,%eax
    1023:	15 06 3c 05 11       	adc    $0x11053c06,%eax
  if (!dst_lru) {
    1028:	06                   	(bad)
    1029:	40 05 15 67 05 03    	rex add $0x3056715,%eax
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    102f:	4c 08 21             	rex.WR or %r12b,(%rcx)
    1032:	04 0c                	add    $0xc,%al
    1034:	05 0a 03 ba 02       	add    $0x2ba030a,%eax
    1039:	ba 05 14 06 4a       	mov    $0x4a061405,%edx
    103e:	05 1e 4a 05 28       	add    $0x28054a1e,%eax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1043:	4a 05 1b 4a 05 32    	rex.WX add $0x32054a1b,%rax
    1049:	3c 05                	cmp    $0x5,%al
    104b:	3c 4a                	cmp    $0x4a,%al
    104d:	05 2f 4a 05 45       	add    $0x45054a2f,%eax
    1052:	3c 03                	cmp    $0x3,%al
    1054:	e7 7c                	out    %eax,$0x7c
    1056:	3c 05                	cmp    $0x5,%al
    1058:	19 06                	sbb    %eax,(%rsi)
    105a:	03 95 03 4a 05 23    	add    0x23054a03(%rbp),%edx
    1060:	06                   	(bad)
    1061:	4a 05 2d 4a 05 37    	rex.WX add $0x37054a2d,%rax
    1067:	4a 05 2a 4a 05 40    	rex.WX add $0x40054a2a,%rax
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    106d:	3c 03                	cmp    $0x3,%al
    106f:	eb 7c                	jmp    10ed <balancer_ingress+0x10ed>
    1071:	3c 04                	cmp    $0x4,%al
    1073:	00 05 19 06 03 f0    	add    %al,-0xffcf9e7(%rip)        # fffffffff0031692 <server_id_map+0x36fca6d95692>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1079:	06                   	(bad)
    107a:	82                   	(bad)
    107b:	05 0b 06 2e 05       	add    $0x52e060b,%eax
    1080:	07                   	(bad)
    1081:	06                   	(bad)
        quic_packets_stats->cid_initial += 1;
    1082:	03 c8                	add    %eax,%ecx
    1084:	7d 66                	jge    10ec <balancer_ingress+0x10ec>
    1086:	06                   	(bad)
    1087:	03 c8                	add    %eax,%ecx
    1089:	7b 08                	jnp    1093 <balancer_ingress+0x1093>
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    108b:	9e                   	sahf
    108c:	05 1a 06 03 a7       	add    $0xa703061a,%eax
    1091:	01 9e 05 09 06 58    	add    %ebx,0x58060905(%rsi)
    1097:	05 19 06 2f 05       	add    $0x52f0619,%eax
    109c:	15 5a 06 03 d6       	adc    $0xd603065a,%eax
    10a1:	7e 4a                	jle    10ed <balancer_ingress+0x10ed>
    10a3:	04 06                	add    $0x6,%al
    10a5:	05 01 06 03 9f       	add    $0x9f030601,%eax
    10aa:	03 58 04             	add    0x4(%rax),%ebx
    10ad:	00 05 0b 03 e0 04    	add    %al,0x4e0030b(%rip)        # 4e013be <_license+0x4dfef91>
    10b3:	08 20                	or     %ah,(%rax)
    10b5:	06                   	(bad)
    10b6:	03 81 78 4a 05 28    	add    0x28054a78(%rcx),%eax
  if (!per_vip_stats) {
    10bc:	06                   	(bad)
    10bd:	03 d5                	add    %ebp,%edx
    10bf:	04 f2                	add    $0xf2,%al
    10c1:	05 35 06 74 05       	add    $0x5740635,%eax
    10c6:	36 06                	ss (bad)
    10c8:	59                   	pop    %rcx
    10c9:	05 2f 06 4a 05       	add    $0x54a062f,%eax
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    10ce:	00 03                	add    %al,(%rbx)
    10d0:	aa                   	stos   %al,%es:(%rdi)
    10d1:	7b 66                	jnp    1139 <balancer_ingress+0x1139>
    10d3:	05 22 06 03 d7       	add    $0xd7030622,%eax
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    10d8:	04 4a                	add    $0x4a,%al
    10da:	05 1c af 06 58       	add    $0x5806af1c,%eax
    10df:	66 03 a6 7b 2e 03 da 	add    -0x25fcd185(%rsi),%sp
  if (!connId) {
    10e6:	04 9e                	add    $0x9e,%al
    10e8:	05 0a 06 08 13       	add    $0x1308060a,%eax
  __u8 connIdVersion = (connId[0] >> 6);
    10ed:	05 09 06 3c 05       	add    $0x53c0609,%eax
    10f2:	14 06                	adc    $0x6,%al
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10f4:	69 06 03 a2 7b 3c    	imul   $0x3c7ba203,(%rsi),%eax
    10fa:	05 16 06 03 84       	add    $0x84030616,%eax
    10ff:	08 08                	or     %cl,(%rax)
    1101:	e4 04                	in     $0x4,%al
    1103:	0c 05                	or     $0x5,%al
    1105:	23 03                	and    (%rbx),%eax
    1107:	f9                   	stc
    1108:	7a 9e                	jp     10a8 <balancer_ingress+0x10a8>
    110a:	06                   	(bad)
    110b:	03 83 7d 4a 05 08    	add    0x8054a7d(%rbx),%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    1111:	06                   	(bad)
    1112:	03 88 03 c8 06 03    	add    0x306c803(%rax),%ecx
    1118:	f8                   	clc
    1119:	7c d6                	jl     10f1 <balancer_ingress+0x10f1>
    111b:	04 00                	add    $0x0,%al
    111d:	05 1b 06 03 f5       	add    $0xf503061b,%eax
    1122:	06                   	(bad)
    1123:	08 82 05 0d 59 06    	or     %al,0x6590d05(%rdx)
    1129:	03 8a 79 2e 05 11    	add    0x11052e79(%rdx),%ecx
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    112f:	06                   	(bad)
    1130:	03 f8                	add    %eax,%edi
    1132:	06                   	(bad)
    1133:	9e                   	sahf
    1134:	05 0f 9f 05 1d       	add    $0x1d059f0f,%eax
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1139:	35 05 13 67 06       	xor    $0x6671305,%eax
    113e:	66 03 ff             	add    %di,%di
        quic_packets_stats->cid_initial += 1;
    1141:	78 4a                	js     118d <balancer_ingress+0x118d>
    1143:	03 81 07 9e 05 12    	add    0x12059e07(%rcx),%eax
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1149:	06                   	(bad)
    114a:	bb 05 11 06 3c       	mov    $0x3c061105,%ebx
    114f:	03 fe                	add    %esi,%edi
    1151:	78 66                	js     11b9 <balancer_ingress+0x11b9>
    1153:	04 06                	add    $0x6,%al
    1155:	05 01 06 03 9a       	add    $0x9a030601,%eax
    115a:	03 82 04 00 05 07    	add    0x7050004(%rdx),%eax
    1160:	03 d1                	add    %ecx,%edx
    1162:	01 ac 06 3c 05 1f 06 	add    %ebp,0x61f053c(%rsi,%rax,1)
    1169:	67 05 16 06 4a 05    	addr32 add $0x54a0616,%eax
    116f:	09 2e                	or     %ebp,(%rsi)
    1171:	05 23 06 03 9f       	add    $0x9f030623,%eax
    1176:	02 66 05             	add    0x5(%rsi),%ah
    1179:	00 06                	add    %al,(%rsi)
    117b:	03 f5                	add    %ebp,%esi
    117d:	78 ba                	js     1139 <balancer_ingress+0x1139>
  if (!per_vip_stats) {
    117f:	05 14 06 03 af       	add    $0xaf030614,%eax
    1184:	07                   	(bad)
    1185:	08 ba 05 1e 03 26    	or     %bh,0x26031e05(%rdx)
    118b:	ba 05 2b 06 58       	mov    $0x58062b05,%edx
    1190:	05 1b 06 2f 05       	add    $0x52f061b,%eax
    1195:	09 3b                	or     %edi,(%rbx)
    1197:	06                   	(bad)
    1198:	03 ab 78 2e 04 06    	add    0x6042e78(%rbx),%ebp
  if (!connId) {
    119e:	05 01 06 03 9a       	add    $0x9a030601,%eax
    11a3:	03 f2                	add    %edx,%esi
    11a5:	04 00                	add    $0x0,%al
  __u8 connIdVersion = (connId[0] >> 6);
    11a7:	05 08 03 9f 7e       	add    $0x7e9f0308,%eax
    11ac:	ac                   	lods   %ds:(%rsi),%al
    11ad:	05 07 06 3c 05       	add    $0x53c0607,%eax
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    11b2:	00 03                	add    %al,(%rbx)
    11b4:	c7                   	(bad)
    11b5:	7e 2e                	jle    11e5 <balancer_ingress+0x11e5>
    11b7:	05 28 06 03 bc       	add    $0xbc030628,%eax
    11bc:	01 3c 05 07 06 58 03 	add    %edi,0x3580607(,%rax,1)
    11c3:	c4                   	(bad)
    11c4:	7e 2e                	jle    11f4 <balancer_ingress+0x11f4>
    11c6:	05 10 06 03 bd       	add    $0xbd030610,%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    11cb:	01 74 05 12          	add    %esi,0x12(%rbp,%rax,1)
    11cf:	2f                   	(bad)
    11d0:	05 23 06 08 12       	add    $0x12080623,%eax
    11d5:	05 09 3c 03 c2       	add    $0xc2033c09,%eax
    11da:	7e 2e                	jle    120a <balancer_ingress+0x120a>
    11dc:	05 14 06 03 c1       	add    $0xc1030614,%eax
    11e1:	01 82 05 12 4c 06    	add    %eax,0x64c1205(%rdx)
    dst_lru->atime = cur_time;
    11e7:	03 bd 7e 3c 03 c3    	add    -0x3cfcc382(%rbp),%edi
    11ed:	01 2e                	add    %ebp,(%rsi)
  key = dst_lru->pos;
    11ef:	05 14 06 67 05       	add    $0x5670614,%eax
    11f4:	0b 4b 06             	or     0x6(%rbx),%ecx
  pckt->real_index = key;
    11f7:	03 bb 7e 4a 03 c5    	add    -0x3afcb582(%rbx),%edi
    11fd:	01 9e 03 bb 7e ba    	add    %ebx,-0x458144fd(%rsi)
    1203:	05 1f 06 03 92       	add    $0x9203061f,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
    1208:	05 ac 05 2e 06       	add    $0x62e05ac,%eax
    120d:	58                   	pop    %rax
    120e:	05 17 06 67 05       	add    $0x5670617,%eax
    1213:	2e 06                	cs (bad)
    1215:	4a 05 07 06 03 97    	rex.WX add $0xffffffff97030607,%rax
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    121b:	7b 66                	jnp    1283 <balancer_ingress+0x1283>
    121d:	05 08 f3 05 07       	add    $0x705f308,%eax
    1222:	06                   	(bad)
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1223:	3c 03                	cmp    $0x3,%al
    1225:	55                   	push   %rbp
    1226:	66 05 0f 06          	add    $0x60f,%ax
    122a:	03 2e                	add    (%rsi),%ebp
    122c:	08 20                	or     %ah,(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    122e:	05 12 32 05 29       	add    $0x29053212,%eax
    1233:	06                   	(bad)
    1234:	74 05                	je     123b <balancer_ingress+0x123b>
    1236:	07                   	(bad)
    1237:	74 05                	je     123e <balancer_ingress+0x123e>
    1239:	19 06                	sbb    %eax,(%rsi)
    123b:	30 83 68 05 1d bb    	xor    %al,-0x44e2fa98(%rbx)
    1241:	05 09 06 08 9e       	add    $0x9e080609,%eax
    1246:	04 06                	add    $0x6,%al
  if (!conn_rate_stats) {
    1248:	05 01 06 03 e2       	add    $0xe2030601,%eax
    124d:	02 2e                	add    (%rsi),%ch
    124f:	06                   	(bad)
    1250:	03 e6                	add    %esi,%esp
    1252:	7c 08                	jl     125c <balancer_ingress+0x125c>
    1254:	4a 04 00             	rex.WX add $0x0,%al
  *cur_time = bpf_ktime_get_ns();
    1257:	05 09 06 03 96       	add    $0x96030609,%eax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    125c:	05 08 4a 06 3c       	add    $0x3c064a08,%eax
    1261:	05 19 06 2f 04       	add    $0x42f0619,%eax
    1266:	06                   	(bad)
    1267:	05 01 03 83 7e       	add    $0x7e830301,%eax
    conn_rate_stats->v1 = 1;
    126c:	58                   	pop    %rax
    126d:	06                   	(bad)
    126e:	03 e6                	add    %esi,%esp
    conn_rate_stats->v2 = *cur_time;
    1270:	7c 90                	jl     1202 <balancer_ingress+0x1202>
    1272:	04 00                	add    $0x0,%al
    1274:	05 0b 06 03 98       	add    $0x9803060b,%eax
    conn_rate_stats->v1 += 1;
    1279:	05 08 4a 06 3c       	add    $0x3c064a08,%eax
    127e:	05 27 06 33 05       	add    $0x5330627,%eax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1283:	0d f3 06 3c 05       	or     $0x53c06f3,%eax
    1288:	1a 06                	sbb    (%rsi),%al
    128a:	67 05 0a 03 c8 02    	addr32 add $0x2c8030a,%eax
    1290:	90                   	nop
    1291:	05 09 06 3c 05       	add    $0x53c0609,%eax
    1296:	10 06                	adc    %al,(%rsi)
    1298:	03 27                	add    (%rdi),%esp
    129a:	66 06                	data16 (bad)
    129c:	66 66 05 08 06       	data16 add $0x608,%ax
    if (down_reals_map) {
    12a1:	08 13                	or     %dl,(%rbx)
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    12a3:	05 07 06 3c 03       	add    $0x33c0607,%eax
    12a8:	f1                   	int1
    12a9:	77 66                	ja     1311 <balancer_ingress+0x1311>
    12ab:	05 12 06 03 92       	add    $0x92030612,%eax
      if (down_real) {
    12b0:	08 82 05 15 75 05    	or     %al,0x5751505(%rdx)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    12b6:	12 06                	adc    (%rsi),%al
    12b8:	3c 05                	cmp    $0x5,%al
    12ba:	10 06                	adc    %al,(%rsi)
    12bc:	4d 06                	rex.WRB (bad)
    12be:	03 ea                	add    %edx,%ebp
    12c0:	77 08                	ja     12ca <balancer_ingress+0x12ca>
    12c2:	12 03                	adc    (%rbx),%al
    12c4:	96                   	xchg   %eax,%esi
    12c5:	08 9e 05 08 06 08    	or     %bl,0x8060805(%rsi)
    12cb:	13 05 07 06 3c 05    	adc    0x53c0607(%rip),%eax        # 53c18d8 <_license+0x53bf4ab>
        if (stats_data) {
    12d1:	12 06                	adc    (%rsi),%al
    12d3:	69 4b 05 17 b3 05 12 	imul   $0x1205b317,0x5(%rbx),%ecx
          stats_data->v1 += 1;
    12da:	59                   	pop    %rcx
    12db:	05 07 06 4a 04       	add    $0x44a0607,%eax
    12e0:	11 05 49 06 03 c0    	adc    %eax,-0x3ffcf9b7(%rip)        # ffffffffc003192f <server_id_map+0x36fc76d9592f>
    if (!dst) {
    12e6:	78 66                	js     134e <balancer_ingress+0x134e>
    12e8:	06                   	(bad)
    12e9:	03 9d 7f 66 05 07    	add    0x705667f(%rbp),%ebx
    12ef:	06                   	(bad)
    12f0:	03 e6                	add    %esi,%esp
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    12f2:	00 74 06 ba          	add    %dh,-0x46(%rsi,%rax,1)
    12f6:	05 1c 06 69 05       	add    $0x569061c,%eax
    12fb:	20 4b 05             	and    %cl,0x5(%rbx)
    12fe:	0e                   	(bad)
    12ff:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
    1305:	06                   	(bad)
    1306:	3c 03                	cmp    $0x3,%al
    1308:	92                   	xchg   %eax,%edx
    1309:	7f 66                	jg     1371 <balancer_ingress+0x1371>
    130b:	03 ee                	add    %esi,%ebp
    130d:	00 90 03 92 7f 90    	add    %dl,-0x6f806dfd(%rax)
    1313:	05 03 06 03 f1       	add    $0xf1030603,%eax
    1318:	00 02                	add    %al,(%rdx)
  if (!data_stats) {
    131a:	23 01                	and    (%rcx),%eax
    131c:	08 2f                	or     %ch,(%rdi)
    131e:	05 14 d7 05 1c       	add    $0x1c05d714,%eax
    1323:	68 05 2e 06 4a       	push   $0x4a062e05
    1328:	04 12                	add    $0x12,%al
    132a:	05 0c 06 03 45       	add    $0x4503060c,%eax
  data_stats->v1 += 1;
    132f:	2e 4f 05 12 40 05 10 	cs rex.WRXB add $0x10054012,%rax
  data_stats->v2 += pkt_bytes;
    1336:	06                   	(bad)
    1337:	90                   	nop
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1338:	05 0b 06 59 05       	add    $0x559060b,%eax
    133d:	0e                   	(bad)
    133e:	75 3d                	jne    137d <balancer_ingress+0x137d>
    1340:	05 0c 3d 04 0f       	add    $0xf043d0c,%eax
    1345:	05 0e 03 71 66       	add    $0x6671030e,%eax
    134a:	05 0b 06 f2 05       	add    $0x5f2060b,%eax
    134f:	0e                   	(bad)
    1350:	3c 05                	cmp    $0x5,%al
    1352:	0b 3c 04             	or     (%rsp,%rax,1),%edi
    1355:	00 05 00 03 48 3c    	add    %al,0x3c480300(%rip)        # 3c48165b <_license+0x3c47f22e>
    135b:	05 1b 06 03 e8       	add    $0xe803061b,%eax
    1360:	07                   	(bad)
    1361:	02 7d 01             	add    0x1(%rbp),%bh
  if (!data_stats) {
    1364:	05 0b 06 58 05       	add    $0x558060b,%eax
    1369:	0d 06 31 05 0e       	or     $0xe053106,%eax
  data_stats->v1 += 1;
    136e:	f3 05 0d 06 3c 06    	repz add $0x63c060d,%eax
  data_stats->v2 += pkt_bytes;
    1374:	69 05 00 06 03 91 78 	imul   $0x1705ba78,-0x6efcfa00(%rip),%eax        # ffffffff9103197e <server_id_map+0x36fc47d9597e>
    137b:	ba 05 17 
  if (dst->flags & F_IPV6) {
    137e:	06                   	(bad)
    137f:	03 de                	add    %esi,%ebx
    1381:	00 9e 05 07 03 4c    	add    %bl,0x4c030705(%rsi)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1387:	08 20                	or     %ah,(%rax)
    1389:	06                   	(bad)
    138a:	03 56 f2             	add    -0xe(%rsi),%edx
    138d:	05 08 06 03 2b       	add    $0x2b030608,%eax
    1392:	3c 05                	cmp    $0x5,%al
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1394:	07                   	(bad)
    1395:	06                   	(bad)
    1396:	3c 03                	cmp    $0x3,%al
    1398:	55                   	push   %rbp
    1399:	2e 05 0f 06 03 2e    	cs add $0x2e03060f,%eax
    139f:	9e                   	sahf
    13a0:	05 12 32 05 29       	add    $0x29053212,%eax
  data = (void*)(long)xdp->data;
    13a5:	06                   	(bad)
    13a6:	74 05                	je     13ad <balancer_ingress+0x13ad>
    13a8:	07                   	(bad)
  data_end = (void*)(long)xdp->data_end;
    13a9:	74 05                	je     13b0 <balancer_ingress+0x13b0>
    13ab:	19 06                	sbb    %eax,(%rsi)
  iph = data + sizeof(struct ethhdr);
    13ad:	30 75 06             	xor    %dh,0x6(%rbp)
    13b0:	03 4b 66             	add    0x66(%rbx),%ecx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    13b3:	06                   	(bad)
    13b4:	03 37                	add    (%rdi),%esi
    13b6:	4a 05 1d 9f 05 09    	rex.WX add $0x9059f1d,%rax
    13bc:	06                   	(bad)
    13bd:	74 03                	je     13c2 <balancer_ingress+0x13c2>
    13bf:	48                   	rex.W
    13c0:	2e 05 19 06 03 88    	cs add $0x88030619,%eax
    13c6:	01 66 05             	add    %esp,0x5(%rsi)
    13c9:	09 06                	or     %eax,(%rsi)
    13cb:	3c 03                	cmp    $0x3,%al
    13cd:	f8                   	clc
    13ce:	7e 2e                	jle    13fe <balancer_ingress+0x13fe>
    13d0:	04 0d                	add    $0xd,%al
    13d2:	05 0a 06 03 3f       	add    $0x3f03060a,%eax
    13d7:	74 4b                	je     1424 <balancer_ingress+0x1424>
    13d9:	05 11 03 17 4a       	add    $0x4a170311,%eax
    13de:	5a                   	pop    %rdx
    13df:	5a                   	pop    %rdx
    13e0:	05 0c 5a 06 03       	add    $0x3065a0c,%eax
    13e5:	a3 7f 74 04 00 05 1e 	movabs %eax,0x3061e050004747f
    13ec:	06 03 
  memcpy(new_eth->h_dest, cval->mac, 6);
    13ee:	8c 01                	mov    %es,(%rcx)
    13f0:	3c 05                	cmp    $0x5,%al
    13f2:	1c 06                	sbb    $0x6,%al
    13f4:	58                   	pop    %rax
    13f5:	05 07 06 59 04       	add    $0x4590607,%eax
    13fa:	0d 03 b3 7f 02       	or     $0x27fb303,%eax
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    13ff:	23 01                	and    (%rcx),%eax
    1401:	05 05 67 05 1a       	add    $0x1a056705,%eax
    1406:	03 47 2e             	add    0x2e(%rdi),%eax
    1409:	05 05 03 39 3c       	add    $0x3c390305,%eax
  new_eth->h_proto = BE_ETH_P_IP;
    140e:	05 07 2c 05 05       	add    $0x5052c07,%eax
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1413:	84 05 1a 03 47 9e    	test   %al,-0x61b8fce6(%rip)        # ffffffff9e471733 <server_id_map+0x36fc551d5733>
  iph->ihl = 5;
    1419:	05 05 03 39 58       	add    $0x58390305,%eax
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    141e:	05 1a 03 47 4a       	add    $0x4a47031a,%eax
    1423:	05 05 03 39 58       	add    $0x58390305,%eax
    1428:	05 1a 03 47 82       	add    $0x8247031a,%eax
  iph->id = 0;
    142d:	05 05 03 39 58       	add    $0x58390305,%eax
  iph->daddr = daddr;
    1432:	05 1a 03 47 66       	add    $0x6647031a,%eax
  iph->ttl = DEFAULT_TTL;
    1437:	05 05 03 39 58       	add    $0x58390305,%eax
    143c:	05 1a 03 47 66       	add    $0x6647031a,%eax
    1441:	05 05 03 39 74       	add    $0x74390305,%eax
    1446:	05 0c 03 16 2e       	add    $0x2e16030c,%eax
    144b:	05 16 06 4a 05       	add    $0x54a0616,%eax
    1450:	0c 06                	or     $0x6,%al
    1452:	3e 05 16 06 4a 05    	ds add $0x54a0616,%eax
    1458:	09 06                	or     %eax,(%rsi)
      if (pckt.flow.proto == IPPROTO_TCP) {
    145a:	3a 05 0c 32 05 16    	cmp    0x1605320c(%rip),%al        # 1605466c <_license+0x1605223f>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1460:	06                   	(bad)
    1461:	4a 05 09 06 3a 05    	rex.WX add $0x53a0609,%rax
    1467:	0c 32                	or     $0x32,%al
    1469:	05 09 48 30 05       	add    $0x5304809,%eax
    146e:	05 03 64 2e 05       	add    $0x52e6403,%eax
    1473:	07                   	(bad)
    1474:	03 1d 2e 05 1a 03    	add    0x31a052e(%rip),%ebx        # 31a19a8 <_license+0x319f57b>
        if (!lru_stats) {
    147a:	aa                   	stos   %al,%es:(%rdi)
    147b:	7f 3c                	jg     14b9 <balancer_ingress+0x14b9>
    147d:	05 07 03 d6 00       	add    $0xd60307,%eax
    1482:	58                   	pop    %rax
        if (pckt.flags & F_SYN_SET) {
    1483:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    1488:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
    148e:	58                   	pop    %rax
    148f:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
  struct real_pos_lru new_dst_lru = {};
    1494:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
    149a:	58                   	pop    %rax
    149b:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    14a0:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    14a6:	58                   	pop    %rax
    14a7:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    14ac:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
    14b2:	58                   	pop    %rax
    14b3:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    14b8:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
    14be:	3c 05                	cmp    $0x5,%al
    14c0:	1a 03                	sbb    (%rbx),%al
  if (!conn_rate_stats) {
    14c2:	aa                   	stos   %al,%es:(%rdi)
    14c3:	7f 4a                	jg     150f <balancer_ingress+0x150f>
    14c5:	05 05 03 df 00       	add    $0xdf0305,%eax
    14ca:	3c 75                	cmp    $0x75,%al
    14cc:	49 05 03 69 05 1a    	rex.WB add $0x1a056903,%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    14d2:	03 9e 7f 82 05 03    	add    0x305827f(%rsi),%ebx
    14d8:	03 e2                	add    %edx,%esp
    14da:	00 58 05             	add    %bl,0x5(%rax)
    14dd:	1a 03                	sbb    (%rbx),%al
    14df:	9e                   	sahf
    conn_rate_stats->v1 = 1;
    14e0:	7f 4a                	jg     152c <balancer_ingress+0x152c>
    14e2:	05 03 03 e2 00       	add    $0xe20303,%eax
    14e7:	58                   	pop    %rax
    conn_rate_stats->v2 = *cur_time;
    14e8:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    14ed:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    conn_rate_stats->v1 += 1;
    14f3:	58                   	pop    %rax
    14f4:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    14f9:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    14ff:	58                   	pop    %rax
    1500:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    1505:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    150b:	58                   	pop    %rax
    150c:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1511:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    1517:	3c 05                	cmp    $0x5,%al
    1519:	1a 03                	sbb    (%rbx),%al
    151b:	9e                   	sahf
    151c:	7f 4a                	jg     1568 <balancer_ingress+0x1568>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    151e:	05 03 03 e2 00       	add    $0xe20303,%eax
    1523:	3c 06                	cmp    $0x6,%al
    1525:	03 96 7f 2e 04 00    	add    0x42e7f(%rsi),%edx
      memset(pckt->flow.srcv6, 0, 16);
    152b:	05 30 06 03 8f       	add    $0x8f030630,%eax
    1530:	01 58 05             	add    %ebx,0x5(%rax)
    1533:	22 08                	and    (%rax),%cl
    1535:	13 05 15 06 58 05    	adc    0x5580615(%rip),%eax        # 5581b50 <_license+0x557f723>
    153b:	2b 74 05 10          	sub    0x10(%rbp,%rax,1),%esi
    153f:	06                   	(bad)
    1540:	30 05 09 67 05 10    	xor    %al,0x10056709(%rip)        # 10057c4f <_license+0x10055822>
  b += initval;
    1546:	2d 06 03 ee 7e       	sub    $0x7eee0306,%eax
  __jhash_final(a, b, c);
    154b:	2e 05 0b 06 03 96    	cs add $0x9603060b,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    1551:	01 9e 05 09 9f 05    	add    %ebx,0x59f0905(%rsi)
  __jhash_final(a, b, c);
    1557:	14 35                	adc    $0x35,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1559:	05 0b 4b 05 07       	add    $0x7054b0b,%eax
  __jhash_final(a, b, c);
    155e:	67 03 a5 7f 2e 05 08 	add    0x8052e7f(%ebp),%esp
  return (word << shift) | (word >> ((-shift) & 31));
    1565:	08 91 05 07 06 3c    	or     %dl,0x3c060705(%rcx)
    156b:	06                   	(bad)
    156c:	03 0a                	add    (%rdx),%ecx
    156e:	4a 05 08 08 91 05    	rex.WX add $0x5910808,%rax
    1574:	07                   	(bad)
    1575:	06                   	(bad)
    1576:	3c 05                	cmp    $0x5,%al
    1578:	00 03                	add    %al,(%rbx)
  __jhash_final(a, b, c);
    157a:	af                   	scas   %es:(%rdi),%eax
    157b:	7f 2e                	jg     15ab <balancer_ingress+0x15ab>
  return (word << shift) | (word >> ((-shift) & 31));
    157d:	05 01 06 03 c8       	add    $0xc8030601,%eax
  __jhash_final(a, b, c);
    1582:	08 c8                	or     %cl,%al
  return (word << shift) | (word >> ((-shift) & 31));
    1584:	05 07 03 de 78       	add    $0x78de0307,%eax
    1589:	08 3c 05 0f 06 66 03 	or     %bh,0x366060f(,%rax,1)
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1590:	da 7e 2e             	fidivrl 0x2e(%rsi)
    1593:	05 24 03 a6 01       	add    $0x1a60324,%eax
    1598:	3c 05                	cmp    $0x5,%al
    159a:	34 90                	xor    $0x90,%al
    159c:	03 da                	add    %edx,%ebx
    159e:	7e 90                	jle    1530 <balancer_ingress+0x1530>
    15a0:	04 11                	add    $0x11,%al
    15a2:	05 07 06 03 3a       	add    $0x3a030607,%eax
    key = RING_SIZE * (vip_info->vip_num) + hash;
    15a7:	d6                   	(bad)
    15a8:	06                   	(bad)
    15a9:	ba 05 1c 06 31       	mov    $0x31061c05,%edx
    15ae:	05 20 4b 05 0f       	add    $0xf054b20,%eax
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15b3:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
    if (!real_pos) {
    15b9:	06                   	(bad)
    15ba:	3c 03                	cmp    $0x3,%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15bc:	be 7f 2e 03 c2       	mov    $0xc2032e7f,%esi
    15c1:	00 90 03 be 7f 58    	add    %dl,0x587fbe03(%rax)
    15c7:	05 03 06 03 c5       	add    $0xc5030603,%eax
    key = *real_pos;
    15cc:	00 9e 08 2f 05 14    	add    %bl,0x14052f08(%rsi)
    if (key == 0) {
    15d2:	d7                   	xlat   %ds:(%rbx)
    15d3:	05 00 06 03 b9       	add    $0xb9030600,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
    15d8:	7f 66                	jg     1640 <balancer_ingress+0x1640>
    15da:	04 12                	add    $0x12,%al
    15dc:	05 12 06 03 25       	add    $0x25030612,%eax
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    15e1:	58                   	pop    %rax
    15e2:	04 11                	add    $0x11,%al
    15e4:	05 1d 03 27 4a       	add    $0x4a27031d,%eax
    15e9:	51                   	push   %rcx
    15ea:	04 12                	add    $0x12,%al
    15ec:	05 03 4b 05 20       	add    $0x20054b03,%eax
    15f1:	68 05 12 06 58       	push   $0x58061205
    15f6:	05 23 06 67 05       	add    $0x5670623,%eax
  if (!ch_drop_stats) {
    15fb:	15 06 3c 05 11       	adc    $0x11053c06,%eax
    1600:	06                   	(bad)
    1601:	40 05 17 67 05 15    	rex add $0x15056717,%eax
    1607:	06                   	(bad)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1608:	58                   	pop    %rax
    1609:	05 03 06 5a 08       	add    $0x85a0603,%eax
    160e:	21 04 00             	and    %eax,(%rax,%rax,1)
    1611:	05 00 06 03 a1       	add    $0xa1030600,%eax
    1616:	7f 74                	jg     168c <balancer_ingress+0x168c>
    1618:	05 1a 06 03 a7       	add    $0xa703061a,%eax
    161d:	01 c8                	add    %ecx,%eax
    161f:	05 09 06 58 05       	add    $0x5580609,%eax
  if (!ch_drop_stats) {
    1624:	19 06                	sbb    %eax,(%rsi)
    1626:	2f                   	(bad)
    1627:	05 15 5a 06 03       	add    $0x3065a15,%eax
    162c:	d6                   	(bad)
    162d:	7e 4a                	jle    1679 <balancer_ingress+0x1679>
    162f:	04 06                	add    $0x6,%al
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1631:	05 01 06 03 9f       	add    $0x9f030601,%eax
    1636:	03 58 04             	add    0x4(%rax),%ebx
    1639:	00 05 0b 03 e0 04    	add    %al,0x4e0030b(%rip)        # 4e0194a <_license+0x4dff51d>
    163f:	08 20                	or     %ah,(%rax)
    1641:	06                   	(bad)
    1642:	03 81 78 4a 05 1a    	add    0x1a054a78(%rcx),%eax
    1648:	06                   	(bad)
    1649:	03 d0                	add    %eax,%edx
    164b:	04 9e                	add    $0x9e,%al
    164d:	05 36 06 82 05       	add    $0x5820636,%eax
    1652:	47                   	rex.RXB
    1653:	4a 05 1a 06 2f 05    	rex.WX add $0x52f061a,%rax
    1659:	36 06                	ss (bad)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    165b:	66 05 47 4a          	add    $0x4a47,%ax
    165f:	05 1a 06 2f 05       	add    $0x52f061a,%eax
    1664:	36 06                	ss (bad)
    1666:	66 05 47 4a          	add    $0x4a47,%ax
    166a:	05 00 03 ae 7b       	add    $0x7bae0300,%eax
  data = (void*)(long)xdp->data;
    166f:	2e 05 28 06 03 d5    	cs add $0xd5030628,%eax
  ip6h = data + sizeof(struct ethhdr);
    1675:	04 c8                	add    $0xc8,%al
    1677:	05 35 06 74 05       	add    $0x5740635,%eax
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    167c:	36 06                	ss (bad)
    167e:	59                   	pop    %rcx
    167f:	05 2f 06 4a 05       	add    $0x54a062f,%eax
    1684:	22 06                	and    (%rsi),%al
    1686:	67 05 1c cb 06 58    	addr32 add $0x5806cb1c,%eax
    168c:	66 03 a6 7b 2e 03 da 	add    -0x25fcd185(%rsi),%sp
    1693:	04 9e                	add    $0x9e,%al
    1695:	05 0a 06 08 13       	add    $0x1308060a,%eax
    169a:	05 09 06 3c 05       	add    $0x53c0609,%eax
    169f:	14 06                	adc    $0x6,%al
    16a1:	69 06 03 a2 7b 3c    	imul   $0x3c7ba203,(%rsi),%eax
  memcpy(new_eth->h_dest, cval->mac, 6);
    16a7:	05 16 06 03 84       	add    $0x84030616,%eax
    16ac:	08 08                	or     %cl,(%rax)
    16ae:	e4 04                	in     $0x4,%al
    16b0:	0c 05                	or     $0x5,%al
    16b2:	0a 03                	or     (%rbx),%al
    16b4:	95                   	xchg   %eax,%ebp
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    16b5:	7b 08                	jnp    16bf <balancer_ingress+0x16bf>
    16b7:	82                   	(bad)
    16b8:	05 14 06 4a 05       	add    $0x54a0614,%eax
    16bd:	1e                   	(bad)
    16be:	4a 05 28 4a 05 1b    	rex.WX add $0x1b054a28,%rax
  new_eth->h_proto = BE_ETH_P_IPV6;
    16c4:	4a 05 32 3c 05 3c    	rex.WX add $0x3c053c32,%rax
    16ca:	4a 05 2f 4a 05 45    	rex.WX add $0x45054a2f,%rax
  saddr[3] = src ^ port;
    16d0:	3c 03                	cmp    $0x3,%al
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    16d2:	e7 7c                	out    %eax,$0x7c
    16d4:	3c 05                	cmp    $0x5,%al
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    16d6:	19 06                	sbb    %eax,(%rsi)
    16d8:	03 95 03 4a 05 23    	add    0x23054a03(%rbp),%edx
  ip6h->priority = (tc & 0xF0) >> 4;
    16de:	06                   	(bad)
    16df:	4a 05 2d 4a 05 37    	rex.WX add $0x37054a2d,%rax
    16e5:	4a 05 2a 4a 05 40    	rex.WX add $0x40054a2a,%rax
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    16eb:	3c 03                	cmp    $0x3,%al
  ip6h->nexthdr = proto;
    16ed:	eb 7c                	jmp    176b <balancer_ingress+0x176b>
    16ef:	3c 04                	cmp    $0x4,%al
    16f1:	00 05 19 06 03 f0    	add    %al,-0xffcf9e7(%rip)        # fffffffff0031d10 <server_id_map+0x36fca6d95d10>
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    16f7:	06                   	(bad)
    16f8:	82                   	(bad)
    16f9:	05 0b 06 2e 05       	add    $0x52e060b,%eax
    16fe:	07                   	(bad)
    16ff:	06                   	(bad)
    1700:	03 c8                	add    %eax,%ecx
    1702:	7d 66                	jge    176a <balancer_ingress+0x176a>
    1704:	06                   	(bad)
    1705:	03 c8                	add    %eax,%ecx
    1707:	7b e4                	jnp    16ed <balancer_ingress+0x16ed>
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    1709:	06                   	(bad)
    170a:	03 2a                	add    (%rdx),%ebp
    170c:	74 05                	je     1713 <balancer_ingress+0x1713>
    170e:	08 08                	or     %cl,(%rax)
    1710:	91                   	xchg   %eax,%ecx
    1711:	05 07 06 3c 03       	add    $0x33c0607,%eax
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1716:	55                   	push   %rbp
    1717:	66 05 0f 06          	add    $0x60f,%ax
    171b:	03 2e                	add    (%rsi),%ebp
    171d:	74 05                	je     1724 <balancer_ingress+0x1724>
    171f:	12 32                	adc    (%rdx),%dh
    1721:	05 29 06 74 05       	add    $0x5740629,%eax
    1726:	07                   	(bad)
    1727:	74 05                	je     172e <balancer_ingress+0x172e>
    1729:	19 06                	sbb    %eax,(%rsi)
    172b:	68 75 06 03 4b       	push   $0x4b030675
    1730:	90                   	nop
    1731:	05 1b 06 03 f5       	add    $0xf503061b,%eax
    1736:	06                   	(bad)
    1737:	08 82 05 0d 59 06    	or     %al,0x6590d05(%rdx)
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    173d:	03 8a 79 2e 05 11    	add    0x11052e79(%rdx),%ecx
    1743:	06                   	(bad)
    1744:	03 f8                	add    %eax,%edi
    1746:	06                   	(bad)
    1747:	9e                   	sahf
    1748:	05 0f 9f 05 1d       	add    $0x1d059f0f,%eax
    174d:	35 05 13 75 06       	xor    $0x6751305,%eax
    1752:	66 03 ff             	add    %di,%di
    1755:	78 4a                	js     17a1 <balancer_ingress+0x17a1>
    1757:	03 81 07 9e 05 12    	add    0x12059e07(%rcx),%eax
      if (qpr.server_id > 0) {
    175d:	06                   	(bad)
    175e:	bb 05 11 06 3c       	mov    $0x3c061105,%ebx
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1763:	03 fe                	add    %esi,%edi
    1765:	78 2e                	js     1795 <balancer_ingress+0x1795>
    1767:	04 06                	add    $0x6,%al
    1769:	05 01 06 03 9a       	add    $0x9a030601,%eax
    176e:	03 58 04             	add    0x4(%rax),%ebx
    1771:	00 05 07 03 d1 01    	add    %al,0x1d10307(%rip)        # 1d11a7e <_license+0x1d0f651>
    1777:	ac                   	lods   %ds:(%rsi),%al
    1778:	06                   	(bad)
    1779:	3c 05                	cmp    $0x5,%al
    177b:	1f                   	(bad)
    177c:	06                   	(bad)
    177d:	67 05 16 06 4a 05    	addr32 add $0x54a0616,%eax
    1783:	09 2e                	or     %ebp,(%rsi)
    if (pckt->flow.proto == IPPROTO_UDP) {
    1785:	05 23 06 03 9f       	add    $0x9f030623,%eax
    178a:	02 66 05             	add    0x5(%rsi),%ah
      new_dst_lru.atime = cur_time;
    178d:	00 06                	add    %al,(%rsi)
    178f:	03 f5                	add    %ebp,%esi
    new_dst_lru.pos = key;
    1791:	78 ba                	js     174d <balancer_ingress+0x174d>
    1793:	05 14 06 03 ef       	add    $0xef030614,%eax
    1798:	04 08                	add    $0x8,%al
BPF_MAP_OPS_INLINE(int,
    179a:	d6                   	(bad)
    179b:	05 37 03 9e 02       	add    $0x29e0337,%eax
    17a0:	2e 05 07 03 f3 7d    	cs add $0x7df30307,%eax
    17a6:	58                   	pop    %rax
    17a7:	06                   	(bad)
    17a8:	74 03                	je     17ad <balancer_ingress+0x17ad>
    17aa:	80 7b 2e 03          	cmpb   $0x3,0x2e(%rbx)
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    17ae:	80 05 9e 05 08 06 08 	addb   $0x8,0x608059e(%rip)        # 6081d53 <_license+0x607f926>
    17b5:	13 05 07 06 3c 05    	adc    0x53c0607(%rip),%eax        # 53c1dc2 <_license+0x53bf995>
    17bb:	14 06                	adc    $0x6,%al
    17bd:	35 06 03 f8 7a       	xor    $0x7af80306,%eax
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17c2:	4a 05 19 06 03 37    	rex.WX add $0x37030619,%rax
    17c8:	2e 05 1d 9f 05 09    	cs add $0x9059f1d,%eax
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17ce:	06                   	(bad)
    17cf:	66 05 17 06          	add    $0x617,%ax
    17d3:	03 bf 04 2e 05 1b    	add    0x1b052e04(%rdi),%edi
    17d9:	08 21                	or     %ah,(%rcx)
  bool vip_match = address_match && port_match && proto_match;
    17db:	05 13 06 4a 03       	add    $0x34a0613,%eax
    17e0:	88 7b 4a             	mov    %bh,0x4a(%rbx)
    17e3:	04 06                	add    $0x6,%al
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17e5:	05 01 06 03 9f       	add    $0x9f030601,%eax
    17ea:	03 58 04             	add    0x4(%rax),%ebx
    17ed:	00 05 23 03 f3 03    	add    %al,0x3f30323(%rip)        # 3f31b16 <_license+0x3f2f6e9>
    17f3:	08 20                	or     %ah,(%rax)
    17f5:	05 00 06 03 ee       	add    $0xee030600,%eax
    17fa:	78 74                	js     1870 <balancer_ingress+0x1870>
    17fc:	05 2c 06 03 94       	add    $0x9403062c,%eax
    1801:	07                   	(bad)
    1802:	4a 05 14 03 1b 58    	rex.WX add $0x581b0314,%rax
    1808:	06                   	(bad)
    1809:	03 d1                	add    %ecx,%edx
    180b:	78 58                	js     1865 <balancer_ingress+0x1865>
    if (!lru_miss_stat) {
    180d:	05 07 06 03 2a       	add    $0x2a030607,%eax
    1812:	08 82 05 08 08 91    	or     %al,-0x6ef7f7fb(%rdx)
    *lru_miss_stat += 1;
    1818:	05 07 06 3c 03       	add    $0x33c0607,%eax
    181d:	55                   	push   %rbp
    181e:	66 05 0f 06          	add    $0x60f,%ax
    1822:	03 2e                	add    (%rsi),%ebp
    1824:	74 05                	je     182b <balancer_ingress+0x182b>
    1826:	12 32                	adc    (%rdx),%dh
    1828:	05 29 06 74 05       	add    $0x5740629,%eax
    182d:	07                   	(bad)
    182e:	74 05                	je     1835 <balancer_ingress+0x1835>
    1830:	19 06                	sbb    %eax,(%rsi)
    1832:	30 75 05             	xor    %dh,0x5(%rbp)
    1835:	14 03                	adc    $0x3,%al
    1837:	ba 04 66 05 37       	mov    $0x37056604,%edx
      data_stats->v2 += 1;
    183c:	03 9e 02 2e 05 07    	add    0x7052e02(%rsi),%ebx
    1842:	03 f3                	add    %ebx,%esi
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1844:	7d 58                	jge    189e <balancer_ingress+0x189e>
    1846:	06                   	(bad)
    1847:	ac                   	lods   %ds:(%rsi),%al
    1848:	03 80 7b 2e 03 80    	add    -0x7ffcd185(%rax),%eax
    184e:	05 08 20 05 08       	add    $0x8052008,%eax
    1853:	06                   	(bad)
  if (!connId) {
    1854:	08 13                	or     %dl,(%rbx)
    1856:	05 07 06 3c 05       	add    $0x53c0607,%eax
    185b:	14 06                	adc    $0x6,%al
    185d:	35 06 03 f8 7a       	xor    $0x7af80306,%eax
    1862:	4a 05 19 06 03 37    	rex.WX add $0x37030619,%rax
    1868:	2e 05 1d 9f 05 09    	cs add $0x9059f1d,%eax
    186e:	06                   	(bad)
    186f:	66 05 17 06          	add    $0x617,%ax
    1873:	03 bf 04 2e 05 1b    	add    0x1b052e04(%rdi),%edi
    1879:	08 21                	or     %ah,(%rcx)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    187b:	05 13 06 4a 03       	add    $0x34a0613,%eax
        if (real_pos) {
    1880:	88 7b 4a             	mov    %bh,0x4a(%rbx)
    1883:	04 06                	add    $0x6,%al
    1885:	05 01 06 03 9f       	add    $0x9f030601,%eax
    188a:	03 58 04             	add    0x4(%rax),%ebx
          key = *real_pos;
    188d:	00 05 23 03 f3 03    	add    %al,0x3f30323(%rip)        # 3f31bb6 <_license+0x3f2f789>
    1893:	08 20                	or     %ah,(%rax)
    1895:	05 00 06 03 ee       	add    $0xee030600,%eax
            pckt.real_index = key;
    189a:	78 74                	js     1910 <balancer_ingress+0x1910>
    189c:	05 2c 06 03 94       	add    $0x9403062c,%eax
            dst = bpf_map_lookup_elem(&reals, &key);
    18a1:	07                   	(bad)
    18a2:	4a 05 14 03 1b 58    	rex.WX add $0x581b0314,%rax
    18a8:	06                   	(bad)
    18a9:	03 d1                	add    %ecx,%edx
    18ab:	78 66                	js     1913 <balancer_ingress+0x1913>
    18ad:	02                   	.byte 0x2
    18ae:	05                   	.byte 0x5
    18af:	00 01                	add    %al,(%rcx)
    18b1:	01                   	.byte 0x1

Disassembly of section .debug_line_str:

0000000000000000 <.debug_line_str>:
  void* data = (void*)(long)ctx->data;
   0:	2f                   	(bad)
   1:	72 6f                	jb     72 <balancer_ingress+0x72>
   3:	6f                   	outsl  %ds:(%rsi),(%dx)
   4:	74 2f                	je     35 <balancer_ingress+0x35>
   6:	57                   	push   %rdi
   7:	6f                   	outsl  %ds:(%rsi),(%dx)
   8:	72 6b                	jb     75 <balancer_ingress+0x75>
   a:	73 70                	jae    7c <balancer_ingress+0x7c>
   c:	61                   	(bad)
   d:	63 65 2f             	movsxd 0x2f(%rbp),%esp
  10:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  14:	61                   	(bad)
  15:	6e                   	outsb  %ds:(%rsi),(%dx)
  16:	2f                   	(bad)
  17:	5f                   	pop    %rdi
  void* data_end = (void*)(long)ctx->data_end;
  18:	62 75                	(bad)
  1a:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
  21:	73 
  if (data + nh_off > data_end) {
  22:	2f                   	(bad)
  23:	62                   	(bad)
  24:	70 66                	jo     8c <balancer_ingress+0x8c>
  26:	70 72                	jo     9a <balancer_ingress+0x9a>
  28:	6f                   	outsl  %ds:(%rsi),(%dx)
  29:	67 00 2e             	add    %ch,(%esi)
  2c:	2f                   	(bad)
  2d:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  eth_proto = eth->h_proto;
  31:	61                   	(bad)
  32:	6e                   	outsb  %ds:(%rsi),(%dx)
  33:	2f                   	(bad)
  34:	6c                   	insb   (%dx),%es:(%rdi)
  if (eth_proto == BE_ETH_P_IP) {
  35:	69 62 2f 62 70 66 00 	imul   $0x667062,0x2f(%rdx),%esp
  3c:	2f                   	(bad)
  3d:	75 73                	jne    b2 <balancer_ingress+0xb2>
  3f:	72 2f                	jb     70 <balancer_ingress+0x70>
  41:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  48:	2f                   	(bad)
  49:	61                   	(bad)
  4a:	73 6d                	jae    b9 <balancer_ingress+0xb9>
  4c:	2d 67 65 6e 65       	sub    $0x656e6567,%eax
  struct packet_description pckt = {};
  51:	72 69                	jb     bc <balancer_ingress+0xbc>
  53:	63 00                	movsxd (%rax),%eax
  55:	2f                   	(bad)
  56:	75 73                	jne    cb <balancer_ingress+0xcb>
  58:	72 2f                	jb     89 <balancer_ingress+0x89>
  5a:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  61:	2f                   	(bad)
  62:	6c                   	insb   (%dx),%es:(%rdi)
  63:	69 6e 75 78 00 2e 2f 	imul   $0x2f2e0078,0x75(%rsi),%ebp
  6a:	2e 68 65 61 64 65    	cs push $0x65646165
  70:	72 5f                	jb     d1 <balancer_ingress+0xd1>
  72:	6f                   	outsl  %ds:(%rsi),(%dx)
  73:	76 65                	jbe    da <balancer_ingress+0xda>
  75:	72 72                	jb     e9 <balancer_ingress+0xe9>
  77:	69 64 65 2f 36 2f 6b 	imul   $0x616b2f36,0x2f(%rbp,%riz,2),%esp
  7e:	61 
  7f:	74 72                	je     f3 <balancer_ingress+0xf3>
  81:	61                   	(bad)
  82:	6e                   	outsb  %ds:(%rsi),(%dx)
  83:	2f                   	(bad)
  84:	6c                   	insb   (%dx),%es:(%rdi)
  85:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
  struct vip_definition vip = {};
  8c:	78 5f                	js     ed <balancer_ingress+0xed>
  8e:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  95:	73 00                	jae    97 <balancer_ingress+0x97>
  97:	2e 2f                	cs (bad)
  99:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  9d:	61                   	(bad)
  9e:	6e                   	outsb  %ds:(%rsi),(%dx)
  9f:	2f                   	(bad)
    if (iph + 1 > data_end) {
  a0:	6c                   	insb   (%dx),%es:(%rdi)
  a1:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
  a8:	78 5f                	js     109 <balancer_ingress+0x109>
  aa:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
    if (iph->ihl != 5) {
  b1:	73 00                	jae    b3 <balancer_ingress+0xb3>
  b3:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  b7:	61                   	(bad)
  b8:	6e                   	outsb  %ds:(%rsi),(%dx)
    pckt->tos = iph->tos;
  b9:	2f                   	(bad)
  ba:	6c                   	insb   (%dx),%es:(%rdi)
  bb:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
    *protocol = iph->protocol;
  c2:	62 61 6c 61 6e       	(bad)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  c7:	63 65 72             	movsxd 0x72(%rbp),%esp
  ca:	2e 62                	cs (bad)
  cc:	70 66                	jo     134 <balancer_ingress+0x134>
  ce:	2e 63 00             	cs movsxd (%rax),%eax
  d1:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
  d4:	74 72                	je     148 <balancer_ingress+0x148>
  d6:	6f                   	outsl  %ds:(%rsi),(%dx)
  d7:	6c                   	insb   (%dx),%es:(%rdi)
  d8:	5f                   	pop    %rdi
  d9:	64 61                	fs (bad)
    if (*protocol == IPPROTO_ICMP) {
  db:	74 61                	je     13e <balancer_ingress+0x13e>
  dd:	5f                   	pop    %rdi
  de:	6d                   	insl   (%dx),%es:(%rdi)
  df:	61                   	(bad)
  e0:	70 73                	jo     155 <balancer_ingress+0x155>
  e2:	2e 68 00 69 6e 74    	cs push $0x746e6900
  if (icmp_hdr + 1 > data_end) {
  e8:	2d 6c 6c 36 34       	sub    $0x34366c6c,%eax
  ed:	2e 68 00 62 61 6c    	cs push $0x6c616200
  if (icmp_hdr->type == ICMP_ECHO) {
  f3:	61                   	(bad)
  f4:	6e                   	outsb  %ds:(%rsi),(%dx)
  f5:	63 65 72             	movsxd 0x72(%rbp),%esp
  f8:	5f                   	pop    %rdi
  f9:	73 74                	jae    16f <balancer_ingress+0x16f>
  fb:	72 75                	jb     172 <balancer_ingress+0x172>
  fd:	63 74 73 2e          	movsxd 0x2e(%rbx,%rsi,2),%esi
 101:	68 00 74 79 70       	push   $0x70797400
 106:	65 73 2e             	gs jae 137 <balancer_ingress+0x137>
 109:	68 00 62 61 6c       	push   $0x6c616200
  icmp_hdr->type = ICMP_ECHOREPLY;
 10e:	61                   	(bad)
 10f:	6e                   	outsb  %ds:(%rsi),(%dx)
 110:	63 65 72             	movsxd 0x72(%rbp),%esp
  icmp_hdr->checksum += 0x0008;
 113:	5f                   	pop    %rdi
 114:	6d                   	insl   (%dx),%es:(%rdi)
 115:	61                   	(bad)
 116:	70 73                	jo     18b <balancer_ingress+0x18b>
  iph->ttl = DEFAULT_TTL;
 118:	2e 68 00 62 70 66    	cs push $0x66706200
  tmp_addr = iph->daddr;
 11e:	5f                   	pop    %rdi
 11f:	68 65 6c 70 65       	push   $0x65706c65
  iph->saddr = tmp_addr;
 124:	72 73                	jb     199 <balancer_ingress+0x199>
 126:	2e 68 00 62 70 66    	cs push $0x66706200
 12c:	2e 68 00 69 6e 2e    	cs push $0x2e6e6900
 132:	68 00 69 70 76       	push   $0x76706900
 137:	36 2e 68 00 69 6e 36 	ss cs push $0x366e6900
 13e:	2e 68 00 69 70 2e    	cs push $0x2e706900
 144:	68 00 70 63 6b       	push   $0x6b637000
 149:	74 5f                	je     1aa <balancer_ingress+0x1aa>
 14b:	70 61                	jo     1ae <balancer_ingress+0x1ae>
 14d:	72 73                	jb     1c2 <balancer_ingress+0x1c2>
 14f:	69 6e 67 2e 68 00 6a 	imul   $0x6a00682e,0x67(%rsi),%ebp
 156:	68 61 73 68 2e       	push   $0x2e687361
 15b:	68 00 68 61 6e       	push   $0x6e616800
  struct packet_description pckt = {};
 160:	64 6c                	fs insb (%dx),%es:(%rdi)
 162:	65 5f                	gs pop %rdi
 164:	69 63 6d 70 2e 68 00 	imul   $0x682e70,0x6d(%rbx),%esp
 16b:	63 73 75             	movsxd 0x75(%rbx),%esi
 16e:	6d                   	insl   (%dx),%es:(%rdi)
 16f:	5f                   	pop    %rdi
 170:	68 65 6c 70 65       	push   $0x65706c65
 175:	72 73                	jb     1ea <balancer_ingress+0x1ea>
 177:	2e 68 00 62 61 6c    	cs push $0x6c616200
 17d:	61                   	(bad)
 17e:	6e                   	outsb  %ds:(%rsi),(%dx)
 17f:	63 65 72             	movsxd 0x72(%rbp),%esp
 182:	5f                   	pop    %rdi
 183:	68 65 6c 70 65       	push   $0x65706c65
 188:	72 73                	jb     1fd <balancer_ingress+0x1fd>
 18a:	2e 68 00 70 63 6b    	cs push $0x6b637000
 190:	74 5f                	je     1f1 <balancer_ingress+0x1f1>
 192:	65 6e                	outsb  %gs:(%rsi),(%dx)
 194:	63 61 70             	movsxd 0x70(%rcx),%esp
  struct vip_definition vip = {};
 197:	2e 68 00 65 6e 63    	cs push $0x636e6500
 19d:	61                   	(bad)
 19e:	70 5f                	jo     1ff <balancer_ingress+0x1ff>
 1a0:	68 65 6c 70 65       	push   $0x65706c65
 1a5:	72 73                	jb     21a <balancer_ingress+0x21a>
 1a7:	2e 68 00 69 63 6d    	cs push $0x6d636900
 1ad:	70 76                	jo     225 <balancer_ingress+0x225>
    if (ip6h + 1 > data_end) {
 1af:	36 2e 68 00 74 63 70 	ss cs push $0x70637400
 1b6:	2e 68 00 69 66 5f    	cs push $0x5f666900
    *protocol = ip6h->nexthdr;
 1bc:	65 74 68             	gs je  227 <balancer_ingress+0x227>
    pckt->flow.proto = *protocol;
 1bf:	65 72 2e             	gs jb  1f0 <balancer_ingress+0x1f0>
 1c2:	68 00 75 64 70       	push   $0x70647500
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1c7:	2e                   	cs
 1c8:	68                   	.byte 0x68
	...
