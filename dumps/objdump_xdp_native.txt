
bpf/native/balancer.bpf:     file format elf64-x86-64


Disassembly of section xdp:

0000000000000000 <balancer_ingress>:

  return XDP_TX;
}

SEC(PROG_SEC_NAME)
int balancer_ingress(struct xdp_md* ctx) {
       0:	f3 0f 1e fa          	endbr64
       4:	55                   	push   %rbp
       5:	48 89 e5             	mov    %rsp,%rbp
       8:	48 81 ec f0 17 00 00 	sub    $0x17f0,%rsp
       f:	48 89 bd 78 e8 ff ff 	mov    %rdi,-0x1788(%rbp)
  void* data = (void*)(long)ctx->data;
      16:	48 8b 85 78 e8 ff ff 	mov    -0x1788(%rbp),%rax
      1d:	48 8b 00             	mov    (%rax),%rax
      20:	48 89 85 70 e8 ff ff 	mov    %rax,-0x1790(%rbp)
  void* data_end = (void*)(long)ctx->data_end;
      27:	48 8b 85 78 e8 ff ff 	mov    -0x1788(%rbp),%rax
      2e:	48 8b 40 08          	mov    0x8(%rax),%rax
      32:	48 89 85 68 e8 ff ff 	mov    %rax,-0x1798(%rbp)
  struct ethhdr* eth = data;
      39:	48 8b 85 70 e8 ff ff 	mov    -0x1790(%rbp),%rax
      40:	48 89 85 60 e8 ff ff 	mov    %rax,-0x17a0(%rbp)
  __u32 eth_proto;
  __u32 nh_off;
  nh_off = sizeof(struct ethhdr);
      47:	c7 85 58 e8 ff ff 0e 	movl   $0xe,-0x17a8(%rbp)
      4e:	00 00 00 

  if (data + nh_off > data_end) {
      51:	48 8b 85 70 e8 ff ff 	mov    -0x1790(%rbp),%rax
      58:	8b 8d 58 e8 ff ff    	mov    -0x17a8(%rbp),%ecx
      5e:	48 01 c8             	add    %rcx,%rax
      61:	48 3b 85 68 e8 ff ff 	cmp    -0x1798(%rbp),%rax
      68:	76 0f                	jbe    79 <balancer_ingress+0x79>
    // bogus packet, len less than minimum ethernet frame size
    return XDP_DROP;
      6a:	c7 85 84 e8 ff ff 01 	movl   $0x1,-0x177c(%rbp)
      71:	00 00 00 
      74:	e9 f8 76 00 00       	jmp    7771 <balancer_ingress+0x7771>
  }

  eth_proto = eth->h_proto;
      79:	48 8b 85 60 e8 ff ff 	mov    -0x17a0(%rbp),%rax
      80:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
      84:	89 85 5c e8 ff ff    	mov    %eax,-0x17a4(%rbp)

  if (eth_proto == BE_ETH_P_IP) {
      8a:	83 bd 5c e8 ff ff 08 	cmpl   $0x8,-0x17a4(%rbp)
      91:	0f 85 39 3b 00 00    	jne    3bd0 <balancer_ingress+0x3bd0>
    return process_packet(ctx, nh_off, false);
      97:	48 8b 8d 78 e8 ff ff 	mov    -0x1788(%rbp),%rcx
      9e:	8b 85 58 e8 ff ff    	mov    -0x17a8(%rbp),%eax
      a4:	48 89 8d 08 ee ff ff 	mov    %rcx,-0x11f8(%rbp)
      ab:	48 89 85 00 ee ff ff 	mov    %rax,-0x1200(%rbp)
      b2:	c6 85 ff ed ff ff 00 	movb   $0x0,-0x1201(%rbp)
  void* data = (void*)(long)xdp->data;
      b9:	48 8b 85 08 ee ff ff 	mov    -0x11f8(%rbp),%rax
      c0:	48 8b 00             	mov    (%rax),%rax
      c3:	48 89 85 f0 ed ff ff 	mov    %rax,-0x1210(%rbp)
  void* data_end = (void*)(long)xdp->data_end;
      ca:	48 8b 85 08 ee ff ff 	mov    -0x11f8(%rbp),%rax
      d1:	48 8b 40 08          	mov    0x8(%rax),%rax
      d5:	48 89 85 e8 ed ff ff 	mov    %rax,-0x1218(%rbp)
  struct real_definition* dst = NULL;
      dc:	48 c7 85 d8 ed ff ff 	movq   $0x0,-0x1228(%rbp)
      e3:	00 00 00 00 
  struct packet_description pckt = {};
      e7:	48 8d 85 a8 ed ff ff 	lea    -0x1258(%rbp),%rax
      ee:	31 c9                	xor    %ecx,%ecx
      f0:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
      f7:	00 
      f8:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
      ff:	00 
     100:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
     107:	00 
     108:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
     10f:	00 
     110:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
     117:	00 
     118:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  struct vip_definition vip = {};
     11f:	48 8d 85 90 ed ff ff 	lea    -0x1270(%rbp),%rax
     126:	31 c9                	xor    %ecx,%ecx
     128:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
     12f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
     136:	00 
     137:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  __u32 mac_addr_pos = 0;
     13e:	c7 85 70 ed ff ff 00 	movl   $0x0,-0x1290(%rbp)
     145:	00 00 00 
  __u64 th_off = 0;
     148:	48 c7 85 60 ed ff ff 	movq   $0x0,-0x12a0(%rbp)
     14f:	00 00 00 00 
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
     153:	48 8b b5 00 ee ff ff 	mov    -0x1200(%rbp),%rsi
     15a:	48 8b 95 f0 ed ff ff 	mov    -0x1210(%rbp),%rdx
     161:	48 8b 8d e8 ed ff ff 	mov    -0x1218(%rbp),%rcx
     168:	8a 85 ff ed ff ff    	mov    -0x1201(%rbp),%al
     16e:	48 8d bd a8 ed ff ff 	lea    -0x1258(%rbp),%rdi
     175:	48 89 bd 68 ee ff ff 	mov    %rdi,-0x1198(%rbp)
     17c:	48 8d bd 7f ed ff ff 	lea    -0x1281(%rbp),%rdi
     183:	48 89 bd 60 ee ff ff 	mov    %rdi,-0x11a0(%rbp)
     18a:	48 89 b5 58 ee ff ff 	mov    %rsi,-0x11a8(%rbp)
     191:	48 8d b5 60 ed ff ff 	lea    -0x12a0(%rbp),%rsi
     198:	48 89 b5 50 ee ff ff 	mov    %rsi,-0x11b0(%rbp)
     19f:	48 8d b5 6e ed ff ff 	lea    -0x1292(%rbp),%rsi
     1a6:	48 89 b5 48 ee ff ff 	mov    %rsi,-0x11b8(%rbp)
     1ad:	48 89 95 40 ee ff ff 	mov    %rdx,-0x11c0(%rbp)
     1b4:	48 89 8d 38 ee ff ff 	mov    %rcx,-0x11c8(%rbp)
     1bb:	24 01                	and    $0x1,%al
     1bd:	88 85 37 ee ff ff    	mov    %al,-0x11c9(%rbp)
    void* data_end,
    bool is_ipv6) {
  __u64 iph_len;
  struct iphdr* iph;
  struct ipv6hdr* ip6h;
  if (is_ipv6) {
     1c3:	f6 85 37 ee ff ff 01 	testb  $0x1,-0x11c9(%rbp)
     1ca:	0f 84 7a 01 00 00    	je     34a <balancer_ingress+0x34a>
    ip6h = data + nh_off;
     1d0:	48 8b 85 40 ee ff ff 	mov    -0x11c0(%rbp),%rax
     1d7:	48 03 85 58 ee ff ff 	add    -0x11a8(%rbp),%rax
     1de:	48 89 85 18 ee ff ff 	mov    %rax,-0x11e8(%rbp)
    if (ip6h + 1 > data_end) {
     1e5:	48 8b 85 18 ee ff ff 	mov    -0x11e8(%rbp),%rax
     1ec:	48 83 c0 28          	add    $0x28,%rax
     1f0:	48 8b 8d 38 ee ff ff 	mov    -0x11c8(%rbp),%rcx
     1f7:	48 39 c8             	cmp    %rcx,%rax
     1fa:	76 0f                	jbe    20b <balancer_ingress+0x20b>
      return XDP_DROP;
     1fc:	c7 85 74 ee ff ff 01 	movl   $0x1,-0x118c(%rbp)
     203:	00 00 00 
     206:	e9 86 02 00 00       	jmp    491 <balancer_ingress+0x491>
    }

    iph_len = sizeof(struct ipv6hdr);
     20b:	48 c7 85 28 ee ff ff 	movq   $0x28,-0x11d8(%rbp)
     212:	28 00 00 00 
    *protocol = ip6h->nexthdr;
     216:	48 8b 85 18 ee ff ff 	mov    -0x11e8(%rbp),%rax
     21d:	8a 48 06             	mov    0x6(%rax),%cl
     220:	48 8b 85 60 ee ff ff 	mov    -0x11a0(%rbp),%rax
     227:	88 08                	mov    %cl,(%rax)
    pckt->flow.proto = *protocol;
     229:	48 8b 85 60 ee ff ff 	mov    -0x11a0(%rbp),%rax
     230:	8a 08                	mov    (%rax),%cl
     232:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     239:	88 48 24             	mov    %cl,0x24(%rax)

    // copy tos from the packet
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     23c:	48 8b 85 18 ee ff ff 	mov    -0x11e8(%rbp),%rax
     243:	8a 00                	mov    (%rax),%al
     245:	24 0f                	and    $0xf,%al
     247:	0f b6 c0             	movzbl %al,%eax
     24a:	c1 e0 04             	shl    $0x4,%eax
     24d:	25 f0 00 00 00       	and    $0xf0,%eax
     252:	88 c1                	mov    %al,%cl
     254:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     25b:	88 48 2d             	mov    %cl,0x2d(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     25e:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     265:	0f b6 40 2d          	movzbl 0x2d(%rax),%eax
     269:	48 8b 8d 18 ee ff ff 	mov    -0x11e8(%rbp),%rcx
     270:	0f b6 49 01          	movzbl 0x1(%rcx),%ecx
     274:	c1 f9 04             	sar    $0x4,%ecx
     277:	83 e1 0f             	and    $0xf,%ecx
     27a:	09 c8                	or     %ecx,%eax
     27c:	88 c1                	mov    %al,%cl
     27e:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     285:	88 48 2d             	mov    %cl,0x2d(%rax)

    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
     288:	48 8b 85 18 ee ff ff 	mov    -0x11e8(%rbp),%rax
     28f:	66 8b 40 04          	mov    0x4(%rax),%ax
     293:	66 c1 c0 08          	rol    $0x8,%ax
     297:	0f b7 c0             	movzwl %ax,%eax
     29a:	89 85 54 e8 ff ff    	mov    %eax,-0x17ac(%rbp)
     2a0:	8b 85 54 e8 ff ff    	mov    -0x17ac(%rbp),%eax
     2a6:	66 89 c1             	mov    %ax,%cx
     2a9:	48 8b 85 48 ee ff ff 	mov    -0x11b8(%rbp),%rax
     2b0:	66 89 08             	mov    %cx,(%rax)
    *th_off += nh_off + iph_len;
     2b3:	48 8b 8d 58 ee ff ff 	mov    -0x11a8(%rbp),%rcx
     2ba:	48 03 8d 28 ee ff ff 	add    -0x11d8(%rbp),%rcx
     2c1:	48 8b 85 50 ee ff ff 	mov    -0x11b0(%rbp),%rax
     2c8:	48 03 08             	add    (%rax),%rcx
     2cb:	48 89 08             	mov    %rcx,(%rax)
    if (*protocol == IPPROTO_FRAGMENT) {
     2ce:	48 8b 85 60 ee ff ff 	mov    -0x11a0(%rbp),%rax
     2d5:	0f b6 00             	movzbl (%rax),%eax
     2d8:	83 f8 2c             	cmp    $0x2c,%eax
     2db:	75 0f                	jne    2ec <balancer_ingress+0x2ec>
      // we drop fragmented packets
      return XDP_DROP;
     2dd:	c7 85 74 ee ff ff 01 	movl   $0x1,-0x118c(%rbp)
     2e4:	00 00 00 
     2e7:	e9 a5 01 00 00       	jmp    491 <balancer_ingress+0x491>
    } else if (*protocol == IPPROTO_ICMPV6) {
     2ec:	48 8b 85 60 ee ff ff 	mov    -0x11a0(%rbp),%rax
     2f3:	0f b6 00             	movzbl (%rax),%eax
     2f6:	83 f8 3a             	cmp    $0x3a,%eax
     2f9:	75 0f                	jne    30a <balancer_ingress+0x30a>
      return FURTHER_PROCESSING;
     2fb:	c7 85 74 ee ff ff ff 	movl   $0xffffffff,-0x118c(%rbp)
     302:	ff ff ff 
     305:	e9 87 01 00 00       	jmp    491 <balancer_ingress+0x491>
    } else {
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     30a:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     311:	48 8b 8d 18 ee ff ff 	mov    -0x11e8(%rbp),%rcx
     318:	48 8b 51 08          	mov    0x8(%rcx),%rdx
     31c:	48 89 10             	mov    %rdx,(%rax)
     31f:	48 8b 49 10          	mov    0x10(%rcx),%rcx
     323:	48 89 48 08          	mov    %rcx,0x8(%rax)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     327:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     32e:	48 8b 8d 18 ee ff ff 	mov    -0x11e8(%rbp),%rcx
     335:	48 8b 51 18          	mov    0x18(%rcx),%rdx
     339:	48 89 50 10          	mov    %rdx,0x10(%rax)
     33d:	48 8b 49 20          	mov    0x20(%rcx),%rcx
     341:	48 89 48 18          	mov    %rcx,0x18(%rax)
    }
  } else {
     345:	e9 3d 01 00 00       	jmp    487 <balancer_ingress+0x487>
    iph = data + nh_off;
     34a:	48 8b 85 40 ee ff ff 	mov    -0x11c0(%rbp),%rax
     351:	48 03 85 58 ee ff ff 	add    -0x11a8(%rbp),%rax
     358:	48 89 85 20 ee ff ff 	mov    %rax,-0x11e0(%rbp)
    if (iph + 1 > data_end) {
     35f:	48 8b 85 20 ee ff ff 	mov    -0x11e0(%rbp),%rax
     366:	48 83 c0 14          	add    $0x14,%rax
     36a:	48 8b 8d 38 ee ff ff 	mov    -0x11c8(%rbp),%rcx
     371:	48 39 c8             	cmp    %rcx,%rax
     374:	76 0f                	jbe    385 <balancer_ingress+0x385>
      return XDP_DROP;
     376:	c7 85 74 ee ff ff 01 	movl   $0x1,-0x118c(%rbp)
     37d:	00 00 00 
     380:	e9 0c 01 00 00       	jmp    491 <balancer_ingress+0x491>
    }
    // ihl contains len of ipv4 header in 32bit words
    if (iph->ihl != 5) {
     385:	48 8b 85 20 ee ff ff 	mov    -0x11e0(%rbp),%rax
     38c:	8a 00                	mov    (%rax),%al
     38e:	24 0f                	and    $0xf,%al
     390:	0f b6 c0             	movzbl %al,%eax
     393:	83 f8 05             	cmp    $0x5,%eax
     396:	74 0f                	je     3a7 <balancer_ingress+0x3a7>
      // if len of ipv4 hdr is not equal to 20bytes that means that header
      // contains ip options, and we dont support em
      return XDP_DROP;
     398:	c7 85 74 ee ff ff 01 	movl   $0x1,-0x118c(%rbp)
     39f:	00 00 00 
     3a2:	e9 ea 00 00 00       	jmp    491 <balancer_ingress+0x491>
    }
    pckt->tos = iph->tos;
     3a7:	48 8b 85 20 ee ff ff 	mov    -0x11e0(%rbp),%rax
     3ae:	8a 48 01             	mov    0x1(%rax),%cl
     3b1:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     3b8:	88 48 2d             	mov    %cl,0x2d(%rax)
    *protocol = iph->protocol;
     3bb:	48 8b 85 20 ee ff ff 	mov    -0x11e0(%rbp),%rax
     3c2:	8a 48 09             	mov    0x9(%rax),%cl
     3c5:	48 8b 85 60 ee ff ff 	mov    -0x11a0(%rbp),%rax
     3cc:	88 08                	mov    %cl,(%rax)
    pckt->flow.proto = *protocol;
     3ce:	48 8b 85 60 ee ff ff 	mov    -0x11a0(%rbp),%rax
     3d5:	8a 08                	mov    (%rax),%cl
     3d7:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     3de:	88 48 24             	mov    %cl,0x24(%rax)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
     3e1:	48 8b 85 20 ee ff ff 	mov    -0x11e0(%rbp),%rax
     3e8:	66 8b 40 02          	mov    0x2(%rax),%ax
     3ec:	66 c1 c0 08          	rol    $0x8,%ax
     3f0:	0f b7 c0             	movzwl %ax,%eax
     3f3:	89 85 50 e8 ff ff    	mov    %eax,-0x17b0(%rbp)
     3f9:	8b 85 50 e8 ff ff    	mov    -0x17b0(%rbp),%eax
     3ff:	66 89 c1             	mov    %ax,%cx
     402:	48 8b 85 48 ee ff ff 	mov    -0x11b8(%rbp),%rax
     409:	66 89 08             	mov    %cx,(%rax)
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;
     40c:	48 8b 8d 58 ee ff ff 	mov    -0x11a8(%rbp),%rcx
     413:	48 83 c1 14          	add    $0x14,%rcx
     417:	48 8b 85 50 ee ff ff 	mov    -0x11b0(%rbp),%rax
     41e:	48 03 08             	add    (%rax),%rcx
     421:	48 89 08             	mov    %rcx,(%rax)

    if (iph->frag_off & PCKT_FRAGMENTED) {
     424:	48 8b 85 20 ee ff ff 	mov    -0x11e0(%rbp),%rax
     42b:	0f b7 40 06          	movzwl 0x6(%rax),%eax
     42f:	25 3f ff 00 00       	and    $0xff3f,%eax
     434:	83 f8 00             	cmp    $0x0,%eax
     437:	74 0c                	je     445 <balancer_ingress+0x445>
      // we drop fragmented packets.
      return XDP_DROP;
     439:	c7 85 74 ee ff ff 01 	movl   $0x1,-0x118c(%rbp)
     440:	00 00 00 
     443:	eb 4c                	jmp    491 <balancer_ingress+0x491>
    }
    if (*protocol == IPPROTO_ICMP) {
     445:	48 8b 85 60 ee ff ff 	mov    -0x11a0(%rbp),%rax
     44c:	0f b6 00             	movzbl (%rax),%eax
     44f:	83 f8 01             	cmp    $0x1,%eax
     452:	75 0c                	jne    460 <balancer_ingress+0x460>
      return FURTHER_PROCESSING;
     454:	c7 85 74 ee ff ff ff 	movl   $0xffffffff,-0x118c(%rbp)
     45b:	ff ff ff 
     45e:	eb 31                	jmp    491 <balancer_ingress+0x491>
    } else {
      pckt->flow.src = iph->saddr;
     460:	48 8b 85 20 ee ff ff 	mov    -0x11e0(%rbp),%rax
     467:	8b 48 0c             	mov    0xc(%rax),%ecx
     46a:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     471:	89 08                	mov    %ecx,(%rax)
      pckt->flow.dst = iph->daddr;
     473:	48 8b 85 20 ee ff ff 	mov    -0x11e0(%rbp),%rax
     47a:	8b 48 10             	mov    0x10(%rax),%ecx
     47d:	48 8b 85 68 ee ff ff 	mov    -0x1198(%rbp),%rax
     484:	89 48 10             	mov    %ecx,0x10(%rax)
    }
  }
  return FURTHER_PROCESSING;
     487:	c7 85 74 ee ff ff ff 	movl   $0xffffffff,-0x118c(%rbp)
     48e:	ff ff ff 
}
     491:	8b 85 74 ee ff ff    	mov    -0x118c(%rbp),%eax
  action = parse_l3_headers(
     497:	89 85 78 ed ff ff    	mov    %eax,-0x1288(%rbp)
  if (action >= 0) {
     49d:	83 bd 78 ed ff ff 00 	cmpl   $0x0,-0x1288(%rbp)
     4a4:	7c 11                	jl     4b7 <balancer_ingress+0x4b7>
    return action;
     4a6:	8b 85 78 ed ff ff    	mov    -0x1288(%rbp),%eax
     4ac:	89 85 14 ee ff ff    	mov    %eax,-0x11ec(%rbp)
     4b2:	e9 08 37 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  action = handle_if_icmp(data, data_end, th_off, &pckt, protocol);
     4b7:	48 8b b5 f0 ed ff ff 	mov    -0x1210(%rbp),%rsi
     4be:	48 8b 95 e8 ed ff ff 	mov    -0x1218(%rbp),%rdx
     4c5:	48 8b 8d 60 ed ff ff 	mov    -0x12a0(%rbp),%rcx
     4cc:	8a 85 7f ed ff ff    	mov    -0x1281(%rbp),%al
     4d2:	48 89 b5 f0 ee ff ff 	mov    %rsi,-0x1110(%rbp)
     4d9:	48 89 95 e8 ee ff ff 	mov    %rdx,-0x1118(%rbp)
     4e0:	48 89 8d e0 ee ff ff 	mov    %rcx,-0x1120(%rbp)
     4e7:	48 8d 8d a8 ed ff ff 	lea    -0x1258(%rbp),%rcx
     4ee:	48 89 8d d8 ee ff ff 	mov    %rcx,-0x1128(%rbp)
     4f5:	88 85 d7 ee ff ff    	mov    %al,-0x1129(%rbp)
    void* data,
    void* data_end,
    __u64 off,
    struct packet_description* pckt,
    __u8 protocol) {
  if (protocol == IPPROTO_ICMPV6) {
     4fb:	0f b6 85 d7 ee ff ff 	movzbl -0x1129(%rbp),%eax
     502:	83 f8 3a             	cmp    $0x3a,%eax
     505:	0f 85 2f 04 00 00    	jne    93a <balancer_ingress+0x93a>
    return parse_icmpv6(data, data_end, off, pckt);
     50b:	48 8b b5 f0 ee ff ff 	mov    -0x1110(%rbp),%rsi
     512:	48 8b 95 e8 ee ff ff 	mov    -0x1118(%rbp),%rdx
     519:	48 8b 8d e0 ee ff ff 	mov    -0x1120(%rbp),%rcx
     520:	48 8b 85 d8 ee ff ff 	mov    -0x1128(%rbp),%rax
     527:	48 89 b5 38 f9 ff ff 	mov    %rsi,-0x6c8(%rbp)
     52e:	48 89 95 30 f9 ff ff 	mov    %rdx,-0x6d0(%rbp)
     535:	48 89 8d 28 f9 ff ff 	mov    %rcx,-0x6d8(%rbp)
     53c:	48 89 85 20 f9 ff ff 	mov    %rax,-0x6e0(%rbp)
  icmp_hdr = data + off;
     543:	48 8b 85 38 f9 ff ff 	mov    -0x6c8(%rbp),%rax
     54a:	48 03 85 28 f9 ff ff 	add    -0x6d8(%rbp),%rax
     551:	48 89 85 18 f9 ff ff 	mov    %rax,-0x6e8(%rbp)
  if (icmp_hdr + 1 > data_end) {
     558:	48 8b 85 18 f9 ff ff 	mov    -0x6e8(%rbp),%rax
     55f:	48 83 c0 08          	add    $0x8,%rax
     563:	48 8b 8d 30 f9 ff ff 	mov    -0x6d0(%rbp),%rcx
     56a:	48 39 c8             	cmp    %rcx,%rax
     56d:	76 0f                	jbe    57e <balancer_ingress+0x57e>
    return XDP_DROP;
     56f:	c7 85 40 f9 ff ff 01 	movl   $0x1,-0x6c0(%rbp)
     576:	00 00 00 
     579:	e9 ab 03 00 00       	jmp    929 <balancer_ingress+0x929>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     57e:	48 8b 85 18 f9 ff ff 	mov    -0x6e8(%rbp),%rax
     585:	0f b6 00             	movzbl (%rax),%eax
     588:	3d 80 00 00 00       	cmp    $0x80,%eax
     58d:	0f 85 b4 01 00 00    	jne    747 <balancer_ingress+0x747>
    return send_icmp6_reply(data, data_end);
     593:	48 8b 8d 38 f9 ff ff 	mov    -0x6c8(%rbp),%rcx
     59a:	48 8b 85 30 f9 ff ff 	mov    -0x6d0(%rbp),%rax
     5a1:	48 89 8d 48 fa ff ff 	mov    %rcx,-0x5b8(%rbp)
     5a8:	48 89 85 40 fa ff ff 	mov    %rax,-0x5c0(%rbp)
  __u64 off = 0;
     5af:	48 c7 85 18 fa ff ff 	movq   $0x0,-0x5e8(%rbp)
     5b6:	00 00 00 00 
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     5ba:	48 8b 85 48 fa ff ff 	mov    -0x5b8(%rbp),%rax
     5c1:	48 83 c0 0e          	add    $0xe,%rax
     5c5:	48 83 c0 28          	add    $0x28,%rax
     5c9:	48 83 c0 08          	add    $0x8,%rax
       sizeof(struct icmp6hdr)) > data_end) {
     5cd:	48 3b 85 40 fa ff ff 	cmp    -0x5c0(%rbp),%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     5d4:	76 0f                	jbe    5e5 <balancer_ingress+0x5e5>
    return XDP_DROP;
     5d6:	c7 85 54 fa ff ff 01 	movl   $0x1,-0x5ac(%rbp)
     5dd:	00 00 00 
     5e0:	e9 51 01 00 00       	jmp    736 <balancer_ingress+0x736>
  off += sizeof(struct ethhdr);
     5e5:	48 8b 85 18 fa ff ff 	mov    -0x5e8(%rbp),%rax
     5ec:	48 83 c0 0e          	add    $0xe,%rax
     5f0:	48 89 85 18 fa ff ff 	mov    %rax,-0x5e8(%rbp)
  ip6h = data + off;
     5f7:	48 8b 85 48 fa ff ff 	mov    -0x5b8(%rbp),%rax
     5fe:	48 03 85 18 fa ff ff 	add    -0x5e8(%rbp),%rax
     605:	48 89 85 38 fa ff ff 	mov    %rax,-0x5c8(%rbp)
  off += sizeof(struct ipv6hdr);
     60c:	48 8b 85 18 fa ff ff 	mov    -0x5e8(%rbp),%rax
     613:	48 83 c0 28          	add    $0x28,%rax
     617:	48 89 85 18 fa ff ff 	mov    %rax,-0x5e8(%rbp)
  icmp_hdr = data + off;
     61e:	48 8b 85 48 fa ff ff 	mov    -0x5b8(%rbp),%rax
     625:	48 03 85 18 fa ff ff 	add    -0x5e8(%rbp),%rax
     62c:	48 89 85 30 fa ff ff 	mov    %rax,-0x5d0(%rbp)
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
     633:	48 8b 85 30 fa ff ff 	mov    -0x5d0(%rbp),%rax
     63a:	c6 00 81             	movb   $0x81,(%rax)
  icmp_hdr->icmp6_cksum -= 0x0001;
     63d:	48 8b 85 30 fa ff ff 	mov    -0x5d0(%rbp),%rax
     644:	0f b7 48 02          	movzwl 0x2(%rax),%ecx
     648:	83 e9 01             	sub    $0x1,%ecx
     64b:	66 89 48 02          	mov    %cx,0x2(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
     64f:	48 8b 85 38 fa ff ff 	mov    -0x5c8(%rbp),%rax
     656:	c6 40 07 40          	movb   $0x40,0x7(%rax)
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
     65a:	48 8b 85 38 fa ff ff 	mov    -0x5c8(%rbp),%rax
     661:	48 8b 48 08          	mov    0x8(%rax),%rcx
     665:	48 89 8d 20 fa ff ff 	mov    %rcx,-0x5e0(%rbp)
     66c:	48 8b 40 10          	mov    0x10(%rax),%rax
     670:	48 89 85 28 fa ff ff 	mov    %rax,-0x5d8(%rbp)
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
     677:	48 8b 85 38 fa ff ff 	mov    -0x5c8(%rbp),%rax
     67e:	48 8b 8d 38 fa ff ff 	mov    -0x5c8(%rbp),%rcx
     685:	48 8b 51 18          	mov    0x18(%rcx),%rdx
     689:	48 89 50 08          	mov    %rdx,0x8(%rax)
     68d:	48 8b 49 20          	mov    0x20(%rcx),%rcx
     691:	48 89 48 10          	mov    %rcx,0x10(%rax)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
     695:	48 8b 85 38 fa ff ff 	mov    -0x5c8(%rbp),%rax
     69c:	48 8b 8d 20 fa ff ff 	mov    -0x5e0(%rbp),%rcx
     6a3:	48 89 48 18          	mov    %rcx,0x18(%rax)
     6a7:	48 8b 8d 28 fa ff ff 	mov    -0x5d8(%rbp),%rcx
     6ae:	48 89 48 20          	mov    %rcx,0x20(%rax)
  return swap_mac_and_send(data, data_end);
     6b2:	48 8b 8d 48 fa ff ff 	mov    -0x5b8(%rbp),%rcx
     6b9:	48 8b 85 40 fa ff ff 	mov    -0x5c0(%rbp),%rax
     6c0:	48 89 8d d0 fa ff ff 	mov    %rcx,-0x530(%rbp)
     6c7:	48 89 85 c8 fa ff ff 	mov    %rax,-0x538(%rbp)
  eth = data;
     6ce:	48 8b 85 d0 fa ff ff 	mov    -0x530(%rbp),%rax
     6d5:	48 89 85 c0 fa ff ff 	mov    %rax,-0x540(%rbp)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     6dc:	48 8b 85 c0 fa ff ff 	mov    -0x540(%rbp),%rax
     6e3:	8b 48 06             	mov    0x6(%rax),%ecx
     6e6:	89 8d ba fa ff ff    	mov    %ecx,-0x546(%rbp)
     6ec:	66 8b 40 0a          	mov    0xa(%rax),%ax
     6f0:	66 89 85 be fa ff ff 	mov    %ax,-0x542(%rbp)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     6f7:	48 8b 85 c0 fa ff ff 	mov    -0x540(%rbp),%rax
     6fe:	48 8b 8d c0 fa ff ff 	mov    -0x540(%rbp),%rcx
     705:	8b 11                	mov    (%rcx),%edx
     707:	89 50 06             	mov    %edx,0x6(%rax)
     70a:	66 8b 49 04          	mov    0x4(%rcx),%cx
     70e:	66 89 48 0a          	mov    %cx,0xa(%rax)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     712:	48 8b 85 c0 fa ff ff 	mov    -0x540(%rbp),%rax
     719:	8b 8d ba fa ff ff    	mov    -0x546(%rbp),%ecx
     71f:	89 08                	mov    %ecx,(%rax)
     721:	66 8b 8d be fa ff ff 	mov    -0x542(%rbp),%cx
     728:	66 89 48 04          	mov    %cx,0x4(%rax)
  return swap_mac_and_send(data, data_end);
     72c:	c7 85 54 fa ff ff 03 	movl   $0x3,-0x5ac(%rbp)
     733:	00 00 00 
}
     736:	8b 85 54 fa ff ff    	mov    -0x5ac(%rbp),%eax
    return send_icmp6_reply(data, data_end);
     73c:	89 85 40 f9 ff ff    	mov    %eax,-0x6c0(%rbp)
     742:	e9 e2 01 00 00       	jmp    929 <balancer_ingress+0x929>
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
     747:	48 8b 85 18 f9 ff ff 	mov    -0x6e8(%rbp),%rax
     74e:	0f b6 00             	movzbl (%rax),%eax
     751:	83 f8 02             	cmp    $0x2,%eax
     754:	74 1e                	je     774 <balancer_ingress+0x774>
      (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {
     756:	48 8b 85 18 f9 ff ff 	mov    -0x6e8(%rbp),%rax
     75d:	0f b6 00             	movzbl (%rax),%eax
     760:	83 f8 01             	cmp    $0x1,%eax
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
     763:	74 0f                	je     774 <balancer_ingress+0x774>
    return XDP_PASS;
     765:	c7 85 40 f9 ff ff 02 	movl   $0x2,-0x6c0(%rbp)
     76c:	00 00 00 
     76f:	e9 b5 01 00 00       	jmp    929 <balancer_ingress+0x929>
  if (icmp_hdr->icmp6_type == ICMPV6_PKT_TOOBIG) {
     774:	48 8b 85 18 f9 ff ff 	mov    -0x6e8(%rbp),%rax
     77b:	0f b6 00             	movzbl (%rax),%eax
     77e:	83 f8 02             	cmp    $0x2,%eax
     781:	0f 85 ee 00 00 00    	jne    875 <balancer_ingress+0x875>
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     787:	c7 85 0c f9 ff ff 0c 	movl   $0x20c,-0x6f4(%rbp)
     78e:	02 00 00 
        bpf_map_lookup_elem(&stats, &stats_key);
     791:	48 c7 85 f8 f8 ff ff 	movq   $0x0,-0x708(%rbp)
     798:	00 00 00 00 
     79c:	c7 85 f4 f8 ff ff 02 	movl   $0x2,-0x70c(%rbp)
     7a3:	00 00 00 
     7a6:	8b 85 0c f9 ff ff    	mov    -0x6f4(%rbp),%eax
     7ac:	89 85 f0 f8 ff ff    	mov    %eax,-0x710(%rbp)
     7b2:	c7 85 ec f8 ff ff 02 	movl   $0x2,-0x714(%rbp)
     7b9:	00 00 00 
     7bc:	c7 85 e8 f8 ff ff 08 	movl   $0x8,-0x718(%rbp)
     7c3:	00 00 00 
     7c6:	83 bd f0 f8 ff ff 02 	cmpl   $0x2,-0x710(%rbp)
     7cd:	73 21                	jae    7f0 <balancer_ingress+0x7f0>
     7cf:	8b 85 f0 f8 ff ff    	mov    -0x710(%rbp),%eax
     7d5:	89 c1                	mov    %eax,%ecx
     7d7:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
     7de:	88 ff ff 
     7e1:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
     7e8:	00 
     7e9:	48 89 85 f8 f8 ff ff 	mov    %rax,-0x708(%rbp)
     7f0:	48 8b 85 f8 f8 ff ff 	mov    -0x708(%rbp),%rax
     7f7:	48 89 85 e0 f8 ff ff 	mov    %rax,-0x720(%rbp)
     7fe:	48 8b 85 e0 f8 ff ff 	mov    -0x720(%rbp),%rax
    struct lb_stats* icmp_ptb_v6_stats =
     805:	48 89 85 00 f9 ff ff 	mov    %rax,-0x700(%rbp)
    if (!icmp_ptb_v6_stats) {
     80c:	48 83 bd 00 f9 ff ff 	cmpq   $0x0,-0x700(%rbp)
     813:	00 
     814:	75 0f                	jne    825 <balancer_ingress+0x825>
      return XDP_DROP;
     816:	c7 85 40 f9 ff ff 01 	movl   $0x1,-0x6c0(%rbp)
     81d:	00 00 00 
     820:	e9 04 01 00 00       	jmp    929 <balancer_ingress+0x929>
    icmp_ptb_v6_stats->v1 += 1;
     825:	48 8b 85 00 f9 ff ff 	mov    -0x700(%rbp),%rax
     82c:	48 8b 08             	mov    (%rax),%rcx
     82f:	48 83 c1 01          	add    $0x1,%rcx
     833:	48 89 08             	mov    %rcx,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     836:	48 8b 85 18 f9 ff ff 	mov    -0x6e8(%rbp),%rax
     83d:	8b 40 04             	mov    0x4(%rax),%eax
     840:	0f c8                	bswap  %eax
     842:	89 85 4c e8 ff ff    	mov    %eax,-0x17b4(%rbp)
     848:	8b 85 4c e8 ff ff    	mov    -0x17b4(%rbp),%eax
     84e:	89 85 dc f8 ff ff    	mov    %eax,-0x724(%rbp)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     854:	81 bd dc f8 ff ff 00 	cmpl   $0x500,-0x724(%rbp)
     85b:	05 00 00 
     85e:	73 13                	jae    873 <balancer_ingress+0x873>
      icmp_ptb_v6_stats->v2 += 1;
     860:	48 8b 85 00 f9 ff ff 	mov    -0x700(%rbp),%rax
     867:	48 8b 48 08          	mov    0x8(%rax),%rcx
     86b:	48 83 c1 01          	add    $0x1,%rcx
     86f:	48 89 48 08          	mov    %rcx,0x8(%rax)
  }
     873:	eb 00                	jmp    875 <balancer_ingress+0x875>
  off += sizeof(struct icmp6hdr);
     875:	48 8b 85 28 f9 ff ff 	mov    -0x6d8(%rbp),%rax
     87c:	48 83 c0 08          	add    $0x8,%rax
     880:	48 89 85 28 f9 ff ff 	mov    %rax,-0x6d8(%rbp)
  ip6h = data + off;
     887:	48 8b 85 38 f9 ff ff 	mov    -0x6c8(%rbp),%rax
     88e:	48 03 85 28 f9 ff ff 	add    -0x6d8(%rbp),%rax
     895:	48 89 85 10 f9 ff ff 	mov    %rax,-0x6f0(%rbp)
  if (ip6h + 1 > data_end) {
     89c:	48 8b 85 10 f9 ff ff 	mov    -0x6f0(%rbp),%rax
     8a3:	48 83 c0 28          	add    $0x28,%rax
     8a7:	48 8b 8d 30 f9 ff ff 	mov    -0x6d0(%rbp),%rcx
     8ae:	48 39 c8             	cmp    %rcx,%rax
     8b1:	76 0c                	jbe    8bf <balancer_ingress+0x8bf>
    return XDP_DROP;
     8b3:	c7 85 40 f9 ff ff 01 	movl   $0x1,-0x6c0(%rbp)
     8ba:	00 00 00 
     8bd:	eb 6a                	jmp    929 <balancer_ingress+0x929>
  pckt->flow.proto = ip6h->nexthdr;
     8bf:	48 8b 85 10 f9 ff ff 	mov    -0x6f0(%rbp),%rax
     8c6:	8a 48 06             	mov    0x6(%rax),%cl
     8c9:	48 8b 85 20 f9 ff ff 	mov    -0x6e0(%rbp),%rax
     8d0:	88 48 24             	mov    %cl,0x24(%rax)
  pckt->flags |= F_ICMP;
     8d3:	48 8b 85 20 f9 ff ff 	mov    -0x6e0(%rbp),%rax
     8da:	0f b6 48 2c          	movzbl 0x2c(%rax),%ecx
     8de:	83 c9 01             	or     $0x1,%ecx
     8e1:	88 48 2c             	mov    %cl,0x2c(%rax)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     8e4:	48 8b 85 20 f9 ff ff 	mov    -0x6e0(%rbp),%rax
     8eb:	48 8b 8d 10 f9 ff ff 	mov    -0x6f0(%rbp),%rcx
     8f2:	48 8b 51 18          	mov    0x18(%rcx),%rdx
     8f6:	48 89 10             	mov    %rdx,(%rax)
     8f9:	48 8b 49 20          	mov    0x20(%rcx),%rcx
     8fd:	48 89 48 08          	mov    %rcx,0x8(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     901:	48 8b 85 20 f9 ff ff 	mov    -0x6e0(%rbp),%rax
     908:	48 8b 8d 10 f9 ff ff 	mov    -0x6f0(%rbp),%rcx
     90f:	48 8b 51 08          	mov    0x8(%rcx),%rdx
     913:	48 89 50 10          	mov    %rdx,0x10(%rax)
     917:	48 8b 49 10          	mov    0x10(%rcx),%rcx
     91b:	48 89 48 18          	mov    %rcx,0x18(%rax)
  return FURTHER_PROCESSING;
     91f:	c7 85 40 f9 ff ff ff 	movl   $0xffffffff,-0x6c0(%rbp)
     926:	ff ff ff 
}
     929:	8b 85 40 f9 ff ff    	mov    -0x6c0(%rbp),%eax
    return parse_icmpv6(data, data_end, off, pckt);
     92f:	89 85 f8 ee ff ff    	mov    %eax,-0x1108(%rbp)
     935:	e9 58 05 00 00       	jmp    e92 <balancer_ingress+0xe92>
  } else if (protocol == IPPROTO_ICMP) {
     93a:	0f b6 85 d7 ee ff ff 	movzbl -0x1129(%rbp),%eax
     941:	83 f8 01             	cmp    $0x1,%eax
     944:	0f 85 3e 05 00 00    	jne    e88 <balancer_ingress+0xe88>
    return parse_icmp(data, data_end, off, pckt);
     94a:	48 8b b5 f0 ee ff ff 	mov    -0x1110(%rbp),%rsi
     951:	48 8b 95 e8 ee ff ff 	mov    -0x1118(%rbp),%rdx
     958:	48 8b 8d e0 ee ff ff 	mov    -0x1120(%rbp),%rcx
     95f:	48 8b 85 d8 ee ff ff 	mov    -0x1128(%rbp),%rax
     966:	48 89 b5 08 fa ff ff 	mov    %rsi,-0x5f8(%rbp)
     96d:	48 89 95 00 fa ff ff 	mov    %rdx,-0x600(%rbp)
     974:	48 89 8d f8 f9 ff ff 	mov    %rcx,-0x608(%rbp)
     97b:	48 89 85 f0 f9 ff ff 	mov    %rax,-0x610(%rbp)
  icmp_hdr = data + off;
     982:	48 8b 85 08 fa ff ff 	mov    -0x5f8(%rbp),%rax
     989:	48 03 85 f8 f9 ff ff 	add    -0x608(%rbp),%rax
     990:	48 89 85 e8 f9 ff ff 	mov    %rax,-0x618(%rbp)
  if (icmp_hdr + 1 > data_end) {
     997:	48 8b 85 e8 f9 ff ff 	mov    -0x618(%rbp),%rax
     99e:	48 83 c0 08          	add    $0x8,%rax
     9a2:	48 8b 8d 00 fa ff ff 	mov    -0x600(%rbp),%rcx
     9a9:	48 39 c8             	cmp    %rcx,%rax
     9ac:	76 0f                	jbe    9bd <balancer_ingress+0x9bd>
    return XDP_DROP;
     9ae:	c7 85 14 fa ff ff 01 	movl   $0x1,-0x5ec(%rbp)
     9b5:	00 00 00 
     9b8:	e9 bd 04 00 00       	jmp    e7a <balancer_ingress+0xe7a>
  if (icmp_hdr->type == ICMP_ECHO) {
     9bd:	48 8b 85 e8 f9 ff ff 	mov    -0x618(%rbp),%rax
     9c4:	0f b6 00             	movzbl (%rax),%eax
     9c7:	83 f8 08             	cmp    $0x8,%eax
     9ca:	0f 85 c2 02 00 00    	jne    c92 <balancer_ingress+0xc92>
    return send_icmp_reply(data, data_end);
     9d0:	48 8b 8d 08 fa ff ff 	mov    -0x5f8(%rbp),%rcx
     9d7:	48 8b 85 00 fa ff ff 	mov    -0x600(%rbp),%rax
     9de:	48 89 8d 08 fb ff ff 	mov    %rcx,-0x4f8(%rbp)
     9e5:	48 89 85 00 fb ff ff 	mov    %rax,-0x500(%rbp)
  __u32 tmp_addr = 0;
     9ec:	c7 85 ec fa ff ff 00 	movl   $0x0,-0x514(%rbp)
     9f3:	00 00 00 
  __u64 csum = 0;
     9f6:	48 c7 85 e0 fa ff ff 	movq   $0x0,-0x520(%rbp)
     9fd:	00 00 00 00 
  __u64 off = 0;
     a01:	48 c7 85 d8 fa ff ff 	movq   $0x0,-0x528(%rbp)
     a08:	00 00 00 00 
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     a0c:	48 8b 85 08 fb ff ff 	mov    -0x4f8(%rbp),%rax
     a13:	48 83 c0 0e          	add    $0xe,%rax
     a17:	48 83 c0 14          	add    $0x14,%rax
     a1b:	48 83 c0 08          	add    $0x8,%rax
       sizeof(struct icmphdr)) > data_end) {
     a1f:	48 3b 85 00 fb ff ff 	cmp    -0x500(%rbp),%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     a26:	76 0f                	jbe    a37 <balancer_ingress+0xa37>
    return XDP_DROP;
     a28:	c7 85 14 fb ff ff 01 	movl   $0x1,-0x4ec(%rbp)
     a2f:	00 00 00 
     a32:	e9 4a 02 00 00       	jmp    c81 <balancer_ingress+0xc81>
  off += sizeof(struct ethhdr);
     a37:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
     a3e:	48 83 c0 0e          	add    $0xe,%rax
     a42:	48 89 85 d8 fa ff ff 	mov    %rax,-0x528(%rbp)
  iph = data + off;
     a49:	48 8b 85 08 fb ff ff 	mov    -0x4f8(%rbp),%rax
     a50:	48 03 85 d8 fa ff ff 	add    -0x528(%rbp),%rax
     a57:	48 89 85 f8 fa ff ff 	mov    %rax,-0x508(%rbp)
  off += sizeof(struct iphdr);
     a5e:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
     a65:	48 83 c0 14          	add    $0x14,%rax
     a69:	48 89 85 d8 fa ff ff 	mov    %rax,-0x528(%rbp)
  icmp_hdr = data + off;
     a70:	48 8b 85 08 fb ff ff 	mov    -0x4f8(%rbp),%rax
     a77:	48 03 85 d8 fa ff ff 	add    -0x528(%rbp),%rax
     a7e:	48 89 85 f0 fa ff ff 	mov    %rax,-0x510(%rbp)
  icmp_hdr->type = ICMP_ECHOREPLY;
     a85:	48 8b 85 f0 fa ff ff 	mov    -0x510(%rbp),%rax
     a8c:	c6 00 00             	movb   $0x0,(%rax)
  icmp_hdr->checksum += 0x0008;
     a8f:	48 8b 85 f0 fa ff ff 	mov    -0x510(%rbp),%rax
     a96:	0f b7 48 02          	movzwl 0x2(%rax),%ecx
     a9a:	83 c1 08             	add    $0x8,%ecx
     a9d:	66 89 48 02          	mov    %cx,0x2(%rax)
  iph->ttl = DEFAULT_TTL;
     aa1:	48 8b 85 f8 fa ff ff 	mov    -0x508(%rbp),%rax
     aa8:	c6 40 08 40          	movb   $0x40,0x8(%rax)
  tmp_addr = iph->daddr;
     aac:	48 8b 85 f8 fa ff ff 	mov    -0x508(%rbp),%rax
     ab3:	8b 40 10             	mov    0x10(%rax),%eax
     ab6:	89 85 ec fa ff ff    	mov    %eax,-0x514(%rbp)
  iph->daddr = iph->saddr;
     abc:	48 8b 85 f8 fa ff ff 	mov    -0x508(%rbp),%rax
     ac3:	8b 48 0c             	mov    0xc(%rax),%ecx
     ac6:	48 8b 85 f8 fa ff ff 	mov    -0x508(%rbp),%rax
     acd:	89 48 10             	mov    %ecx,0x10(%rax)
  iph->saddr = tmp_addr;
     ad0:	8b 8d ec fa ff ff    	mov    -0x514(%rbp),%ecx
     ad6:	48 8b 85 f8 fa ff ff 	mov    -0x508(%rbp),%rax
     add:	89 48 0c             	mov    %ecx,0xc(%rax)
  iph->check = 0;
     ae0:	48 8b 85 f8 fa ff ff 	mov    -0x508(%rbp),%rax
     ae7:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  ipv4_csum_inline(iph, &csum);
     aed:	48 8b 85 f8 fa ff ff 	mov    -0x508(%rbp),%rax
     af4:	48 89 85 d0 fb ff ff 	mov    %rax,-0x430(%rbp)
     afb:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
     b02:	48 89 85 c8 fb ff ff 	mov    %rax,-0x438(%rbp)
}

__attribute__((__always_inline__)) static inline void ipv4_csum_inline(
    void* iph,
    __u64* csum) {
  __u16* next_iph_u16 = (__u16*)iph;
     b09:	48 8b 85 d0 fb ff ff 	mov    -0x430(%rbp),%rax
     b10:	48 89 85 c0 fb ff ff 	mov    %rax,-0x440(%rbp)
#pragma clang loop unroll(full)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
     b17:	c7 85 bc fb ff ff 00 	movl   $0x0,-0x444(%rbp)
     b1e:	00 00 00 
     b21:	48 63 85 bc fb ff ff 	movslq -0x444(%rbp),%rax
     b28:	48 83 f8 0a          	cmp    $0xa,%rax
     b2c:	73 38                	jae    b66 <balancer_ingress+0xb66>
    *csum += *next_iph_u16++;
     b2e:	48 8b 85 c0 fb ff ff 	mov    -0x440(%rbp),%rax
     b35:	48 89 c1             	mov    %rax,%rcx
     b38:	48 83 c1 02          	add    $0x2,%rcx
     b3c:	48 89 8d c0 fb ff ff 	mov    %rcx,-0x440(%rbp)
     b43:	0f b7 00             	movzwl (%rax),%eax
     b46:	89 c1                	mov    %eax,%ecx
     b48:	48 8b 85 c8 fb ff ff 	mov    -0x438(%rbp),%rax
     b4f:	48 03 08             	add    (%rax),%rcx
     b52:	48 89 08             	mov    %rcx,(%rax)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
     b55:	8b 85 bc fb ff ff    	mov    -0x444(%rbp),%eax
     b5b:	83 c0 01             	add    $0x1,%eax
     b5e:	89 85 bc fb ff ff    	mov    %eax,-0x444(%rbp)
     b64:	eb bb                	jmp    b21 <balancer_ingress+0xb21>
  }
  *csum = csum_fold_helper(*csum);
     b66:	48 8b 85 c8 fb ff ff 	mov    -0x438(%rbp),%rax
     b6d:	48 8b 00             	mov    (%rax),%rax
     b70:	48 89 85 e0 fb ff ff 	mov    %rax,-0x420(%rbp)
  for (i = 0; i < 4; i++) {
     b77:	c7 85 dc fb ff ff 00 	movl   $0x0,-0x424(%rbp)
     b7e:	00 00 00 
     b81:	83 bd dc fb ff ff 04 	cmpl   $0x4,-0x424(%rbp)
     b88:	7d 44                	jge    bce <balancer_ingress+0xbce>
    if (csum >> 16)
     b8a:	48 8b 85 e0 fb ff ff 	mov    -0x420(%rbp),%rax
     b91:	48 c1 e8 10          	shr    $0x10,%rax
     b95:	48 83 f8 00          	cmp    $0x0,%rax
     b99:	74 22                	je     bbd <balancer_ingress+0xbbd>
      csum = (csum & 0xffff) + (csum >> 16);
     b9b:	48 8b 85 e0 fb ff ff 	mov    -0x420(%rbp),%rax
     ba2:	48 25 ff ff 00 00    	and    $0xffff,%rax
     ba8:	48 8b 8d e0 fb ff ff 	mov    -0x420(%rbp),%rcx
     baf:	48 c1 e9 10          	shr    $0x10,%rcx
     bb3:	48 01 c8             	add    %rcx,%rax
     bb6:	48 89 85 e0 fb ff ff 	mov    %rax,-0x420(%rbp)
  for (i = 0; i < 4; i++) {
     bbd:	8b 85 dc fb ff ff    	mov    -0x424(%rbp),%eax
     bc3:	83 c0 01             	add    $0x1,%eax
     bc6:	89 85 dc fb ff ff    	mov    %eax,-0x424(%rbp)
     bcc:	eb b3                	jmp    b81 <balancer_ingress+0xb81>
  return ~csum;
     bce:	48 8b 85 e0 fb ff ff 	mov    -0x420(%rbp),%rax
     bd5:	48 83 f0 ff          	xor    $0xffffffffffffffff,%rax
  *csum = csum_fold_helper(*csum);
     bd9:	0f b7 c0             	movzwl %ax,%eax
     bdc:	89 c1                	mov    %eax,%ecx
     bde:	48 8b 85 c8 fb ff ff 	mov    -0x438(%rbp),%rax
     be5:	48 89 08             	mov    %rcx,(%rax)
  iph->check = csum;
     be8:	48 8b 85 e0 fa ff ff 	mov    -0x520(%rbp),%rax
     bef:	66 89 c1             	mov    %ax,%cx
     bf2:	48 8b 85 f8 fa ff ff 	mov    -0x508(%rbp),%rax
     bf9:	66 89 48 0a          	mov    %cx,0xa(%rax)
  return swap_mac_and_send(data, data_end);
     bfd:	48 8b 8d 08 fb ff ff 	mov    -0x4f8(%rbp),%rcx
     c04:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
     c0b:	48 89 8d 30 fb ff ff 	mov    %rcx,-0x4d0(%rbp)
     c12:	48 89 85 28 fb ff ff 	mov    %rax,-0x4d8(%rbp)
  eth = data;
     c19:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
     c20:	48 89 85 20 fb ff ff 	mov    %rax,-0x4e0(%rbp)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     c27:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
     c2e:	8b 48 06             	mov    0x6(%rax),%ecx
     c31:	89 8d 1a fb ff ff    	mov    %ecx,-0x4e6(%rbp)
     c37:	66 8b 40 0a          	mov    0xa(%rax),%ax
     c3b:	66 89 85 1e fb ff ff 	mov    %ax,-0x4e2(%rbp)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     c42:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
     c49:	48 8b 8d 20 fb ff ff 	mov    -0x4e0(%rbp),%rcx
     c50:	8b 11                	mov    (%rcx),%edx
     c52:	89 50 06             	mov    %edx,0x6(%rax)
     c55:	66 8b 49 04          	mov    0x4(%rcx),%cx
     c59:	66 89 48 0a          	mov    %cx,0xa(%rax)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     c5d:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
     c64:	8b 8d 1a fb ff ff    	mov    -0x4e6(%rbp),%ecx
     c6a:	89 08                	mov    %ecx,(%rax)
     c6c:	66 8b 8d 1e fb ff ff 	mov    -0x4e2(%rbp),%cx
     c73:	66 89 48 04          	mov    %cx,0x4(%rax)
  return swap_mac_and_send(data, data_end);
     c77:	c7 85 14 fb ff ff 03 	movl   $0x3,-0x4ec(%rbp)
     c7e:	00 00 00 
}
     c81:	8b 85 14 fb ff ff    	mov    -0x4ec(%rbp),%eax
    return send_icmp_reply(data, data_end);
     c87:	89 85 14 fa ff ff    	mov    %eax,-0x5ec(%rbp)
     c8d:	e9 e8 01 00 00       	jmp    e7a <balancer_ingress+0xe7a>
  if (icmp_hdr->type != ICMP_DEST_UNREACH) {
     c92:	48 8b 85 e8 f9 ff ff 	mov    -0x618(%rbp),%rax
     c99:	0f b6 00             	movzbl (%rax),%eax
     c9c:	83 f8 03             	cmp    $0x3,%eax
     c9f:	74 0f                	je     cb0 <balancer_ingress+0xcb0>
    return XDP_PASS;
     ca1:	c7 85 14 fa ff ff 02 	movl   $0x2,-0x5ec(%rbp)
     ca8:	00 00 00 
     cab:	e9 ca 01 00 00       	jmp    e7a <balancer_ingress+0xe7a>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     cb0:	48 8b 85 e8 f9 ff ff 	mov    -0x618(%rbp),%rax
     cb7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
     cbb:	83 f8 04             	cmp    $0x4,%eax
     cbe:	0f 85 f7 00 00 00    	jne    dbb <balancer_ingress+0xdbb>
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     cc4:	c7 85 dc f9 ff ff 0d 	movl   $0x20d,-0x624(%rbp)
     ccb:	02 00 00 
        bpf_map_lookup_elem(&stats, &stats_key);
     cce:	48 c7 85 c8 f9 ff ff 	movq   $0x0,-0x638(%rbp)
     cd5:	00 00 00 00 
     cd9:	c7 85 c4 f9 ff ff 02 	movl   $0x2,-0x63c(%rbp)
     ce0:	00 00 00 
     ce3:	8b 85 dc f9 ff ff    	mov    -0x624(%rbp),%eax
     ce9:	89 85 c0 f9 ff ff    	mov    %eax,-0x640(%rbp)
     cef:	c7 85 bc f9 ff ff 02 	movl   $0x2,-0x644(%rbp)
     cf6:	00 00 00 
     cf9:	c7 85 b8 f9 ff ff 08 	movl   $0x8,-0x648(%rbp)
     d00:	00 00 00 
     d03:	83 bd c0 f9 ff ff 02 	cmpl   $0x2,-0x640(%rbp)
     d0a:	73 21                	jae    d2d <balancer_ingress+0xd2d>
     d0c:	8b 85 c0 f9 ff ff    	mov    -0x640(%rbp),%eax
     d12:	89 c1                	mov    %eax,%ecx
     d14:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
     d1b:	88 ff ff 
     d1e:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
     d25:	00 
     d26:	48 89 85 c8 f9 ff ff 	mov    %rax,-0x638(%rbp)
     d2d:	48 8b 85 c8 f9 ff ff 	mov    -0x638(%rbp),%rax
     d34:	48 89 85 b0 f9 ff ff 	mov    %rax,-0x650(%rbp)
     d3b:	48 8b 85 b0 f9 ff ff 	mov    -0x650(%rbp),%rax
    struct lb_stats* icmp_ptb_v4_stats =
     d42:	48 89 85 d0 f9 ff ff 	mov    %rax,-0x630(%rbp)
    if (!icmp_ptb_v4_stats) {
     d49:	48 83 bd d0 f9 ff ff 	cmpq   $0x0,-0x630(%rbp)
     d50:	00 
     d51:	75 0f                	jne    d62 <balancer_ingress+0xd62>
      return XDP_DROP;
     d53:	c7 85 14 fa ff ff 01 	movl   $0x1,-0x5ec(%rbp)
     d5a:	00 00 00 
     d5d:	e9 18 01 00 00       	jmp    e7a <balancer_ingress+0xe7a>
    icmp_ptb_v4_stats->v1 += 1;
     d62:	48 8b 85 d0 f9 ff ff 	mov    -0x630(%rbp),%rax
     d69:	48 8b 08             	mov    (%rax),%rcx
     d6c:	48 83 c1 01          	add    $0x1,%rcx
     d70:	48 89 08             	mov    %rcx,(%rax)
    __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);
     d73:	48 8b 85 e8 f9 ff ff 	mov    -0x618(%rbp),%rax
     d7a:	66 8b 40 06          	mov    0x6(%rax),%ax
     d7e:	66 c1 c0 08          	rol    $0x8,%ax
     d82:	0f b7 c0             	movzwl %ax,%eax
     d85:	89 85 48 e8 ff ff    	mov    %eax,-0x17b8(%rbp)
     d8b:	8b 85 48 e8 ff ff    	mov    -0x17b8(%rbp),%eax
     d91:	66 89 85 ae f9 ff ff 	mov    %ax,-0x652(%rbp)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     d98:	0f b7 85 ae f9 ff ff 	movzwl -0x652(%rbp),%eax
     d9f:	3d 00 05 00 00       	cmp    $0x500,%eax
     da4:	7d 13                	jge    db9 <balancer_ingress+0xdb9>
      icmp_ptb_v4_stats->v2 += 1;
     da6:	48 8b 85 d0 f9 ff ff 	mov    -0x630(%rbp),%rax
     dad:	48 8b 48 08          	mov    0x8(%rax),%rcx
     db1:	48 83 c1 01          	add    $0x1,%rcx
     db5:	48 89 48 08          	mov    %rcx,0x8(%rax)
  }
     db9:	eb 00                	jmp    dbb <balancer_ingress+0xdbb>
  off += sizeof(struct icmphdr);
     dbb:	48 8b 85 f8 f9 ff ff 	mov    -0x608(%rbp),%rax
     dc2:	48 83 c0 08          	add    $0x8,%rax
     dc6:	48 89 85 f8 f9 ff ff 	mov    %rax,-0x608(%rbp)
  iph = data + off;
     dcd:	48 8b 85 08 fa ff ff 	mov    -0x5f8(%rbp),%rax
     dd4:	48 03 85 f8 f9 ff ff 	add    -0x608(%rbp),%rax
     ddb:	48 89 85 e0 f9 ff ff 	mov    %rax,-0x620(%rbp)
  if (iph + 1 > data_end) {
     de2:	48 8b 85 e0 f9 ff ff 	mov    -0x620(%rbp),%rax
     de9:	48 83 c0 14          	add    $0x14,%rax
     ded:	48 8b 8d 00 fa ff ff 	mov    -0x600(%rbp),%rcx
     df4:	48 39 c8             	cmp    %rcx,%rax
     df7:	76 0c                	jbe    e05 <balancer_ingress+0xe05>
    return XDP_DROP;
     df9:	c7 85 14 fa ff ff 01 	movl   $0x1,-0x5ec(%rbp)
     e00:	00 00 00 
     e03:	eb 75                	jmp    e7a <balancer_ingress+0xe7a>
  if (iph->ihl != 5) {
     e05:	48 8b 85 e0 f9 ff ff 	mov    -0x620(%rbp),%rax
     e0c:	8a 00                	mov    (%rax),%al
     e0e:	24 0f                	and    $0xf,%al
     e10:	0f b6 c0             	movzbl %al,%eax
     e13:	83 f8 05             	cmp    $0x5,%eax
     e16:	74 0c                	je     e24 <balancer_ingress+0xe24>
    return XDP_DROP;
     e18:	c7 85 14 fa ff ff 01 	movl   $0x1,-0x5ec(%rbp)
     e1f:	00 00 00 
     e22:	eb 56                	jmp    e7a <balancer_ingress+0xe7a>
  pckt->flow.proto = iph->protocol;
     e24:	48 8b 85 e0 f9 ff ff 	mov    -0x620(%rbp),%rax
     e2b:	8a 48 09             	mov    0x9(%rax),%cl
     e2e:	48 8b 85 f0 f9 ff ff 	mov    -0x610(%rbp),%rax
     e35:	88 48 24             	mov    %cl,0x24(%rax)
  pckt->flags |= F_ICMP;
     e38:	48 8b 85 f0 f9 ff ff 	mov    -0x610(%rbp),%rax
     e3f:	0f b6 48 2c          	movzbl 0x2c(%rax),%ecx
     e43:	83 c9 01             	or     $0x1,%ecx
     e46:	88 48 2c             	mov    %cl,0x2c(%rax)
  pckt->flow.src = iph->daddr;
     e49:	48 8b 85 e0 f9 ff ff 	mov    -0x620(%rbp),%rax
     e50:	8b 48 10             	mov    0x10(%rax),%ecx
     e53:	48 8b 85 f0 f9 ff ff 	mov    -0x610(%rbp),%rax
     e5a:	89 08                	mov    %ecx,(%rax)
  pckt->flow.dst = iph->saddr;
     e5c:	48 8b 85 e0 f9 ff ff 	mov    -0x620(%rbp),%rax
     e63:	8b 48 0c             	mov    0xc(%rax),%ecx
     e66:	48 8b 85 f0 f9 ff ff 	mov    -0x610(%rbp),%rax
     e6d:	89 48 10             	mov    %ecx,0x10(%rax)
  return FURTHER_PROCESSING;
     e70:	c7 85 14 fa ff ff ff 	movl   $0xffffffff,-0x5ec(%rbp)
     e77:	ff ff ff 
}
     e7a:	8b 85 14 fa ff ff    	mov    -0x5ec(%rbp),%eax
    return parse_icmp(data, data_end, off, pckt);
     e80:	89 85 f8 ee ff ff    	mov    %eax,-0x1108(%rbp)
     e86:	eb 0a                	jmp    e92 <balancer_ingress+0xe92>
  } else {
    return FURTHER_PROCESSING;
     e88:	c7 85 f8 ee ff ff ff 	movl   $0xffffffff,-0x1108(%rbp)
     e8f:	ff ff ff 
  }
}
     e92:	8b 85 f8 ee ff ff    	mov    -0x1108(%rbp),%eax
     e98:	89 85 78 ed ff ff    	mov    %eax,-0x1288(%rbp)
  if (action >= 0) {
     e9e:	83 bd 78 ed ff ff 00 	cmpl   $0x0,-0x1288(%rbp)
     ea5:	7c 11                	jl     eb8 <balancer_ingress+0xeb8>
    return action;
     ea7:	8b 85 78 ed ff ff    	mov    -0x1288(%rbp),%eax
     ead:	89 85 14 ee ff ff    	mov    %eax,-0x11ec(%rbp)
     eb3:	e9 07 2d 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  protocol = pckt.flow.proto;
     eb8:	8a 85 cc ed ff ff    	mov    -0x1234(%rbp),%al
     ebe:	88 85 7f ed ff ff    	mov    %al,-0x1281(%rbp)
  if (protocol == IPPROTO_TCP) {
     ec4:	0f b6 85 7f ed ff ff 	movzbl -0x1281(%rbp),%eax
     ecb:	83 f8 06             	cmp    $0x6,%eax
     ece:	0f 85 da 01 00 00    	jne    10ae <balancer_ingress+0x10ae>
    if (!parse_tcp(data, data_end, is_ipv6, &pckt)) {
     ed4:	48 8b 95 f0 ed ff ff 	mov    -0x1210(%rbp),%rdx
     edb:	48 8b 8d e8 ed ff ff 	mov    -0x1218(%rbp),%rcx
     ee2:	8a 85 ff ed ff ff    	mov    -0x1201(%rbp),%al
     ee8:	48 89 95 58 ef ff ff 	mov    %rdx,-0x10a8(%rbp)
     eef:	48 89 8d 50 ef ff ff 	mov    %rcx,-0x10b0(%rbp)
     ef6:	24 01                	and    $0x1,%al
     ef8:	88 85 4f ef ff ff    	mov    %al,-0x10b1(%rbp)
     efe:	48 8d 85 a8 ed ff ff 	lea    -0x1258(%rbp),%rax
     f05:	48 89 85 40 ef ff ff 	mov    %rax,-0x10c0(%rbp)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     f0c:	48 8b 85 40 ef ff ff 	mov    -0x10c0(%rbp),%rax
     f13:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
     f17:	83 e0 01             	and    $0x1,%eax
     f1a:	83 f8 00             	cmp    $0x0,%eax
     f1d:	0f 94 c0             	sete   %al
     f20:	34 ff                	xor    $0xff,%al
     f22:	24 01                	and    $0x1,%al
     f24:	88 85 3f ef ff ff    	mov    %al,-0x10c1(%rbp)
  __u64 off = calc_offset(is_ipv6, is_icmp);
     f2a:	8a 8d 4f ef ff ff    	mov    -0x10b1(%rbp),%cl
     f30:	8a 85 3f ef ff ff    	mov    -0x10c1(%rbp),%al
     f36:	80 e1 01             	and    $0x1,%cl
     f39:	88 8d 57 fc ff ff    	mov    %cl,-0x3a9(%rbp)
     f3f:	24 01                	and    $0x1,%al
     f41:	88 85 56 fc ff ff    	mov    %al,-0x3aa(%rbp)
  __u64 off = sizeof(struct ethhdr);
     f47:	48 c7 85 48 fc ff ff 	movq   $0xe,-0x3b8(%rbp)
     f4e:	0e 00 00 00 
  if (is_ipv6) {
     f52:	f6 85 57 fc ff ff 01 	testb  $0x1,-0x3a9(%rbp)
     f59:	74 2f                	je     f8a <balancer_ingress+0xf8a>
    off += sizeof(struct ipv6hdr);
     f5b:	48 8b 85 48 fc ff ff 	mov    -0x3b8(%rbp),%rax
     f62:	48 83 c0 28          	add    $0x28,%rax
     f66:	48 89 85 48 fc ff ff 	mov    %rax,-0x3b8(%rbp)
    if (is_icmp) {
     f6d:	f6 85 56 fc ff ff 01 	testb  $0x1,-0x3aa(%rbp)
     f74:	74 12                	je     f88 <balancer_ingress+0xf88>
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
     f76:	48 8b 85 48 fc ff ff 	mov    -0x3b8(%rbp),%rax
     f7d:	48 83 c0 30          	add    $0x30,%rax
     f81:	48 89 85 48 fc ff ff 	mov    %rax,-0x3b8(%rbp)
  } else {
     f88:	eb 2f                	jmp    fb9 <balancer_ingress+0xfb9>
    off += sizeof(struct iphdr);
     f8a:	48 8b 85 48 fc ff ff 	mov    -0x3b8(%rbp),%rax
     f91:	48 83 c0 14          	add    $0x14,%rax
     f95:	48 89 85 48 fc ff ff 	mov    %rax,-0x3b8(%rbp)
    if (is_icmp) {
     f9c:	f6 85 56 fc ff ff 01 	testb  $0x1,-0x3aa(%rbp)
     fa3:	74 12                	je     fb7 <balancer_ingress+0xfb7>
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
     fa5:	48 8b 85 48 fc ff ff 	mov    -0x3b8(%rbp),%rax
     fac:	48 83 c0 1c          	add    $0x1c,%rax
     fb0:	48 89 85 48 fc ff ff 	mov    %rax,-0x3b8(%rbp)
     fb7:	eb 00                	jmp    fb9 <balancer_ingress+0xfb9>
  return off;
     fb9:	48 8b 85 48 fc ff ff 	mov    -0x3b8(%rbp),%rax
  __u64 off = calc_offset(is_ipv6, is_icmp);
     fc0:	48 89 85 30 ef ff ff 	mov    %rax,-0x10d0(%rbp)
  tcp = data + off;
     fc7:	48 8b 85 58 ef ff ff 	mov    -0x10a8(%rbp),%rax
     fce:	48 03 85 30 ef ff ff 	add    -0x10d0(%rbp),%rax
     fd5:	48 89 85 28 ef ff ff 	mov    %rax,-0x10d8(%rbp)
  if (tcp + 1 > data_end) {
     fdc:	48 8b 85 28 ef ff ff 	mov    -0x10d8(%rbp),%rax
     fe3:	48 83 c0 14          	add    $0x14,%rax
     fe7:	48 8b 8d 50 ef ff ff 	mov    -0x10b0(%rbp),%rcx
     fee:	48 39 c8             	cmp    %rcx,%rax
     ff1:	76 0c                	jbe    fff <balancer_ingress+0xfff>
    return false;
     ff3:	c6 85 67 ef ff ff 00 	movb   $0x0,-0x1099(%rbp)
     ffa:	e9 92 00 00 00       	jmp    1091 <balancer_ingress+0x1091>
  if (tcp->syn) {
     fff:	48 8b 85 28 ef ff ff 	mov    -0x10d8(%rbp),%rax
    1006:	66 8b 40 0c          	mov    0xc(%rax),%ax
    100a:	66 c1 e8 09          	shr    $0x9,%ax
    100e:	66 83 e0 01          	and    $0x1,%ax
    1012:	66 83 f8 00          	cmp    $0x0,%ax
    1016:	74 11                	je     1029 <balancer_ingress+0x1029>
    pckt->flags |= F_SYN_SET;
    1018:	48 8b 85 40 ef ff ff 	mov    -0x10c0(%rbp),%rax
    101f:	0f b6 48 2c          	movzbl 0x2c(%rax),%ecx
    1023:	83 c9 02             	or     $0x2,%ecx
    1026:	88 48 2c             	mov    %cl,0x2c(%rax)
  if (!is_icmp) {
    1029:	f6 85 3f ef ff ff 01 	testb  $0x1,-0x10c1(%rbp)
    1030:	75 2d                	jne    105f <balancer_ingress+0x105f>
    pckt->flow.port16[0] = tcp->source;
    1032:	48 8b 85 28 ef ff ff 	mov    -0x10d8(%rbp),%rax
    1039:	66 8b 08             	mov    (%rax),%cx
    103c:	48 8b 85 40 ef ff ff 	mov    -0x10c0(%rbp),%rax
    1043:	66 89 48 20          	mov    %cx,0x20(%rax)
    pckt->flow.port16[1] = tcp->dest;
    1047:	48 8b 85 28 ef ff ff 	mov    -0x10d8(%rbp),%rax
    104e:	66 8b 48 02          	mov    0x2(%rax),%cx
    1052:	48 8b 85 40 ef ff ff 	mov    -0x10c0(%rbp),%rax
    1059:	66 89 48 22          	mov    %cx,0x22(%rax)
  } else {
    105d:	eb 2b                	jmp    108a <balancer_ingress+0x108a>
    pckt->flow.port16[0] = tcp->dest;
    105f:	48 8b 85 28 ef ff ff 	mov    -0x10d8(%rbp),%rax
    1066:	66 8b 48 02          	mov    0x2(%rax),%cx
    106a:	48 8b 85 40 ef ff ff 	mov    -0x10c0(%rbp),%rax
    1071:	66 89 48 20          	mov    %cx,0x20(%rax)
    pckt->flow.port16[1] = tcp->source;
    1075:	48 8b 85 28 ef ff ff 	mov    -0x10d8(%rbp),%rax
    107c:	66 8b 08             	mov    (%rax),%cx
    107f:	48 8b 85 40 ef ff ff 	mov    -0x10c0(%rbp),%rax
    1086:	66 89 48 22          	mov    %cx,0x22(%rax)
  return true;
    108a:	c6 85 67 ef ff ff 01 	movb   $0x1,-0x1099(%rbp)
    1091:	f6 85 67 ef ff ff 01 	testb  $0x1,-0x1099(%rbp)
    1098:	75 0f                	jne    10a9 <balancer_ingress+0x10a9>
      return XDP_DROP;
    109a:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    10a1:	00 00 00 
    10a4:	e9 16 2b 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  } else if (protocol == IPPROTO_UDP) {
    10a9:	e9 c9 01 00 00       	jmp    1277 <balancer_ingress+0x1277>
    10ae:	0f b6 85 7f ed ff ff 	movzbl -0x1281(%rbp),%eax
    10b5:	83 f8 11             	cmp    $0x11,%eax
    10b8:	0f 85 aa 01 00 00    	jne    1268 <balancer_ingress+0x1268>
    if (!parse_udp(data, data_end, is_ipv6, &pckt)) {
    10be:	48 8b 95 f0 ed ff ff 	mov    -0x1210(%rbp),%rdx
    10c5:	48 8b 8d e8 ed ff ff 	mov    -0x1218(%rbp),%rcx
    10cc:	8a 85 ff ed ff ff    	mov    -0x1201(%rbp),%al
    10d2:	48 89 95 d8 ef ff ff 	mov    %rdx,-0x1028(%rbp)
    10d9:	48 89 8d d0 ef ff ff 	mov    %rcx,-0x1030(%rbp)
    10e0:	24 01                	and    $0x1,%al
    10e2:	88 85 cf ef ff ff    	mov    %al,-0x1031(%rbp)
    10e8:	48 8d 85 a8 ed ff ff 	lea    -0x1258(%rbp),%rax
    10ef:	48 89 85 c0 ef ff ff 	mov    %rax,-0x1040(%rbp)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
    10f6:	48 8b 85 c0 ef ff ff 	mov    -0x1040(%rbp),%rax
    10fd:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
    1101:	83 e0 01             	and    $0x1,%eax
    1104:	83 f8 00             	cmp    $0x0,%eax
    1107:	0f 94 c0             	sete   %al
    110a:	34 ff                	xor    $0xff,%al
    110c:	24 01                	and    $0x1,%al
    110e:	88 85 bf ef ff ff    	mov    %al,-0x1041(%rbp)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    1114:	8a 8d cf ef ff ff    	mov    -0x1031(%rbp),%cl
    111a:	8a 85 bf ef ff ff    	mov    -0x1041(%rbp),%al
    1120:	80 e1 01             	and    $0x1,%cl
    1123:	88 8d 37 fc ff ff    	mov    %cl,-0x3c9(%rbp)
    1129:	24 01                	and    $0x1,%al
    112b:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%rbp)
  __u64 off = sizeof(struct ethhdr);
    1131:	48 c7 85 28 fc ff ff 	movq   $0xe,-0x3d8(%rbp)
    1138:	0e 00 00 00 
  if (is_ipv6) {
    113c:	f6 85 37 fc ff ff 01 	testb  $0x1,-0x3c9(%rbp)
    1143:	74 2f                	je     1174 <balancer_ingress+0x1174>
    off += sizeof(struct ipv6hdr);
    1145:	48 8b 85 28 fc ff ff 	mov    -0x3d8(%rbp),%rax
    114c:	48 83 c0 28          	add    $0x28,%rax
    1150:	48 89 85 28 fc ff ff 	mov    %rax,-0x3d8(%rbp)
    if (is_icmp) {
    1157:	f6 85 36 fc ff ff 01 	testb  $0x1,-0x3ca(%rbp)
    115e:	74 12                	je     1172 <balancer_ingress+0x1172>
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
    1160:	48 8b 85 28 fc ff ff 	mov    -0x3d8(%rbp),%rax
    1167:	48 83 c0 30          	add    $0x30,%rax
    116b:	48 89 85 28 fc ff ff 	mov    %rax,-0x3d8(%rbp)
  } else {
    1172:	eb 2f                	jmp    11a3 <balancer_ingress+0x11a3>
    off += sizeof(struct iphdr);
    1174:	48 8b 85 28 fc ff ff 	mov    -0x3d8(%rbp),%rax
    117b:	48 83 c0 14          	add    $0x14,%rax
    117f:	48 89 85 28 fc ff ff 	mov    %rax,-0x3d8(%rbp)
    if (is_icmp) {
    1186:	f6 85 36 fc ff ff 01 	testb  $0x1,-0x3ca(%rbp)
    118d:	74 12                	je     11a1 <balancer_ingress+0x11a1>
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
    118f:	48 8b 85 28 fc ff ff 	mov    -0x3d8(%rbp),%rax
    1196:	48 83 c0 1c          	add    $0x1c,%rax
    119a:	48 89 85 28 fc ff ff 	mov    %rax,-0x3d8(%rbp)
    11a1:	eb 00                	jmp    11a3 <balancer_ingress+0x11a3>
  return off;
    11a3:	48 8b 85 28 fc ff ff 	mov    -0x3d8(%rbp),%rax
  __u64 off = calc_offset(is_ipv6, is_icmp);
    11aa:	48 89 85 b0 ef ff ff 	mov    %rax,-0x1050(%rbp)
  udp = data + off;
    11b1:	48 8b 85 d8 ef ff ff 	mov    -0x1028(%rbp),%rax
    11b8:	48 03 85 b0 ef ff ff 	add    -0x1050(%rbp),%rax
    11bf:	48 89 85 a8 ef ff ff 	mov    %rax,-0x1058(%rbp)
  if (udp + 1 > data_end) {
    11c6:	48 8b 85 a8 ef ff ff 	mov    -0x1058(%rbp),%rax
    11cd:	48 83 c0 08          	add    $0x8,%rax
    11d1:	48 8b 8d d0 ef ff ff 	mov    -0x1030(%rbp),%rcx
    11d8:	48 39 c8             	cmp    %rcx,%rax
    11db:	76 09                	jbe    11e6 <balancer_ingress+0x11e6>
    return false;
    11dd:	c6 85 e7 ef ff ff 00 	movb   $0x0,-0x1019(%rbp)
    11e4:	eb 68                	jmp    124e <balancer_ingress+0x124e>
  if (!is_icmp) {
    11e6:	f6 85 bf ef ff ff 01 	testb  $0x1,-0x1041(%rbp)
    11ed:	75 2d                	jne    121c <balancer_ingress+0x121c>
    pckt->flow.port16[0] = udp->source;
    11ef:	48 8b 85 a8 ef ff ff 	mov    -0x1058(%rbp),%rax
    11f6:	66 8b 08             	mov    (%rax),%cx
    11f9:	48 8b 85 c0 ef ff ff 	mov    -0x1040(%rbp),%rax
    1200:	66 89 48 20          	mov    %cx,0x20(%rax)
    pckt->flow.port16[1] = udp->dest;
    1204:	48 8b 85 a8 ef ff ff 	mov    -0x1058(%rbp),%rax
    120b:	66 8b 48 02          	mov    0x2(%rax),%cx
    120f:	48 8b 85 c0 ef ff ff 	mov    -0x1040(%rbp),%rax
    1216:	66 89 48 22          	mov    %cx,0x22(%rax)
  } else {
    121a:	eb 2b                	jmp    1247 <balancer_ingress+0x1247>
    pckt->flow.port16[0] = udp->dest;
    121c:	48 8b 85 a8 ef ff ff 	mov    -0x1058(%rbp),%rax
    1223:	66 8b 48 02          	mov    0x2(%rax),%cx
    1227:	48 8b 85 c0 ef ff ff 	mov    -0x1040(%rbp),%rax
    122e:	66 89 48 20          	mov    %cx,0x20(%rax)
    pckt->flow.port16[1] = udp->source;
    1232:	48 8b 85 a8 ef ff ff 	mov    -0x1058(%rbp),%rax
    1239:	66 8b 08             	mov    (%rax),%cx
    123c:	48 8b 85 c0 ef ff ff 	mov    -0x1040(%rbp),%rax
    1243:	66 89 48 22          	mov    %cx,0x22(%rax)
  return true;
    1247:	c6 85 e7 ef ff ff 01 	movb   $0x1,-0x1019(%rbp)
    124e:	f6 85 e7 ef ff ff 01 	testb  $0x1,-0x1019(%rbp)
    1255:	75 0f                	jne    1266 <balancer_ingress+0x1266>
      return XDP_DROP;
    1257:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    125e:	00 00 00 
    1261:	e9 59 29 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
    1266:	eb 0f                	jmp    1277 <balancer_ingress+0x1277>
    return XDP_PASS;
    1268:	c7 85 14 ee ff ff 02 	movl   $0x2,-0x11ec(%rbp)
    126f:	00 00 00 
    1272:	e9 48 29 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  if (is_ipv6) {
    1277:	f6 85 ff ed ff ff 01 	testb  $0x1,-0x1201(%rbp)
    127e:	74 1e                	je     129e <balancer_ingress+0x129e>
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
    1280:	48 8b 85 b8 ed ff ff 	mov    -0x1248(%rbp),%rax
    1287:	48 89 85 90 ed ff ff 	mov    %rax,-0x1270(%rbp)
    128e:	48 8b 85 c0 ed ff ff 	mov    -0x1240(%rbp),%rax
    1295:	48 89 85 98 ed ff ff 	mov    %rax,-0x1268(%rbp)
  } else {
    129c:	eb 0c                	jmp    12aa <balancer_ingress+0x12aa>
    vip.vip = pckt.flow.dst;
    129e:	8b 85 b8 ed ff ff    	mov    -0x1248(%rbp),%eax
    12a4:	89 85 90 ed ff ff    	mov    %eax,-0x1270(%rbp)
  vip.port = pckt.flow.port16[1];
    12aa:	66 8b 85 ca ed ff ff 	mov    -0x1236(%rbp),%ax
    12b1:	66 89 85 a0 ed ff ff 	mov    %ax,-0x1260(%rbp)
  vip.proto = pckt.flow.proto;
    12b8:	8a 85 cc ed ff ff    	mov    -0x1234(%rbp),%al
    12be:	88 85 a2 ed ff ff    	mov    %al,-0x125e(%rbp)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
    12c4:	48 c7 85 58 ed ff ff 	movq   $0x0,-0x12a8(%rbp)
    12cb:	00 00 00 00 
    12cf:	c7 85 54 ed ff ff 02 	movl   $0x2,-0x12ac(%rbp)
    12d6:	00 00 00 
    12d9:	8b 85 90 ed ff ff    	mov    -0x1270(%rbp),%eax
    12df:	89 85 50 ed ff ff    	mov    %eax,-0x12b0(%rbp)
    12e5:	c7 85 4c ed ff ff 02 	movl   $0x2,-0x12b4(%rbp)
    12ec:	00 00 00 
    12ef:	c7 85 48 ed ff ff 08 	movl   $0x8,-0x12b8(%rbp)
    12f6:	00 00 00 
    12f9:	83 bd 50 ed ff ff 02 	cmpl   $0x2,-0x12b0(%rbp)
    1300:	73 21                	jae    1323 <balancer_ingress+0x1323>
    1302:	8b 85 50 ed ff ff    	mov    -0x12b0(%rbp),%eax
    1308:	89 c1                	mov    %eax,%ecx
    130a:	48 b8 00 40 11 3a 81 	movabs $0xffff88813a114000,%rax
    1311:	88 ff ff 
    1314:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    131b:	00 
    131c:	48 89 85 58 ed ff ff 	mov    %rax,-0x12a8(%rbp)
    1323:	48 8b 85 58 ed ff ff 	mov    -0x12a8(%rbp),%rax
    132a:	48 89 85 40 ed ff ff 	mov    %rax,-0x12c0(%rbp)
    1331:	48 8b 85 40 ed ff ff 	mov    -0x12c0(%rbp),%rax
    1338:	48 89 85 88 ed ff ff 	mov    %rax,-0x1278(%rbp)
  if (!vip_info) {
    133f:	48 83 bd 88 ed ff ff 	cmpq   $0x0,-0x1278(%rbp)
    1346:	00 
    1347:	0f 85 cc 00 00 00    	jne    1419 <balancer_ingress+0x1419>
    vip.port = 0;
    134d:	66 c7 85 a0 ed ff ff 	movw   $0x0,-0x1260(%rbp)
    1354:	00 00 
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
    1356:	48 c7 85 38 ed ff ff 	movq   $0x0,-0x12c8(%rbp)
    135d:	00 00 00 00 
    1361:	c7 85 34 ed ff ff 02 	movl   $0x2,-0x12cc(%rbp)
    1368:	00 00 00 
    136b:	8b 85 90 ed ff ff    	mov    -0x1270(%rbp),%eax
    1371:	89 85 30 ed ff ff    	mov    %eax,-0x12d0(%rbp)
    1377:	c7 85 2c ed ff ff 02 	movl   $0x2,-0x12d4(%rbp)
    137e:	00 00 00 
    1381:	c7 85 28 ed ff ff 08 	movl   $0x8,-0x12d8(%rbp)
    1388:	00 00 00 
    138b:	83 bd 30 ed ff ff 02 	cmpl   $0x2,-0x12d0(%rbp)
    1392:	73 21                	jae    13b5 <balancer_ingress+0x13b5>
    1394:	8b 85 30 ed ff ff    	mov    -0x12d0(%rbp),%eax
    139a:	89 c1                	mov    %eax,%ecx
    139c:	48 b8 00 40 11 3a 81 	movabs $0xffff88813a114000,%rax
    13a3:	88 ff ff 
    13a6:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    13ad:	00 
    13ae:	48 89 85 38 ed ff ff 	mov    %rax,-0x12c8(%rbp)
    13b5:	48 8b 85 38 ed ff ff 	mov    -0x12c8(%rbp),%rax
    13bc:	48 89 85 20 ed ff ff 	mov    %rax,-0x12e0(%rbp)
    13c3:	48 8b 85 20 ed ff ff 	mov    -0x12e0(%rbp),%rax
    13ca:	48 89 85 88 ed ff ff 	mov    %rax,-0x1278(%rbp)
    if (!vip_info) {
    13d1:	48 83 bd 88 ed ff ff 	cmpq   $0x0,-0x1278(%rbp)
    13d8:	00 
    13d9:	75 0f                	jne    13ea <balancer_ingress+0x13ea>
      return XDP_PASS;
    13db:	c7 85 14 ee ff ff 02 	movl   $0x2,-0x11ec(%rbp)
    13e2:	00 00 00 
    13e5:	e9 d5 27 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
    13ea:	48 8b 85 88 ed ff ff 	mov    -0x1278(%rbp),%rax
    13f1:	8b 00                	mov    (%rax),%eax
    13f3:	83 e0 08             	and    $0x8,%eax
    13f6:	83 f8 00             	cmp    $0x0,%eax
    13f9:	75 1c                	jne    1417 <balancer_ingress+0x1417>
        !(vip_info->flags & F_HASH_SRC_DST_PORT)) {
    13fb:	48 8b 85 88 ed ff ff 	mov    -0x1278(%rbp),%rax
    1402:	8b 00                	mov    (%rax),%eax
    1404:	25 80 00 00 00       	and    $0x80,%eax
    1409:	83 f8 00             	cmp    $0x0,%eax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
    140c:	75 09                	jne    1417 <balancer_ingress+0x1417>
      pckt.flow.port16[1] = 0;
    140e:	66 c7 85 ca ed ff ff 	movw   $0x0,-0x1236(%rbp)
    1415:	00 00 
  }
    1417:	eb 00                	jmp    1419 <balancer_ingress+0x1419>
  if (data_end - data > MAX_PCKT_SIZE) {
    1419:	48 8b 85 e8 ed ff ff 	mov    -0x1218(%rbp),%rax
    1420:	48 8b 8d f0 ed ff ff 	mov    -0x1210(%rbp),%rcx
    1427:	48 29 c8             	sub    %rcx,%rax
    142a:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
    1430:	7e 0f                	jle    1441 <balancer_ingress+0x1441>
    return XDP_DROP;
    1432:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    1439:	00 00 00 
    143c:	e9 7e 27 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
    1441:	c7 85 1c ed ff ff 00 	movl   $0x200,-0x12e4(%rbp)
    1448:	02 00 00 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    144b:	48 c7 85 10 ed ff ff 	movq   $0x0,-0x12f0(%rbp)
    1452:	00 00 00 00 
    1456:	c7 85 0c ed ff ff 02 	movl   $0x2,-0x12f4(%rbp)
    145d:	00 00 00 
    1460:	8b 85 1c ed ff ff    	mov    -0x12e4(%rbp),%eax
    1466:	89 85 08 ed ff ff    	mov    %eax,-0x12f8(%rbp)
    146c:	c7 85 04 ed ff ff 02 	movl   $0x2,-0x12fc(%rbp)
    1473:	00 00 00 
    1476:	c7 85 00 ed ff ff 08 	movl   $0x8,-0x1300(%rbp)
    147d:	00 00 00 
    1480:	83 bd 08 ed ff ff 02 	cmpl   $0x2,-0x12f8(%rbp)
    1487:	73 21                	jae    14aa <balancer_ingress+0x14aa>
    1489:	8b 85 08 ed ff ff    	mov    -0x12f8(%rbp),%eax
    148f:	89 c1                	mov    %eax,%ecx
    1491:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    1498:	88 ff ff 
    149b:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    14a2:	00 
    14a3:	48 89 85 10 ed ff ff 	mov    %rax,-0x12f0(%rbp)
    14aa:	48 8b 85 10 ed ff ff 	mov    -0x12f0(%rbp),%rax
    14b1:	48 89 85 f8 ec ff ff 	mov    %rax,-0x1308(%rbp)
    14b8:	48 8b 85 f8 ec ff ff 	mov    -0x1308(%rbp),%rax
    14bf:	48 89 85 80 ed ff ff 	mov    %rax,-0x1280(%rbp)
  if (!data_stats) {
    14c6:	48 83 bd 80 ed ff ff 	cmpq   $0x0,-0x1280(%rbp)
    14cd:	00 
    14ce:	75 0f                	jne    14df <balancer_ingress+0x14df>
    return XDP_DROP;
    14d0:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    14d7:	00 00 00 
    14da:	e9 e0 26 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  data_stats->v1 += 1;
    14df:	48 8b 85 80 ed ff ff 	mov    -0x1280(%rbp),%rax
    14e6:	48 8b 08             	mov    (%rax),%rcx
    14e9:	48 83 c1 01          	add    $0x1,%rcx
    14ed:	48 89 08             	mov    %rcx,(%rax)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
    14f0:	48 8b 85 88 ed ff ff 	mov    -0x1278(%rbp),%rax
    14f7:	8b 00                	mov    (%rax),%eax
    14f9:	83 e0 01             	and    $0x1,%eax
    14fc:	83 f8 00             	cmp    $0x0,%eax
    14ff:	74 09                	je     150a <balancer_ingress+0x150a>
    pckt.flow.port16[0] = 0;
    1501:	66 c7 85 c8 ed ff ff 	movw   $0x0,-0x1238(%rbp)
    1508:	00 00 
  vip_num = vip_info->vip_num;
    150a:	48 8b 85 88 ed ff ff 	mov    -0x1278(%rbp),%rax
    1511:	8b 40 04             	mov    0x4(%rax),%eax
    1514:	89 85 74 ed ff ff    	mov    %eax,-0x128c(%rbp)
  __u32 cpu_num = bpf_get_smp_processor_id();
    151a:	48 b8 80 7f 00 00 00 	movabs $0x7f80,%rax
    1521:	00 00 00 
    1524:	48 8b 00             	mov    (%rax),%rax
    1527:	ff d0                	call   *%rax
    1529:	89 85 f4 ec ff ff    	mov    %eax,-0x130c(%rbp)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
    152f:	48 c7 85 e0 ec ff ff 	movq   $0x0,-0x1320(%rbp)
    1536:	00 00 00 00 
    153a:	c7 85 dc ec ff ff 02 	movl   $0x2,-0x1324(%rbp)
    1541:	00 00 00 
    1544:	8b 85 f4 ec ff ff    	mov    -0x130c(%rbp),%eax
    154a:	89 85 d8 ec ff ff    	mov    %eax,-0x1328(%rbp)
    1550:	c7 85 d4 ec ff ff 02 	movl   $0x2,-0x132c(%rbp)
    1557:	00 00 00 
    155a:	c7 85 d0 ec ff ff 08 	movl   $0x8,-0x1330(%rbp)
    1561:	00 00 00 
    1564:	83 bd d8 ec ff ff 02 	cmpl   $0x2,-0x1328(%rbp)
    156b:	73 21                	jae    158e <balancer_ingress+0x158e>
    156d:	8b 85 d8 ec ff ff    	mov    -0x1328(%rbp),%eax
    1573:	89 c1                	mov    %eax,%ecx
    1575:	48 b8 00 a0 27 71 81 	movabs $0xffff88817127a000,%rax
    157c:	88 ff ff 
    157f:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    1586:	00 
    1587:	48 89 85 e0 ec ff ff 	mov    %rax,-0x1320(%rbp)
    158e:	48 8b 85 e0 ec ff ff 	mov    -0x1320(%rbp),%rax
    1595:	48 89 85 c8 ec ff ff 	mov    %rax,-0x1338(%rbp)
    159c:	48 8b 85 c8 ec ff ff 	mov    -0x1338(%rbp),%rax
    15a3:	48 89 85 e8 ec ff ff 	mov    %rax,-0x1318(%rbp)
  if (!lru_map) {
    15aa:	48 83 bd e8 ec ff ff 	cmpq   $0x0,-0x1318(%rbp)
    15b1:	00 
    15b2:	0f 85 c0 00 00 00    	jne    1678 <balancer_ingress+0x1678>
    lru_map = &fallback_cache;
    15b8:	48 b8 00 38 11 3a 81 	movabs $0xffff88813a113800,%rax
    15bf:	88 ff ff 
    15c2:	48 89 85 e8 ec ff ff 	mov    %rax,-0x1318(%rbp)
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
    15c9:	c7 85 c4 ec ff ff 03 	movl   $0x203,-0x133c(%rbp)
    15d0:	02 00 00 
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
    15d3:	48 c7 85 b0 ec ff ff 	movq   $0x0,-0x1350(%rbp)
    15da:	00 00 00 00 
    15de:	c7 85 ac ec ff ff 02 	movl   $0x2,-0x1354(%rbp)
    15e5:	00 00 00 
    15e8:	8b 85 c4 ec ff ff    	mov    -0x133c(%rbp),%eax
    15ee:	89 85 a8 ec ff ff    	mov    %eax,-0x1358(%rbp)
    15f4:	c7 85 a4 ec ff ff 02 	movl   $0x2,-0x135c(%rbp)
    15fb:	00 00 00 
    15fe:	c7 85 a0 ec ff ff 08 	movl   $0x8,-0x1360(%rbp)
    1605:	00 00 00 
    1608:	83 bd a8 ec ff ff 02 	cmpl   $0x2,-0x1358(%rbp)
    160f:	73 21                	jae    1632 <balancer_ingress+0x1632>
    1611:	8b 85 a8 ec ff ff    	mov    -0x1358(%rbp),%eax
    1617:	89 c1                	mov    %eax,%ecx
    1619:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    1620:	88 ff ff 
    1623:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    162a:	00 
    162b:	48 89 85 b0 ec ff ff 	mov    %rax,-0x1350(%rbp)
    1632:	48 8b 85 b0 ec ff ff 	mov    -0x1350(%rbp),%rax
    1639:	48 89 85 98 ec ff ff 	mov    %rax,-0x1368(%rbp)
    1640:	48 8b 85 98 ec ff ff 	mov    -0x1368(%rbp),%rax
    1647:	48 89 85 b8 ec ff ff 	mov    %rax,-0x1348(%rbp)
    if (!lru_stats) {
    164e:	48 83 bd b8 ec ff ff 	cmpq   $0x0,-0x1348(%rbp)
    1655:	00 
    1656:	75 0f                	jne    1667 <balancer_ingress+0x1667>
      return XDP_DROP;
    1658:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    165f:	00 00 00 
    1662:	e9 58 25 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
    lru_stats->v1 += 1;
    1667:	48 8b 85 b8 ec ff ff 	mov    -0x1348(%rbp),%rax
    166e:	48 8b 08             	mov    (%rax),%rcx
    1671:	48 83 c1 01          	add    $0x1,%rcx
    1675:	48 89 08             	mov    %rcx,(%rax)
  if ((vip_info->flags & F_QUIC_VIP)) {
    1678:	48 8b 85 88 ed ff ff 	mov    -0x1278(%rbp),%rax
    167f:	8b 00                	mov    (%rax),%eax
    1681:	83 e0 04             	and    $0x4,%eax
    1684:	83 f8 00             	cmp    $0x0,%eax
    1687:	0f 84 ae 0c 00 00    	je     233b <balancer_ingress+0x233b>
    bool is_icmp = (pckt.flags & F_ICMP);
    168d:	0f b6 85 d4 ed ff ff 	movzbl -0x122c(%rbp),%eax
    1694:	83 e0 01             	and    $0x1,%eax
    1697:	83 f8 00             	cmp    $0x0,%eax
    169a:	0f 95 c0             	setne  %al
    169d:	24 01                	and    $0x1,%al
    169f:	88 85 97 ec ff ff    	mov    %al,-0x1369(%rbp)
    if (is_icmp) {
    16a5:	f6 85 97 ec ff ff 01 	testb  $0x1,-0x1369(%rbp)
    16ac:	0f 84 be 01 00 00    	je     1870 <balancer_ingress+0x1870>
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
    16b2:	c7 85 90 ec ff ff 0b 	movl   $0x20b,-0x1370(%rbp)
    16b9:	02 00 00 
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    16bc:	48 c7 85 80 ec ff ff 	movq   $0x0,-0x1380(%rbp)
    16c3:	00 00 00 00 
    16c7:	c7 85 7c ec ff ff 02 	movl   $0x2,-0x1384(%rbp)
    16ce:	00 00 00 
    16d1:	8b 85 90 ec ff ff    	mov    -0x1370(%rbp),%eax
    16d7:	89 85 78 ec ff ff    	mov    %eax,-0x1388(%rbp)
    16dd:	c7 85 74 ec ff ff 02 	movl   $0x2,-0x138c(%rbp)
    16e4:	00 00 00 
    16e7:	c7 85 70 ec ff ff 08 	movl   $0x8,-0x1390(%rbp)
    16ee:	00 00 00 
    16f1:	83 bd 78 ec ff ff 02 	cmpl   $0x2,-0x1388(%rbp)
    16f8:	73 21                	jae    171b <balancer_ingress+0x171b>
    16fa:	8b 85 78 ec ff ff    	mov    -0x1388(%rbp),%eax
    1700:	89 c1                	mov    %eax,%ecx
    1702:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    1709:	88 ff ff 
    170c:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    1713:	00 
    1714:	48 89 85 80 ec ff ff 	mov    %rax,-0x1380(%rbp)
    171b:	48 8b 85 80 ec ff ff 	mov    -0x1380(%rbp),%rax
    1722:	48 89 85 68 ec ff ff 	mov    %rax,-0x1398(%rbp)
    1729:	48 8b 85 68 ec ff ff 	mov    -0x1398(%rbp),%rax
    1730:	48 89 85 88 ec ff ff 	mov    %rax,-0x1378(%rbp)
      if (!data_stats) {
    1737:	48 83 bd 88 ec ff ff 	cmpq   $0x0,-0x1378(%rbp)
    173e:	00 
    173f:	75 0f                	jne    1750 <balancer_ingress+0x1750>
        return XDP_DROP;
    1741:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    1748:	00 00 00 
    174b:	e9 6f 24 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
      data_stats->v1 += 1;
    1750:	48 8b 85 88 ec ff ff 	mov    -0x1378(%rbp),%rax
    1757:	48 8b 08             	mov    (%rax),%rcx
    175a:	48 83 c1 01          	add    $0x1,%rcx
    175e:	48 89 08             	mov    %rcx,(%rax)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    1761:	48 8b 95 f0 ed ff ff 	mov    -0x1210(%rbp),%rdx
    1768:	48 8b 8d e8 ed ff ff 	mov    -0x1218(%rbp),%rcx
    176f:	8a 85 ff ed ff ff    	mov    -0x1201(%rbp),%al
    1775:	48 89 95 50 f0 ff ff 	mov    %rdx,-0xfb0(%rbp)
    177c:	48 89 8d 48 f0 ff ff 	mov    %rcx,-0xfb8(%rbp)
    1783:	24 01                	and    $0x1,%al
    1785:	88 85 47 f0 ff ff    	mov    %al,-0xfb9(%rbp)
  __u64 off = sizeof(struct ethhdr);
    178b:	48 c7 85 38 f0 ff ff 	movq   $0xe,-0xfc8(%rbp)
    1792:	0e 00 00 00 
  if (is_ipv6) {
    1796:	f6 85 47 f0 ff ff 01 	testb  $0x1,-0xfb9(%rbp)
    179d:	74 58                	je     17f7 <balancer_ingress+0x17f7>
    struct icmp6hdr* icmp_hdr = data + off + sizeof(struct ipv6hdr);
    179f:	48 8b 85 50 f0 ff ff 	mov    -0xfb0(%rbp),%rax
    17a6:	48 03 85 38 f0 ff ff 	add    -0xfc8(%rbp),%rax
    17ad:	48 83 c0 28          	add    $0x28,%rax
    17b1:	48 89 85 30 f0 ff ff 	mov    %rax,-0xfd0(%rbp)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
    17b8:	48 8b 85 30 f0 ff ff 	mov    -0xfd0(%rbp),%rax
    17bf:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    17c3:	b0 01                	mov    $0x1,%al
    17c5:	83 f9 03             	cmp    $0x3,%ecx
    17c8:	88 85 47 e8 ff ff    	mov    %al,-0x17b9(%rbp)
    17ce:	74 17                	je     17e7 <balancer_ingress+0x17e7>
        (icmp_hdr->icmp6_code == ICMPV6_PORT_UNREACH));
    17d0:	48 8b 85 30 f0 ff ff 	mov    -0xfd0(%rbp),%rax
    17d7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    17db:	83 f8 04             	cmp    $0x4,%eax
    17de:	0f 94 c0             	sete   %al
    17e1:	88 85 47 e8 ff ff    	mov    %al,-0x17b9(%rbp)
    17e7:	8a 85 47 e8 ff ff    	mov    -0x17b9(%rbp),%al
    return (
    17ed:	24 01                	and    $0x1,%al
    17ef:	88 85 5f f0 ff ff    	mov    %al,-0xfa1(%rbp)
    17f5:	eb 56                	jmp    184d <balancer_ingress+0x184d>
    struct icmphdr* icmp_hdr = data + off + sizeof(struct iphdr);
    17f7:	48 8b 85 50 f0 ff ff 	mov    -0xfb0(%rbp),%rax
    17fe:	48 03 85 38 f0 ff ff 	add    -0xfc8(%rbp),%rax
    1805:	48 83 c0 14          	add    $0x14,%rax
    1809:	48 89 85 28 f0 ff ff 	mov    %rax,-0xfd8(%rbp)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    1810:	48 8b 85 28 f0 ff ff 	mov    -0xfd8(%rbp),%rax
    1817:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    181b:	b0 01                	mov    $0x1,%al
    181d:	83 f9 03             	cmp    $0x3,%ecx
    1820:	88 85 46 e8 ff ff    	mov    %al,-0x17ba(%rbp)
    1826:	74 17                	je     183f <balancer_ingress+0x183f>
        (icmp_hdr->code == ICMP_HOST_UNREACH));
    1828:	48 8b 85 28 f0 ff ff 	mov    -0xfd8(%rbp),%rax
    182f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    1833:	83 f8 01             	cmp    $0x1,%eax
    1836:	0f 94 c0             	sete   %al
    1839:	88 85 46 e8 ff ff    	mov    %al,-0x17ba(%rbp)
    183f:	8a 85 46 e8 ff ff    	mov    -0x17ba(%rbp),%al
    return (
    1845:	24 01                	and    $0x1,%al
    1847:	88 85 5f f0 ff ff    	mov    %al,-0xfa1(%rbp)
    184d:	f6 85 5f f0 ff ff 01 	testb  $0x1,-0xfa1(%rbp)
    1854:	75 02                	jne    1858 <balancer_ingress+0x1858>
    1856:	eb 13                	jmp    186b <balancer_ingress+0x186b>
        data_stats->v2 += 1;
    1858:	48 8b 85 88 ec ff ff 	mov    -0x1378(%rbp),%rax
    185f:	48 8b 48 08          	mov    0x8(%rax),%rcx
    1863:	48 83 c1 01          	add    $0x1,%rcx
    1867:	48 89 48 08          	mov    %rcx,0x8(%rax)
    } else {
    186b:	e9 c9 0a 00 00       	jmp    2339 <balancer_ingress+0x2339>
      __u32 quic_packets_stats_key = 0;
    1870:	c7 85 64 ec ff ff 00 	movl   $0x0,-0x139c(%rbp)
    1877:	00 00 00 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
    187a:	48 c7 85 50 ec ff ff 	movq   $0x0,-0x13b0(%rbp)
    1881:	00 00 00 00 
    1885:	c7 85 4c ec ff ff 02 	movl   $0x2,-0x13b4(%rbp)
    188c:	00 00 00 
    188f:	8b 85 64 ec ff ff    	mov    -0x139c(%rbp),%eax
    1895:	89 85 48 ec ff ff    	mov    %eax,-0x13b8(%rbp)
    189b:	c7 85 44 ec ff ff 02 	movl   $0x2,-0x13bc(%rbp)
    18a2:	00 00 00 
    18a5:	c7 85 40 ec ff ff 08 	movl   $0x8,-0x13c0(%rbp)
    18ac:	00 00 00 
    18af:	83 bd 48 ec ff ff 02 	cmpl   $0x2,-0x13b8(%rbp)
    18b6:	73 21                	jae    18d9 <balancer_ingress+0x18d9>
    18b8:	8b 85 48 ec ff ff    	mov    -0x13b8(%rbp),%eax
    18be:	89 c1                	mov    %eax,%ecx
    18c0:	48 b8 00 28 97 51 81 	movabs $0xffff888151972800,%rax
    18c7:	88 ff ff 
    18ca:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    18d1:	00 
    18d2:	48 89 85 50 ec ff ff 	mov    %rax,-0x13b0(%rbp)
    18d9:	48 8b 85 50 ec ff ff 	mov    -0x13b0(%rbp),%rax
    18e0:	48 89 85 38 ec ff ff 	mov    %rax,-0x13c8(%rbp)
    18e7:	48 8b 85 38 ec ff ff 	mov    -0x13c8(%rbp),%rax
      struct lb_quic_packets_stats* quic_packets_stats =
    18ee:	48 89 85 58 ec ff ff 	mov    %rax,-0x13a8(%rbp)
      if (!quic_packets_stats) {
    18f5:	48 83 bd 58 ec ff ff 	cmpq   $0x0,-0x13a8(%rbp)
    18fc:	00 
    18fd:	75 0f                	jne    190e <balancer_ingress+0x190e>
        return XDP_DROP;
    18ff:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    1906:	00 00 00 
    1909:	e9 b1 22 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
      struct quic_parse_result qpr = parse_quic(data, data_end, is_ipv6, &pckt);
    190e:	48 8b 95 f0 ed ff ff 	mov    -0x1210(%rbp),%rdx
    1915:	48 8b 8d e8 ed ff ff 	mov    -0x1218(%rbp),%rcx
    191c:	8a 85 ff ed ff ff    	mov    -0x1201(%rbp),%al
    1922:	48 89 95 e0 f0 ff ff 	mov    %rdx,-0xf20(%rbp)
    1929:	48 89 8d d8 f0 ff ff 	mov    %rcx,-0xf28(%rbp)
    1930:	24 01                	and    $0x1,%al
    1932:	88 85 d7 f0 ff ff    	mov    %al,-0xf29(%rbp)
    1938:	48 8d 85 a8 ed ff ff 	lea    -0x1258(%rbp),%rax
    193f:	48 89 85 c8 f0 ff ff 	mov    %rax,-0xf38(%rbp)
  struct quic_parse_result result = {
    1946:	48 8d 85 e8 f0 ff ff 	lea    -0xf18(%rbp),%rax
    194d:	48 b9 cc 7c 00 00 00 	movabs $0x7ccc,%rcx
    1954:	00 00 00 
    1957:	48 8b 09             	mov    (%rcx),%rcx
    195a:	48 89 08             	mov    %rcx,(%rax)
  bool is_icmp = (pckt->flags & F_ICMP);
    195d:	48 8b 85 c8 f0 ff ff 	mov    -0xf38(%rbp),%rax
    1964:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
    1968:	83 e0 01             	and    $0x1,%eax
    196b:	83 f8 00             	cmp    $0x0,%eax
    196e:	0f 95 c0             	setne  %al
    1971:	24 01                	and    $0x1,%al
    1973:	88 85 c7 f0 ff ff    	mov    %al,-0xf39(%rbp)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    1979:	8a 8d d7 f0 ff ff    	mov    -0xf29(%rbp),%cl
    197f:	8a 85 c7 f0 ff ff    	mov    -0xf39(%rbp),%al
    1985:	80 e1 01             	and    $0x1,%cl
    1988:	88 8d 17 fc ff ff    	mov    %cl,-0x3e9(%rbp)
    198e:	24 01                	and    $0x1,%al
    1990:	88 85 16 fc ff ff    	mov    %al,-0x3ea(%rbp)
  __u64 off = sizeof(struct ethhdr);
    1996:	48 c7 85 08 fc ff ff 	movq   $0xe,-0x3f8(%rbp)
    199d:	0e 00 00 00 
  if (is_ipv6) {
    19a1:	f6 85 17 fc ff ff 01 	testb  $0x1,-0x3e9(%rbp)
    19a8:	74 2f                	je     19d9 <balancer_ingress+0x19d9>
    off += sizeof(struct ipv6hdr);
    19aa:	48 8b 85 08 fc ff ff 	mov    -0x3f8(%rbp),%rax
    19b1:	48 83 c0 28          	add    $0x28,%rax
    19b5:	48 89 85 08 fc ff ff 	mov    %rax,-0x3f8(%rbp)
    if (is_icmp) {
    19bc:	f6 85 16 fc ff ff 01 	testb  $0x1,-0x3ea(%rbp)
    19c3:	74 12                	je     19d7 <balancer_ingress+0x19d7>
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
    19c5:	48 8b 85 08 fc ff ff 	mov    -0x3f8(%rbp),%rax
    19cc:	48 83 c0 30          	add    $0x30,%rax
    19d0:	48 89 85 08 fc ff ff 	mov    %rax,-0x3f8(%rbp)
  } else {
    19d7:	eb 2f                	jmp    1a08 <balancer_ingress+0x1a08>
    off += sizeof(struct iphdr);
    19d9:	48 8b 85 08 fc ff ff 	mov    -0x3f8(%rbp),%rax
    19e0:	48 83 c0 14          	add    $0x14,%rax
    19e4:	48 89 85 08 fc ff ff 	mov    %rax,-0x3f8(%rbp)
    if (is_icmp) {
    19eb:	f6 85 16 fc ff ff 01 	testb  $0x1,-0x3ea(%rbp)
    19f2:	74 12                	je     1a06 <balancer_ingress+0x1a06>
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
    19f4:	48 8b 85 08 fc ff ff 	mov    -0x3f8(%rbp),%rax
    19fb:	48 83 c0 1c          	add    $0x1c,%rax
    19ff:	48 89 85 08 fc ff ff 	mov    %rax,-0x3f8(%rbp)
    1a06:	eb 00                	jmp    1a08 <balancer_ingress+0x1a08>
  return off;
    1a08:	48 8b 85 08 fc ff ff 	mov    -0x3f8(%rbp),%rax
  __u64 off = calc_offset(is_ipv6, is_icmp);
    1a0f:	48 89 85 b8 f0 ff ff 	mov    %rax,-0xf48(%rbp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1a16:	48 8b 85 e0 f0 ff ff 	mov    -0xf20(%rbp),%rax
    1a1d:	48 03 85 b8 f0 ff ff 	add    -0xf48(%rbp),%rax
    1a24:	48 83 c0 08          	add    $0x8,%rax
    1a28:	48 83 c0 01          	add    $0x1,%rax
    1a2c:	48 3b 85 d8 f0 ff ff 	cmp    -0xf28(%rbp),%rax
    1a33:	76 05                	jbe    1a3a <balancer_ingress+0x1a3a>
    return result;
    1a35:	e9 e4 01 00 00       	jmp    1c1e <balancer_ingress+0x1c1e>
  __u8* quic_data = data + off + sizeof(struct udphdr);
    1a3a:	48 8b 85 e0 f0 ff ff 	mov    -0xf20(%rbp),%rax
    1a41:	48 03 85 b8 f0 ff ff 	add    -0xf48(%rbp),%rax
    1a48:	48 83 c0 08          	add    $0x8,%rax
    1a4c:	48 89 85 b0 f0 ff ff 	mov    %rax,-0xf50(%rbp)
  __u8* pkt_type = quic_data;
    1a53:	48 8b 85 b0 f0 ff ff 	mov    -0xf50(%rbp),%rax
    1a5a:	48 89 85 a8 f0 ff ff 	mov    %rax,-0xf58(%rbp)
  __u8* connId = NULL;
    1a61:	48 c7 85 a0 f0 ff ff 	movq   $0x0,-0xf60(%rbp)
    1a68:	00 00 00 00 
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    1a6c:	48 8b 85 a8 f0 ff ff 	mov    -0xf58(%rbp),%rax
    1a73:	0f b6 00             	movzbl (%rax),%eax
    1a76:	25 80 00 00 00       	and    $0x80,%eax
    1a7b:	3d 80 00 00 00       	cmp    $0x80,%eax
    1a80:	75 6e                	jne    1af0 <balancer_ingress+0x1af0>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1a82:	48 8b 85 b0 f0 ff ff 	mov    -0xf50(%rbp),%rax
    1a89:	48 83 c0 0e          	add    $0xe,%rax
    1a8d:	48 3b 85 d8 f0 ff ff 	cmp    -0xf28(%rbp),%rax
    1a94:	76 05                	jbe    1a9b <balancer_ingress+0x1a9b>
      return result;
    1a96:	e9 83 01 00 00       	jmp    1c1e <balancer_ingress+0x1c1e>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1a9b:	48 8b 85 a8 f0 ff ff 	mov    -0xf58(%rbp),%rax
    1aa2:	0f b6 00             	movzbl (%rax),%eax
    1aa5:	83 e0 30             	and    $0x30,%eax
    1aa8:	83 f8 20             	cmp    $0x20,%eax
    1aab:	7d 0c                	jge    1ab9 <balancer_ingress+0x1ab9>
      result.is_initial = true;
    1aad:	c6 85 ed f0 ff ff 01 	movb   $0x1,-0xf13(%rbp)
      return result;
    1ab4:	e9 65 01 00 00       	jmp    1c1e <balancer_ingress+0x1c1e>
    struct quic_long_header* long_header = (struct quic_long_header*)quic_data;
    1ab9:	48 8b 85 b0 f0 ff ff 	mov    -0xf50(%rbp),%rax
    1ac0:	48 89 85 98 f0 ff ff 	mov    %rax,-0xf68(%rbp)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1ac7:	48 8b 85 98 f0 ff ff 	mov    -0xf68(%rbp),%rax
    1ace:	0f b6 40 05          	movzbl 0x5(%rax),%eax
    1ad2:	83 f8 08             	cmp    $0x8,%eax
    1ad5:	7d 05                	jge    1adc <balancer_ingress+0x1adc>
      return result;
    1ad7:	e9 42 01 00 00       	jmp    1c1e <balancer_ingress+0x1c1e>
    connId = long_header->dst_connection_id;
    1adc:	48 8b 85 98 f0 ff ff 	mov    -0xf68(%rbp),%rax
    1ae3:	48 83 c0 06          	add    $0x6,%rax
    1ae7:	48 89 85 a0 f0 ff ff 	mov    %rax,-0xf60(%rbp)
  } else {
    1aee:	eb 2b                	jmp    1b1b <balancer_ingress+0x1b1b>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    1af0:	48 8b 85 b0 f0 ff ff 	mov    -0xf50(%rbp),%rax
    1af7:	48 83 c0 09          	add    $0x9,%rax
    1afb:	48 3b 85 d8 f0 ff ff 	cmp    -0xf28(%rbp),%rax
    1b02:	76 05                	jbe    1b09 <balancer_ingress+0x1b09>
      return result;
    1b04:	e9 15 01 00 00       	jmp    1c1e <balancer_ingress+0x1c1e>
    connId = ((struct quic_short_header*)quic_data)->connection_id;
    1b09:	48 8b 85 b0 f0 ff ff 	mov    -0xf50(%rbp),%rax
    1b10:	48 83 c0 01          	add    $0x1,%rax
    1b14:	48 89 85 a0 f0 ff ff 	mov    %rax,-0xf60(%rbp)
  if (!connId) {
    1b1b:	48 83 bd a0 f0 ff ff 	cmpq   $0x0,-0xf60(%rbp)
    1b22:	00 
    1b23:	75 05                	jne    1b2a <balancer_ingress+0x1b2a>
    return result;
    1b25:	e9 f4 00 00 00       	jmp    1c1e <balancer_ingress+0x1c1e>
  __u8 connIdVersion = (connId[0] >> 6);
    1b2a:	48 8b 85 a0 f0 ff ff 	mov    -0xf60(%rbp),%rax
    1b31:	0f b6 00             	movzbl (%rax),%eax
    1b34:	c1 f8 06             	sar    $0x6,%eax
    1b37:	88 85 97 f0 ff ff    	mov    %al,-0xf69(%rbp)
  result.cid_version = connIdVersion;
    1b3d:	8a 85 97 f0 ff ff    	mov    -0xf69(%rbp),%al
    1b43:	88 85 ec f0 ff ff    	mov    %al,-0xf14(%rbp)
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    1b49:	0f b6 85 97 f0 ff ff 	movzbl -0xf69(%rbp),%eax
    1b50:	83 f8 01             	cmp    $0x1,%eax
    1b53:	75 3b                	jne    1b90 <balancer_ingress+0x1b90>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    1b55:	48 8b 85 a0 f0 ff ff 	mov    -0xf60(%rbp),%rax
    1b5c:	0f b6 00             	movzbl (%rax),%eax
    1b5f:	83 e0 3f             	and    $0x3f,%eax
    1b62:	c1 e0 0a             	shl    $0xa,%eax
    1b65:	48 8b 8d a0 f0 ff ff 	mov    -0xf60(%rbp),%rcx
    1b6c:	0f b6 49 01          	movzbl 0x1(%rcx),%ecx
    1b70:	c1 e1 02             	shl    $0x2,%ecx
    1b73:	09 c8                	or     %ecx,%eax
    1b75:	48 8b 8d a0 f0 ff ff 	mov    -0xf60(%rbp),%rcx
    1b7c:	0f b6 49 02          	movzbl 0x2(%rcx),%ecx
    1b80:	c1 f9 06             	sar    $0x6,%ecx
    1b83:	09 c8                	or     %ecx,%eax
    result.server_id =
    1b85:	89 85 e8 f0 ff ff    	mov    %eax,-0xf18(%rbp)
    return result;
    1b8b:	e9 8e 00 00 00       	jmp    1c1e <balancer_ingress+0x1c1e>
  } else if (connIdVersion == QUIC_CONNID_VERSION_V2) {
    1b90:	0f b6 85 97 f0 ff ff 	movzbl -0xf69(%rbp),%eax
    1b97:	83 f8 02             	cmp    $0x2,%eax
    1b9a:	75 33                	jne    1bcf <balancer_ingress+0x1bcf>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1b9c:	48 8b 85 a0 f0 ff ff 	mov    -0xf60(%rbp),%rax
    1ba3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    1ba7:	c1 e0 10             	shl    $0x10,%eax
    1baa:	48 8b 8d a0 f0 ff ff 	mov    -0xf60(%rbp),%rcx
    1bb1:	0f b6 49 02          	movzbl 0x2(%rcx),%ecx
    1bb5:	c1 e1 08             	shl    $0x8,%ecx
    1bb8:	09 c8                	or     %ecx,%eax
    1bba:	48 8b 8d a0 f0 ff ff 	mov    -0xf60(%rbp),%rcx
    1bc1:	0f b6 49 03          	movzbl 0x3(%rcx),%ecx
    1bc5:	09 c8                	or     %ecx,%eax
    1bc7:	89 85 e8 f0 ff ff    	mov    %eax,-0xf18(%rbp)
    return result;
    1bcd:	eb 4f                	jmp    1c1e <balancer_ingress+0x1c1e>
  } else if (connIdVersion == QUIC_CONNID_VERSION_V3) {
    1bcf:	0f b6 85 97 f0 ff ff 	movzbl -0xf69(%rbp),%eax
    1bd6:	83 f8 03             	cmp    $0x3,%eax
    1bd9:	75 41                	jne    1c1c <balancer_ingress+0x1c1c>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1bdb:	48 8b 85 a0 f0 ff ff 	mov    -0xf60(%rbp),%rax
    1be2:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    1be6:	c1 e0 18             	shl    $0x18,%eax
    1be9:	48 8b 8d a0 f0 ff ff 	mov    -0xf60(%rbp),%rcx
    1bf0:	0f b6 49 02          	movzbl 0x2(%rcx),%ecx
    1bf4:	c1 e1 10             	shl    $0x10,%ecx
    1bf7:	09 c8                	or     %ecx,%eax
    1bf9:	48 8b 8d a0 f0 ff ff 	mov    -0xf60(%rbp),%rcx
    1c00:	0f b6 49 03          	movzbl 0x3(%rcx),%ecx
    1c04:	c1 e1 08             	shl    $0x8,%ecx
    1c07:	09 c8                	or     %ecx,%eax
    1c09:	48 8b 8d a0 f0 ff ff 	mov    -0xf60(%rbp),%rcx
    1c10:	0f b6 49 04          	movzbl 0x4(%rcx),%ecx
    1c14:	09 c8                	or     %ecx,%eax
    result.server_id =
    1c16:	89 85 e8 f0 ff ff    	mov    %eax,-0xf18(%rbp)
  return result;
    1c1c:	eb 00                	jmp    1c1e <balancer_ingress+0x1c1e>
}
    1c1e:	48 8b 85 e8 f0 ff ff 	mov    -0xf18(%rbp),%rax
    1c25:	48 89 85 30 ec ff ff 	mov    %rax,-0x13d0(%rbp)
      if (qpr.server_id > 0) {
    1c2c:	83 bd 30 ec ff ff 00 	cmpl   $0x0,-0x13d0(%rbp)
    1c33:	0f 8e f1 05 00 00    	jle    222a <balancer_ingress+0x222a>
        increment_quic_cid_version_stats(quic_packets_stats, qpr.cid_version);
    1c39:	48 8b 8d 58 ec ff ff 	mov    -0x13a8(%rbp),%rcx
    1c40:	8a 85 34 ec ff ff    	mov    -0x13cc(%rbp),%al
    1c46:	48 89 8d 58 f1 ff ff 	mov    %rcx,-0xea8(%rbp)
    1c4d:	88 85 57 f1 ff ff    	mov    %al,-0xea9(%rbp)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1c53:	0f b6 85 57 f1 ff ff 	movzbl -0xea9(%rbp),%eax
    1c5a:	83 f8 01             	cmp    $0x1,%eax
    1c5d:	75 15                	jne    1c74 <balancer_ingress+0x1c74>
    quic_packets_stats->cid_v1 += 1;
    1c5f:	48 8b 85 58 f1 ff ff 	mov    -0xea8(%rbp),%rax
    1c66:	48 8b 48 38          	mov    0x38(%rax),%rcx
    1c6a:	48 83 c1 01          	add    $0x1,%rcx
    1c6e:	48 89 48 38          	mov    %rcx,0x38(%rax)
  } else if (cid_version == QUIC_CONNID_VERSION_V2) {
    1c72:	eb 59                	jmp    1ccd <balancer_ingress+0x1ccd>
    1c74:	0f b6 85 57 f1 ff ff 	movzbl -0xea9(%rbp),%eax
    1c7b:	83 f8 02             	cmp    $0x2,%eax
    1c7e:	75 15                	jne    1c95 <balancer_ingress+0x1c95>
    quic_packets_stats->cid_v2 += 1;
    1c80:	48 8b 85 58 f1 ff ff 	mov    -0xea8(%rbp),%rax
    1c87:	48 8b 48 40          	mov    0x40(%rax),%rcx
    1c8b:	48 83 c1 01          	add    $0x1,%rcx
    1c8f:	48 89 48 40          	mov    %rcx,0x40(%rax)
  } else if (cid_version == QUIC_CONNID_VERSION_V3) {
    1c93:	eb 36                	jmp    1ccb <balancer_ingress+0x1ccb>
    1c95:	0f b6 85 57 f1 ff ff 	movzbl -0xea9(%rbp),%eax
    1c9c:	83 f8 03             	cmp    $0x3,%eax
    1c9f:	75 15                	jne    1cb6 <balancer_ingress+0x1cb6>
    quic_packets_stats->cid_v3 += 1;
    1ca1:	48 8b 85 58 f1 ff ff 	mov    -0xea8(%rbp),%rax
    1ca8:	48 8b 48 48          	mov    0x48(%rax),%rcx
    1cac:	48 83 c1 01          	add    $0x1,%rcx
    1cb0:	48 89 48 48          	mov    %rcx,0x48(%rax)
  } else {
    1cb4:	eb 13                	jmp    1cc9 <balancer_ingress+0x1cc9>
    quic_packets_stats->cid_v0 += 1;
    1cb6:	48 8b 85 58 f1 ff ff 	mov    -0xea8(%rbp),%rax
    1cbd:	48 8b 48 30          	mov    0x30(%rax),%rcx
    1cc1:	48 83 c1 01          	add    $0x1,%rcx
    1cc5:	48 89 48 30          	mov    %rcx,0x30(%rax)
    1cc9:	eb 00                	jmp    1ccb <balancer_ingress+0x1ccb>
    1ccb:	eb 00                	jmp    1ccd <balancer_ingress+0x1ccd>
        __u32 key = qpr.server_id;
    1ccd:	8b 85 30 ec ff ff    	mov    -0x13d0(%rbp),%eax
    1cd3:	89 85 2c ec ff ff    	mov    %eax,-0x13d4(%rbp)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1cd9:	48 c7 85 18 ec ff ff 	movq   $0x0,-0x13e8(%rbp)
    1ce0:	00 00 00 00 
    1ce4:	c7 85 14 ec ff ff 02 	movl   $0x2,-0x13ec(%rbp)
    1ceb:	00 00 00 
    1cee:	8b 85 2c ec ff ff    	mov    -0x13d4(%rbp),%eax
    1cf4:	89 85 10 ec ff ff    	mov    %eax,-0x13f0(%rbp)
    1cfa:	c7 85 0c ec ff ff 02 	movl   $0x2,-0x13f4(%rbp)
    1d01:	00 00 00 
    1d04:	c7 85 08 ec ff ff 08 	movl   $0x8,-0x13f8(%rbp)
    1d0b:	00 00 00 
    1d0e:	83 bd 10 ec ff ff 02 	cmpl   $0x2,-0x13f0(%rbp)
    1d15:	73 21                	jae    1d38 <balancer_ingress+0x1d38>
    1d17:	8b 85 10 ec ff ff    	mov    -0x13f0(%rbp),%eax
    1d1d:	89 c1                	mov    %eax,%ecx
    1d1f:	48 b8 00 c0 27 f4 00 	movabs $0xffffc900f427c000,%rax
    1d26:	c9 ff ff 
    1d29:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    1d30:	00 
    1d31:	48 89 85 18 ec ff ff 	mov    %rax,-0x13e8(%rbp)
    1d38:	48 8b 85 18 ec ff ff 	mov    -0x13e8(%rbp),%rax
    1d3f:	48 89 85 00 ec ff ff 	mov    %rax,-0x1400(%rbp)
    1d46:	48 8b 85 00 ec ff ff 	mov    -0x1400(%rbp),%rax
    1d4d:	48 89 85 20 ec ff ff 	mov    %rax,-0x13e0(%rbp)
        if (real_pos) {
    1d54:	48 83 bd 20 ec ff ff 	cmpq   $0x0,-0x13e0(%rbp)
    1d5b:	00 
    1d5c:	0f 84 8d 04 00 00    	je     21ef <balancer_ingress+0x21ef>
          key = *real_pos;
    1d62:	48 8b 85 20 ec ff ff 	mov    -0x13e0(%rbp),%rax
    1d69:	8b 00                	mov    (%rax),%eax
    1d6b:	89 85 2c ec ff ff    	mov    %eax,-0x13d4(%rbp)
          if (key == 0) {
    1d71:	83 bd 2c ec ff ff 00 	cmpl   $0x0,-0x13d4(%rbp)
    1d78:	75 3b                	jne    1db5 <balancer_ingress+0x1db5>
            quic_packets_stats->cid_invalid_server_id += 1;
    1d7a:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    1d81:	48 8b 48 10          	mov    0x10(%rax),%rcx
    1d85:	48 83 c1 01          	add    $0x1,%rcx
    1d89:	48 89 48 10          	mov    %rcx,0x10(%rax)
            quic_packets_stats->cid_invalid_server_id_sample = qpr.server_id;
    1d8d:	48 63 8d 30 ec ff ff 	movslq -0x13d0(%rbp),%rcx
    1d94:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    1d9b:	48 89 48 18          	mov    %rcx,0x18(%rax)
            quic_packets_stats->ch_routed += 1;
    1d9f:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    1da6:	48 8b 08             	mov    (%rax),%rcx
    1da9:	48 83 c1 01          	add    $0x1,%rcx
    1dad:	48 89 08             	mov    %rcx,(%rax)
          } else {
    1db0:	e9 38 04 00 00       	jmp    21ed <balancer_ingress+0x21ed>
            pckt.real_index = key;
    1db5:	8b 85 2c ec ff ff    	mov    -0x13d4(%rbp),%eax
    1dbb:	89 85 d0 ed ff ff    	mov    %eax,-0x1230(%rbp)
            dst = bpf_map_lookup_elem(&reals, &key);
    1dc1:	48 c7 85 f8 eb ff ff 	movq   $0x0,-0x1408(%rbp)
    1dc8:	00 00 00 00 
    1dcc:	c7 85 f4 eb ff ff 02 	movl   $0x2,-0x140c(%rbp)
    1dd3:	00 00 00 
    1dd6:	8b 85 2c ec ff ff    	mov    -0x13d4(%rbp),%eax
    1ddc:	89 85 f0 eb ff ff    	mov    %eax,-0x1410(%rbp)
    1de2:	c7 85 ec eb ff ff 02 	movl   $0x2,-0x1414(%rbp)
    1de9:	00 00 00 
    1dec:	c7 85 e8 eb ff ff 08 	movl   $0x8,-0x1418(%rbp)
    1df3:	00 00 00 
    1df6:	83 bd f0 eb ff ff 02 	cmpl   $0x2,-0x1410(%rbp)
    1dfd:	73 21                	jae    1e20 <balancer_ingress+0x1e20>
    1dff:	8b 85 f0 eb ff ff    	mov    -0x1410(%rbp),%eax
    1e05:	89 c1                	mov    %eax,%ecx
    1e07:	48 b8 00 30 50 52 00 	movabs $0xffffc90052503000,%rax
    1e0e:	c9 ff ff 
    1e11:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    1e18:	00 
    1e19:	48 89 85 f8 eb ff ff 	mov    %rax,-0x1408(%rbp)
    1e20:	48 8b 85 f8 eb ff ff 	mov    -0x1408(%rbp),%rax
    1e27:	48 89 85 e0 eb ff ff 	mov    %rax,-0x1420(%rbp)
    1e2e:	48 8b 85 e0 eb ff ff 	mov    -0x1420(%rbp),%rax
    1e35:	48 89 85 d8 ed ff ff 	mov    %rax,-0x1228(%rbp)
            if (!dst) {
    1e3c:	48 83 bd d8 ed ff ff 	cmpq   $0x0,-0x1228(%rbp)
    1e43:	00 
    1e44:	75 22                	jne    1e68 <balancer_ingress+0x1e68>
              quic_packets_stats->cid_unknown_real_dropped += 1;
    1e46:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    1e4d:	48 8b 48 28          	mov    0x28(%rax),%rcx
    1e51:	48 83 c1 01          	add    $0x1,%rcx
    1e55:	48 89 48 28          	mov    %rcx,0x28(%rax)
              return XDP_DROP;
    1e59:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    1e60:	00 00 00 
    1e63:	e9 57 1d 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
            int res = check_and_update_real_index_in_lru(&pckt, lru_map);
    1e68:	48 8b 85 e8 ec ff ff 	mov    -0x1318(%rbp),%rax
    1e6f:	48 8d 8d a8 ed ff ff 	lea    -0x1258(%rbp),%rcx
    1e76:	48 89 8d 98 f1 ff ff 	mov    %rcx,-0xe68(%rbp)
    1e7d:	48 89 85 90 f1 ff ff 	mov    %rax,-0xe70(%rbp)
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1e84:	48 b8 88 7f 00 00 00 	movabs $0x7f88,%rax
    1e8b:	00 00 00 
    1e8e:	48 8b 00             	mov    (%rax),%rax
    1e91:	48 8b bd 90 f1 ff ff 	mov    -0xe70(%rbp),%rdi
    1e98:	48 8b b5 98 f1 ff ff 	mov    -0xe68(%rbp),%rsi
    1e9f:	ff d0                	call   *%rax
    1ea1:	48 89 85 88 f1 ff ff 	mov    %rax,-0xe78(%rbp)
  if (dst_lru) {
    1ea8:	48 83 bd 88 f1 ff ff 	cmpq   $0x0,-0xe78(%rbp)
    1eaf:	00 
    1eb0:	74 46                	je     1ef8 <balancer_ingress+0x1ef8>
    if (dst_lru->pos == pckt->real_index) {
    1eb2:	48 8b 85 88 f1 ff ff 	mov    -0xe78(%rbp),%rax
    1eb9:	8b 00                	mov    (%rax),%eax
    1ebb:	48 8b 8d 98 f1 ff ff 	mov    -0xe68(%rbp),%rcx
    1ec2:	3b 41 28             	cmp    0x28(%rcx),%eax
    1ec5:	75 0f                	jne    1ed6 <balancer_ingress+0x1ed6>
      return DST_MATCH_IN_LRU;
    1ec7:	c7 85 a4 f1 ff ff 00 	movl   $0x0,-0xe5c(%rbp)
    1ece:	00 00 00 
    1ed1:	e9 c9 01 00 00       	jmp    209f <balancer_ingress+0x209f>
      dst_lru->pos = pckt->real_index;
    1ed6:	48 8b 85 98 f1 ff ff 	mov    -0xe68(%rbp),%rax
    1edd:	8b 48 28             	mov    0x28(%rax),%ecx
    1ee0:	48 8b 85 88 f1 ff ff 	mov    -0xe78(%rbp),%rax
    1ee7:	89 08                	mov    %ecx,(%rax)
      return DST_MISMATCH_IN_LRU;
    1ee9:	c7 85 a4 f1 ff ff 01 	movl   $0x1,-0xe5c(%rbp)
    1ef0:	00 00 00 
    1ef3:	e9 a7 01 00 00       	jmp    209f <balancer_ingress+0x209f>
    1ef8:	48 8d 85 80 f1 ff ff 	lea    -0xe80(%rbp),%rax
    1eff:	48 89 85 c8 fd ff ff 	mov    %rax,-0x238(%rbp)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1f06:	c7 85 c4 fd ff ff 02 	movl   $0x202,-0x23c(%rbp)
    1f0d:	02 00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1f10:	48 c7 85 b0 fd ff ff 	movq   $0x0,-0x250(%rbp)
    1f17:	00 00 00 00 
    1f1b:	c7 85 ac fd ff ff 02 	movl   $0x2,-0x254(%rbp)
    1f22:	00 00 00 
    1f25:	8b 85 c4 fd ff ff    	mov    -0x23c(%rbp),%eax
    1f2b:	89 85 a8 fd ff ff    	mov    %eax,-0x258(%rbp)
    1f31:	c7 85 a4 fd ff ff 02 	movl   $0x2,-0x25c(%rbp)
    1f38:	00 00 00 
    1f3b:	c7 85 a0 fd ff ff 08 	movl   $0x8,-0x260(%rbp)
    1f42:	00 00 00 
    1f45:	83 bd a8 fd ff ff 02 	cmpl   $0x2,-0x258(%rbp)
    1f4c:	73 21                	jae    1f6f <balancer_ingress+0x1f6f>
    1f4e:	8b 85 a8 fd ff ff    	mov    -0x258(%rbp),%eax
    1f54:	89 c1                	mov    %eax,%ecx
    1f56:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    1f5d:	88 ff ff 
    1f60:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    1f67:	00 
    1f68:	48 89 85 b0 fd ff ff 	mov    %rax,-0x250(%rbp)
    1f6f:	48 8b 85 b0 fd ff ff 	mov    -0x250(%rbp),%rax
    1f76:	48 89 85 98 fd ff ff 	mov    %rax,-0x268(%rbp)
    1f7d:	48 8b 85 98 fd ff ff 	mov    -0x268(%rbp),%rax
  struct lb_stats* conn_rate_stats =
    1f84:	48 89 85 b8 fd ff ff 	mov    %rax,-0x248(%rbp)
  if (!conn_rate_stats) {
    1f8b:	48 83 bd b8 fd ff ff 	cmpq   $0x0,-0x248(%rbp)
    1f92:	00 
    1f93:	75 0c                	jne    1fa1 <balancer_ingress+0x1fa1>
    return true;
    1f95:	c6 85 d6 fd ff ff 01 	movb   $0x1,-0x22a(%rbp)
    1f9c:	e9 91 00 00 00       	jmp    2032 <balancer_ingress+0x2032>
  *cur_time = bpf_ktime_get_ns();
    1fa1:	48 b8 98 7f 00 00 00 	movabs $0x7f98,%rax
    1fa8:	00 00 00 
    1fab:	48 8b 00             	mov    (%rax),%rax
    1fae:	ff d0                	call   *%rax
    1fb0:	48 89 c1             	mov    %rax,%rcx
    1fb3:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
    1fba:	48 89 08             	mov    %rcx,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1fbd:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
    1fc4:	48 8b 00             	mov    (%rax),%rax
    1fc7:	48 8b 8d b8 fd ff ff 	mov    -0x248(%rbp),%rcx
    1fce:	48 2b 41 08          	sub    0x8(%rcx),%rax
    1fd2:	48 3d 00 ca 9a 3b    	cmp    $0x3b9aca00,%rax
    1fd8:	76 25                	jbe    1fff <balancer_ingress+0x1fff>
    conn_rate_stats->v1 = 1;
    1fda:	48 8b 85 b8 fd ff ff 	mov    -0x248(%rbp),%rax
    1fe1:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    conn_rate_stats->v2 = *cur_time;
    1fe8:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
    1fef:	48 8b 08             	mov    (%rax),%rcx
    1ff2:	48 8b 85 b8 fd ff ff 	mov    -0x248(%rbp),%rax
    1ff9:	48 89 48 08          	mov    %rcx,0x8(%rax)
  } else {
    1ffd:	eb 2c                	jmp    202b <balancer_ingress+0x202b>
    conn_rate_stats->v1 += 1;
    1fff:	48 8b 85 b8 fd ff ff 	mov    -0x248(%rbp),%rax
    2006:	48 8b 08             	mov    (%rax),%rcx
    2009:	48 83 c1 01          	add    $0x1,%rcx
    200d:	48 89 08             	mov    %rcx,(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2010:	48 8b 85 b8 fd ff ff 	mov    -0x248(%rbp),%rax
    2017:	48 81 38 48 e8 01 00 	cmpq   $0x1e848,(%rax)
    201e:	76 09                	jbe    2029 <balancer_ingress+0x2029>
      return true;
    2020:	c6 85 d6 fd ff ff 01 	movb   $0x1,-0x22a(%rbp)
    2027:	eb 09                	jmp    2032 <balancer_ingress+0x2032>
    2029:	eb 00                	jmp    202b <balancer_ingress+0x202b>
  return false;
    202b:	c6 85 d6 fd ff ff 00 	movb   $0x0,-0x22a(%rbp)
  if (is_under_flood(&cur_time)) {
    2032:	f6 85 d6 fd ff ff 01 	testb  $0x1,-0x22a(%rbp)
    2039:	75 02                	jne    203d <balancer_ingress+0x203d>
    203b:	eb 0c                	jmp    2049 <balancer_ingress+0x2049>
    return DST_NOT_FOUND_IN_LRU;
    203d:	c7 85 a4 f1 ff ff 02 	movl   $0x2,-0xe5c(%rbp)
    2044:	00 00 00 
    2047:	eb 56                	jmp    209f <balancer_ingress+0x209f>
  struct real_pos_lru new_dst_lru = {};
    2049:	48 c7 85 78 f1 ff ff 	movq   $0x0,-0xe88(%rbp)
    2050:	00 00 00 00 
    2054:	48 c7 85 70 f1 ff ff 	movq   $0x0,-0xe90(%rbp)
    205b:	00 00 00 00 
  new_dst_lru.pos = pckt->real_index;
    205f:	48 8b 85 98 f1 ff ff 	mov    -0xe68(%rbp),%rax
    2066:	8b 40 28             	mov    0x28(%rax),%eax
    2069:	89 85 70 f1 ff ff    	mov    %eax,-0xe90(%rbp)
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    206f:	48 b8 90 7f 00 00 00 	movabs $0x7f90,%rax
    2076:	00 00 00 
    2079:	48 8b 00             	mov    (%rax),%rax
    207c:	48 8b bd 90 f1 ff ff 	mov    -0xe70(%rbp),%rdi
    2083:	48 8b b5 98 f1 ff ff 	mov    -0xe68(%rbp),%rsi
    208a:	48 8d 95 70 f1 ff ff 	lea    -0xe90(%rbp),%rdx
    2091:	31 c9                	xor    %ecx,%ecx
    2093:	ff d0                	call   *%rax
  return DST_NOT_FOUND_IN_LRU;
    2095:	c7 85 a4 f1 ff ff 02 	movl   $0x2,-0xe5c(%rbp)
    209c:	00 00 00 
}
    209f:	8b 85 a4 f1 ff ff    	mov    -0xe5c(%rbp),%eax
            int res = check_and_update_real_index_in_lru(&pckt, lru_map);
    20a5:	89 85 dc eb ff ff    	mov    %eax,-0x1424(%rbp)
            if (res == DST_MATCH_IN_LRU) {
    20ab:	83 bd dc eb ff ff 00 	cmpl   $0x0,-0x1424(%rbp)
    20b2:	75 18                	jne    20cc <balancer_ingress+0x20cc>
              quic_packets_stats->dst_match_in_lru += 1;
    20b4:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    20bb:	48 8b 48 50          	mov    0x50(%rax),%rcx
    20bf:	48 83 c1 01          	add    $0x1,%rcx
    20c3:	48 89 48 50          	mov    %rcx,0x50(%rax)
            } else if (res == DST_MISMATCH_IN_LRU) {
    20c7:	e9 0e 01 00 00       	jmp    21da <balancer_ingress+0x21da>
    20cc:	83 bd dc eb ff ff 01 	cmpl   $0x1,-0x1424(%rbp)
    20d3:	0f 85 ec 00 00 00    	jne    21c5 <balancer_ingress+0x21c5>
              quic_packets_stats->dst_mismatch_in_lru += 1;
    20d9:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    20e0:	48 8b 48 58          	mov    0x58(%rax),%rcx
    20e4:	48 83 c1 01          	add    $0x1,%rcx
    20e8:	48 89 48 58          	mov    %rcx,0x58(%rax)
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    20ec:	8b 85 74 ed ff ff    	mov    -0x128c(%rbp),%eax
    20f2:	89 85 0c f2 ff ff    	mov    %eax,-0xdf4(%rbp)
    20f8:	c6 85 0b f2 ff ff 00 	movb   $0x0,-0xdf5(%rbp)
    20ff:	c6 85 0a f2 ff ff 01 	movb   $0x1,-0xdf6(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2106:	48 c7 85 f8 f1 ff ff 	movq   $0x0,-0xe08(%rbp)
    210d:	00 00 00 00 
    2111:	c7 85 f4 f1 ff ff 02 	movl   $0x2,-0xe0c(%rbp)
    2118:	00 00 00 
    211b:	8b 85 0c f2 ff ff    	mov    -0xdf4(%rbp),%eax
    2121:	89 85 f0 f1 ff ff    	mov    %eax,-0xe10(%rbp)
    2127:	c7 85 ec f1 ff ff 02 	movl   $0x2,-0xe14(%rbp)
    212e:	00 00 00 
    2131:	c7 85 e8 f1 ff ff 08 	movl   $0x8,-0xe18(%rbp)
    2138:	00 00 00 
    213b:	83 bd f0 f1 ff ff 02 	cmpl   $0x2,-0xe10(%rbp)
    2142:	73 21                	jae    2165 <balancer_ingress+0x2165>
    2144:	8b 85 f0 f1 ff ff    	mov    -0xe10(%rbp),%eax
    214a:	89 c1                	mov    %eax,%ecx
    214c:	48 b8 00 80 b4 1f 81 	movabs $0xffff88811fb48000,%rax
    2153:	88 ff ff 
    2156:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    215d:	00 
    215e:	48 89 85 f8 f1 ff ff 	mov    %rax,-0xe08(%rbp)
    2165:	48 8b 85 f8 f1 ff ff 	mov    -0xe08(%rbp),%rax
    216c:	48 89 85 e0 f1 ff ff 	mov    %rax,-0xe20(%rbp)
    2173:	48 8b 85 e0 f1 ff ff 	mov    -0xe20(%rbp),%rax
  struct lb_stats* per_vip_stats =
    217a:	48 89 85 00 f2 ff ff 	mov    %rax,-0xe00(%rbp)
  if (!per_vip_stats) {
    2181:	48 83 bd 00 f2 ff ff 	cmpq   $0x0,-0xe00(%rbp)
    2188:	00 
    2189:	75 02                	jne    218d <balancer_ingress+0x218d>
    return;
    218b:	eb 36                	jmp    21c3 <balancer_ingress+0x21c3>
  if (newConn) {
    218d:	f6 85 0b f2 ff ff 01 	testb  $0x1,-0xdf5(%rbp)
    2194:	74 11                	je     21a7 <balancer_ingress+0x21a7>
    per_vip_stats->v1 += 1;
    2196:	48 8b 85 00 f2 ff ff 	mov    -0xe00(%rbp),%rax
    219d:	48 8b 08             	mov    (%rax),%rcx
    21a0:	48 83 c1 01          	add    $0x1,%rcx
    21a4:	48 89 08             	mov    %rcx,(%rax)
  if (misMatchInLRU) {
    21a7:	f6 85 0a f2 ff ff 01 	testb  $0x1,-0xdf6(%rbp)
    21ae:	74 13                	je     21c3 <balancer_ingress+0x21c3>
    per_vip_stats->v2 += 1;
    21b0:	48 8b 85 00 f2 ff ff 	mov    -0xe00(%rbp),%rax
    21b7:	48 8b 48 08          	mov    0x8(%rax),%rcx
    21bb:	48 83 c1 01          	add    $0x1,%rcx
    21bf:	48 89 48 08          	mov    %rcx,0x8(%rax)
            } else {
    21c3:	eb 13                	jmp    21d8 <balancer_ingress+0x21d8>
              quic_packets_stats->dst_not_found_in_lru += 1;
    21c5:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    21cc:	48 8b 48 60          	mov    0x60(%rax),%rcx
    21d0:	48 83 c1 01          	add    $0x1,%rcx
    21d4:	48 89 48 60          	mov    %rcx,0x60(%rax)
    21d8:	eb 00                	jmp    21da <balancer_ingress+0x21da>
            quic_packets_stats->cid_routed += 1;
    21da:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    21e1:	48 8b 48 20          	mov    0x20(%rax),%rcx
    21e5:	48 83 c1 01          	add    $0x1,%rcx
    21e9:	48 89 48 20          	mov    %rcx,0x20(%rax)
        } else {
    21ed:	eb 36                	jmp    2225 <balancer_ingress+0x2225>
          quic_packets_stats->cid_invalid_server_id += 1;
    21ef:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    21f6:	48 8b 48 10          	mov    0x10(%rax),%rcx
    21fa:	48 83 c1 01          	add    $0x1,%rcx
    21fe:	48 89 48 10          	mov    %rcx,0x10(%rax)
          quic_packets_stats->cid_invalid_server_id_sample = qpr.server_id;
    2202:	48 63 8d 30 ec ff ff 	movslq -0x13d0(%rbp),%rcx
    2209:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    2210:	48 89 48 18          	mov    %rcx,0x18(%rax)
          quic_packets_stats->ch_routed += 1;
    2214:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    221b:	48 8b 08             	mov    (%rax),%rcx
    221e:	48 83 c1 01          	add    $0x1,%rcx
    2222:	48 89 08             	mov    %rcx,(%rax)
      } else if (!qpr.is_initial) {
    2225:	e9 0d 01 00 00       	jmp    2337 <balancer_ingress+0x2337>
    222a:	f6 85 35 ec ff ff 01 	testb  $0x1,-0x13cb(%rbp)
    2231:	75 16                	jne    2249 <balancer_ingress+0x2249>
        quic_packets_stats->ch_routed += 1;
    2233:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    223a:	48 8b 08             	mov    (%rax),%rcx
    223d:	48 83 c1 01          	add    $0x1,%rcx
    2241:	48 89 08             	mov    %rcx,(%rax)
      } else {
    2244:	e9 ec 00 00 00       	jmp    2335 <balancer_ingress+0x2335>
        quic_packets_stats->cid_initial += 1;
    2249:	48 8b 85 58 ec ff ff 	mov    -0x13a8(%rbp),%rax
    2250:	48 8b 48 08          	mov    0x8(%rax),%rcx
    2254:	48 83 c1 01          	add    $0x1,%rcx
    2258:	48 89 48 08          	mov    %rcx,0x8(%rax)
            vip_num, /* new conn */ true, /* mismatch in lru */ false);
    225c:	8b 85 74 ed ff ff    	mov    -0x128c(%rbp),%eax
    2262:	89 85 3c f2 ff ff    	mov    %eax,-0xdc4(%rbp)
    2268:	c6 85 3b f2 ff ff 01 	movb   $0x1,-0xdc5(%rbp)
    226f:	c6 85 3a f2 ff ff 00 	movb   $0x0,-0xdc6(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2276:	48 c7 85 28 f2 ff ff 	movq   $0x0,-0xdd8(%rbp)
    227d:	00 00 00 00 
    2281:	c7 85 24 f2 ff ff 02 	movl   $0x2,-0xddc(%rbp)
    2288:	00 00 00 
    228b:	8b 85 3c f2 ff ff    	mov    -0xdc4(%rbp),%eax
    2291:	89 85 20 f2 ff ff    	mov    %eax,-0xde0(%rbp)
    2297:	c7 85 1c f2 ff ff 02 	movl   $0x2,-0xde4(%rbp)
    229e:	00 00 00 
    22a1:	c7 85 18 f2 ff ff 08 	movl   $0x8,-0xde8(%rbp)
    22a8:	00 00 00 
    22ab:	83 bd 20 f2 ff ff 02 	cmpl   $0x2,-0xde0(%rbp)
    22b2:	73 21                	jae    22d5 <balancer_ingress+0x22d5>
    22b4:	8b 85 20 f2 ff ff    	mov    -0xde0(%rbp),%eax
    22ba:	89 c1                	mov    %eax,%ecx
    22bc:	48 b8 00 80 b4 1f 81 	movabs $0xffff88811fb48000,%rax
    22c3:	88 ff ff 
    22c6:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    22cd:	00 
    22ce:	48 89 85 28 f2 ff ff 	mov    %rax,-0xdd8(%rbp)
    22d5:	48 8b 85 28 f2 ff ff 	mov    -0xdd8(%rbp),%rax
    22dc:	48 89 85 10 f2 ff ff 	mov    %rax,-0xdf0(%rbp)
    22e3:	48 8b 85 10 f2 ff ff 	mov    -0xdf0(%rbp),%rax
  struct lb_stats* per_vip_stats =
    22ea:	48 89 85 30 f2 ff ff 	mov    %rax,-0xdd0(%rbp)
  if (!per_vip_stats) {
    22f1:	48 83 bd 30 f2 ff ff 	cmpq   $0x0,-0xdd0(%rbp)
    22f8:	00 
    22f9:	75 02                	jne    22fd <balancer_ingress+0x22fd>
    return;
    22fb:	eb 36                	jmp    2333 <balancer_ingress+0x2333>
  if (newConn) {
    22fd:	f6 85 3b f2 ff ff 01 	testb  $0x1,-0xdc5(%rbp)
    2304:	74 11                	je     2317 <balancer_ingress+0x2317>
    per_vip_stats->v1 += 1;
    2306:	48 8b 85 30 f2 ff ff 	mov    -0xdd0(%rbp),%rax
    230d:	48 8b 08             	mov    (%rax),%rcx
    2310:	48 83 c1 01          	add    $0x1,%rcx
    2314:	48 89 08             	mov    %rcx,(%rax)
  if (misMatchInLRU) {
    2317:	f6 85 3a f2 ff ff 01 	testb  $0x1,-0xdc6(%rbp)
    231e:	74 13                	je     2333 <balancer_ingress+0x2333>
    per_vip_stats->v2 += 1;
    2320:	48 8b 85 30 f2 ff ff 	mov    -0xdd0(%rbp),%rax
    2327:	48 8b 48 08          	mov    0x8(%rax),%rcx
    232b:	48 83 c1 01          	add    $0x1,%rcx
    232f:	48 89 48 08          	mov    %rcx,0x8(%rax)
    2333:	eb 00                	jmp    2335 <balancer_ingress+0x2335>
    2335:	eb 00                	jmp    2337 <balancer_ingress+0x2337>
    2337:	eb 00                	jmp    2339 <balancer_ingress+0x2339>
  }
    2339:	eb 00                	jmp    233b <balancer_ingress+0x233b>
  original_sport = pckt.flow.port16[0];
    233b:	66 8b 85 c8 ed ff ff 	mov    -0x1238(%rbp),%ax
    2342:	66 89 85 7c ed ff ff 	mov    %ax,-0x1284(%rbp)
  if (!dst) {
    2349:	48 83 bd d8 ed ff ff 	cmpq   $0x0,-0x1228(%rbp)
    2350:	00 
    2351:	0f 85 b8 0e 00 00    	jne    320f <balancer_ingress+0x320f>
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    2357:	48 83 bd d8 ed ff ff 	cmpq   $0x0,-0x1228(%rbp)
    235e:	00 
    235f:	0f 85 92 01 00 00    	jne    24f7 <balancer_ingress+0x24f7>
    2365:	0f b6 85 d4 ed ff ff 	movzbl -0x122c(%rbp),%eax
    236c:	83 e0 02             	and    $0x2,%eax
    236f:	83 f8 00             	cmp    $0x0,%eax
    2372:	0f 85 7f 01 00 00    	jne    24f7 <balancer_ingress+0x24f7>
        !(vip_info->flags & F_LRU_BYPASS)) {
    2378:	48 8b 85 88 ed ff ff 	mov    -0x1278(%rbp),%rax
    237f:	8b 00                	mov    (%rax),%eax
    2381:	83 e0 02             	and    $0x2,%eax
    2384:	83 f8 00             	cmp    $0x0,%eax
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    2387:	0f 85 6a 01 00 00    	jne    24f7 <balancer_ingress+0x24f7>
      connection_table_lookup(&dst, &pckt, lru_map, /*isGlobalLru=*/false);
    238d:	48 8b 85 e8 ec ff ff 	mov    -0x1318(%rbp),%rax
    2394:	48 8d 8d d8 ed ff ff 	lea    -0x1228(%rbp),%rcx
    239b:	48 89 8d f0 f2 ff ff 	mov    %rcx,-0xd10(%rbp)
    23a2:	48 8d 8d a8 ed ff ff 	lea    -0x1258(%rbp),%rcx
    23a9:	48 89 8d e8 f2 ff ff 	mov    %rcx,-0xd18(%rbp)
    23b0:	48 89 85 e0 f2 ff ff 	mov    %rax,-0xd20(%rbp)
    23b7:	c6 85 df f2 ff ff 00 	movb   $0x0,-0xd21(%rbp)
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    23be:	48 b8 88 7f 00 00 00 	movabs $0x7f88,%rax
    23c5:	00 00 00 
    23c8:	48 8b 00             	mov    (%rax),%rax
    23cb:	48 8b bd e0 f2 ff ff 	mov    -0xd20(%rbp),%rdi
    23d2:	48 8b b5 e8 f2 ff ff 	mov    -0xd18(%rbp),%rsi
    23d9:	ff d0                	call   *%rax
    23db:	48 89 85 d0 f2 ff ff 	mov    %rax,-0xd30(%rbp)
  if (!dst_lru) {
    23e2:	48 83 bd d0 f2 ff ff 	cmpq   $0x0,-0xd30(%rbp)
    23e9:	00 
    23ea:	75 05                	jne    23f1 <balancer_ingress+0x23f1>
    return;
    23ec:	e9 04 01 00 00       	jmp    24f5 <balancer_ingress+0x24f5>
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    23f1:	f6 85 df f2 ff ff 01 	testb  $0x1,-0xd21(%rbp)
    23f8:	75 5e                	jne    2458 <balancer_ingress+0x2458>
    23fa:	48 8b 85 e8 f2 ff ff 	mov    -0xd18(%rbp),%rax
    2401:	0f b6 40 24          	movzbl 0x24(%rax),%eax
    2405:	83 f8 11             	cmp    $0x11,%eax
    2408:	75 4e                	jne    2458 <balancer_ingress+0x2458>
    cur_time = bpf_ktime_get_ns();
    240a:	48 b8 98 7f 00 00 00 	movabs $0x7f98,%rax
    2411:	00 00 00 
    2414:	48 8b 00             	mov    (%rax),%rax
    2417:	ff d0                	call   *%rax
    2419:	48 89 85 c8 f2 ff ff 	mov    %rax,-0xd38(%rbp)
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    2420:	48 8b 85 c8 f2 ff ff 	mov    -0xd38(%rbp),%rax
    2427:	48 8b 8d d0 f2 ff ff 	mov    -0xd30(%rbp),%rcx
    242e:	48 2b 41 08          	sub    0x8(%rcx),%rax
    2432:	48 b9 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rcx
    2439:	00 00 00 
    243c:	48 39 c8             	cmp    %rcx,%rax
    243f:	76 05                	jbe    2446 <balancer_ingress+0x2446>
      return;
    2441:	e9 af 00 00 00       	jmp    24f5 <balancer_ingress+0x24f5>
    dst_lru->atime = cur_time;
    2446:	48 8b 8d c8 f2 ff ff 	mov    -0xd38(%rbp),%rcx
    244d:	48 8b 85 d0 f2 ff ff 	mov    -0xd30(%rbp),%rax
    2454:	48 89 48 08          	mov    %rcx,0x8(%rax)
  key = dst_lru->pos;
    2458:	48 8b 85 d0 f2 ff ff 	mov    -0xd30(%rbp),%rax
    245f:	8b 00                	mov    (%rax),%eax
    2461:	89 85 c4 f2 ff ff    	mov    %eax,-0xd3c(%rbp)
  pckt->real_index = key;
    2467:	8b 8d c4 f2 ff ff    	mov    -0xd3c(%rbp),%ecx
    246d:	48 8b 85 e8 f2 ff ff 	mov    -0xd18(%rbp),%rax
    2474:	89 48 28             	mov    %ecx,0x28(%rax)
  *real = bpf_map_lookup_elem(&reals, &key);
    2477:	48 c7 85 b8 f2 ff ff 	movq   $0x0,-0xd48(%rbp)
    247e:	00 00 00 00 
    2482:	c7 85 b4 f2 ff ff 02 	movl   $0x2,-0xd4c(%rbp)
    2489:	00 00 00 
    248c:	8b 85 c4 f2 ff ff    	mov    -0xd3c(%rbp),%eax
    2492:	89 85 b0 f2 ff ff    	mov    %eax,-0xd50(%rbp)
    2498:	c7 85 ac f2 ff ff 02 	movl   $0x2,-0xd54(%rbp)
    249f:	00 00 00 
    24a2:	c7 85 a8 f2 ff ff 08 	movl   $0x8,-0xd58(%rbp)
    24a9:	00 00 00 
    24ac:	83 bd b0 f2 ff ff 02 	cmpl   $0x2,-0xd50(%rbp)
    24b3:	73 21                	jae    24d6 <balancer_ingress+0x24d6>
    24b5:	8b 85 b0 f2 ff ff    	mov    -0xd50(%rbp),%eax
    24bb:	89 c1                	mov    %eax,%ecx
    24bd:	48 b8 00 30 50 52 00 	movabs $0xffffc90052503000,%rax
    24c4:	c9 ff ff 
    24c7:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    24ce:	00 
    24cf:	48 89 85 b8 f2 ff ff 	mov    %rax,-0xd48(%rbp)
    24d6:	48 8b 85 b8 f2 ff ff 	mov    -0xd48(%rbp),%rax
    24dd:	48 89 85 a0 f2 ff ff 	mov    %rax,-0xd60(%rbp)
    24e4:	48 8b 8d a0 f2 ff ff 	mov    -0xd60(%rbp),%rcx
    24eb:	48 8b 85 f0 f2 ff ff 	mov    -0xd10(%rbp),%rax
    24f2:	48 89 08             	mov    %rcx,(%rax)
    }
    24f5:	eb 00                	jmp    24f7 <balancer_ingress+0x24f7>
    check_udp_flow_migration(&dst, &pckt, vip_info, &vip);
    24f7:	48 8b 85 88 ed ff ff 	mov    -0x1278(%rbp),%rax
    24fe:	48 8d 8d d8 ed ff ff 	lea    -0x1228(%rbp),%rcx
    2505:	48 89 8d d0 f3 ff ff 	mov    %rcx,-0xc30(%rbp)
    250c:	48 8d 8d a8 ed ff ff 	lea    -0x1258(%rbp),%rcx
    2513:	48 89 8d c8 f3 ff ff 	mov    %rcx,-0xc38(%rbp)
    251a:	48 89 85 c0 f3 ff ff 	mov    %rax,-0xc40(%rbp)
    2521:	48 8d 85 90 ed ff ff 	lea    -0x1270(%rbp),%rax
    2528:	48 89 85 b8 f3 ff ff 	mov    %rax,-0xc48(%rbp)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    252f:	48 83 bd d0 f3 ff ff 	cmpq   $0x0,-0xc30(%rbp)
    2536:	00 
    2537:	0f 84 e8 02 00 00    	je     2825 <balancer_ingress+0x2825>
    253d:	48 8b 85 c8 f3 ff ff 	mov    -0xc38(%rbp),%rax
    2544:	0f b6 40 24          	movzbl 0x24(%rax),%eax
    2548:	83 f8 11             	cmp    $0x11,%eax
    254b:	0f 85 d4 02 00 00    	jne    2825 <balancer_ingress+0x2825>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    2551:	48 8b 85 c0 f3 ff ff 	mov    -0xc40(%rbp),%rax
    2558:	8b 00                	mov    (%rax),%eax
    255a:	25 00 02 00 00       	and    $0x200,%eax
    255f:	83 f8 00             	cmp    $0x0,%eax
    2562:	0f 84 bd 02 00 00    	je     2825 <balancer_ingress+0x2825>
    2568:	48 8d 85 b0 f3 ff ff 	lea    -0xc50(%rbp),%rax
    256f:	48 89 85 48 fd ff ff 	mov    %rax,-0x2b8(%rbp)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    2576:	c7 85 44 fd ff ff 02 	movl   $0x202,-0x2bc(%rbp)
    257d:	02 00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2580:	48 c7 85 30 fd ff ff 	movq   $0x0,-0x2d0(%rbp)
    2587:	00 00 00 00 
    258b:	c7 85 2c fd ff ff 02 	movl   $0x2,-0x2d4(%rbp)
    2592:	00 00 00 
    2595:	8b 85 44 fd ff ff    	mov    -0x2bc(%rbp),%eax
    259b:	89 85 28 fd ff ff    	mov    %eax,-0x2d8(%rbp)
    25a1:	c7 85 24 fd ff ff 02 	movl   $0x2,-0x2dc(%rbp)
    25a8:	00 00 00 
    25ab:	c7 85 20 fd ff ff 08 	movl   $0x8,-0x2e0(%rbp)
    25b2:	00 00 00 
    25b5:	83 bd 28 fd ff ff 02 	cmpl   $0x2,-0x2d8(%rbp)
    25bc:	73 21                	jae    25df <balancer_ingress+0x25df>
    25be:	8b 85 28 fd ff ff    	mov    -0x2d8(%rbp),%eax
    25c4:	89 c1                	mov    %eax,%ecx
    25c6:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    25cd:	88 ff ff 
    25d0:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    25d7:	00 
    25d8:	48 89 85 30 fd ff ff 	mov    %rax,-0x2d0(%rbp)
    25df:	48 8b 85 30 fd ff ff 	mov    -0x2d0(%rbp),%rax
    25e6:	48 89 85 18 fd ff ff 	mov    %rax,-0x2e8(%rbp)
    25ed:	48 8b 85 18 fd ff ff 	mov    -0x2e8(%rbp),%rax
  struct lb_stats* conn_rate_stats =
    25f4:	48 89 85 38 fd ff ff 	mov    %rax,-0x2c8(%rbp)
  if (!conn_rate_stats) {
    25fb:	48 83 bd 38 fd ff ff 	cmpq   $0x0,-0x2c8(%rbp)
    2602:	00 
    2603:	75 0c                	jne    2611 <balancer_ingress+0x2611>
    return true;
    2605:	c6 85 57 fd ff ff 01 	movb   $0x1,-0x2a9(%rbp)
    260c:	e9 91 00 00 00       	jmp    26a2 <balancer_ingress+0x26a2>
  *cur_time = bpf_ktime_get_ns();
    2611:	48 b8 98 7f 00 00 00 	movabs $0x7f98,%rax
    2618:	00 00 00 
    261b:	48 8b 00             	mov    (%rax),%rax
    261e:	ff d0                	call   *%rax
    2620:	48 89 c1             	mov    %rax,%rcx
    2623:	48 8b 85 48 fd ff ff 	mov    -0x2b8(%rbp),%rax
    262a:	48 89 08             	mov    %rcx,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    262d:	48 8b 85 48 fd ff ff 	mov    -0x2b8(%rbp),%rax
    2634:	48 8b 00             	mov    (%rax),%rax
    2637:	48 8b 8d 38 fd ff ff 	mov    -0x2c8(%rbp),%rcx
    263e:	48 2b 41 08          	sub    0x8(%rcx),%rax
    2642:	48 3d 00 ca 9a 3b    	cmp    $0x3b9aca00,%rax
    2648:	76 25                	jbe    266f <balancer_ingress+0x266f>
    conn_rate_stats->v1 = 1;
    264a:	48 8b 85 38 fd ff ff 	mov    -0x2c8(%rbp),%rax
    2651:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    conn_rate_stats->v2 = *cur_time;
    2658:	48 8b 85 48 fd ff ff 	mov    -0x2b8(%rbp),%rax
    265f:	48 8b 08             	mov    (%rax),%rcx
    2662:	48 8b 85 38 fd ff ff 	mov    -0x2c8(%rbp),%rax
    2669:	48 89 48 08          	mov    %rcx,0x8(%rax)
  } else {
    266d:	eb 2c                	jmp    269b <balancer_ingress+0x269b>
    conn_rate_stats->v1 += 1;
    266f:	48 8b 85 38 fd ff ff 	mov    -0x2c8(%rbp),%rax
    2676:	48 8b 08             	mov    (%rax),%rcx
    2679:	48 83 c1 01          	add    $0x1,%rcx
    267d:	48 89 08             	mov    %rcx,(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2680:	48 8b 85 38 fd ff ff 	mov    -0x2c8(%rbp),%rax
    2687:	48 81 38 48 e8 01 00 	cmpq   $0x1e848,(%rax)
    268e:	76 09                	jbe    2699 <balancer_ingress+0x2699>
      return true;
    2690:	c6 85 57 fd ff ff 01 	movb   $0x1,-0x2a9(%rbp)
    2697:	eb 09                	jmp    26a2 <balancer_ingress+0x26a2>
    2699:	eb 00                	jmp    269b <balancer_ingress+0x269b>
  return false;
    269b:	c6 85 57 fd ff ff 00 	movb   $0x0,-0x2a9(%rbp)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    26a2:	f6 85 57 fd ff ff 01 	testb  $0x1,-0x2a9(%rbp)
    26a9:	0f 85 76 01 00 00    	jne    2825 <balancer_ingress+0x2825>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    26af:	48 c7 85 a0 f3 ff ff 	movq   $0x0,-0xc60(%rbp)
    26b6:	00 00 00 00 
    26ba:	c7 85 9c f3 ff ff 02 	movl   $0x2,-0xc64(%rbp)
    26c1:	00 00 00 
    26c4:	48 8b 85 b8 f3 ff ff 	mov    -0xc48(%rbp),%rax
    26cb:	8b 00                	mov    (%rax),%eax
    26cd:	89 85 98 f3 ff ff    	mov    %eax,-0xc68(%rbp)
    26d3:	c7 85 94 f3 ff ff 02 	movl   $0x2,-0xc6c(%rbp)
    26da:	00 00 00 
    26dd:	c7 85 90 f3 ff ff 08 	movl   $0x8,-0xc70(%rbp)
    26e4:	00 00 00 
    26e7:	83 bd 98 f3 ff ff 02 	cmpl   $0x2,-0xc68(%rbp)
    26ee:	73 21                	jae    2711 <balancer_ingress+0x2711>
    26f0:	8b 85 98 f3 ff ff    	mov    -0xc68(%rbp),%eax
    26f6:	89 c1                	mov    %eax,%ecx
    26f8:	48 b8 00 20 11 3a 81 	movabs $0xffff88813a112000,%rax
    26ff:	88 ff ff 
    2702:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    2709:	00 
    270a:	48 89 85 a0 f3 ff ff 	mov    %rax,-0xc60(%rbp)
    2711:	48 8b 85 a0 f3 ff ff 	mov    -0xc60(%rbp),%rax
    2718:	48 89 85 88 f3 ff ff 	mov    %rax,-0xc78(%rbp)
    271f:	48 8b 85 88 f3 ff ff 	mov    -0xc78(%rbp),%rax
    2726:	48 89 85 a8 f3 ff ff 	mov    %rax,-0xc58(%rbp)
    if (down_reals_map) {
    272d:	48 83 bd a8 f3 ff ff 	cmpq   $0x0,-0xc58(%rbp)
    2734:	00 
    2735:	0f 84 e8 00 00 00    	je     2823 <balancer_ingress+0x2823>
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    273b:	48 b8 88 7f 00 00 00 	movabs $0x7f88,%rax
    2742:	00 00 00 
    2745:	48 8b 00             	mov    (%rax),%rax
    2748:	48 8b bd a8 f3 ff ff 	mov    -0xc58(%rbp),%rdi
    274f:	48 8b b5 c8 f3 ff ff 	mov    -0xc38(%rbp),%rsi
    2756:	48 83 c6 28          	add    $0x28,%rsi
    275a:	ff d0                	call   *%rax
    275c:	48 89 85 80 f3 ff ff 	mov    %rax,-0xc80(%rbp)
      if (down_real) {
    2763:	48 83 bd 80 f3 ff ff 	cmpq   $0x0,-0xc80(%rbp)
    276a:	00 
    276b:	0f 84 b0 00 00 00    	je     2821 <balancer_ingress+0x2821>
        *dst = NULL;
    2771:	48 8b 85 d0 f3 ff ff 	mov    -0xc30(%rbp),%rax
    2778:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
    277f:	c7 85 7c f3 ff ff 0f 	movl   $0x20f,-0xc84(%rbp)
    2786:	02 00 00 
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    2789:	48 c7 85 68 f3 ff ff 	movq   $0x0,-0xc98(%rbp)
    2790:	00 00 00 00 
    2794:	c7 85 64 f3 ff ff 02 	movl   $0x2,-0xc9c(%rbp)
    279b:	00 00 00 
    279e:	8b 85 7c f3 ff ff    	mov    -0xc84(%rbp),%eax
    27a4:	89 85 60 f3 ff ff    	mov    %eax,-0xca0(%rbp)
    27aa:	c7 85 5c f3 ff ff 02 	movl   $0x2,-0xca4(%rbp)
    27b1:	00 00 00 
    27b4:	c7 85 58 f3 ff ff 08 	movl   $0x8,-0xca8(%rbp)
    27bb:	00 00 00 
    27be:	83 bd 60 f3 ff ff 02 	cmpl   $0x2,-0xca0(%rbp)
    27c5:	73 21                	jae    27e8 <balancer_ingress+0x27e8>
    27c7:	8b 85 60 f3 ff ff    	mov    -0xca0(%rbp),%eax
    27cd:	89 c1                	mov    %eax,%ecx
    27cf:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    27d6:	88 ff ff 
    27d9:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    27e0:	00 
    27e1:	48 89 85 68 f3 ff ff 	mov    %rax,-0xc98(%rbp)
    27e8:	48 8b 85 68 f3 ff ff 	mov    -0xc98(%rbp),%rax
    27ef:	48 89 85 50 f3 ff ff 	mov    %rax,-0xcb0(%rbp)
    27f6:	48 8b 85 50 f3 ff ff 	mov    -0xcb0(%rbp),%rax
    27fd:	48 89 85 70 f3 ff ff 	mov    %rax,-0xc90(%rbp)
        if (stats_data) {
    2804:	48 83 bd 70 f3 ff ff 	cmpq   $0x0,-0xc90(%rbp)
    280b:	00 
    280c:	74 11                	je     281f <balancer_ingress+0x281f>
          stats_data->v1 += 1;
    280e:	48 8b 85 70 f3 ff ff 	mov    -0xc90(%rbp),%rax
    2815:	48 8b 08             	mov    (%rax),%rcx
    2818:	48 83 c1 01          	add    $0x1,%rcx
    281c:	48 89 08             	mov    %rcx,(%rax)
      }
    281f:	eb 00                	jmp    2821 <balancer_ingress+0x2821>
    }
    2821:	eb 00                	jmp    2823 <balancer_ingress+0x2823>
  }
    2823:	eb 00                	jmp    2825 <balancer_ingress+0x2825>
    if (!dst) {
    2825:	48 83 bd d8 ed ff ff 	cmpq   $0x0,-0x1228(%rbp)
    282c:	00 
    282d:	0f 85 da 09 00 00    	jne    320d <balancer_ingress+0x320d>
      if (pckt.flow.proto == IPPROTO_TCP) {
    2833:	0f b6 85 cc ed ff ff 	movzbl -0x1234(%rbp),%eax
    283a:	83 f8 06             	cmp    $0x6,%eax
    283d:	0f 85 d5 00 00 00    	jne    2918 <balancer_ingress+0x2918>
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
    2843:	c7 85 d8 eb ff ff 01 	movl   $0x201,-0x1428(%rbp)
    284a:	02 00 00 
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    284d:	48 c7 85 c8 eb ff ff 	movq   $0x0,-0x1438(%rbp)
    2854:	00 00 00 00 
    2858:	c7 85 c4 eb ff ff 02 	movl   $0x2,-0x143c(%rbp)
    285f:	00 00 00 
    2862:	8b 85 d8 eb ff ff    	mov    -0x1428(%rbp),%eax
    2868:	89 85 c0 eb ff ff    	mov    %eax,-0x1440(%rbp)
    286e:	c7 85 bc eb ff ff 02 	movl   $0x2,-0x1444(%rbp)
    2875:	00 00 00 
    2878:	c7 85 b8 eb ff ff 08 	movl   $0x8,-0x1448(%rbp)
    287f:	00 00 00 
    2882:	83 bd c0 eb ff ff 02 	cmpl   $0x2,-0x1440(%rbp)
    2889:	73 21                	jae    28ac <balancer_ingress+0x28ac>
    288b:	8b 85 c0 eb ff ff    	mov    -0x1440(%rbp),%eax
    2891:	89 c1                	mov    %eax,%ecx
    2893:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    289a:	88 ff ff 
    289d:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    28a4:	00 
    28a5:	48 89 85 c8 eb ff ff 	mov    %rax,-0x1438(%rbp)
    28ac:	48 8b 85 c8 eb ff ff 	mov    -0x1438(%rbp),%rax
    28b3:	48 89 85 b0 eb ff ff 	mov    %rax,-0x1450(%rbp)
    28ba:	48 8b 85 b0 eb ff ff 	mov    -0x1450(%rbp),%rax
        struct lb_stats* lru_stats =
    28c1:	48 89 85 d0 eb ff ff 	mov    %rax,-0x1430(%rbp)
        if (!lru_stats) {
    28c8:	48 83 bd d0 eb ff ff 	cmpq   $0x0,-0x1430(%rbp)
    28cf:	00 
    28d0:	75 0f                	jne    28e1 <balancer_ingress+0x28e1>
          return XDP_DROP;
    28d2:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    28d9:	00 00 00 
    28dc:	e9 de 12 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
        if (pckt.flags & F_SYN_SET) {
    28e1:	0f b6 85 d4 ed ff ff 	movzbl -0x122c(%rbp),%eax
    28e8:	83 e0 02             	and    $0x2,%eax
    28eb:	83 f8 00             	cmp    $0x0,%eax
    28ee:	74 13                	je     2903 <balancer_ingress+0x2903>
          lru_stats->v1 += 1;
    28f0:	48 8b 85 d0 eb ff ff 	mov    -0x1430(%rbp),%rax
    28f7:	48 8b 08             	mov    (%rax),%rcx
    28fa:	48 83 c1 01          	add    $0x1,%rcx
    28fe:	48 89 08             	mov    %rcx,(%rax)
        } else {
    2901:	eb 13                	jmp    2916 <balancer_ingress+0x2916>
          lru_stats->v2 += 1;
    2903:	48 8b 85 d0 eb ff ff 	mov    -0x1430(%rbp),%rax
    290a:	48 8b 48 08          	mov    0x8(%rax),%rcx
    290e:	48 83 c1 01          	add    $0x1,%rcx
    2912:	48 89 48 08          	mov    %rcx,0x8(%rax)
      }
    2916:	eb 00                	jmp    2918 <balancer_ingress+0x2918>
      if (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6, lru_map)) {
    2918:	48 8b 95 88 ed ff ff 	mov    -0x1278(%rbp),%rdx
    291f:	8a 8d ff ed ff ff    	mov    -0x1201(%rbp),%cl
    2925:	48 8b 85 e8 ec ff ff 	mov    -0x1318(%rbp),%rax
    292c:	48 8d b5 d8 ed ff ff 	lea    -0x1228(%rbp),%rsi
    2933:	48 89 b5 f8 f4 ff ff 	mov    %rsi,-0xb08(%rbp)
    293a:	48 8d b5 a8 ed ff ff 	lea    -0x1258(%rbp),%rsi
    2941:	48 89 b5 f0 f4 ff ff 	mov    %rsi,-0xb10(%rbp)
    2948:	48 89 95 e8 f4 ff ff 	mov    %rdx,-0xb18(%rbp)
    294f:	80 e1 01             	and    $0x1,%cl
    2952:	88 8d e7 f4 ff ff    	mov    %cl,-0xb19(%rbp)
    2958:	48 89 85 d8 f4 ff ff 	mov    %rax,-0xb28(%rbp)
  struct real_pos_lru new_dst_lru = {};
    295f:	48 8d 85 c8 f4 ff ff 	lea    -0xb38(%rbp),%rax
    2966:	31 c9                	xor    %ecx,%ecx
    2968:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    296f:	00 
    2970:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  bool under_flood = false;
    2977:	c6 85 c7 f4 ff ff 00 	movb   $0x0,-0xb39(%rbp)
  bool src_found = false;
    297e:	c6 85 c6 f4 ff ff 00 	movb   $0x0,-0xb3a(%rbp)
  __u64 cur_time = 0;
    2985:	48 c7 85 b0 f4 ff ff 	movq   $0x0,-0xb50(%rbp)
    298c:	00 00 00 00 
    2990:	48 8d 85 b0 f4 ff ff 	lea    -0xb50(%rbp),%rax
    2997:	48 89 85 c8 fc ff ff 	mov    %rax,-0x338(%rbp)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    299e:	c7 85 c4 fc ff ff 02 	movl   $0x202,-0x33c(%rbp)
    29a5:	02 00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    29a8:	48 c7 85 b0 fc ff ff 	movq   $0x0,-0x350(%rbp)
    29af:	00 00 00 00 
    29b3:	c7 85 ac fc ff ff 02 	movl   $0x2,-0x354(%rbp)
    29ba:	00 00 00 
    29bd:	8b 85 c4 fc ff ff    	mov    -0x33c(%rbp),%eax
    29c3:	89 85 a8 fc ff ff    	mov    %eax,-0x358(%rbp)
    29c9:	c7 85 a4 fc ff ff 02 	movl   $0x2,-0x35c(%rbp)
    29d0:	00 00 00 
    29d3:	c7 85 a0 fc ff ff 08 	movl   $0x8,-0x360(%rbp)
    29da:	00 00 00 
    29dd:	83 bd a8 fc ff ff 02 	cmpl   $0x2,-0x358(%rbp)
    29e4:	73 21                	jae    2a07 <balancer_ingress+0x2a07>
    29e6:	8b 85 a8 fc ff ff    	mov    -0x358(%rbp),%eax
    29ec:	89 c1                	mov    %eax,%ecx
    29ee:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    29f5:	88 ff ff 
    29f8:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    29ff:	00 
    2a00:	48 89 85 b0 fc ff ff 	mov    %rax,-0x350(%rbp)
    2a07:	48 8b 85 b0 fc ff ff 	mov    -0x350(%rbp),%rax
    2a0e:	48 89 85 98 fc ff ff 	mov    %rax,-0x368(%rbp)
    2a15:	48 8b 85 98 fc ff ff 	mov    -0x368(%rbp),%rax
  struct lb_stats* conn_rate_stats =
    2a1c:	48 89 85 b8 fc ff ff 	mov    %rax,-0x348(%rbp)
  if (!conn_rate_stats) {
    2a23:	48 83 bd b8 fc ff ff 	cmpq   $0x0,-0x348(%rbp)
    2a2a:	00 
    2a2b:	75 0c                	jne    2a39 <balancer_ingress+0x2a39>
    return true;
    2a2d:	c6 85 d7 fc ff ff 01 	movb   $0x1,-0x329(%rbp)
    2a34:	e9 91 00 00 00       	jmp    2aca <balancer_ingress+0x2aca>
  *cur_time = bpf_ktime_get_ns();
    2a39:	48 b8 98 7f 00 00 00 	movabs $0x7f98,%rax
    2a40:	00 00 00 
    2a43:	48 8b 00             	mov    (%rax),%rax
    2a46:	ff d0                	call   *%rax
    2a48:	48 89 c1             	mov    %rax,%rcx
    2a4b:	48 8b 85 c8 fc ff ff 	mov    -0x338(%rbp),%rax
    2a52:	48 89 08             	mov    %rcx,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    2a55:	48 8b 85 c8 fc ff ff 	mov    -0x338(%rbp),%rax
    2a5c:	48 8b 00             	mov    (%rax),%rax
    2a5f:	48 8b 8d b8 fc ff ff 	mov    -0x348(%rbp),%rcx
    2a66:	48 2b 41 08          	sub    0x8(%rcx),%rax
    2a6a:	48 3d 00 ca 9a 3b    	cmp    $0x3b9aca00,%rax
    2a70:	76 25                	jbe    2a97 <balancer_ingress+0x2a97>
    conn_rate_stats->v1 = 1;
    2a72:	48 8b 85 b8 fc ff ff 	mov    -0x348(%rbp),%rax
    2a79:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    conn_rate_stats->v2 = *cur_time;
    2a80:	48 8b 85 c8 fc ff ff 	mov    -0x338(%rbp),%rax
    2a87:	48 8b 08             	mov    (%rax),%rcx
    2a8a:	48 8b 85 b8 fc ff ff 	mov    -0x348(%rbp),%rax
    2a91:	48 89 48 08          	mov    %rcx,0x8(%rax)
  } else {
    2a95:	eb 2c                	jmp    2ac3 <balancer_ingress+0x2ac3>
    conn_rate_stats->v1 += 1;
    2a97:	48 8b 85 b8 fc ff ff 	mov    -0x348(%rbp),%rax
    2a9e:	48 8b 08             	mov    (%rax),%rcx
    2aa1:	48 83 c1 01          	add    $0x1,%rcx
    2aa5:	48 89 08             	mov    %rcx,(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2aa8:	48 8b 85 b8 fc ff ff 	mov    -0x348(%rbp),%rax
    2aaf:	48 81 38 48 e8 01 00 	cmpq   $0x1e848,(%rax)
    2ab6:	76 09                	jbe    2ac1 <balancer_ingress+0x2ac1>
      return true;
    2ab8:	c6 85 d7 fc ff ff 01 	movb   $0x1,-0x329(%rbp)
    2abf:	eb 09                	jmp    2aca <balancer_ingress+0x2aca>
    2ac1:	eb 00                	jmp    2ac3 <balancer_ingress+0x2ac3>
  return false;
    2ac3:	c6 85 d7 fc ff ff 00 	movb   $0x0,-0x329(%rbp)
}
    2aca:	8a 85 d7 fc ff ff    	mov    -0x329(%rbp),%al
  under_flood = is_under_flood(&cur_time);
    2ad0:	24 01                	and    $0x1,%al
    2ad2:	88 85 c7 f4 ff ff    	mov    %al,-0xb39(%rbp)
  if (!src_found) {
    2ad8:	f6 85 c6 f4 ff ff 01 	testb  $0x1,-0xb3a(%rbp)
    2adf:	0f 85 57 02 00 00    	jne    2d3c <balancer_ingress+0x2d3c>
    bool hash_16bytes = is_ipv6;
    2ae5:	8a 85 e7 f4 ff ff    	mov    -0xb19(%rbp),%al
    2aeb:	24 01                	and    $0x1,%al
    2aed:	88 85 a7 f4 ff ff    	mov    %al,-0xb59(%rbp)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    2af3:	48 8b 85 e8 f4 ff ff 	mov    -0xb18(%rbp),%rax
    2afa:	8b 00                	mov    (%rax),%eax
    2afc:	83 e0 08             	and    $0x8,%eax
    2aff:	83 f8 00             	cmp    $0x0,%eax
    2b02:	74 2e                	je     2b32 <balancer_ingress+0x2b32>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    2b04:	48 8b 85 f0 f4 ff ff 	mov    -0xb10(%rbp),%rax
    2b0b:	66 8b 48 22          	mov    0x22(%rax),%cx
    2b0f:	48 8b 85 f0 f4 ff ff 	mov    -0xb10(%rbp),%rax
    2b16:	66 89 48 20          	mov    %cx,0x20(%rax)
      memset(pckt->flow.srcv6, 0, 16);
    2b1a:	48 8b 85 f0 f4 ff ff 	mov    -0xb10(%rbp),%rax
    2b21:	31 c9                	xor    %ecx,%ecx
    2b23:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    2b2a:	00 
    2b2b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    2b32:	48 8b 8d f0 f4 ff ff 	mov    -0xb10(%rbp),%rcx
    2b39:	8a 85 a7 f4 ff ff    	mov    -0xb59(%rbp),%al
    2b3f:	48 89 8d e8 fd ff ff 	mov    %rcx,-0x218(%rbp)
    2b46:	24 01                	and    $0x1,%al
    2b48:	88 85 e7 fd ff ff    	mov    %al,-0x219(%rbp)
  if (hash_16bytes) {
    2b4e:	f6 85 e7 fd ff ff 01 	testb  $0x1,-0x219(%rbp)
    2b55:	74 34                	je     2b8b <balancer_ingress+0x2b8b>
        jhash(pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6),
    2b57:	48 8b bd e8 fd ff ff 	mov    -0x218(%rbp),%rdi
    2b5e:	be 10 00 00 00       	mov    $0x10,%esi
    2b63:	ba 00 02 00 00       	mov    $0x200,%edx
    2b68:	e8 13 4c 00 00       	call   7780 <jhash>
    2b6d:	89 c7                	mov    %eax,%edi
        pckt->flow.ports,
    2b6f:	48 8b 85 e8 fd ff ff 	mov    -0x218(%rbp),%rax
    2b76:	8b 70 20             	mov    0x20(%rax),%esi
    2b79:	ba 00 02 00 02       	mov    $0x2000200,%edx
    return jhash_2words(
    2b7e:	e8 bd 4f 00 00       	call   7b40 <jhash_2words>
    2b83:	89 85 f4 fd ff ff    	mov    %eax,-0x20c(%rbp)
    2b89:	eb 23                	jmp    2bae <balancer_ingress+0x2bae>
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    2b8b:	48 8b 85 e8 fd ff ff 	mov    -0x218(%rbp),%rax
    2b92:	8b 38                	mov    (%rax),%edi
    2b94:	48 8b 85 e8 fd ff ff 	mov    -0x218(%rbp),%rax
    2b9b:	8b 70 20             	mov    0x20(%rax),%esi
    2b9e:	ba 00 02 00 02       	mov    $0x2000200,%edx
    2ba3:	e8 98 4f 00 00       	call   7b40 <jhash_2words>
    2ba8:	89 85 f4 fd ff ff    	mov    %eax,-0x20c(%rbp)
}
    2bae:	8b 85 f4 fd ff ff    	mov    -0x20c(%rbp),%eax
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    2bb4:	b9 01 00 01 00       	mov    $0x10001,%ecx
    2bb9:	31 d2                	xor    %edx,%edx
    2bbb:	f7 f1                	div    %ecx
    2bbd:	89 95 ac f4 ff ff    	mov    %edx,-0xb54(%rbp)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    2bc3:	48 8b 85 e8 f4 ff ff 	mov    -0xb18(%rbp),%rax
    2bca:	69 40 04 01 00 01 00 	imul   $0x10001,0x4(%rax),%eax
    2bd1:	03 85 ac f4 ff ff    	add    -0xb54(%rbp),%eax
    2bd7:	89 85 a8 f4 ff ff    	mov    %eax,-0xb58(%rbp)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    2bdd:	48 c7 85 98 f4 ff ff 	movq   $0x0,-0xb68(%rbp)
    2be4:	00 00 00 00 
    2be8:	c7 85 94 f4 ff ff 02 	movl   $0x2,-0xb6c(%rbp)
    2bef:	00 00 00 
    2bf2:	8b 85 a8 f4 ff ff    	mov    -0xb58(%rbp),%eax
    2bf8:	89 85 90 f4 ff ff    	mov    %eax,-0xb70(%rbp)
    2bfe:	c7 85 8c f4 ff ff 02 	movl   $0x2,-0xb74(%rbp)
    2c05:	00 00 00 
    2c08:	c7 85 88 f4 ff ff 08 	movl   $0x8,-0xb78(%rbp)
    2c0f:	00 00 00 
    2c12:	83 bd 90 f4 ff ff 02 	cmpl   $0x2,-0xb70(%rbp)
    2c19:	73 21                	jae    2c3c <balancer_ingress+0x2c3c>
    2c1b:	8b 85 90 f4 ff ff    	mov    -0xb70(%rbp),%eax
    2c21:	89 c1                	mov    %eax,%ecx
    2c23:	48 b8 00 70 1f e4 00 	movabs $0xffffc900e41f7000,%rax
    2c2a:	c9 ff ff 
    2c2d:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    2c34:	00 
    2c35:	48 89 85 98 f4 ff ff 	mov    %rax,-0xb68(%rbp)
    2c3c:	48 8b 85 98 f4 ff ff 	mov    -0xb68(%rbp),%rax
    2c43:	48 89 85 80 f4 ff ff 	mov    %rax,-0xb80(%rbp)
    2c4a:	48 8b 85 80 f4 ff ff 	mov    -0xb80(%rbp),%rax
    2c51:	48 89 85 b8 f4 ff ff 	mov    %rax,-0xb48(%rbp)
    if (!real_pos) {
    2c58:	48 83 bd b8 f4 ff ff 	cmpq   $0x0,-0xb48(%rbp)
    2c5f:	00 
    2c60:	75 0c                	jne    2c6e <balancer_ingress+0x2c6e>
      return false;
    2c62:	c6 85 07 f5 ff ff 00 	movb   $0x0,-0xaf9(%rbp)
    2c69:	e9 93 02 00 00       	jmp    2f01 <balancer_ingress+0x2f01>
    key = *real_pos;
    2c6e:	48 8b 85 b8 f4 ff ff 	mov    -0xb48(%rbp),%rax
    2c75:	8b 00                	mov    (%rax),%eax
    2c77:	89 85 a8 f4 ff ff    	mov    %eax,-0xb58(%rbp)
    if (key == 0) {
    2c7d:	83 bd a8 f4 ff ff 00 	cmpl   $0x0,-0xb58(%rbp)
    2c84:	0f 85 b0 00 00 00    	jne    2d3a <balancer_ingress+0x2d3a>
  __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
    2c8a:	c7 85 54 fe ff ff 09 	movl   $0x209,-0x1ac(%rbp)
    2c91:	02 00 00 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    2c94:	48 c7 85 40 fe ff ff 	movq   $0x0,-0x1c0(%rbp)
    2c9b:	00 00 00 00 
    2c9f:	c7 85 3c fe ff ff 02 	movl   $0x2,-0x1c4(%rbp)
    2ca6:	00 00 00 
    2ca9:	8b 85 54 fe ff ff    	mov    -0x1ac(%rbp),%eax
    2caf:	89 85 38 fe ff ff    	mov    %eax,-0x1c8(%rbp)
    2cb5:	c7 85 34 fe ff ff 02 	movl   $0x2,-0x1cc(%rbp)
    2cbc:	00 00 00 
    2cbf:	c7 85 30 fe ff ff 08 	movl   $0x8,-0x1d0(%rbp)
    2cc6:	00 00 00 
    2cc9:	83 bd 38 fe ff ff 02 	cmpl   $0x2,-0x1c8(%rbp)
    2cd0:	73 21                	jae    2cf3 <balancer_ingress+0x2cf3>
    2cd2:	8b 85 38 fe ff ff    	mov    -0x1c8(%rbp),%eax
    2cd8:	89 c1                	mov    %eax,%ecx
    2cda:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    2ce1:	88 ff ff 
    2ce4:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    2ceb:	00 
    2cec:	48 89 85 40 fe ff ff 	mov    %rax,-0x1c0(%rbp)
    2cf3:	48 8b 85 40 fe ff ff 	mov    -0x1c0(%rbp),%rax
    2cfa:	48 89 85 28 fe ff ff 	mov    %rax,-0x1d8(%rbp)
    2d01:	48 8b 85 28 fe ff ff 	mov    -0x1d8(%rbp),%rax
  struct lb_stats* ch_drop_stats =
    2d08:	48 89 85 48 fe ff ff 	mov    %rax,-0x1b8(%rbp)
  if (!ch_drop_stats) {
    2d0f:	48 83 bd 48 fe ff ff 	cmpq   $0x0,-0x1b8(%rbp)
    2d16:	00 
    2d17:	75 02                	jne    2d1b <balancer_ingress+0x2d1b>
    return;
    2d19:	eb 13                	jmp    2d2e <balancer_ingress+0x2d2e>
  ch_drop_stats->v2 += 1;
    2d1b:	48 8b 85 48 fe ff ff 	mov    -0x1b8(%rbp),%rax
    2d22:	48 8b 48 08          	mov    0x8(%rax),%rcx
    2d26:	48 83 c1 01          	add    $0x1,%rcx
    2d2a:	48 89 48 08          	mov    %rcx,0x8(%rax)
      return false;
    2d2e:	c6 85 07 f5 ff ff 00 	movb   $0x0,-0xaf9(%rbp)
    2d35:	e9 c7 01 00 00       	jmp    2f01 <balancer_ingress+0x2f01>
  }
    2d3a:	eb 00                	jmp    2d3c <balancer_ingress+0x2d3c>
  pckt->real_index = key;
    2d3c:	8b 8d a8 f4 ff ff    	mov    -0xb58(%rbp),%ecx
    2d42:	48 8b 85 f0 f4 ff ff 	mov    -0xb10(%rbp),%rax
    2d49:	89 48 28             	mov    %ecx,0x28(%rax)
  *real = bpf_map_lookup_elem(&reals, &key);
    2d4c:	48 c7 85 78 f4 ff ff 	movq   $0x0,-0xb88(%rbp)
    2d53:	00 00 00 00 
    2d57:	c7 85 74 f4 ff ff 02 	movl   $0x2,-0xb8c(%rbp)
    2d5e:	00 00 00 
    2d61:	8b 85 a8 f4 ff ff    	mov    -0xb58(%rbp),%eax
    2d67:	89 85 70 f4 ff ff    	mov    %eax,-0xb90(%rbp)
    2d6d:	c7 85 6c f4 ff ff 02 	movl   $0x2,-0xb94(%rbp)
    2d74:	00 00 00 
    2d77:	c7 85 68 f4 ff ff 08 	movl   $0x8,-0xb98(%rbp)
    2d7e:	00 00 00 
    2d81:	83 bd 70 f4 ff ff 02 	cmpl   $0x2,-0xb90(%rbp)
    2d88:	73 21                	jae    2dab <balancer_ingress+0x2dab>
    2d8a:	8b 85 70 f4 ff ff    	mov    -0xb90(%rbp),%eax
    2d90:	89 c1                	mov    %eax,%ecx
    2d92:	48 b8 00 30 50 52 00 	movabs $0xffffc90052503000,%rax
    2d99:	c9 ff ff 
    2d9c:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    2da3:	00 
    2da4:	48 89 85 78 f4 ff ff 	mov    %rax,-0xb88(%rbp)
    2dab:	48 8b 85 78 f4 ff ff 	mov    -0xb88(%rbp),%rax
    2db2:	48 89 85 60 f4 ff ff 	mov    %rax,-0xba0(%rbp)
    2db9:	48 8b 8d 60 f4 ff ff 	mov    -0xba0(%rbp),%rcx
    2dc0:	48 8b 85 f8 f4 ff ff 	mov    -0xb08(%rbp),%rax
    2dc7:	48 89 08             	mov    %rcx,(%rax)
  if (!(*real)) {
    2dca:	48 8b 85 f8 f4 ff ff 	mov    -0xb08(%rbp),%rax
    2dd1:	48 83 38 00          	cmpq   $0x0,(%rax)
    2dd5:	0f 85 ab 00 00 00    	jne    2e86 <balancer_ingress+0x2e86>
  __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
    2ddb:	c7 85 b4 fe ff ff 09 	movl   $0x209,-0x14c(%rbp)
    2de2:	02 00 00 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    2de5:	48 c7 85 a0 fe ff ff 	movq   $0x0,-0x160(%rbp)
    2dec:	00 00 00 00 
    2df0:	c7 85 9c fe ff ff 02 	movl   $0x2,-0x164(%rbp)
    2df7:	00 00 00 
    2dfa:	8b 85 b4 fe ff ff    	mov    -0x14c(%rbp),%eax
    2e00:	89 85 98 fe ff ff    	mov    %eax,-0x168(%rbp)
    2e06:	c7 85 94 fe ff ff 02 	movl   $0x2,-0x16c(%rbp)
    2e0d:	00 00 00 
    2e10:	c7 85 90 fe ff ff 08 	movl   $0x8,-0x170(%rbp)
    2e17:	00 00 00 
    2e1a:	83 bd 98 fe ff ff 02 	cmpl   $0x2,-0x168(%rbp)
    2e21:	73 21                	jae    2e44 <balancer_ingress+0x2e44>
    2e23:	8b 85 98 fe ff ff    	mov    -0x168(%rbp),%eax
    2e29:	89 c1                	mov    %eax,%ecx
    2e2b:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    2e32:	88 ff ff 
    2e35:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    2e3c:	00 
    2e3d:	48 89 85 a0 fe ff ff 	mov    %rax,-0x160(%rbp)
    2e44:	48 8b 85 a0 fe ff ff 	mov    -0x160(%rbp),%rax
    2e4b:	48 89 85 88 fe ff ff 	mov    %rax,-0x178(%rbp)
    2e52:	48 8b 85 88 fe ff ff 	mov    -0x178(%rbp),%rax
  struct lb_stats* ch_drop_stats =
    2e59:	48 89 85 a8 fe ff ff 	mov    %rax,-0x158(%rbp)
  if (!ch_drop_stats) {
    2e60:	48 83 bd a8 fe ff ff 	cmpq   $0x0,-0x158(%rbp)
    2e67:	00 
    2e68:	75 02                	jne    2e6c <balancer_ingress+0x2e6c>
    return;
    2e6a:	eb 11                	jmp    2e7d <balancer_ingress+0x2e7d>
  ch_drop_stats->v1 += 1;
    2e6c:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
    2e73:	48 8b 08             	mov    (%rax),%rcx
    2e76:	48 83 c1 01          	add    $0x1,%rcx
    2e7a:	48 89 08             	mov    %rcx,(%rax)
    return false;
    2e7d:	c6 85 07 f5 ff ff 00 	movb   $0x0,-0xaf9(%rbp)
    2e84:	eb 7b                	jmp    2f01 <balancer_ingress+0x2f01>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    2e86:	48 83 bd d8 f4 ff ff 	cmpq   $0x0,-0xb28(%rbp)
    2e8d:	00 
    2e8e:	74 6a                	je     2efa <balancer_ingress+0x2efa>
    2e90:	48 8b 85 e8 f4 ff ff 	mov    -0xb18(%rbp),%rax
    2e97:	8b 00                	mov    (%rax),%eax
    2e99:	83 e0 02             	and    $0x2,%eax
    2e9c:	83 f8 00             	cmp    $0x0,%eax
    2e9f:	75 59                	jne    2efa <balancer_ingress+0x2efa>
    2ea1:	f6 85 c7 f4 ff ff 01 	testb  $0x1,-0xb39(%rbp)
    2ea8:	75 50                	jne    2efa <balancer_ingress+0x2efa>
    if (pckt->flow.proto == IPPROTO_UDP) {
    2eaa:	48 8b 85 f0 f4 ff ff 	mov    -0xb10(%rbp),%rax
    2eb1:	0f b6 40 24          	movzbl 0x24(%rax),%eax
    2eb5:	83 f8 11             	cmp    $0x11,%eax
    2eb8:	75 0e                	jne    2ec8 <balancer_ingress+0x2ec8>
      new_dst_lru.atime = cur_time;
    2eba:	48 8b 85 b0 f4 ff ff 	mov    -0xb50(%rbp),%rax
    2ec1:	48 89 85 d0 f4 ff ff 	mov    %rax,-0xb30(%rbp)
    new_dst_lru.pos = key;
    2ec8:	8b 85 a8 f4 ff ff    	mov    -0xb58(%rbp),%eax
    2ece:	89 85 c8 f4 ff ff    	mov    %eax,-0xb38(%rbp)
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    2ed4:	48 b8 90 7f 00 00 00 	movabs $0x7f90,%rax
    2edb:	00 00 00 
    2ede:	48 8b 00             	mov    (%rax),%rax
    2ee1:	48 8b bd d8 f4 ff ff 	mov    -0xb28(%rbp),%rdi
    2ee8:	48 8b b5 f0 f4 ff ff 	mov    -0xb10(%rbp),%rsi
    2eef:	48 8d 95 c8 f4 ff ff 	lea    -0xb38(%rbp),%rdx
    2ef6:	31 c9                	xor    %ecx,%ecx
    2ef8:	ff d0                	call   *%rax
  return true;
    2efa:	c6 85 07 f5 ff ff 01 	movb   $0x1,-0xaf9(%rbp)
      if (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6, lru_map)) {
    2f01:	f6 85 07 f5 ff ff 01 	testb  $0x1,-0xaf9(%rbp)
    2f08:	75 0f                	jne    2f19 <balancer_ingress+0x2f19>
        return XDP_DROP;
    2f0a:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    2f11:	00 00 00 
    2f14:	e9 a6 0c 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    2f19:	48 8b 8d 88 ed ff ff 	mov    -0x1278(%rbp),%rcx
    2f20:	8a 85 ff ed ff ff    	mov    -0x1201(%rbp),%al
    2f26:	48 8d 95 90 ed ff ff 	lea    -0x1270(%rbp),%rdx
    2f2d:	48 89 95 20 f6 ff ff 	mov    %rdx,-0x9e0(%rbp)
    2f34:	48 8d 95 a8 ed ff ff 	lea    -0x1258(%rbp),%rdx
    2f3b:	48 89 95 18 f6 ff ff 	mov    %rdx,-0x9e8(%rbp)
    2f42:	48 89 8d 10 f6 ff ff 	mov    %rcx,-0x9f0(%rbp)
    2f49:	24 01                	and    $0x1,%al
    2f4b:	88 85 0f f6 ff ff    	mov    %al,-0x9f1(%rbp)
  __u32 vip_miss_stats_key = 0;
    2f51:	c7 85 08 f6 ff ff 00 	movl   $0x0,-0x9f8(%rbp)
    2f58:	00 00 00 
      bpf_map_lookup_elem(&vip_miss_stats, &vip_miss_stats_key);
    2f5b:	48 c7 85 f8 f5 ff ff 	movq   $0x0,-0xa08(%rbp)
    2f62:	00 00 00 00 
    2f66:	c7 85 f4 f5 ff ff 02 	movl   $0x2,-0xa0c(%rbp)
    2f6d:	00 00 00 
    2f70:	8b 85 08 f6 ff ff    	mov    -0x9f8(%rbp),%eax
    2f76:	89 85 f0 f5 ff ff    	mov    %eax,-0xa10(%rbp)
    2f7c:	c7 85 ec f5 ff ff 02 	movl   $0x2,-0xa14(%rbp)
    2f83:	00 00 00 
    2f86:	c7 85 e8 f5 ff ff 08 	movl   $0x8,-0xa18(%rbp)
    2f8d:	00 00 00 
    2f90:	83 bd f0 f5 ff ff 02 	cmpl   $0x2,-0xa10(%rbp)
    2f97:	73 21                	jae    2fba <balancer_ingress+0x2fba>
    2f99:	8b 85 f0 f5 ff ff    	mov    -0xa10(%rbp),%eax
    2f9f:	89 c1                	mov    %eax,%ecx
    2fa1:	48 b8 00 24 97 51 81 	movabs $0xffff888151972400,%rax
    2fa8:	88 ff ff 
    2fab:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    2fb2:	00 
    2fb3:	48 89 85 f8 f5 ff ff 	mov    %rax,-0xa08(%rbp)
    2fba:	48 8b 85 f8 f5 ff ff 	mov    -0xa08(%rbp),%rax
    2fc1:	48 89 85 e0 f5 ff ff 	mov    %rax,-0xa20(%rbp)
    2fc8:	48 8b 85 e0 f5 ff ff 	mov    -0xa20(%rbp),%rax
  struct vip_definition* lru_miss_stat_vip =
    2fcf:	48 89 85 00 f6 ff ff 	mov    %rax,-0xa00(%rbp)
  if (!lru_miss_stat_vip) {
    2fd6:	48 83 bd 00 f6 ff ff 	cmpq   $0x0,-0xa00(%rbp)
    2fdd:	00 
    2fde:	75 0f                	jne    2fef <balancer_ingress+0x2fef>
    return XDP_DROP;
    2fe0:	c7 85 2c f6 ff ff 01 	movl   $0x1,-0x9d4(%rbp)
    2fe7:	00 00 00 
    2fea:	e9 f3 01 00 00       	jmp    31e2 <balancer_ingress+0x31e2>
  bool address_match = (is_ipv6 &&
    2fef:	f6 85 0f f6 ff ff 01 	testb  $0x1,-0x9f1(%rbp)
    2ff6:	74 5e                	je     3056 <balancer_ingress+0x3056>
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    2ff8:	48 8b 85 00 f6 ff ff 	mov    -0xa00(%rbp),%rax
    2fff:	8b 00                	mov    (%rax),%eax
    3001:	48 8b 8d 20 f6 ff ff 	mov    -0x9e0(%rbp),%rcx
    3008:	3b 01                	cmp    (%rcx),%eax
    300a:	75 4a                	jne    3056 <balancer_ingress+0x3056>
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    300c:	48 8b 85 00 f6 ff ff 	mov    -0xa00(%rbp),%rax
    3013:	8b 40 04             	mov    0x4(%rax),%eax
    3016:	48 8b 8d 20 f6 ff ff 	mov    -0x9e0(%rbp),%rcx
    301d:	3b 41 04             	cmp    0x4(%rcx),%eax
    3020:	75 34                	jne    3056 <balancer_ingress+0x3056>
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    3022:	48 8b 85 00 f6 ff ff 	mov    -0xa00(%rbp),%rax
    3029:	8b 40 08             	mov    0x8(%rax),%eax
    302c:	48 8b 8d 20 f6 ff ff 	mov    -0x9e0(%rbp),%rcx
    3033:	3b 41 08             	cmp    0x8(%rcx),%eax
    3036:	75 1e                	jne    3056 <balancer_ingress+0x3056>
                         lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
    3038:	48 8b 85 00 f6 ff ff 	mov    -0xa00(%rbp),%rax
    303f:	8b 48 0c             	mov    0xc(%rax),%ecx
    3042:	48 8b 95 20 f6 ff ff 	mov    -0x9e0(%rbp),%rdx
    3049:	b0 01                	mov    $0x1,%al
    304b:	3b 4a 0c             	cmp    0xc(%rdx),%ecx
    304e:	88 85 45 e8 ff ff    	mov    %al,-0x17bb(%rbp)
    3054:	74 38                	je     308e <balancer_ingress+0x308e>
      (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
    3056:	31 c0                	xor    %eax,%eax
    3058:	f6 85 0f f6 ff ff 01 	testb  $0x1,-0x9f1(%rbp)
    305f:	88 85 44 e8 ff ff    	mov    %al,-0x17bc(%rbp)
    3065:	75 1b                	jne    3082 <balancer_ingress+0x3082>
    3067:	48 8b 85 00 f6 ff ff 	mov    -0xa00(%rbp),%rax
    306e:	8b 00                	mov    (%rax),%eax
    3070:	48 8b 8d 20 f6 ff ff 	mov    -0x9e0(%rbp),%rcx
    3077:	3b 01                	cmp    (%rcx),%eax
    3079:	0f 94 c0             	sete   %al
    307c:	88 85 44 e8 ff ff    	mov    %al,-0x17bc(%rbp)
    3082:	8a 85 44 e8 ff ff    	mov    -0x17bc(%rbp),%al
    3088:	88 85 45 e8 ff ff    	mov    %al,-0x17bb(%rbp)
    308e:	8a 85 45 e8 ff ff    	mov    -0x17bb(%rbp),%al
  bool address_match = (is_ipv6 &&
    3094:	24 01                	and    $0x1,%al
    3096:	88 85 df f5 ff ff    	mov    %al,-0xa21(%rbp)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    309c:	48 8b 85 00 f6 ff ff 	mov    -0xa00(%rbp),%rax
    30a3:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    30a7:	48 8b 8d 20 f6 ff ff 	mov    -0x9e0(%rbp),%rcx
    30ae:	0f b7 49 10          	movzwl 0x10(%rcx),%ecx
    30b2:	39 c8                	cmp    %ecx,%eax
    30b4:	0f 94 c0             	sete   %al
    30b7:	24 01                	and    $0x1,%al
    30b9:	88 85 de f5 ff ff    	mov    %al,-0xa22(%rbp)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    30bf:	48 8b 85 20 f6 ff ff 	mov    -0x9e0(%rbp),%rax
    30c6:	8a 40 12             	mov    0x12(%rax),%al
    30c9:	48 8b 8d 00 f6 ff ff 	mov    -0xa00(%rbp),%rcx
    30d0:	88 41 12             	mov    %al,0x12(%rcx)
    30d3:	3c 00                	cmp    $0x0,%al
    30d5:	0f 95 c0             	setne  %al
    30d8:	24 01                	and    $0x1,%al
    30da:	88 85 dd f5 ff ff    	mov    %al,-0xa23(%rbp)
  bool vip_match = address_match && port_match && proto_match;
    30e0:	31 c0                	xor    %eax,%eax
    30e2:	f6 85 df f5 ff ff 01 	testb  $0x1,-0xa21(%rbp)
    30e9:	88 85 43 e8 ff ff    	mov    %al,-0x17bd(%rbp)
    30ef:	74 1d                	je     310e <balancer_ingress+0x310e>
    30f1:	31 c0                	xor    %eax,%eax
    30f3:	f6 85 de f5 ff ff 01 	testb  $0x1,-0xa22(%rbp)
    30fa:	88 85 43 e8 ff ff    	mov    %al,-0x17bd(%rbp)
    3100:	74 0c                	je     310e <balancer_ingress+0x310e>
    3102:	8a 85 dd f5 ff ff    	mov    -0xa23(%rbp),%al
    3108:	88 85 43 e8 ff ff    	mov    %al,-0x17bd(%rbp)
    310e:	8a 85 43 e8 ff ff    	mov    -0x17bd(%rbp),%al
    3114:	24 01                	and    $0x1,%al
    3116:	88 85 dc f5 ff ff    	mov    %al,-0xa24(%rbp)
  if (vip_match) {
    311c:	f6 85 dc f5 ff ff 01 	testb  $0x1,-0xa24(%rbp)
    3123:	0f 84 af 00 00 00    	je     31d8 <balancer_ingress+0x31d8>
    __u32 lru_stats_key = pckt->real_index;
    3129:	48 8b 85 18 f6 ff ff 	mov    -0x9e8(%rbp),%rax
    3130:	8b 40 28             	mov    0x28(%rax),%eax
    3133:	89 85 d8 f5 ff ff    	mov    %eax,-0xa28(%rbp)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    3139:	48 c7 85 c8 f5 ff ff 	movq   $0x0,-0xa38(%rbp)
    3140:	00 00 00 00 
    3144:	c7 85 c4 f5 ff ff 02 	movl   $0x2,-0xa3c(%rbp)
    314b:	00 00 00 
    314e:	8b 85 d8 f5 ff ff    	mov    -0xa28(%rbp),%eax
    3154:	89 85 c0 f5 ff ff    	mov    %eax,-0xa40(%rbp)
    315a:	c7 85 bc f5 ff ff 02 	movl   $0x2,-0xa44(%rbp)
    3161:	00 00 00 
    3164:	c7 85 b8 f5 ff ff 08 	movl   $0x8,-0xa48(%rbp)
    316b:	00 00 00 
    316e:	83 bd c0 f5 ff ff 02 	cmpl   $0x2,-0xa40(%rbp)
    3175:	73 21                	jae    3198 <balancer_ingress+0x3198>
    3177:	8b 85 c0 f5 ff ff    	mov    -0xa40(%rbp),%eax
    317d:	89 c1                	mov    %eax,%ecx
    317f:	48 b8 00 c0 11 52 00 	movabs $0xffffc9005211c000,%rax
    3186:	c9 ff ff 
    3189:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    3190:	00 
    3191:	48 89 85 c8 f5 ff ff 	mov    %rax,-0xa38(%rbp)
    3198:	48 8b 85 c8 f5 ff ff 	mov    -0xa38(%rbp),%rax
    319f:	48 89 85 b0 f5 ff ff 	mov    %rax,-0xa50(%rbp)
    31a6:	48 8b 85 b0 f5 ff ff 	mov    -0xa50(%rbp),%rax
    31ad:	48 89 85 d0 f5 ff ff 	mov    %rax,-0xa30(%rbp)
    if (!lru_miss_stat) {
    31b4:	48 83 bd d0 f5 ff ff 	cmpq   $0x0,-0xa30(%rbp)
    31bb:	00 
    31bc:	75 0c                	jne    31ca <balancer_ingress+0x31ca>
      return XDP_DROP;
    31be:	c7 85 2c f6 ff ff 01 	movl   $0x1,-0x9d4(%rbp)
    31c5:	00 00 00 
    31c8:	eb 18                	jmp    31e2 <balancer_ingress+0x31e2>
    *lru_miss_stat += 1;
    31ca:	48 8b 85 d0 f5 ff ff 	mov    -0xa30(%rbp),%rax
    31d1:	8b 08                	mov    (%rax),%ecx
    31d3:	83 c1 01             	add    $0x1,%ecx
    31d6:	89 08                	mov    %ecx,(%rax)
  return FURTHER_PROCESSING;
    31d8:	c7 85 2c f6 ff ff ff 	movl   $0xffffffff,-0x9d4(%rbp)
    31df:	ff ff ff 
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    31e2:	83 bd 2c f6 ff ff 00 	cmpl   $0x0,-0x9d4(%rbp)
    31e9:	7c 0f                	jl     31fa <balancer_ingress+0x31fa>
        return XDP_DROP;
    31eb:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    31f2:	00 00 00 
    31f5:	e9 c5 09 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
      data_stats->v2 += 1;
    31fa:	48 8b 85 80 ed ff ff 	mov    -0x1280(%rbp),%rax
    3201:	48 8b 48 08          	mov    0x8(%rax),%rcx
    3205:	48 83 c1 01          	add    $0x1,%rcx
    3209:	48 89 48 08          	mov    %rcx,0x8(%rax)
  }
    320d:	eb 00                	jmp    320f <balancer_ingress+0x320f>
  cval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos);
    320f:	48 c7 85 a8 eb ff ff 	movq   $0x0,-0x1458(%rbp)
    3216:	00 00 00 00 
    321a:	c7 85 a4 eb ff ff 02 	movl   $0x2,-0x145c(%rbp)
    3221:	00 00 00 
    3224:	8b 85 70 ed ff ff    	mov    -0x1290(%rbp),%eax
    322a:	89 85 a0 eb ff ff    	mov    %eax,-0x1460(%rbp)
    3230:	c7 85 9c eb ff ff 02 	movl   $0x2,-0x1464(%rbp)
    3237:	00 00 00 
    323a:	c7 85 98 eb ff ff 08 	movl   $0x8,-0x1468(%rbp)
    3241:	00 00 00 
    3244:	83 bd a0 eb ff ff 02 	cmpl   $0x2,-0x1460(%rbp)
    324b:	73 21                	jae    326e <balancer_ingress+0x326e>
    324d:	8b 85 a0 eb ff ff    	mov    -0x1460(%rbp),%eax
    3253:	89 c1                	mov    %eax,%ecx
    3255:	48 b8 00 20 97 51 81 	movabs $0xffff888151972000,%rax
    325c:	88 ff ff 
    325f:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    3266:	00 
    3267:	48 89 85 a8 eb ff ff 	mov    %rax,-0x1458(%rbp)
    326e:	48 8b 85 a8 eb ff ff 	mov    -0x1458(%rbp),%rax
    3275:	48 89 85 90 eb ff ff 	mov    %rax,-0x1470(%rbp)
    327c:	48 8b 85 90 eb ff ff 	mov    -0x1470(%rbp),%rax
    3283:	48 89 85 e0 ed ff ff 	mov    %rax,-0x1220(%rbp)
  if (!cval) {
    328a:	48 83 bd e0 ed ff ff 	cmpq   $0x0,-0x1220(%rbp)
    3291:	00 
    3292:	75 0f                	jne    32a3 <balancer_ingress+0x32a3>
    return XDP_DROP;
    3294:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    329b:	00 00 00 
    329e:	e9 1c 09 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    32a3:	48 c7 85 88 eb ff ff 	movq   $0x0,-0x1478(%rbp)
    32aa:	00 00 00 00 
    32ae:	c7 85 84 eb ff ff 02 	movl   $0x2,-0x147c(%rbp)
    32b5:	00 00 00 
    32b8:	8b 85 74 ed ff ff    	mov    -0x128c(%rbp),%eax
    32be:	89 85 80 eb ff ff    	mov    %eax,-0x1480(%rbp)
    32c4:	c7 85 7c eb ff ff 02 	movl   $0x2,-0x1484(%rbp)
    32cb:	00 00 00 
    32ce:	c7 85 78 eb ff ff 08 	movl   $0x8,-0x1488(%rbp)
    32d5:	00 00 00 
    32d8:	83 bd 80 eb ff ff 02 	cmpl   $0x2,-0x1480(%rbp)
    32df:	73 21                	jae    3302 <balancer_ingress+0x3302>
    32e1:	8b 85 80 eb ff ff    	mov    -0x1480(%rbp),%eax
    32e7:	89 c1                	mov    %eax,%ecx
    32e9:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    32f0:	88 ff ff 
    32f3:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    32fa:	00 
    32fb:	48 89 85 88 eb ff ff 	mov    %rax,-0x1478(%rbp)
    3302:	48 8b 85 88 eb ff ff 	mov    -0x1478(%rbp),%rax
    3309:	48 89 85 70 eb ff ff 	mov    %rax,-0x1490(%rbp)
    3310:	48 8b 85 70 eb ff ff 	mov    -0x1490(%rbp),%rax
    3317:	48 89 85 80 ed ff ff 	mov    %rax,-0x1280(%rbp)
  if (!data_stats) {
    331e:	48 83 bd 80 ed ff ff 	cmpq   $0x0,-0x1280(%rbp)
    3325:	00 
    3326:	75 0f                	jne    3337 <balancer_ingress+0x3337>
    return XDP_DROP;
    3328:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    332f:	00 00 00 
    3332:	e9 88 08 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  data_stats->v1 += 1;
    3337:	48 8b 85 80 ed ff ff 	mov    -0x1280(%rbp),%rax
    333e:	48 8b 08             	mov    (%rax),%rcx
    3341:	48 83 c1 01          	add    $0x1,%rcx
    3345:	48 89 08             	mov    %rcx,(%rax)
  data_stats->v2 += pkt_bytes;
    3348:	0f b7 85 6e ed ff ff 	movzwl -0x1292(%rbp),%eax
    334f:	89 c1                	mov    %eax,%ecx
    3351:	48 8b 85 80 ed ff ff 	mov    -0x1280(%rbp),%rax
    3358:	48 03 48 08          	add    0x8(%rax),%rcx
    335c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    3360:	48 c7 85 68 eb ff ff 	movq   $0x0,-0x1498(%rbp)
    3367:	00 00 00 00 
    336b:	c7 85 64 eb ff ff 02 	movl   $0x2,-0x149c(%rbp)
    3372:	00 00 00 
    3375:	8b 85 d0 ed ff ff    	mov    -0x1230(%rbp),%eax
    337b:	89 85 60 eb ff ff    	mov    %eax,-0x14a0(%rbp)
    3381:	c7 85 5c eb ff ff 02 	movl   $0x2,-0x14a4(%rbp)
    3388:	00 00 00 
    338b:	c7 85 58 eb ff ff 08 	movl   $0x8,-0x14a8(%rbp)
    3392:	00 00 00 
    3395:	83 bd 60 eb ff ff 02 	cmpl   $0x2,-0x14a0(%rbp)
    339c:	73 21                	jae    33bf <balancer_ingress+0x33bf>
    339e:	8b 85 60 eb ff ff    	mov    -0x14a0(%rbp),%eax
    33a4:	89 c1                	mov    %eax,%ecx
    33a6:	48 b8 00 a0 0d 52 00 	movabs $0xffffc900520da000,%rax
    33ad:	c9 ff ff 
    33b0:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    33b7:	00 
    33b8:	48 89 85 68 eb ff ff 	mov    %rax,-0x1498(%rbp)
    33bf:	48 8b 85 68 eb ff ff 	mov    -0x1498(%rbp),%rax
    33c6:	48 89 85 50 eb ff ff 	mov    %rax,-0x14b0(%rbp)
    33cd:	48 8b 85 50 eb ff ff 	mov    -0x14b0(%rbp),%rax
    33d4:	48 89 85 80 ed ff ff 	mov    %rax,-0x1280(%rbp)
  if (!data_stats) {
    33db:	48 83 bd 80 ed ff ff 	cmpq   $0x0,-0x1280(%rbp)
    33e2:	00 
    33e3:	75 0f                	jne    33f4 <balancer_ingress+0x33f4>
    return XDP_DROP;
    33e5:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    33ec:	00 00 00 
    33ef:	e9 cb 07 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  data_stats->v1 += 1;
    33f4:	48 8b 85 80 ed ff ff 	mov    -0x1280(%rbp),%rax
    33fb:	48 8b 08             	mov    (%rax),%rcx
    33fe:	48 83 c1 01          	add    $0x1,%rcx
    3402:	48 89 08             	mov    %rcx,(%rax)
  data_stats->v2 += pkt_bytes;
    3405:	0f b7 85 6e ed ff ff 	movzwl -0x1292(%rbp),%eax
    340c:	89 c1                	mov    %eax,%ecx
    340e:	48 8b 85 80 ed ff ff 	mov    -0x1280(%rbp),%rax
    3415:	48 03 48 08          	add    0x8(%rax),%rcx
    3419:	48 89 48 08          	mov    %rcx,0x8(%rax)
  pckt.flow.port16[0] = original_sport;
    341d:	66 8b 85 7c ed ff ff 	mov    -0x1284(%rbp),%ax
    3424:	66 89 85 c8 ed ff ff 	mov    %ax,-0x1238(%rbp)
  if (dst->flags & F_IPV6) {
    342b:	48 8b 85 d8 ed ff ff 	mov    -0x1228(%rbp),%rax
    3432:	0f b6 40 10          	movzbl 0x10(%rax),%eax
    3436:	83 e0 01             	and    $0x1,%eax
    3439:	83 f8 00             	cmp    $0x0,%eax
    343c:	0f 84 e4 03 00 00    	je     3826 <balancer_ingress+0x3826>
    if (!PCKT_ENCAP_V6(xdp, cval, is_ipv6, &pckt, dst, pkt_bytes)) {
    3442:	48 8b bd 08 ee ff ff 	mov    -0x11f8(%rbp),%rdi
    3449:	48 8b b5 e0 ed ff ff 	mov    -0x1220(%rbp),%rsi
    3450:	8a 95 ff ed ff ff    	mov    -0x1201(%rbp),%dl
    3456:	48 8b 8d d8 ed ff ff 	mov    -0x1228(%rbp),%rcx
    345d:	0f b7 85 6e ed ff ff 	movzwl -0x1292(%rbp),%eax
    3464:	48 89 bd 20 f7 ff ff 	mov    %rdi,-0x8e0(%rbp)
    346b:	48 89 b5 18 f7 ff ff 	mov    %rsi,-0x8e8(%rbp)
    3472:	80 e2 01             	and    $0x1,%dl
    3475:	88 95 17 f7 ff ff    	mov    %dl,-0x8e9(%rbp)
    347b:	48 8d 95 a8 ed ff ff 	lea    -0x1258(%rbp),%rdx
    3482:	48 89 95 08 f7 ff ff 	mov    %rdx,-0x8f8(%rbp)
    3489:	48 89 8d 00 f7 ff ff 	mov    %rcx,-0x900(%rbp)
    3490:	89 85 fc f6 ff ff    	mov    %eax,-0x904(%rbp)
  struct ethhdr* old_eth;
  __u16 payload_len;
  __u32 saddr[4];
  __u8 proto;
  // ip(6)ip6 encap
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    3496:	48 b8 a0 7f 00 00 00 	movabs $0x7fa0,%rax
    349d:	00 00 00 
    34a0:	48 8b 00             	mov    (%rax),%rax
    34a3:	48 8b bd 20 f7 ff ff 	mov    -0x8e0(%rbp),%rdi
    34aa:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    34af:	ff d0                	call   *%rax
    34b1:	83 f8 00             	cmp    $0x0,%eax
    34b4:	74 0c                	je     34c2 <balancer_ingress+0x34c2>
    return false;
    34b6:	c6 85 2e f7 ff ff 00 	movb   $0x0,-0x8d2(%rbp)
    34bd:	e9 47 03 00 00       	jmp    3809 <balancer_ingress+0x3809>
  }
  data = (void*)(long)xdp->data;
    34c2:	48 8b 85 20 f7 ff ff 	mov    -0x8e0(%rbp),%rax
    34c9:	48 8b 00             	mov    (%rax),%rax
    34cc:	48 89 85 f0 f6 ff ff 	mov    %rax,-0x910(%rbp)
  data_end = (void*)(long)xdp->data_end;
    34d3:	48 8b 85 20 f7 ff ff 	mov    -0x8e0(%rbp),%rax
    34da:	48 8b 40 08          	mov    0x8(%rax),%rax
    34de:	48 89 85 e8 f6 ff ff 	mov    %rax,-0x918(%rbp)
  new_eth = data;
    34e5:	48 8b 85 f0 f6 ff ff 	mov    -0x910(%rbp),%rax
    34ec:	48 89 85 d8 f6 ff ff 	mov    %rax,-0x928(%rbp)
  ip6h = data + sizeof(struct ethhdr);
    34f3:	48 8b 85 f0 f6 ff ff 	mov    -0x910(%rbp),%rax
    34fa:	48 83 c0 0e          	add    $0xe,%rax
    34fe:	48 89 85 e0 f6 ff ff 	mov    %rax,-0x920(%rbp)
  old_eth = data + sizeof(struct ipv6hdr);
    3505:	48 8b 85 f0 f6 ff ff 	mov    -0x910(%rbp),%rax
    350c:	48 83 c0 28          	add    $0x28,%rax
    3510:	48 89 85 d0 f6 ff ff 	mov    %rax,-0x930(%rbp)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    3517:	48 8b 85 d8 f6 ff ff 	mov    -0x928(%rbp),%rax
    351e:	48 83 c0 0e          	add    $0xe,%rax
    3522:	48 8b 8d e8 f6 ff ff 	mov    -0x918(%rbp),%rcx
    3529:	48 39 c8             	cmp    %rcx,%rax
    352c:	77 2e                	ja     355c <balancer_ingress+0x355c>
    352e:	48 8b 85 d0 f6 ff ff 	mov    -0x930(%rbp),%rax
    3535:	48 83 c0 0e          	add    $0xe,%rax
    3539:	48 8b 8d e8 f6 ff ff 	mov    -0x918(%rbp),%rcx
    3540:	48 39 c8             	cmp    %rcx,%rax
    3543:	77 17                	ja     355c <balancer_ingress+0x355c>
    3545:	48 8b 85 e0 f6 ff ff 	mov    -0x920(%rbp),%rax
    354c:	48 83 c0 28          	add    $0x28,%rax
    3550:	48 8b 8d e8 f6 ff ff 	mov    -0x918(%rbp),%rcx
    3557:	48 39 c8             	cmp    %rcx,%rax
    355a:	76 0c                	jbe    3568 <balancer_ingress+0x3568>
    return false;
    355c:	c6 85 2e f7 ff ff 00 	movb   $0x0,-0x8d2(%rbp)
    3563:	e9 a1 02 00 00       	jmp    3809 <balancer_ingress+0x3809>
  }
  memcpy(new_eth->h_dest, cval->mac, 6);
    3568:	48 8b 85 d8 f6 ff ff 	mov    -0x928(%rbp),%rax
    356f:	48 8b 8d 18 f7 ff ff 	mov    -0x8e8(%rbp),%rcx
    3576:	8b 11                	mov    (%rcx),%edx
    3578:	89 10                	mov    %edx,(%rax)
    357a:	66 8b 49 04          	mov    0x4(%rcx),%cx
    357e:	66 89 48 04          	mov    %cx,0x4(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    3582:	48 8b 85 d8 f6 ff ff 	mov    -0x928(%rbp),%rax
    3589:	48 8b 8d d0 f6 ff ff 	mov    -0x930(%rbp),%rcx
    3590:	8b 11                	mov    (%rcx),%edx
    3592:	89 50 06             	mov    %edx,0x6(%rax)
    3595:	66 8b 49 04          	mov    0x4(%rcx),%cx
    3599:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    359d:	48 8b 85 d8 f6 ff ff 	mov    -0x928(%rbp),%rax
    35a4:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)

  if (is_ipv6) {
    35aa:	f6 85 17 f7 ff ff 01 	testb  $0x1,-0x8e9(%rbp)
    35b1:	0f 84 8f 00 00 00    	je     3646 <balancer_ingress+0x3646>
    proto = IPPROTO_IPV6;
    35b7:	c6 85 af f6 ff ff 29 	movb   $0x29,-0x951(%rbp)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
    35be:	48 8b 85 08 f7 ff ff 	mov    -0x8f8(%rbp),%rax
    35c5:	66 8b 50 20          	mov    0x20(%rax),%dx
    35c9:	48 8b 85 08 f7 ff ff 	mov    -0x8f8(%rbp),%rax
    35d0:	8b 48 0c             	mov    0xc(%rax),%ecx
    35d3:	48 8d 85 b0 f6 ff ff 	lea    -0x950(%rbp),%rax
    35da:	66 89 95 e6 fe ff ff 	mov    %dx,-0x11a(%rbp)
    35e1:	89 8d e0 fe ff ff    	mov    %ecx,-0x120(%rbp)
    35e7:	48 89 85 d8 fe ff ff 	mov    %rax,-0x128(%rbp)
#include "katran/lib/bpf/balancer_consts.h"
#include "katran/lib/bpf/csum_helpers.h"

__attribute__((__always_inline__)) static inline void
create_encap_ipv6_src(__u16 port, __be32 src, __u32* saddr) {
  saddr[0] = IPIP_V6_PREFIX1;
    35ee:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
    35f5:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
  saddr[1] = IPIP_V6_PREFIX2;
    35fb:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
    3602:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  saddr[2] = IPIP_V6_PREFIX3;
    3609:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
    3610:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  saddr[3] = src ^ port;
    3617:	8b 8d e0 fe ff ff    	mov    -0x120(%rbp),%ecx
    361d:	0f b7 85 e6 fe ff ff 	movzwl -0x11a(%rbp),%eax
    3624:	31 c1                	xor    %eax,%ecx
    3626:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
    362d:	89 48 0c             	mov    %ecx,0xc(%rax)
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    3630:	8b 85 fc f6 ff ff    	mov    -0x904(%rbp),%eax
    3636:	48 83 c0 28          	add    $0x28,%rax
    363a:	66 89 85 ce f6 ff ff 	mov    %ax,-0x932(%rbp)
  } else {
    3641:	e9 85 00 00 00       	jmp    36cb <balancer_ingress+0x36cb>
    proto = IPPROTO_IPIP;
    3646:	c6 85 af f6 ff ff 04 	movb   $0x4,-0x951(%rbp)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
    364d:	48 8b 85 08 f7 ff ff 	mov    -0x8f8(%rbp),%rax
    3654:	66 8b 50 20          	mov    0x20(%rax),%dx
    3658:	48 8b 85 08 f7 ff ff 	mov    -0x8f8(%rbp),%rax
    365f:	8b 08                	mov    (%rax),%ecx
    3661:	48 8d 85 b0 f6 ff ff 	lea    -0x950(%rbp),%rax
    3668:	66 89 95 fa fe ff ff 	mov    %dx,-0x106(%rbp)
    366f:	89 8d f4 fe ff ff    	mov    %ecx,-0x10c(%rbp)
    3675:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
  saddr[0] = IPIP_V6_PREFIX1;
    367c:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
    3683:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
  saddr[1] = IPIP_V6_PREFIX2;
    3689:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
    3690:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  saddr[2] = IPIP_V6_PREFIX3;
    3697:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
    369e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  saddr[3] = src ^ port;
    36a5:	8b 8d f4 fe ff ff    	mov    -0x10c(%rbp),%ecx
    36ab:	0f b7 85 fa fe ff ff 	movzwl -0x106(%rbp),%eax
    36b2:	31 c1                	xor    %eax,%ecx
    36b4:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
    36bb:	89 48 0c             	mov    %ecx,0xc(%rax)
    payload_len = pkt_bytes;
    36be:	8b 85 fc f6 ff ff    	mov    -0x904(%rbp),%eax
    36c4:	66 89 85 ce f6 ff ff 	mov    %ax,-0x932(%rbp)
  }

  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    36cb:	4c 8b 85 e0 f6 ff ff 	mov    -0x920(%rbp),%r8
    36d2:	48 8b 85 08 f7 ff ff 	mov    -0x8f8(%rbp),%rax
    36d9:	40 8a 78 2d          	mov    0x2d(%rax),%dil
    36dd:	48 8d b5 b0 f6 ff ff 	lea    -0x950(%rbp),%rsi
    36e4:	48 8b 95 00 f7 ff ff 	mov    -0x900(%rbp),%rdx
    36eb:	66 8b 8d ce f6 ff ff 	mov    -0x932(%rbp),%cx
    36f2:	8a 85 af f6 ff ff    	mov    -0x951(%rbp),%al
    36f8:	4c 89 85 40 ff ff ff 	mov    %r8,-0xc0(%rbp)
    36ff:	40 88 bd 3f ff ff ff 	mov    %dil,-0xc1(%rbp)
    3706:	48 89 b5 30 ff ff ff 	mov    %rsi,-0xd0(%rbp)
    370d:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
    3714:	66 89 8d 26 ff ff ff 	mov    %cx,-0xda(%rbp)
    371b:	88 85 25 ff ff ff    	mov    %al,-0xdb(%rbp)
    __u8 tc,
    __u32* saddr,
    __u32* daddr,
    __u16 payload_len,
    __u8 proto) {
  ip6h->version = 6;
    3721:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    3728:	8a 08                	mov    (%rax),%cl
    372a:	80 e1 0f             	and    $0xf,%cl
    372d:	80 c9 60             	or     $0x60,%cl
    3730:	88 08                	mov    %cl,(%rax)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    3732:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    3739:	48 83 c0 01          	add    $0x1,%rax
    373d:	31 c9                	xor    %ecx,%ecx
    373f:	c6 40 02 00          	movb   $0x0,0x2(%rax)
    3743:	66 c7 00 00 00       	movw   $0x0,(%rax)
#ifdef COPY_INNER_PACKET_TOS
  ip6h->priority = (tc & 0xF0) >> 4;
    3748:	0f b6 85 3f ff ff ff 	movzbl -0xc1(%rbp),%eax
    374f:	25 f0 00 00 00       	and    $0xf0,%eax
    3754:	c1 f8 04             	sar    $0x4,%eax
    3757:	88 c2                	mov    %al,%dl
    3759:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    3760:	8a 08                	mov    (%rax),%cl
    3762:	80 e2 0f             	and    $0xf,%dl
    3765:	80 e1 f0             	and    $0xf0,%cl
    3768:	08 d1                	or     %dl,%cl
    376a:	88 08                	mov    %cl,(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    376c:	0f b6 85 3f ff ff ff 	movzbl -0xc1(%rbp),%eax
    3773:	83 e0 0f             	and    $0xf,%eax
    3776:	c1 e0 04             	shl    $0x4,%eax
    3779:	88 c1                	mov    %al,%cl
    377b:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    3782:	88 48 01             	mov    %cl,0x1(%rax)
#else
  ip6h->priority = DEFAULT_TOS;
#endif
  ip6h->nexthdr = proto;
    3785:	8a 8d 25 ff ff ff    	mov    -0xdb(%rbp),%cl
    378b:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    3792:	88 48 06             	mov    %cl,0x6(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    3795:	66 8b 85 26 ff ff ff 	mov    -0xda(%rbp),%ax
    379c:	66 c1 c0 08          	rol    $0x8,%ax
    37a0:	0f b7 c0             	movzwl %ax,%eax
    37a3:	89 85 3c e8 ff ff    	mov    %eax,-0x17c4(%rbp)
    37a9:	8b 85 3c e8 ff ff    	mov    -0x17c4(%rbp),%eax
    37af:	66 89 c1             	mov    %ax,%cx
    37b2:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    37b9:	66 89 48 04          	mov    %cx,0x4(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
    37bd:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    37c4:	c6 40 07 40          	movb   $0x40,0x7(%rax)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    37c8:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    37cf:	48 8b 8d 30 ff ff ff 	mov    -0xd0(%rbp),%rcx
    37d6:	48 8b 11             	mov    (%rcx),%rdx
    37d9:	48 89 50 08          	mov    %rdx,0x8(%rax)
    37dd:	48 8b 49 08          	mov    0x8(%rcx),%rcx
    37e1:	48 89 48 10          	mov    %rcx,0x10(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    37e5:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
    37ec:	48 8b 8d 28 ff ff ff 	mov    -0xd8(%rbp),%rcx
    37f3:	48 8b 11             	mov    (%rcx),%rdx
    37f6:	48 89 50 18          	mov    %rdx,0x18(%rax)
    37fa:	48 8b 49 08          	mov    0x8(%rcx),%rcx
    37fe:	48 89 48 20          	mov    %rcx,0x20(%rax)

  return true;
    3802:	c6 85 2e f7 ff ff 01 	movb   $0x1,-0x8d2(%rbp)
    3809:	f6 85 2e f7 ff ff 01 	testb  $0x1,-0x8d2(%rbp)
    3810:	75 0f                	jne    3821 <balancer_ingress+0x3821>
      return XDP_DROP;
    3812:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    3819:	00 00 00 
    381c:	e9 9e 03 00 00       	jmp    3bbf <balancer_ingress+0x3bbf>
  } else {
    3821:	e9 8f 03 00 00       	jmp    3bb5 <balancer_ingress+0x3bb5>
    if (!PCKT_ENCAP_V4(xdp, cval, &pckt, dst, pkt_bytes)) {
    3826:	48 8b b5 08 ee ff ff 	mov    -0x11f8(%rbp),%rsi
    382d:	48 8b 95 e0 ed ff ff 	mov    -0x1220(%rbp),%rdx
    3834:	48 8b 8d d8 ed ff ff 	mov    -0x1228(%rbp),%rcx
    383b:	0f b7 85 6e ed ff ff 	movzwl -0x1292(%rbp),%eax
    3842:	48 89 b5 00 f8 ff ff 	mov    %rsi,-0x800(%rbp)
    3849:	48 89 95 f8 f7 ff ff 	mov    %rdx,-0x808(%rbp)
    3850:	48 8d 95 a8 ed ff ff 	lea    -0x1258(%rbp),%rdx
    3857:	48 89 95 f0 f7 ff ff 	mov    %rdx,-0x810(%rbp)
    385e:	48 89 8d e8 f7 ff ff 	mov    %rcx,-0x818(%rbp)
    3865:	89 85 e4 f7 ff ff    	mov    %eax,-0x81c(%rbp)
  void* data;
  void* data_end;
  struct iphdr* iph;
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    386b:	48 8b 85 f0 f7 ff ff 	mov    -0x810(%rbp),%rax
    3872:	66 8b 48 20          	mov    0x20(%rax),%cx
    3876:	48 8b 85 f0 f7 ff ff 	mov    -0x810(%rbp),%rax
    387d:	8b 00                	mov    (%rax),%eax
    387f:	66 89 8d 5e ff ff ff 	mov    %cx,-0xa2(%rbp)
    3886:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%rbp)
  __u32 ip_suffix = bpf_htons(port);
    388c:	66 8b 85 5e ff ff ff 	mov    -0xa2(%rbp),%ax
    3893:	66 c1 c0 08          	rol    $0x8,%ax
    3897:	0f b7 c0             	movzwl %ax,%eax
    389a:	89 85 38 e8 ff ff    	mov    %eax,-0x17c8(%rbp)
    38a0:	8b 85 38 e8 ff ff    	mov    -0x17c8(%rbp),%eax
    38a6:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  ip_suffix <<= 16;
    38ac:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
    38b2:	c1 e0 10             	shl    $0x10,%eax
    38b5:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  ip_suffix ^= src;
    38bb:	8b 8d 58 ff ff ff    	mov    -0xa8(%rbp),%ecx
    38c1:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
    38c7:	31 c8                	xor    %ecx,%eax
    38c9:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  return ((0xFFFF0000 & ip_suffix) | IPIP_V4_PREFIX);
    38cf:	0f b7 85 56 ff ff ff 	movzwl -0xaa(%rbp),%eax
    38d6:	c1 e0 10             	shl    $0x10,%eax
    38d9:	0d ac 10 00 00       	or     $0x10ac,%eax
    38de:	89 85 b4 f7 ff ff    	mov    %eax,-0x84c(%rbp)
  __u64 csum = 0;
    38e4:	48 c7 85 a8 f7 ff ff 	movq   $0x0,-0x858(%rbp)
    38eb:	00 00 00 00 
  // ipip encap
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    38ef:	48 b8 a0 7f 00 00 00 	movabs $0x7fa0,%rax
    38f6:	00 00 00 
    38f9:	48 8b 00             	mov    (%rax),%rax
    38fc:	48 8b bd 00 f8 ff ff 	mov    -0x800(%rbp),%rdi
    3903:	be ec ff ff ff       	mov    $0xffffffec,%esi
    3908:	ff d0                	call   *%rax
    390a:	83 f8 00             	cmp    $0x0,%eax
    390d:	74 0c                	je     391b <balancer_ingress+0x391b>
    return false;
    390f:	c6 85 0f f8 ff ff 00 	movb   $0x0,-0x7f1(%rbp)
    3916:	e9 83 02 00 00       	jmp    3b9e <balancer_ingress+0x3b9e>
  }
  data = (void*)(long)xdp->data;
    391b:	48 8b 85 00 f8 ff ff 	mov    -0x800(%rbp),%rax
    3922:	48 8b 00             	mov    (%rax),%rax
    3925:	48 89 85 d8 f7 ff ff 	mov    %rax,-0x828(%rbp)
  data_end = (void*)(long)xdp->data_end;
    392c:	48 8b 85 00 f8 ff ff 	mov    -0x800(%rbp),%rax
    3933:	48 8b 40 08          	mov    0x8(%rax),%rax
    3937:	48 89 85 d0 f7 ff ff 	mov    %rax,-0x830(%rbp)
  new_eth = data;
    393e:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
    3945:	48 89 85 c0 f7 ff ff 	mov    %rax,-0x840(%rbp)
  iph = data + sizeof(struct ethhdr);
    394c:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
    3953:	48 83 c0 0e          	add    $0xe,%rax
    3957:	48 89 85 c8 f7 ff ff 	mov    %rax,-0x838(%rbp)
  old_eth = data + sizeof(struct iphdr);
    395e:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
    3965:	48 83 c0 14          	add    $0x14,%rax
    3969:	48 89 85 b8 f7 ff ff 	mov    %rax,-0x848(%rbp)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    3970:	48 8b 85 c0 f7 ff ff 	mov    -0x840(%rbp),%rax
    3977:	48 83 c0 0e          	add    $0xe,%rax
    397b:	48 8b 8d d0 f7 ff ff 	mov    -0x830(%rbp),%rcx
    3982:	48 39 c8             	cmp    %rcx,%rax
    3985:	77 2e                	ja     39b5 <balancer_ingress+0x39b5>
    3987:	48 8b 85 b8 f7 ff ff 	mov    -0x848(%rbp),%rax
    398e:	48 83 c0 0e          	add    $0xe,%rax
    3992:	48 8b 8d d0 f7 ff ff 	mov    -0x830(%rbp),%rcx
    3999:	48 39 c8             	cmp    %rcx,%rax
    399c:	77 17                	ja     39b5 <balancer_ingress+0x39b5>
    399e:	48 8b 85 c8 f7 ff ff 	mov    -0x838(%rbp),%rax
    39a5:	48 83 c0 14          	add    $0x14,%rax
    39a9:	48 8b 8d d0 f7 ff ff 	mov    -0x830(%rbp),%rcx
    39b0:	48 39 c8             	cmp    %rcx,%rax
    39b3:	76 0c                	jbe    39c1 <balancer_ingress+0x39c1>
    return false;
    39b5:	c6 85 0f f8 ff ff 00 	movb   $0x0,-0x7f1(%rbp)
    39bc:	e9 dd 01 00 00       	jmp    3b9e <balancer_ingress+0x3b9e>
  }
  memcpy(new_eth->h_dest, cval->mac, 6);
    39c1:	48 8b 85 c0 f7 ff ff 	mov    -0x840(%rbp),%rax
    39c8:	48 8b 8d f8 f7 ff ff 	mov    -0x808(%rbp),%rcx
    39cf:	8b 11                	mov    (%rcx),%edx
    39d1:	89 10                	mov    %edx,(%rax)
    39d3:	66 8b 49 04          	mov    0x4(%rcx),%cx
    39d7:	66 89 48 04          	mov    %cx,0x4(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    39db:	48 8b 85 c0 f7 ff ff 	mov    -0x840(%rbp),%rax
    39e2:	48 8b 8d b8 f7 ff ff 	mov    -0x848(%rbp),%rcx
    39e9:	8b 11                	mov    (%rcx),%edx
    39eb:	89 50 06             	mov    %edx,0x6(%rax)
    39ee:	66 8b 49 04          	mov    0x4(%rcx),%cx
    39f2:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    39f6:	48 8b 85 c0 f7 ff ff 	mov    -0x840(%rbp),%rax
    39fd:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)

  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    3a03:	48 8b bd c8 f7 ff ff 	mov    -0x838(%rbp),%rdi
    3a0a:	48 8b 85 f0 f7 ff ff 	mov    -0x810(%rbp),%rax
    3a11:	40 8a 70 2d          	mov    0x2d(%rax),%sil
    3a15:	8b 95 b4 f7 ff ff    	mov    -0x84c(%rbp),%edx
    3a1b:	48 8b 85 e8 f7 ff ff 	mov    -0x818(%rbp),%rax
    3a22:	8b 08                	mov    (%rax),%ecx
    3a24:	8b 85 e4 f7 ff ff    	mov    -0x81c(%rbp),%eax
    3a2a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    3a2e:	40 88 75 c7          	mov    %sil,-0x39(%rbp)
    3a32:	89 55 c0             	mov    %edx,-0x40(%rbp)
    3a35:	89 4d bc             	mov    %ecx,-0x44(%rbp)
    3a38:	66 89 45 ba          	mov    %ax,-0x46(%rbp)
    3a3c:	c6 45 b9 04          	movb   $0x4,-0x47(%rbp)
  __u64 csum = 0;
    3a40:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    3a47:	00 
  iph->version = 4;
    3a48:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3a4c:	8a 08                	mov    (%rax),%cl
    3a4e:	80 e1 0f             	and    $0xf,%cl
    3a51:	80 c9 40             	or     $0x40,%cl
    3a54:	88 08                	mov    %cl,(%rax)
  iph->ihl = 5;
    3a56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3a5a:	8a 08                	mov    (%rax),%cl
    3a5c:	80 e1 f0             	and    $0xf0,%cl
    3a5f:	80 c9 05             	or     $0x5,%cl
    3a62:	88 08                	mov    %cl,(%rax)
  iph->frag_off = 0;
    3a64:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3a68:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
  iph->protocol = proto;
    3a6e:	8a 4d b9             	mov    -0x47(%rbp),%cl
    3a71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3a75:	88 48 09             	mov    %cl,0x9(%rax)
  iph->check = 0;
    3a78:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3a7c:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  iph->tos = tos;
    3a82:	8a 4d c7             	mov    -0x39(%rbp),%cl
    3a85:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3a89:	88 48 01             	mov    %cl,0x1(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    3a8c:	0f b7 45 ba          	movzwl -0x46(%rbp),%eax
    3a90:	48 83 c0 14          	add    $0x14,%rax
    3a94:	66 c1 c0 08          	rol    $0x8,%ax
    3a98:	0f b7 c0             	movzwl %ax,%eax
    3a9b:	89 85 34 e8 ff ff    	mov    %eax,-0x17cc(%rbp)
    3aa1:	8b 85 34 e8 ff ff    	mov    -0x17cc(%rbp),%eax
    3aa7:	66 89 c1             	mov    %ax,%cx
    3aaa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3aae:	66 89 48 02          	mov    %cx,0x2(%rax)
  iph->id = 0;
    3ab2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3ab6:	66 c7 40 04 00 00    	movw   $0x0,0x4(%rax)
  iph->daddr = daddr;
    3abc:	8b 4d bc             	mov    -0x44(%rbp),%ecx
    3abf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3ac3:	89 48 10             	mov    %ecx,0x10(%rax)
  iph->saddr = saddr;
    3ac6:	8b 4d c0             	mov    -0x40(%rbp),%ecx
    3ac9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3acd:	89 48 0c             	mov    %ecx,0xc(%rax)
  iph->ttl = DEFAULT_TTL;
    3ad0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3ad4:	c6 40 08 40          	movb   $0x40,0x8(%rax)
  ipv4_csum_inline(iph, &csum);
    3ad8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3adc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    3ae0:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
    3ae4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  __u16* next_iph_u16 = (__u16*)iph;
    3ae8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    3aec:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    3af0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
    3af7:	48 63 45 d4          	movslq -0x2c(%rbp),%rax
    3afb:	48 83 f8 0a          	cmp    $0xa,%rax
    3aff:	73 29                	jae    3b2a <balancer_ingress+0x3b2a>
    *csum += *next_iph_u16++;
    3b01:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    3b05:	48 89 c1             	mov    %rax,%rcx
    3b08:	48 83 c1 02          	add    $0x2,%rcx
    3b0c:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    3b10:	0f b7 00             	movzwl (%rax),%eax
    3b13:	89 c1                	mov    %eax,%ecx
    3b15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3b19:	48 03 08             	add    (%rax),%rcx
    3b1c:	48 89 08             	mov    %rcx,(%rax)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    3b1f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    3b22:	83 c0 01             	add    $0x1,%eax
    3b25:	89 45 d4             	mov    %eax,-0x2c(%rbp)
    3b28:	eb cd                	jmp    3af7 <balancer_ingress+0x3af7>
  *csum = csum_fold_helper(*csum);
    3b2a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3b2e:	48 8b 00             	mov    (%rax),%rax
    3b31:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  for (i = 0; i < 4; i++) {
    3b35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    3b3c:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
    3b40:	7d 32                	jge    3b74 <balancer_ingress+0x3b74>
    if (csum >> 16)
    3b42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3b46:	48 c1 e8 10          	shr    $0x10,%rax
    3b4a:	48 83 f8 00          	cmp    $0x0,%rax
    3b4e:	74 19                	je     3b69 <balancer_ingress+0x3b69>
      csum = (csum & 0xffff) + (csum >> 16);
    3b50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3b54:	48 25 ff ff 00 00    	and    $0xffff,%rax
    3b5a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    3b5e:	48 c1 e9 10          	shr    $0x10,%rcx
    3b62:	48 01 c8             	add    %rcx,%rax
    3b65:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  for (i = 0; i < 4; i++) {
    3b69:	8b 45 f4             	mov    -0xc(%rbp),%eax
    3b6c:	83 c0 01             	add    $0x1,%eax
    3b6f:	89 45 f4             	mov    %eax,-0xc(%rbp)
    3b72:	eb c8                	jmp    3b3c <balancer_ingress+0x3b3c>
  return ~csum;
    3b74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    3b78:	48 83 f0 ff          	xor    $0xffffffffffffffff,%rax
  *csum = csum_fold_helper(*csum);
    3b7c:	0f b7 c0             	movzwl %ax,%eax
    3b7f:	89 c1                	mov    %eax,%ecx
    3b81:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3b85:	48 89 08             	mov    %rcx,(%rax)
  iph->check = csum;
    3b88:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    3b8c:	66 89 c1             	mov    %ax,%cx
    3b8f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    3b93:	66 89 48 0a          	mov    %cx,0xa(%rax)

  return true;
    3b97:	c6 85 0f f8 ff ff 01 	movb   $0x1,-0x7f1(%rbp)
    3b9e:	f6 85 0f f8 ff ff 01 	testb  $0x1,-0x7f1(%rbp)
    3ba5:	75 0c                	jne    3bb3 <balancer_ingress+0x3bb3>
      return XDP_DROP;
    3ba7:	c7 85 14 ee ff ff 01 	movl   $0x1,-0x11ec(%rbp)
    3bae:	00 00 00 
    3bb1:	eb 0c                	jmp    3bbf <balancer_ingress+0x3bbf>
    3bb3:	eb 00                	jmp    3bb5 <balancer_ingress+0x3bb5>
  return XDP_TX;
    3bb5:	c7 85 14 ee ff ff 03 	movl   $0x3,-0x11ec(%rbp)
    3bbc:	00 00 00 
}
    3bbf:	8b 85 14 ee ff ff    	mov    -0x11ec(%rbp),%eax
    return process_packet(ctx, nh_off, false);
    3bc5:	89 85 84 e8 ff ff    	mov    %eax,-0x177c(%rbp)
    3bcb:	e9 a1 3b 00 00       	jmp    7771 <balancer_ingress+0x7771>
  } else if (eth_proto == BE_ETH_P_IPV6) {
    3bd0:	81 bd 5c e8 ff ff 86 	cmpl   $0xdd86,-0x17a4(%rbp)
    3bd7:	dd 00 00 
    3bda:	0f 85 87 3b 00 00    	jne    7767 <balancer_ingress+0x7767>
    return process_packet(ctx, nh_off, true);
    3be0:	48 8b 8d 78 e8 ff ff 	mov    -0x1788(%rbp),%rcx
    3be7:	8b 85 58 e8 ff ff    	mov    -0x17a8(%rbp),%eax
    3bed:	48 89 8d 40 eb ff ff 	mov    %rcx,-0x14c0(%rbp)
    3bf4:	48 89 85 38 eb ff ff 	mov    %rax,-0x14c8(%rbp)
    3bfb:	c6 85 37 eb ff ff 01 	movb   $0x1,-0x14c9(%rbp)
  void* data = (void*)(long)xdp->data;
    3c02:	48 8b 85 40 eb ff ff 	mov    -0x14c0(%rbp),%rax
    3c09:	48 8b 00             	mov    (%rax),%rax
    3c0c:	48 89 85 28 eb ff ff 	mov    %rax,-0x14d8(%rbp)
  void* data_end = (void*)(long)xdp->data_end;
    3c13:	48 8b 85 40 eb ff ff 	mov    -0x14c0(%rbp),%rax
    3c1a:	48 8b 40 08          	mov    0x8(%rax),%rax
    3c1e:	48 89 85 20 eb ff ff 	mov    %rax,-0x14e0(%rbp)
  struct real_definition* dst = NULL;
    3c25:	48 c7 85 10 eb ff ff 	movq   $0x0,-0x14f0(%rbp)
    3c2c:	00 00 00 00 
  struct packet_description pckt = {};
    3c30:	48 8d 85 e0 ea ff ff 	lea    -0x1520(%rbp),%rax
    3c37:	31 c9                	xor    %ecx,%ecx
    3c39:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
    3c40:	00 
    3c41:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
    3c48:	00 
    3c49:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
    3c50:	00 
    3c51:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
    3c58:	00 
    3c59:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    3c60:	00 
    3c61:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  struct vip_definition vip = {};
    3c68:	48 8d 85 c8 ea ff ff 	lea    -0x1538(%rbp),%rax
    3c6f:	31 c9                	xor    %ecx,%ecx
    3c71:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
    3c78:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    3c7f:	00 
    3c80:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  __u32 mac_addr_pos = 0;
    3c87:	c7 85 a8 ea ff ff 00 	movl   $0x0,-0x1558(%rbp)
    3c8e:	00 00 00 
  __u64 th_off = 0;
    3c91:	48 c7 85 98 ea ff ff 	movq   $0x0,-0x1568(%rbp)
    3c98:	00 00 00 00 
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
    3c9c:	48 8b b5 38 eb ff ff 	mov    -0x14c8(%rbp),%rsi
    3ca3:	48 8b 95 28 eb ff ff 	mov    -0x14d8(%rbp),%rdx
    3caa:	48 8b 8d 20 eb ff ff 	mov    -0x14e0(%rbp),%rcx
    3cb1:	8a 85 37 eb ff ff    	mov    -0x14c9(%rbp),%al
    3cb7:	48 8d bd e0 ea ff ff 	lea    -0x1520(%rbp),%rdi
    3cbe:	48 89 bd c8 ee ff ff 	mov    %rdi,-0x1138(%rbp)
    3cc5:	48 8d bd b7 ea ff ff 	lea    -0x1549(%rbp),%rdi
    3ccc:	48 89 bd c0 ee ff ff 	mov    %rdi,-0x1140(%rbp)
    3cd3:	48 89 b5 b8 ee ff ff 	mov    %rsi,-0x1148(%rbp)
    3cda:	48 8d b5 98 ea ff ff 	lea    -0x1568(%rbp),%rsi
    3ce1:	48 89 b5 b0 ee ff ff 	mov    %rsi,-0x1150(%rbp)
    3ce8:	48 8d b5 a6 ea ff ff 	lea    -0x155a(%rbp),%rsi
    3cef:	48 89 b5 a8 ee ff ff 	mov    %rsi,-0x1158(%rbp)
    3cf6:	48 89 95 a0 ee ff ff 	mov    %rdx,-0x1160(%rbp)
    3cfd:	48 89 8d 98 ee ff ff 	mov    %rcx,-0x1168(%rbp)
    3d04:	24 01                	and    $0x1,%al
    3d06:	88 85 97 ee ff ff    	mov    %al,-0x1169(%rbp)
  if (is_ipv6) {
    3d0c:	f6 85 97 ee ff ff 01 	testb  $0x1,-0x1169(%rbp)
    3d13:	0f 84 7a 01 00 00    	je     3e93 <balancer_ingress+0x3e93>
    ip6h = data + nh_off;
    3d19:	48 8b 85 a0 ee ff ff 	mov    -0x1160(%rbp),%rax
    3d20:	48 03 85 b8 ee ff ff 	add    -0x1148(%rbp),%rax
    3d27:	48 89 85 78 ee ff ff 	mov    %rax,-0x1188(%rbp)
    if (ip6h + 1 > data_end) {
    3d2e:	48 8b 85 78 ee ff ff 	mov    -0x1188(%rbp),%rax
    3d35:	48 83 c0 28          	add    $0x28,%rax
    3d39:	48 8b 8d 98 ee ff ff 	mov    -0x1168(%rbp),%rcx
    3d40:	48 39 c8             	cmp    %rcx,%rax
    3d43:	76 0f                	jbe    3d54 <balancer_ingress+0x3d54>
      return XDP_DROP;
    3d45:	c7 85 d0 ee ff ff 01 	movl   $0x1,-0x1130(%rbp)
    3d4c:	00 00 00 
    3d4f:	e9 86 02 00 00       	jmp    3fda <balancer_ingress+0x3fda>
    iph_len = sizeof(struct ipv6hdr);
    3d54:	48 c7 85 88 ee ff ff 	movq   $0x28,-0x1178(%rbp)
    3d5b:	28 00 00 00 
    *protocol = ip6h->nexthdr;
    3d5f:	48 8b 85 78 ee ff ff 	mov    -0x1188(%rbp),%rax
    3d66:	8a 48 06             	mov    0x6(%rax),%cl
    3d69:	48 8b 85 c0 ee ff ff 	mov    -0x1140(%rbp),%rax
    3d70:	88 08                	mov    %cl,(%rax)
    pckt->flow.proto = *protocol;
    3d72:	48 8b 85 c0 ee ff ff 	mov    -0x1140(%rbp),%rax
    3d79:	8a 08                	mov    (%rax),%cl
    3d7b:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3d82:	88 48 24             	mov    %cl,0x24(%rax)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
    3d85:	48 8b 85 78 ee ff ff 	mov    -0x1188(%rbp),%rax
    3d8c:	8a 00                	mov    (%rax),%al
    3d8e:	24 0f                	and    $0xf,%al
    3d90:	0f b6 c0             	movzbl %al,%eax
    3d93:	c1 e0 04             	shl    $0x4,%eax
    3d96:	25 f0 00 00 00       	and    $0xf0,%eax
    3d9b:	88 c1                	mov    %al,%cl
    3d9d:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3da4:	88 48 2d             	mov    %cl,0x2d(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
    3da7:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3dae:	0f b6 40 2d          	movzbl 0x2d(%rax),%eax
    3db2:	48 8b 8d 78 ee ff ff 	mov    -0x1188(%rbp),%rcx
    3db9:	0f b6 49 01          	movzbl 0x1(%rcx),%ecx
    3dbd:	c1 f9 04             	sar    $0x4,%ecx
    3dc0:	83 e1 0f             	and    $0xf,%ecx
    3dc3:	09 c8                	or     %ecx,%eax
    3dc5:	88 c1                	mov    %al,%cl
    3dc7:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3dce:	88 48 2d             	mov    %cl,0x2d(%rax)
    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
    3dd1:	48 8b 85 78 ee ff ff 	mov    -0x1188(%rbp),%rax
    3dd8:	66 8b 40 04          	mov    0x4(%rax),%ax
    3ddc:	66 c1 c0 08          	rol    $0x8,%ax
    3de0:	0f b7 c0             	movzwl %ax,%eax
    3de3:	89 85 30 e8 ff ff    	mov    %eax,-0x17d0(%rbp)
    3de9:	8b 85 30 e8 ff ff    	mov    -0x17d0(%rbp),%eax
    3def:	66 89 c1             	mov    %ax,%cx
    3df2:	48 8b 85 a8 ee ff ff 	mov    -0x1158(%rbp),%rax
    3df9:	66 89 08             	mov    %cx,(%rax)
    *th_off += nh_off + iph_len;
    3dfc:	48 8b 8d b8 ee ff ff 	mov    -0x1148(%rbp),%rcx
    3e03:	48 03 8d 88 ee ff ff 	add    -0x1178(%rbp),%rcx
    3e0a:	48 8b 85 b0 ee ff ff 	mov    -0x1150(%rbp),%rax
    3e11:	48 03 08             	add    (%rax),%rcx
    3e14:	48 89 08             	mov    %rcx,(%rax)
    if (*protocol == IPPROTO_FRAGMENT) {
    3e17:	48 8b 85 c0 ee ff ff 	mov    -0x1140(%rbp),%rax
    3e1e:	0f b6 00             	movzbl (%rax),%eax
    3e21:	83 f8 2c             	cmp    $0x2c,%eax
    3e24:	75 0f                	jne    3e35 <balancer_ingress+0x3e35>
      return XDP_DROP;
    3e26:	c7 85 d0 ee ff ff 01 	movl   $0x1,-0x1130(%rbp)
    3e2d:	00 00 00 
    3e30:	e9 a5 01 00 00       	jmp    3fda <balancer_ingress+0x3fda>
    } else if (*protocol == IPPROTO_ICMPV6) {
    3e35:	48 8b 85 c0 ee ff ff 	mov    -0x1140(%rbp),%rax
    3e3c:	0f b6 00             	movzbl (%rax),%eax
    3e3f:	83 f8 3a             	cmp    $0x3a,%eax
    3e42:	75 0f                	jne    3e53 <balancer_ingress+0x3e53>
      return FURTHER_PROCESSING;
    3e44:	c7 85 d0 ee ff ff ff 	movl   $0xffffffff,-0x1130(%rbp)
    3e4b:	ff ff ff 
    3e4e:	e9 87 01 00 00       	jmp    3fda <balancer_ingress+0x3fda>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
    3e53:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3e5a:	48 8b 8d 78 ee ff ff 	mov    -0x1188(%rbp),%rcx
    3e61:	48 8b 51 08          	mov    0x8(%rcx),%rdx
    3e65:	48 89 10             	mov    %rdx,(%rax)
    3e68:	48 8b 49 10          	mov    0x10(%rcx),%rcx
    3e6c:	48 89 48 08          	mov    %rcx,0x8(%rax)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
    3e70:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3e77:	48 8b 8d 78 ee ff ff 	mov    -0x1188(%rbp),%rcx
    3e7e:	48 8b 51 18          	mov    0x18(%rcx),%rdx
    3e82:	48 89 50 10          	mov    %rdx,0x10(%rax)
    3e86:	48 8b 49 20          	mov    0x20(%rcx),%rcx
    3e8a:	48 89 48 18          	mov    %rcx,0x18(%rax)
  } else {
    3e8e:	e9 3d 01 00 00       	jmp    3fd0 <balancer_ingress+0x3fd0>
    iph = data + nh_off;
    3e93:	48 8b 85 a0 ee ff ff 	mov    -0x1160(%rbp),%rax
    3e9a:	48 03 85 b8 ee ff ff 	add    -0x1148(%rbp),%rax
    3ea1:	48 89 85 80 ee ff ff 	mov    %rax,-0x1180(%rbp)
    if (iph + 1 > data_end) {
    3ea8:	48 8b 85 80 ee ff ff 	mov    -0x1180(%rbp),%rax
    3eaf:	48 83 c0 14          	add    $0x14,%rax
    3eb3:	48 8b 8d 98 ee ff ff 	mov    -0x1168(%rbp),%rcx
    3eba:	48 39 c8             	cmp    %rcx,%rax
    3ebd:	76 0f                	jbe    3ece <balancer_ingress+0x3ece>
      return XDP_DROP;
    3ebf:	c7 85 d0 ee ff ff 01 	movl   $0x1,-0x1130(%rbp)
    3ec6:	00 00 00 
    3ec9:	e9 0c 01 00 00       	jmp    3fda <balancer_ingress+0x3fda>
    if (iph->ihl != 5) {
    3ece:	48 8b 85 80 ee ff ff 	mov    -0x1180(%rbp),%rax
    3ed5:	8a 00                	mov    (%rax),%al
    3ed7:	24 0f                	and    $0xf,%al
    3ed9:	0f b6 c0             	movzbl %al,%eax
    3edc:	83 f8 05             	cmp    $0x5,%eax
    3edf:	74 0f                	je     3ef0 <balancer_ingress+0x3ef0>
      return XDP_DROP;
    3ee1:	c7 85 d0 ee ff ff 01 	movl   $0x1,-0x1130(%rbp)
    3ee8:	00 00 00 
    3eeb:	e9 ea 00 00 00       	jmp    3fda <balancer_ingress+0x3fda>
    pckt->tos = iph->tos;
    3ef0:	48 8b 85 80 ee ff ff 	mov    -0x1180(%rbp),%rax
    3ef7:	8a 48 01             	mov    0x1(%rax),%cl
    3efa:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3f01:	88 48 2d             	mov    %cl,0x2d(%rax)
    *protocol = iph->protocol;
    3f04:	48 8b 85 80 ee ff ff 	mov    -0x1180(%rbp),%rax
    3f0b:	8a 48 09             	mov    0x9(%rax),%cl
    3f0e:	48 8b 85 c0 ee ff ff 	mov    -0x1140(%rbp),%rax
    3f15:	88 08                	mov    %cl,(%rax)
    pckt->flow.proto = *protocol;
    3f17:	48 8b 85 c0 ee ff ff 	mov    -0x1140(%rbp),%rax
    3f1e:	8a 08                	mov    (%rax),%cl
    3f20:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3f27:	88 48 24             	mov    %cl,0x24(%rax)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
    3f2a:	48 8b 85 80 ee ff ff 	mov    -0x1180(%rbp),%rax
    3f31:	66 8b 40 02          	mov    0x2(%rax),%ax
    3f35:	66 c1 c0 08          	rol    $0x8,%ax
    3f39:	0f b7 c0             	movzwl %ax,%eax
    3f3c:	89 85 2c e8 ff ff    	mov    %eax,-0x17d4(%rbp)
    3f42:	8b 85 2c e8 ff ff    	mov    -0x17d4(%rbp),%eax
    3f48:	66 89 c1             	mov    %ax,%cx
    3f4b:	48 8b 85 a8 ee ff ff 	mov    -0x1158(%rbp),%rax
    3f52:	66 89 08             	mov    %cx,(%rax)
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;
    3f55:	48 8b 8d b8 ee ff ff 	mov    -0x1148(%rbp),%rcx
    3f5c:	48 83 c1 14          	add    $0x14,%rcx
    3f60:	48 8b 85 b0 ee ff ff 	mov    -0x1150(%rbp),%rax
    3f67:	48 03 08             	add    (%rax),%rcx
    3f6a:	48 89 08             	mov    %rcx,(%rax)
    if (iph->frag_off & PCKT_FRAGMENTED) {
    3f6d:	48 8b 85 80 ee ff ff 	mov    -0x1180(%rbp),%rax
    3f74:	0f b7 40 06          	movzwl 0x6(%rax),%eax
    3f78:	25 3f ff 00 00       	and    $0xff3f,%eax
    3f7d:	83 f8 00             	cmp    $0x0,%eax
    3f80:	74 0c                	je     3f8e <balancer_ingress+0x3f8e>
      return XDP_DROP;
    3f82:	c7 85 d0 ee ff ff 01 	movl   $0x1,-0x1130(%rbp)
    3f89:	00 00 00 
    3f8c:	eb 4c                	jmp    3fda <balancer_ingress+0x3fda>
    if (*protocol == IPPROTO_ICMP) {
    3f8e:	48 8b 85 c0 ee ff ff 	mov    -0x1140(%rbp),%rax
    3f95:	0f b6 00             	movzbl (%rax),%eax
    3f98:	83 f8 01             	cmp    $0x1,%eax
    3f9b:	75 0c                	jne    3fa9 <balancer_ingress+0x3fa9>
      return FURTHER_PROCESSING;
    3f9d:	c7 85 d0 ee ff ff ff 	movl   $0xffffffff,-0x1130(%rbp)
    3fa4:	ff ff ff 
    3fa7:	eb 31                	jmp    3fda <balancer_ingress+0x3fda>
      pckt->flow.src = iph->saddr;
    3fa9:	48 8b 85 80 ee ff ff 	mov    -0x1180(%rbp),%rax
    3fb0:	8b 48 0c             	mov    0xc(%rax),%ecx
    3fb3:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3fba:	89 08                	mov    %ecx,(%rax)
      pckt->flow.dst = iph->daddr;
    3fbc:	48 8b 85 80 ee ff ff 	mov    -0x1180(%rbp),%rax
    3fc3:	8b 48 10             	mov    0x10(%rax),%ecx
    3fc6:	48 8b 85 c8 ee ff ff 	mov    -0x1138(%rbp),%rax
    3fcd:	89 48 10             	mov    %ecx,0x10(%rax)
  return FURTHER_PROCESSING;
    3fd0:	c7 85 d0 ee ff ff ff 	movl   $0xffffffff,-0x1130(%rbp)
    3fd7:	ff ff ff 
}
    3fda:	8b 85 d0 ee ff ff    	mov    -0x1130(%rbp),%eax
  action = parse_l3_headers(
    3fe0:	89 85 b0 ea ff ff    	mov    %eax,-0x1550(%rbp)
  if (action >= 0) {
    3fe6:	83 bd b0 ea ff ff 00 	cmpl   $0x0,-0x1550(%rbp)
    3fed:	7c 11                	jl     4000 <balancer_ingress+0x4000>
    return action;
    3fef:	8b 85 b0 ea ff ff    	mov    -0x1550(%rbp),%eax
    3ff5:	89 85 4c eb ff ff    	mov    %eax,-0x14b4(%rbp)
    3ffb:	e9 59 37 00 00       	jmp    7759 <balancer_ingress+0x7759>
  action = handle_if_icmp(data, data_end, th_off, &pckt, protocol);
    4000:	48 8b b5 28 eb ff ff 	mov    -0x14d8(%rbp),%rsi
    4007:	48 8b 95 20 eb ff ff 	mov    -0x14e0(%rbp),%rdx
    400e:	48 8b 8d 98 ea ff ff 	mov    -0x1568(%rbp),%rcx
    4015:	8a 85 b7 ea ff ff    	mov    -0x1549(%rbp),%al
    401b:	48 89 b5 18 ef ff ff 	mov    %rsi,-0x10e8(%rbp)
    4022:	48 89 95 10 ef ff ff 	mov    %rdx,-0x10f0(%rbp)
    4029:	48 89 8d 08 ef ff ff 	mov    %rcx,-0x10f8(%rbp)
    4030:	48 8d 8d e0 ea ff ff 	lea    -0x1520(%rbp),%rcx
    4037:	48 89 8d 00 ef ff ff 	mov    %rcx,-0x1100(%rbp)
    403e:	88 85 ff ee ff ff    	mov    %al,-0x1101(%rbp)
  if (protocol == IPPROTO_ICMPV6) {
    4044:	0f b6 85 ff ee ff ff 	movzbl -0x1101(%rbp),%eax
    404b:	83 f8 3a             	cmp    $0x3a,%eax
    404e:	0f 85 2f 04 00 00    	jne    4483 <balancer_ingress+0x4483>
    return parse_icmpv6(data, data_end, off, pckt);
    4054:	48 8b b5 18 ef ff ff 	mov    -0x10e8(%rbp),%rsi
    405b:	48 8b 95 10 ef ff ff 	mov    -0x10f0(%rbp),%rdx
    4062:	48 8b 8d 08 ef ff ff 	mov    -0x10f8(%rbp),%rcx
    4069:	48 8b 85 00 ef ff ff 	mov    -0x1100(%rbp),%rax
    4070:	48 89 b5 d0 f8 ff ff 	mov    %rsi,-0x730(%rbp)
    4077:	48 89 95 c8 f8 ff ff 	mov    %rdx,-0x738(%rbp)
    407e:	48 89 8d c0 f8 ff ff 	mov    %rcx,-0x740(%rbp)
    4085:	48 89 85 b8 f8 ff ff 	mov    %rax,-0x748(%rbp)
  icmp_hdr = data + off;
    408c:	48 8b 85 d0 f8 ff ff 	mov    -0x730(%rbp),%rax
    4093:	48 03 85 c0 f8 ff ff 	add    -0x740(%rbp),%rax
    409a:	48 89 85 b0 f8 ff ff 	mov    %rax,-0x750(%rbp)
  if (icmp_hdr + 1 > data_end) {
    40a1:	48 8b 85 b0 f8 ff ff 	mov    -0x750(%rbp),%rax
    40a8:	48 83 c0 08          	add    $0x8,%rax
    40ac:	48 8b 8d c8 f8 ff ff 	mov    -0x738(%rbp),%rcx
    40b3:	48 39 c8             	cmp    %rcx,%rax
    40b6:	76 0f                	jbe    40c7 <balancer_ingress+0x40c7>
    return XDP_DROP;
    40b8:	c7 85 d8 f8 ff ff 01 	movl   $0x1,-0x728(%rbp)
    40bf:	00 00 00 
    40c2:	e9 ab 03 00 00       	jmp    4472 <balancer_ingress+0x4472>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
    40c7:	48 8b 85 b0 f8 ff ff 	mov    -0x750(%rbp),%rax
    40ce:	0f b6 00             	movzbl (%rax),%eax
    40d1:	3d 80 00 00 00       	cmp    $0x80,%eax
    40d6:	0f 85 b4 01 00 00    	jne    4290 <balancer_ingress+0x4290>
    return send_icmp6_reply(data, data_end);
    40dc:	48 8b 8d d0 f8 ff ff 	mov    -0x730(%rbp),%rcx
    40e3:	48 8b 85 c8 f8 ff ff 	mov    -0x738(%rbp),%rax
    40ea:	48 89 8d 88 fa ff ff 	mov    %rcx,-0x578(%rbp)
    40f1:	48 89 85 80 fa ff ff 	mov    %rax,-0x580(%rbp)
  __u64 off = 0;
    40f8:	48 c7 85 58 fa ff ff 	movq   $0x0,-0x5a8(%rbp)
    40ff:	00 00 00 00 
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
    4103:	48 8b 85 88 fa ff ff 	mov    -0x578(%rbp),%rax
    410a:	48 83 c0 0e          	add    $0xe,%rax
    410e:	48 83 c0 28          	add    $0x28,%rax
    4112:	48 83 c0 08          	add    $0x8,%rax
       sizeof(struct icmp6hdr)) > data_end) {
    4116:	48 3b 85 80 fa ff ff 	cmp    -0x580(%rbp),%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
    411d:	76 0f                	jbe    412e <balancer_ingress+0x412e>
    return XDP_DROP;
    411f:	c7 85 94 fa ff ff 01 	movl   $0x1,-0x56c(%rbp)
    4126:	00 00 00 
    4129:	e9 51 01 00 00       	jmp    427f <balancer_ingress+0x427f>
  off += sizeof(struct ethhdr);
    412e:	48 8b 85 58 fa ff ff 	mov    -0x5a8(%rbp),%rax
    4135:	48 83 c0 0e          	add    $0xe,%rax
    4139:	48 89 85 58 fa ff ff 	mov    %rax,-0x5a8(%rbp)
  ip6h = data + off;
    4140:	48 8b 85 88 fa ff ff 	mov    -0x578(%rbp),%rax
    4147:	48 03 85 58 fa ff ff 	add    -0x5a8(%rbp),%rax
    414e:	48 89 85 78 fa ff ff 	mov    %rax,-0x588(%rbp)
  off += sizeof(struct ipv6hdr);
    4155:	48 8b 85 58 fa ff ff 	mov    -0x5a8(%rbp),%rax
    415c:	48 83 c0 28          	add    $0x28,%rax
    4160:	48 89 85 58 fa ff ff 	mov    %rax,-0x5a8(%rbp)
  icmp_hdr = data + off;
    4167:	48 8b 85 88 fa ff ff 	mov    -0x578(%rbp),%rax
    416e:	48 03 85 58 fa ff ff 	add    -0x5a8(%rbp),%rax
    4175:	48 89 85 70 fa ff ff 	mov    %rax,-0x590(%rbp)
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
    417c:	48 8b 85 70 fa ff ff 	mov    -0x590(%rbp),%rax
    4183:	c6 00 81             	movb   $0x81,(%rax)
  icmp_hdr->icmp6_cksum -= 0x0001;
    4186:	48 8b 85 70 fa ff ff 	mov    -0x590(%rbp),%rax
    418d:	0f b7 48 02          	movzwl 0x2(%rax),%ecx
    4191:	83 e9 01             	sub    $0x1,%ecx
    4194:	66 89 48 02          	mov    %cx,0x2(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
    4198:	48 8b 85 78 fa ff ff 	mov    -0x588(%rbp),%rax
    419f:	c6 40 07 40          	movb   $0x40,0x7(%rax)
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
    41a3:	48 8b 85 78 fa ff ff 	mov    -0x588(%rbp),%rax
    41aa:	48 8b 48 08          	mov    0x8(%rax),%rcx
    41ae:	48 89 8d 60 fa ff ff 	mov    %rcx,-0x5a0(%rbp)
    41b5:	48 8b 40 10          	mov    0x10(%rax),%rax
    41b9:	48 89 85 68 fa ff ff 	mov    %rax,-0x598(%rbp)
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
    41c0:	48 8b 85 78 fa ff ff 	mov    -0x588(%rbp),%rax
    41c7:	48 8b 8d 78 fa ff ff 	mov    -0x588(%rbp),%rcx
    41ce:	48 8b 51 18          	mov    0x18(%rcx),%rdx
    41d2:	48 89 50 08          	mov    %rdx,0x8(%rax)
    41d6:	48 8b 49 20          	mov    0x20(%rcx),%rcx
    41da:	48 89 48 10          	mov    %rcx,0x10(%rax)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
    41de:	48 8b 85 78 fa ff ff 	mov    -0x588(%rbp),%rax
    41e5:	48 8b 8d 60 fa ff ff 	mov    -0x5a0(%rbp),%rcx
    41ec:	48 89 48 18          	mov    %rcx,0x18(%rax)
    41f0:	48 8b 8d 68 fa ff ff 	mov    -0x598(%rbp),%rcx
    41f7:	48 89 48 20          	mov    %rcx,0x20(%rax)
  return swap_mac_and_send(data, data_end);
    41fb:	48 8b 8d 88 fa ff ff 	mov    -0x578(%rbp),%rcx
    4202:	48 8b 85 80 fa ff ff 	mov    -0x580(%rbp),%rax
    4209:	48 89 8d b0 fa ff ff 	mov    %rcx,-0x550(%rbp)
    4210:	48 89 85 a8 fa ff ff 	mov    %rax,-0x558(%rbp)
  eth = data;
    4217:	48 8b 85 b0 fa ff ff 	mov    -0x550(%rbp),%rax
    421e:	48 89 85 a0 fa ff ff 	mov    %rax,-0x560(%rbp)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
    4225:	48 8b 85 a0 fa ff ff 	mov    -0x560(%rbp),%rax
    422c:	8b 48 06             	mov    0x6(%rax),%ecx
    422f:	89 8d 9a fa ff ff    	mov    %ecx,-0x566(%rbp)
    4235:	66 8b 40 0a          	mov    0xa(%rax),%ax
    4239:	66 89 85 9e fa ff ff 	mov    %ax,-0x562(%rbp)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
    4240:	48 8b 85 a0 fa ff ff 	mov    -0x560(%rbp),%rax
    4247:	48 8b 8d a0 fa ff ff 	mov    -0x560(%rbp),%rcx
    424e:	8b 11                	mov    (%rcx),%edx
    4250:	89 50 06             	mov    %edx,0x6(%rax)
    4253:	66 8b 49 04          	mov    0x4(%rcx),%cx
    4257:	66 89 48 0a          	mov    %cx,0xa(%rax)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
    425b:	48 8b 85 a0 fa ff ff 	mov    -0x560(%rbp),%rax
    4262:	8b 8d 9a fa ff ff    	mov    -0x566(%rbp),%ecx
    4268:	89 08                	mov    %ecx,(%rax)
    426a:	66 8b 8d 9e fa ff ff 	mov    -0x562(%rbp),%cx
    4271:	66 89 48 04          	mov    %cx,0x4(%rax)
  return swap_mac_and_send(data, data_end);
    4275:	c7 85 94 fa ff ff 03 	movl   $0x3,-0x56c(%rbp)
    427c:	00 00 00 
}
    427f:	8b 85 94 fa ff ff    	mov    -0x56c(%rbp),%eax
    return send_icmp6_reply(data, data_end);
    4285:	89 85 d8 f8 ff ff    	mov    %eax,-0x728(%rbp)
    428b:	e9 e2 01 00 00       	jmp    4472 <balancer_ingress+0x4472>
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
    4290:	48 8b 85 b0 f8 ff ff 	mov    -0x750(%rbp),%rax
    4297:	0f b6 00             	movzbl (%rax),%eax
    429a:	83 f8 02             	cmp    $0x2,%eax
    429d:	74 1e                	je     42bd <balancer_ingress+0x42bd>
      (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {
    429f:	48 8b 85 b0 f8 ff ff 	mov    -0x750(%rbp),%rax
    42a6:	0f b6 00             	movzbl (%rax),%eax
    42a9:	83 f8 01             	cmp    $0x1,%eax
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
    42ac:	74 0f                	je     42bd <balancer_ingress+0x42bd>
    return XDP_PASS;
    42ae:	c7 85 d8 f8 ff ff 02 	movl   $0x2,-0x728(%rbp)
    42b5:	00 00 00 
    42b8:	e9 b5 01 00 00       	jmp    4472 <balancer_ingress+0x4472>
  if (icmp_hdr->icmp6_type == ICMPV6_PKT_TOOBIG) {
    42bd:	48 8b 85 b0 f8 ff ff 	mov    -0x750(%rbp),%rax
    42c4:	0f b6 00             	movzbl (%rax),%eax
    42c7:	83 f8 02             	cmp    $0x2,%eax
    42ca:	0f 85 ee 00 00 00    	jne    43be <balancer_ingress+0x43be>
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
    42d0:	c7 85 a4 f8 ff ff 0c 	movl   $0x20c,-0x75c(%rbp)
    42d7:	02 00 00 
        bpf_map_lookup_elem(&stats, &stats_key);
    42da:	48 c7 85 90 f8 ff ff 	movq   $0x0,-0x770(%rbp)
    42e1:	00 00 00 00 
    42e5:	c7 85 8c f8 ff ff 02 	movl   $0x2,-0x774(%rbp)
    42ec:	00 00 00 
    42ef:	8b 85 a4 f8 ff ff    	mov    -0x75c(%rbp),%eax
    42f5:	89 85 88 f8 ff ff    	mov    %eax,-0x778(%rbp)
    42fb:	c7 85 84 f8 ff ff 02 	movl   $0x2,-0x77c(%rbp)
    4302:	00 00 00 
    4305:	c7 85 80 f8 ff ff 08 	movl   $0x8,-0x780(%rbp)
    430c:	00 00 00 
    430f:	83 bd 88 f8 ff ff 02 	cmpl   $0x2,-0x778(%rbp)
    4316:	73 21                	jae    4339 <balancer_ingress+0x4339>
    4318:	8b 85 88 f8 ff ff    	mov    -0x778(%rbp),%eax
    431e:	89 c1                	mov    %eax,%ecx
    4320:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    4327:	88 ff ff 
    432a:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    4331:	00 
    4332:	48 89 85 90 f8 ff ff 	mov    %rax,-0x770(%rbp)
    4339:	48 8b 85 90 f8 ff ff 	mov    -0x770(%rbp),%rax
    4340:	48 89 85 78 f8 ff ff 	mov    %rax,-0x788(%rbp)
    4347:	48 8b 85 78 f8 ff ff 	mov    -0x788(%rbp),%rax
    struct lb_stats* icmp_ptb_v6_stats =
    434e:	48 89 85 98 f8 ff ff 	mov    %rax,-0x768(%rbp)
    if (!icmp_ptb_v6_stats) {
    4355:	48 83 bd 98 f8 ff ff 	cmpq   $0x0,-0x768(%rbp)
    435c:	00 
    435d:	75 0f                	jne    436e <balancer_ingress+0x436e>
      return XDP_DROP;
    435f:	c7 85 d8 f8 ff ff 01 	movl   $0x1,-0x728(%rbp)
    4366:	00 00 00 
    4369:	e9 04 01 00 00       	jmp    4472 <balancer_ingress+0x4472>
    icmp_ptb_v6_stats->v1 += 1;
    436e:	48 8b 85 98 f8 ff ff 	mov    -0x768(%rbp),%rax
    4375:	48 8b 08             	mov    (%rax),%rcx
    4378:	48 83 c1 01          	add    $0x1,%rcx
    437c:	48 89 08             	mov    %rcx,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
    437f:	48 8b 85 b0 f8 ff ff 	mov    -0x750(%rbp),%rax
    4386:	8b 40 04             	mov    0x4(%rax),%eax
    4389:	0f c8                	bswap  %eax
    438b:	89 85 28 e8 ff ff    	mov    %eax,-0x17d8(%rbp)
    4391:	8b 85 28 e8 ff ff    	mov    -0x17d8(%rbp),%eax
    4397:	89 85 74 f8 ff ff    	mov    %eax,-0x78c(%rbp)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
    439d:	81 bd 74 f8 ff ff 00 	cmpl   $0x500,-0x78c(%rbp)
    43a4:	05 00 00 
    43a7:	73 13                	jae    43bc <balancer_ingress+0x43bc>
      icmp_ptb_v6_stats->v2 += 1;
    43a9:	48 8b 85 98 f8 ff ff 	mov    -0x768(%rbp),%rax
    43b0:	48 8b 48 08          	mov    0x8(%rax),%rcx
    43b4:	48 83 c1 01          	add    $0x1,%rcx
    43b8:	48 89 48 08          	mov    %rcx,0x8(%rax)
  }
    43bc:	eb 00                	jmp    43be <balancer_ingress+0x43be>
  off += sizeof(struct icmp6hdr);
    43be:	48 8b 85 c0 f8 ff ff 	mov    -0x740(%rbp),%rax
    43c5:	48 83 c0 08          	add    $0x8,%rax
    43c9:	48 89 85 c0 f8 ff ff 	mov    %rax,-0x740(%rbp)
  ip6h = data + off;
    43d0:	48 8b 85 d0 f8 ff ff 	mov    -0x730(%rbp),%rax
    43d7:	48 03 85 c0 f8 ff ff 	add    -0x740(%rbp),%rax
    43de:	48 89 85 a8 f8 ff ff 	mov    %rax,-0x758(%rbp)
  if (ip6h + 1 > data_end) {
    43e5:	48 8b 85 a8 f8 ff ff 	mov    -0x758(%rbp),%rax
    43ec:	48 83 c0 28          	add    $0x28,%rax
    43f0:	48 8b 8d c8 f8 ff ff 	mov    -0x738(%rbp),%rcx
    43f7:	48 39 c8             	cmp    %rcx,%rax
    43fa:	76 0c                	jbe    4408 <balancer_ingress+0x4408>
    return XDP_DROP;
    43fc:	c7 85 d8 f8 ff ff 01 	movl   $0x1,-0x728(%rbp)
    4403:	00 00 00 
    4406:	eb 6a                	jmp    4472 <balancer_ingress+0x4472>
  pckt->flow.proto = ip6h->nexthdr;
    4408:	48 8b 85 a8 f8 ff ff 	mov    -0x758(%rbp),%rax
    440f:	8a 48 06             	mov    0x6(%rax),%cl
    4412:	48 8b 85 b8 f8 ff ff 	mov    -0x748(%rbp),%rax
    4419:	88 48 24             	mov    %cl,0x24(%rax)
  pckt->flags |= F_ICMP;
    441c:	48 8b 85 b8 f8 ff ff 	mov    -0x748(%rbp),%rax
    4423:	0f b6 48 2c          	movzbl 0x2c(%rax),%ecx
    4427:	83 c9 01             	or     $0x1,%ecx
    442a:	88 48 2c             	mov    %cl,0x2c(%rax)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
    442d:	48 8b 85 b8 f8 ff ff 	mov    -0x748(%rbp),%rax
    4434:	48 8b 8d a8 f8 ff ff 	mov    -0x758(%rbp),%rcx
    443b:	48 8b 51 18          	mov    0x18(%rcx),%rdx
    443f:	48 89 10             	mov    %rdx,(%rax)
    4442:	48 8b 49 20          	mov    0x20(%rcx),%rcx
    4446:	48 89 48 08          	mov    %rcx,0x8(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
    444a:	48 8b 85 b8 f8 ff ff 	mov    -0x748(%rbp),%rax
    4451:	48 8b 8d a8 f8 ff ff 	mov    -0x758(%rbp),%rcx
    4458:	48 8b 51 08          	mov    0x8(%rcx),%rdx
    445c:	48 89 50 10          	mov    %rdx,0x10(%rax)
    4460:	48 8b 49 10          	mov    0x10(%rcx),%rcx
    4464:	48 89 48 18          	mov    %rcx,0x18(%rax)
  return FURTHER_PROCESSING;
    4468:	c7 85 d8 f8 ff ff ff 	movl   $0xffffffff,-0x728(%rbp)
    446f:	ff ff ff 
}
    4472:	8b 85 d8 f8 ff ff    	mov    -0x728(%rbp),%eax
    return parse_icmpv6(data, data_end, off, pckt);
    4478:	89 85 24 ef ff ff    	mov    %eax,-0x10dc(%rbp)
    447e:	e9 58 05 00 00       	jmp    49db <balancer_ingress+0x49db>
  } else if (protocol == IPPROTO_ICMP) {
    4483:	0f b6 85 ff ee ff ff 	movzbl -0x1101(%rbp),%eax
    448a:	83 f8 01             	cmp    $0x1,%eax
    448d:	0f 85 3e 05 00 00    	jne    49d1 <balancer_ingress+0x49d1>
    return parse_icmp(data, data_end, off, pckt);
    4493:	48 8b b5 18 ef ff ff 	mov    -0x10e8(%rbp),%rsi
    449a:	48 8b 95 10 ef ff ff 	mov    -0x10f0(%rbp),%rdx
    44a1:	48 8b 8d 08 ef ff ff 	mov    -0x10f8(%rbp),%rcx
    44a8:	48 8b 85 00 ef ff ff 	mov    -0x1100(%rbp),%rax
    44af:	48 89 b5 a0 f9 ff ff 	mov    %rsi,-0x660(%rbp)
    44b6:	48 89 95 98 f9 ff ff 	mov    %rdx,-0x668(%rbp)
    44bd:	48 89 8d 90 f9 ff ff 	mov    %rcx,-0x670(%rbp)
    44c4:	48 89 85 88 f9 ff ff 	mov    %rax,-0x678(%rbp)
  icmp_hdr = data + off;
    44cb:	48 8b 85 a0 f9 ff ff 	mov    -0x660(%rbp),%rax
    44d2:	48 03 85 90 f9 ff ff 	add    -0x670(%rbp),%rax
    44d9:	48 89 85 80 f9 ff ff 	mov    %rax,-0x680(%rbp)
  if (icmp_hdr + 1 > data_end) {
    44e0:	48 8b 85 80 f9 ff ff 	mov    -0x680(%rbp),%rax
    44e7:	48 83 c0 08          	add    $0x8,%rax
    44eb:	48 8b 8d 98 f9 ff ff 	mov    -0x668(%rbp),%rcx
    44f2:	48 39 c8             	cmp    %rcx,%rax
    44f5:	76 0f                	jbe    4506 <balancer_ingress+0x4506>
    return XDP_DROP;
    44f7:	c7 85 a8 f9 ff ff 01 	movl   $0x1,-0x658(%rbp)
    44fe:	00 00 00 
    4501:	e9 bd 04 00 00       	jmp    49c3 <balancer_ingress+0x49c3>
  if (icmp_hdr->type == ICMP_ECHO) {
    4506:	48 8b 85 80 f9 ff ff 	mov    -0x680(%rbp),%rax
    450d:	0f b6 00             	movzbl (%rax),%eax
    4510:	83 f8 08             	cmp    $0x8,%eax
    4513:	0f 85 c2 02 00 00    	jne    47db <balancer_ingress+0x47db>
    return send_icmp_reply(data, data_end);
    4519:	48 8b 8d a0 f9 ff ff 	mov    -0x660(%rbp),%rcx
    4520:	48 8b 85 98 f9 ff ff 	mov    -0x668(%rbp),%rax
    4527:	48 89 8d 68 fb ff ff 	mov    %rcx,-0x498(%rbp)
    452e:	48 89 85 60 fb ff ff 	mov    %rax,-0x4a0(%rbp)
  __u32 tmp_addr = 0;
    4535:	c7 85 4c fb ff ff 00 	movl   $0x0,-0x4b4(%rbp)
    453c:	00 00 00 
  __u64 csum = 0;
    453f:	48 c7 85 40 fb ff ff 	movq   $0x0,-0x4c0(%rbp)
    4546:	00 00 00 00 
  __u64 off = 0;
    454a:	48 c7 85 38 fb ff ff 	movq   $0x0,-0x4c8(%rbp)
    4551:	00 00 00 00 
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
    4555:	48 8b 85 68 fb ff ff 	mov    -0x498(%rbp),%rax
    455c:	48 83 c0 0e          	add    $0xe,%rax
    4560:	48 83 c0 14          	add    $0x14,%rax
    4564:	48 83 c0 08          	add    $0x8,%rax
       sizeof(struct icmphdr)) > data_end) {
    4568:	48 3b 85 60 fb ff ff 	cmp    -0x4a0(%rbp),%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
    456f:	76 0f                	jbe    4580 <balancer_ingress+0x4580>
    return XDP_DROP;
    4571:	c7 85 74 fb ff ff 01 	movl   $0x1,-0x48c(%rbp)
    4578:	00 00 00 
    457b:	e9 4a 02 00 00       	jmp    47ca <balancer_ingress+0x47ca>
  off += sizeof(struct ethhdr);
    4580:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
    4587:	48 83 c0 0e          	add    $0xe,%rax
    458b:	48 89 85 38 fb ff ff 	mov    %rax,-0x4c8(%rbp)
  iph = data + off;
    4592:	48 8b 85 68 fb ff ff 	mov    -0x498(%rbp),%rax
    4599:	48 03 85 38 fb ff ff 	add    -0x4c8(%rbp),%rax
    45a0:	48 89 85 58 fb ff ff 	mov    %rax,-0x4a8(%rbp)
  off += sizeof(struct iphdr);
    45a7:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
    45ae:	48 83 c0 14          	add    $0x14,%rax
    45b2:	48 89 85 38 fb ff ff 	mov    %rax,-0x4c8(%rbp)
  icmp_hdr = data + off;
    45b9:	48 8b 85 68 fb ff ff 	mov    -0x498(%rbp),%rax
    45c0:	48 03 85 38 fb ff ff 	add    -0x4c8(%rbp),%rax
    45c7:	48 89 85 50 fb ff ff 	mov    %rax,-0x4b0(%rbp)
  icmp_hdr->type = ICMP_ECHOREPLY;
    45ce:	48 8b 85 50 fb ff ff 	mov    -0x4b0(%rbp),%rax
    45d5:	c6 00 00             	movb   $0x0,(%rax)
  icmp_hdr->checksum += 0x0008;
    45d8:	48 8b 85 50 fb ff ff 	mov    -0x4b0(%rbp),%rax
    45df:	0f b7 48 02          	movzwl 0x2(%rax),%ecx
    45e3:	83 c1 08             	add    $0x8,%ecx
    45e6:	66 89 48 02          	mov    %cx,0x2(%rax)
  iph->ttl = DEFAULT_TTL;
    45ea:	48 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%rax
    45f1:	c6 40 08 40          	movb   $0x40,0x8(%rax)
  tmp_addr = iph->daddr;
    45f5:	48 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%rax
    45fc:	8b 40 10             	mov    0x10(%rax),%eax
    45ff:	89 85 4c fb ff ff    	mov    %eax,-0x4b4(%rbp)
  iph->daddr = iph->saddr;
    4605:	48 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%rax
    460c:	8b 48 0c             	mov    0xc(%rax),%ecx
    460f:	48 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%rax
    4616:	89 48 10             	mov    %ecx,0x10(%rax)
  iph->saddr = tmp_addr;
    4619:	8b 8d 4c fb ff ff    	mov    -0x4b4(%rbp),%ecx
    461f:	48 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%rax
    4626:	89 48 0c             	mov    %ecx,0xc(%rax)
  iph->check = 0;
    4629:	48 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%rax
    4630:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  ipv4_csum_inline(iph, &csum);
    4636:	48 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%rax
    463d:	48 89 85 b0 fb ff ff 	mov    %rax,-0x450(%rbp)
    4644:	48 8d 85 40 fb ff ff 	lea    -0x4c0(%rbp),%rax
    464b:	48 89 85 a8 fb ff ff 	mov    %rax,-0x458(%rbp)
  __u16* next_iph_u16 = (__u16*)iph;
    4652:	48 8b 85 b0 fb ff ff 	mov    -0x450(%rbp),%rax
    4659:	48 89 85 a0 fb ff ff 	mov    %rax,-0x460(%rbp)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    4660:	c7 85 9c fb ff ff 00 	movl   $0x0,-0x464(%rbp)
    4667:	00 00 00 
    466a:	48 63 85 9c fb ff ff 	movslq -0x464(%rbp),%rax
    4671:	48 83 f8 0a          	cmp    $0xa,%rax
    4675:	73 38                	jae    46af <balancer_ingress+0x46af>
    *csum += *next_iph_u16++;
    4677:	48 8b 85 a0 fb ff ff 	mov    -0x460(%rbp),%rax
    467e:	48 89 c1             	mov    %rax,%rcx
    4681:	48 83 c1 02          	add    $0x2,%rcx
    4685:	48 89 8d a0 fb ff ff 	mov    %rcx,-0x460(%rbp)
    468c:	0f b7 00             	movzwl (%rax),%eax
    468f:	89 c1                	mov    %eax,%ecx
    4691:	48 8b 85 a8 fb ff ff 	mov    -0x458(%rbp),%rax
    4698:	48 03 08             	add    (%rax),%rcx
    469b:	48 89 08             	mov    %rcx,(%rax)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    469e:	8b 85 9c fb ff ff    	mov    -0x464(%rbp),%eax
    46a4:	83 c0 01             	add    $0x1,%eax
    46a7:	89 85 9c fb ff ff    	mov    %eax,-0x464(%rbp)
    46ad:	eb bb                	jmp    466a <balancer_ingress+0x466a>
  *csum = csum_fold_helper(*csum);
    46af:	48 8b 85 a8 fb ff ff 	mov    -0x458(%rbp),%rax
    46b6:	48 8b 00             	mov    (%rax),%rax
    46b9:	48 89 85 f0 fb ff ff 	mov    %rax,-0x410(%rbp)
  for (i = 0; i < 4; i++) {
    46c0:	c7 85 ec fb ff ff 00 	movl   $0x0,-0x414(%rbp)
    46c7:	00 00 00 
    46ca:	83 bd ec fb ff ff 04 	cmpl   $0x4,-0x414(%rbp)
    46d1:	7d 44                	jge    4717 <balancer_ingress+0x4717>
    if (csum >> 16)
    46d3:	48 8b 85 f0 fb ff ff 	mov    -0x410(%rbp),%rax
    46da:	48 c1 e8 10          	shr    $0x10,%rax
    46de:	48 83 f8 00          	cmp    $0x0,%rax
    46e2:	74 22                	je     4706 <balancer_ingress+0x4706>
      csum = (csum & 0xffff) + (csum >> 16);
    46e4:	48 8b 85 f0 fb ff ff 	mov    -0x410(%rbp),%rax
    46eb:	48 25 ff ff 00 00    	and    $0xffff,%rax
    46f1:	48 8b 8d f0 fb ff ff 	mov    -0x410(%rbp),%rcx
    46f8:	48 c1 e9 10          	shr    $0x10,%rcx
    46fc:	48 01 c8             	add    %rcx,%rax
    46ff:	48 89 85 f0 fb ff ff 	mov    %rax,-0x410(%rbp)
  for (i = 0; i < 4; i++) {
    4706:	8b 85 ec fb ff ff    	mov    -0x414(%rbp),%eax
    470c:	83 c0 01             	add    $0x1,%eax
    470f:	89 85 ec fb ff ff    	mov    %eax,-0x414(%rbp)
    4715:	eb b3                	jmp    46ca <balancer_ingress+0x46ca>
  return ~csum;
    4717:	48 8b 85 f0 fb ff ff 	mov    -0x410(%rbp),%rax
    471e:	48 83 f0 ff          	xor    $0xffffffffffffffff,%rax
  *csum = csum_fold_helper(*csum);
    4722:	0f b7 c0             	movzwl %ax,%eax
    4725:	89 c1                	mov    %eax,%ecx
    4727:	48 8b 85 a8 fb ff ff 	mov    -0x458(%rbp),%rax
    472e:	48 89 08             	mov    %rcx,(%rax)
  iph->check = csum;
    4731:	48 8b 85 40 fb ff ff 	mov    -0x4c0(%rbp),%rax
    4738:	66 89 c1             	mov    %ax,%cx
    473b:	48 8b 85 58 fb ff ff 	mov    -0x4a8(%rbp),%rax
    4742:	66 89 48 0a          	mov    %cx,0xa(%rax)
  return swap_mac_and_send(data, data_end);
    4746:	48 8b 8d 68 fb ff ff 	mov    -0x498(%rbp),%rcx
    474d:	48 8b 85 60 fb ff ff 	mov    -0x4a0(%rbp),%rax
    4754:	48 89 8d 90 fb ff ff 	mov    %rcx,-0x470(%rbp)
    475b:	48 89 85 88 fb ff ff 	mov    %rax,-0x478(%rbp)
  eth = data;
    4762:	48 8b 85 90 fb ff ff 	mov    -0x470(%rbp),%rax
    4769:	48 89 85 80 fb ff ff 	mov    %rax,-0x480(%rbp)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
    4770:	48 8b 85 80 fb ff ff 	mov    -0x480(%rbp),%rax
    4777:	8b 48 06             	mov    0x6(%rax),%ecx
    477a:	89 8d 7a fb ff ff    	mov    %ecx,-0x486(%rbp)
    4780:	66 8b 40 0a          	mov    0xa(%rax),%ax
    4784:	66 89 85 7e fb ff ff 	mov    %ax,-0x482(%rbp)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
    478b:	48 8b 85 80 fb ff ff 	mov    -0x480(%rbp),%rax
    4792:	48 8b 8d 80 fb ff ff 	mov    -0x480(%rbp),%rcx
    4799:	8b 11                	mov    (%rcx),%edx
    479b:	89 50 06             	mov    %edx,0x6(%rax)
    479e:	66 8b 49 04          	mov    0x4(%rcx),%cx
    47a2:	66 89 48 0a          	mov    %cx,0xa(%rax)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
    47a6:	48 8b 85 80 fb ff ff 	mov    -0x480(%rbp),%rax
    47ad:	8b 8d 7a fb ff ff    	mov    -0x486(%rbp),%ecx
    47b3:	89 08                	mov    %ecx,(%rax)
    47b5:	66 8b 8d 7e fb ff ff 	mov    -0x482(%rbp),%cx
    47bc:	66 89 48 04          	mov    %cx,0x4(%rax)
  return swap_mac_and_send(data, data_end);
    47c0:	c7 85 74 fb ff ff 03 	movl   $0x3,-0x48c(%rbp)
    47c7:	00 00 00 
}
    47ca:	8b 85 74 fb ff ff    	mov    -0x48c(%rbp),%eax
    return send_icmp_reply(data, data_end);
    47d0:	89 85 a8 f9 ff ff    	mov    %eax,-0x658(%rbp)
    47d6:	e9 e8 01 00 00       	jmp    49c3 <balancer_ingress+0x49c3>
  if (icmp_hdr->type != ICMP_DEST_UNREACH) {
    47db:	48 8b 85 80 f9 ff ff 	mov    -0x680(%rbp),%rax
    47e2:	0f b6 00             	movzbl (%rax),%eax
    47e5:	83 f8 03             	cmp    $0x3,%eax
    47e8:	74 0f                	je     47f9 <balancer_ingress+0x47f9>
    return XDP_PASS;
    47ea:	c7 85 a8 f9 ff ff 02 	movl   $0x2,-0x658(%rbp)
    47f1:	00 00 00 
    47f4:	e9 ca 01 00 00       	jmp    49c3 <balancer_ingress+0x49c3>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
    47f9:	48 8b 85 80 f9 ff ff 	mov    -0x680(%rbp),%rax
    4800:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    4804:	83 f8 04             	cmp    $0x4,%eax
    4807:	0f 85 f7 00 00 00    	jne    4904 <balancer_ingress+0x4904>
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
    480d:	c7 85 74 f9 ff ff 0d 	movl   $0x20d,-0x68c(%rbp)
    4814:	02 00 00 
        bpf_map_lookup_elem(&stats, &stats_key);
    4817:	48 c7 85 60 f9 ff ff 	movq   $0x0,-0x6a0(%rbp)
    481e:	00 00 00 00 
    4822:	c7 85 5c f9 ff ff 02 	movl   $0x2,-0x6a4(%rbp)
    4829:	00 00 00 
    482c:	8b 85 74 f9 ff ff    	mov    -0x68c(%rbp),%eax
    4832:	89 85 58 f9 ff ff    	mov    %eax,-0x6a8(%rbp)
    4838:	c7 85 54 f9 ff ff 02 	movl   $0x2,-0x6ac(%rbp)
    483f:	00 00 00 
    4842:	c7 85 50 f9 ff ff 08 	movl   $0x8,-0x6b0(%rbp)
    4849:	00 00 00 
    484c:	83 bd 58 f9 ff ff 02 	cmpl   $0x2,-0x6a8(%rbp)
    4853:	73 21                	jae    4876 <balancer_ingress+0x4876>
    4855:	8b 85 58 f9 ff ff    	mov    -0x6a8(%rbp),%eax
    485b:	89 c1                	mov    %eax,%ecx
    485d:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    4864:	88 ff ff 
    4867:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    486e:	00 
    486f:	48 89 85 60 f9 ff ff 	mov    %rax,-0x6a0(%rbp)
    4876:	48 8b 85 60 f9 ff ff 	mov    -0x6a0(%rbp),%rax
    487d:	48 89 85 48 f9 ff ff 	mov    %rax,-0x6b8(%rbp)
    4884:	48 8b 85 48 f9 ff ff 	mov    -0x6b8(%rbp),%rax
    struct lb_stats* icmp_ptb_v4_stats =
    488b:	48 89 85 68 f9 ff ff 	mov    %rax,-0x698(%rbp)
    if (!icmp_ptb_v4_stats) {
    4892:	48 83 bd 68 f9 ff ff 	cmpq   $0x0,-0x698(%rbp)
    4899:	00 
    489a:	75 0f                	jne    48ab <balancer_ingress+0x48ab>
      return XDP_DROP;
    489c:	c7 85 a8 f9 ff ff 01 	movl   $0x1,-0x658(%rbp)
    48a3:	00 00 00 
    48a6:	e9 18 01 00 00       	jmp    49c3 <balancer_ingress+0x49c3>
    icmp_ptb_v4_stats->v1 += 1;
    48ab:	48 8b 85 68 f9 ff ff 	mov    -0x698(%rbp),%rax
    48b2:	48 8b 08             	mov    (%rax),%rcx
    48b5:	48 83 c1 01          	add    $0x1,%rcx
    48b9:	48 89 08             	mov    %rcx,(%rax)
    __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);
    48bc:	48 8b 85 80 f9 ff ff 	mov    -0x680(%rbp),%rax
    48c3:	66 8b 40 06          	mov    0x6(%rax),%ax
    48c7:	66 c1 c0 08          	rol    $0x8,%ax
    48cb:	0f b7 c0             	movzwl %ax,%eax
    48ce:	89 85 24 e8 ff ff    	mov    %eax,-0x17dc(%rbp)
    48d4:	8b 85 24 e8 ff ff    	mov    -0x17dc(%rbp),%eax
    48da:	66 89 85 46 f9 ff ff 	mov    %ax,-0x6ba(%rbp)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
    48e1:	0f b7 85 46 f9 ff ff 	movzwl -0x6ba(%rbp),%eax
    48e8:	3d 00 05 00 00       	cmp    $0x500,%eax
    48ed:	7d 13                	jge    4902 <balancer_ingress+0x4902>
      icmp_ptb_v4_stats->v2 += 1;
    48ef:	48 8b 85 68 f9 ff ff 	mov    -0x698(%rbp),%rax
    48f6:	48 8b 48 08          	mov    0x8(%rax),%rcx
    48fa:	48 83 c1 01          	add    $0x1,%rcx
    48fe:	48 89 48 08          	mov    %rcx,0x8(%rax)
  }
    4902:	eb 00                	jmp    4904 <balancer_ingress+0x4904>
  off += sizeof(struct icmphdr);
    4904:	48 8b 85 90 f9 ff ff 	mov    -0x670(%rbp),%rax
    490b:	48 83 c0 08          	add    $0x8,%rax
    490f:	48 89 85 90 f9 ff ff 	mov    %rax,-0x670(%rbp)
  iph = data + off;
    4916:	48 8b 85 a0 f9 ff ff 	mov    -0x660(%rbp),%rax
    491d:	48 03 85 90 f9 ff ff 	add    -0x670(%rbp),%rax
    4924:	48 89 85 78 f9 ff ff 	mov    %rax,-0x688(%rbp)
  if (iph + 1 > data_end) {
    492b:	48 8b 85 78 f9 ff ff 	mov    -0x688(%rbp),%rax
    4932:	48 83 c0 14          	add    $0x14,%rax
    4936:	48 8b 8d 98 f9 ff ff 	mov    -0x668(%rbp),%rcx
    493d:	48 39 c8             	cmp    %rcx,%rax
    4940:	76 0c                	jbe    494e <balancer_ingress+0x494e>
    return XDP_DROP;
    4942:	c7 85 a8 f9 ff ff 01 	movl   $0x1,-0x658(%rbp)
    4949:	00 00 00 
    494c:	eb 75                	jmp    49c3 <balancer_ingress+0x49c3>
  if (iph->ihl != 5) {
    494e:	48 8b 85 78 f9 ff ff 	mov    -0x688(%rbp),%rax
    4955:	8a 00                	mov    (%rax),%al
    4957:	24 0f                	and    $0xf,%al
    4959:	0f b6 c0             	movzbl %al,%eax
    495c:	83 f8 05             	cmp    $0x5,%eax
    495f:	74 0c                	je     496d <balancer_ingress+0x496d>
    return XDP_DROP;
    4961:	c7 85 a8 f9 ff ff 01 	movl   $0x1,-0x658(%rbp)
    4968:	00 00 00 
    496b:	eb 56                	jmp    49c3 <balancer_ingress+0x49c3>
  pckt->flow.proto = iph->protocol;
    496d:	48 8b 85 78 f9 ff ff 	mov    -0x688(%rbp),%rax
    4974:	8a 48 09             	mov    0x9(%rax),%cl
    4977:	48 8b 85 88 f9 ff ff 	mov    -0x678(%rbp),%rax
    497e:	88 48 24             	mov    %cl,0x24(%rax)
  pckt->flags |= F_ICMP;
    4981:	48 8b 85 88 f9 ff ff 	mov    -0x678(%rbp),%rax
    4988:	0f b6 48 2c          	movzbl 0x2c(%rax),%ecx
    498c:	83 c9 01             	or     $0x1,%ecx
    498f:	88 48 2c             	mov    %cl,0x2c(%rax)
  pckt->flow.src = iph->daddr;
    4992:	48 8b 85 78 f9 ff ff 	mov    -0x688(%rbp),%rax
    4999:	8b 48 10             	mov    0x10(%rax),%ecx
    499c:	48 8b 85 88 f9 ff ff 	mov    -0x678(%rbp),%rax
    49a3:	89 08                	mov    %ecx,(%rax)
  pckt->flow.dst = iph->saddr;
    49a5:	48 8b 85 78 f9 ff ff 	mov    -0x688(%rbp),%rax
    49ac:	8b 48 0c             	mov    0xc(%rax),%ecx
    49af:	48 8b 85 88 f9 ff ff 	mov    -0x678(%rbp),%rax
    49b6:	89 48 10             	mov    %ecx,0x10(%rax)
  return FURTHER_PROCESSING;
    49b9:	c7 85 a8 f9 ff ff ff 	movl   $0xffffffff,-0x658(%rbp)
    49c0:	ff ff ff 
}
    49c3:	8b 85 a8 f9 ff ff    	mov    -0x658(%rbp),%eax
    return parse_icmp(data, data_end, off, pckt);
    49c9:	89 85 24 ef ff ff    	mov    %eax,-0x10dc(%rbp)
    49cf:	eb 0a                	jmp    49db <balancer_ingress+0x49db>
    return FURTHER_PROCESSING;
    49d1:	c7 85 24 ef ff ff ff 	movl   $0xffffffff,-0x10dc(%rbp)
    49d8:	ff ff ff 
}
    49db:	8b 85 24 ef ff ff    	mov    -0x10dc(%rbp),%eax
    49e1:	89 85 b0 ea ff ff    	mov    %eax,-0x1550(%rbp)
  if (action >= 0) {
    49e7:	83 bd b0 ea ff ff 00 	cmpl   $0x0,-0x1550(%rbp)
    49ee:	7c 11                	jl     4a01 <balancer_ingress+0x4a01>
    return action;
    49f0:	8b 85 b0 ea ff ff    	mov    -0x1550(%rbp),%eax
    49f6:	89 85 4c eb ff ff    	mov    %eax,-0x14b4(%rbp)
    49fc:	e9 58 2d 00 00       	jmp    7759 <balancer_ingress+0x7759>
  protocol = pckt.flow.proto;
    4a01:	8a 85 04 eb ff ff    	mov    -0x14fc(%rbp),%al
    4a07:	88 85 b7 ea ff ff    	mov    %al,-0x1549(%rbp)
  if (protocol == IPPROTO_TCP) {
    4a0d:	0f b6 85 b7 ea ff ff 	movzbl -0x1549(%rbp),%eax
    4a14:	83 f8 06             	cmp    $0x6,%eax
    4a17:	0f 85 da 01 00 00    	jne    4bf7 <balancer_ingress+0x4bf7>
    if (!parse_tcp(data, data_end, is_ipv6, &pckt)) {
    4a1d:	48 8b 95 28 eb ff ff 	mov    -0x14d8(%rbp),%rdx
    4a24:	48 8b 8d 20 eb ff ff 	mov    -0x14e0(%rbp),%rcx
    4a2b:	8a 85 37 eb ff ff    	mov    -0x14c9(%rbp),%al
    4a31:	48 89 95 98 ef ff ff 	mov    %rdx,-0x1068(%rbp)
    4a38:	48 89 8d 90 ef ff ff 	mov    %rcx,-0x1070(%rbp)
    4a3f:	24 01                	and    $0x1,%al
    4a41:	88 85 8f ef ff ff    	mov    %al,-0x1071(%rbp)
    4a47:	48 8d 85 e0 ea ff ff 	lea    -0x1520(%rbp),%rax
    4a4e:	48 89 85 80 ef ff ff 	mov    %rax,-0x1080(%rbp)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
    4a55:	48 8b 85 80 ef ff ff 	mov    -0x1080(%rbp),%rax
    4a5c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
    4a60:	83 e0 01             	and    $0x1,%eax
    4a63:	83 f8 00             	cmp    $0x0,%eax
    4a66:	0f 94 c0             	sete   %al
    4a69:	34 ff                	xor    $0xff,%al
    4a6b:	24 01                	and    $0x1,%al
    4a6d:	88 85 7f ef ff ff    	mov    %al,-0x1081(%rbp)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    4a73:	8a 8d 8f ef ff ff    	mov    -0x1071(%rbp),%cl
    4a79:	8a 85 7f ef ff ff    	mov    -0x1081(%rbp),%al
    4a7f:	80 e1 01             	and    $0x1,%cl
    4a82:	88 8d 47 fc ff ff    	mov    %cl,-0x3b9(%rbp)
    4a88:	24 01                	and    $0x1,%al
    4a8a:	88 85 46 fc ff ff    	mov    %al,-0x3ba(%rbp)
  __u64 off = sizeof(struct ethhdr);
    4a90:	48 c7 85 38 fc ff ff 	movq   $0xe,-0x3c8(%rbp)
    4a97:	0e 00 00 00 
  if (is_ipv6) {
    4a9b:	f6 85 47 fc ff ff 01 	testb  $0x1,-0x3b9(%rbp)
    4aa2:	74 2f                	je     4ad3 <balancer_ingress+0x4ad3>
    off += sizeof(struct ipv6hdr);
    4aa4:	48 8b 85 38 fc ff ff 	mov    -0x3c8(%rbp),%rax
    4aab:	48 83 c0 28          	add    $0x28,%rax
    4aaf:	48 89 85 38 fc ff ff 	mov    %rax,-0x3c8(%rbp)
    if (is_icmp) {
    4ab6:	f6 85 46 fc ff ff 01 	testb  $0x1,-0x3ba(%rbp)
    4abd:	74 12                	je     4ad1 <balancer_ingress+0x4ad1>
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
    4abf:	48 8b 85 38 fc ff ff 	mov    -0x3c8(%rbp),%rax
    4ac6:	48 83 c0 30          	add    $0x30,%rax
    4aca:	48 89 85 38 fc ff ff 	mov    %rax,-0x3c8(%rbp)
  } else {
    4ad1:	eb 2f                	jmp    4b02 <balancer_ingress+0x4b02>
    off += sizeof(struct iphdr);
    4ad3:	48 8b 85 38 fc ff ff 	mov    -0x3c8(%rbp),%rax
    4ada:	48 83 c0 14          	add    $0x14,%rax
    4ade:	48 89 85 38 fc ff ff 	mov    %rax,-0x3c8(%rbp)
    if (is_icmp) {
    4ae5:	f6 85 46 fc ff ff 01 	testb  $0x1,-0x3ba(%rbp)
    4aec:	74 12                	je     4b00 <balancer_ingress+0x4b00>
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
    4aee:	48 8b 85 38 fc ff ff 	mov    -0x3c8(%rbp),%rax
    4af5:	48 83 c0 1c          	add    $0x1c,%rax
    4af9:	48 89 85 38 fc ff ff 	mov    %rax,-0x3c8(%rbp)
    4b00:	eb 00                	jmp    4b02 <balancer_ingress+0x4b02>
  return off;
    4b02:	48 8b 85 38 fc ff ff 	mov    -0x3c8(%rbp),%rax
  __u64 off = calc_offset(is_ipv6, is_icmp);
    4b09:	48 89 85 70 ef ff ff 	mov    %rax,-0x1090(%rbp)
  tcp = data + off;
    4b10:	48 8b 85 98 ef ff ff 	mov    -0x1068(%rbp),%rax
    4b17:	48 03 85 70 ef ff ff 	add    -0x1090(%rbp),%rax
    4b1e:	48 89 85 68 ef ff ff 	mov    %rax,-0x1098(%rbp)
  if (tcp + 1 > data_end) {
    4b25:	48 8b 85 68 ef ff ff 	mov    -0x1098(%rbp),%rax
    4b2c:	48 83 c0 14          	add    $0x14,%rax
    4b30:	48 8b 8d 90 ef ff ff 	mov    -0x1070(%rbp),%rcx
    4b37:	48 39 c8             	cmp    %rcx,%rax
    4b3a:	76 0c                	jbe    4b48 <balancer_ingress+0x4b48>
    return false;
    4b3c:	c6 85 a7 ef ff ff 00 	movb   $0x0,-0x1059(%rbp)
    4b43:	e9 92 00 00 00       	jmp    4bda <balancer_ingress+0x4bda>
  if (tcp->syn) {
    4b48:	48 8b 85 68 ef ff ff 	mov    -0x1098(%rbp),%rax
    4b4f:	66 8b 40 0c          	mov    0xc(%rax),%ax
    4b53:	66 c1 e8 09          	shr    $0x9,%ax
    4b57:	66 83 e0 01          	and    $0x1,%ax
    4b5b:	66 83 f8 00          	cmp    $0x0,%ax
    4b5f:	74 11                	je     4b72 <balancer_ingress+0x4b72>
    pckt->flags |= F_SYN_SET;
    4b61:	48 8b 85 80 ef ff ff 	mov    -0x1080(%rbp),%rax
    4b68:	0f b6 48 2c          	movzbl 0x2c(%rax),%ecx
    4b6c:	83 c9 02             	or     $0x2,%ecx
    4b6f:	88 48 2c             	mov    %cl,0x2c(%rax)
  if (!is_icmp) {
    4b72:	f6 85 7f ef ff ff 01 	testb  $0x1,-0x1081(%rbp)
    4b79:	75 2d                	jne    4ba8 <balancer_ingress+0x4ba8>
    pckt->flow.port16[0] = tcp->source;
    4b7b:	48 8b 85 68 ef ff ff 	mov    -0x1098(%rbp),%rax
    4b82:	66 8b 08             	mov    (%rax),%cx
    4b85:	48 8b 85 80 ef ff ff 	mov    -0x1080(%rbp),%rax
    4b8c:	66 89 48 20          	mov    %cx,0x20(%rax)
    pckt->flow.port16[1] = tcp->dest;
    4b90:	48 8b 85 68 ef ff ff 	mov    -0x1098(%rbp),%rax
    4b97:	66 8b 48 02          	mov    0x2(%rax),%cx
    4b9b:	48 8b 85 80 ef ff ff 	mov    -0x1080(%rbp),%rax
    4ba2:	66 89 48 22          	mov    %cx,0x22(%rax)
  } else {
    4ba6:	eb 2b                	jmp    4bd3 <balancer_ingress+0x4bd3>
    pckt->flow.port16[0] = tcp->dest;
    4ba8:	48 8b 85 68 ef ff ff 	mov    -0x1098(%rbp),%rax
    4baf:	66 8b 48 02          	mov    0x2(%rax),%cx
    4bb3:	48 8b 85 80 ef ff ff 	mov    -0x1080(%rbp),%rax
    4bba:	66 89 48 20          	mov    %cx,0x20(%rax)
    pckt->flow.port16[1] = tcp->source;
    4bbe:	48 8b 85 68 ef ff ff 	mov    -0x1098(%rbp),%rax
    4bc5:	66 8b 08             	mov    (%rax),%cx
    4bc8:	48 8b 85 80 ef ff ff 	mov    -0x1080(%rbp),%rax
    4bcf:	66 89 48 22          	mov    %cx,0x22(%rax)
  return true;
    4bd3:	c6 85 a7 ef ff ff 01 	movb   $0x1,-0x1059(%rbp)
    4bda:	f6 85 a7 ef ff ff 01 	testb  $0x1,-0x1059(%rbp)
    4be1:	75 0f                	jne    4bf2 <balancer_ingress+0x4bf2>
      return XDP_DROP;
    4be3:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    4bea:	00 00 00 
    4bed:	e9 67 2b 00 00       	jmp    7759 <balancer_ingress+0x7759>
  } else if (protocol == IPPROTO_UDP) {
    4bf2:	e9 c9 01 00 00       	jmp    4dc0 <balancer_ingress+0x4dc0>
    4bf7:	0f b6 85 b7 ea ff ff 	movzbl -0x1549(%rbp),%eax
    4bfe:	83 f8 11             	cmp    $0x11,%eax
    4c01:	0f 85 aa 01 00 00    	jne    4db1 <balancer_ingress+0x4db1>
    if (!parse_udp(data, data_end, is_ipv6, &pckt)) {
    4c07:	48 8b 95 28 eb ff ff 	mov    -0x14d8(%rbp),%rdx
    4c0e:	48 8b 8d 20 eb ff ff 	mov    -0x14e0(%rbp),%rcx
    4c15:	8a 85 37 eb ff ff    	mov    -0x14c9(%rbp),%al
    4c1b:	48 89 95 18 f0 ff ff 	mov    %rdx,-0xfe8(%rbp)
    4c22:	48 89 8d 10 f0 ff ff 	mov    %rcx,-0xff0(%rbp)
    4c29:	24 01                	and    $0x1,%al
    4c2b:	88 85 0f f0 ff ff    	mov    %al,-0xff1(%rbp)
    4c31:	48 8d 85 e0 ea ff ff 	lea    -0x1520(%rbp),%rax
    4c38:	48 89 85 00 f0 ff ff 	mov    %rax,-0x1000(%rbp)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
    4c3f:	48 8b 85 00 f0 ff ff 	mov    -0x1000(%rbp),%rax
    4c46:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
    4c4a:	83 e0 01             	and    $0x1,%eax
    4c4d:	83 f8 00             	cmp    $0x0,%eax
    4c50:	0f 94 c0             	sete   %al
    4c53:	34 ff                	xor    $0xff,%al
    4c55:	24 01                	and    $0x1,%al
    4c57:	88 85 ff ef ff ff    	mov    %al,-0x1001(%rbp)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    4c5d:	8a 8d 0f f0 ff ff    	mov    -0xff1(%rbp),%cl
    4c63:	8a 85 ff ef ff ff    	mov    -0x1001(%rbp),%al
    4c69:	80 e1 01             	and    $0x1,%cl
    4c6c:	88 8d 27 fc ff ff    	mov    %cl,-0x3d9(%rbp)
    4c72:	24 01                	and    $0x1,%al
    4c74:	88 85 26 fc ff ff    	mov    %al,-0x3da(%rbp)
  __u64 off = sizeof(struct ethhdr);
    4c7a:	48 c7 85 18 fc ff ff 	movq   $0xe,-0x3e8(%rbp)
    4c81:	0e 00 00 00 
  if (is_ipv6) {
    4c85:	f6 85 27 fc ff ff 01 	testb  $0x1,-0x3d9(%rbp)
    4c8c:	74 2f                	je     4cbd <balancer_ingress+0x4cbd>
    off += sizeof(struct ipv6hdr);
    4c8e:	48 8b 85 18 fc ff ff 	mov    -0x3e8(%rbp),%rax
    4c95:	48 83 c0 28          	add    $0x28,%rax
    4c99:	48 89 85 18 fc ff ff 	mov    %rax,-0x3e8(%rbp)
    if (is_icmp) {
    4ca0:	f6 85 26 fc ff ff 01 	testb  $0x1,-0x3da(%rbp)
    4ca7:	74 12                	je     4cbb <balancer_ingress+0x4cbb>
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
    4ca9:	48 8b 85 18 fc ff ff 	mov    -0x3e8(%rbp),%rax
    4cb0:	48 83 c0 30          	add    $0x30,%rax
    4cb4:	48 89 85 18 fc ff ff 	mov    %rax,-0x3e8(%rbp)
  } else {
    4cbb:	eb 2f                	jmp    4cec <balancer_ingress+0x4cec>
    off += sizeof(struct iphdr);
    4cbd:	48 8b 85 18 fc ff ff 	mov    -0x3e8(%rbp),%rax
    4cc4:	48 83 c0 14          	add    $0x14,%rax
    4cc8:	48 89 85 18 fc ff ff 	mov    %rax,-0x3e8(%rbp)
    if (is_icmp) {
    4ccf:	f6 85 26 fc ff ff 01 	testb  $0x1,-0x3da(%rbp)
    4cd6:	74 12                	je     4cea <balancer_ingress+0x4cea>
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
    4cd8:	48 8b 85 18 fc ff ff 	mov    -0x3e8(%rbp),%rax
    4cdf:	48 83 c0 1c          	add    $0x1c,%rax
    4ce3:	48 89 85 18 fc ff ff 	mov    %rax,-0x3e8(%rbp)
    4cea:	eb 00                	jmp    4cec <balancer_ingress+0x4cec>
  return off;
    4cec:	48 8b 85 18 fc ff ff 	mov    -0x3e8(%rbp),%rax
  __u64 off = calc_offset(is_ipv6, is_icmp);
    4cf3:	48 89 85 f0 ef ff ff 	mov    %rax,-0x1010(%rbp)
  udp = data + off;
    4cfa:	48 8b 85 18 f0 ff ff 	mov    -0xfe8(%rbp),%rax
    4d01:	48 03 85 f0 ef ff ff 	add    -0x1010(%rbp),%rax
    4d08:	48 89 85 e8 ef ff ff 	mov    %rax,-0x1018(%rbp)
  if (udp + 1 > data_end) {
    4d0f:	48 8b 85 e8 ef ff ff 	mov    -0x1018(%rbp),%rax
    4d16:	48 83 c0 08          	add    $0x8,%rax
    4d1a:	48 8b 8d 10 f0 ff ff 	mov    -0xff0(%rbp),%rcx
    4d21:	48 39 c8             	cmp    %rcx,%rax
    4d24:	76 09                	jbe    4d2f <balancer_ingress+0x4d2f>
    return false;
    4d26:	c6 85 27 f0 ff ff 00 	movb   $0x0,-0xfd9(%rbp)
    4d2d:	eb 68                	jmp    4d97 <balancer_ingress+0x4d97>
  if (!is_icmp) {
    4d2f:	f6 85 ff ef ff ff 01 	testb  $0x1,-0x1001(%rbp)
    4d36:	75 2d                	jne    4d65 <balancer_ingress+0x4d65>
    pckt->flow.port16[0] = udp->source;
    4d38:	48 8b 85 e8 ef ff ff 	mov    -0x1018(%rbp),%rax
    4d3f:	66 8b 08             	mov    (%rax),%cx
    4d42:	48 8b 85 00 f0 ff ff 	mov    -0x1000(%rbp),%rax
    4d49:	66 89 48 20          	mov    %cx,0x20(%rax)
    pckt->flow.port16[1] = udp->dest;
    4d4d:	48 8b 85 e8 ef ff ff 	mov    -0x1018(%rbp),%rax
    4d54:	66 8b 48 02          	mov    0x2(%rax),%cx
    4d58:	48 8b 85 00 f0 ff ff 	mov    -0x1000(%rbp),%rax
    4d5f:	66 89 48 22          	mov    %cx,0x22(%rax)
  } else {
    4d63:	eb 2b                	jmp    4d90 <balancer_ingress+0x4d90>
    pckt->flow.port16[0] = udp->dest;
    4d65:	48 8b 85 e8 ef ff ff 	mov    -0x1018(%rbp),%rax
    4d6c:	66 8b 48 02          	mov    0x2(%rax),%cx
    4d70:	48 8b 85 00 f0 ff ff 	mov    -0x1000(%rbp),%rax
    4d77:	66 89 48 20          	mov    %cx,0x20(%rax)
    pckt->flow.port16[1] = udp->source;
    4d7b:	48 8b 85 e8 ef ff ff 	mov    -0x1018(%rbp),%rax
    4d82:	66 8b 08             	mov    (%rax),%cx
    4d85:	48 8b 85 00 f0 ff ff 	mov    -0x1000(%rbp),%rax
    4d8c:	66 89 48 22          	mov    %cx,0x22(%rax)
  return true;
    4d90:	c6 85 27 f0 ff ff 01 	movb   $0x1,-0xfd9(%rbp)
    4d97:	f6 85 27 f0 ff ff 01 	testb  $0x1,-0xfd9(%rbp)
    4d9e:	75 0f                	jne    4daf <balancer_ingress+0x4daf>
      return XDP_DROP;
    4da0:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    4da7:	00 00 00 
    4daa:	e9 aa 29 00 00       	jmp    7759 <balancer_ingress+0x7759>
    4daf:	eb 0f                	jmp    4dc0 <balancer_ingress+0x4dc0>
    return XDP_PASS;
    4db1:	c7 85 4c eb ff ff 02 	movl   $0x2,-0x14b4(%rbp)
    4db8:	00 00 00 
    4dbb:	e9 99 29 00 00       	jmp    7759 <balancer_ingress+0x7759>
  if (is_ipv6) {
    4dc0:	f6 85 37 eb ff ff 01 	testb  $0x1,-0x14c9(%rbp)
    4dc7:	74 1e                	je     4de7 <balancer_ingress+0x4de7>
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
    4dc9:	48 8b 85 f0 ea ff ff 	mov    -0x1510(%rbp),%rax
    4dd0:	48 89 85 c8 ea ff ff 	mov    %rax,-0x1538(%rbp)
    4dd7:	48 8b 85 f8 ea ff ff 	mov    -0x1508(%rbp),%rax
    4dde:	48 89 85 d0 ea ff ff 	mov    %rax,-0x1530(%rbp)
  } else {
    4de5:	eb 0c                	jmp    4df3 <balancer_ingress+0x4df3>
    vip.vip = pckt.flow.dst;
    4de7:	8b 85 f0 ea ff ff    	mov    -0x1510(%rbp),%eax
    4ded:	89 85 c8 ea ff ff    	mov    %eax,-0x1538(%rbp)
  vip.port = pckt.flow.port16[1];
    4df3:	66 8b 85 02 eb ff ff 	mov    -0x14fe(%rbp),%ax
    4dfa:	66 89 85 d8 ea ff ff 	mov    %ax,-0x1528(%rbp)
  vip.proto = pckt.flow.proto;
    4e01:	8a 85 04 eb ff ff    	mov    -0x14fc(%rbp),%al
    4e07:	88 85 da ea ff ff    	mov    %al,-0x1526(%rbp)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
    4e0d:	48 c7 85 90 ea ff ff 	movq   $0x0,-0x1570(%rbp)
    4e14:	00 00 00 00 
    4e18:	c7 85 8c ea ff ff 02 	movl   $0x2,-0x1574(%rbp)
    4e1f:	00 00 00 
    4e22:	8b 85 c8 ea ff ff    	mov    -0x1538(%rbp),%eax
    4e28:	89 85 88 ea ff ff    	mov    %eax,-0x1578(%rbp)
    4e2e:	c7 85 84 ea ff ff 02 	movl   $0x2,-0x157c(%rbp)
    4e35:	00 00 00 
    4e38:	c7 85 80 ea ff ff 08 	movl   $0x8,-0x1580(%rbp)
    4e3f:	00 00 00 
    4e42:	83 bd 88 ea ff ff 02 	cmpl   $0x2,-0x1578(%rbp)
    4e49:	73 21                	jae    4e6c <balancer_ingress+0x4e6c>
    4e4b:	8b 85 88 ea ff ff    	mov    -0x1578(%rbp),%eax
    4e51:	89 c1                	mov    %eax,%ecx
    4e53:	48 b8 00 40 11 3a 81 	movabs $0xffff88813a114000,%rax
    4e5a:	88 ff ff 
    4e5d:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    4e64:	00 
    4e65:	48 89 85 90 ea ff ff 	mov    %rax,-0x1570(%rbp)
    4e6c:	48 8b 85 90 ea ff ff 	mov    -0x1570(%rbp),%rax
    4e73:	48 89 85 78 ea ff ff 	mov    %rax,-0x1588(%rbp)
    4e7a:	48 8b 85 78 ea ff ff 	mov    -0x1588(%rbp),%rax
    4e81:	48 89 85 c0 ea ff ff 	mov    %rax,-0x1540(%rbp)
  if (!vip_info) {
    4e88:	48 83 bd c0 ea ff ff 	cmpq   $0x0,-0x1540(%rbp)
    4e8f:	00 
    4e90:	0f 85 cc 00 00 00    	jne    4f62 <balancer_ingress+0x4f62>
    vip.port = 0;
    4e96:	66 c7 85 d8 ea ff ff 	movw   $0x0,-0x1528(%rbp)
    4e9d:	00 00 
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
    4e9f:	48 c7 85 70 ea ff ff 	movq   $0x0,-0x1590(%rbp)
    4ea6:	00 00 00 00 
    4eaa:	c7 85 6c ea ff ff 02 	movl   $0x2,-0x1594(%rbp)
    4eb1:	00 00 00 
    4eb4:	8b 85 c8 ea ff ff    	mov    -0x1538(%rbp),%eax
    4eba:	89 85 68 ea ff ff    	mov    %eax,-0x1598(%rbp)
    4ec0:	c7 85 64 ea ff ff 02 	movl   $0x2,-0x159c(%rbp)
    4ec7:	00 00 00 
    4eca:	c7 85 60 ea ff ff 08 	movl   $0x8,-0x15a0(%rbp)
    4ed1:	00 00 00 
    4ed4:	83 bd 68 ea ff ff 02 	cmpl   $0x2,-0x1598(%rbp)
    4edb:	73 21                	jae    4efe <balancer_ingress+0x4efe>
    4edd:	8b 85 68 ea ff ff    	mov    -0x1598(%rbp),%eax
    4ee3:	89 c1                	mov    %eax,%ecx
    4ee5:	48 b8 00 40 11 3a 81 	movabs $0xffff88813a114000,%rax
    4eec:	88 ff ff 
    4eef:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    4ef6:	00 
    4ef7:	48 89 85 70 ea ff ff 	mov    %rax,-0x1590(%rbp)
    4efe:	48 8b 85 70 ea ff ff 	mov    -0x1590(%rbp),%rax
    4f05:	48 89 85 58 ea ff ff 	mov    %rax,-0x15a8(%rbp)
    4f0c:	48 8b 85 58 ea ff ff 	mov    -0x15a8(%rbp),%rax
    4f13:	48 89 85 c0 ea ff ff 	mov    %rax,-0x1540(%rbp)
    if (!vip_info) {
    4f1a:	48 83 bd c0 ea ff ff 	cmpq   $0x0,-0x1540(%rbp)
    4f21:	00 
    4f22:	75 0f                	jne    4f33 <balancer_ingress+0x4f33>
      return XDP_PASS;
    4f24:	c7 85 4c eb ff ff 02 	movl   $0x2,-0x14b4(%rbp)
    4f2b:	00 00 00 
    4f2e:	e9 26 28 00 00       	jmp    7759 <balancer_ingress+0x7759>
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
    4f33:	48 8b 85 c0 ea ff ff 	mov    -0x1540(%rbp),%rax
    4f3a:	8b 00                	mov    (%rax),%eax
    4f3c:	83 e0 08             	and    $0x8,%eax
    4f3f:	83 f8 00             	cmp    $0x0,%eax
    4f42:	75 1c                	jne    4f60 <balancer_ingress+0x4f60>
        !(vip_info->flags & F_HASH_SRC_DST_PORT)) {
    4f44:	48 8b 85 c0 ea ff ff 	mov    -0x1540(%rbp),%rax
    4f4b:	8b 00                	mov    (%rax),%eax
    4f4d:	25 80 00 00 00       	and    $0x80,%eax
    4f52:	83 f8 00             	cmp    $0x0,%eax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
    4f55:	75 09                	jne    4f60 <balancer_ingress+0x4f60>
      pckt.flow.port16[1] = 0;
    4f57:	66 c7 85 02 eb ff ff 	movw   $0x0,-0x14fe(%rbp)
    4f5e:	00 00 
  }
    4f60:	eb 00                	jmp    4f62 <balancer_ingress+0x4f62>
  if (data_end - data > MAX_PCKT_SIZE) {
    4f62:	48 8b 85 20 eb ff ff 	mov    -0x14e0(%rbp),%rax
    4f69:	48 8b 8d 28 eb ff ff 	mov    -0x14d8(%rbp),%rcx
    4f70:	48 29 c8             	sub    %rcx,%rax
    4f73:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
    4f79:	7e 0f                	jle    4f8a <balancer_ingress+0x4f8a>
    return XDP_DROP;
    4f7b:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    4f82:	00 00 00 
    4f85:	e9 cf 27 00 00       	jmp    7759 <balancer_ingress+0x7759>
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
    4f8a:	c7 85 54 ea ff ff 00 	movl   $0x200,-0x15ac(%rbp)
    4f91:	02 00 00 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    4f94:	48 c7 85 48 ea ff ff 	movq   $0x0,-0x15b8(%rbp)
    4f9b:	00 00 00 00 
    4f9f:	c7 85 44 ea ff ff 02 	movl   $0x2,-0x15bc(%rbp)
    4fa6:	00 00 00 
    4fa9:	8b 85 54 ea ff ff    	mov    -0x15ac(%rbp),%eax
    4faf:	89 85 40 ea ff ff    	mov    %eax,-0x15c0(%rbp)
    4fb5:	c7 85 3c ea ff ff 02 	movl   $0x2,-0x15c4(%rbp)
    4fbc:	00 00 00 
    4fbf:	c7 85 38 ea ff ff 08 	movl   $0x8,-0x15c8(%rbp)
    4fc6:	00 00 00 
    4fc9:	83 bd 40 ea ff ff 02 	cmpl   $0x2,-0x15c0(%rbp)
    4fd0:	73 21                	jae    4ff3 <balancer_ingress+0x4ff3>
    4fd2:	8b 85 40 ea ff ff    	mov    -0x15c0(%rbp),%eax
    4fd8:	89 c1                	mov    %eax,%ecx
    4fda:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    4fe1:	88 ff ff 
    4fe4:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    4feb:	00 
    4fec:	48 89 85 48 ea ff ff 	mov    %rax,-0x15b8(%rbp)
    4ff3:	48 8b 85 48 ea ff ff 	mov    -0x15b8(%rbp),%rax
    4ffa:	48 89 85 30 ea ff ff 	mov    %rax,-0x15d0(%rbp)
    5001:	48 8b 85 30 ea ff ff 	mov    -0x15d0(%rbp),%rax
    5008:	48 89 85 b8 ea ff ff 	mov    %rax,-0x1548(%rbp)
  if (!data_stats) {
    500f:	48 83 bd b8 ea ff ff 	cmpq   $0x0,-0x1548(%rbp)
    5016:	00 
    5017:	75 0f                	jne    5028 <balancer_ingress+0x5028>
    return XDP_DROP;
    5019:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    5020:	00 00 00 
    5023:	e9 31 27 00 00       	jmp    7759 <balancer_ingress+0x7759>
  data_stats->v1 += 1;
    5028:	48 8b 85 b8 ea ff ff 	mov    -0x1548(%rbp),%rax
    502f:	48 8b 08             	mov    (%rax),%rcx
    5032:	48 83 c1 01          	add    $0x1,%rcx
    5036:	48 89 08             	mov    %rcx,(%rax)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
    5039:	48 8b 85 c0 ea ff ff 	mov    -0x1540(%rbp),%rax
    5040:	8b 00                	mov    (%rax),%eax
    5042:	83 e0 01             	and    $0x1,%eax
    5045:	83 f8 00             	cmp    $0x0,%eax
    5048:	74 09                	je     5053 <balancer_ingress+0x5053>
    pckt.flow.port16[0] = 0;
    504a:	66 c7 85 00 eb ff ff 	movw   $0x0,-0x1500(%rbp)
    5051:	00 00 
  vip_num = vip_info->vip_num;
    5053:	48 8b 85 c0 ea ff ff 	mov    -0x1540(%rbp),%rax
    505a:	8b 40 04             	mov    0x4(%rax),%eax
    505d:	89 85 ac ea ff ff    	mov    %eax,-0x1554(%rbp)
  __u32 cpu_num = bpf_get_smp_processor_id();
    5063:	48 b8 80 7f 00 00 00 	movabs $0x7f80,%rax
    506a:	00 00 00 
    506d:	48 8b 00             	mov    (%rax),%rax
    5070:	ff d0                	call   *%rax
    5072:	89 85 2c ea ff ff    	mov    %eax,-0x15d4(%rbp)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
    5078:	48 c7 85 18 ea ff ff 	movq   $0x0,-0x15e8(%rbp)
    507f:	00 00 00 00 
    5083:	c7 85 14 ea ff ff 02 	movl   $0x2,-0x15ec(%rbp)
    508a:	00 00 00 
    508d:	8b 85 2c ea ff ff    	mov    -0x15d4(%rbp),%eax
    5093:	89 85 10 ea ff ff    	mov    %eax,-0x15f0(%rbp)
    5099:	c7 85 0c ea ff ff 02 	movl   $0x2,-0x15f4(%rbp)
    50a0:	00 00 00 
    50a3:	c7 85 08 ea ff ff 08 	movl   $0x8,-0x15f8(%rbp)
    50aa:	00 00 00 
    50ad:	83 bd 10 ea ff ff 02 	cmpl   $0x2,-0x15f0(%rbp)
    50b4:	73 21                	jae    50d7 <balancer_ingress+0x50d7>
    50b6:	8b 85 10 ea ff ff    	mov    -0x15f0(%rbp),%eax
    50bc:	89 c1                	mov    %eax,%ecx
    50be:	48 b8 00 a0 27 71 81 	movabs $0xffff88817127a000,%rax
    50c5:	88 ff ff 
    50c8:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    50cf:	00 
    50d0:	48 89 85 18 ea ff ff 	mov    %rax,-0x15e8(%rbp)
    50d7:	48 8b 85 18 ea ff ff 	mov    -0x15e8(%rbp),%rax
    50de:	48 89 85 00 ea ff ff 	mov    %rax,-0x1600(%rbp)
    50e5:	48 8b 85 00 ea ff ff 	mov    -0x1600(%rbp),%rax
    50ec:	48 89 85 20 ea ff ff 	mov    %rax,-0x15e0(%rbp)
  if (!lru_map) {
    50f3:	48 83 bd 20 ea ff ff 	cmpq   $0x0,-0x15e0(%rbp)
    50fa:	00 
    50fb:	0f 85 c0 00 00 00    	jne    51c1 <balancer_ingress+0x51c1>
    lru_map = &fallback_cache;
    5101:	48 b8 00 38 11 3a 81 	movabs $0xffff88813a113800,%rax
    5108:	88 ff ff 
    510b:	48 89 85 20 ea ff ff 	mov    %rax,-0x15e0(%rbp)
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
    5112:	c7 85 fc e9 ff ff 03 	movl   $0x203,-0x1604(%rbp)
    5119:	02 00 00 
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
    511c:	48 c7 85 e8 e9 ff ff 	movq   $0x0,-0x1618(%rbp)
    5123:	00 00 00 00 
    5127:	c7 85 e4 e9 ff ff 02 	movl   $0x2,-0x161c(%rbp)
    512e:	00 00 00 
    5131:	8b 85 fc e9 ff ff    	mov    -0x1604(%rbp),%eax
    5137:	89 85 e0 e9 ff ff    	mov    %eax,-0x1620(%rbp)
    513d:	c7 85 dc e9 ff ff 02 	movl   $0x2,-0x1624(%rbp)
    5144:	00 00 00 
    5147:	c7 85 d8 e9 ff ff 08 	movl   $0x8,-0x1628(%rbp)
    514e:	00 00 00 
    5151:	83 bd e0 e9 ff ff 02 	cmpl   $0x2,-0x1620(%rbp)
    5158:	73 21                	jae    517b <balancer_ingress+0x517b>
    515a:	8b 85 e0 e9 ff ff    	mov    -0x1620(%rbp),%eax
    5160:	89 c1                	mov    %eax,%ecx
    5162:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    5169:	88 ff ff 
    516c:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    5173:	00 
    5174:	48 89 85 e8 e9 ff ff 	mov    %rax,-0x1618(%rbp)
    517b:	48 8b 85 e8 e9 ff ff 	mov    -0x1618(%rbp),%rax
    5182:	48 89 85 d0 e9 ff ff 	mov    %rax,-0x1630(%rbp)
    5189:	48 8b 85 d0 e9 ff ff 	mov    -0x1630(%rbp),%rax
    5190:	48 89 85 f0 e9 ff ff 	mov    %rax,-0x1610(%rbp)
    if (!lru_stats) {
    5197:	48 83 bd f0 e9 ff ff 	cmpq   $0x0,-0x1610(%rbp)
    519e:	00 
    519f:	75 0f                	jne    51b0 <balancer_ingress+0x51b0>
      return XDP_DROP;
    51a1:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    51a8:	00 00 00 
    51ab:	e9 a9 25 00 00       	jmp    7759 <balancer_ingress+0x7759>
    lru_stats->v1 += 1;
    51b0:	48 8b 85 f0 e9 ff ff 	mov    -0x1610(%rbp),%rax
    51b7:	48 8b 08             	mov    (%rax),%rcx
    51ba:	48 83 c1 01          	add    $0x1,%rcx
    51be:	48 89 08             	mov    %rcx,(%rax)
  if ((vip_info->flags & F_QUIC_VIP)) {
    51c1:	48 8b 85 c0 ea ff ff 	mov    -0x1540(%rbp),%rax
    51c8:	8b 00                	mov    (%rax),%eax
    51ca:	83 e0 04             	and    $0x4,%eax
    51cd:	83 f8 00             	cmp    $0x0,%eax
    51d0:	0f 84 ae 0c 00 00    	je     5e84 <balancer_ingress+0x5e84>
    bool is_icmp = (pckt.flags & F_ICMP);
    51d6:	0f b6 85 0c eb ff ff 	movzbl -0x14f4(%rbp),%eax
    51dd:	83 e0 01             	and    $0x1,%eax
    51e0:	83 f8 00             	cmp    $0x0,%eax
    51e3:	0f 95 c0             	setne  %al
    51e6:	24 01                	and    $0x1,%al
    51e8:	88 85 cf e9 ff ff    	mov    %al,-0x1631(%rbp)
    if (is_icmp) {
    51ee:	f6 85 cf e9 ff ff 01 	testb  $0x1,-0x1631(%rbp)
    51f5:	0f 84 be 01 00 00    	je     53b9 <balancer_ingress+0x53b9>
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
    51fb:	c7 85 c8 e9 ff ff 0b 	movl   $0x20b,-0x1638(%rbp)
    5202:	02 00 00 
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    5205:	48 c7 85 b8 e9 ff ff 	movq   $0x0,-0x1648(%rbp)
    520c:	00 00 00 00 
    5210:	c7 85 b4 e9 ff ff 02 	movl   $0x2,-0x164c(%rbp)
    5217:	00 00 00 
    521a:	8b 85 c8 e9 ff ff    	mov    -0x1638(%rbp),%eax
    5220:	89 85 b0 e9 ff ff    	mov    %eax,-0x1650(%rbp)
    5226:	c7 85 ac e9 ff ff 02 	movl   $0x2,-0x1654(%rbp)
    522d:	00 00 00 
    5230:	c7 85 a8 e9 ff ff 08 	movl   $0x8,-0x1658(%rbp)
    5237:	00 00 00 
    523a:	83 bd b0 e9 ff ff 02 	cmpl   $0x2,-0x1650(%rbp)
    5241:	73 21                	jae    5264 <balancer_ingress+0x5264>
    5243:	8b 85 b0 e9 ff ff    	mov    -0x1650(%rbp),%eax
    5249:	89 c1                	mov    %eax,%ecx
    524b:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    5252:	88 ff ff 
    5255:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    525c:	00 
    525d:	48 89 85 b8 e9 ff ff 	mov    %rax,-0x1648(%rbp)
    5264:	48 8b 85 b8 e9 ff ff 	mov    -0x1648(%rbp),%rax
    526b:	48 89 85 a0 e9 ff ff 	mov    %rax,-0x1660(%rbp)
    5272:	48 8b 85 a0 e9 ff ff 	mov    -0x1660(%rbp),%rax
    5279:	48 89 85 c0 e9 ff ff 	mov    %rax,-0x1640(%rbp)
      if (!data_stats) {
    5280:	48 83 bd c0 e9 ff ff 	cmpq   $0x0,-0x1640(%rbp)
    5287:	00 
    5288:	75 0f                	jne    5299 <balancer_ingress+0x5299>
        return XDP_DROP;
    528a:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    5291:	00 00 00 
    5294:	e9 c0 24 00 00       	jmp    7759 <balancer_ingress+0x7759>
      data_stats->v1 += 1;
    5299:	48 8b 85 c0 e9 ff ff 	mov    -0x1640(%rbp),%rax
    52a0:	48 8b 08             	mov    (%rax),%rcx
    52a3:	48 83 c1 01          	add    $0x1,%rcx
    52a7:	48 89 08             	mov    %rcx,(%rax)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    52aa:	48 8b 95 28 eb ff ff 	mov    -0x14d8(%rbp),%rdx
    52b1:	48 8b 8d 20 eb ff ff 	mov    -0x14e0(%rbp),%rcx
    52b8:	8a 85 37 eb ff ff    	mov    -0x14c9(%rbp),%al
    52be:	48 89 95 88 f0 ff ff 	mov    %rdx,-0xf78(%rbp)
    52c5:	48 89 8d 80 f0 ff ff 	mov    %rcx,-0xf80(%rbp)
    52cc:	24 01                	and    $0x1,%al
    52ce:	88 85 7f f0 ff ff    	mov    %al,-0xf81(%rbp)
  __u64 off = sizeof(struct ethhdr);
    52d4:	48 c7 85 70 f0 ff ff 	movq   $0xe,-0xf90(%rbp)
    52db:	0e 00 00 00 
  if (is_ipv6) {
    52df:	f6 85 7f f0 ff ff 01 	testb  $0x1,-0xf81(%rbp)
    52e6:	74 58                	je     5340 <balancer_ingress+0x5340>
    struct icmp6hdr* icmp_hdr = data + off + sizeof(struct ipv6hdr);
    52e8:	48 8b 85 88 f0 ff ff 	mov    -0xf78(%rbp),%rax
    52ef:	48 03 85 70 f0 ff ff 	add    -0xf90(%rbp),%rax
    52f6:	48 83 c0 28          	add    $0x28,%rax
    52fa:	48 89 85 68 f0 ff ff 	mov    %rax,-0xf98(%rbp)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
    5301:	48 8b 85 68 f0 ff ff 	mov    -0xf98(%rbp),%rax
    5308:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    530c:	b0 01                	mov    $0x1,%al
    530e:	83 f9 03             	cmp    $0x3,%ecx
    5311:	88 85 23 e8 ff ff    	mov    %al,-0x17dd(%rbp)
    5317:	74 17                	je     5330 <balancer_ingress+0x5330>
        (icmp_hdr->icmp6_code == ICMPV6_PORT_UNREACH));
    5319:	48 8b 85 68 f0 ff ff 	mov    -0xf98(%rbp),%rax
    5320:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    5324:	83 f8 04             	cmp    $0x4,%eax
    5327:	0f 94 c0             	sete   %al
    532a:	88 85 23 e8 ff ff    	mov    %al,-0x17dd(%rbp)
    5330:	8a 85 23 e8 ff ff    	mov    -0x17dd(%rbp),%al
    return (
    5336:	24 01                	and    $0x1,%al
    5338:	88 85 96 f0 ff ff    	mov    %al,-0xf6a(%rbp)
    533e:	eb 56                	jmp    5396 <balancer_ingress+0x5396>
    struct icmphdr* icmp_hdr = data + off + sizeof(struct iphdr);
    5340:	48 8b 85 88 f0 ff ff 	mov    -0xf78(%rbp),%rax
    5347:	48 03 85 70 f0 ff ff 	add    -0xf90(%rbp),%rax
    534e:	48 83 c0 14          	add    $0x14,%rax
    5352:	48 89 85 60 f0 ff ff 	mov    %rax,-0xfa0(%rbp)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    5359:	48 8b 85 60 f0 ff ff 	mov    -0xfa0(%rbp),%rax
    5360:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    5364:	b0 01                	mov    $0x1,%al
    5366:	83 f9 03             	cmp    $0x3,%ecx
    5369:	88 85 22 e8 ff ff    	mov    %al,-0x17de(%rbp)
    536f:	74 17                	je     5388 <balancer_ingress+0x5388>
        (icmp_hdr->code == ICMP_HOST_UNREACH));
    5371:	48 8b 85 60 f0 ff ff 	mov    -0xfa0(%rbp),%rax
    5378:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    537c:	83 f8 01             	cmp    $0x1,%eax
    537f:	0f 94 c0             	sete   %al
    5382:	88 85 22 e8 ff ff    	mov    %al,-0x17de(%rbp)
    5388:	8a 85 22 e8 ff ff    	mov    -0x17de(%rbp),%al
    return (
    538e:	24 01                	and    $0x1,%al
    5390:	88 85 96 f0 ff ff    	mov    %al,-0xf6a(%rbp)
    5396:	f6 85 96 f0 ff ff 01 	testb  $0x1,-0xf6a(%rbp)
    539d:	75 02                	jne    53a1 <balancer_ingress+0x53a1>
    539f:	eb 13                	jmp    53b4 <balancer_ingress+0x53b4>
        data_stats->v2 += 1;
    53a1:	48 8b 85 c0 e9 ff ff 	mov    -0x1640(%rbp),%rax
    53a8:	48 8b 48 08          	mov    0x8(%rax),%rcx
    53ac:	48 83 c1 01          	add    $0x1,%rcx
    53b0:	48 89 48 08          	mov    %rcx,0x8(%rax)
    } else {
    53b4:	e9 c9 0a 00 00       	jmp    5e82 <balancer_ingress+0x5e82>
      __u32 quic_packets_stats_key = 0;
    53b9:	c7 85 9c e9 ff ff 00 	movl   $0x0,-0x1664(%rbp)
    53c0:	00 00 00 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
    53c3:	48 c7 85 88 e9 ff ff 	movq   $0x0,-0x1678(%rbp)
    53ca:	00 00 00 00 
    53ce:	c7 85 84 e9 ff ff 02 	movl   $0x2,-0x167c(%rbp)
    53d5:	00 00 00 
    53d8:	8b 85 9c e9 ff ff    	mov    -0x1664(%rbp),%eax
    53de:	89 85 80 e9 ff ff    	mov    %eax,-0x1680(%rbp)
    53e4:	c7 85 7c e9 ff ff 02 	movl   $0x2,-0x1684(%rbp)
    53eb:	00 00 00 
    53ee:	c7 85 78 e9 ff ff 08 	movl   $0x8,-0x1688(%rbp)
    53f5:	00 00 00 
    53f8:	83 bd 80 e9 ff ff 02 	cmpl   $0x2,-0x1680(%rbp)
    53ff:	73 21                	jae    5422 <balancer_ingress+0x5422>
    5401:	8b 85 80 e9 ff ff    	mov    -0x1680(%rbp),%eax
    5407:	89 c1                	mov    %eax,%ecx
    5409:	48 b8 00 28 97 51 81 	movabs $0xffff888151972800,%rax
    5410:	88 ff ff 
    5413:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    541a:	00 
    541b:	48 89 85 88 e9 ff ff 	mov    %rax,-0x1678(%rbp)
    5422:	48 8b 85 88 e9 ff ff 	mov    -0x1678(%rbp),%rax
    5429:	48 89 85 70 e9 ff ff 	mov    %rax,-0x1690(%rbp)
    5430:	48 8b 85 70 e9 ff ff 	mov    -0x1690(%rbp),%rax
      struct lb_quic_packets_stats* quic_packets_stats =
    5437:	48 89 85 90 e9 ff ff 	mov    %rax,-0x1670(%rbp)
      if (!quic_packets_stats) {
    543e:	48 83 bd 90 e9 ff ff 	cmpq   $0x0,-0x1670(%rbp)
    5445:	00 
    5446:	75 0f                	jne    5457 <balancer_ingress+0x5457>
        return XDP_DROP;
    5448:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    544f:	00 00 00 
    5452:	e9 02 23 00 00       	jmp    7759 <balancer_ingress+0x7759>
      struct quic_parse_result qpr = parse_quic(data, data_end, is_ipv6, &pckt);
    5457:	48 8b 95 28 eb ff ff 	mov    -0x14d8(%rbp),%rdx
    545e:	48 8b 8d 20 eb ff ff 	mov    -0x14e0(%rbp),%rcx
    5465:	8a 85 37 eb ff ff    	mov    -0x14c9(%rbp),%al
    546b:	48 89 95 40 f1 ff ff 	mov    %rdx,-0xec0(%rbp)
    5472:	48 89 8d 38 f1 ff ff 	mov    %rcx,-0xec8(%rbp)
    5479:	24 01                	and    $0x1,%al
    547b:	88 85 37 f1 ff ff    	mov    %al,-0xec9(%rbp)
    5481:	48 8d 85 e0 ea ff ff 	lea    -0x1520(%rbp),%rax
    5488:	48 89 85 28 f1 ff ff 	mov    %rax,-0xed8(%rbp)
  struct quic_parse_result result = {
    548f:	48 8d 85 48 f1 ff ff 	lea    -0xeb8(%rbp),%rax
    5496:	48 b9 cc 7c 00 00 00 	movabs $0x7ccc,%rcx
    549d:	00 00 00 
    54a0:	48 8b 09             	mov    (%rcx),%rcx
    54a3:	48 89 08             	mov    %rcx,(%rax)
  bool is_icmp = (pckt->flags & F_ICMP);
    54a6:	48 8b 85 28 f1 ff ff 	mov    -0xed8(%rbp),%rax
    54ad:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
    54b1:	83 e0 01             	and    $0x1,%eax
    54b4:	83 f8 00             	cmp    $0x0,%eax
    54b7:	0f 95 c0             	setne  %al
    54ba:	24 01                	and    $0x1,%al
    54bc:	88 85 27 f1 ff ff    	mov    %al,-0xed9(%rbp)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    54c2:	8a 8d 37 f1 ff ff    	mov    -0xec9(%rbp),%cl
    54c8:	8a 85 27 f1 ff ff    	mov    -0xed9(%rbp),%al
    54ce:	80 e1 01             	and    $0x1,%cl
    54d1:	88 8d 07 fc ff ff    	mov    %cl,-0x3f9(%rbp)
    54d7:	24 01                	and    $0x1,%al
    54d9:	88 85 06 fc ff ff    	mov    %al,-0x3fa(%rbp)
  __u64 off = sizeof(struct ethhdr);
    54df:	48 c7 85 f8 fb ff ff 	movq   $0xe,-0x408(%rbp)
    54e6:	0e 00 00 00 
  if (is_ipv6) {
    54ea:	f6 85 07 fc ff ff 01 	testb  $0x1,-0x3f9(%rbp)
    54f1:	74 2f                	je     5522 <balancer_ingress+0x5522>
    off += sizeof(struct ipv6hdr);
    54f3:	48 8b 85 f8 fb ff ff 	mov    -0x408(%rbp),%rax
    54fa:	48 83 c0 28          	add    $0x28,%rax
    54fe:	48 89 85 f8 fb ff ff 	mov    %rax,-0x408(%rbp)
    if (is_icmp) {
    5505:	f6 85 06 fc ff ff 01 	testb  $0x1,-0x3fa(%rbp)
    550c:	74 12                	je     5520 <balancer_ingress+0x5520>
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
    550e:	48 8b 85 f8 fb ff ff 	mov    -0x408(%rbp),%rax
    5515:	48 83 c0 30          	add    $0x30,%rax
    5519:	48 89 85 f8 fb ff ff 	mov    %rax,-0x408(%rbp)
  } else {
    5520:	eb 2f                	jmp    5551 <balancer_ingress+0x5551>
    off += sizeof(struct iphdr);
    5522:	48 8b 85 f8 fb ff ff 	mov    -0x408(%rbp),%rax
    5529:	48 83 c0 14          	add    $0x14,%rax
    552d:	48 89 85 f8 fb ff ff 	mov    %rax,-0x408(%rbp)
    if (is_icmp) {
    5534:	f6 85 06 fc ff ff 01 	testb  $0x1,-0x3fa(%rbp)
    553b:	74 12                	je     554f <balancer_ingress+0x554f>
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
    553d:	48 8b 85 f8 fb ff ff 	mov    -0x408(%rbp),%rax
    5544:	48 83 c0 1c          	add    $0x1c,%rax
    5548:	48 89 85 f8 fb ff ff 	mov    %rax,-0x408(%rbp)
    554f:	eb 00                	jmp    5551 <balancer_ingress+0x5551>
  return off;
    5551:	48 8b 85 f8 fb ff ff 	mov    -0x408(%rbp),%rax
  __u64 off = calc_offset(is_ipv6, is_icmp);
    5558:	48 89 85 18 f1 ff ff 	mov    %rax,-0xee8(%rbp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    555f:	48 8b 85 40 f1 ff ff 	mov    -0xec0(%rbp),%rax
    5566:	48 03 85 18 f1 ff ff 	add    -0xee8(%rbp),%rax
    556d:	48 83 c0 08          	add    $0x8,%rax
    5571:	48 83 c0 01          	add    $0x1,%rax
    5575:	48 3b 85 38 f1 ff ff 	cmp    -0xec8(%rbp),%rax
    557c:	76 05                	jbe    5583 <balancer_ingress+0x5583>
    return result;
    557e:	e9 e4 01 00 00       	jmp    5767 <balancer_ingress+0x5767>
  __u8* quic_data = data + off + sizeof(struct udphdr);
    5583:	48 8b 85 40 f1 ff ff 	mov    -0xec0(%rbp),%rax
    558a:	48 03 85 18 f1 ff ff 	add    -0xee8(%rbp),%rax
    5591:	48 83 c0 08          	add    $0x8,%rax
    5595:	48 89 85 10 f1 ff ff 	mov    %rax,-0xef0(%rbp)
  __u8* pkt_type = quic_data;
    559c:	48 8b 85 10 f1 ff ff 	mov    -0xef0(%rbp),%rax
    55a3:	48 89 85 08 f1 ff ff 	mov    %rax,-0xef8(%rbp)
  __u8* connId = NULL;
    55aa:	48 c7 85 00 f1 ff ff 	movq   $0x0,-0xf00(%rbp)
    55b1:	00 00 00 00 
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    55b5:	48 8b 85 08 f1 ff ff 	mov    -0xef8(%rbp),%rax
    55bc:	0f b6 00             	movzbl (%rax),%eax
    55bf:	25 80 00 00 00       	and    $0x80,%eax
    55c4:	3d 80 00 00 00       	cmp    $0x80,%eax
    55c9:	75 6e                	jne    5639 <balancer_ingress+0x5639>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    55cb:	48 8b 85 10 f1 ff ff 	mov    -0xef0(%rbp),%rax
    55d2:	48 83 c0 0e          	add    $0xe,%rax
    55d6:	48 3b 85 38 f1 ff ff 	cmp    -0xec8(%rbp),%rax
    55dd:	76 05                	jbe    55e4 <balancer_ingress+0x55e4>
      return result;
    55df:	e9 83 01 00 00       	jmp    5767 <balancer_ingress+0x5767>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    55e4:	48 8b 85 08 f1 ff ff 	mov    -0xef8(%rbp),%rax
    55eb:	0f b6 00             	movzbl (%rax),%eax
    55ee:	83 e0 30             	and    $0x30,%eax
    55f1:	83 f8 20             	cmp    $0x20,%eax
    55f4:	7d 0c                	jge    5602 <balancer_ingress+0x5602>
      result.is_initial = true;
    55f6:	c6 85 4d f1 ff ff 01 	movb   $0x1,-0xeb3(%rbp)
      return result;
    55fd:	e9 65 01 00 00       	jmp    5767 <balancer_ingress+0x5767>
    struct quic_long_header* long_header = (struct quic_long_header*)quic_data;
    5602:	48 8b 85 10 f1 ff ff 	mov    -0xef0(%rbp),%rax
    5609:	48 89 85 f8 f0 ff ff 	mov    %rax,-0xf08(%rbp)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    5610:	48 8b 85 f8 f0 ff ff 	mov    -0xf08(%rbp),%rax
    5617:	0f b6 40 05          	movzbl 0x5(%rax),%eax
    561b:	83 f8 08             	cmp    $0x8,%eax
    561e:	7d 05                	jge    5625 <balancer_ingress+0x5625>
      return result;
    5620:	e9 42 01 00 00       	jmp    5767 <balancer_ingress+0x5767>
    connId = long_header->dst_connection_id;
    5625:	48 8b 85 f8 f0 ff ff 	mov    -0xf08(%rbp),%rax
    562c:	48 83 c0 06          	add    $0x6,%rax
    5630:	48 89 85 00 f1 ff ff 	mov    %rax,-0xf00(%rbp)
  } else {
    5637:	eb 2b                	jmp    5664 <balancer_ingress+0x5664>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    5639:	48 8b 85 10 f1 ff ff 	mov    -0xef0(%rbp),%rax
    5640:	48 83 c0 09          	add    $0x9,%rax
    5644:	48 3b 85 38 f1 ff ff 	cmp    -0xec8(%rbp),%rax
    564b:	76 05                	jbe    5652 <balancer_ingress+0x5652>
      return result;
    564d:	e9 15 01 00 00       	jmp    5767 <balancer_ingress+0x5767>
    connId = ((struct quic_short_header*)quic_data)->connection_id;
    5652:	48 8b 85 10 f1 ff ff 	mov    -0xef0(%rbp),%rax
    5659:	48 83 c0 01          	add    $0x1,%rax
    565d:	48 89 85 00 f1 ff ff 	mov    %rax,-0xf00(%rbp)
  if (!connId) {
    5664:	48 83 bd 00 f1 ff ff 	cmpq   $0x0,-0xf00(%rbp)
    566b:	00 
    566c:	75 05                	jne    5673 <balancer_ingress+0x5673>
    return result;
    566e:	e9 f4 00 00 00       	jmp    5767 <balancer_ingress+0x5767>
  __u8 connIdVersion = (connId[0] >> 6);
    5673:	48 8b 85 00 f1 ff ff 	mov    -0xf00(%rbp),%rax
    567a:	0f b6 00             	movzbl (%rax),%eax
    567d:	c1 f8 06             	sar    $0x6,%eax
    5680:	88 85 f7 f0 ff ff    	mov    %al,-0xf09(%rbp)
  result.cid_version = connIdVersion;
    5686:	8a 85 f7 f0 ff ff    	mov    -0xf09(%rbp),%al
    568c:	88 85 4c f1 ff ff    	mov    %al,-0xeb4(%rbp)
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    5692:	0f b6 85 f7 f0 ff ff 	movzbl -0xf09(%rbp),%eax
    5699:	83 f8 01             	cmp    $0x1,%eax
    569c:	75 3b                	jne    56d9 <balancer_ingress+0x56d9>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    569e:	48 8b 85 00 f1 ff ff 	mov    -0xf00(%rbp),%rax
    56a5:	0f b6 00             	movzbl (%rax),%eax
    56a8:	83 e0 3f             	and    $0x3f,%eax
    56ab:	c1 e0 0a             	shl    $0xa,%eax
    56ae:	48 8b 8d 00 f1 ff ff 	mov    -0xf00(%rbp),%rcx
    56b5:	0f b6 49 01          	movzbl 0x1(%rcx),%ecx
    56b9:	c1 e1 02             	shl    $0x2,%ecx
    56bc:	09 c8                	or     %ecx,%eax
    56be:	48 8b 8d 00 f1 ff ff 	mov    -0xf00(%rbp),%rcx
    56c5:	0f b6 49 02          	movzbl 0x2(%rcx),%ecx
    56c9:	c1 f9 06             	sar    $0x6,%ecx
    56cc:	09 c8                	or     %ecx,%eax
    result.server_id =
    56ce:	89 85 48 f1 ff ff    	mov    %eax,-0xeb8(%rbp)
    return result;
    56d4:	e9 8e 00 00 00       	jmp    5767 <balancer_ingress+0x5767>
  } else if (connIdVersion == QUIC_CONNID_VERSION_V2) {
    56d9:	0f b6 85 f7 f0 ff ff 	movzbl -0xf09(%rbp),%eax
    56e0:	83 f8 02             	cmp    $0x2,%eax
    56e3:	75 33                	jne    5718 <balancer_ingress+0x5718>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    56e5:	48 8b 85 00 f1 ff ff 	mov    -0xf00(%rbp),%rax
    56ec:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    56f0:	c1 e0 10             	shl    $0x10,%eax
    56f3:	48 8b 8d 00 f1 ff ff 	mov    -0xf00(%rbp),%rcx
    56fa:	0f b6 49 02          	movzbl 0x2(%rcx),%ecx
    56fe:	c1 e1 08             	shl    $0x8,%ecx
    5701:	09 c8                	or     %ecx,%eax
    5703:	48 8b 8d 00 f1 ff ff 	mov    -0xf00(%rbp),%rcx
    570a:	0f b6 49 03          	movzbl 0x3(%rcx),%ecx
    570e:	09 c8                	or     %ecx,%eax
    5710:	89 85 48 f1 ff ff    	mov    %eax,-0xeb8(%rbp)
    return result;
    5716:	eb 4f                	jmp    5767 <balancer_ingress+0x5767>
  } else if (connIdVersion == QUIC_CONNID_VERSION_V3) {
    5718:	0f b6 85 f7 f0 ff ff 	movzbl -0xf09(%rbp),%eax
    571f:	83 f8 03             	cmp    $0x3,%eax
    5722:	75 41                	jne    5765 <balancer_ingress+0x5765>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    5724:	48 8b 85 00 f1 ff ff 	mov    -0xf00(%rbp),%rax
    572b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    572f:	c1 e0 18             	shl    $0x18,%eax
    5732:	48 8b 8d 00 f1 ff ff 	mov    -0xf00(%rbp),%rcx
    5739:	0f b6 49 02          	movzbl 0x2(%rcx),%ecx
    573d:	c1 e1 10             	shl    $0x10,%ecx
    5740:	09 c8                	or     %ecx,%eax
    5742:	48 8b 8d 00 f1 ff ff 	mov    -0xf00(%rbp),%rcx
    5749:	0f b6 49 03          	movzbl 0x3(%rcx),%ecx
    574d:	c1 e1 08             	shl    $0x8,%ecx
    5750:	09 c8                	or     %ecx,%eax
    5752:	48 8b 8d 00 f1 ff ff 	mov    -0xf00(%rbp),%rcx
    5759:	0f b6 49 04          	movzbl 0x4(%rcx),%ecx
    575d:	09 c8                	or     %ecx,%eax
    result.server_id =
    575f:	89 85 48 f1 ff ff    	mov    %eax,-0xeb8(%rbp)
  return result;
    5765:	eb 00                	jmp    5767 <balancer_ingress+0x5767>
}
    5767:	48 8b 85 48 f1 ff ff 	mov    -0xeb8(%rbp),%rax
    576e:	48 89 85 68 e9 ff ff 	mov    %rax,-0x1698(%rbp)
      if (qpr.server_id > 0) {
    5775:	83 bd 68 e9 ff ff 00 	cmpl   $0x0,-0x1698(%rbp)
    577c:	0f 8e f1 05 00 00    	jle    5d73 <balancer_ingress+0x5d73>
        increment_quic_cid_version_stats(quic_packets_stats, qpr.cid_version);
    5782:	48 8b 8d 90 e9 ff ff 	mov    -0x1670(%rbp),%rcx
    5789:	8a 85 6c e9 ff ff    	mov    -0x1694(%rbp),%al
    578f:	48 89 8d 68 f1 ff ff 	mov    %rcx,-0xe98(%rbp)
    5796:	88 85 67 f1 ff ff    	mov    %al,-0xe99(%rbp)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    579c:	0f b6 85 67 f1 ff ff 	movzbl -0xe99(%rbp),%eax
    57a3:	83 f8 01             	cmp    $0x1,%eax
    57a6:	75 15                	jne    57bd <balancer_ingress+0x57bd>
    quic_packets_stats->cid_v1 += 1;
    57a8:	48 8b 85 68 f1 ff ff 	mov    -0xe98(%rbp),%rax
    57af:	48 8b 48 38          	mov    0x38(%rax),%rcx
    57b3:	48 83 c1 01          	add    $0x1,%rcx
    57b7:	48 89 48 38          	mov    %rcx,0x38(%rax)
  } else if (cid_version == QUIC_CONNID_VERSION_V2) {
    57bb:	eb 59                	jmp    5816 <balancer_ingress+0x5816>
    57bd:	0f b6 85 67 f1 ff ff 	movzbl -0xe99(%rbp),%eax
    57c4:	83 f8 02             	cmp    $0x2,%eax
    57c7:	75 15                	jne    57de <balancer_ingress+0x57de>
    quic_packets_stats->cid_v2 += 1;
    57c9:	48 8b 85 68 f1 ff ff 	mov    -0xe98(%rbp),%rax
    57d0:	48 8b 48 40          	mov    0x40(%rax),%rcx
    57d4:	48 83 c1 01          	add    $0x1,%rcx
    57d8:	48 89 48 40          	mov    %rcx,0x40(%rax)
  } else if (cid_version == QUIC_CONNID_VERSION_V3) {
    57dc:	eb 36                	jmp    5814 <balancer_ingress+0x5814>
    57de:	0f b6 85 67 f1 ff ff 	movzbl -0xe99(%rbp),%eax
    57e5:	83 f8 03             	cmp    $0x3,%eax
    57e8:	75 15                	jne    57ff <balancer_ingress+0x57ff>
    quic_packets_stats->cid_v3 += 1;
    57ea:	48 8b 85 68 f1 ff ff 	mov    -0xe98(%rbp),%rax
    57f1:	48 8b 48 48          	mov    0x48(%rax),%rcx
    57f5:	48 83 c1 01          	add    $0x1,%rcx
    57f9:	48 89 48 48          	mov    %rcx,0x48(%rax)
  } else {
    57fd:	eb 13                	jmp    5812 <balancer_ingress+0x5812>
    quic_packets_stats->cid_v0 += 1;
    57ff:	48 8b 85 68 f1 ff ff 	mov    -0xe98(%rbp),%rax
    5806:	48 8b 48 30          	mov    0x30(%rax),%rcx
    580a:	48 83 c1 01          	add    $0x1,%rcx
    580e:	48 89 48 30          	mov    %rcx,0x30(%rax)
    5812:	eb 00                	jmp    5814 <balancer_ingress+0x5814>
    5814:	eb 00                	jmp    5816 <balancer_ingress+0x5816>
        __u32 key = qpr.server_id;
    5816:	8b 85 68 e9 ff ff    	mov    -0x1698(%rbp),%eax
    581c:	89 85 64 e9 ff ff    	mov    %eax,-0x169c(%rbp)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    5822:	48 c7 85 50 e9 ff ff 	movq   $0x0,-0x16b0(%rbp)
    5829:	00 00 00 00 
    582d:	c7 85 4c e9 ff ff 02 	movl   $0x2,-0x16b4(%rbp)
    5834:	00 00 00 
    5837:	8b 85 64 e9 ff ff    	mov    -0x169c(%rbp),%eax
    583d:	89 85 48 e9 ff ff    	mov    %eax,-0x16b8(%rbp)
    5843:	c7 85 44 e9 ff ff 02 	movl   $0x2,-0x16bc(%rbp)
    584a:	00 00 00 
    584d:	c7 85 40 e9 ff ff 08 	movl   $0x8,-0x16c0(%rbp)
    5854:	00 00 00 
    5857:	83 bd 48 e9 ff ff 02 	cmpl   $0x2,-0x16b8(%rbp)
    585e:	73 21                	jae    5881 <balancer_ingress+0x5881>
    5860:	8b 85 48 e9 ff ff    	mov    -0x16b8(%rbp),%eax
    5866:	89 c1                	mov    %eax,%ecx
    5868:	48 b8 00 c0 27 f4 00 	movabs $0xffffc900f427c000,%rax
    586f:	c9 ff ff 
    5872:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    5879:	00 
    587a:	48 89 85 50 e9 ff ff 	mov    %rax,-0x16b0(%rbp)
    5881:	48 8b 85 50 e9 ff ff 	mov    -0x16b0(%rbp),%rax
    5888:	48 89 85 38 e9 ff ff 	mov    %rax,-0x16c8(%rbp)
    588f:	48 8b 85 38 e9 ff ff 	mov    -0x16c8(%rbp),%rax
    5896:	48 89 85 58 e9 ff ff 	mov    %rax,-0x16a8(%rbp)
        if (real_pos) {
    589d:	48 83 bd 58 e9 ff ff 	cmpq   $0x0,-0x16a8(%rbp)
    58a4:	00 
    58a5:	0f 84 8d 04 00 00    	je     5d38 <balancer_ingress+0x5d38>
          key = *real_pos;
    58ab:	48 8b 85 58 e9 ff ff 	mov    -0x16a8(%rbp),%rax
    58b2:	8b 00                	mov    (%rax),%eax
    58b4:	89 85 64 e9 ff ff    	mov    %eax,-0x169c(%rbp)
          if (key == 0) {
    58ba:	83 bd 64 e9 ff ff 00 	cmpl   $0x0,-0x169c(%rbp)
    58c1:	75 3b                	jne    58fe <balancer_ingress+0x58fe>
            quic_packets_stats->cid_invalid_server_id += 1;
    58c3:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    58ca:	48 8b 48 10          	mov    0x10(%rax),%rcx
    58ce:	48 83 c1 01          	add    $0x1,%rcx
    58d2:	48 89 48 10          	mov    %rcx,0x10(%rax)
            quic_packets_stats->cid_invalid_server_id_sample = qpr.server_id;
    58d6:	48 63 8d 68 e9 ff ff 	movslq -0x1698(%rbp),%rcx
    58dd:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    58e4:	48 89 48 18          	mov    %rcx,0x18(%rax)
            quic_packets_stats->ch_routed += 1;
    58e8:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    58ef:	48 8b 08             	mov    (%rax),%rcx
    58f2:	48 83 c1 01          	add    $0x1,%rcx
    58f6:	48 89 08             	mov    %rcx,(%rax)
          } else {
    58f9:	e9 38 04 00 00       	jmp    5d36 <balancer_ingress+0x5d36>
            pckt.real_index = key;
    58fe:	8b 85 64 e9 ff ff    	mov    -0x169c(%rbp),%eax
    5904:	89 85 08 eb ff ff    	mov    %eax,-0x14f8(%rbp)
            dst = bpf_map_lookup_elem(&reals, &key);
    590a:	48 c7 85 30 e9 ff ff 	movq   $0x0,-0x16d0(%rbp)
    5911:	00 00 00 00 
    5915:	c7 85 2c e9 ff ff 02 	movl   $0x2,-0x16d4(%rbp)
    591c:	00 00 00 
    591f:	8b 85 64 e9 ff ff    	mov    -0x169c(%rbp),%eax
    5925:	89 85 28 e9 ff ff    	mov    %eax,-0x16d8(%rbp)
    592b:	c7 85 24 e9 ff ff 02 	movl   $0x2,-0x16dc(%rbp)
    5932:	00 00 00 
    5935:	c7 85 20 e9 ff ff 08 	movl   $0x8,-0x16e0(%rbp)
    593c:	00 00 00 
    593f:	83 bd 28 e9 ff ff 02 	cmpl   $0x2,-0x16d8(%rbp)
    5946:	73 21                	jae    5969 <balancer_ingress+0x5969>
    5948:	8b 85 28 e9 ff ff    	mov    -0x16d8(%rbp),%eax
    594e:	89 c1                	mov    %eax,%ecx
    5950:	48 b8 00 30 50 52 00 	movabs $0xffffc90052503000,%rax
    5957:	c9 ff ff 
    595a:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    5961:	00 
    5962:	48 89 85 30 e9 ff ff 	mov    %rax,-0x16d0(%rbp)
    5969:	48 8b 85 30 e9 ff ff 	mov    -0x16d0(%rbp),%rax
    5970:	48 89 85 18 e9 ff ff 	mov    %rax,-0x16e8(%rbp)
    5977:	48 8b 85 18 e9 ff ff 	mov    -0x16e8(%rbp),%rax
    597e:	48 89 85 10 eb ff ff 	mov    %rax,-0x14f0(%rbp)
            if (!dst) {
    5985:	48 83 bd 10 eb ff ff 	cmpq   $0x0,-0x14f0(%rbp)
    598c:	00 
    598d:	75 22                	jne    59b1 <balancer_ingress+0x59b1>
              quic_packets_stats->cid_unknown_real_dropped += 1;
    598f:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5996:	48 8b 48 28          	mov    0x28(%rax),%rcx
    599a:	48 83 c1 01          	add    $0x1,%rcx
    599e:	48 89 48 28          	mov    %rcx,0x28(%rax)
              return XDP_DROP;
    59a2:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    59a9:	00 00 00 
    59ac:	e9 a8 1d 00 00       	jmp    7759 <balancer_ingress+0x7759>
            int res = check_and_update_real_index_in_lru(&pckt, lru_map);
    59b1:	48 8b 85 20 ea ff ff 	mov    -0x15e0(%rbp),%rax
    59b8:	48 8d 8d e0 ea ff ff 	lea    -0x1520(%rbp),%rcx
    59bf:	48 89 8d d0 f1 ff ff 	mov    %rcx,-0xe30(%rbp)
    59c6:	48 89 85 c8 f1 ff ff 	mov    %rax,-0xe38(%rbp)
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    59cd:	48 b8 88 7f 00 00 00 	movabs $0x7f88,%rax
    59d4:	00 00 00 
    59d7:	48 8b 00             	mov    (%rax),%rax
    59da:	48 8b bd c8 f1 ff ff 	mov    -0xe38(%rbp),%rdi
    59e1:	48 8b b5 d0 f1 ff ff 	mov    -0xe30(%rbp),%rsi
    59e8:	ff d0                	call   *%rax
    59ea:	48 89 85 c0 f1 ff ff 	mov    %rax,-0xe40(%rbp)
  if (dst_lru) {
    59f1:	48 83 bd c0 f1 ff ff 	cmpq   $0x0,-0xe40(%rbp)
    59f8:	00 
    59f9:	74 46                	je     5a41 <balancer_ingress+0x5a41>
    if (dst_lru->pos == pckt->real_index) {
    59fb:	48 8b 85 c0 f1 ff ff 	mov    -0xe40(%rbp),%rax
    5a02:	8b 00                	mov    (%rax),%eax
    5a04:	48 8b 8d d0 f1 ff ff 	mov    -0xe30(%rbp),%rcx
    5a0b:	3b 41 28             	cmp    0x28(%rcx),%eax
    5a0e:	75 0f                	jne    5a1f <balancer_ingress+0x5a1f>
      return DST_MATCH_IN_LRU;
    5a10:	c7 85 dc f1 ff ff 00 	movl   $0x0,-0xe24(%rbp)
    5a17:	00 00 00 
    5a1a:	e9 c9 01 00 00       	jmp    5be8 <balancer_ingress+0x5be8>
      dst_lru->pos = pckt->real_index;
    5a1f:	48 8b 85 d0 f1 ff ff 	mov    -0xe30(%rbp),%rax
    5a26:	8b 48 28             	mov    0x28(%rax),%ecx
    5a29:	48 8b 85 c0 f1 ff ff 	mov    -0xe40(%rbp),%rax
    5a30:	89 08                	mov    %ecx,(%rax)
      return DST_MISMATCH_IN_LRU;
    5a32:	c7 85 dc f1 ff ff 01 	movl   $0x1,-0xe24(%rbp)
    5a39:	00 00 00 
    5a3c:	e9 a7 01 00 00       	jmp    5be8 <balancer_ingress+0x5be8>
    5a41:	48 8d 85 b8 f1 ff ff 	lea    -0xe48(%rbp),%rax
    5a48:	48 89 85 88 fd ff ff 	mov    %rax,-0x278(%rbp)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    5a4f:	c7 85 84 fd ff ff 02 	movl   $0x202,-0x27c(%rbp)
    5a56:	02 00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    5a59:	48 c7 85 70 fd ff ff 	movq   $0x0,-0x290(%rbp)
    5a60:	00 00 00 00 
    5a64:	c7 85 6c fd ff ff 02 	movl   $0x2,-0x294(%rbp)
    5a6b:	00 00 00 
    5a6e:	8b 85 84 fd ff ff    	mov    -0x27c(%rbp),%eax
    5a74:	89 85 68 fd ff ff    	mov    %eax,-0x298(%rbp)
    5a7a:	c7 85 64 fd ff ff 02 	movl   $0x2,-0x29c(%rbp)
    5a81:	00 00 00 
    5a84:	c7 85 60 fd ff ff 08 	movl   $0x8,-0x2a0(%rbp)
    5a8b:	00 00 00 
    5a8e:	83 bd 68 fd ff ff 02 	cmpl   $0x2,-0x298(%rbp)
    5a95:	73 21                	jae    5ab8 <balancer_ingress+0x5ab8>
    5a97:	8b 85 68 fd ff ff    	mov    -0x298(%rbp),%eax
    5a9d:	89 c1                	mov    %eax,%ecx
    5a9f:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    5aa6:	88 ff ff 
    5aa9:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    5ab0:	00 
    5ab1:	48 89 85 70 fd ff ff 	mov    %rax,-0x290(%rbp)
    5ab8:	48 8b 85 70 fd ff ff 	mov    -0x290(%rbp),%rax
    5abf:	48 89 85 58 fd ff ff 	mov    %rax,-0x2a8(%rbp)
    5ac6:	48 8b 85 58 fd ff ff 	mov    -0x2a8(%rbp),%rax
  struct lb_stats* conn_rate_stats =
    5acd:	48 89 85 78 fd ff ff 	mov    %rax,-0x288(%rbp)
  if (!conn_rate_stats) {
    5ad4:	48 83 bd 78 fd ff ff 	cmpq   $0x0,-0x288(%rbp)
    5adb:	00 
    5adc:	75 0c                	jne    5aea <balancer_ingress+0x5aea>
    return true;
    5ade:	c6 85 97 fd ff ff 01 	movb   $0x1,-0x269(%rbp)
    5ae5:	e9 91 00 00 00       	jmp    5b7b <balancer_ingress+0x5b7b>
  *cur_time = bpf_ktime_get_ns();
    5aea:	48 b8 98 7f 00 00 00 	movabs $0x7f98,%rax
    5af1:	00 00 00 
    5af4:	48 8b 00             	mov    (%rax),%rax
    5af7:	ff d0                	call   *%rax
    5af9:	48 89 c1             	mov    %rax,%rcx
    5afc:	48 8b 85 88 fd ff ff 	mov    -0x278(%rbp),%rax
    5b03:	48 89 08             	mov    %rcx,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    5b06:	48 8b 85 88 fd ff ff 	mov    -0x278(%rbp),%rax
    5b0d:	48 8b 00             	mov    (%rax),%rax
    5b10:	48 8b 8d 78 fd ff ff 	mov    -0x288(%rbp),%rcx
    5b17:	48 2b 41 08          	sub    0x8(%rcx),%rax
    5b1b:	48 3d 00 ca 9a 3b    	cmp    $0x3b9aca00,%rax
    5b21:	76 25                	jbe    5b48 <balancer_ingress+0x5b48>
    conn_rate_stats->v1 = 1;
    5b23:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
    5b2a:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    conn_rate_stats->v2 = *cur_time;
    5b31:	48 8b 85 88 fd ff ff 	mov    -0x278(%rbp),%rax
    5b38:	48 8b 08             	mov    (%rax),%rcx
    5b3b:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
    5b42:	48 89 48 08          	mov    %rcx,0x8(%rax)
  } else {
    5b46:	eb 2c                	jmp    5b74 <balancer_ingress+0x5b74>
    conn_rate_stats->v1 += 1;
    5b48:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
    5b4f:	48 8b 08             	mov    (%rax),%rcx
    5b52:	48 83 c1 01          	add    $0x1,%rcx
    5b56:	48 89 08             	mov    %rcx,(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    5b59:	48 8b 85 78 fd ff ff 	mov    -0x288(%rbp),%rax
    5b60:	48 81 38 48 e8 01 00 	cmpq   $0x1e848,(%rax)
    5b67:	76 09                	jbe    5b72 <balancer_ingress+0x5b72>
      return true;
    5b69:	c6 85 97 fd ff ff 01 	movb   $0x1,-0x269(%rbp)
    5b70:	eb 09                	jmp    5b7b <balancer_ingress+0x5b7b>
    5b72:	eb 00                	jmp    5b74 <balancer_ingress+0x5b74>
  return false;
    5b74:	c6 85 97 fd ff ff 00 	movb   $0x0,-0x269(%rbp)
  if (is_under_flood(&cur_time)) {
    5b7b:	f6 85 97 fd ff ff 01 	testb  $0x1,-0x269(%rbp)
    5b82:	75 02                	jne    5b86 <balancer_ingress+0x5b86>
    5b84:	eb 0c                	jmp    5b92 <balancer_ingress+0x5b92>
    return DST_NOT_FOUND_IN_LRU;
    5b86:	c7 85 dc f1 ff ff 02 	movl   $0x2,-0xe24(%rbp)
    5b8d:	00 00 00 
    5b90:	eb 56                	jmp    5be8 <balancer_ingress+0x5be8>
  struct real_pos_lru new_dst_lru = {};
    5b92:	48 c7 85 b0 f1 ff ff 	movq   $0x0,-0xe50(%rbp)
    5b99:	00 00 00 00 
    5b9d:	48 c7 85 a8 f1 ff ff 	movq   $0x0,-0xe58(%rbp)
    5ba4:	00 00 00 00 
  new_dst_lru.pos = pckt->real_index;
    5ba8:	48 8b 85 d0 f1 ff ff 	mov    -0xe30(%rbp),%rax
    5baf:	8b 40 28             	mov    0x28(%rax),%eax
    5bb2:	89 85 a8 f1 ff ff    	mov    %eax,-0xe58(%rbp)
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    5bb8:	48 b8 90 7f 00 00 00 	movabs $0x7f90,%rax
    5bbf:	00 00 00 
    5bc2:	48 8b 00             	mov    (%rax),%rax
    5bc5:	48 8b bd c8 f1 ff ff 	mov    -0xe38(%rbp),%rdi
    5bcc:	48 8b b5 d0 f1 ff ff 	mov    -0xe30(%rbp),%rsi
    5bd3:	48 8d 95 a8 f1 ff ff 	lea    -0xe58(%rbp),%rdx
    5bda:	31 c9                	xor    %ecx,%ecx
    5bdc:	ff d0                	call   *%rax
  return DST_NOT_FOUND_IN_LRU;
    5bde:	c7 85 dc f1 ff ff 02 	movl   $0x2,-0xe24(%rbp)
    5be5:	00 00 00 
}
    5be8:	8b 85 dc f1 ff ff    	mov    -0xe24(%rbp),%eax
            int res = check_and_update_real_index_in_lru(&pckt, lru_map);
    5bee:	89 85 14 e9 ff ff    	mov    %eax,-0x16ec(%rbp)
            if (res == DST_MATCH_IN_LRU) {
    5bf4:	83 bd 14 e9 ff ff 00 	cmpl   $0x0,-0x16ec(%rbp)
    5bfb:	75 18                	jne    5c15 <balancer_ingress+0x5c15>
              quic_packets_stats->dst_match_in_lru += 1;
    5bfd:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5c04:	48 8b 48 50          	mov    0x50(%rax),%rcx
    5c08:	48 83 c1 01          	add    $0x1,%rcx
    5c0c:	48 89 48 50          	mov    %rcx,0x50(%rax)
            } else if (res == DST_MISMATCH_IN_LRU) {
    5c10:	e9 0e 01 00 00       	jmp    5d23 <balancer_ingress+0x5d23>
    5c15:	83 bd 14 e9 ff ff 01 	cmpl   $0x1,-0x16ec(%rbp)
    5c1c:	0f 85 ec 00 00 00    	jne    5d0e <balancer_ingress+0x5d0e>
              quic_packets_stats->dst_mismatch_in_lru += 1;
    5c22:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5c29:	48 8b 48 58          	mov    0x58(%rax),%rcx
    5c2d:	48 83 c1 01          	add    $0x1,%rcx
    5c31:	48 89 48 58          	mov    %rcx,0x58(%rax)
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    5c35:	8b 85 ac ea ff ff    	mov    -0x1554(%rbp),%eax
    5c3b:	89 85 6c f2 ff ff    	mov    %eax,-0xd94(%rbp)
    5c41:	c6 85 6b f2 ff ff 00 	movb   $0x0,-0xd95(%rbp)
    5c48:	c6 85 6a f2 ff ff 01 	movb   $0x1,-0xd96(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    5c4f:	48 c7 85 58 f2 ff ff 	movq   $0x0,-0xda8(%rbp)
    5c56:	00 00 00 00 
    5c5a:	c7 85 54 f2 ff ff 02 	movl   $0x2,-0xdac(%rbp)
    5c61:	00 00 00 
    5c64:	8b 85 6c f2 ff ff    	mov    -0xd94(%rbp),%eax
    5c6a:	89 85 50 f2 ff ff    	mov    %eax,-0xdb0(%rbp)
    5c70:	c7 85 4c f2 ff ff 02 	movl   $0x2,-0xdb4(%rbp)
    5c77:	00 00 00 
    5c7a:	c7 85 48 f2 ff ff 08 	movl   $0x8,-0xdb8(%rbp)
    5c81:	00 00 00 
    5c84:	83 bd 50 f2 ff ff 02 	cmpl   $0x2,-0xdb0(%rbp)
    5c8b:	73 21                	jae    5cae <balancer_ingress+0x5cae>
    5c8d:	8b 85 50 f2 ff ff    	mov    -0xdb0(%rbp),%eax
    5c93:	89 c1                	mov    %eax,%ecx
    5c95:	48 b8 00 80 b4 1f 81 	movabs $0xffff88811fb48000,%rax
    5c9c:	88 ff ff 
    5c9f:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    5ca6:	00 
    5ca7:	48 89 85 58 f2 ff ff 	mov    %rax,-0xda8(%rbp)
    5cae:	48 8b 85 58 f2 ff ff 	mov    -0xda8(%rbp),%rax
    5cb5:	48 89 85 40 f2 ff ff 	mov    %rax,-0xdc0(%rbp)
    5cbc:	48 8b 85 40 f2 ff ff 	mov    -0xdc0(%rbp),%rax
  struct lb_stats* per_vip_stats =
    5cc3:	48 89 85 60 f2 ff ff 	mov    %rax,-0xda0(%rbp)
  if (!per_vip_stats) {
    5cca:	48 83 bd 60 f2 ff ff 	cmpq   $0x0,-0xda0(%rbp)
    5cd1:	00 
    5cd2:	75 02                	jne    5cd6 <balancer_ingress+0x5cd6>
    return;
    5cd4:	eb 36                	jmp    5d0c <balancer_ingress+0x5d0c>
  if (newConn) {
    5cd6:	f6 85 6b f2 ff ff 01 	testb  $0x1,-0xd95(%rbp)
    5cdd:	74 11                	je     5cf0 <balancer_ingress+0x5cf0>
    per_vip_stats->v1 += 1;
    5cdf:	48 8b 85 60 f2 ff ff 	mov    -0xda0(%rbp),%rax
    5ce6:	48 8b 08             	mov    (%rax),%rcx
    5ce9:	48 83 c1 01          	add    $0x1,%rcx
    5ced:	48 89 08             	mov    %rcx,(%rax)
  if (misMatchInLRU) {
    5cf0:	f6 85 6a f2 ff ff 01 	testb  $0x1,-0xd96(%rbp)
    5cf7:	74 13                	je     5d0c <balancer_ingress+0x5d0c>
    per_vip_stats->v2 += 1;
    5cf9:	48 8b 85 60 f2 ff ff 	mov    -0xda0(%rbp),%rax
    5d00:	48 8b 48 08          	mov    0x8(%rax),%rcx
    5d04:	48 83 c1 01          	add    $0x1,%rcx
    5d08:	48 89 48 08          	mov    %rcx,0x8(%rax)
            } else {
    5d0c:	eb 13                	jmp    5d21 <balancer_ingress+0x5d21>
              quic_packets_stats->dst_not_found_in_lru += 1;
    5d0e:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5d15:	48 8b 48 60          	mov    0x60(%rax),%rcx
    5d19:	48 83 c1 01          	add    $0x1,%rcx
    5d1d:	48 89 48 60          	mov    %rcx,0x60(%rax)
    5d21:	eb 00                	jmp    5d23 <balancer_ingress+0x5d23>
            quic_packets_stats->cid_routed += 1;
    5d23:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5d2a:	48 8b 48 20          	mov    0x20(%rax),%rcx
    5d2e:	48 83 c1 01          	add    $0x1,%rcx
    5d32:	48 89 48 20          	mov    %rcx,0x20(%rax)
        } else {
    5d36:	eb 36                	jmp    5d6e <balancer_ingress+0x5d6e>
          quic_packets_stats->cid_invalid_server_id += 1;
    5d38:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5d3f:	48 8b 48 10          	mov    0x10(%rax),%rcx
    5d43:	48 83 c1 01          	add    $0x1,%rcx
    5d47:	48 89 48 10          	mov    %rcx,0x10(%rax)
          quic_packets_stats->cid_invalid_server_id_sample = qpr.server_id;
    5d4b:	48 63 8d 68 e9 ff ff 	movslq -0x1698(%rbp),%rcx
    5d52:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5d59:	48 89 48 18          	mov    %rcx,0x18(%rax)
          quic_packets_stats->ch_routed += 1;
    5d5d:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5d64:	48 8b 08             	mov    (%rax),%rcx
    5d67:	48 83 c1 01          	add    $0x1,%rcx
    5d6b:	48 89 08             	mov    %rcx,(%rax)
      } else if (!qpr.is_initial) {
    5d6e:	e9 0d 01 00 00       	jmp    5e80 <balancer_ingress+0x5e80>
    5d73:	f6 85 6d e9 ff ff 01 	testb  $0x1,-0x1693(%rbp)
    5d7a:	75 16                	jne    5d92 <balancer_ingress+0x5d92>
        quic_packets_stats->ch_routed += 1;
    5d7c:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5d83:	48 8b 08             	mov    (%rax),%rcx
    5d86:	48 83 c1 01          	add    $0x1,%rcx
    5d8a:	48 89 08             	mov    %rcx,(%rax)
      } else {
    5d8d:	e9 ec 00 00 00       	jmp    5e7e <balancer_ingress+0x5e7e>
        quic_packets_stats->cid_initial += 1;
    5d92:	48 8b 85 90 e9 ff ff 	mov    -0x1670(%rbp),%rax
    5d99:	48 8b 48 08          	mov    0x8(%rax),%rcx
    5d9d:	48 83 c1 01          	add    $0x1,%rcx
    5da1:	48 89 48 08          	mov    %rcx,0x8(%rax)
            vip_num, /* new conn */ true, /* mismatch in lru */ false);
    5da5:	8b 85 ac ea ff ff    	mov    -0x1554(%rbp),%eax
    5dab:	89 85 9c f2 ff ff    	mov    %eax,-0xd64(%rbp)
    5db1:	c6 85 9b f2 ff ff 01 	movb   $0x1,-0xd65(%rbp)
    5db8:	c6 85 9a f2 ff ff 00 	movb   $0x0,-0xd66(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    5dbf:	48 c7 85 88 f2 ff ff 	movq   $0x0,-0xd78(%rbp)
    5dc6:	00 00 00 00 
    5dca:	c7 85 84 f2 ff ff 02 	movl   $0x2,-0xd7c(%rbp)
    5dd1:	00 00 00 
    5dd4:	8b 85 9c f2 ff ff    	mov    -0xd64(%rbp),%eax
    5dda:	89 85 80 f2 ff ff    	mov    %eax,-0xd80(%rbp)
    5de0:	c7 85 7c f2 ff ff 02 	movl   $0x2,-0xd84(%rbp)
    5de7:	00 00 00 
    5dea:	c7 85 78 f2 ff ff 08 	movl   $0x8,-0xd88(%rbp)
    5df1:	00 00 00 
    5df4:	83 bd 80 f2 ff ff 02 	cmpl   $0x2,-0xd80(%rbp)
    5dfb:	73 21                	jae    5e1e <balancer_ingress+0x5e1e>
    5dfd:	8b 85 80 f2 ff ff    	mov    -0xd80(%rbp),%eax
    5e03:	89 c1                	mov    %eax,%ecx
    5e05:	48 b8 00 80 b4 1f 81 	movabs $0xffff88811fb48000,%rax
    5e0c:	88 ff ff 
    5e0f:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    5e16:	00 
    5e17:	48 89 85 88 f2 ff ff 	mov    %rax,-0xd78(%rbp)
    5e1e:	48 8b 85 88 f2 ff ff 	mov    -0xd78(%rbp),%rax
    5e25:	48 89 85 70 f2 ff ff 	mov    %rax,-0xd90(%rbp)
    5e2c:	48 8b 85 70 f2 ff ff 	mov    -0xd90(%rbp),%rax
  struct lb_stats* per_vip_stats =
    5e33:	48 89 85 90 f2 ff ff 	mov    %rax,-0xd70(%rbp)
  if (!per_vip_stats) {
    5e3a:	48 83 bd 90 f2 ff ff 	cmpq   $0x0,-0xd70(%rbp)
    5e41:	00 
    5e42:	75 02                	jne    5e46 <balancer_ingress+0x5e46>
    return;
    5e44:	eb 36                	jmp    5e7c <balancer_ingress+0x5e7c>
  if (newConn) {
    5e46:	f6 85 9b f2 ff ff 01 	testb  $0x1,-0xd65(%rbp)
    5e4d:	74 11                	je     5e60 <balancer_ingress+0x5e60>
    per_vip_stats->v1 += 1;
    5e4f:	48 8b 85 90 f2 ff ff 	mov    -0xd70(%rbp),%rax
    5e56:	48 8b 08             	mov    (%rax),%rcx
    5e59:	48 83 c1 01          	add    $0x1,%rcx
    5e5d:	48 89 08             	mov    %rcx,(%rax)
  if (misMatchInLRU) {
    5e60:	f6 85 9a f2 ff ff 01 	testb  $0x1,-0xd66(%rbp)
    5e67:	74 13                	je     5e7c <balancer_ingress+0x5e7c>
    per_vip_stats->v2 += 1;
    5e69:	48 8b 85 90 f2 ff ff 	mov    -0xd70(%rbp),%rax
    5e70:	48 8b 48 08          	mov    0x8(%rax),%rcx
    5e74:	48 83 c1 01          	add    $0x1,%rcx
    5e78:	48 89 48 08          	mov    %rcx,0x8(%rax)
    5e7c:	eb 00                	jmp    5e7e <balancer_ingress+0x5e7e>
    5e7e:	eb 00                	jmp    5e80 <balancer_ingress+0x5e80>
    5e80:	eb 00                	jmp    5e82 <balancer_ingress+0x5e82>
  }
    5e82:	eb 00                	jmp    5e84 <balancer_ingress+0x5e84>
  original_sport = pckt.flow.port16[0];
    5e84:	66 8b 85 00 eb ff ff 	mov    -0x1500(%rbp),%ax
    5e8b:	66 89 85 b4 ea ff ff 	mov    %ax,-0x154c(%rbp)
  if (!dst) {
    5e92:	48 83 bd 10 eb ff ff 	cmpq   $0x0,-0x14f0(%rbp)
    5e99:	00 
    5e9a:	0f 85 b8 0e 00 00    	jne    6d58 <balancer_ingress+0x6d58>
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    5ea0:	48 83 bd 10 eb ff ff 	cmpq   $0x0,-0x14f0(%rbp)
    5ea7:	00 
    5ea8:	0f 85 92 01 00 00    	jne    6040 <balancer_ingress+0x6040>
    5eae:	0f b6 85 0c eb ff ff 	movzbl -0x14f4(%rbp),%eax
    5eb5:	83 e0 02             	and    $0x2,%eax
    5eb8:	83 f8 00             	cmp    $0x0,%eax
    5ebb:	0f 85 7f 01 00 00    	jne    6040 <balancer_ingress+0x6040>
        !(vip_info->flags & F_LRU_BYPASS)) {
    5ec1:	48 8b 85 c0 ea ff ff 	mov    -0x1540(%rbp),%rax
    5ec8:	8b 00                	mov    (%rax),%eax
    5eca:	83 e0 02             	and    $0x2,%eax
    5ecd:	83 f8 00             	cmp    $0x0,%eax
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    5ed0:	0f 85 6a 01 00 00    	jne    6040 <balancer_ingress+0x6040>
      connection_table_lookup(&dst, &pckt, lru_map, /*isGlobalLru=*/false);
    5ed6:	48 8b 85 20 ea ff ff 	mov    -0x15e0(%rbp),%rax
    5edd:	48 8d 8d 10 eb ff ff 	lea    -0x14f0(%rbp),%rcx
    5ee4:	48 89 8d 48 f3 ff ff 	mov    %rcx,-0xcb8(%rbp)
    5eeb:	48 8d 8d e0 ea ff ff 	lea    -0x1520(%rbp),%rcx
    5ef2:	48 89 8d 40 f3 ff ff 	mov    %rcx,-0xcc0(%rbp)
    5ef9:	48 89 85 38 f3 ff ff 	mov    %rax,-0xcc8(%rbp)
    5f00:	c6 85 37 f3 ff ff 00 	movb   $0x0,-0xcc9(%rbp)
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    5f07:	48 b8 88 7f 00 00 00 	movabs $0x7f88,%rax
    5f0e:	00 00 00 
    5f11:	48 8b 00             	mov    (%rax),%rax
    5f14:	48 8b bd 38 f3 ff ff 	mov    -0xcc8(%rbp),%rdi
    5f1b:	48 8b b5 40 f3 ff ff 	mov    -0xcc0(%rbp),%rsi
    5f22:	ff d0                	call   *%rax
    5f24:	48 89 85 28 f3 ff ff 	mov    %rax,-0xcd8(%rbp)
  if (!dst_lru) {
    5f2b:	48 83 bd 28 f3 ff ff 	cmpq   $0x0,-0xcd8(%rbp)
    5f32:	00 
    5f33:	75 05                	jne    5f3a <balancer_ingress+0x5f3a>
    return;
    5f35:	e9 04 01 00 00       	jmp    603e <balancer_ingress+0x603e>
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    5f3a:	f6 85 37 f3 ff ff 01 	testb  $0x1,-0xcc9(%rbp)
    5f41:	75 5e                	jne    5fa1 <balancer_ingress+0x5fa1>
    5f43:	48 8b 85 40 f3 ff ff 	mov    -0xcc0(%rbp),%rax
    5f4a:	0f b6 40 24          	movzbl 0x24(%rax),%eax
    5f4e:	83 f8 11             	cmp    $0x11,%eax
    5f51:	75 4e                	jne    5fa1 <balancer_ingress+0x5fa1>
    cur_time = bpf_ktime_get_ns();
    5f53:	48 b8 98 7f 00 00 00 	movabs $0x7f98,%rax
    5f5a:	00 00 00 
    5f5d:	48 8b 00             	mov    (%rax),%rax
    5f60:	ff d0                	call   *%rax
    5f62:	48 89 85 20 f3 ff ff 	mov    %rax,-0xce0(%rbp)
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    5f69:	48 8b 85 20 f3 ff ff 	mov    -0xce0(%rbp),%rax
    5f70:	48 8b 8d 28 f3 ff ff 	mov    -0xcd8(%rbp),%rcx
    5f77:	48 2b 41 08          	sub    0x8(%rcx),%rax
    5f7b:	48 b9 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rcx
    5f82:	00 00 00 
    5f85:	48 39 c8             	cmp    %rcx,%rax
    5f88:	76 05                	jbe    5f8f <balancer_ingress+0x5f8f>
      return;
    5f8a:	e9 af 00 00 00       	jmp    603e <balancer_ingress+0x603e>
    dst_lru->atime = cur_time;
    5f8f:	48 8b 8d 20 f3 ff ff 	mov    -0xce0(%rbp),%rcx
    5f96:	48 8b 85 28 f3 ff ff 	mov    -0xcd8(%rbp),%rax
    5f9d:	48 89 48 08          	mov    %rcx,0x8(%rax)
  key = dst_lru->pos;
    5fa1:	48 8b 85 28 f3 ff ff 	mov    -0xcd8(%rbp),%rax
    5fa8:	8b 00                	mov    (%rax),%eax
    5faa:	89 85 1c f3 ff ff    	mov    %eax,-0xce4(%rbp)
  pckt->real_index = key;
    5fb0:	8b 8d 1c f3 ff ff    	mov    -0xce4(%rbp),%ecx
    5fb6:	48 8b 85 40 f3 ff ff 	mov    -0xcc0(%rbp),%rax
    5fbd:	89 48 28             	mov    %ecx,0x28(%rax)
  *real = bpf_map_lookup_elem(&reals, &key);
    5fc0:	48 c7 85 10 f3 ff ff 	movq   $0x0,-0xcf0(%rbp)
    5fc7:	00 00 00 00 
    5fcb:	c7 85 0c f3 ff ff 02 	movl   $0x2,-0xcf4(%rbp)
    5fd2:	00 00 00 
    5fd5:	8b 85 1c f3 ff ff    	mov    -0xce4(%rbp),%eax
    5fdb:	89 85 08 f3 ff ff    	mov    %eax,-0xcf8(%rbp)
    5fe1:	c7 85 04 f3 ff ff 02 	movl   $0x2,-0xcfc(%rbp)
    5fe8:	00 00 00 
    5feb:	c7 85 00 f3 ff ff 08 	movl   $0x8,-0xd00(%rbp)
    5ff2:	00 00 00 
    5ff5:	83 bd 08 f3 ff ff 02 	cmpl   $0x2,-0xcf8(%rbp)
    5ffc:	73 21                	jae    601f <balancer_ingress+0x601f>
    5ffe:	8b 85 08 f3 ff ff    	mov    -0xcf8(%rbp),%eax
    6004:	89 c1                	mov    %eax,%ecx
    6006:	48 b8 00 30 50 52 00 	movabs $0xffffc90052503000,%rax
    600d:	c9 ff ff 
    6010:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6017:	00 
    6018:	48 89 85 10 f3 ff ff 	mov    %rax,-0xcf0(%rbp)
    601f:	48 8b 85 10 f3 ff ff 	mov    -0xcf0(%rbp),%rax
    6026:	48 89 85 f8 f2 ff ff 	mov    %rax,-0xd08(%rbp)
    602d:	48 8b 8d f8 f2 ff ff 	mov    -0xd08(%rbp),%rcx
    6034:	48 8b 85 48 f3 ff ff 	mov    -0xcb8(%rbp),%rax
    603b:	48 89 08             	mov    %rcx,(%rax)
    }
    603e:	eb 00                	jmp    6040 <balancer_ingress+0x6040>
    check_udp_flow_migration(&dst, &pckt, vip_info, &vip);
    6040:	48 8b 85 c0 ea ff ff 	mov    -0x1540(%rbp),%rax
    6047:	48 8d 8d 10 eb ff ff 	lea    -0x14f0(%rbp),%rcx
    604e:	48 89 8d 58 f4 ff ff 	mov    %rcx,-0xba8(%rbp)
    6055:	48 8d 8d e0 ea ff ff 	lea    -0x1520(%rbp),%rcx
    605c:	48 89 8d 50 f4 ff ff 	mov    %rcx,-0xbb0(%rbp)
    6063:	48 89 85 48 f4 ff ff 	mov    %rax,-0xbb8(%rbp)
    606a:	48 8d 85 c8 ea ff ff 	lea    -0x1538(%rbp),%rax
    6071:	48 89 85 40 f4 ff ff 	mov    %rax,-0xbc0(%rbp)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    6078:	48 83 bd 58 f4 ff ff 	cmpq   $0x0,-0xba8(%rbp)
    607f:	00 
    6080:	0f 84 e8 02 00 00    	je     636e <balancer_ingress+0x636e>
    6086:	48 8b 85 50 f4 ff ff 	mov    -0xbb0(%rbp),%rax
    608d:	0f b6 40 24          	movzbl 0x24(%rax),%eax
    6091:	83 f8 11             	cmp    $0x11,%eax
    6094:	0f 85 d4 02 00 00    	jne    636e <balancer_ingress+0x636e>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    609a:	48 8b 85 48 f4 ff ff 	mov    -0xbb8(%rbp),%rax
    60a1:	8b 00                	mov    (%rax),%eax
    60a3:	25 00 02 00 00       	and    $0x200,%eax
    60a8:	83 f8 00             	cmp    $0x0,%eax
    60ab:	0f 84 bd 02 00 00    	je     636e <balancer_ingress+0x636e>
    60b1:	48 8d 85 38 f4 ff ff 	lea    -0xbc8(%rbp),%rax
    60b8:	48 89 85 08 fd ff ff 	mov    %rax,-0x2f8(%rbp)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    60bf:	c7 85 04 fd ff ff 02 	movl   $0x202,-0x2fc(%rbp)
    60c6:	02 00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    60c9:	48 c7 85 f0 fc ff ff 	movq   $0x0,-0x310(%rbp)
    60d0:	00 00 00 00 
    60d4:	c7 85 ec fc ff ff 02 	movl   $0x2,-0x314(%rbp)
    60db:	00 00 00 
    60de:	8b 85 04 fd ff ff    	mov    -0x2fc(%rbp),%eax
    60e4:	89 85 e8 fc ff ff    	mov    %eax,-0x318(%rbp)
    60ea:	c7 85 e4 fc ff ff 02 	movl   $0x2,-0x31c(%rbp)
    60f1:	00 00 00 
    60f4:	c7 85 e0 fc ff ff 08 	movl   $0x8,-0x320(%rbp)
    60fb:	00 00 00 
    60fe:	83 bd e8 fc ff ff 02 	cmpl   $0x2,-0x318(%rbp)
    6105:	73 21                	jae    6128 <balancer_ingress+0x6128>
    6107:	8b 85 e8 fc ff ff    	mov    -0x318(%rbp),%eax
    610d:	89 c1                	mov    %eax,%ecx
    610f:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    6116:	88 ff ff 
    6119:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6120:	00 
    6121:	48 89 85 f0 fc ff ff 	mov    %rax,-0x310(%rbp)
    6128:	48 8b 85 f0 fc ff ff 	mov    -0x310(%rbp),%rax
    612f:	48 89 85 d8 fc ff ff 	mov    %rax,-0x328(%rbp)
    6136:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  struct lb_stats* conn_rate_stats =
    613d:	48 89 85 f8 fc ff ff 	mov    %rax,-0x308(%rbp)
  if (!conn_rate_stats) {
    6144:	48 83 bd f8 fc ff ff 	cmpq   $0x0,-0x308(%rbp)
    614b:	00 
    614c:	75 0c                	jne    615a <balancer_ingress+0x615a>
    return true;
    614e:	c6 85 17 fd ff ff 01 	movb   $0x1,-0x2e9(%rbp)
    6155:	e9 91 00 00 00       	jmp    61eb <balancer_ingress+0x61eb>
  *cur_time = bpf_ktime_get_ns();
    615a:	48 b8 98 7f 00 00 00 	movabs $0x7f98,%rax
    6161:	00 00 00 
    6164:	48 8b 00             	mov    (%rax),%rax
    6167:	ff d0                	call   *%rax
    6169:	48 89 c1             	mov    %rax,%rcx
    616c:	48 8b 85 08 fd ff ff 	mov    -0x2f8(%rbp),%rax
    6173:	48 89 08             	mov    %rcx,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    6176:	48 8b 85 08 fd ff ff 	mov    -0x2f8(%rbp),%rax
    617d:	48 8b 00             	mov    (%rax),%rax
    6180:	48 8b 8d f8 fc ff ff 	mov    -0x308(%rbp),%rcx
    6187:	48 2b 41 08          	sub    0x8(%rcx),%rax
    618b:	48 3d 00 ca 9a 3b    	cmp    $0x3b9aca00,%rax
    6191:	76 25                	jbe    61b8 <balancer_ingress+0x61b8>
    conn_rate_stats->v1 = 1;
    6193:	48 8b 85 f8 fc ff ff 	mov    -0x308(%rbp),%rax
    619a:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    conn_rate_stats->v2 = *cur_time;
    61a1:	48 8b 85 08 fd ff ff 	mov    -0x2f8(%rbp),%rax
    61a8:	48 8b 08             	mov    (%rax),%rcx
    61ab:	48 8b 85 f8 fc ff ff 	mov    -0x308(%rbp),%rax
    61b2:	48 89 48 08          	mov    %rcx,0x8(%rax)
  } else {
    61b6:	eb 2c                	jmp    61e4 <balancer_ingress+0x61e4>
    conn_rate_stats->v1 += 1;
    61b8:	48 8b 85 f8 fc ff ff 	mov    -0x308(%rbp),%rax
    61bf:	48 8b 08             	mov    (%rax),%rcx
    61c2:	48 83 c1 01          	add    $0x1,%rcx
    61c6:	48 89 08             	mov    %rcx,(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    61c9:	48 8b 85 f8 fc ff ff 	mov    -0x308(%rbp),%rax
    61d0:	48 81 38 48 e8 01 00 	cmpq   $0x1e848,(%rax)
    61d7:	76 09                	jbe    61e2 <balancer_ingress+0x61e2>
      return true;
    61d9:	c6 85 17 fd ff ff 01 	movb   $0x1,-0x2e9(%rbp)
    61e0:	eb 09                	jmp    61eb <balancer_ingress+0x61eb>
    61e2:	eb 00                	jmp    61e4 <balancer_ingress+0x61e4>
  return false;
    61e4:	c6 85 17 fd ff ff 00 	movb   $0x0,-0x2e9(%rbp)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    61eb:	f6 85 17 fd ff ff 01 	testb  $0x1,-0x2e9(%rbp)
    61f2:	0f 85 76 01 00 00    	jne    636e <balancer_ingress+0x636e>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    61f8:	48 c7 85 28 f4 ff ff 	movq   $0x0,-0xbd8(%rbp)
    61ff:	00 00 00 00 
    6203:	c7 85 24 f4 ff ff 02 	movl   $0x2,-0xbdc(%rbp)
    620a:	00 00 00 
    620d:	48 8b 85 40 f4 ff ff 	mov    -0xbc0(%rbp),%rax
    6214:	8b 00                	mov    (%rax),%eax
    6216:	89 85 20 f4 ff ff    	mov    %eax,-0xbe0(%rbp)
    621c:	c7 85 1c f4 ff ff 02 	movl   $0x2,-0xbe4(%rbp)
    6223:	00 00 00 
    6226:	c7 85 18 f4 ff ff 08 	movl   $0x8,-0xbe8(%rbp)
    622d:	00 00 00 
    6230:	83 bd 20 f4 ff ff 02 	cmpl   $0x2,-0xbe0(%rbp)
    6237:	73 21                	jae    625a <balancer_ingress+0x625a>
    6239:	8b 85 20 f4 ff ff    	mov    -0xbe0(%rbp),%eax
    623f:	89 c1                	mov    %eax,%ecx
    6241:	48 b8 00 20 11 3a 81 	movabs $0xffff88813a112000,%rax
    6248:	88 ff ff 
    624b:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6252:	00 
    6253:	48 89 85 28 f4 ff ff 	mov    %rax,-0xbd8(%rbp)
    625a:	48 8b 85 28 f4 ff ff 	mov    -0xbd8(%rbp),%rax
    6261:	48 89 85 10 f4 ff ff 	mov    %rax,-0xbf0(%rbp)
    6268:	48 8b 85 10 f4 ff ff 	mov    -0xbf0(%rbp),%rax
    626f:	48 89 85 30 f4 ff ff 	mov    %rax,-0xbd0(%rbp)
    if (down_reals_map) {
    6276:	48 83 bd 30 f4 ff ff 	cmpq   $0x0,-0xbd0(%rbp)
    627d:	00 
    627e:	0f 84 e8 00 00 00    	je     636c <balancer_ingress+0x636c>
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    6284:	48 b8 88 7f 00 00 00 	movabs $0x7f88,%rax
    628b:	00 00 00 
    628e:	48 8b 00             	mov    (%rax),%rax
    6291:	48 8b bd 30 f4 ff ff 	mov    -0xbd0(%rbp),%rdi
    6298:	48 8b b5 50 f4 ff ff 	mov    -0xbb0(%rbp),%rsi
    629f:	48 83 c6 28          	add    $0x28,%rsi
    62a3:	ff d0                	call   *%rax
    62a5:	48 89 85 08 f4 ff ff 	mov    %rax,-0xbf8(%rbp)
      if (down_real) {
    62ac:	48 83 bd 08 f4 ff ff 	cmpq   $0x0,-0xbf8(%rbp)
    62b3:	00 
    62b4:	0f 84 b0 00 00 00    	je     636a <balancer_ingress+0x636a>
        *dst = NULL;
    62ba:	48 8b 85 58 f4 ff ff 	mov    -0xba8(%rbp),%rax
    62c1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
    62c8:	c7 85 04 f4 ff ff 0f 	movl   $0x20f,-0xbfc(%rbp)
    62cf:	02 00 00 
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    62d2:	48 c7 85 f0 f3 ff ff 	movq   $0x0,-0xc10(%rbp)
    62d9:	00 00 00 00 
    62dd:	c7 85 ec f3 ff ff 02 	movl   $0x2,-0xc14(%rbp)
    62e4:	00 00 00 
    62e7:	8b 85 04 f4 ff ff    	mov    -0xbfc(%rbp),%eax
    62ed:	89 85 e8 f3 ff ff    	mov    %eax,-0xc18(%rbp)
    62f3:	c7 85 e4 f3 ff ff 02 	movl   $0x2,-0xc1c(%rbp)
    62fa:	00 00 00 
    62fd:	c7 85 e0 f3 ff ff 08 	movl   $0x8,-0xc20(%rbp)
    6304:	00 00 00 
    6307:	83 bd e8 f3 ff ff 02 	cmpl   $0x2,-0xc18(%rbp)
    630e:	73 21                	jae    6331 <balancer_ingress+0x6331>
    6310:	8b 85 e8 f3 ff ff    	mov    -0xc18(%rbp),%eax
    6316:	89 c1                	mov    %eax,%ecx
    6318:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    631f:	88 ff ff 
    6322:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6329:	00 
    632a:	48 89 85 f0 f3 ff ff 	mov    %rax,-0xc10(%rbp)
    6331:	48 8b 85 f0 f3 ff ff 	mov    -0xc10(%rbp),%rax
    6338:	48 89 85 d8 f3 ff ff 	mov    %rax,-0xc28(%rbp)
    633f:	48 8b 85 d8 f3 ff ff 	mov    -0xc28(%rbp),%rax
    6346:	48 89 85 f8 f3 ff ff 	mov    %rax,-0xc08(%rbp)
        if (stats_data) {
    634d:	48 83 bd f8 f3 ff ff 	cmpq   $0x0,-0xc08(%rbp)
    6354:	00 
    6355:	74 11                	je     6368 <balancer_ingress+0x6368>
          stats_data->v1 += 1;
    6357:	48 8b 85 f8 f3 ff ff 	mov    -0xc08(%rbp),%rax
    635e:	48 8b 08             	mov    (%rax),%rcx
    6361:	48 83 c1 01          	add    $0x1,%rcx
    6365:	48 89 08             	mov    %rcx,(%rax)
      }
    6368:	eb 00                	jmp    636a <balancer_ingress+0x636a>
    }
    636a:	eb 00                	jmp    636c <balancer_ingress+0x636c>
  }
    636c:	eb 00                	jmp    636e <balancer_ingress+0x636e>
    if (!dst) {
    636e:	48 83 bd 10 eb ff ff 	cmpq   $0x0,-0x14f0(%rbp)
    6375:	00 
    6376:	0f 85 da 09 00 00    	jne    6d56 <balancer_ingress+0x6d56>
      if (pckt.flow.proto == IPPROTO_TCP) {
    637c:	0f b6 85 04 eb ff ff 	movzbl -0x14fc(%rbp),%eax
    6383:	83 f8 06             	cmp    $0x6,%eax
    6386:	0f 85 d5 00 00 00    	jne    6461 <balancer_ingress+0x6461>
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
    638c:	c7 85 10 e9 ff ff 01 	movl   $0x201,-0x16f0(%rbp)
    6393:	02 00 00 
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    6396:	48 c7 85 00 e9 ff ff 	movq   $0x0,-0x1700(%rbp)
    639d:	00 00 00 00 
    63a1:	c7 85 fc e8 ff ff 02 	movl   $0x2,-0x1704(%rbp)
    63a8:	00 00 00 
    63ab:	8b 85 10 e9 ff ff    	mov    -0x16f0(%rbp),%eax
    63b1:	89 85 f8 e8 ff ff    	mov    %eax,-0x1708(%rbp)
    63b7:	c7 85 f4 e8 ff ff 02 	movl   $0x2,-0x170c(%rbp)
    63be:	00 00 00 
    63c1:	c7 85 f0 e8 ff ff 08 	movl   $0x8,-0x1710(%rbp)
    63c8:	00 00 00 
    63cb:	83 bd f8 e8 ff ff 02 	cmpl   $0x2,-0x1708(%rbp)
    63d2:	73 21                	jae    63f5 <balancer_ingress+0x63f5>
    63d4:	8b 85 f8 e8 ff ff    	mov    -0x1708(%rbp),%eax
    63da:	89 c1                	mov    %eax,%ecx
    63dc:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    63e3:	88 ff ff 
    63e6:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    63ed:	00 
    63ee:	48 89 85 00 e9 ff ff 	mov    %rax,-0x1700(%rbp)
    63f5:	48 8b 85 00 e9 ff ff 	mov    -0x1700(%rbp),%rax
    63fc:	48 89 85 e8 e8 ff ff 	mov    %rax,-0x1718(%rbp)
    6403:	48 8b 85 e8 e8 ff ff 	mov    -0x1718(%rbp),%rax
        struct lb_stats* lru_stats =
    640a:	48 89 85 08 e9 ff ff 	mov    %rax,-0x16f8(%rbp)
        if (!lru_stats) {
    6411:	48 83 bd 08 e9 ff ff 	cmpq   $0x0,-0x16f8(%rbp)
    6418:	00 
    6419:	75 0f                	jne    642a <balancer_ingress+0x642a>
          return XDP_DROP;
    641b:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    6422:	00 00 00 
    6425:	e9 2f 13 00 00       	jmp    7759 <balancer_ingress+0x7759>
        if (pckt.flags & F_SYN_SET) {
    642a:	0f b6 85 0c eb ff ff 	movzbl -0x14f4(%rbp),%eax
    6431:	83 e0 02             	and    $0x2,%eax
    6434:	83 f8 00             	cmp    $0x0,%eax
    6437:	74 13                	je     644c <balancer_ingress+0x644c>
          lru_stats->v1 += 1;
    6439:	48 8b 85 08 e9 ff ff 	mov    -0x16f8(%rbp),%rax
    6440:	48 8b 08             	mov    (%rax),%rcx
    6443:	48 83 c1 01          	add    $0x1,%rcx
    6447:	48 89 08             	mov    %rcx,(%rax)
        } else {
    644a:	eb 13                	jmp    645f <balancer_ingress+0x645f>
          lru_stats->v2 += 1;
    644c:	48 8b 85 08 e9 ff ff 	mov    -0x16f8(%rbp),%rax
    6453:	48 8b 48 08          	mov    0x8(%rax),%rcx
    6457:	48 83 c1 01          	add    $0x1,%rcx
    645b:	48 89 48 08          	mov    %rcx,0x8(%rax)
      }
    645f:	eb 00                	jmp    6461 <balancer_ingress+0x6461>
      if (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6, lru_map)) {
    6461:	48 8b 95 c0 ea ff ff 	mov    -0x1540(%rbp),%rdx
    6468:	8a 8d 37 eb ff ff    	mov    -0x14c9(%rbp),%cl
    646e:	48 8b 85 20 ea ff ff 	mov    -0x15e0(%rbp),%rax
    6475:	48 8d b5 10 eb ff ff 	lea    -0x14f0(%rbp),%rsi
    647c:	48 89 b5 a0 f5 ff ff 	mov    %rsi,-0xa60(%rbp)
    6483:	48 8d b5 e0 ea ff ff 	lea    -0x1520(%rbp),%rsi
    648a:	48 89 b5 98 f5 ff ff 	mov    %rsi,-0xa68(%rbp)
    6491:	48 89 95 90 f5 ff ff 	mov    %rdx,-0xa70(%rbp)
    6498:	80 e1 01             	and    $0x1,%cl
    649b:	88 8d 8f f5 ff ff    	mov    %cl,-0xa71(%rbp)
    64a1:	48 89 85 80 f5 ff ff 	mov    %rax,-0xa80(%rbp)
  struct real_pos_lru new_dst_lru = {};
    64a8:	48 8d 85 70 f5 ff ff 	lea    -0xa90(%rbp),%rax
    64af:	31 c9                	xor    %ecx,%ecx
    64b1:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    64b8:	00 
    64b9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  bool under_flood = false;
    64c0:	c6 85 6f f5 ff ff 00 	movb   $0x0,-0xa91(%rbp)
  bool src_found = false;
    64c7:	c6 85 6e f5 ff ff 00 	movb   $0x0,-0xa92(%rbp)
  __u64 cur_time = 0;
    64ce:	48 c7 85 58 f5 ff ff 	movq   $0x0,-0xaa8(%rbp)
    64d5:	00 00 00 00 
    64d9:	48 8d 85 58 f5 ff ff 	lea    -0xaa8(%rbp),%rax
    64e0:	48 89 85 88 fc ff ff 	mov    %rax,-0x378(%rbp)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    64e7:	c7 85 84 fc ff ff 02 	movl   $0x202,-0x37c(%rbp)
    64ee:	02 00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    64f1:	48 c7 85 70 fc ff ff 	movq   $0x0,-0x390(%rbp)
    64f8:	00 00 00 00 
    64fc:	c7 85 6c fc ff ff 02 	movl   $0x2,-0x394(%rbp)
    6503:	00 00 00 
    6506:	8b 85 84 fc ff ff    	mov    -0x37c(%rbp),%eax
    650c:	89 85 68 fc ff ff    	mov    %eax,-0x398(%rbp)
    6512:	c7 85 64 fc ff ff 02 	movl   $0x2,-0x39c(%rbp)
    6519:	00 00 00 
    651c:	c7 85 60 fc ff ff 08 	movl   $0x8,-0x3a0(%rbp)
    6523:	00 00 00 
    6526:	83 bd 68 fc ff ff 02 	cmpl   $0x2,-0x398(%rbp)
    652d:	73 21                	jae    6550 <balancer_ingress+0x6550>
    652f:	8b 85 68 fc ff ff    	mov    -0x398(%rbp),%eax
    6535:	89 c1                	mov    %eax,%ecx
    6537:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    653e:	88 ff ff 
    6541:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6548:	00 
    6549:	48 89 85 70 fc ff ff 	mov    %rax,-0x390(%rbp)
    6550:	48 8b 85 70 fc ff ff 	mov    -0x390(%rbp),%rax
    6557:	48 89 85 58 fc ff ff 	mov    %rax,-0x3a8(%rbp)
    655e:	48 8b 85 58 fc ff ff 	mov    -0x3a8(%rbp),%rax
  struct lb_stats* conn_rate_stats =
    6565:	48 89 85 78 fc ff ff 	mov    %rax,-0x388(%rbp)
  if (!conn_rate_stats) {
    656c:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
    6573:	00 
    6574:	75 0c                	jne    6582 <balancer_ingress+0x6582>
    return true;
    6576:	c6 85 97 fc ff ff 01 	movb   $0x1,-0x369(%rbp)
    657d:	e9 91 00 00 00       	jmp    6613 <balancer_ingress+0x6613>
  *cur_time = bpf_ktime_get_ns();
    6582:	48 b8 98 7f 00 00 00 	movabs $0x7f98,%rax
    6589:	00 00 00 
    658c:	48 8b 00             	mov    (%rax),%rax
    658f:	ff d0                	call   *%rax
    6591:	48 89 c1             	mov    %rax,%rcx
    6594:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
    659b:	48 89 08             	mov    %rcx,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    659e:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
    65a5:	48 8b 00             	mov    (%rax),%rax
    65a8:	48 8b 8d 78 fc ff ff 	mov    -0x388(%rbp),%rcx
    65af:	48 2b 41 08          	sub    0x8(%rcx),%rax
    65b3:	48 3d 00 ca 9a 3b    	cmp    $0x3b9aca00,%rax
    65b9:	76 25                	jbe    65e0 <balancer_ingress+0x65e0>
    conn_rate_stats->v1 = 1;
    65bb:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
    65c2:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    conn_rate_stats->v2 = *cur_time;
    65c9:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
    65d0:	48 8b 08             	mov    (%rax),%rcx
    65d3:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
    65da:	48 89 48 08          	mov    %rcx,0x8(%rax)
  } else {
    65de:	eb 2c                	jmp    660c <balancer_ingress+0x660c>
    conn_rate_stats->v1 += 1;
    65e0:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
    65e7:	48 8b 08             	mov    (%rax),%rcx
    65ea:	48 83 c1 01          	add    $0x1,%rcx
    65ee:	48 89 08             	mov    %rcx,(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    65f1:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
    65f8:	48 81 38 48 e8 01 00 	cmpq   $0x1e848,(%rax)
    65ff:	76 09                	jbe    660a <balancer_ingress+0x660a>
      return true;
    6601:	c6 85 97 fc ff ff 01 	movb   $0x1,-0x369(%rbp)
    6608:	eb 09                	jmp    6613 <balancer_ingress+0x6613>
    660a:	eb 00                	jmp    660c <balancer_ingress+0x660c>
  return false;
    660c:	c6 85 97 fc ff ff 00 	movb   $0x0,-0x369(%rbp)
}
    6613:	8a 85 97 fc ff ff    	mov    -0x369(%rbp),%al
  under_flood = is_under_flood(&cur_time);
    6619:	24 01                	and    $0x1,%al
    661b:	88 85 6f f5 ff ff    	mov    %al,-0xa91(%rbp)
  if (!src_found) {
    6621:	f6 85 6e f5 ff ff 01 	testb  $0x1,-0xa92(%rbp)
    6628:	0f 85 57 02 00 00    	jne    6885 <balancer_ingress+0x6885>
    bool hash_16bytes = is_ipv6;
    662e:	8a 85 8f f5 ff ff    	mov    -0xa71(%rbp),%al
    6634:	24 01                	and    $0x1,%al
    6636:	88 85 4f f5 ff ff    	mov    %al,-0xab1(%rbp)
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    663c:	48 8b 85 90 f5 ff ff 	mov    -0xa70(%rbp),%rax
    6643:	8b 00                	mov    (%rax),%eax
    6645:	83 e0 08             	and    $0x8,%eax
    6648:	83 f8 00             	cmp    $0x0,%eax
    664b:	74 2e                	je     667b <balancer_ingress+0x667b>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    664d:	48 8b 85 98 f5 ff ff 	mov    -0xa68(%rbp),%rax
    6654:	66 8b 48 22          	mov    0x22(%rax),%cx
    6658:	48 8b 85 98 f5 ff ff 	mov    -0xa68(%rbp),%rax
    665f:	66 89 48 20          	mov    %cx,0x20(%rax)
      memset(pckt->flow.srcv6, 0, 16);
    6663:	48 8b 85 98 f5 ff ff 	mov    -0xa68(%rbp),%rax
    666a:	31 c9                	xor    %ecx,%ecx
    666c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    6673:	00 
    6674:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    667b:	48 8b 8d 98 f5 ff ff 	mov    -0xa68(%rbp),%rcx
    6682:	8a 85 4f f5 ff ff    	mov    -0xab1(%rbp),%al
    6688:	48 89 8d d8 fd ff ff 	mov    %rcx,-0x228(%rbp)
    668f:	24 01                	and    $0x1,%al
    6691:	88 85 d7 fd ff ff    	mov    %al,-0x229(%rbp)
  if (hash_16bytes) {
    6697:	f6 85 d7 fd ff ff 01 	testb  $0x1,-0x229(%rbp)
    669e:	74 34                	je     66d4 <balancer_ingress+0x66d4>
        jhash(pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6),
    66a0:	48 8b bd d8 fd ff ff 	mov    -0x228(%rbp),%rdi
    66a7:	be 10 00 00 00       	mov    $0x10,%esi
    66ac:	ba 00 02 00 00       	mov    $0x200,%edx
    66b1:	e8 ca 10 00 00       	call   7780 <jhash>
    66b6:	89 c7                	mov    %eax,%edi
        pckt->flow.ports,
    66b8:	48 8b 85 d8 fd ff ff 	mov    -0x228(%rbp),%rax
    66bf:	8b 70 20             	mov    0x20(%rax),%esi
    66c2:	ba 00 02 00 02       	mov    $0x2000200,%edx
    return jhash_2words(
    66c7:	e8 74 14 00 00       	call   7b40 <jhash_2words>
    66cc:	89 85 e0 fd ff ff    	mov    %eax,-0x220(%rbp)
    66d2:	eb 23                	jmp    66f7 <balancer_ingress+0x66f7>
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    66d4:	48 8b 85 d8 fd ff ff 	mov    -0x228(%rbp),%rax
    66db:	8b 38                	mov    (%rax),%edi
    66dd:	48 8b 85 d8 fd ff ff 	mov    -0x228(%rbp),%rax
    66e4:	8b 70 20             	mov    0x20(%rax),%esi
    66e7:	ba 00 02 00 02       	mov    $0x2000200,%edx
    66ec:	e8 4f 14 00 00       	call   7b40 <jhash_2words>
    66f1:	89 85 e0 fd ff ff    	mov    %eax,-0x220(%rbp)
}
    66f7:	8b 85 e0 fd ff ff    	mov    -0x220(%rbp),%eax
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    66fd:	b9 01 00 01 00       	mov    $0x10001,%ecx
    6702:	31 d2                	xor    %edx,%edx
    6704:	f7 f1                	div    %ecx
    6706:	89 95 54 f5 ff ff    	mov    %edx,-0xaac(%rbp)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    670c:	48 8b 85 90 f5 ff ff 	mov    -0xa70(%rbp),%rax
    6713:	69 40 04 01 00 01 00 	imul   $0x10001,0x4(%rax),%eax
    671a:	03 85 54 f5 ff ff    	add    -0xaac(%rbp),%eax
    6720:	89 85 50 f5 ff ff    	mov    %eax,-0xab0(%rbp)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    6726:	48 c7 85 40 f5 ff ff 	movq   $0x0,-0xac0(%rbp)
    672d:	00 00 00 00 
    6731:	c7 85 3c f5 ff ff 02 	movl   $0x2,-0xac4(%rbp)
    6738:	00 00 00 
    673b:	8b 85 50 f5 ff ff    	mov    -0xab0(%rbp),%eax
    6741:	89 85 38 f5 ff ff    	mov    %eax,-0xac8(%rbp)
    6747:	c7 85 34 f5 ff ff 02 	movl   $0x2,-0xacc(%rbp)
    674e:	00 00 00 
    6751:	c7 85 30 f5 ff ff 08 	movl   $0x8,-0xad0(%rbp)
    6758:	00 00 00 
    675b:	83 bd 38 f5 ff ff 02 	cmpl   $0x2,-0xac8(%rbp)
    6762:	73 21                	jae    6785 <balancer_ingress+0x6785>
    6764:	8b 85 38 f5 ff ff    	mov    -0xac8(%rbp),%eax
    676a:	89 c1                	mov    %eax,%ecx
    676c:	48 b8 00 70 1f e4 00 	movabs $0xffffc900e41f7000,%rax
    6773:	c9 ff ff 
    6776:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    677d:	00 
    677e:	48 89 85 40 f5 ff ff 	mov    %rax,-0xac0(%rbp)
    6785:	48 8b 85 40 f5 ff ff 	mov    -0xac0(%rbp),%rax
    678c:	48 89 85 28 f5 ff ff 	mov    %rax,-0xad8(%rbp)
    6793:	48 8b 85 28 f5 ff ff 	mov    -0xad8(%rbp),%rax
    679a:	48 89 85 60 f5 ff ff 	mov    %rax,-0xaa0(%rbp)
    if (!real_pos) {
    67a1:	48 83 bd 60 f5 ff ff 	cmpq   $0x0,-0xaa0(%rbp)
    67a8:	00 
    67a9:	75 0c                	jne    67b7 <balancer_ingress+0x67b7>
      return false;
    67ab:	c6 85 af f5 ff ff 00 	movb   $0x0,-0xa51(%rbp)
    67b2:	e9 93 02 00 00       	jmp    6a4a <balancer_ingress+0x6a4a>
    key = *real_pos;
    67b7:	48 8b 85 60 f5 ff ff 	mov    -0xaa0(%rbp),%rax
    67be:	8b 00                	mov    (%rax),%eax
    67c0:	89 85 50 f5 ff ff    	mov    %eax,-0xab0(%rbp)
    if (key == 0) {
    67c6:	83 bd 50 f5 ff ff 00 	cmpl   $0x0,-0xab0(%rbp)
    67cd:	0f 85 b0 00 00 00    	jne    6883 <balancer_ingress+0x6883>
  __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
    67d3:	c7 85 24 fe ff ff 09 	movl   $0x209,-0x1dc(%rbp)
    67da:	02 00 00 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    67dd:	48 c7 85 10 fe ff ff 	movq   $0x0,-0x1f0(%rbp)
    67e4:	00 00 00 00 
    67e8:	c7 85 0c fe ff ff 02 	movl   $0x2,-0x1f4(%rbp)
    67ef:	00 00 00 
    67f2:	8b 85 24 fe ff ff    	mov    -0x1dc(%rbp),%eax
    67f8:	89 85 08 fe ff ff    	mov    %eax,-0x1f8(%rbp)
    67fe:	c7 85 04 fe ff ff 02 	movl   $0x2,-0x1fc(%rbp)
    6805:	00 00 00 
    6808:	c7 85 00 fe ff ff 08 	movl   $0x8,-0x200(%rbp)
    680f:	00 00 00 
    6812:	83 bd 08 fe ff ff 02 	cmpl   $0x2,-0x1f8(%rbp)
    6819:	73 21                	jae    683c <balancer_ingress+0x683c>
    681b:	8b 85 08 fe ff ff    	mov    -0x1f8(%rbp),%eax
    6821:	89 c1                	mov    %eax,%ecx
    6823:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    682a:	88 ff ff 
    682d:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6834:	00 
    6835:	48 89 85 10 fe ff ff 	mov    %rax,-0x1f0(%rbp)
    683c:	48 8b 85 10 fe ff ff 	mov    -0x1f0(%rbp),%rax
    6843:	48 89 85 f8 fd ff ff 	mov    %rax,-0x208(%rbp)
    684a:	48 8b 85 f8 fd ff ff 	mov    -0x208(%rbp),%rax
  struct lb_stats* ch_drop_stats =
    6851:	48 89 85 18 fe ff ff 	mov    %rax,-0x1e8(%rbp)
  if (!ch_drop_stats) {
    6858:	48 83 bd 18 fe ff ff 	cmpq   $0x0,-0x1e8(%rbp)
    685f:	00 
    6860:	75 02                	jne    6864 <balancer_ingress+0x6864>
    return;
    6862:	eb 13                	jmp    6877 <balancer_ingress+0x6877>
  ch_drop_stats->v2 += 1;
    6864:	48 8b 85 18 fe ff ff 	mov    -0x1e8(%rbp),%rax
    686b:	48 8b 48 08          	mov    0x8(%rax),%rcx
    686f:	48 83 c1 01          	add    $0x1,%rcx
    6873:	48 89 48 08          	mov    %rcx,0x8(%rax)
      return false;
    6877:	c6 85 af f5 ff ff 00 	movb   $0x0,-0xa51(%rbp)
    687e:	e9 c7 01 00 00       	jmp    6a4a <balancer_ingress+0x6a4a>
  }
    6883:	eb 00                	jmp    6885 <balancer_ingress+0x6885>
  pckt->real_index = key;
    6885:	8b 8d 50 f5 ff ff    	mov    -0xab0(%rbp),%ecx
    688b:	48 8b 85 98 f5 ff ff 	mov    -0xa68(%rbp),%rax
    6892:	89 48 28             	mov    %ecx,0x28(%rax)
  *real = bpf_map_lookup_elem(&reals, &key);
    6895:	48 c7 85 20 f5 ff ff 	movq   $0x0,-0xae0(%rbp)
    689c:	00 00 00 00 
    68a0:	c7 85 1c f5 ff ff 02 	movl   $0x2,-0xae4(%rbp)
    68a7:	00 00 00 
    68aa:	8b 85 50 f5 ff ff    	mov    -0xab0(%rbp),%eax
    68b0:	89 85 18 f5 ff ff    	mov    %eax,-0xae8(%rbp)
    68b6:	c7 85 14 f5 ff ff 02 	movl   $0x2,-0xaec(%rbp)
    68bd:	00 00 00 
    68c0:	c7 85 10 f5 ff ff 08 	movl   $0x8,-0xaf0(%rbp)
    68c7:	00 00 00 
    68ca:	83 bd 18 f5 ff ff 02 	cmpl   $0x2,-0xae8(%rbp)
    68d1:	73 21                	jae    68f4 <balancer_ingress+0x68f4>
    68d3:	8b 85 18 f5 ff ff    	mov    -0xae8(%rbp),%eax
    68d9:	89 c1                	mov    %eax,%ecx
    68db:	48 b8 00 30 50 52 00 	movabs $0xffffc90052503000,%rax
    68e2:	c9 ff ff 
    68e5:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    68ec:	00 
    68ed:	48 89 85 20 f5 ff ff 	mov    %rax,-0xae0(%rbp)
    68f4:	48 8b 85 20 f5 ff ff 	mov    -0xae0(%rbp),%rax
    68fb:	48 89 85 08 f5 ff ff 	mov    %rax,-0xaf8(%rbp)
    6902:	48 8b 8d 08 f5 ff ff 	mov    -0xaf8(%rbp),%rcx
    6909:	48 8b 85 a0 f5 ff ff 	mov    -0xa60(%rbp),%rax
    6910:	48 89 08             	mov    %rcx,(%rax)
  if (!(*real)) {
    6913:	48 8b 85 a0 f5 ff ff 	mov    -0xa60(%rbp),%rax
    691a:	48 83 38 00          	cmpq   $0x0,(%rax)
    691e:	0f 85 ab 00 00 00    	jne    69cf <balancer_ingress+0x69cf>
  __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
    6924:	c7 85 84 fe ff ff 09 	movl   $0x209,-0x17c(%rbp)
    692b:	02 00 00 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    692e:	48 c7 85 70 fe ff ff 	movq   $0x0,-0x190(%rbp)
    6935:	00 00 00 00 
    6939:	c7 85 6c fe ff ff 02 	movl   $0x2,-0x194(%rbp)
    6940:	00 00 00 
    6943:	8b 85 84 fe ff ff    	mov    -0x17c(%rbp),%eax
    6949:	89 85 68 fe ff ff    	mov    %eax,-0x198(%rbp)
    694f:	c7 85 64 fe ff ff 02 	movl   $0x2,-0x19c(%rbp)
    6956:	00 00 00 
    6959:	c7 85 60 fe ff ff 08 	movl   $0x8,-0x1a0(%rbp)
    6960:	00 00 00 
    6963:	83 bd 68 fe ff ff 02 	cmpl   $0x2,-0x198(%rbp)
    696a:	73 21                	jae    698d <balancer_ingress+0x698d>
    696c:	8b 85 68 fe ff ff    	mov    -0x198(%rbp),%eax
    6972:	89 c1                	mov    %eax,%ecx
    6974:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    697b:	88 ff ff 
    697e:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6985:	00 
    6986:	48 89 85 70 fe ff ff 	mov    %rax,-0x190(%rbp)
    698d:	48 8b 85 70 fe ff ff 	mov    -0x190(%rbp),%rax
    6994:	48 89 85 58 fe ff ff 	mov    %rax,-0x1a8(%rbp)
    699b:	48 8b 85 58 fe ff ff 	mov    -0x1a8(%rbp),%rax
  struct lb_stats* ch_drop_stats =
    69a2:	48 89 85 78 fe ff ff 	mov    %rax,-0x188(%rbp)
  if (!ch_drop_stats) {
    69a9:	48 83 bd 78 fe ff ff 	cmpq   $0x0,-0x188(%rbp)
    69b0:	00 
    69b1:	75 02                	jne    69b5 <balancer_ingress+0x69b5>
    return;
    69b3:	eb 11                	jmp    69c6 <balancer_ingress+0x69c6>
  ch_drop_stats->v1 += 1;
    69b5:	48 8b 85 78 fe ff ff 	mov    -0x188(%rbp),%rax
    69bc:	48 8b 08             	mov    (%rax),%rcx
    69bf:	48 83 c1 01          	add    $0x1,%rcx
    69c3:	48 89 08             	mov    %rcx,(%rax)
    return false;
    69c6:	c6 85 af f5 ff ff 00 	movb   $0x0,-0xa51(%rbp)
    69cd:	eb 7b                	jmp    6a4a <balancer_ingress+0x6a4a>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    69cf:	48 83 bd 80 f5 ff ff 	cmpq   $0x0,-0xa80(%rbp)
    69d6:	00 
    69d7:	74 6a                	je     6a43 <balancer_ingress+0x6a43>
    69d9:	48 8b 85 90 f5 ff ff 	mov    -0xa70(%rbp),%rax
    69e0:	8b 00                	mov    (%rax),%eax
    69e2:	83 e0 02             	and    $0x2,%eax
    69e5:	83 f8 00             	cmp    $0x0,%eax
    69e8:	75 59                	jne    6a43 <balancer_ingress+0x6a43>
    69ea:	f6 85 6f f5 ff ff 01 	testb  $0x1,-0xa91(%rbp)
    69f1:	75 50                	jne    6a43 <balancer_ingress+0x6a43>
    if (pckt->flow.proto == IPPROTO_UDP) {
    69f3:	48 8b 85 98 f5 ff ff 	mov    -0xa68(%rbp),%rax
    69fa:	0f b6 40 24          	movzbl 0x24(%rax),%eax
    69fe:	83 f8 11             	cmp    $0x11,%eax
    6a01:	75 0e                	jne    6a11 <balancer_ingress+0x6a11>
      new_dst_lru.atime = cur_time;
    6a03:	48 8b 85 58 f5 ff ff 	mov    -0xaa8(%rbp),%rax
    6a0a:	48 89 85 78 f5 ff ff 	mov    %rax,-0xa88(%rbp)
    new_dst_lru.pos = key;
    6a11:	8b 85 50 f5 ff ff    	mov    -0xab0(%rbp),%eax
    6a17:	89 85 70 f5 ff ff    	mov    %eax,-0xa90(%rbp)
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    6a1d:	48 b8 90 7f 00 00 00 	movabs $0x7f90,%rax
    6a24:	00 00 00 
    6a27:	48 8b 00             	mov    (%rax),%rax
    6a2a:	48 8b bd 80 f5 ff ff 	mov    -0xa80(%rbp),%rdi
    6a31:	48 8b b5 98 f5 ff ff 	mov    -0xa68(%rbp),%rsi
    6a38:	48 8d 95 70 f5 ff ff 	lea    -0xa90(%rbp),%rdx
    6a3f:	31 c9                	xor    %ecx,%ecx
    6a41:	ff d0                	call   *%rax
  return true;
    6a43:	c6 85 af f5 ff ff 01 	movb   $0x1,-0xa51(%rbp)
      if (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6, lru_map)) {
    6a4a:	f6 85 af f5 ff ff 01 	testb  $0x1,-0xa51(%rbp)
    6a51:	75 0f                	jne    6a62 <balancer_ingress+0x6a62>
        return XDP_DROP;
    6a53:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    6a5a:	00 00 00 
    6a5d:	e9 f7 0c 00 00       	jmp    7759 <balancer_ingress+0x7759>
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    6a62:	48 8b 8d c0 ea ff ff 	mov    -0x1540(%rbp),%rcx
    6a69:	8a 85 37 eb ff ff    	mov    -0x14c9(%rbp),%al
    6a6f:	48 8d 95 c8 ea ff ff 	lea    -0x1538(%rbp),%rdx
    6a76:	48 89 95 a0 f6 ff ff 	mov    %rdx,-0x960(%rbp)
    6a7d:	48 8d 95 e0 ea ff ff 	lea    -0x1520(%rbp),%rdx
    6a84:	48 89 95 98 f6 ff ff 	mov    %rdx,-0x968(%rbp)
    6a8b:	48 89 8d 90 f6 ff ff 	mov    %rcx,-0x970(%rbp)
    6a92:	24 01                	and    $0x1,%al
    6a94:	88 85 8f f6 ff ff    	mov    %al,-0x971(%rbp)
  __u32 vip_miss_stats_key = 0;
    6a9a:	c7 85 88 f6 ff ff 00 	movl   $0x0,-0x978(%rbp)
    6aa1:	00 00 00 
      bpf_map_lookup_elem(&vip_miss_stats, &vip_miss_stats_key);
    6aa4:	48 c7 85 78 f6 ff ff 	movq   $0x0,-0x988(%rbp)
    6aab:	00 00 00 00 
    6aaf:	c7 85 74 f6 ff ff 02 	movl   $0x2,-0x98c(%rbp)
    6ab6:	00 00 00 
    6ab9:	8b 85 88 f6 ff ff    	mov    -0x978(%rbp),%eax
    6abf:	89 85 70 f6 ff ff    	mov    %eax,-0x990(%rbp)
    6ac5:	c7 85 6c f6 ff ff 02 	movl   $0x2,-0x994(%rbp)
    6acc:	00 00 00 
    6acf:	c7 85 68 f6 ff ff 08 	movl   $0x8,-0x998(%rbp)
    6ad6:	00 00 00 
    6ad9:	83 bd 70 f6 ff ff 02 	cmpl   $0x2,-0x990(%rbp)
    6ae0:	73 21                	jae    6b03 <balancer_ingress+0x6b03>
    6ae2:	8b 85 70 f6 ff ff    	mov    -0x990(%rbp),%eax
    6ae8:	89 c1                	mov    %eax,%ecx
    6aea:	48 b8 00 24 97 51 81 	movabs $0xffff888151972400,%rax
    6af1:	88 ff ff 
    6af4:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6afb:	00 
    6afc:	48 89 85 78 f6 ff ff 	mov    %rax,-0x988(%rbp)
    6b03:	48 8b 85 78 f6 ff ff 	mov    -0x988(%rbp),%rax
    6b0a:	48 89 85 60 f6 ff ff 	mov    %rax,-0x9a0(%rbp)
    6b11:	48 8b 85 60 f6 ff ff 	mov    -0x9a0(%rbp),%rax
  struct vip_definition* lru_miss_stat_vip =
    6b18:	48 89 85 80 f6 ff ff 	mov    %rax,-0x980(%rbp)
  if (!lru_miss_stat_vip) {
    6b1f:	48 83 bd 80 f6 ff ff 	cmpq   $0x0,-0x980(%rbp)
    6b26:	00 
    6b27:	75 0f                	jne    6b38 <balancer_ingress+0x6b38>
    return XDP_DROP;
    6b29:	c7 85 a8 f6 ff ff 01 	movl   $0x1,-0x958(%rbp)
    6b30:	00 00 00 
    6b33:	e9 f3 01 00 00       	jmp    6d2b <balancer_ingress+0x6d2b>
  bool address_match = (is_ipv6 &&
    6b38:	f6 85 8f f6 ff ff 01 	testb  $0x1,-0x971(%rbp)
    6b3f:	74 5e                	je     6b9f <balancer_ingress+0x6b9f>
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    6b41:	48 8b 85 80 f6 ff ff 	mov    -0x980(%rbp),%rax
    6b48:	8b 00                	mov    (%rax),%eax
    6b4a:	48 8b 8d a0 f6 ff ff 	mov    -0x960(%rbp),%rcx
    6b51:	3b 01                	cmp    (%rcx),%eax
    6b53:	75 4a                	jne    6b9f <balancer_ingress+0x6b9f>
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    6b55:	48 8b 85 80 f6 ff ff 	mov    -0x980(%rbp),%rax
    6b5c:	8b 40 04             	mov    0x4(%rax),%eax
    6b5f:	48 8b 8d a0 f6 ff ff 	mov    -0x960(%rbp),%rcx
    6b66:	3b 41 04             	cmp    0x4(%rcx),%eax
    6b69:	75 34                	jne    6b9f <balancer_ingress+0x6b9f>
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    6b6b:	48 8b 85 80 f6 ff ff 	mov    -0x980(%rbp),%rax
    6b72:	8b 40 08             	mov    0x8(%rax),%eax
    6b75:	48 8b 8d a0 f6 ff ff 	mov    -0x960(%rbp),%rcx
    6b7c:	3b 41 08             	cmp    0x8(%rcx),%eax
    6b7f:	75 1e                	jne    6b9f <balancer_ingress+0x6b9f>
                         lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
    6b81:	48 8b 85 80 f6 ff ff 	mov    -0x980(%rbp),%rax
    6b88:	8b 48 0c             	mov    0xc(%rax),%ecx
    6b8b:	48 8b 95 a0 f6 ff ff 	mov    -0x960(%rbp),%rdx
    6b92:	b0 01                	mov    $0x1,%al
    6b94:	3b 4a 0c             	cmp    0xc(%rdx),%ecx
    6b97:	88 85 21 e8 ff ff    	mov    %al,-0x17df(%rbp)
    6b9d:	74 38                	je     6bd7 <balancer_ingress+0x6bd7>
      (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
    6b9f:	31 c0                	xor    %eax,%eax
    6ba1:	f6 85 8f f6 ff ff 01 	testb  $0x1,-0x971(%rbp)
    6ba8:	88 85 20 e8 ff ff    	mov    %al,-0x17e0(%rbp)
    6bae:	75 1b                	jne    6bcb <balancer_ingress+0x6bcb>
    6bb0:	48 8b 85 80 f6 ff ff 	mov    -0x980(%rbp),%rax
    6bb7:	8b 00                	mov    (%rax),%eax
    6bb9:	48 8b 8d a0 f6 ff ff 	mov    -0x960(%rbp),%rcx
    6bc0:	3b 01                	cmp    (%rcx),%eax
    6bc2:	0f 94 c0             	sete   %al
    6bc5:	88 85 20 e8 ff ff    	mov    %al,-0x17e0(%rbp)
    6bcb:	8a 85 20 e8 ff ff    	mov    -0x17e0(%rbp),%al
    6bd1:	88 85 21 e8 ff ff    	mov    %al,-0x17df(%rbp)
    6bd7:	8a 85 21 e8 ff ff    	mov    -0x17df(%rbp),%al
  bool address_match = (is_ipv6 &&
    6bdd:	24 01                	and    $0x1,%al
    6bdf:	88 85 5f f6 ff ff    	mov    %al,-0x9a1(%rbp)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    6be5:	48 8b 85 80 f6 ff ff 	mov    -0x980(%rbp),%rax
    6bec:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    6bf0:	48 8b 8d a0 f6 ff ff 	mov    -0x960(%rbp),%rcx
    6bf7:	0f b7 49 10          	movzwl 0x10(%rcx),%ecx
    6bfb:	39 c8                	cmp    %ecx,%eax
    6bfd:	0f 94 c0             	sete   %al
    6c00:	24 01                	and    $0x1,%al
    6c02:	88 85 5e f6 ff ff    	mov    %al,-0x9a2(%rbp)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    6c08:	48 8b 85 a0 f6 ff ff 	mov    -0x960(%rbp),%rax
    6c0f:	8a 40 12             	mov    0x12(%rax),%al
    6c12:	48 8b 8d 80 f6 ff ff 	mov    -0x980(%rbp),%rcx
    6c19:	88 41 12             	mov    %al,0x12(%rcx)
    6c1c:	3c 00                	cmp    $0x0,%al
    6c1e:	0f 95 c0             	setne  %al
    6c21:	24 01                	and    $0x1,%al
    6c23:	88 85 5d f6 ff ff    	mov    %al,-0x9a3(%rbp)
  bool vip_match = address_match && port_match && proto_match;
    6c29:	31 c0                	xor    %eax,%eax
    6c2b:	f6 85 5f f6 ff ff 01 	testb  $0x1,-0x9a1(%rbp)
    6c32:	88 85 1f e8 ff ff    	mov    %al,-0x17e1(%rbp)
    6c38:	74 1d                	je     6c57 <balancer_ingress+0x6c57>
    6c3a:	31 c0                	xor    %eax,%eax
    6c3c:	f6 85 5e f6 ff ff 01 	testb  $0x1,-0x9a2(%rbp)
    6c43:	88 85 1f e8 ff ff    	mov    %al,-0x17e1(%rbp)
    6c49:	74 0c                	je     6c57 <balancer_ingress+0x6c57>
    6c4b:	8a 85 5d f6 ff ff    	mov    -0x9a3(%rbp),%al
    6c51:	88 85 1f e8 ff ff    	mov    %al,-0x17e1(%rbp)
    6c57:	8a 85 1f e8 ff ff    	mov    -0x17e1(%rbp),%al
    6c5d:	24 01                	and    $0x1,%al
    6c5f:	88 85 5c f6 ff ff    	mov    %al,-0x9a4(%rbp)
  if (vip_match) {
    6c65:	f6 85 5c f6 ff ff 01 	testb  $0x1,-0x9a4(%rbp)
    6c6c:	0f 84 af 00 00 00    	je     6d21 <balancer_ingress+0x6d21>
    __u32 lru_stats_key = pckt->real_index;
    6c72:	48 8b 85 98 f6 ff ff 	mov    -0x968(%rbp),%rax
    6c79:	8b 40 28             	mov    0x28(%rax),%eax
    6c7c:	89 85 58 f6 ff ff    	mov    %eax,-0x9a8(%rbp)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    6c82:	48 c7 85 48 f6 ff ff 	movq   $0x0,-0x9b8(%rbp)
    6c89:	00 00 00 00 
    6c8d:	c7 85 44 f6 ff ff 02 	movl   $0x2,-0x9bc(%rbp)
    6c94:	00 00 00 
    6c97:	8b 85 58 f6 ff ff    	mov    -0x9a8(%rbp),%eax
    6c9d:	89 85 40 f6 ff ff    	mov    %eax,-0x9c0(%rbp)
    6ca3:	c7 85 3c f6 ff ff 02 	movl   $0x2,-0x9c4(%rbp)
    6caa:	00 00 00 
    6cad:	c7 85 38 f6 ff ff 08 	movl   $0x8,-0x9c8(%rbp)
    6cb4:	00 00 00 
    6cb7:	83 bd 40 f6 ff ff 02 	cmpl   $0x2,-0x9c0(%rbp)
    6cbe:	73 21                	jae    6ce1 <balancer_ingress+0x6ce1>
    6cc0:	8b 85 40 f6 ff ff    	mov    -0x9c0(%rbp),%eax
    6cc6:	89 c1                	mov    %eax,%ecx
    6cc8:	48 b8 00 c0 11 52 00 	movabs $0xffffc9005211c000,%rax
    6ccf:	c9 ff ff 
    6cd2:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6cd9:	00 
    6cda:	48 89 85 48 f6 ff ff 	mov    %rax,-0x9b8(%rbp)
    6ce1:	48 8b 85 48 f6 ff ff 	mov    -0x9b8(%rbp),%rax
    6ce8:	48 89 85 30 f6 ff ff 	mov    %rax,-0x9d0(%rbp)
    6cef:	48 8b 85 30 f6 ff ff 	mov    -0x9d0(%rbp),%rax
    6cf6:	48 89 85 50 f6 ff ff 	mov    %rax,-0x9b0(%rbp)
    if (!lru_miss_stat) {
    6cfd:	48 83 bd 50 f6 ff ff 	cmpq   $0x0,-0x9b0(%rbp)
    6d04:	00 
    6d05:	75 0c                	jne    6d13 <balancer_ingress+0x6d13>
      return XDP_DROP;
    6d07:	c7 85 a8 f6 ff ff 01 	movl   $0x1,-0x958(%rbp)
    6d0e:	00 00 00 
    6d11:	eb 18                	jmp    6d2b <balancer_ingress+0x6d2b>
    *lru_miss_stat += 1;
    6d13:	48 8b 85 50 f6 ff ff 	mov    -0x9b0(%rbp),%rax
    6d1a:	8b 08                	mov    (%rax),%ecx
    6d1c:	83 c1 01             	add    $0x1,%ecx
    6d1f:	89 08                	mov    %ecx,(%rax)
  return FURTHER_PROCESSING;
    6d21:	c7 85 a8 f6 ff ff ff 	movl   $0xffffffff,-0x958(%rbp)
    6d28:	ff ff ff 
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    6d2b:	83 bd a8 f6 ff ff 00 	cmpl   $0x0,-0x958(%rbp)
    6d32:	7c 0f                	jl     6d43 <balancer_ingress+0x6d43>
        return XDP_DROP;
    6d34:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    6d3b:	00 00 00 
    6d3e:	e9 16 0a 00 00       	jmp    7759 <balancer_ingress+0x7759>
      data_stats->v2 += 1;
    6d43:	48 8b 85 b8 ea ff ff 	mov    -0x1548(%rbp),%rax
    6d4a:	48 8b 48 08          	mov    0x8(%rax),%rcx
    6d4e:	48 83 c1 01          	add    $0x1,%rcx
    6d52:	48 89 48 08          	mov    %rcx,0x8(%rax)
  }
    6d56:	eb 00                	jmp    6d58 <balancer_ingress+0x6d58>
  cval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos);
    6d58:	48 c7 85 e0 e8 ff ff 	movq   $0x0,-0x1720(%rbp)
    6d5f:	00 00 00 00 
    6d63:	c7 85 dc e8 ff ff 02 	movl   $0x2,-0x1724(%rbp)
    6d6a:	00 00 00 
    6d6d:	8b 85 a8 ea ff ff    	mov    -0x1558(%rbp),%eax
    6d73:	89 85 d8 e8 ff ff    	mov    %eax,-0x1728(%rbp)
    6d79:	c7 85 d4 e8 ff ff 02 	movl   $0x2,-0x172c(%rbp)
    6d80:	00 00 00 
    6d83:	c7 85 d0 e8 ff ff 08 	movl   $0x8,-0x1730(%rbp)
    6d8a:	00 00 00 
    6d8d:	83 bd d8 e8 ff ff 02 	cmpl   $0x2,-0x1728(%rbp)
    6d94:	73 21                	jae    6db7 <balancer_ingress+0x6db7>
    6d96:	8b 85 d8 e8 ff ff    	mov    -0x1728(%rbp),%eax
    6d9c:	89 c1                	mov    %eax,%ecx
    6d9e:	48 b8 00 20 97 51 81 	movabs $0xffff888151972000,%rax
    6da5:	88 ff ff 
    6da8:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6daf:	00 
    6db0:	48 89 85 e0 e8 ff ff 	mov    %rax,-0x1720(%rbp)
    6db7:	48 8b 85 e0 e8 ff ff 	mov    -0x1720(%rbp),%rax
    6dbe:	48 89 85 c8 e8 ff ff 	mov    %rax,-0x1738(%rbp)
    6dc5:	48 8b 85 c8 e8 ff ff 	mov    -0x1738(%rbp),%rax
    6dcc:	48 89 85 18 eb ff ff 	mov    %rax,-0x14e8(%rbp)
  if (!cval) {
    6dd3:	48 83 bd 18 eb ff ff 	cmpq   $0x0,-0x14e8(%rbp)
    6dda:	00 
    6ddb:	75 0f                	jne    6dec <balancer_ingress+0x6dec>
    return XDP_DROP;
    6ddd:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    6de4:	00 00 00 
    6de7:	e9 6d 09 00 00       	jmp    7759 <balancer_ingress+0x7759>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    6dec:	48 c7 85 c0 e8 ff ff 	movq   $0x0,-0x1740(%rbp)
    6df3:	00 00 00 00 
    6df7:	c7 85 bc e8 ff ff 02 	movl   $0x2,-0x1744(%rbp)
    6dfe:	00 00 00 
    6e01:	8b 85 ac ea ff ff    	mov    -0x1554(%rbp),%eax
    6e07:	89 85 b8 e8 ff ff    	mov    %eax,-0x1748(%rbp)
    6e0d:	c7 85 b4 e8 ff ff 02 	movl   $0x2,-0x174c(%rbp)
    6e14:	00 00 00 
    6e17:	c7 85 b0 e8 ff ff 08 	movl   $0x8,-0x1750(%rbp)
    6e1e:	00 00 00 
    6e21:	83 bd b8 e8 ff ff 02 	cmpl   $0x2,-0x1748(%rbp)
    6e28:	73 21                	jae    6e4b <balancer_ingress+0x6e4b>
    6e2a:	8b 85 b8 e8 ff ff    	mov    -0x1748(%rbp),%eax
    6e30:	89 c1                	mov    %eax,%ecx
    6e32:	48 b8 00 c0 24 2e 81 	movabs $0xffff88812e24c000,%rax
    6e39:	88 ff ff 
    6e3c:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6e43:	00 
    6e44:	48 89 85 c0 e8 ff ff 	mov    %rax,-0x1740(%rbp)
    6e4b:	48 8b 85 c0 e8 ff ff 	mov    -0x1740(%rbp),%rax
    6e52:	48 89 85 a8 e8 ff ff 	mov    %rax,-0x1758(%rbp)
    6e59:	48 8b 85 a8 e8 ff ff 	mov    -0x1758(%rbp),%rax
    6e60:	48 89 85 b8 ea ff ff 	mov    %rax,-0x1548(%rbp)
  if (!data_stats) {
    6e67:	48 83 bd b8 ea ff ff 	cmpq   $0x0,-0x1548(%rbp)
    6e6e:	00 
    6e6f:	75 0f                	jne    6e80 <balancer_ingress+0x6e80>
    return XDP_DROP;
    6e71:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    6e78:	00 00 00 
    6e7b:	e9 d9 08 00 00       	jmp    7759 <balancer_ingress+0x7759>
  data_stats->v1 += 1;
    6e80:	48 8b 85 b8 ea ff ff 	mov    -0x1548(%rbp),%rax
    6e87:	48 8b 08             	mov    (%rax),%rcx
    6e8a:	48 83 c1 01          	add    $0x1,%rcx
    6e8e:	48 89 08             	mov    %rcx,(%rax)
  data_stats->v2 += pkt_bytes;
    6e91:	0f b7 85 a6 ea ff ff 	movzwl -0x155a(%rbp),%eax
    6e98:	89 c1                	mov    %eax,%ecx
    6e9a:	48 8b 85 b8 ea ff ff 	mov    -0x1548(%rbp),%rax
    6ea1:	48 03 48 08          	add    0x8(%rax),%rcx
    6ea5:	48 89 48 08          	mov    %rcx,0x8(%rax)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    6ea9:	48 c7 85 a0 e8 ff ff 	movq   $0x0,-0x1760(%rbp)
    6eb0:	00 00 00 00 
    6eb4:	c7 85 9c e8 ff ff 02 	movl   $0x2,-0x1764(%rbp)
    6ebb:	00 00 00 
    6ebe:	8b 85 08 eb ff ff    	mov    -0x14f8(%rbp),%eax
    6ec4:	89 85 98 e8 ff ff    	mov    %eax,-0x1768(%rbp)
    6eca:	c7 85 94 e8 ff ff 02 	movl   $0x2,-0x176c(%rbp)
    6ed1:	00 00 00 
    6ed4:	c7 85 90 e8 ff ff 08 	movl   $0x8,-0x1770(%rbp)
    6edb:	00 00 00 
    6ede:	83 bd 98 e8 ff ff 02 	cmpl   $0x2,-0x1768(%rbp)
    6ee5:	73 21                	jae    6f08 <balancer_ingress+0x6f08>
    6ee7:	8b 85 98 e8 ff ff    	mov    -0x1768(%rbp),%eax
    6eed:	89 c1                	mov    %eax,%ecx
    6eef:	48 b8 00 a0 0d 52 00 	movabs $0xffffc900520da000,%rax
    6ef6:	c9 ff ff 
    6ef9:	48 8d 84 c8 00 01 00 	lea    0x100(%rax,%rcx,8),%rax
    6f00:	00 
    6f01:	48 89 85 a0 e8 ff ff 	mov    %rax,-0x1760(%rbp)
    6f08:	48 8b 85 a0 e8 ff ff 	mov    -0x1760(%rbp),%rax
    6f0f:	48 89 85 88 e8 ff ff 	mov    %rax,-0x1778(%rbp)
    6f16:	48 8b 85 88 e8 ff ff 	mov    -0x1778(%rbp),%rax
    6f1d:	48 89 85 b8 ea ff ff 	mov    %rax,-0x1548(%rbp)
  if (!data_stats) {
    6f24:	48 83 bd b8 ea ff ff 	cmpq   $0x0,-0x1548(%rbp)
    6f2b:	00 
    6f2c:	75 0f                	jne    6f3d <balancer_ingress+0x6f3d>
    return XDP_DROP;
    6f2e:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    6f35:	00 00 00 
    6f38:	e9 1c 08 00 00       	jmp    7759 <balancer_ingress+0x7759>
  data_stats->v1 += 1;
    6f3d:	48 8b 85 b8 ea ff ff 	mov    -0x1548(%rbp),%rax
    6f44:	48 8b 08             	mov    (%rax),%rcx
    6f47:	48 83 c1 01          	add    $0x1,%rcx
    6f4b:	48 89 08             	mov    %rcx,(%rax)
  data_stats->v2 += pkt_bytes;
    6f4e:	0f b7 85 a6 ea ff ff 	movzwl -0x155a(%rbp),%eax
    6f55:	89 c1                	mov    %eax,%ecx
    6f57:	48 8b 85 b8 ea ff ff 	mov    -0x1548(%rbp),%rax
    6f5e:	48 03 48 08          	add    0x8(%rax),%rcx
    6f62:	48 89 48 08          	mov    %rcx,0x8(%rax)
  pckt.flow.port16[0] = original_sport;
    6f66:	66 8b 85 b4 ea ff ff 	mov    -0x154c(%rbp),%ax
    6f6d:	66 89 85 00 eb ff ff 	mov    %ax,-0x1500(%rbp)
  if (dst->flags & F_IPV6) {
    6f74:	48 8b 85 10 eb ff ff 	mov    -0x14f0(%rbp),%rax
    6f7b:	0f b6 40 10          	movzbl 0x10(%rax),%eax
    6f7f:	83 e0 01             	and    $0x1,%eax
    6f82:	83 f8 00             	cmp    $0x0,%eax
    6f85:	0f 84 e4 03 00 00    	je     736f <balancer_ingress+0x736f>
    if (!PCKT_ENCAP_V6(xdp, cval, is_ipv6, &pckt, dst, pkt_bytes)) {
    6f8b:	48 8b bd 40 eb ff ff 	mov    -0x14c0(%rbp),%rdi
    6f92:	48 8b b5 18 eb ff ff 	mov    -0x14e8(%rbp),%rsi
    6f99:	8a 95 37 eb ff ff    	mov    -0x14c9(%rbp),%dl
    6f9f:	48 8b 8d 10 eb ff ff 	mov    -0x14f0(%rbp),%rcx
    6fa6:	0f b7 85 a6 ea ff ff 	movzwl -0x155a(%rbp),%eax
    6fad:	48 89 bd 98 f7 ff ff 	mov    %rdi,-0x868(%rbp)
    6fb4:	48 89 b5 90 f7 ff ff 	mov    %rsi,-0x870(%rbp)
    6fbb:	80 e2 01             	and    $0x1,%dl
    6fbe:	88 95 8f f7 ff ff    	mov    %dl,-0x871(%rbp)
    6fc4:	48 8d 95 e0 ea ff ff 	lea    -0x1520(%rbp),%rdx
    6fcb:	48 89 95 80 f7 ff ff 	mov    %rdx,-0x880(%rbp)
    6fd2:	48 89 8d 78 f7 ff ff 	mov    %rcx,-0x888(%rbp)
    6fd9:	89 85 74 f7 ff ff    	mov    %eax,-0x88c(%rbp)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    6fdf:	48 b8 a0 7f 00 00 00 	movabs $0x7fa0,%rax
    6fe6:	00 00 00 
    6fe9:	48 8b 00             	mov    (%rax),%rax
    6fec:	48 8b bd 98 f7 ff ff 	mov    -0x868(%rbp),%rdi
    6ff3:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    6ff8:	ff d0                	call   *%rax
    6ffa:	83 f8 00             	cmp    $0x0,%eax
    6ffd:	74 0c                	je     700b <balancer_ingress+0x700b>
    return false;
    6fff:	c6 85 a7 f7 ff ff 00 	movb   $0x0,-0x859(%rbp)
    7006:	e9 47 03 00 00       	jmp    7352 <balancer_ingress+0x7352>
  data = (void*)(long)xdp->data;
    700b:	48 8b 85 98 f7 ff ff 	mov    -0x868(%rbp),%rax
    7012:	48 8b 00             	mov    (%rax),%rax
    7015:	48 89 85 68 f7 ff ff 	mov    %rax,-0x898(%rbp)
  data_end = (void*)(long)xdp->data_end;
    701c:	48 8b 85 98 f7 ff ff 	mov    -0x868(%rbp),%rax
    7023:	48 8b 40 08          	mov    0x8(%rax),%rax
    7027:	48 89 85 60 f7 ff ff 	mov    %rax,-0x8a0(%rbp)
  new_eth = data;
    702e:	48 8b 85 68 f7 ff ff 	mov    -0x898(%rbp),%rax
    7035:	48 89 85 50 f7 ff ff 	mov    %rax,-0x8b0(%rbp)
  ip6h = data + sizeof(struct ethhdr);
    703c:	48 8b 85 68 f7 ff ff 	mov    -0x898(%rbp),%rax
    7043:	48 83 c0 0e          	add    $0xe,%rax
    7047:	48 89 85 58 f7 ff ff 	mov    %rax,-0x8a8(%rbp)
  old_eth = data + sizeof(struct ipv6hdr);
    704e:	48 8b 85 68 f7 ff ff 	mov    -0x898(%rbp),%rax
    7055:	48 83 c0 28          	add    $0x28,%rax
    7059:	48 89 85 48 f7 ff ff 	mov    %rax,-0x8b8(%rbp)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    7060:	48 8b 85 50 f7 ff ff 	mov    -0x8b0(%rbp),%rax
    7067:	48 83 c0 0e          	add    $0xe,%rax
    706b:	48 8b 8d 60 f7 ff ff 	mov    -0x8a0(%rbp),%rcx
    7072:	48 39 c8             	cmp    %rcx,%rax
    7075:	77 2e                	ja     70a5 <balancer_ingress+0x70a5>
    7077:	48 8b 85 48 f7 ff ff 	mov    -0x8b8(%rbp),%rax
    707e:	48 83 c0 0e          	add    $0xe,%rax
    7082:	48 8b 8d 60 f7 ff ff 	mov    -0x8a0(%rbp),%rcx
    7089:	48 39 c8             	cmp    %rcx,%rax
    708c:	77 17                	ja     70a5 <balancer_ingress+0x70a5>
    708e:	48 8b 85 58 f7 ff ff 	mov    -0x8a8(%rbp),%rax
    7095:	48 83 c0 28          	add    $0x28,%rax
    7099:	48 8b 8d 60 f7 ff ff 	mov    -0x8a0(%rbp),%rcx
    70a0:	48 39 c8             	cmp    %rcx,%rax
    70a3:	76 0c                	jbe    70b1 <balancer_ingress+0x70b1>
    return false;
    70a5:	c6 85 a7 f7 ff ff 00 	movb   $0x0,-0x859(%rbp)
    70ac:	e9 a1 02 00 00       	jmp    7352 <balancer_ingress+0x7352>
  memcpy(new_eth->h_dest, cval->mac, 6);
    70b1:	48 8b 85 50 f7 ff ff 	mov    -0x8b0(%rbp),%rax
    70b8:	48 8b 8d 90 f7 ff ff 	mov    -0x870(%rbp),%rcx
    70bf:	8b 11                	mov    (%rcx),%edx
    70c1:	89 10                	mov    %edx,(%rax)
    70c3:	66 8b 49 04          	mov    0x4(%rcx),%cx
    70c7:	66 89 48 04          	mov    %cx,0x4(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    70cb:	48 8b 85 50 f7 ff ff 	mov    -0x8b0(%rbp),%rax
    70d2:	48 8b 8d 48 f7 ff ff 	mov    -0x8b8(%rbp),%rcx
    70d9:	8b 11                	mov    (%rcx),%edx
    70db:	89 50 06             	mov    %edx,0x6(%rax)
    70de:	66 8b 49 04          	mov    0x4(%rcx),%cx
    70e2:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    70e6:	48 8b 85 50 f7 ff ff 	mov    -0x8b0(%rbp),%rax
    70ed:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
  if (is_ipv6) {
    70f3:	f6 85 8f f7 ff ff 01 	testb  $0x1,-0x871(%rbp)
    70fa:	0f 84 8f 00 00 00    	je     718f <balancer_ingress+0x718f>
    proto = IPPROTO_IPV6;
    7100:	c6 85 2f f7 ff ff 29 	movb   $0x29,-0x8d1(%rbp)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
    7107:	48 8b 85 80 f7 ff ff 	mov    -0x880(%rbp),%rax
    710e:	66 8b 50 20          	mov    0x20(%rax),%dx
    7112:	48 8b 85 80 f7 ff ff 	mov    -0x880(%rbp),%rax
    7119:	8b 48 0c             	mov    0xc(%rax),%ecx
    711c:	48 8d 85 30 f7 ff ff 	lea    -0x8d0(%rbp),%rax
    7123:	66 89 95 c6 fe ff ff 	mov    %dx,-0x13a(%rbp)
    712a:	89 8d c0 fe ff ff    	mov    %ecx,-0x140(%rbp)
    7130:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
  saddr[0] = IPIP_V6_PREFIX1;
    7137:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
    713e:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
  saddr[1] = IPIP_V6_PREFIX2;
    7144:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
    714b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  saddr[2] = IPIP_V6_PREFIX3;
    7152:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
    7159:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  saddr[3] = src ^ port;
    7160:	8b 8d c0 fe ff ff    	mov    -0x140(%rbp),%ecx
    7166:	0f b7 85 c6 fe ff ff 	movzwl -0x13a(%rbp),%eax
    716d:	31 c1                	xor    %eax,%ecx
    716f:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
    7176:	89 48 0c             	mov    %ecx,0xc(%rax)
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    7179:	8b 85 74 f7 ff ff    	mov    -0x88c(%rbp),%eax
    717f:	48 83 c0 28          	add    $0x28,%rax
    7183:	66 89 85 46 f7 ff ff 	mov    %ax,-0x8ba(%rbp)
  } else {
    718a:	e9 85 00 00 00       	jmp    7214 <balancer_ingress+0x7214>
    proto = IPPROTO_IPIP;
    718f:	c6 85 2f f7 ff ff 04 	movb   $0x4,-0x8d1(%rbp)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
    7196:	48 8b 85 80 f7 ff ff 	mov    -0x880(%rbp),%rax
    719d:	66 8b 50 20          	mov    0x20(%rax),%dx
    71a1:	48 8b 85 80 f7 ff ff 	mov    -0x880(%rbp),%rax
    71a8:	8b 08                	mov    (%rax),%ecx
    71aa:	48 8d 85 30 f7 ff ff 	lea    -0x8d0(%rbp),%rax
    71b1:	66 89 95 d6 fe ff ff 	mov    %dx,-0x12a(%rbp)
    71b8:	89 8d d0 fe ff ff    	mov    %ecx,-0x130(%rbp)
    71be:	48 89 85 c8 fe ff ff 	mov    %rax,-0x138(%rbp)
  saddr[0] = IPIP_V6_PREFIX1;
    71c5:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
    71cc:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
  saddr[1] = IPIP_V6_PREFIX2;
    71d2:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
    71d9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  saddr[2] = IPIP_V6_PREFIX3;
    71e0:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
    71e7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  saddr[3] = src ^ port;
    71ee:	8b 8d d0 fe ff ff    	mov    -0x130(%rbp),%ecx
    71f4:	0f b7 85 d6 fe ff ff 	movzwl -0x12a(%rbp),%eax
    71fb:	31 c1                	xor    %eax,%ecx
    71fd:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
    7204:	89 48 0c             	mov    %ecx,0xc(%rax)
    payload_len = pkt_bytes;
    7207:	8b 85 74 f7 ff ff    	mov    -0x88c(%rbp),%eax
    720d:	66 89 85 46 f7 ff ff 	mov    %ax,-0x8ba(%rbp)
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    7214:	4c 8b 85 58 f7 ff ff 	mov    -0x8a8(%rbp),%r8
    721b:	48 8b 85 80 f7 ff ff 	mov    -0x880(%rbp),%rax
    7222:	40 8a 78 2d          	mov    0x2d(%rax),%dil
    7226:	48 8d b5 30 f7 ff ff 	lea    -0x8d0(%rbp),%rsi
    722d:	48 8b 95 78 f7 ff ff 	mov    -0x888(%rbp),%rdx
    7234:	66 8b 8d 46 f7 ff ff 	mov    -0x8ba(%rbp),%cx
    723b:	8a 85 2f f7 ff ff    	mov    -0x8d1(%rbp),%al
    7241:	4c 89 85 18 ff ff ff 	mov    %r8,-0xe8(%rbp)
    7248:	40 88 bd 17 ff ff ff 	mov    %dil,-0xe9(%rbp)
    724f:	48 89 b5 08 ff ff ff 	mov    %rsi,-0xf8(%rbp)
    7256:	48 89 95 00 ff ff ff 	mov    %rdx,-0x100(%rbp)
    725d:	66 89 8d fe fe ff ff 	mov    %cx,-0x102(%rbp)
    7264:	88 85 fd fe ff ff    	mov    %al,-0x103(%rbp)
  ip6h->version = 6;
    726a:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
    7271:	8a 08                	mov    (%rax),%cl
    7273:	80 e1 0f             	and    $0xf,%cl
    7276:	80 c9 60             	or     $0x60,%cl
    7279:	88 08                	mov    %cl,(%rax)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    727b:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
    7282:	48 83 c0 01          	add    $0x1,%rax
    7286:	31 c9                	xor    %ecx,%ecx
    7288:	c6 40 02 00          	movb   $0x0,0x2(%rax)
    728c:	66 c7 00 00 00       	movw   $0x0,(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    7291:	0f b6 85 17 ff ff ff 	movzbl -0xe9(%rbp),%eax
    7298:	25 f0 00 00 00       	and    $0xf0,%eax
    729d:	c1 f8 04             	sar    $0x4,%eax
    72a0:	88 c2                	mov    %al,%dl
    72a2:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
    72a9:	8a 08                	mov    (%rax),%cl
    72ab:	80 e2 0f             	and    $0xf,%dl
    72ae:	80 e1 f0             	and    $0xf0,%cl
    72b1:	08 d1                	or     %dl,%cl
    72b3:	88 08                	mov    %cl,(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    72b5:	0f b6 85 17 ff ff ff 	movzbl -0xe9(%rbp),%eax
    72bc:	83 e0 0f             	and    $0xf,%eax
    72bf:	c1 e0 04             	shl    $0x4,%eax
    72c2:	88 c1                	mov    %al,%cl
    72c4:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
    72cb:	88 48 01             	mov    %cl,0x1(%rax)
  ip6h->nexthdr = proto;
    72ce:	8a 8d fd fe ff ff    	mov    -0x103(%rbp),%cl
    72d4:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
    72db:	88 48 06             	mov    %cl,0x6(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    72de:	66 8b 85 fe fe ff ff 	mov    -0x102(%rbp),%ax
    72e5:	66 c1 c0 08          	rol    $0x8,%ax
    72e9:	0f b7 c0             	movzwl %ax,%eax
    72ec:	89 85 18 e8 ff ff    	mov    %eax,-0x17e8(%rbp)
    72f2:	8b 85 18 e8 ff ff    	mov    -0x17e8(%rbp),%eax
    72f8:	66 89 c1             	mov    %ax,%cx
    72fb:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
    7302:	66 89 48 04          	mov    %cx,0x4(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
    7306:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
    730d:	c6 40 07 40          	movb   $0x40,0x7(%rax)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    7311:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
    7318:	48 8b 8d 08 ff ff ff 	mov    -0xf8(%rbp),%rcx
    731f:	48 8b 11             	mov    (%rcx),%rdx
    7322:	48 89 50 08          	mov    %rdx,0x8(%rax)
    7326:	48 8b 49 08          	mov    0x8(%rcx),%rcx
    732a:	48 89 48 10          	mov    %rcx,0x10(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    732e:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
    7335:	48 8b 8d 00 ff ff ff 	mov    -0x100(%rbp),%rcx
    733c:	48 8b 11             	mov    (%rcx),%rdx
    733f:	48 89 50 18          	mov    %rdx,0x18(%rax)
    7343:	48 8b 49 08          	mov    0x8(%rcx),%rcx
    7347:	48 89 48 20          	mov    %rcx,0x20(%rax)
  return true;
    734b:	c6 85 a7 f7 ff ff 01 	movb   $0x1,-0x859(%rbp)
    7352:	f6 85 a7 f7 ff ff 01 	testb  $0x1,-0x859(%rbp)
    7359:	75 0f                	jne    736a <balancer_ingress+0x736a>
      return XDP_DROP;
    735b:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    7362:	00 00 00 
    7365:	e9 ef 03 00 00       	jmp    7759 <balancer_ingress+0x7759>
  } else {
    736a:	e9 e0 03 00 00       	jmp    774f <balancer_ingress+0x774f>
    if (!PCKT_ENCAP_V4(xdp, cval, &pckt, dst, pkt_bytes)) {
    736f:	48 8b b5 40 eb ff ff 	mov    -0x14c0(%rbp),%rsi
    7376:	48 8b 95 18 eb ff ff 	mov    -0x14e8(%rbp),%rdx
    737d:	48 8b 8d 10 eb ff ff 	mov    -0x14f0(%rbp),%rcx
    7384:	0f b7 85 a6 ea ff ff 	movzwl -0x155a(%rbp),%eax
    738b:	48 89 b5 68 f8 ff ff 	mov    %rsi,-0x798(%rbp)
    7392:	48 89 95 60 f8 ff ff 	mov    %rdx,-0x7a0(%rbp)
    7399:	48 8d 95 e0 ea ff ff 	lea    -0x1520(%rbp),%rdx
    73a0:	48 89 95 58 f8 ff ff 	mov    %rdx,-0x7a8(%rbp)
    73a7:	48 89 8d 50 f8 ff ff 	mov    %rcx,-0x7b0(%rbp)
    73ae:	89 85 4c f8 ff ff    	mov    %eax,-0x7b4(%rbp)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    73b4:	48 8b 85 58 f8 ff ff 	mov    -0x7a8(%rbp),%rax
    73bb:	66 8b 48 20          	mov    0x20(%rax),%cx
    73bf:	48 8b 85 58 f8 ff ff 	mov    -0x7a8(%rbp),%rax
    73c6:	8b 00                	mov    (%rax),%eax
    73c8:	66 89 8d 52 ff ff ff 	mov    %cx,-0xae(%rbp)
    73cf:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  __u32 ip_suffix = bpf_htons(port);
    73d5:	66 8b 85 52 ff ff ff 	mov    -0xae(%rbp),%ax
    73dc:	66 c1 c0 08          	rol    $0x8,%ax
    73e0:	0f b7 c0             	movzwl %ax,%eax
    73e3:	89 85 14 e8 ff ff    	mov    %eax,-0x17ec(%rbp)
    73e9:	8b 85 14 e8 ff ff    	mov    -0x17ec(%rbp),%eax
    73ef:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
  ip_suffix <<= 16;
    73f5:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
    73fb:	c1 e0 10             	shl    $0x10,%eax
    73fe:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
  ip_suffix ^= src;
    7404:	8b 8d 4c ff ff ff    	mov    -0xb4(%rbp),%ecx
    740a:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
    7410:	31 c8                	xor    %ecx,%eax
    7412:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
  return ((0xFFFF0000 & ip_suffix) | IPIP_V4_PREFIX);
    7418:	0f b7 85 4a ff ff ff 	movzwl -0xb6(%rbp),%eax
    741f:	c1 e0 10             	shl    $0x10,%eax
    7422:	0d ac 10 00 00       	or     $0x10ac,%eax
    7427:	89 85 1c f8 ff ff    	mov    %eax,-0x7e4(%rbp)
  __u64 csum = 0;
    742d:	48 c7 85 10 f8 ff ff 	movq   $0x0,-0x7f0(%rbp)
    7434:	00 00 00 00 
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    7438:	48 b8 a0 7f 00 00 00 	movabs $0x7fa0,%rax
    743f:	00 00 00 
    7442:	48 8b 00             	mov    (%rax),%rax
    7445:	48 8b bd 68 f8 ff ff 	mov    -0x798(%rbp),%rdi
    744c:	be ec ff ff ff       	mov    $0xffffffec,%esi
    7451:	ff d0                	call   *%rax
    7453:	83 f8 00             	cmp    $0x0,%eax
    7456:	74 0c                	je     7464 <balancer_ingress+0x7464>
    return false;
    7458:	c6 85 73 f8 ff ff 00 	movb   $0x0,-0x78d(%rbp)
    745f:	e9 d4 02 00 00       	jmp    7738 <balancer_ingress+0x7738>
  data = (void*)(long)xdp->data;
    7464:	48 8b 85 68 f8 ff ff 	mov    -0x798(%rbp),%rax
    746b:	48 8b 00             	mov    (%rax),%rax
    746e:	48 89 85 40 f8 ff ff 	mov    %rax,-0x7c0(%rbp)
  data_end = (void*)(long)xdp->data_end;
    7475:	48 8b 85 68 f8 ff ff 	mov    -0x798(%rbp),%rax
    747c:	48 8b 40 08          	mov    0x8(%rax),%rax
    7480:	48 89 85 38 f8 ff ff 	mov    %rax,-0x7c8(%rbp)
  new_eth = data;
    7487:	48 8b 85 40 f8 ff ff 	mov    -0x7c0(%rbp),%rax
    748e:	48 89 85 28 f8 ff ff 	mov    %rax,-0x7d8(%rbp)
  iph = data + sizeof(struct ethhdr);
    7495:	48 8b 85 40 f8 ff ff 	mov    -0x7c0(%rbp),%rax
    749c:	48 83 c0 0e          	add    $0xe,%rax
    74a0:	48 89 85 30 f8 ff ff 	mov    %rax,-0x7d0(%rbp)
  old_eth = data + sizeof(struct iphdr);
    74a7:	48 8b 85 40 f8 ff ff 	mov    -0x7c0(%rbp),%rax
    74ae:	48 83 c0 14          	add    $0x14,%rax
    74b2:	48 89 85 20 f8 ff ff 	mov    %rax,-0x7e0(%rbp)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    74b9:	48 8b 85 28 f8 ff ff 	mov    -0x7d8(%rbp),%rax
    74c0:	48 83 c0 0e          	add    $0xe,%rax
    74c4:	48 8b 8d 38 f8 ff ff 	mov    -0x7c8(%rbp),%rcx
    74cb:	48 39 c8             	cmp    %rcx,%rax
    74ce:	77 2e                	ja     74fe <balancer_ingress+0x74fe>
    74d0:	48 8b 85 20 f8 ff ff 	mov    -0x7e0(%rbp),%rax
    74d7:	48 83 c0 0e          	add    $0xe,%rax
    74db:	48 8b 8d 38 f8 ff ff 	mov    -0x7c8(%rbp),%rcx
    74e2:	48 39 c8             	cmp    %rcx,%rax
    74e5:	77 17                	ja     74fe <balancer_ingress+0x74fe>
    74e7:	48 8b 85 30 f8 ff ff 	mov    -0x7d0(%rbp),%rax
    74ee:	48 83 c0 14          	add    $0x14,%rax
    74f2:	48 8b 8d 38 f8 ff ff 	mov    -0x7c8(%rbp),%rcx
    74f9:	48 39 c8             	cmp    %rcx,%rax
    74fc:	76 0c                	jbe    750a <balancer_ingress+0x750a>
    return false;
    74fe:	c6 85 73 f8 ff ff 00 	movb   $0x0,-0x78d(%rbp)
    7505:	e9 2e 02 00 00       	jmp    7738 <balancer_ingress+0x7738>
  memcpy(new_eth->h_dest, cval->mac, 6);
    750a:	48 8b 85 28 f8 ff ff 	mov    -0x7d8(%rbp),%rax
    7511:	48 8b 8d 60 f8 ff ff 	mov    -0x7a0(%rbp),%rcx
    7518:	8b 11                	mov    (%rcx),%edx
    751a:	89 10                	mov    %edx,(%rax)
    751c:	66 8b 49 04          	mov    0x4(%rcx),%cx
    7520:	66 89 48 04          	mov    %cx,0x4(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    7524:	48 8b 85 28 f8 ff ff 	mov    -0x7d8(%rbp),%rax
    752b:	48 8b 8d 20 f8 ff ff 	mov    -0x7e0(%rbp),%rcx
    7532:	8b 11                	mov    (%rcx),%edx
    7534:	89 50 06             	mov    %edx,0x6(%rax)
    7537:	66 8b 49 04          	mov    0x4(%rcx),%cx
    753b:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    753f:	48 8b 85 28 f8 ff ff 	mov    -0x7d8(%rbp),%rax
    7546:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    754c:	48 8b bd 30 f8 ff ff 	mov    -0x7d0(%rbp),%rdi
    7553:	48 8b 85 58 f8 ff ff 	mov    -0x7a8(%rbp),%rax
    755a:	40 8a 70 2d          	mov    0x2d(%rax),%sil
    755e:	8b 95 1c f8 ff ff    	mov    -0x7e4(%rbp),%edx
    7564:	48 8b 85 50 f8 ff ff 	mov    -0x7b0(%rbp),%rax
    756b:	8b 08                	mov    (%rax),%ecx
    756d:	8b 85 4c f8 ff ff    	mov    -0x7b4(%rbp),%eax
    7573:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
    757a:	40 88 b5 77 ff ff ff 	mov    %sil,-0x89(%rbp)
    7581:	89 95 70 ff ff ff    	mov    %edx,-0x90(%rbp)
    7587:	89 8d 6c ff ff ff    	mov    %ecx,-0x94(%rbp)
    758d:	66 89 85 6a ff ff ff 	mov    %ax,-0x96(%rbp)
    7594:	c6 85 69 ff ff ff 04 	movb   $0x4,-0x97(%rbp)
  __u64 csum = 0;
    759b:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
    75a2:	00 00 00 00 
  iph->version = 4;
    75a6:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    75ad:	8a 08                	mov    (%rax),%cl
    75af:	80 e1 0f             	and    $0xf,%cl
    75b2:	80 c9 40             	or     $0x40,%cl
    75b5:	88 08                	mov    %cl,(%rax)
  iph->ihl = 5;
    75b7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    75be:	8a 08                	mov    (%rax),%cl
    75c0:	80 e1 f0             	and    $0xf0,%cl
    75c3:	80 c9 05             	or     $0x5,%cl
    75c6:	88 08                	mov    %cl,(%rax)
  iph->frag_off = 0;
    75c8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    75cf:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
  iph->protocol = proto;
    75d5:	8a 8d 69 ff ff ff    	mov    -0x97(%rbp),%cl
    75db:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    75e2:	88 48 09             	mov    %cl,0x9(%rax)
  iph->check = 0;
    75e5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    75ec:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  iph->tos = tos;
    75f2:	8a 8d 77 ff ff ff    	mov    -0x89(%rbp),%cl
    75f8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    75ff:	88 48 01             	mov    %cl,0x1(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    7602:	0f b7 85 6a ff ff ff 	movzwl -0x96(%rbp),%eax
    7609:	48 83 c0 14          	add    $0x14,%rax
    760d:	66 c1 c0 08          	rol    $0x8,%ax
    7611:	0f b7 c0             	movzwl %ax,%eax
    7614:	89 85 10 e8 ff ff    	mov    %eax,-0x17f0(%rbp)
    761a:	8b 85 10 e8 ff ff    	mov    -0x17f0(%rbp),%eax
    7620:	66 89 c1             	mov    %ax,%cx
    7623:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    762a:	66 89 48 02          	mov    %cx,0x2(%rax)
  iph->id = 0;
    762e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    7635:	66 c7 40 04 00 00    	movw   $0x0,0x4(%rax)
  iph->daddr = daddr;
    763b:	8b 8d 6c ff ff ff    	mov    -0x94(%rbp),%ecx
    7641:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    7648:	89 48 10             	mov    %ecx,0x10(%rax)
  iph->saddr = saddr;
    764b:	8b 8d 70 ff ff ff    	mov    -0x90(%rbp),%ecx
    7651:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    7658:	89 48 0c             	mov    %ecx,0xc(%rax)
  iph->ttl = DEFAULT_TTL;
    765b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    7662:	c6 40 08 40          	movb   $0x40,0x8(%rax)
  ipv4_csum_inline(iph, &csum);
    7666:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    766d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    7671:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
    7678:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  __u16* next_iph_u16 = (__u16*)iph;
    767c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    7680:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    7684:	c7 45 84 00 00 00 00 	movl   $0x0,-0x7c(%rbp)
    768b:	48 63 45 84          	movslq -0x7c(%rbp),%rax
    768f:	48 83 f8 0a          	cmp    $0xa,%rax
    7693:	73 29                	jae    76be <balancer_ingress+0x76be>
    *csum += *next_iph_u16++;
    7695:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    7699:	48 89 c1             	mov    %rax,%rcx
    769c:	48 83 c1 02          	add    $0x2,%rcx
    76a0:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
    76a4:	0f b7 00             	movzwl (%rax),%eax
    76a7:	89 c1                	mov    %eax,%ecx
    76a9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    76ad:	48 03 08             	add    (%rax),%rcx
    76b0:	48 89 08             	mov    %rcx,(%rax)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    76b3:	8b 45 84             	mov    -0x7c(%rbp),%eax
    76b6:	83 c0 01             	add    $0x1,%eax
    76b9:	89 45 84             	mov    %eax,-0x7c(%rbp)
    76bc:	eb cd                	jmp    768b <balancer_ingress+0x768b>
  *csum = csum_fold_helper(*csum);
    76be:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    76c2:	48 8b 00             	mov    (%rax),%rax
    76c5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  for (i = 0; i < 4; i++) {
    76c9:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%rbp)
    76d0:	83 7d a4 04          	cmpl   $0x4,-0x5c(%rbp)
    76d4:	7d 32                	jge    7708 <balancer_ingress+0x7708>
    if (csum >> 16)
    76d6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    76da:	48 c1 e8 10          	shr    $0x10,%rax
    76de:	48 83 f8 00          	cmp    $0x0,%rax
    76e2:	74 19                	je     76fd <balancer_ingress+0x76fd>
      csum = (csum & 0xffff) + (csum >> 16);
    76e4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    76e8:	48 25 ff ff 00 00    	and    $0xffff,%rax
    76ee:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
    76f2:	48 c1 e9 10          	shr    $0x10,%rcx
    76f6:	48 01 c8             	add    %rcx,%rax
    76f9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  for (i = 0; i < 4; i++) {
    76fd:	8b 45 a4             	mov    -0x5c(%rbp),%eax
    7700:	83 c0 01             	add    $0x1,%eax
    7703:	89 45 a4             	mov    %eax,-0x5c(%rbp)
    7706:	eb c8                	jmp    76d0 <balancer_ingress+0x76d0>
  return ~csum;
    7708:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    770c:	48 83 f0 ff          	xor    $0xffffffffffffffff,%rax
  *csum = csum_fold_helper(*csum);
    7710:	0f b7 c0             	movzwl %ax,%eax
    7713:	89 c1                	mov    %eax,%ecx
    7715:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    7719:	48 89 08             	mov    %rcx,(%rax)
  iph->check = csum;
    771c:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
    7723:	66 89 c1             	mov    %ax,%cx
    7726:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    772d:	66 89 48 0a          	mov    %cx,0xa(%rax)
  return true;
    7731:	c6 85 73 f8 ff ff 01 	movb   $0x1,-0x78d(%rbp)
    7738:	f6 85 73 f8 ff ff 01 	testb  $0x1,-0x78d(%rbp)
    773f:	75 0c                	jne    774d <balancer_ingress+0x774d>
      return XDP_DROP;
    7741:	c7 85 4c eb ff ff 01 	movl   $0x1,-0x14b4(%rbp)
    7748:	00 00 00 
    774b:	eb 0c                	jmp    7759 <balancer_ingress+0x7759>
    774d:	eb 00                	jmp    774f <balancer_ingress+0x774f>
  return XDP_TX;
    774f:	c7 85 4c eb ff ff 03 	movl   $0x3,-0x14b4(%rbp)
    7756:	00 00 00 
}
    7759:	8b 85 4c eb ff ff    	mov    -0x14b4(%rbp),%eax
    return process_packet(ctx, nh_off, true);
    775f:	89 85 84 e8 ff ff    	mov    %eax,-0x177c(%rbp)
    7765:	eb 0a                	jmp    7771 <balancer_ingress+0x7771>
  } else {
    // pass to tcp/ip stack
    return XDP_PASS;
    7767:	c7 85 84 e8 ff ff 02 	movl   $0x2,-0x177c(%rbp)
    776e:	00 00 00 
  }
}
    7771:	8b 85 84 e8 ff ff    	mov    -0x177c(%rbp),%eax
    7777:	48 81 c4 f0 17 00 00 	add    $0x17f0,%rsp
    777e:	5d                   	pop    %rbp
    777f:	c3                   	ret

Disassembly of section .text.jhash:

0000000000007780 <jhash>:

#define JHASH_INITVAL 0xdeadbeef

typedef unsigned int u32;

static inline u32 jhash(const void* key, u32 length, u32 initval) {
    7780:	55                   	push   %rbp
    7781:	48 89 e5             	mov    %rsp,%rbp
    7784:	48 83 ec 30          	sub    $0x30,%rsp
    7788:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    778c:	89 75 f4             	mov    %esi,-0xc(%rbp)
    778f:	89 55 f0             	mov    %edx,-0x10(%rbp)
  u32 a, b, c;
  const unsigned char* k = key;
    7792:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    7796:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  a = b = c = JHASH_INITVAL + length + initval;
    779a:	8b 45 f4             	mov    -0xc(%rbp),%eax
    779d:	05 ef be ad de       	add    $0xdeadbeef,%eax
    77a2:	03 45 f0             	add    -0x10(%rbp),%eax
    77a5:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    77a8:	89 45 e8             	mov    %eax,-0x18(%rbp)
    77ab:	89 45 ec             	mov    %eax,-0x14(%rbp)

  while (length > 12) {
    77ae:	83 7d f4 0c          	cmpl   $0xc,-0xc(%rbp)
    77b2:	0f 86 2a 01 00 00    	jbe    78e2 <jhash+0x162>
    a += *(u32*)(k);
    77b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    77bc:	8b 00                	mov    (%rax),%eax
    77be:	03 45 ec             	add    -0x14(%rbp),%eax
    77c1:	89 45 ec             	mov    %eax,-0x14(%rbp)
    b += *(u32*)(k + 4);
    77c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    77c8:	8b 40 04             	mov    0x4(%rax),%eax
    77cb:	03 45 e8             	add    -0x18(%rbp),%eax
    77ce:	89 45 e8             	mov    %eax,-0x18(%rbp)
    c += *(u32*)(k + 8);
    77d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    77d5:	8b 40 08             	mov    0x8(%rax),%eax
    77d8:	03 45 e4             	add    -0x1c(%rbp),%eax
    77db:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    __jhash_mix(a, b, c);
    77de:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
    77e1:	8b 45 ec             	mov    -0x14(%rbp),%eax
    77e4:	29 c8                	sub    %ecx,%eax
    77e6:	89 45 ec             	mov    %eax,-0x14(%rbp)
    77e9:	8b 7d e4             	mov    -0x1c(%rbp),%edi
    77ec:	be 04 00 00 00       	mov    $0x4,%esi
    77f1:	e8 aa 04 00 00       	call   7ca0 <rol32>
    77f6:	33 45 ec             	xor    -0x14(%rbp),%eax
    77f9:	89 45 ec             	mov    %eax,-0x14(%rbp)
    77fc:	8b 45 e8             	mov    -0x18(%rbp),%eax
    77ff:	03 45 e4             	add    -0x1c(%rbp),%eax
    7802:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    7805:	8b 4d ec             	mov    -0x14(%rbp),%ecx
    7808:	8b 45 e8             	mov    -0x18(%rbp),%eax
    780b:	29 c8                	sub    %ecx,%eax
    780d:	89 45 e8             	mov    %eax,-0x18(%rbp)
    7810:	8b 7d ec             	mov    -0x14(%rbp),%edi
    7813:	be 06 00 00 00       	mov    $0x6,%esi
    7818:	e8 83 04 00 00       	call   7ca0 <rol32>
    781d:	33 45 e8             	xor    -0x18(%rbp),%eax
    7820:	89 45 e8             	mov    %eax,-0x18(%rbp)
    7823:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    7826:	03 45 ec             	add    -0x14(%rbp),%eax
    7829:	89 45 ec             	mov    %eax,-0x14(%rbp)
    782c:	8b 4d e8             	mov    -0x18(%rbp),%ecx
    782f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    7832:	29 c8                	sub    %ecx,%eax
    7834:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    7837:	8b 7d e8             	mov    -0x18(%rbp),%edi
    783a:	be 08 00 00 00       	mov    $0x8,%esi
    783f:	e8 5c 04 00 00       	call   7ca0 <rol32>
    7844:	33 45 e4             	xor    -0x1c(%rbp),%eax
    7847:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    784a:	8b 45 ec             	mov    -0x14(%rbp),%eax
    784d:	03 45 e8             	add    -0x18(%rbp),%eax
    7850:	89 45 e8             	mov    %eax,-0x18(%rbp)
    7853:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
    7856:	8b 45 ec             	mov    -0x14(%rbp),%eax
    7859:	29 c8                	sub    %ecx,%eax
    785b:	89 45 ec             	mov    %eax,-0x14(%rbp)
    785e:	8b 7d e4             	mov    -0x1c(%rbp),%edi
    7861:	be 10 00 00 00       	mov    $0x10,%esi
    7866:	e8 35 04 00 00       	call   7ca0 <rol32>
    786b:	33 45 ec             	xor    -0x14(%rbp),%eax
    786e:	89 45 ec             	mov    %eax,-0x14(%rbp)
    7871:	8b 45 e8             	mov    -0x18(%rbp),%eax
    7874:	03 45 e4             	add    -0x1c(%rbp),%eax
    7877:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    787a:	8b 4d ec             	mov    -0x14(%rbp),%ecx
    787d:	8b 45 e8             	mov    -0x18(%rbp),%eax
    7880:	29 c8                	sub    %ecx,%eax
    7882:	89 45 e8             	mov    %eax,-0x18(%rbp)
    7885:	8b 7d ec             	mov    -0x14(%rbp),%edi
    7888:	be 13 00 00 00       	mov    $0x13,%esi
    788d:	e8 0e 04 00 00       	call   7ca0 <rol32>
    7892:	33 45 e8             	xor    -0x18(%rbp),%eax
    7895:	89 45 e8             	mov    %eax,-0x18(%rbp)
    7898:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    789b:	03 45 ec             	add    -0x14(%rbp),%eax
    789e:	89 45 ec             	mov    %eax,-0x14(%rbp)
    78a1:	8b 4d e8             	mov    -0x18(%rbp),%ecx
    78a4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    78a7:	29 c8                	sub    %ecx,%eax
    78a9:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    78ac:	8b 7d e8             	mov    -0x18(%rbp),%edi
    78af:	be 04 00 00 00       	mov    $0x4,%esi
    78b4:	e8 e7 03 00 00       	call   7ca0 <rol32>
    78b9:	33 45 e4             	xor    -0x1c(%rbp),%eax
    78bc:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    78bf:	8b 45 ec             	mov    -0x14(%rbp),%eax
    78c2:	03 45 e8             	add    -0x18(%rbp),%eax
    78c5:	89 45 e8             	mov    %eax,-0x18(%rbp)
    length -= 12;
    78c8:	8b 45 f4             	mov    -0xc(%rbp),%eax
    78cb:	83 e8 0c             	sub    $0xc,%eax
    78ce:	89 45 f4             	mov    %eax,-0xc(%rbp)
    k += 12;
    78d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    78d5:	48 83 c0 0c          	add    $0xc,%rax
    78d9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  while (length > 12) {
    78dd:	e9 cc fe ff ff       	jmp    77ae <jhash+0x2e>
  }
  switch (length) {
    78e2:	8b 45 f4             	mov    -0xc(%rbp),%eax
    78e5:	89 45 d4             	mov    %eax,-0x2c(%rbp)
    78e8:	85 c0                	test   %eax,%eax
    78ea:	0f 84 3c 02 00 00    	je     7b2c <jhash+0x3ac>
    78f0:	eb 00                	jmp    78f2 <jhash+0x172>
    78f2:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    78f5:	83 e8 01             	sub    $0x1,%eax
    78f8:	0f 84 41 01 00 00    	je     7a3f <jhash+0x2bf>
    78fe:	eb 00                	jmp    7900 <jhash+0x180>
    7900:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    7903:	83 e8 02             	sub    $0x2,%eax
    7906:	0f 84 22 01 00 00    	je     7a2e <jhash+0x2ae>
    790c:	eb 00                	jmp    790e <jhash+0x18e>
    790e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    7911:	83 e8 03             	sub    $0x3,%eax
    7914:	0f 84 03 01 00 00    	je     7a1d <jhash+0x29d>
    791a:	eb 00                	jmp    791c <jhash+0x19c>
    791c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    791f:	83 e8 04             	sub    $0x4,%eax
    7922:	0f 84 e4 00 00 00    	je     7a0c <jhash+0x28c>
    7928:	eb 00                	jmp    792a <jhash+0x1aa>
    792a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    792d:	83 e8 05             	sub    $0x5,%eax
    7930:	0f 84 c8 00 00 00    	je     79fe <jhash+0x27e>
    7936:	eb 00                	jmp    7938 <jhash+0x1b8>
    7938:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    793b:	83 e8 06             	sub    $0x6,%eax
    793e:	0f 84 a9 00 00 00    	je     79ed <jhash+0x26d>
    7944:	eb 00                	jmp    7946 <jhash+0x1c6>
    7946:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    7949:	83 e8 07             	sub    $0x7,%eax
    794c:	0f 84 8a 00 00 00    	je     79dc <jhash+0x25c>
    7952:	eb 00                	jmp    7954 <jhash+0x1d4>
    7954:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    7957:	83 e8 08             	sub    $0x8,%eax
    795a:	74 6f                	je     79cb <jhash+0x24b>
    795c:	eb 00                	jmp    795e <jhash+0x1de>
    795e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    7961:	83 e8 09             	sub    $0x9,%eax
    7964:	74 57                	je     79bd <jhash+0x23d>
    7966:	eb 00                	jmp    7968 <jhash+0x1e8>
    7968:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    796b:	83 e8 0a             	sub    $0xa,%eax
    796e:	74 3c                	je     79ac <jhash+0x22c>
    7970:	eb 00                	jmp    7972 <jhash+0x1f2>
    7972:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    7975:	83 e8 0b             	sub    $0xb,%eax
    7978:	74 21                	je     799b <jhash+0x21b>
    797a:	eb 00                	jmp    797c <jhash+0x1fc>
    797c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    797f:	83 e8 0c             	sub    $0xc,%eax
    7982:	0f 85 a6 01 00 00    	jne    7b2e <jhash+0x3ae>
    7988:	eb 00                	jmp    798a <jhash+0x20a>
    case 12:
      c += (u32)k[11] << 24;
    798a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    798e:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
    7992:	c1 e0 18             	shl    $0x18,%eax
    7995:	03 45 e4             	add    -0x1c(%rbp),%eax
    7998:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    case 11:
      c += (u32)k[10] << 16;
    799b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    799f:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
    79a3:	c1 e0 10             	shl    $0x10,%eax
    79a6:	03 45 e4             	add    -0x1c(%rbp),%eax
    79a9:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    case 10:
      c += (u32)k[9] << 8;
    79ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    79b0:	0f b6 40 09          	movzbl 0x9(%rax),%eax
    79b4:	c1 e0 08             	shl    $0x8,%eax
    79b7:	03 45 e4             	add    -0x1c(%rbp),%eax
    79ba:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    case 9:
      c += k[8];
    79bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    79c1:	0f b6 40 08          	movzbl 0x8(%rax),%eax
    79c5:	03 45 e4             	add    -0x1c(%rbp),%eax
    79c8:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    case 8:
      b += (u32)k[7] << 24;
    79cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    79cf:	0f b6 40 07          	movzbl 0x7(%rax),%eax
    79d3:	c1 e0 18             	shl    $0x18,%eax
    79d6:	03 45 e8             	add    -0x18(%rbp),%eax
    79d9:	89 45 e8             	mov    %eax,-0x18(%rbp)
    case 7:
      b += (u32)k[6] << 16;
    79dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    79e0:	0f b6 40 06          	movzbl 0x6(%rax),%eax
    79e4:	c1 e0 10             	shl    $0x10,%eax
    79e7:	03 45 e8             	add    -0x18(%rbp),%eax
    79ea:	89 45 e8             	mov    %eax,-0x18(%rbp)
    case 6:
      b += (u32)k[5] << 8;
    79ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    79f1:	0f b6 40 05          	movzbl 0x5(%rax),%eax
    79f5:	c1 e0 08             	shl    $0x8,%eax
    79f8:	03 45 e8             	add    -0x18(%rbp),%eax
    79fb:	89 45 e8             	mov    %eax,-0x18(%rbp)
    case 5:
      b += k[4];
    79fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    7a02:	0f b6 40 04          	movzbl 0x4(%rax),%eax
    7a06:	03 45 e8             	add    -0x18(%rbp),%eax
    7a09:	89 45 e8             	mov    %eax,-0x18(%rbp)
    case 4:
      a += (u32)k[3] << 24;
    7a0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    7a10:	0f b6 40 03          	movzbl 0x3(%rax),%eax
    7a14:	c1 e0 18             	shl    $0x18,%eax
    7a17:	03 45 ec             	add    -0x14(%rbp),%eax
    7a1a:	89 45 ec             	mov    %eax,-0x14(%rbp)
    case 3:
      a += (u32)k[2] << 16;
    7a1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    7a21:	0f b6 40 02          	movzbl 0x2(%rax),%eax
    7a25:	c1 e0 10             	shl    $0x10,%eax
    7a28:	03 45 ec             	add    -0x14(%rbp),%eax
    7a2b:	89 45 ec             	mov    %eax,-0x14(%rbp)
    case 2:
      a += (u32)k[1] << 8;
    7a2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    7a32:	0f b6 40 01          	movzbl 0x1(%rax),%eax
    7a36:	c1 e0 08             	shl    $0x8,%eax
    7a39:	03 45 ec             	add    -0x14(%rbp),%eax
    7a3c:	89 45 ec             	mov    %eax,-0x14(%rbp)
    case 1:
      a += k[0];
    7a3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    7a43:	0f b6 00             	movzbl (%rax),%eax
    7a46:	03 45 ec             	add    -0x14(%rbp),%eax
    7a49:	89 45 ec             	mov    %eax,-0x14(%rbp)
      __jhash_final(a, b, c);
    7a4c:	8b 45 e8             	mov    -0x18(%rbp),%eax
    7a4f:	33 45 e4             	xor    -0x1c(%rbp),%eax
    7a52:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    7a55:	8b 7d e8             	mov    -0x18(%rbp),%edi
    7a58:	be 0e 00 00 00       	mov    $0xe,%esi
    7a5d:	e8 3e 02 00 00       	call   7ca0 <rol32>
    7a62:	89 c1                	mov    %eax,%ecx
    7a64:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    7a67:	29 c8                	sub    %ecx,%eax
    7a69:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    7a6c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    7a6f:	33 45 ec             	xor    -0x14(%rbp),%eax
    7a72:	89 45 ec             	mov    %eax,-0x14(%rbp)
    7a75:	8b 7d e4             	mov    -0x1c(%rbp),%edi
    7a78:	be 0b 00 00 00       	mov    $0xb,%esi
    7a7d:	e8 1e 02 00 00       	call   7ca0 <rol32>
    7a82:	89 c1                	mov    %eax,%ecx
    7a84:	8b 45 ec             	mov    -0x14(%rbp),%eax
    7a87:	29 c8                	sub    %ecx,%eax
    7a89:	89 45 ec             	mov    %eax,-0x14(%rbp)
    7a8c:	8b 45 ec             	mov    -0x14(%rbp),%eax
    7a8f:	33 45 e8             	xor    -0x18(%rbp),%eax
    7a92:	89 45 e8             	mov    %eax,-0x18(%rbp)
    7a95:	8b 7d ec             	mov    -0x14(%rbp),%edi
    7a98:	be 19 00 00 00       	mov    $0x19,%esi
    7a9d:	e8 fe 01 00 00       	call   7ca0 <rol32>
    7aa2:	89 c1                	mov    %eax,%ecx
    7aa4:	8b 45 e8             	mov    -0x18(%rbp),%eax
    7aa7:	29 c8                	sub    %ecx,%eax
    7aa9:	89 45 e8             	mov    %eax,-0x18(%rbp)
    7aac:	8b 45 e8             	mov    -0x18(%rbp),%eax
    7aaf:	33 45 e4             	xor    -0x1c(%rbp),%eax
    7ab2:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    7ab5:	8b 7d e8             	mov    -0x18(%rbp),%edi
    7ab8:	be 10 00 00 00       	mov    $0x10,%esi
    7abd:	e8 de 01 00 00       	call   7ca0 <rol32>
    7ac2:	89 c1                	mov    %eax,%ecx
    7ac4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    7ac7:	29 c8                	sub    %ecx,%eax
    7ac9:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    7acc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    7acf:	33 45 ec             	xor    -0x14(%rbp),%eax
    7ad2:	89 45 ec             	mov    %eax,-0x14(%rbp)
    7ad5:	8b 7d e4             	mov    -0x1c(%rbp),%edi
    7ad8:	be 04 00 00 00       	mov    $0x4,%esi
    7add:	e8 be 01 00 00       	call   7ca0 <rol32>
    7ae2:	89 c1                	mov    %eax,%ecx
    7ae4:	8b 45 ec             	mov    -0x14(%rbp),%eax
    7ae7:	29 c8                	sub    %ecx,%eax
    7ae9:	89 45 ec             	mov    %eax,-0x14(%rbp)
    7aec:	8b 45 ec             	mov    -0x14(%rbp),%eax
    7aef:	33 45 e8             	xor    -0x18(%rbp),%eax
    7af2:	89 45 e8             	mov    %eax,-0x18(%rbp)
    7af5:	8b 7d ec             	mov    -0x14(%rbp),%edi
    7af8:	be 0e 00 00 00       	mov    $0xe,%esi
    7afd:	e8 9e 01 00 00       	call   7ca0 <rol32>
    7b02:	89 c1                	mov    %eax,%ecx
    7b04:	8b 45 e8             	mov    -0x18(%rbp),%eax
    7b07:	29 c8                	sub    %ecx,%eax
    7b09:	89 45 e8             	mov    %eax,-0x18(%rbp)
    7b0c:	8b 45 e8             	mov    -0x18(%rbp),%eax
    7b0f:	33 45 e4             	xor    -0x1c(%rbp),%eax
    7b12:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    7b15:	8b 7d e8             	mov    -0x18(%rbp),%edi
    7b18:	be 18 00 00 00       	mov    $0x18,%esi
    7b1d:	e8 7e 01 00 00       	call   7ca0 <rol32>
    7b22:	89 c1                	mov    %eax,%ecx
    7b24:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    7b27:	29 c8                	sub    %ecx,%eax
    7b29:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    case 0: /* Nothing left to add */
      break;
    7b2c:	eb 00                	jmp    7b2e <jhash+0x3ae>
  }

  return c;
    7b2e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    7b31:	48 83 c4 30          	add    $0x30,%rsp
    7b35:	5d                   	pop    %rbp
    7b36:	c3                   	ret

Disassembly of section .text.jhash_2words:

0000000000007b40 <jhash_2words>:
  c += initval;
  __jhash_final(a, b, c);
  return c;
}

static inline u32 jhash_2words(u32 a, u32 b, u32 initval) {
    7b40:	55                   	push   %rbp
    7b41:	48 89 e5             	mov    %rsp,%rbp
    7b44:	48 83 ec 10          	sub    $0x10,%rsp
    7b48:	89 7d fc             	mov    %edi,-0x4(%rbp)
    7b4b:	89 75 f8             	mov    %esi,-0x8(%rbp)
    7b4e:	89 55 f4             	mov    %edx,-0xc(%rbp)
  return __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 << 2));
    7b51:	8b 7d fc             	mov    -0x4(%rbp),%edi
    7b54:	8b 75 f8             	mov    -0x8(%rbp),%esi
    7b57:	8b 4d f4             	mov    -0xc(%rbp),%ecx
    7b5a:	81 c1 ef be ad de    	add    $0xdeadbeef,%ecx
    7b60:	83 c1 08             	add    $0x8,%ecx
    7b63:	31 c0                	xor    %eax,%eax
    7b65:	31 d2                	xor    %edx,%edx
    7b67:	e8 14 00 00 00       	call   7b80 <__jhash_nwords>
    7b6c:	48 83 c4 10          	add    $0x10,%rsp
    7b70:	5d                   	pop    %rbp
    7b71:	c3                   	ret

Disassembly of section .text.__jhash_nwords:

0000000000007b80 <__jhash_nwords>:
static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval) {
    7b80:	55                   	push   %rbp
    7b81:	48 89 e5             	mov    %rsp,%rbp
    7b84:	48 83 ec 10          	sub    $0x10,%rsp
    7b88:	89 7d fc             	mov    %edi,-0x4(%rbp)
    7b8b:	89 75 f8             	mov    %esi,-0x8(%rbp)
    7b8e:	89 55 f4             	mov    %edx,-0xc(%rbp)
    7b91:	89 4d f0             	mov    %ecx,-0x10(%rbp)
  a += initval;
    7b94:	8b 45 f0             	mov    -0x10(%rbp),%eax
    7b97:	03 45 fc             	add    -0x4(%rbp),%eax
    7b9a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  b += initval;
    7b9d:	8b 45 f0             	mov    -0x10(%rbp),%eax
    7ba0:	03 45 f8             	add    -0x8(%rbp),%eax
    7ba3:	89 45 f8             	mov    %eax,-0x8(%rbp)
  c += initval;
    7ba6:	8b 45 f0             	mov    -0x10(%rbp),%eax
    7ba9:	03 45 f4             	add    -0xc(%rbp),%eax
    7bac:	89 45 f4             	mov    %eax,-0xc(%rbp)
  __jhash_final(a, b, c);
    7baf:	8b 45 f8             	mov    -0x8(%rbp),%eax
    7bb2:	33 45 f4             	xor    -0xc(%rbp),%eax
    7bb5:	89 45 f4             	mov    %eax,-0xc(%rbp)
    7bb8:	8b 7d f8             	mov    -0x8(%rbp),%edi
    7bbb:	be 0e 00 00 00       	mov    $0xe,%esi
    7bc0:	e8 db 00 00 00       	call   7ca0 <rol32>
    7bc5:	89 c1                	mov    %eax,%ecx
    7bc7:	8b 45 f4             	mov    -0xc(%rbp),%eax
    7bca:	29 c8                	sub    %ecx,%eax
    7bcc:	89 45 f4             	mov    %eax,-0xc(%rbp)
    7bcf:	8b 45 f4             	mov    -0xc(%rbp),%eax
    7bd2:	33 45 fc             	xor    -0x4(%rbp),%eax
    7bd5:	89 45 fc             	mov    %eax,-0x4(%rbp)
    7bd8:	8b 7d f4             	mov    -0xc(%rbp),%edi
    7bdb:	be 0b 00 00 00       	mov    $0xb,%esi
    7be0:	e8 bb 00 00 00       	call   7ca0 <rol32>
    7be5:	89 c1                	mov    %eax,%ecx
    7be7:	8b 45 fc             	mov    -0x4(%rbp),%eax
    7bea:	29 c8                	sub    %ecx,%eax
    7bec:	89 45 fc             	mov    %eax,-0x4(%rbp)
    7bef:	8b 45 fc             	mov    -0x4(%rbp),%eax
    7bf2:	33 45 f8             	xor    -0x8(%rbp),%eax
    7bf5:	89 45 f8             	mov    %eax,-0x8(%rbp)
    7bf8:	8b 7d fc             	mov    -0x4(%rbp),%edi
    7bfb:	be 19 00 00 00       	mov    $0x19,%esi
    7c00:	e8 9b 00 00 00       	call   7ca0 <rol32>
    7c05:	89 c1                	mov    %eax,%ecx
    7c07:	8b 45 f8             	mov    -0x8(%rbp),%eax
    7c0a:	29 c8                	sub    %ecx,%eax
    7c0c:	89 45 f8             	mov    %eax,-0x8(%rbp)
    7c0f:	8b 45 f8             	mov    -0x8(%rbp),%eax
    7c12:	33 45 f4             	xor    -0xc(%rbp),%eax
    7c15:	89 45 f4             	mov    %eax,-0xc(%rbp)
    7c18:	8b 7d f8             	mov    -0x8(%rbp),%edi
    7c1b:	be 10 00 00 00       	mov    $0x10,%esi
    7c20:	e8 7b 00 00 00       	call   7ca0 <rol32>
    7c25:	89 c1                	mov    %eax,%ecx
    7c27:	8b 45 f4             	mov    -0xc(%rbp),%eax
    7c2a:	29 c8                	sub    %ecx,%eax
    7c2c:	89 45 f4             	mov    %eax,-0xc(%rbp)
    7c2f:	8b 45 f4             	mov    -0xc(%rbp),%eax
    7c32:	33 45 fc             	xor    -0x4(%rbp),%eax
    7c35:	89 45 fc             	mov    %eax,-0x4(%rbp)
    7c38:	8b 7d f4             	mov    -0xc(%rbp),%edi
    7c3b:	be 04 00 00 00       	mov    $0x4,%esi
    7c40:	e8 5b 00 00 00       	call   7ca0 <rol32>
    7c45:	89 c1                	mov    %eax,%ecx
    7c47:	8b 45 fc             	mov    -0x4(%rbp),%eax
    7c4a:	29 c8                	sub    %ecx,%eax
    7c4c:	89 45 fc             	mov    %eax,-0x4(%rbp)
    7c4f:	8b 45 fc             	mov    -0x4(%rbp),%eax
    7c52:	33 45 f8             	xor    -0x8(%rbp),%eax
    7c55:	89 45 f8             	mov    %eax,-0x8(%rbp)
    7c58:	8b 7d fc             	mov    -0x4(%rbp),%edi
    7c5b:	be 0e 00 00 00       	mov    $0xe,%esi
    7c60:	e8 3b 00 00 00       	call   7ca0 <rol32>
    7c65:	89 c1                	mov    %eax,%ecx
    7c67:	8b 45 f8             	mov    -0x8(%rbp),%eax
    7c6a:	29 c8                	sub    %ecx,%eax
    7c6c:	89 45 f8             	mov    %eax,-0x8(%rbp)
    7c6f:	8b 45 f8             	mov    -0x8(%rbp),%eax
    7c72:	33 45 f4             	xor    -0xc(%rbp),%eax
    7c75:	89 45 f4             	mov    %eax,-0xc(%rbp)
    7c78:	8b 7d f8             	mov    -0x8(%rbp),%edi
    7c7b:	be 18 00 00 00       	mov    $0x18,%esi
    7c80:	e8 1b 00 00 00       	call   7ca0 <rol32>
    7c85:	89 c1                	mov    %eax,%ecx
    7c87:	8b 45 f4             	mov    -0xc(%rbp),%eax
    7c8a:	29 c8                	sub    %ecx,%eax
    7c8c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  return c;
    7c8f:	8b 45 f4             	mov    -0xc(%rbp),%eax
    7c92:	48 83 c4 10          	add    $0x10,%rsp
    7c96:	5d                   	pop    %rbp
    7c97:	c3                   	ret

Disassembly of section .text.rol32:

0000000000007ca0 <rol32>:
static inline __u32 rol32(__u32 word, unsigned int shift) {
    7ca0:	55                   	push   %rbp
    7ca1:	48 89 e5             	mov    %rsp,%rbp
    7ca4:	50                   	push   %rax
    7ca5:	89 7d fc             	mov    %edi,-0x4(%rbp)
    7ca8:	89 75 f8             	mov    %esi,-0x8(%rbp)
  return (word << shift) | (word >> ((-shift) & 31));
    7cab:	8b 45 fc             	mov    -0x4(%rbp),%eax
    7cae:	8b 4d f8             	mov    -0x8(%rbp),%ecx
    7cb1:	d3 e0                	shl    %cl,%eax
    7cb3:	8b 55 fc             	mov    -0x4(%rbp),%edx
    7cb6:	31 c9                	xor    %ecx,%ecx
    7cb8:	2b 4d f8             	sub    -0x8(%rbp),%ecx
    7cbb:	83 e1 1f             	and    $0x1f,%ecx
    7cbe:	d3 ea                	shr    %cl,%edx
    7cc0:	89 d1                	mov    %edx,%ecx
    7cc2:	09 c8                	or     %ecx,%eax
    7cc4:	48 83 c4 08          	add    $0x8,%rsp
    7cc8:	5d                   	pop    %rbp
    7cc9:	c3                   	ret

Disassembly of section .rodata.cst8:

0000000000007ccc <.rodata.cst8>:
    7ccc:	ff                   	(bad)
    7ccd:	ff                   	(bad)
    7cce:	ff                   	(bad)
    7ccf:	ff                   	(bad)
    7cd0:	ff 00                	incl   (%rax)
	...

Disassembly of section license:

0000000000007cd4 <_license>:
    7cd4:	47 50                	rex.RXB push %r8
    7cd6:	4c                   	rex.WR
	...

Disassembly of section .maps:

0000000000007cd8 <.maps>:
	...

Disassembly of section .data.bpf_get_smp_processor_id:

0000000000007f80 <bpf_get_smp_processor_id>:
    7f80:	90                   	nop
    7f81:	d5                   	(bad)
    7f82:	09 9f ff ff ff ff    	or     %ebx,-0x1(%rdi)

Disassembly of section .data.real_bpf_map_lookup_elem:

0000000000007f88 <real_bpf_map_lookup_elem>:
    7f88:	30 c9                	xor    %cl,%cl
    7f8a:	09 9f ff ff ff ff    	or     %ebx,-0x1(%rdi)

Disassembly of section .data.bpf_map_update_elem:

0000000000007f90 <bpf_map_update_elem>:
    7f90:	c0 c9 09             	ror    $0x9,%cl
    7f93:	9f                   	lahf
    7f94:	ff                   	(bad)
    7f95:	ff                   	(bad)
    7f96:	ff                   	(bad)
    7f97:	ff                   	.byte 0xff

Disassembly of section .data.bpf_ktime_get_ns:

0000000000007f98 <bpf_ktime_get_ns>:
    7f98:	30 d6                	xor    %dl,%dh
    7f9a:	09 9f ff ff ff ff    	or     %ebx,-0x1(%rdi)

Disassembly of section .data.bpf_xdp_adjust_head:

0000000000007fa0 <bpf_xdp_adjust_head>:
    7fa0:	20 5c 23 a1          	and    %bl,-0x5f(%rbx,%riz,1)
    7fa4:	ff                   	(bad)
    7fa5:	ff                   	(bad)
    7fa6:	ff                   	(bad)
    7fa7:	ff                   	.byte 0xff

Disassembly of section .debug_abbrev:

0000000000000000 <.debug_abbrev>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	01 11                	add    %edx,(%rcx)
   2:	01 25 25 13 05 03    	add    %esp,0x3051325(%rip)        # 305132d <bpf_xdp_adjust_head+0x304938d>
   8:	25 72 17 10 17       	and    $0x17101772,%eax
   d:	1b 25 11 01 55 23    	sbb    0x23550111(%rip),%esp        # 23550124 <bpf_xdp_adjust_head+0x23548184>
  13:	73 17                	jae    2c <balancer_ingress+0x2c>
  15:	74 17                	je     2e <balancer_ingress+0x2e>
  void* data = (void*)(long)ctx->data;
  17:	00 00                	add    %al,(%rax)
  19:	02 34 00             	add    (%rax,%rax,1),%dh
  1c:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f136b <bpf_xdp_adjust_head+0x193e93cb>
  22:	3a 0b                	cmp    (%rbx),%cl
  24:	3b 05 02 18 00 00    	cmp    0x1802(%rip),%eax        # 182c <balancer_ingress+0x182c>
  void* data_end = (void*)(long)ctx->data_end;
  2a:	03 01                	add    (%rcx),%eax
  2c:	01 49 13             	add    %ecx,0x13(%rcx)
  2f:	00 00                	add    %al,(%rax)
  31:	04 21                	add    $0x21,%al
  33:	00 49 13             	add    %cl,0x13(%rcx)
  36:	37                   	(bad)
  37:	0b 00                	or     (%rax),%eax
  struct ethhdr* eth = data;
  39:	00 05 24 00 03 25    	add    %al,0x25030024(%rip)        # 25030063 <bpf_xdp_adjust_head+0x250280c3>
  3f:	3e 0b 0b             	ds or  (%rbx),%ecx
  42:	0b 00                	or     (%rax),%eax
  44:	00 06                	add    %al,(%rsi)
  46:	24 00                	and    $0x0,%al
  nh_off = sizeof(struct ethhdr);
  48:	03 25 0b 0b 3e 0b    	add    0xb3e0b0b(%rip),%esp        # b3e0b59 <bpf_xdp_adjust_head+0xb3d8bb9>
  4e:	00 00                	add    %al,(%rax)
  50:	07                   	(bad)
  if (data + nh_off > data_end) {
  51:	34 00                	xor    $0x0,%al
  53:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f13a2 <bpf_xdp_adjust_head+0x193e9402>
  59:	3a 0b                	cmp    (%rbx),%cl
  5b:	3b 0b                	cmp    (%rbx),%ecx
  5d:	02 18                	add    (%rax),%bl
  5f:	00 00                	add    %al,(%rax)
  61:	08 13                	or     %dl,(%rbx)
  63:	01 0b                	add    %ecx,(%rbx)
  65:	0b 3a                	or     (%rdx),%edi
  67:	0b 3b                	or     (%rbx),%edi
  69:	0b 00                	or     (%rax),%eax
    return XDP_DROP;
  6b:	00 09                	add    %cl,(%rcx)
  6d:	0d 00 03 25 49       	or     $0x49250300,%eax
  72:	13 3a                	adc    (%rdx),%edi
  74:	0b 3b                	or     (%rbx),%edi
  76:	0b 38                	or     (%rax),%edi
  78:	0b 00                	or     (%rax),%eax
  eth_proto = eth->h_proto;
  7a:	00 0a                	add    %cl,(%rdx)
  7c:	0f 00 49 13          	str    0x13(%rcx)
  80:	00 00                	add    %al,(%rax)
  82:	0b 16                	or     (%rsi),%edx
  84:	00 49 13             	add    %cl,0x13(%rcx)
  87:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0bc7 <bpf_xdp_adjust_head+0xb3a8c27>
  if (eth_proto == BE_ETH_P_IP) {
  8d:	00 00                	add    %al,(%rax)
  8f:	0c 13                	or     $0x13,%al
  91:	01 03                	add    %eax,(%rbx)
  93:	25 0b 0b 3a 0b       	and    $0xb3a0b0b,%eax
    return process_packet(ctx, nh_off, false);
  98:	3b 0b                	cmp    (%rbx),%ecx
  9a:	00 00                	add    %al,(%rax)
  9c:	0d 0d 00 49 13       	or     $0x1349000d,%eax
  a1:	3a 0b                	cmp    (%rbx),%cl
  a3:	3b 0b                	cmp    (%rbx),%ecx
  a5:	38 0b                	cmp    %cl,(%rbx)
  a7:	00 00                	add    %al,(%rax)
  a9:	0e                   	(bad)
  aa:	17                   	(bad)
  ab:	01 0b                	add    %ecx,(%rbx)
  ad:	0b 3a                	or     (%rdx),%edi
  af:	0b 3b                	or     (%rbx),%edi
  b1:	0b 00                	or     (%rax),%eax
  b3:	00 0f                	add    %cl,(%rdi)
  b5:	21 00                	and    %eax,(%rax)
  b7:	49 13 37             	adc    (%r15),%rsi
  void* data = (void*)(long)xdp->data;
  ba:	05 00 00 10 21       	add    $0x21100000,%eax
  bf:	00 49 13             	add    %cl,0x13(%rcx)
  c2:	00 00                	add    %al,(%rax)
  c4:	11 21                	adc    %esp,(%rcx)
  c6:	00 49 13             	add    %cl,0x13(%rcx)
  c9:	37                   	(bad)
  void* data_end = (void*)(long)xdp->data_end;
  ca:	06                   	(bad)
  cb:	00 00                	add    %al,(%rax)
  cd:	12 34 00             	adc    (%rax,%rax,1),%dh
  d0:	03 25 49 13 3a 0b    	add    0xb3a1349(%rip),%esp        # b3a141f <bpf_xdp_adjust_head+0xb39947f>
  d6:	3b 0b                	cmp    (%rbx),%ecx
  d8:	02 18                	add    (%rax),%bl
  da:	00 00                	add    %al,(%rax)
  struct real_definition* dst = NULL;
  dc:	13 15 00 49 13 27    	adc    0x27134900(%rip),%edx        # 271349e2 <bpf_xdp_adjust_head+0x2712ca42>
  e2:	19 00                	sbb    %eax,(%rax)
  e4:	00 14 15 01 49 13 27 	add    %dl,0x27134901(,%rdx,1)
  struct packet_description pckt = {};
  eb:	19 00                	sbb    %eax,(%rax)
  ed:	00 15 05 00 49 13    	add    %dl,0x13490005(%rip)        # 134900f8 <bpf_xdp_adjust_head+0x13488158>
  f3:	00 00                	add    %al,(%rax)
  f5:	16                   	(bad)
  f6:	0f 00 00             	sldt   (%rax)
  f9:	00 17                	add    %dl,(%rdi)
  fb:	04 01                	add    $0x1,%al
  fd:	49 13 03             	adc    (%r11),%rax
 100:	25 0b 0b 3a 0b       	and    $0xb3a0b0b,%eax
 105:	3b 05 00 00 18 28    	cmp    0x28180000(%rip),%eax        # 2818010b <bpf_xdp_adjust_head+0x2817816b>
 10b:	00 03                	add    %al,(%rbx)
 10d:	25 1c 0f 00 00       	and    $0xf1c,%eax
 112:	19 04 01             	sbb    %eax,(%rcx,%rax,1)
 115:	49 13 0b             	adc    (%r11),%rcx
 118:	0b 3a                	or     (%rdx),%edi
 11a:	0b 3b                	or     (%rbx),%edi
 11c:	0b 00                	or     (%rax),%eax
 11e:	00 1a                	add    %bl,(%rdx)
  struct vip_definition vip = {};
 120:	2e 01 03             	cs add %eax,(%rbx)
 123:	25 3a 0b 3b 05       	and    $0x53b0b3a,%eax
 128:	27                   	(bad)
 129:	19 49 13             	sbb    %ecx,0x13(%rcx)
 12c:	20 21                	and    %ah,(%rcx)
 12e:	01 00                	add    %eax,(%rax)
 130:	00 1b                	add    %bl,(%rbx)
 132:	05 00 03 25 3a       	add    $0x3a250300,%eax
 137:	0b 3b                	or     (%rbx),%edi
 139:	05 49 13 00 00       	add    $0x1349,%eax
  __u32 mac_addr_pos = 0;
 13e:	1c 34                	sbb    $0x34,%al
 140:	00 03                	add    %al,(%rbx)
 142:	25 3a 0b 3b 05       	and    $0x53b0b3a,%eax
 147:	49 13 00             	adc    (%r8),%rax
  __u64 th_off = 0;
 14a:	00 1d 0b 01 00 00    	add    %bl,0x10b(%rip)        # 25b <balancer_ingress+0x25b>
 150:	1e                   	(bad)
 151:	13 01                	adc    (%rcx),%eax
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
 153:	03 25 0b 0b 3a 0b    	add    0xb3a0b0b(%rip),%esp        # b3a0c64 <bpf_xdp_adjust_head+0xb398cc4>
 159:	3b 05 00 00 1f 0d    	cmp    0xd1f0000(%rip),%eax        # d1f015f <bpf_xdp_adjust_head+0xd1e81bf>
 15f:	00 03                	add    %al,(%rbx)
 161:	25 49 13 3a 0b       	and    $0xb3a1349,%eax
 166:	3b 05 38 0b 00 00    	cmp    0xb38(%rip),%eax        # ca4 <balancer_ingress+0xca4>
 16c:	20 13                	and    %dl,(%rbx)
 16e:	00 03                	add    %al,(%rbx)
 170:	25 3c 19 00 00       	and    $0x193c,%eax
 175:	21 26                	and    %esp,(%rsi)
 177:	00 49 13             	add    %cl,0x13(%rcx)
 17a:	00 00                	add    %al,(%rax)
 17c:	22 0d 00 03 25 49    	and    0x49250300(%rip),%cl        # 49250482 <bpf_xdp_adjust_head+0x492484e2>
 182:	13 3a                	adc    (%rdx),%edi
 184:	0b 3b                	or     (%rbx),%edi
 186:	0b 0b                	or     (%rbx),%ecx
 188:	0b 0d 0b 0c 0b 38    	or     0x380b0c0b(%rip),%ecx        # 380b0d99 <bpf_xdp_adjust_head+0x380a8df9>
 18e:	0b 00                	or     (%rax),%eax
 190:	00 23                	add    %ah,(%rbx)
 192:	2e 01 03             	cs add %eax,(%rbx)
 195:	25 3a 0b 3b 0b       	and    $0xb3b0b3a,%eax
 19a:	27                   	(bad)
 19b:	19 49 13             	sbb    %ecx,0x13(%rcx)
 19e:	20 21                	and    %ah,(%rcx)
 1a0:	01 00                	add    %eax,(%rax)
 1a2:	00 24 05 00 03 25 3a 	add    %ah,0x3a250300(,%rax,1)
 1a9:	0b 3b                	or     (%rbx),%edi
 1ab:	0b 49 13             	or     0x13(%rcx),%ecx
 1ae:	00 00                	add    %al,(%rax)
 1b0:	25 34 00 03 25       	and    $0x25030034,%eax
 1b5:	3a 0b                	cmp    (%rbx),%cl
 1b7:	3b 0b                	cmp    (%rbx),%ecx
 1b9:	49 13 00             	adc    (%r8),%rax
 1bc:	00 26                	add    %ah,(%rsi)
 1be:	34 00                	xor    $0x0,%al
 1c0:	03 26                	add    (%rsi),%esp
 1c2:	3a 0b                	cmp    (%rbx),%cl
  if (is_ipv6) {
 1c4:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 1513 <balancer_ingress+0x1513>
 1ca:	27                   	(bad)
 1cb:	13 01                	adc    (%rcx),%eax
 1cd:	03 26                	add    (%rsi),%esp
 1cf:	0b 0b                	or     (%rbx),%ecx
    ip6h = data + nh_off;
 1d1:	3a 0b                	cmp    (%rbx),%cl
 1d3:	3b 0b                	cmp    (%rbx),%ecx
 1d5:	00 00                	add    %al,(%rax)
 1d7:	28 2e                	sub    %ch,(%rsi)
 1d9:	01 03                	add    %eax,(%rbx)
 1db:	26 3a 0b             	es cmp (%rbx),%cl
 1de:	3b 0b                	cmp    (%rbx),%ecx
 1e0:	27                   	(bad)
 1e1:	19 49 13             	sbb    %ecx,0x13(%rcx)
 1e4:	20 21                	and    %ah,(%rcx)
    if (ip6h + 1 > data_end) {
 1e6:	01 00                	add    %eax,(%rax)
 1e8:	00 29                	add    %ch,(%rcx)
 1ea:	34 00                	xor    $0x0,%al
 1ec:	03 26                	add    (%rsi),%esp
 1ee:	3a 0b                	cmp    (%rbx),%cl
 1f0:	3b 0b                	cmp    (%rbx),%ecx
 1f2:	49 13 00             	adc    (%r8),%rax
 1f5:	00 2a                	add    %ch,(%rdx)
 1f7:	2e 01 03             	cs add %eax,(%rbx)
 1fa:	26 3a 0b             	es cmp (%rbx),%cl
      return XDP_DROP;
 1fd:	3b 0b                	cmp    (%rbx),%ecx
 1ff:	27                   	(bad)
 200:	19 20                	sbb    %esp,(%rax)
 202:	21 01                	and    %eax,(%rcx)
 204:	00 00                	add    %al,(%rax)
 206:	2b 05 00 03 26 3a    	sub    0x3a260300(%rip),%eax        # 3a26050c <bpf_xdp_adjust_head+0x3a25856c>
    iph_len = sizeof(struct ipv6hdr);
 20c:	0b 3b                	or     (%rbx),%edi
 20e:	0b 49 13             	or     0x13(%rcx),%ecx
 211:	00 00                	add    %al,(%rax)
 213:	2c 0d                	sub    $0xd,%al
 215:	00 03                	add    %al,(%rbx)
    *protocol = ip6h->nexthdr;
 217:	26 49 13 3a          	es adc (%r10),%rdi
 21b:	0b 3b                	or     (%rbx),%edi
 21d:	0b 38                	or     (%rax),%edi
 21f:	0b 00                	or     (%rax),%eax
 221:	00 2d 0d 00 03 26    	add    %ch,0x2603000d(%rip)        # 26030234 <bpf_xdp_adjust_head+0x26028294>
 227:	49 13 3a             	adc    (%r10),%rdi
    pckt->flow.proto = *protocol;
 22a:	0b 3b                	or     (%rbx),%edi
 22c:	0b 0b                	or     (%rbx),%ecx
 22e:	0b 0d 0b 0c 0b 38    	or     0x380b0c0b(%rip),%ecx        # 380b0e3f <bpf_xdp_adjust_head+0x380a8e9f>
 234:	0b 00                	or     (%rax),%eax
 236:	00 2e                	add    %ch,(%rsi)
 238:	2e 01 03             	cs add %eax,(%rbx)
 23b:	26 3a 0b             	es cmp (%rbx),%cl
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 23e:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491b6b <bpf_xdp_adjust_head+0x13489bcb>
 244:	20 21                	and    %ah,(%rcx)
 246:	01 00                	add    %eax,(%rax)
 248:	00 2f                	add    %ch,(%rdi)
 24a:	2e 01 03             	cs add %eax,(%rbx)
 24d:	26 3a 0b             	es cmp (%rbx),%cl
 250:	3b 05 27 19 20 21    	cmp    0x21201927(%rip),%eax        # 21201b7d <bpf_xdp_adjust_head+0x211f9bdd>
 256:	01 00                	add    %eax,(%rax)
 258:	00 30                	add    %dh,(%rax)
 25a:	05 00 03 26 3a       	add    $0x3a260300,%eax
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 25f:	0b 3b                	or     (%rbx),%edi
 261:	05 49 13 00 00       	add    $0x1349,%eax
 266:	31 2e                	xor    %ebp,(%rsi)
 268:	01 03                	add    %eax,(%rbx)
 26a:	26 3a 0b             	es cmp (%rbx),%cl
 26d:	3b 0b                	cmp    (%rbx),%ecx
 26f:	20 21                	and    %ah,(%rcx)
 271:	01 00                	add    %eax,(%rax)
 273:	00 32                	add    %dh,(%rdx)
 275:	2e 01 11             	cs add %edx,(%rcx)
 278:	1b 12                	sbb    (%rdx),%edx
 27a:	06                   	(bad)
 27b:	40 18 03             	rex sbb %al,(%rbx)
 27e:	26 3a 0b             	es cmp (%rbx),%cl
 281:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491bae <bpf_xdp_adjust_head+0x13489c0e>
 287:	3f                   	(bad)
    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
 288:	19 00                	sbb    %eax,(%rax)
 28a:	00 33                	add    %dh,(%rbx)
 28c:	05 00 02 18 03       	add    $0x3180200,%eax
 291:	26 3a 0b             	es cmp (%rbx),%cl
 294:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 15e3 <balancer_ingress+0x15e3>
 29a:	34 34                	xor    $0x34,%al
 29c:	00 02                	add    %al,(%rdx)
 29e:	18 03                	sbb    %al,(%rbx)
 2a0:	25 3a 0b 3b 05       	and    $0x53b0b3a,%eax
 2a5:	49 13 00             	adc    (%r8),%rax
 2a8:	00 35 34 00 02 18    	add    %dh,0x18020034(%rip)        # 180202e2 <bpf_xdp_adjust_head+0x18018342>
 2ae:	03 26                	add    (%rsi),%esp
 2b0:	3a 0b                	cmp    (%rbx),%cl
 2b2:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 1601 <balancer_ingress+0x1601>
    *th_off += nh_off + iph_len;
 2b8:	36 1d 01 31 13 11    	ss sbb $0x11133101,%eax
 2be:	1b 12                	sbb    (%rdx),%edx
 2c0:	06                   	(bad)
 2c1:	58                   	pop    %rax
 2c2:	0b 59 05             	or     0x5(%rcx),%ebx
 2c5:	57                   	push   %rdi
 2c6:	0b 00                	or     (%rax),%eax
 2c8:	00 37                	add    %dh,(%rdi)
 2ca:	05 00 02 18 31       	add    $0x31180200,%eax
    if (*protocol == IPPROTO_FRAGMENT) {
 2cf:	13 00                	adc    (%rax),%eax
 2d1:	00 38                	add    %bh,(%rax)
 2d3:	34 00                	xor    $0x0,%al
 2d5:	02 18                	add    (%rax),%bl
 2d7:	31 13                	xor    %edx,(%rbx)
 2d9:	00 00                	add    %al,(%rax)
 2db:	39 1d 01 31 13 11    	cmp    %ebx,0x11133101(%rip)        # 111333e2 <bpf_xdp_adjust_head+0x1112b442>
      return XDP_DROP;
 2e1:	1b 12                	sbb    (%rdx),%edx
 2e3:	06                   	(bad)
 2e4:	58                   	pop    %rax
 2e5:	0b 59 0b             	or     0xb(%rcx),%ebx
 2e8:	57                   	push   %rdi
 2e9:	0b 00                	or     (%rax),%eax
 2eb:	00 3a                	add    %bh,(%rdx)
    } else if (*protocol == IPPROTO_ICMPV6) {
 2ed:	0b 01                	or     (%rcx),%eax
 2ef:	11 1b                	adc    %ebx,(%rbx)
 2f1:	12 06                	adc    (%rsi),%al
 2f3:	00 00                	add    %al,(%rax)
 2f5:	3b 0b                	cmp    (%rbx),%ecx
 2f7:	01 55 23             	add    %edx,0x23(%rbp)
 2fa:	00 00                	add    %al,(%rax)
      return FURTHER_PROCESSING;
 2fc:	3c 2e                	cmp    $0x2e,%al
 2fe:	01 11                	add    %edx,(%rcx)
 300:	1b 12                	sbb    (%rdx),%edx
 302:	06                   	(bad)
 303:	40 18 03             	rex sbb %al,(%rbx)
 306:	26 3a 0b             	es cmp (%rbx),%cl
 309:	3b 0b                	cmp    (%rbx),%ecx
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 30b:	27                   	(bad)
 30c:	19 49 13             	sbb    %ecx,0x13(%rcx)
 30f:	00 00                	add    %al,(%rax)
 311:	3d 05 00 02 18       	cmp    $0x18020005,%eax
 316:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0e56 <bpf_xdp_adjust_head+0xb3a8eb6>
 31c:	49 13 00             	adc    (%r8),%rax
 31f:	00 3e                	add    %bh,(%rsi)
 321:	05 00 02 18 03       	add    $0x3180200,%eax
 326:	26 3a 0b             	es cmp (%rbx),%cl
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 329:	3b 0b                	cmp    (%rbx),%ecx
 32b:	49 13 00             	adc    (%r8),%rax
 32e:	00 3f                	add    %bh,(%rdi)
 330:	34 00                	xor    $0x0,%al
 332:	02 18                	add    (%rax),%bl
 334:	03 26                	add    (%rsi),%esp
 336:	3a 0b                	cmp    (%rbx),%cl
 338:	3b 0b                	cmp    (%rbx),%ecx
 33a:	49 13 00             	adc    (%r8),%rax
 33d:	00 40 26             	add    %al,0x26(%rax)
 340:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_info:

0000000000000000 <.debug_info>:
int balancer_ingress(struct xdp_md* ctx) {
       0:	fa                   	cli
       1:	45 00 00             	add    %r8b,(%r8)
       4:	05 00 01 08 00       	add    $0x80100,%eax
       9:	00 00                	add    %al,(%rax)
       b:	00 01                	add    %al,(%rcx)
       d:	00 0c 00             	add    %cl,(%rax,%rax,1)
      10:	01 08                	add    %ecx,(%rax)
      12:	00 00                	add    %al,(%rax)
      14:	00 00                	add    %al,(%rax)
  void* data = (void*)(long)ctx->data;
      16:	00 00                	add    %al,(%rax)
      18:	00 02                	add    %al,(%rdx)
	...
      22:	3a 08                	cmp    (%rax),%cl
      24:	00 00                	add    %al,(%rax)
      26:	00 0c 00             	add    %cl,(%rax,%rax,1)
  void* data_end = (void*)(long)ctx->data_end;
      29:	00 00                	add    %al,(%rax)
      2b:	02 03                	add    (%rbx),%al
      2d:	37                   	(bad)
      2e:	00 00                	add    %al,(%rax)
      30:	00 00                	add    %al,(%rax)
      32:	4a 04 02             	rex.WX add $0x2,%al
      35:	a1 00 03 43 00 00 00 	movabs 0x4704000000430300,%eax
      3c:	04 47 
  struct ethhdr* eth = data;
      3e:	00 00                	add    %al,(%rax)
      40:	00 04 00             	add    %al,(%rax,%rax,1)
      43:	05 04 06 01 06       	add    $0x6010604,%eax
  nh_off = sizeof(struct ethhdr);
      48:	05 08 07 07 06       	add    $0x6070708,%eax
      4d:	56                   	push   %rsi
      4e:	00 00                	add    %al,(%rax)
      50:	00 01                	add    %al,(%rcx)
  if (data + nh_off > data_end) {
      52:	29 02                	sub    %eax,(%rdx)
      54:	a1 01 08 28 01 23 09 	movabs 0x8807092301280801,%eax
      5b:	07 88 
      5d:	00 00                	add    %al,(%rax)
      5f:	00 01                	add    %al,(%rcx)
      61:	24 00                	and    $0x0,%al
      63:	09 09                	or     %ecx,(%rcx)
      65:	9d                   	popf
      66:	00 00                	add    %al,(%rax)
      68:	00 01                	add    %al,(%rcx)
    return XDP_DROP;
      6a:	25 08 09 0c ae       	and    $0xae0c0908,%eax
      6f:	00 00                	add    %al,(%rax)
      71:	00 01                	add    %al,(%rcx)
      73:	26 10 09             	es adc %cl,(%rcx)
      76:	14 05                	adc    $0x5,%al
      78:	01 00                	add    %eax,(%rax)
  eth_proto = eth->h_proto;
      7a:	00 01                	add    %al,(%rcx)
      7c:	27                   	(bad)
      7d:	18 09                	sbb    %cl,(%rcx)
      7f:	15 16 01 00 00       	adc    $0x116,%eax
      84:	01 28                	add    %ebp,(%rax)
      86:	20 00                	and    %al,(%rax)
      88:	0a 8d 00 00 00 03    	or     0x3000000(%rbp),%cl
  if (eth_proto == BE_ETH_P_IP) {
      8e:	99                   	cltd
      8f:	00 00                	add    %al,(%rax)
      91:	00 04 47             	add    %al,(%rdi,%rax,2)
      94:	00 00                	add    %al,(%rax)
      96:	00 02                	add    %al,(%rdx)
    return process_packet(ctx, nh_off, false);
      98:	00 05 08 05 04 0a    	add    %al,0xa040508(%rip)        # a0405a6 <bpf_xdp_adjust_head+0xa038606>
      9e:	a2 00 00 00 0b aa 00 	movabs %al,0xaa0b000000
      a5:	00 00 
      a7:	0b 02                	or     (%rdx),%eax
      a9:	1b 05 0a 07 04 0a    	sbb    0xa04070a(%rip),%eax        # a0407b9 <bpf_xdp_adjust_head+0xa038819>
      af:	b3 00                	mov    $0x0,%bl
      b1:	00 00                	add    %al,(%rax)
      b3:	0c 13                	or     $0x13,%al
      b5:	08 03                	or     %al,(%rbx)
      b7:	35 0d c0 00 00       	xor    $0xc00d,%eax
  void* data = (void*)(long)xdp->data;
      bc:	00 03                	add    %al,(%rbx)
      be:	36 00 0e             	ss add %cl,(%rsi)
      c1:	08 03                	or     %al,(%rbx)
      c3:	36 09 0c e1          	ss or  %ecx,(%rcx,%riz,8)
      c7:	00 00                	add    %al,(%rax)
      c9:	00 03                	add    %al,(%rbx)
  void* data_end = (void*)(long)xdp->data_end;
      cb:	37                   	(bad)
      cc:	00 09                	add    %cl,(%rcx)
      ce:	0f a2                	cpuid
      d0:	00 00                	add    %al,(%rax)
      d2:	00 03                	add    %al,(%rbx)
      d4:	38 00                	cmp    %al,(%rax)
      d6:	09 10                	or     %edx,(%rax)
      d8:	ed                   	in     (%dx),%eax
      d9:	00 00                	add    %al,(%rax)
      db:	00 03                	add    %al,(%rbx)
  struct real_definition* dst = NULL;
      dd:	39 00                	cmp    %eax,(%rax)
      df:	00 00                	add    %al,(%rax)
      e1:	0b e9                	or     %ecx,%ebp
      e3:	00 00                	add    %al,(%rax)
      e5:	00 0e                	add    %cl,(%rsi)
  struct packet_description pckt = {};
      e7:	02 1f                	add    (%rdi),%bl
      e9:	05 0d 07 08 03       	add    $0x308070d,%eax
      ee:	f9                   	stc
      ef:	00 00                	add    %al,(%rax)
      f1:	00 04 47             	add    %al,(%rdi,%rax,2)
      f4:	00 00                	add    %al,(%rax)
      f6:	00 06                	add    %al,(%rsi)
      f8:	00 0b                	add    %cl,(%rbx)
      fa:	01 01                	add    %eax,(%rcx)
      fc:	00 00                	add    %al,(%rax)
      fe:	12 02                	adc    (%rdx),%al
     100:	15 05 11 08 01       	adc    $0x1081105,%eax
     105:	0a 0a                	or     (%rdx),%cl
     107:	01 00                	add    %eax,(%rax)
     109:	00 03                	add    %al,(%rbx)
     10b:	99                   	cltd
     10c:	00 00                	add    %al,(%rax)
     10e:	00 04 47             	add    %al,(%rdi,%rax,2)
     111:	00 00                	add    %al,(%rax)
     113:	00 10                	add    %dl,(%rax)
     115:	00 0a                	add    %cl,(%rdx)
     117:	1b 01                	sbb    (%rcx),%eax
     119:	00 00                	add    %al,(%rax)
     11b:	03 99 00 00 00 04    	add    0x4000000(%rcx),%ebx
  struct vip_definition vip = {};
     121:	47 00 00             	rex.RXB add %r8b,(%r8)
     124:	00 00                	add    %al,(%rax)
     126:	00 07                	add    %al,(%rdi)
     128:	16                   	(bad)
     129:	32 01                	xor    (%rcx),%al
     12b:	00 00                	add    %al,(%rax)
     12d:	04 26                	add    $0x26,%al
     12f:	02 a1 02 08 28 04    	add    0x4280802(%rcx),%ah
     135:	20 09                	and    %cl,(%rcx)
     137:	07                   	(bad)
     138:	64 01 00             	add    %eax,%fs:(%rax)
     13b:	00 04 21             	add    %al,(%rcx,%riz,1)
  __u32 mac_addr_pos = 0;
     13e:	00 09                	add    %cl,(%rcx)
     140:	09 75 01             	or     %esi,0x1(%rbp)
     143:	00 00                	add    %al,(%rax)
     145:	04 22                	add    $0x22,%al
     147:	08 09                	or     %cl,(%rcx)
  __u64 th_off = 0;
     149:	0c d1                	or     $0xd1,%al
     14b:	01 00                	add    %eax,(%rax)
     14d:	00 04 23             	add    %al,(%rbx,%riz,1)
     150:	10 09                	adc    %cl,(%rcx)
     152:	14 ee                	adc    $0xee,%al
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
     154:	01 00                	add    %eax,(%rax)
     156:	00 04 24             	add    %al,(%rsp)
     159:	18 09                	sbb    %cl,(%rcx)
     15b:	15 16 01 00 00       	adc    $0x116,%eax
     160:	04 25                	add    $0x25,%al
     162:	20 00                	and    %al,(%rax)
     164:	0a 69 01             	or     0x1(%rcx),%ch
     167:	00 00                	add    %al,(%rax)
     169:	03 99 00 00 00 04    	add    0x4000000(%rcx),%ebx
     16f:	47 00 00             	rex.RXB add %r8b,(%r8)
     172:	00 01                	add    %al,(%rcx)
     174:	00 0a                	add    %cl,(%rdx)
     176:	7a 01                	jp     179 <balancer_ingress+0x179>
     178:	00 00                	add    %al,(%rax)
     17a:	0c 1e                	or     $0x1e,%al
     17c:	14 03                	adc    $0x3,%al
     17e:	3e 0d 87 01 00 00    	ds or  $0x187,%eax
     184:	03 3f                	add    (%rdi),%edi
     186:	00 0e                	add    %cl,(%rsi)
     188:	10 03                	adc    %al,(%rbx)
     18a:	3f                   	(bad)
     18b:	09 17                	or     %edx,(%rdi)
     18d:	b1 01                	mov    $0x1,%cl
     18f:	00 00                	add    %al,(%rax)
     191:	03 40 00             	add    0x0(%rax),%eax
     194:	09 19                	or     %ebx,(%rcx)
     196:	b9 01 00 00 03       	mov    $0x3000001,%ecx
     19b:	41 00 00             	add    %al,(%r8)
     19e:	09 1a                	or     %ebx,(%rdx)
     1a0:	c5 01 00             	(bad)
     1a3:	00 03                	add    %al,(%rbx)
     1a5:	43 10 09             	rex.XB adc %cl,(%r9)
     1a8:	1d f9 00 00 00       	sbb    $0xf9,%eax
     1ad:	03 44 12 00          	add    0x0(%rdx,%rdx,1),%eax
     1b1:	0b a2 00 00 00 18    	or     0x18000000(%rdx),%esp
     1b7:	05 22 03 b1 01       	add    $0x1b10322,%eax
     1bc:	00 00                	add    %al,(%rax)
     1be:	04 47                	add    $0x47,%al
     1c0:	00 00                	add    %al,(%rax)
     1c2:	00 04 00             	add    %al,(%rax,%rax,1)
  if (is_ipv6) {
     1c5:	0b cd                	or     %ebp,%ecx
     1c7:	01 00                	add    %eax,(%rax)
     1c9:	00 1c 02             	add    %bl,(%rdx,%rax,1)
     1cc:	18 05 1b 07 02 0a    	sbb    %al,0xa02071b(%rip)        # a0208ed <bpf_xdp_adjust_head+0xa01894d>
    ip6h = data + nh_off;
     1d2:	d6                   	(bad)
     1d3:	01 00                	add    %eax,(%rax)
     1d5:	00 0c 21             	add    %cl,(%rcx,%riz,1)
     1d8:	08 03                	or     %al,(%rbx)
     1da:	48 09 1f             	or     %rbx,(%rdi)
     1dd:	a2 00 00 00 03 49 00 	movabs %al,0x2009004903000000
     1e4:	09 20 
    if (ip6h + 1 > data_end) {
     1e6:	a2 00 00 00 03 4a 04 	movabs %al,0xa00044a03000000
     1ed:	00 0a 
     1ef:	f3 01 00             	repz add %eax,(%rax)
     1f2:	00 03                	add    %al,(%rbx)
     1f4:	99                   	cltd
     1f5:	00 00                	add    %al,(%rax)
     1f7:	00 0f                	add    %cl,(%rdi)
     1f9:	47 00 00             	rex.RXB add %r8b,(%r8)
      return XDP_DROP;
     1fc:	00 00                	add    %al,(%rax)
     1fe:	02 00                	add    (%rax),%al
     200:	07                   	(bad)
     201:	22 0b                	and    (%rbx),%cl
     203:	02 00                	add    (%rax),%al
     205:	00 04 2f             	add    %al,(%rdi,%rbp,1)
     208:	02 a1 03 08 28 04    	add    0x4280803(%rcx),%ah
    iph_len = sizeof(struct ipv6hdr);
     20e:	29 09                	sub    %ecx,(%rcx)
     210:	07                   	(bad)
     211:	3d 02 00 00 04       	cmp    $0x4000002,%eax
    *protocol = ip6h->nexthdr;
     216:	2a 00                	sub    (%rax),%al
     218:	09 09                	or     %ecx,(%rcx)
     21a:	4e 02 00             	rex.WRX add (%rax),%r8b
     21d:	00 04 2b             	add    %al,(%rbx,%rbp,1)
     220:	08 09                	or     %cl,(%rcx)
     222:	0c cb                	or     $0xcb,%al
     224:	02 00                	add    (%rax),%al
     226:	00 04 2c             	add    %al,(%rsp,%rbp,1)
    pckt->flow.proto = *protocol;
     229:	10 09                	adc    %cl,(%rcx)
     22b:	14 e8                	adc    $0xe8,%al
     22d:	02 00                	add    (%rax),%al
     22f:	00 04 2d 18 09 15 16 	add    %al,0x16150918(,%rbp,1)
     236:	01 00                	add    %eax,(%rax)
     238:	00 04 2e             	add    %al,(%rsi,%rbp,1)
     23b:	20 00                	and    %al,(%rax)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     23d:	0a 42 02             	or     0x2(%rdx),%al
     240:	00 00                	add    %al,(%rax)
     242:	03 99 00 00 00 04    	add    0x4000000(%rcx),%ebx
     248:	47 00 00             	rex.RXB add %r8b,(%r8)
     24b:	00 09                	add    %cl,(%rcx)
     24d:	00 0a                	add    %cl,(%rdx)
     24f:	53                   	push   %rbx
     250:	02 00                	add    (%rax),%al
     252:	00 0c 29             	add    %cl,(%rcx,%rbp,1)
     255:	28 03                	sub    %al,(%rbx)
     257:	1a 0d 60 02 00 00    	sbb    0x260(%rip),%cl        # 4bd <balancer_ingress+0x4bd>
     25d:	03 1b                	add    (%rbx),%ebx
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     25f:	00 0e                	add    %cl,(%rsi)
     261:	10 03                	adc    %al,(%rbx)
     263:	1b 09                	sbb    (%rcx),%ecx
     265:	23 b1 01 00 00 03    	and    0x3000001(%rcx),%esi
     26b:	1c 00                	sbb    $0x0,%al
     26d:	09 24 b9             	or     %esp,(%rcx,%rdi,4)
     270:	01 00                	add    %eax,(%rax)
     272:	00 03                	add    %al,(%rbx)
     274:	1d 00 00 0d 7f       	sbb    $0x7f0d0000,%eax
     279:	02 00                	add    (%rax),%al
     27b:	00 03                	add    %al,(%rbx)
     27d:	1f                   	(bad)
     27e:	10 0e                	adc    %cl,(%rsi)
     280:	10 03                	adc    %al,(%rbx)
     282:	1f                   	(bad)
     283:	09 25 b1 01 00 00    	or     %esp,0x1b1(%rip)        # 43a <balancer_ingress+0x43a>
    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
     289:	03 20                	add    (%rax),%esp
     28b:	00 09                	add    %cl,(%rcx)
     28d:	26 b9 01 00 00 03    	es mov $0x3000001,%ecx
     293:	21 00                	and    %eax,(%rax)
     295:	00 0d 9e 02 00 00    	add    %cl,0x29e(%rip)        # 539 <balancer_ingress+0x539>
     29b:	03 23                	add    (%rbx),%esp
     29d:	20 0e                	and    %cl,(%rsi)
     29f:	04 03                	add    $0x3,%al
     2a1:	23 09                	and    (%rcx),%ecx
     2a3:	27                   	(bad)
     2a4:	a2 00 00 00 03 24 00 	movabs %al,0x2809002403000000
     2ab:	09 28 
     2ad:	bf 02 00 00 03       	mov    $0x3000002,%edi
     2b2:	25 00 00 09 1d       	and    $0x1d090000,%eax
    *th_off += nh_off + iph_len;
     2b7:	f9                   	stc
     2b8:	00 00                	add    %al,(%rax)
     2ba:	00 03                	add    %al,(%rbx)
     2bc:	27                   	(bad)
     2bd:	24 00                	and    $0x0,%al
     2bf:	03 c5                	add    %ebp,%eax
     2c1:	01 00                	add    %eax,(%rax)
     2c3:	00 04 47             	add    %al,(%rdi,%rax,2)
     2c6:	00 00                	add    %al,(%rax)
     2c8:	00 02                	add    %al,(%rdx)
     2ca:	00 0a                	add    %cl,(%rdx)
     2cc:	d0 02                	rolb   (%rdx)
    if (*protocol == IPPROTO_FRAGMENT) {
     2ce:	00 00                	add    %al,(%rax)
     2d0:	0c 2c                	or     $0x2c,%al
     2d2:	10 03                	adc    %al,(%rbx)
     2d4:	4e 09 2a             	rex.WRX or %r13,(%rdx)
     2d7:	a2 00 00 00 03 4f 00 	movabs %al,0x2b09004f03000000
     2de:	09 2b 
      return XDP_DROP;
     2e0:	e1 00                	loope  2e2 <balancer_ingress+0x2e2>
     2e2:	00 00                	add    %al,(%rax)
     2e4:	03 50 08             	add    0x8(%rax),%edx
     2e7:	00 0a                	add    %cl,(%rdx)
     2e9:	ed                   	in     (%dx),%eax
     2ea:	02 00                	add    (%rax),%al
    } else if (*protocol == IPPROTO_ICMPV6) {
     2ec:	00 03                	add    %al,(%rbx)
     2ee:	99                   	cltd
     2ef:	00 00                	add    %al,(%rax)
     2f1:	00 0f                	add    %cl,(%rdi)
     2f3:	47 00 00             	rex.RXB add %r8b,(%r8)
     2f6:	00 e8                	add    %ch,%al
     2f8:	03 00                	add    (%rax),%eax
     2fa:	07                   	(bad)
      return FURTHER_PROCESSING;
     2fb:	2d 05 03 00 00       	sub    $0x305,%eax
     300:	04 40                	add    $0x40,%al
     302:	02 a1 04 08 28 04    	add    0x4280804(%rcx),%ah
     308:	32 09                	xor    (%rcx),%cl
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     30a:	07                   	(bad)
     30b:	69 03 00 00 04 33    	imul   $0x33040000,(%rbx),%eax
     311:	00 09                	add    %cl,(%rcx)
     313:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     319:	34 08                	xor    $0x8,%al
     31b:	09 0c 9d 00 00 00 04 	or     %ecx,0x4000000(,%rbx,4)
     322:	35 10 09 14 7a       	xor    $0x7a140910,%eax
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     327:	03 00                	add    (%rax),%eax
     329:	00 04 36             	add    %al,(%rsi,%rsi,1)
     32c:	18 09                	sbb    %cl,(%rcx)
     32e:	15 16 01 00 00       	adc    $0x116,%eax
     333:	04 37                	add    $0x37,%al
     335:	20 09                	and    %cl,(%rcx)
     337:	2e 8b 03             	cs mov (%rbx),%eax
     33a:	00 00                	add    %al,(%rax)
     33c:	04 38                	add    $0x38,%al
     33e:	28 08                	sub    %cl,(%rax)
     340:	20 04 38             	and    %al,(%rax,%rdi,1)
     343:	09 07                	or     %eax,(%rdi)
  } else {
     345:	3d 02 00 00 04       	cmp    $0x4000002,%eax
    iph = data + nh_off;
     34a:	38 00                	cmp    %al,(%rax)
     34c:	09 09                	or     %ecx,(%rcx)
     34e:	4e 02 00             	rex.WRX add (%rax),%r8b
     351:	00 04 38             	add    %al,(%rax,%rdi,1)
     354:	08 09                	or     %cl,(%rcx)
     356:	0c cb                	or     $0xcb,%al
     358:	02 00                	add    (%rax),%al
     35a:	00 04 38             	add    %al,(%rax,%rdi,1)
     35d:	10 09                	adc    %cl,(%rcx)
    if (iph + 1 > data_end) {
     35f:	14 e8                	adc    $0xe8,%al
     361:	02 00                	add    (%rax),%al
     363:	00 04 38             	add    %al,(%rax,%rdi,1)
     366:	18 00                	sbb    %al,(%rax)
     368:	00 0a                	add    %cl,(%rdx)
     36a:	6e                   	outsb  %ds:(%rsi),(%dx)
     36b:	03 00                	add    (%rax),%eax
     36d:	00 03                	add    %al,(%rbx)
     36f:	99                   	cltd
     370:	00 00                	add    %al,(%rax)
     372:	00 04 47             	add    %al,(%rdi,%rax,2)
     375:	00 00                	add    %al,(%rax)
      return XDP_DROP;
     377:	00 0c 00             	add    %cl,(%rax,%rax,1)
     37a:	0a 7f 03             	or     0x3(%rdi),%bh
     37d:	00 00                	add    %al,(%rax)
     37f:	03 99 00 00 00 04    	add    0x4000000(%rcx),%ebx
    if (iph->ihl != 5) {
     385:	47 00 00             	rex.RXB add %r8b,(%r8)
     388:	00 80 00 03 96 03    	add    %al,0x3960300(%rax)
     38e:	00 00                	add    %al,(%rax)
     390:	10 47 00             	adc    %al,0x0(%rdi)
     393:	00 00                	add    %al,(%rax)
     395:	00 0a                	add    %cl,(%rdx)
     397:	3f                   	(bad)
      return XDP_DROP;
     398:	03 00                	add    (%rax),%eax
     39a:	00 07                	add    %al,(%rdi)
     39c:	2f                   	(bad)
     39d:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     39e:	03 00                	add    (%rax),%eax
     3a0:	00 04 49             	add    %al,(%rcx,%rcx,2)
     3a3:	02 a1 05 08 28 04    	add    0x4280805(%rcx),%ah
    pckt->tos = iph->tos;
     3a9:	43 09 07             	rex.XB or %eax,(%r15)
     3ac:	88 00                	mov    %al,(%rax)
     3ae:	00 00                	add    %al,(%rax)
     3b0:	04 44                	add    $0x44,%al
     3b2:	00 09                	add    %cl,(%rcx)
     3b4:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     3ba:	45 08 09             	or     %r9b,(%r9)
    *protocol = iph->protocol;
     3bd:	0c 9d                	or     $0x9d,%al
     3bf:	00 00                	add    %al,(%rax)
     3c1:	00 04 46             	add    %al,(%rsi,%rax,2)
     3c4:	10 09                	adc    %cl,(%rcx)
     3c6:	14 d8                	adc    $0xd8,%al
     3c8:	03 00                	add    (%rax),%eax
     3ca:	00 04 47             	add    %al,(%rdi,%rax,2)
     3cd:	18 09                	sbb    %cl,(%rcx)
    pckt->flow.proto = *protocol;
     3cf:	15 16 01 00 00       	adc    $0x116,%eax
     3d4:	04 48                	add    $0x48,%al
     3d6:	20 00                	and    %al,(%rax)
     3d8:	0a dd                	or     %ch,%bl
     3da:	03 00                	add    (%rax),%eax
     3dc:	00 03                	add    %al,(%rbx)
     3de:	99                   	cltd
     3df:	00 00                	add    %al,(%rax)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
     3e1:	00 11                	add    %dl,(%rcx)
     3e3:	47 00 00             	rex.RXB add %r8b,(%r8)
     3e6:	00 00                	add    %al,(%rax)
     3e8:	02 00                	add    (%rax),%al
     3ea:	02 00                	add    (%rax),%al
     3ec:	07                   	(bad)
     3ed:	30 f7                	xor    %dh,%bh
     3ef:	03 00                	add    (%rax),%eax
     3f1:	00 04 52             	add    %al,(%rdx,%rdx,2)
     3f4:	02 a1 06 08 28 04    	add    0x4280806(%rcx),%ah
     3fa:	4c 09 07             	or     %r8,(%rdi)
     3fd:	88 00                	mov    %al,(%rax)
     3ff:	00 00                	add    %al,(%rax)
     401:	04 4d                	add    $0x4d,%al
     403:	00 09                	add    %cl,(%rcx)
     405:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     40b:	4e 08 09             	rex.WRX or %r9b,(%rcx)
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;
     40e:	0c 29                	or     $0x29,%al
     410:	04 00                	add    $0x0,%al
     412:	00 04 4f             	add    %al,(%rdi,%rcx,2)
     415:	10 09                	adc    %cl,(%rcx)
     417:	14 5c                	adc    $0x5c,%al
     419:	04 00                	add    $0x0,%al
     41b:	00 04 50             	add    %al,(%rax,%rdx,2)
     41e:	18 09                	sbb    %cl,(%rcx)
     420:	15 16 01 00 00       	adc    $0x116,%eax
    if (iph->frag_off & PCKT_FRAGMENTED) {
     425:	04 51                	add    $0x51,%al
     427:	20 00                	and    %al,(%rax)
     429:	0a 2e                	or     (%rsi),%ch
     42b:	04 00                	add    $0x0,%al
     42d:	00 0c 31             	add    %cl,(%rcx,%rsi,1)
     430:	14 03                	adc    $0x3,%al
     432:	54                   	push   %rsp
     433:	0d 3b 04 00 00       	or     $0x43b,%eax
     438:	03 55 00             	add    0x0(%rbp),%edx
      return XDP_DROP;
     43b:	0e                   	(bad)
     43c:	10 03                	adc    %al,(%rbx)
     43e:	55                   	push   %rbp
     43f:	09 25 b1 01 00 00    	or     %esp,0x1b1(%rip)        # 5f6 <balancer_ingress+0x5f6>
    if (*protocol == IPPROTO_ICMP) {
     445:	03 56 00             	add    0x0(%rsi),%edx
     448:	09 26                	or     %esp,(%rsi)
     44a:	b9 01 00 00 03       	mov    $0x3000001,%ecx
     44f:	57                   	push   %rdi
     450:	00 00                	add    %al,(%rax)
     452:	09 1f                	or     %ebx,(%rdi)
      return FURTHER_PROCESSING;
     454:	f9                   	stc
     455:	00 00                	add    %al,(%rax)
     457:	00 03                	add    %al,(%rbx)
     459:	59                   	pop    %rcx
     45a:	10 00                	adc    %al,(%rax)
     45c:	0a 61 04             	or     0x4(%rcx),%ah
     45f:	00 00                	add    %al,(%rax)
      pckt->flow.src = iph->saddr;
     461:	03 99 00 00 00 0f    	add    0xf000000(%rcx),%ebx
     467:	47 00 00             	rex.RXB add %r8b,(%r8)
     46a:	00 00                	add    %al,(%rax)
     46c:	10 00                	adc    %al,(%rax)
     46e:	07                   	(bad)
     46f:	32 79 04             	xor    0x4(%rcx),%bh
     472:	00 00                	add    %al,(%rax)
      pckt->flow.dst = iph->daddr;
     474:	04 5b                	add    $0x5b,%al
     476:	02 a1 07 08 28 04    	add    0x4280807(%rcx),%ah
     47c:	55                   	push   %rbp
     47d:	09 07                	or     %eax,(%rdi)
     47f:	ab                   	stos   %eax,%es:(%rdi)
     480:	04 00                	add    $0x0,%al
     482:	00 04 56             	add    %al,(%rsi,%rdx,2)
     485:	00 09                	add    %cl,(%rcx)
  return FURTHER_PROCESSING;
     487:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     48d:	57                   	push   %rdi
     48e:	08 09                	or     %cl,(%rcx)
     490:	0c bc                	or     $0xbc,%al
}
     492:	04 00                	add    $0x0,%al
     494:	00 04 58             	add    %al,(%rax,%rbx,2)
  action = parse_l3_headers(
     497:	10 09                	adc    %cl,(%rcx)
     499:	14 5c                	adc    $0x5c,%al
     49b:	04 00                	add    $0x0,%al
  if (action >= 0) {
     49d:	00 04 59             	add    %al,(%rcx,%rbx,2)
     4a0:	18 09                	sbb    %cl,(%rcx)
     4a2:	15 16 01 00 00       	adc    $0x116,%eax
    return action;
     4a7:	04 5a                	add    $0x5a,%al
     4a9:	20 00                	and    %al,(%rax)
     4ab:	0a b0 04 00 00 03    	or     0x3000004(%rax),%dh
     4b1:	99                   	cltd
     4b2:	00 00                	add    %al,(%rax)
     4b4:	00 04 47             	add    %al,(%rdi,%rax,2)
  action = handle_if_icmp(data, data_end, th_off, &pckt, protocol);
     4b7:	00 00                	add    %al,(%rax)
     4b9:	00 06                	add    %al,(%rsi)
     4bb:	00 0a                	add    %cl,(%rdx)
     4bd:	c1 04 00 00          	roll   $0x0,(%rax,%rax,1)
     4c1:	0c 35                	or     $0x35,%al
     4c3:	10 03                	adc    %al,(%rbx)
     4c5:	5d                   	pop    %rbp
     4c6:	09 33                	or     %esi,(%rbx)
     4c8:	e1 00                	loope  4ca <balancer_ingress+0x4ca>
     4ca:	00 00                	add    %al,(%rax)
     4cc:	03 5e 00             	add    0x0(%rsi),%ebx
     4cf:	09 34 e1             	or     %esi,(%rcx,%riz,8)
     4d2:	00 00                	add    %al,(%rax)
     4d4:	00 03                	add    %al,(%rbx)
     4d6:	5f                   	pop    %rdi
     4d7:	08 00                	or     %al,(%rax)
     4d9:	07                   	(bad)
     4da:	36 e4 04             	ss in  $0x4,%al
     4dd:	00 00                	add    %al,(%rax)
     4df:	04 64                	add    $0x64,%al
     4e1:	02 a1 08 08 28 04    	add    0x4280808(%rcx),%ah
     4e7:	5e                   	pop    %rsi
     4e8:	09 07                	or     %eax,(%rdi)
     4ea:	ab                   	stos   %eax,%es:(%rdi)
     4eb:	04 00                	add    $0x0,%al
     4ed:	00 04 5f             	add    %al,(%rdi,%rbx,2)
     4f0:	00 09                	add    %cl,(%rcx)
     4f2:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     4f8:	60                   	(bad)
     4f9:	08 09                	or     %cl,(%rcx)
  if (protocol == IPPROTO_ICMPV6) {
     4fb:	0c 9d                	or     $0x9d,%al
     4fd:	00 00                	add    %al,(%rax)
     4ff:	00 04 61             	add    %al,(%rcx,%riz,2)
     502:	10 09                	adc    %cl,(%rcx)
     504:	14 5c                	adc    $0x5c,%al
     506:	04 00                	add    $0x0,%al
     508:	00 04 62             	add    %al,(%rdx,%riz,2)
    return parse_icmpv6(data, data_end, off, pckt);
     50b:	18 09                	sbb    %cl,(%rcx)
     50d:	15 16 01 00 00       	adc    $0x116,%eax
     512:	04 63                	add    $0x63,%al
     514:	20 00                	and    %al,(%rax)
     516:	07                   	(bad)
     517:	37                   	(bad)
     518:	21 05 00 00 04 6c    	and    %eax,0x6c040000(%rip)        # 6c04051e <bpf_xdp_adjust_head+0x6c03857e>
     51e:	02 a1 09 08 28 04    	add    0x4280809(%rcx),%ah
     524:	66 09 07             	or     %ax,(%rdi)
     527:	88 00                	mov    %al,(%rax)
     529:	00 00                	add    %al,(%rax)
     52b:	04 67                	add    $0x67,%al
     52d:	00 09                	add    %cl,(%rcx)
     52f:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     535:	68 08 09 0c 75       	push   $0x750c0908
     53a:	01 00                	add    %eax,(%rax)
     53c:	00 04 69             	add    %al,(%rcx,%rbp,2)
     53f:	10 09                	adc    %cl,(%rcx)
     541:	14 64                	adc    $0x64,%al
  icmp_hdr = data + off;
     543:	01 00                	add    %eax,(%rax)
     545:	00 04 6a             	add    %al,(%rdx,%rbp,2)
     548:	18 09                	sbb    %cl,(%rcx)
     54a:	15 16 01 00 00       	adc    $0x116,%eax
     54f:	04 6b                	add    $0x6b,%al
     551:	20 00                	and    %al,(%rax)
     553:	07                   	(bad)
     554:	38 5e 05             	cmp    %bl,0x5(%rsi)
     557:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
     559:	04 75                	add    $0x75,%al
     55b:	02 a1 0a 08 28 04    	add    0x428080a(%rcx),%ah
     561:	6f                   	outsl  %ds:(%rsi),(%dx)
     562:	09 07                	or     %eax,(%rdi)
     564:	ab                   	stos   %eax,%es:(%rdi)
     565:	04 00                	add    $0x0,%al
     567:	00 04 70             	add    %al,(%rax,%rsi,2)
     56a:	00 09                	add    %cl,(%rcx)
     56c:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
    return XDP_DROP;
     572:	71 08                	jno    57c <balancer_ingress+0x57c>
     574:	09 0c bc             	or     %ecx,(%rsp,%rdi,4)
     577:	04 00                	add    $0x0,%al
     579:	00 04 72             	add    %al,(%rdx,%rsi,2)
     57c:	10 09                	adc    %cl,(%rcx)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     57e:	14 90                	adc    $0x90,%al
     580:	05 00 00 04 73       	add    $0x73040000,%eax
     585:	18 09                	sbb    %cl,(%rcx)
     587:	15 16 01 00 00       	adc    $0x116,%eax
     58c:	04 74                	add    $0x74,%al
     58e:	20 00                	and    %al,(%rax)
     590:	0a 95 05 00 00 03    	or     0x3000005(%rbp),%dl
    return send_icmp6_reply(data, data_end);
     596:	99                   	cltd
     597:	00 00                	add    %al,(%rax)
     599:	00 0f                	add    %cl,(%rdi)
     59b:	47 00 00             	rex.RXB add %r8b,(%r8)
     59e:	00 00                	add    %al,(%rax)
     5a0:	04 00                	add    $0x0,%al
     5a2:	07                   	(bad)
     5a3:	39 ad 05 00 00 04    	cmp    %ebp,0x4000005(%rbp)
     5a9:	7e 02                	jle    5ad <balancer_ingress+0x5ad>
     5ab:	a1 0b 08 28 04 78 09 	movabs 0xab0709780428080b,%eax
     5b2:	07 ab 
  __u64 off = 0;
     5b4:	04 00                	add    $0x0,%al
     5b6:	00 04 79             	add    %al,(%rcx,%rdi,2)
     5b9:	00 09                	add    %cl,(%rcx)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     5bb:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     5c1:	7a 08                	jp     5cb <balancer_ingress+0x5cb>
     5c3:	09 0c df             	or     %ecx,(%rdi,%rbx,8)
     5c6:	05 00 00 04 7b       	add    $0x7b040000,%eax
     5cb:	10 09                	adc    %cl,(%rcx)
       sizeof(struct icmp6hdr)) > data_end) {
     5cd:	14 64                	adc    $0x64,%al
     5cf:	01 00                	add    %eax,(%rax)
     5d1:	00 04 7c             	add    %al,(%rsp,%rdi,2)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     5d4:	18 09                	sbb    %cl,(%rcx)
    return XDP_DROP;
     5d6:	15 16 01 00 00       	adc    $0x116,%eax
     5db:	04 7d                	add    $0x7d,%al
     5dd:	20 00                	and    %al,(%rax)
     5df:	0a e4                	or     %ah,%ah
     5e1:	05 00 00 0c 47       	add    $0x470c0000,%eax
  off += sizeof(struct ethhdr);
     5e6:	68 03 8e 09 3a       	push   $0x3a098e03
     5eb:	e1 00                	loope  5ed <balancer_ingress+0x5ed>
     5ed:	00 00                	add    %al,(%rax)
     5ef:	03 8f 00 09 3b e1    	add    -0x1ec4f700(%rdi),%ecx
     5f5:	00 00                	add    %al,(%rax)
  ip6h = data + off;
     5f7:	00 03                	add    %al,(%rbx)
     5f9:	90                   	nop
     5fa:	08 09                	or     %cl,(%rcx)
     5fc:	3c e1                	cmp    $0xe1,%al
     5fe:	00 00                	add    %al,(%rax)
     600:	00 03                	add    %al,(%rbx)
     602:	91                   	xchg   %eax,%ecx
     603:	10 09                	adc    %cl,(%rcx)
     605:	3d e1 00 00 00       	cmp    $0xe1,%eax
     60a:	03 92 18 09 3e e1    	add    -0x1ec1f6e8(%rdx),%edx
  off += sizeof(struct ipv6hdr);
     610:	00 00                	add    %al,(%rax)
     612:	00 03                	add    %al,(%rbx)
     614:	93                   	xchg   %eax,%ebx
     615:	20 09                	and    %cl,(%rcx)
     617:	3f                   	(bad)
     618:	e1 00                	loope  61a <balancer_ingress+0x61a>
     61a:	00 00                	add    %al,(%rax)
     61c:	03 94 28 09 40 e1 00 	add    0xe14009(%rax,%rbp,1),%edx
  icmp_hdr = data + off;
     623:	00 00                	add    %al,(%rax)
     625:	03 95 30 09 41 e1    	add    -0x1ebef6d0(%rbp),%edx
     62b:	00 00                	add    %al,(%rax)
     62d:	00 03                	add    %al,(%rbx)
     62f:	96                   	xchg   %eax,%esi
     630:	38 09                	cmp    %cl,(%rcx)
     632:	42 e1 00             	rex.X loope 635 <balancer_ingress+0x635>
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
     635:	00 00                	add    %al,(%rax)
     637:	03 97 40 09 43 e1    	add    -0x1ebcf6c0(%rdi),%edx
  icmp_hdr->icmp6_cksum -= 0x0001;
     63d:	00 00                	add    %al,(%rax)
     63f:	00 03                	add    %al,(%rbx)
     641:	98                   	cwtl
     642:	48 09 44 e1 00       	or     %rax,0x0(%rcx,%riz,8)
     647:	00 00                	add    %al,(%rax)
     649:	03 99 50 09 45 e1    	add    -0x1ebaf6b0(%rcx),%ebx
  ip6h->hop_limit = DEFAULT_TTL;
     64f:	00 00                	add    %al,(%rax)
     651:	00 03                	add    %al,(%rbx)
     653:	9a                   	(bad)
     654:	58                   	pop    %rax
     655:	09 46 e1             	or     %eax,-0x1f(%rsi)
     658:	00 00                	add    %al,(%rax)
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
     65a:	00 03                	add    %al,(%rbx)
     65c:	9b                   	fwait
     65d:	60                   	(bad)
     65e:	00 07                	add    %al,(%rdi)
     660:	48 6a 06             	rex.W push $0x6
     663:	00 00                	add    %al,(%rax)
     665:	04 87                	add    $0x87,%al
     667:	02 a1 0c 08 28 04    	add    0x428080c(%rcx),%ah
     66d:	81 09 07 ab 04 00    	orl    $0x4ab07,(%rcx)
     673:	00 04 82             	add    %al,(%rdx,%rax,4)
     676:	00 09                	add    %cl,(%rcx)
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
     678:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     67e:	83 08 09             	orl    $0x9,(%rax)
     681:	0c 9c                	or     $0x9c,%al
     683:	06                   	(bad)
     684:	00 00                	add    %al,(%rax)
     686:	04 84                	add    $0x84,%al
     688:	10 09                	adc    %cl,(%rcx)
     68a:	14 64                	adc    $0x64,%al
     68c:	01 00                	add    %eax,(%rax)
     68e:	00 04 85 18 09 15 16 	add    %al,0x16150918(,%rax,4)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
     695:	01 00                	add    %eax,(%rax)
     697:	00 04 86             	add    %al,(%rsi,%rax,4)
     69a:	20 00                	and    %al,(%rax)
     69c:	0a a1 06 00 00 0c    	or     0xc000006(%rcx),%ah
     6a2:	4a 28 03             	rex.WX sub %al,(%rbx)
     6a5:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     6a6:	09 3a                	or     %edi,(%rdx)
     6a8:	e1 00                	loope  6aa <balancer_ingress+0x6aa>
     6aa:	00 00                	add    %al,(%rax)
     6ac:	03 a8 00 09 3e e1    	add    -0x1ec1f700(%rax),%ebp
  return swap_mac_and_send(data, data_end);
     6b2:	00 00                	add    %al,(%rax)
     6b4:	00 03                	add    %al,(%rbx)
     6b6:	a9 08 09 3c e1       	test   $0xe13c0908,%eax
     6bb:	00 00                	add    %al,(%rax)
     6bd:	00 03                	add    %al,(%rbx)
     6bf:	aa                   	stos   %al,%es:(%rdi)
     6c0:	10 09                	adc    %cl,(%rcx)
     6c2:	3f                   	(bad)
     6c3:	e1 00                	loope  6c5 <balancer_ingress+0x6c5>
     6c5:	00 00                	add    %al,(%rax)
     6c7:	03 ab 18 09 49 e1    	add    -0x1eb6f6e8(%rbx),%ebp
     6cd:	00 00                	add    %al,(%rax)
  eth = data;
     6cf:	00 03                	add    %al,(%rbx)
     6d1:	ac                   	lods   %ds:(%rsi),%al
     6d2:	20 00                	and    %al,(%rax)
     6d4:	07                   	(bad)
     6d5:	4b df 06             	rex.WXB filds (%r14)
     6d8:	00 00                	add    %al,(%rax)
     6da:	04 90                	add    $0x90,%al
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     6dc:	02 a1 0d 08 28 04    	add    0x428080d(%rcx),%ah
     6e2:	8a 09                	mov    (%rcx),%cl
     6e4:	07                   	(bad)
     6e5:	ab                   	stos   %eax,%es:(%rdi)
     6e6:	04 00                	add    $0x0,%al
     6e8:	00 04 8b             	add    %al,(%rbx,%rcx,4)
     6eb:	00 09                	add    %cl,(%rcx)
     6ed:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     6f3:	8c 08                	mov    %cs,(%rax)
     6f5:	09 0c bc             	or     %ecx,(%rsp,%rdi,4)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     6f8:	04 00                	add    $0x0,%al
     6fa:	00 04 8d 10 09 14 ee 	add    %al,-0x11ebf6f0(,%rcx,4)
     701:	01 00                	add    %eax,(%rax)
     703:	00 04 8e             	add    %al,(%rsi,%rcx,4)
     706:	18 09                	sbb    %cl,(%rcx)
     708:	15 16 01 00 00       	adc    $0x116,%eax
     70d:	04 8f                	add    $0x8f,%al
     70f:	20 00                	and    %al,(%rax)
     711:	07                   	(bad)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     712:	4c 1c 07             	rex.WR sbb $0x7,%al
     715:	00 00                	add    %al,(%rax)
     717:	04 a3                	add    $0xa3,%al
     719:	02 a1 0e 08 28 04    	add    0x428080e(%rcx),%ah
     71f:	9d                   	popf
     720:	09 07                	or     %eax,(%rdi)
     722:	88 00                	mov    %al,(%rax)
     724:	00 00                	add    %al,(%rax)
     726:	04 9e                	add    $0x9e,%al
     728:	00 09                	add    %cl,(%rcx)
     72a:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
  return swap_mac_and_send(data, data_end);
     730:	9f                   	lahf
     731:	08 09                	or     %cl,(%rcx)
     733:	0c 9d                	or     $0x9d,%al
     735:	00 00                	add    %al,(%rax)
}
     737:	00 04 a0             	add    %al,(%rax,%riz,4)
     73a:	10 09                	adc    %cl,(%rcx)
    return send_icmp6_reply(data, data_end);
     73c:	14 4e                	adc    $0x4e,%al
     73e:	07                   	(bad)
     73f:	00 00                	add    %al,(%rax)
     741:	04 a1                	add    $0xa1,%al
     743:	18 09                	sbb    %cl,(%rcx)
     745:	15 16 01 00 00       	adc    $0x116,%eax
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
     74a:	04 a2                	add    $0xa2,%al
     74c:	20 00                	and    %al,(%rax)
     74e:	0a 53 07             	or     0x7(%rbx),%dl
     751:	00 00                	add    %al,(%rax)
     753:	03 99 00 00 00 11    	add    0x11000000(%rcx),%ebx
      (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {
     759:	47 00 00             	rex.RXB add %r8b,(%r8)
     75c:	00 fe                	add    %bh,%dh
     75e:	ff                   	(bad)
     75f:	ff 00                	incl   (%rax)
     761:	00 07                	add    %al,(%rdi)
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
     763:	4d 6d                	rex.WRB insl (%dx),%es:(%rdi)
    return XDP_PASS;
     765:	07                   	(bad)
     766:	00 00                	add    %al,(%rax)
     768:	04 dc                	add    $0xdc,%al
     76a:	02 a1 0f 08 28 04    	add    0x428080f(%rcx),%ah
     770:	d6                   	(bad)
     771:	09 07                	or     %eax,(%rdi)
     773:	ab                   	stos   %eax,%es:(%rdi)
  if (icmp_hdr->icmp6_type == ICMPV6_PKT_TOOBIG) {
     774:	04 00                	add    $0x0,%al
     776:	00 04 d7             	add    %al,(%rdi,%rdx,8)
     779:	00 09                	add    %cl,(%rcx)
     77b:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     781:	d8 08                	fmuls  (%rax)
     783:	09 0c 9f             	or     %ecx,(%rdi,%rbx,4)
     786:	07                   	(bad)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     787:	00 00                	add    %al,(%rax)
     789:	04 d9                	add    $0xd9,%al
     78b:	10 09                	adc    %cl,(%rcx)
     78d:	14 64                	adc    $0x64,%al
     78f:	01 00                	add    %eax,(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
     791:	00 04 da             	add    %al,(%rdx,%rbx,8)
     794:	18 09                	sbb    %cl,(%rcx)
     796:	15 16 01 00 00       	adc    $0x116,%eax
     79b:	04 db                	add    $0xdb,%al
     79d:	20 00                	and    %al,(%rax)
     79f:	0a a4 07 00 00 0c 50 	or     0x500c0000(%rdi,%rax,1),%ah
     7a6:	20 03                	and    %al,(%rbx)
     7a8:	9f                   	lahf
     7a9:	09 3a                	or     %edi,(%rdx)
     7ab:	e1 00                	loope  7ad <balancer_ingress+0x7ad>
     7ad:	00 00                	add    %al,(%rax)
     7af:	03 a0 00 09 45 e1    	add    -0x1ebaf700(%rax),%esp
     7b5:	00 00                	add    %al,(%rax)
     7b7:	00 03                	add    %al,(%rbx)
     7b9:	a1 08 09 4e e1 00 00 	movabs 0x3000000e14e0908,%eax
     7c0:	00 03 
     7c2:	a2 10 09 4f e1 00 00 	movabs %al,0x3000000e14f0910
     7c9:	00 03 
     7cb:	a3 18 00 07 51 d9 07 	movabs %eax,0x7d951070018
     7d2:	00 00 
     7d4:	04 e4                	add    $0xe4,%al
     7d6:	02 a1 10 08 28 04    	add    0x4280810(%rcx),%ah
     7dc:	de 09                	fimuls (%rcx)
     7de:	07                   	(bad)
     7df:	ab                   	stos   %eax,%es:(%rdi)
     7e0:	04 00                	add    $0x0,%al
     7e2:	00 04 df             	add    %al,(%rdi,%rbx,8)
     7e5:	00 09                	add    %cl,(%rcx)
     7e7:	09 9d 00 00 00 04    	or     %ebx,0x4000000(%rbp)
     7ed:	e0 08                	loopne 7f7 <balancer_ingress+0x7f7>
     7ef:	09 0c bc             	or     %ecx,(%rsp,%rdi,4)
     7f2:	04 00                	add    $0x0,%al
     7f4:	00 04 e1             	add    %al,(%rcx,%riz,8)
     7f7:	10 09                	adc    %cl,(%rcx)
     7f9:	14 ee                	adc    $0xee,%al
     7fb:	01 00                	add    %eax,(%rax)
     7fd:	00 04 e2             	add    %al,(%rdx,%riz,8)
     800:	18 09                	sbb    %cl,(%rcx)
     802:	15 16 01 00 00       	adc    $0x116,%eax
    struct lb_stats* icmp_ptb_v6_stats =
     807:	04 e3                	add    $0xe3,%al
     809:	20 00                	and    %al,(%rax)
     80b:	07                   	(bad)
    if (!icmp_ptb_v6_stats) {
     80c:	52                   	push   %rdx
     80d:	16                   	(bad)
     80e:	08 00                	or     %al,(%rax)
     810:	00 04 f8             	add    %al,(%rax,%rdi,8)
     813:	02 a1 11 08 28 04    	add    0x4280811(%rcx),%ah
      return XDP_DROP;
     819:	e7 09                	out    %eax,$0x9
     81b:	07                   	(bad)
     81c:	83 08 00             	orl    $0x0,(%rax)
     81f:	00 04 e8             	add    %al,(%rax,%rbp,8)
     822:	00 09                	add    %cl,(%rcx)
     824:	09 75 01             	or     %esi,0x1(%rbp)
    icmp_ptb_v6_stats->v1 += 1;
     827:	00 00                	add    %al,(%rax)
     829:	04 e9                	add    $0xe9,%al
     82b:	08 09                	or     %cl,(%rcx)
     82d:	0c 9d                	or     $0x9d,%al
     82f:	00 00                	add    %al,(%rax)
     831:	00 04 ea             	add    %al,(%rdx,%rbp,8)
     834:	10 09                	adc    %cl,(%rcx)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     836:	14 ee                	adc    $0xee,%al
     838:	01 00                	add    %eax,(%rax)
     83a:	00 04 eb             	add    %al,(%rbx,%rbp,8)
     83d:	18 09                	sbb    %cl,(%rcx)
     83f:	15 64 01 00 00       	adc    $0x164,%eax
     844:	04 ec                	add    $0xec,%al
     846:	20 09                	and    %cl,(%rcx)
     848:	2e 94                	cs xchg %eax,%esp
     84a:	08 00                	or     %al,(%rax)
     84c:	00 04 ed 28 08 28 04 	add    %al,0x4280828(,%rbp,8)
     853:	ed                   	in     (%dx),%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     854:	09 07                	or     %eax,(%rdi)
     856:	64 01 00             	add    %eax,%fs:(%rax)
     859:	00 04 ed 00 09 09 9d 	add    %al,-0x62f6f700(,%rbp,8)
      icmp_ptb_v6_stats->v2 += 1;
     860:	00 00                	add    %al,(%rax)
     862:	00 04 ed 08 09 0c a4 	add    %al,-0x5bf3f6f8(,%rbp,8)
     869:	08 00                	or     %al,(%rax)
     86b:	00 04 ed 10 09 14 5c 	add    %al,0x5c140910(,%rbp,8)
     872:	04 00                	add    $0x0,%al
  }
     874:	00 04 ed 18 09 15 64 	add    %al,0x64150918(,%rbp,8)
  off += sizeof(struct icmp6hdr);
     87b:	01 00                	add    %eax,(%rax)
     87d:	00 04 ed 20 00 00 0a 	add    %al,0xa000020(,%rbp,8)
     884:	88 08                	mov    %cl,(%rax)
     886:	00 00                	add    %al,(%rax)
  ip6h = data + off;
     888:	03 99 00 00 00 04    	add    0x4000000(%rcx),%ebx
     88e:	47 00 00             	rex.RXB add %r8b,(%r8)
     891:	00 0d 00 03 9f 08    	add    %cl,0x89f0300(%rip)        # 89f0b97 <bpf_xdp_adjust_head+0x89e8bf7>
     897:	00 00                	add    %al,(%rax)
     899:	10 47 00             	adc    %al,0x0(%rdi)
  if (ip6h + 1 > data_end) {
     89c:	00 00                	add    %al,(%rax)
     89e:	00 0a                	add    %cl,(%rdx)
     8a0:	50                   	push   %rax
     8a1:	08 00                	or     %al,(%rax)
     8a3:	00 0a                	add    %cl,(%rdx)
     8a5:	f9                   	stc
     8a6:	00 00                	add    %al,(%rax)
     8a8:	00 12                	add    %dl,(%rdx)
     8aa:	53                   	push   %rbx
     8ab:	b4 08                	mov    $0x8,%ah
     8ad:	00 00                	add    %al,(%rax)
     8af:	06                   	(bad)
     8b0:	34 02                	xor    $0x2,%al
     8b2:	a1 12 0a b9 08 00 00 	movabs 0xe913000008b90a12,%eax
     8b9:	13 e9 
    return XDP_DROP;
     8bb:	00 00                	add    %al,(%rax)
     8bd:	00 12                	add    %dl,(%rdx)
  pckt->flow.proto = ip6h->nexthdr;
     8bf:	54                   	push   %rsp
     8c0:	c9                   	leave
     8c1:	08 00                	or     %al,(%rax)
     8c3:	00 06                	add    %al,(%rsi)
     8c5:	1a 02                	sbb    (%rdx),%al
     8c7:	a1 13 0a ce 08 00 00 	movabs 0xde14000008ce0a13,%eax
     8ce:	14 de 
     8d0:	08 00                	or     %al,(%rax)
     8d2:	00 15 de 08 00 00    	add    %dl,0x8de(%rip)        # 11b6 <balancer_ingress+0x11b6>
  pckt->flags |= F_ICMP;
     8d8:	15 de 08 00 00       	adc    $0x8de,%eax
     8dd:	00 16                	add    %dl,(%rsi)
     8df:	12 55 b4             	adc    -0x4c(%rbp),%dl
     8e2:	08 00                	or     %al,(%rax)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     8e4:	00 06                	add    %al,(%rsi)
     8e6:	2d 02 a1 14 12       	sub    $0x1214a102,%eax
     8eb:	56                   	push   %rsi
     8ec:	f5                   	cmc
     8ed:	08 00                	or     %al,(%rax)
     8ef:	00 06                	add    %al,(%rsi)
     8f1:	1c 02                	sbb    $0x2,%al
     8f3:	a1 15 0a fa 08 00 00 	movabs 0x9914000008fa0a15,%eax
     8fa:	14 99 
     8fc:	00 00                	add    %al,(%rax)
     8fe:	00 15 de 08 00 00    	add    %dl,0x8de(%rip)        # 11e2 <balancer_ingress+0x11e2>
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     904:	15 de 08 00 00       	adc    $0x8de,%eax
     909:	15 de 08 00 00       	adc    $0x8de,%eax
     90e:	15 e9 00 00 00       	adc    $0xe9,%eax
     913:	00 12                	add    %dl,(%rdx)
     915:	57                   	push   %rdi
     916:	1f                   	(bad)
     917:	09 00                	or     %eax,(%rax)
     919:	00 06                	add    %al,(%rsi)
     91b:	60                   	(bad)
     91c:	02 a1 16 0a 24 09    	add    0x9240a16(%rcx),%ah
  return FURTHER_PROCESSING;
     922:	00 00                	add    %al,(%rax)
     924:	14 99                	adc    $0x99,%al
     926:	00 00                	add    %al,(%rax)
     928:	00 15 de 08 00 00    	add    %dl,0x8de(%rip)        # 120c <balancer_ingress+0x120c>
}
     92e:	15 99 00 00 00       	adc    $0x99,%eax
    return parse_icmpv6(data, data_end, off, pckt);
     933:	00 17                	add    %dl,(%rdi)
     935:	aa                   	stos   %al,%es:(%rdi)
     936:	00 00                	add    %al,(%rax)
     938:	00 5d 04             	add    %bl,0x4(%rbp)
  } else if (protocol == IPPROTO_ICMP) {
     93b:	07                   	(bad)
     93c:	28 0c 18             	sub    %cl,(%rax,%rbx,1)
     93f:	58                   	pop    %rax
     940:	00 18                	add    %bl,(%rax)
     942:	59                   	pop    %rcx
     943:	01 18                	add    %ebx,(%rax)
     945:	5a                   	pop    %rdx
     946:	02 18                	add    (%rax),%bl
     948:	5b                   	pop    %rbx
     949:	03 18                	add    (%rax),%ebx
    return parse_icmp(data, data_end, off, pckt);
     94b:	5c                   	pop    %rsp
     94c:	04 00                	add    $0x0,%al
     94e:	19 aa 00 00 00 04    	sbb    %ebp,0x4000000(%rdx)
     954:	08 1d 18 5e 00 18    	or     %bl,0x18005e18(%rip)        # 18006772 <bpf_xdp_adjust_head+0x17ffe7d2>
     95a:	5f                   	pop    %rdi
     95b:	01 18                	add    %ebx,(%rax)
     95d:	60                   	(bad)
     95e:	02 18                	add    (%rax),%bl
     960:	61                   	(bad)
     961:	04 18                	add    $0x18,%al
     963:	62 06                	(bad)
     965:	18 63 08             	sbb    %ah,0x8(%rbx)
     968:	18 64 0c 18          	sbb    %ah,0x18(%rsp,%rcx,1)
     96c:	65 11 18             	adc    %ebx,%gs:(%rax)
     96f:	66 16                	data16 (bad)
     971:	18 67 1d             	sbb    %ah,0x1d(%rdi)
     974:	18 68 21             	sbb    %ch,0x21(%rax)
     977:	18 69 29             	sbb    %ch,0x29(%rcx)
     97a:	18 6a 2e             	sbb    %ch,0x2e(%rdx)
     97d:	18 6b 2f             	sbb    %ch,0x2f(%rbx)
     980:	18 6c 32 18          	sbb    %ch,0x18(%rdx,%rsi,1)
  icmp_hdr = data + off;
     984:	6d                   	insl   (%dx),%es:(%rdi)
     985:	33 18                	xor    (%rax),%ebx
     987:	6e                   	outsb  %ds:(%rsi),(%dx)
     988:	5c                   	pop    %rsp
     989:	18 6f 5e             	sbb    %ch,0x5e(%rdi)
     98c:	18 70 62             	sbb    %dh,0x62(%rax)
     98f:	18 71 67             	sbb    %dh,0x67(%rcx)
     992:	18 72 6c             	sbb    %dh,0x6c(%rdx)
     995:	18 73 73             	sbb    %dh,0x73(%rbx)
  if (icmp_hdr + 1 > data_end) {
     998:	18 74 84 01          	sbb    %dh,0x1(%rsp,%rax,4)
     99c:	18 75 88             	sbb    %dh,-0x78(%rbp)
     99f:	01 18                	add    %ebx,(%rax)
     9a1:	76 89                	jbe    92c <balancer_ingress+0x92c>
     9a3:	01 18                	add    %ebx,(%rax)
     9a5:	77 8f                	ja     936 <balancer_ingress+0x936>
     9a7:	01 18                	add    %ebx,(%rax)
     9a9:	78 90                	js     93b <balancer_ingress+0x93b>
     9ab:	01 18                	add    %ebx,(%rax)
     9ad:	79 ff                	jns    9ae <balancer_ingress+0x9ae>
    return XDP_DROP;
     9af:	01 18                	add    %ebx,(%rax)
     9b1:	7a 80                	jp     933 <balancer_ingress+0x933>
     9b3:	02 18                	add    (%rax),%bl
     9b5:	7b 86                	jnp    93d <balancer_ingress+0x93d>
     9b7:	02 18                	add    (%rax),%bl
     9b9:	7c 87                	jl     942 <balancer_ingress+0x942>
     9bb:	02 00                	add    (%rax),%al
  if (icmp_hdr->type == ICMP_ECHO) {
     9bd:	05 7d 05 08 0a       	add    $0xa08057d,%eax
     9c2:	43 00 00             	rex.XB add %al,(%r8)
     9c5:	00 0a                	add    %cl,(%rdx)
     9c7:	c5 01 00             	(bad)
     9ca:	00 0a                	add    %cl,(%rdx)
     9cc:	d0 09                	rorb   (%rcx)
     9ce:	00 00                	add    %al,(%rax)
    return send_icmp_reply(data, data_end);
     9d0:	0c 81                	or     $0x81,%al
     9d2:	0e                   	(bad)
     9d3:	09 29                	or     %ebp,(%rcx)
     9d5:	09 1f                	or     %ebx,(%rdi)
     9d7:	f9                   	stc
     9d8:	00 00                	add    %al,(%rax)
     9da:	00 09                	add    %cl,(%rcx)
     9dc:	2a 00                	sub    (%rax),%al
     9de:	09 7e a2             	or     %edi,-0x5e(%rsi)
     9e1:	00 00                	add    %al,(%rax)
     9e3:	00 09                	add    %cl,(%rcx)
     9e5:	2b 01                	sub    (%rcx),%eax
     9e7:	09 7f f9             	or     %edi,-0x7(%rdi)
     9ea:	00 00                	add    %al,(%rax)
  __u32 tmp_addr = 0;
     9ec:	00 09                	add    %cl,(%rcx)
     9ee:	2e 05 09 80 fa 09    	cs add $0x9fa8009,%eax
     9f4:	00 00                	add    %al,(%rax)
  __u64 csum = 0;
     9f6:	09 32                	or     %esi,(%rdx)
     9f8:	06                   	(bad)
     9f9:	00 03                	add    %al,(%rbx)
     9fb:	f9                   	stc
     9fc:	00 00                	add    %al,(%rax)
     9fe:	00 04 47             	add    %al,(%rdi,%rax,2)
  __u64 off = 0;
     a01:	00 00                	add    %al,(%rax)
     a03:	00 08                	add    %cl,(%rax)
     a05:	00 0a                	add    %cl,(%rdx)
     a07:	0b 0a                	or     (%rdx),%ecx
     a09:	00 00                	add    %al,(%rax)
     a0b:	0c 83                	or     $0x83,%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     a0d:	09 09                	or     %ecx,(%rcx)
     a0f:	35 09 1f f9 00       	xor    $0xf91f09,%eax
     a14:	00 00                	add    %al,(%rax)
     a16:	09 36                	or     %esi,(%rsi)
     a18:	00 09                	add    %cl,(%rcx)
     a1a:	82                   	(bad)
     a1b:	fa                   	cli
     a1c:	09 00                	or     %eax,(%rax)
     a1e:	00 09                	add    %cl,(%rcx)
       sizeof(struct icmphdr)) > data_end) {
     a20:	37                   	(bad)
     a21:	01 00                	add    %eax,(%rax)
     a23:	0a 28                	or     (%rax),%ch
     a25:	0a 00                	or     (%rax),%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     a27:	00 0b                	add    %cl,(%rbx)
    return XDP_DROP;
     a29:	aa                   	stos   %al,%es:(%rdi)
     a2a:	00 00                	add    %al,(%rax)
     a2c:	00 84 0a 35 1a 85 00 	add    %al,0x851a35(%rdx,%rcx,1)
     a33:	a8 02                	test   $0x2,%al
     a35:	99                   	cltd
     a36:	00 00                	add    %al,(%rax)
  off += sizeof(struct ethhdr);
     a38:	00 1b                	add    %bl,(%rbx)
     a3a:	86 00                	xchg   %al,(%rax)
     a3c:	a8 02                	test   $0x2,%al
     a3e:	11 0e                	adc    %ecx,(%rsi)
     a40:	00 00                	add    %al,(%rax)
     a42:	1b 91 00 a8 02 e1    	sbb    -0x1efd5800(%rcx),%edx
     a48:	00 00                	add    %al,(%rax)
  iph = data + off;
     a4a:	00 1b                	add    %bl,(%rbx)
     a4c:	92                   	xchg   %eax,%edx
     a4d:	00 a8 02 7b 0e 00    	add    %ch,0xe7b02(%rax)
     a53:	00 1c 87             	add    %bl,(%rdi,%rax,4)
     a56:	00 a9 02 de 08 00    	add    %ch,0x8de02(%rcx)
     a5c:	00 1c 88             	add    %bl,(%rax,%rcx,4)
  off += sizeof(struct iphdr);
     a5f:	00 aa 02 de 08 00    	add    %ch,0x8de02(%rdx)
     a65:	00 1c 94             	add    %bl,(%rsp,%rdx,4)
     a68:	00 ab 02 ae 00 00    	add    %ch,0xae02(%rbx)
     a6e:	00 1c 25 00 ac 02 29 	add    %bl,0x2902ac00
  icmp_hdr = data + off;
     a75:	04 00                	add    $0x0,%al
     a77:	00 1c 95 00 ad 02 7f 	add    %bl,0x7f02ad00(,%rdx,4)
     a7e:	0e                   	(bad)
     a7f:	00 00                	add    %al,(%rax)
     a81:	1c 17                	sbb    $0x17,%al
     a83:	00 ae 02 7a 01 00    	add    %ch,0x17a02(%rsi)
  icmp_hdr->type = ICMP_ECHOREPLY;
     a89:	00 1c 9a             	add    %bl,(%rdx,%rbx,4)
     a8c:	00 af 02 d1 01 00    	add    %ch,0x1d102(%rdi)
  icmp_hdr->checksum += 0x0008;
     a92:	00 1c 9b             	add    %bl,(%rbx,%rbx,4)
     a95:	00 b0 02 bc 04 00    	add    %dh,0x4bc02(%rax)
     a9b:	00 1c 9c             	add    %bl,(%rsp,%rbx,4)
     a9e:	00 b2 02 f9 00 00    	add    %dh,0xf902(%rdx)
  iph->ttl = DEFAULT_TTL;
     aa4:	00 1c 9d 00 b3 02 c5 	add    %bl,-0x3afd4d00(,%rbx,4)
     aab:	01 00                	add    %eax,(%rax)
  tmp_addr = iph->daddr;
     aad:	00 1c 9e             	add    %bl,(%rsi,%rbx,4)
     ab0:	00 b5 02 99 00 00    	add    %dh,0x9902(%rbp)
     ab6:	00 1c 20             	add    %bl,(%rax,%riz,1)
     ab9:	00 b6 02 a2 00 00    	add    %dh,0xa202(%rsi)
  iph->daddr = iph->saddr;
     abf:	00 1c 9f             	add    %bl,(%rdi,%rbx,4)
     ac2:	00 b7 02 a2 00 00    	add    %dh,0xa202(%rdi)
     ac8:	00 1c a0             	add    %bl,(%rax,%riz,4)
     acb:	00 b8 02 c5 01 00    	add    %bh,0x1c502(%rax)
  iph->saddr = tmp_addr;
     ad1:	00 1c a1             	add    %bl,(%rcx,%riz,4)
     ad4:	00 b9 02 e1 00 00    	add    %bh,0xe102(%rcx)
     ada:	00 1c a2             	add    %bl,(%rdx,%riz,4)
     add:	00 35 03 a2 00 00    	add    %dh,0xa203(%rip)        # ace6 <bpf_xdp_adjust_head+0x2d46>
  iph->check = 0;
     ae3:	00 1c a3             	add    %bl,(%rbx,%riz,4)
     ae6:	00 45 03             	add    %al,0x3(%rbp)
     ae9:	a2 00 00 00 1c a4 00 	movabs %al,0x34600a41c000000
     af0:	46 03 
  ipv4_csum_inline(iph, &csum);
     af2:	de 08                	fimuls (%rax)
     af4:	00 00                	add    %al,(%rax)
     af6:	1d 1c a5 00 12       	sbb    $0x1200a51c,%eax
     afb:	03 de                	add    %esi,%ebx
     afd:	08 00                	or     %al,(%rax)
     aff:	00 1d 1c 07 00 12    	add    %bl,0x1200071c(%rip)        # 12001221 <bpf_xdp_adjust_head+0x11ff9281>
     b05:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
  __u16* next_iph_u16 = (__u16*)iph;
     b0b:	1c a6                	sbb    $0xa6,%al
     b0d:	00 12                	add    %dl,(%rdx)
     b0f:	03 a2 00 00 00 1c    	add    0x1c000000(%rdx),%esp
     b15:	14 00                	adc    $0x0,%al
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
     b17:	12 03                	adc    (%rbx),%al
     b19:	ae                   	scas   %es:(%rdi),%al
     b1a:	0e                   	(bad)
     b1b:	00 00                	add    %al,(%rax)
     b1d:	1c a7                	sbb    $0xa7,%al
     b1f:	00 12                	add    %dl,(%rdx)
     b21:	03 ae 0e 00 00 00    	add    0xe(%rsi),%ebp
     b27:	00 00                	add    %al,(%rax)
     b29:	1d 1c a5 00 15       	sbb    $0x1500a51c,%eax
    *csum += *next_iph_u16++;
     b2e:	03 de                	add    %esi,%ebx
     b30:	08 00                	or     %al,(%rax)
     b32:	00 1d 1c 07 00 15    	add    %bl,0x1500071c(%rip)        # 15001254 <bpf_xdp_adjust_head+0x14ff92b4>
     b38:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
     b3e:	1c a6                	sbb    $0xa6,%al
     b40:	00 15 03 a2 00 00    	add    %dl,0xa203(%rip)        # ad49 <bpf_xdp_adjust_head+0x2da9>
     b46:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
     b49:	00 15 03 ae 0e 00    	add    %dl,0xeae03(%rip)        # eb952 <bpf_xdp_adjust_head+0xe39b2>
     b4f:	00 1c a7             	add    %bl,(%rdi,%riz,4)
     b52:	00 15 03 ae 0e 00    	add    %dl,0xeae03(%rip)        # eb95b <bpf_xdp_adjust_head+0xe39bb>
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
     b58:	00 00                	add    %al,(%rax)
     b5a:	00 00                	add    %al,(%rax)
     b5c:	1d 1c a5 00 36       	sbb    $0x3600a51c,%eax
     b61:	03 de                	add    %esi,%ebx
     b63:	08 00                	or     %al,(%rax)
     b65:	00 1d 1c 07 00 36    	add    %bl,0x3600071c(%rip)        # 36001287 <bpf_xdp_adjust_head+0x35ff92e7>
  *csum = csum_fold_helper(*csum);
     b6b:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
     b71:	1c a6                	sbb    $0xa6,%al
     b73:	00 36                	add    %dh,(%rsi)
     b75:	03 a2 00 00 00 1c    	add    0x1c000000(%rdx),%esp
  for (i = 0; i < 4; i++) {
     b7b:	14 00                	adc    $0x0,%al
     b7d:	36 03 ae 0e 00 00 1c 	ss add 0x1c00000e(%rsi),%ebp
     b84:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     b85:	00 36                	add    %dh,(%rsi)
     b87:	03 ae 0e 00 00 00    	add    0xe(%rsi),%ebp
    if (csum >> 16)
     b8d:	00 00                	add    %al,(%rax)
     b8f:	1d 1c a5 00 46       	sbb    $0x4600a51c,%eax
     b94:	03 de                	add    %esi,%ebx
     b96:	08 00                	or     %al,(%rax)
     b98:	00 1d 1c 07 00 46    	add    %bl,0x4600071c(%rip)        # 460012ba <bpf_xdp_adjust_head+0x45ff931a>
      csum = (csum & 0xffff) + (csum >> 16);
     b9e:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
     ba4:	1c a6                	sbb    $0xa6,%al
     ba6:	00 46 03             	add    %al,0x3(%rsi)
     ba9:	a2 00 00 00 1c 14 00 	movabs %al,0x34600141c000000
     bb0:	46 03 
     bb2:	ae                   	scas   %es:(%rdi),%al
     bb3:	0e                   	(bad)
     bb4:	00 00                	add    %al,(%rax)
     bb6:	1c a7                	sbb    $0xa7,%al
     bb8:	00 46 03             	add    %al,0x3(%rsi)
     bbb:	ae                   	scas   %es:(%rdi),%al
     bbc:	0e                   	(bad)
  for (i = 0; i < 4; i++) {
     bbd:	00 00                	add    %al,(%rax)
     bbf:	00 00                	add    %al,(%rax)
     bc1:	00 1d 1c a8 00 49    	add    %bl,0x4900a81c(%rip)        # 4900b3e3 <bpf_xdp_adjust_head+0x49003443>
     bc7:	03 a2 00 00 00 1c    	add    0x1c000000(%rdx),%esp
     bcd:	a9 00 4a 03 bc       	test   $0xbc034a00,%eax
  return ~csum;
     bd2:	04 00                	add    $0x0,%al
     bd4:	00 1d 1c a5 00 4a    	add    %bl,0x4a00a51c(%rip)        # 4a00b0f6 <bpf_xdp_adjust_head+0x4a003156>
  *csum = csum_fold_helper(*csum);
     bda:	03 de                	add    %esi,%ebx
     bdc:	08 00                	or     %al,(%rax)
     bde:	00 1d 1c 07 00 4a    	add    %bl,0x4a00071c(%rip)        # 4a001300 <bpf_xdp_adjust_head+0x49ff9360>
     be4:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
  iph->check = csum;
     bea:	1c a6                	sbb    $0xa6,%al
     bec:	00 4a 03             	add    %cl,0x3(%rdx)
     bef:	a2 00 00 00 1c 14 00 	movabs %al,0x34a00141c000000
     bf6:	4a 03 
     bf8:	ae                   	scas   %es:(%rdi),%al
     bf9:	0e                   	(bad)
     bfa:	00 00                	add    %al,(%rax)
     bfc:	1c a7                	sbb    $0xa7,%al
  return swap_mac_and_send(data, data_end);
     bfe:	00 4a 03             	add    %cl,0x3(%rdx)
     c01:	ae                   	scas   %es:(%rdi),%al
     c02:	0e                   	(bad)
     c03:	00 00                	add    %al,(%rax)
     c05:	00 00                	add    %al,(%rax)
     c07:	00 00                	add    %al,(%rax)
     c09:	1d 1c aa 00 56       	sbb    $0x5600aa1c,%eax
     c0e:	03 7b 0e             	add    0xe(%rbx),%edi
     c11:	00 00                	add    %al,(%rax)
     c13:	1d 1c a2 00 5e       	sbb    $0x5e00a21c,%eax
     c18:	03 a2 00 00 00 1c    	add    0x1c000000(%rdx),%esp
  eth = data;
     c1e:	9b                   	fwait
     c1f:	00 5f 03             	add    %bl,0x3(%rdi)
     c22:	bc 04 00 00 1d       	mov    $0x1d000004,%esp
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     c27:	1c a5                	sbb    $0xa5,%al
     c29:	00 5f 03             	add    %bl,0x3(%rdi)
     c2c:	de 08                	fimuls (%rax)
     c2e:	00 00                	add    %al,(%rax)
     c30:	1d 1c 07 00 5f       	sbb    $0x5f00071c,%eax
     c35:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
     c3b:	1c a6                	sbb    $0xa6,%al
     c3d:	00 5f 03             	add    %bl,0x3(%rdi)
     c40:	a2 00 00 00 1c 14 00 	movabs %al,0x35f00141c000000
     c47:	5f 03 
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     c49:	ae                   	scas   %es:(%rdi),%al
     c4a:	0e                   	(bad)
     c4b:	00 00                	add    %al,(%rax)
     c4d:	1c a7                	sbb    $0xa7,%al
     c4f:	00 5f 03             	add    %bl,0x3(%rdi)
     c52:	ae                   	scas   %es:(%rdi),%al
     c53:	0e                   	(bad)
     c54:	00 00                	add    %al,(%rax)
     c56:	00 00                	add    %al,(%rax)
     c58:	00 00                	add    %al,(%rax)
     c5a:	1d 1c ab 00 69       	sbb    $0x6900ab1c,%eax
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     c5f:	03 a2 00 00 00 1c    	add    0x1c000000(%rdx),%esp
     c65:	ac                   	lods   %ds:(%rsi),%al
     c66:	00 6a 03             	add    %ch,0x3(%rdx)
     c69:	df 05 00 00 1c ad    	filds  -0x52e40000(%rip)        # ffffffffad1c0c6f <server_id_map+0x36feb8f44c6f>
     c6f:	00 6f 03             	add    %ch,0x3(%rdi)
     c72:	b3 0e                	mov    $0xe,%bl
     c74:	00 00                	add    %al,(%rax)
     c76:	1d 1c a5 00 6b       	sbb    $0x6b00a51c,%eax
  return swap_mac_and_send(data, data_end);
     c7b:	03 de                	add    %esi,%ebx
     c7d:	08 00                	or     %al,(%rax)
     c7f:	00 1d 1c 07 00 6b    	add    %bl,0x6b00071c(%rip)        # 6b0013a1 <bpf_xdp_adjust_head+0x6aff9401>
}
     c85:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
    return send_icmp_reply(data, data_end);
     c8b:	1c a6                	sbb    $0xa6,%al
     c8d:	00 6b 03             	add    %ch,0x3(%rbx)
     c90:	a2 00 00 00 1c 14 00 	movabs %al,0x36b00141c000000
     c97:	6b 03 
  if (icmp_hdr->type != ICMP_DEST_UNREACH) {
     c99:	ae                   	scas   %es:(%rdi),%al
     c9a:	0e                   	(bad)
     c9b:	00 00                	add    %al,(%rax)
     c9d:	1c a7                	sbb    $0xa7,%al
     c9f:	00 6b 03             	add    %ch,0x3(%rbx)
    return XDP_PASS;
     ca2:	ae                   	scas   %es:(%rdi),%al
     ca3:	0e                   	(bad)
     ca4:	00 00                	add    %al,(%rax)
     ca6:	00 00                	add    %al,(%rax)
     ca8:	00 1d 1c 09 00 74    	add    %bl,0x7400091c(%rip)        # 740015ca <bpf_xdp_adjust_head+0x73ff962a>
     cae:	03 a2 00 00 00 1c    	add    0x1c000000(%rdx),%esp
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     cb4:	b2 00                	mov    $0x0,%dl
     cb6:	75 03                	jne    cbb <balancer_ingress+0xcbb>
     cb8:	9d                   	popf
     cb9:	00 00                	add    %al,(%rax)
     cbb:	00 1d 1c a5 00 75    	add    %bl,0x7500a51c(%rip)        # 7500b1dd <bpf_xdp_adjust_head+0x7500323d>
     cc1:	03 de                	add    %esi,%ebx
     cc3:	08 00                	or     %al,(%rax)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     cc5:	00 1d 1c 07 00 75    	add    %bl,0x7500071c(%rip)        # 750013e7 <bpf_xdp_adjust_head+0x74ff9447>
     ccb:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
        bpf_map_lookup_elem(&stats, &stats_key);
     cd1:	1c a6                	sbb    $0xa6,%al
     cd3:	00 75 03             	add    %dh,0x3(%rbp)
     cd6:	a2 00 00 00 1c 14 00 	movabs %al,0x37500141c000000
     cdd:	75 03 
     cdf:	ae                   	scas   %es:(%rdi),%al
     ce0:	0e                   	(bad)
     ce1:	00 00                	add    %al,(%rax)
     ce3:	1c a7                	sbb    $0xa7,%al
     ce5:	00 75 03             	add    %dh,0x3(%rbp)
     ce8:	ae                   	scas   %es:(%rdi),%al
     ce9:	0e                   	(bad)
     cea:	00 00                	add    %al,(%rax)
     cec:	00 00                	add    %al,(%rax)
     cee:	00 1d 1c b3 00 89    	add    %bl,-0x76ff4ce4(%rip)        # ffffffff8900c010 <server_id_map+0x36fe94d90010>
     cf4:	03 99 00 00 00 1d    	add    0x1d000000(%rcx),%ebx
     cfa:	1c a5                	sbb    $0xa5,%al
     cfc:	00 81 03 de 08 00    	add    %al,0x8de03(%rcx)
     d02:	00 1d 1c 07 00 81    	add    %bl,-0x7efff8e4(%rip)        # ffffffff81001424 <server_id_map+0x36fe8cd85424>
     d08:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
     d0e:	1c a6                	sbb    $0xa6,%al
     d10:	00 81 03 a2 00 00    	add    %al,0xa203(%rcx)
     d16:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
     d19:	00 81 03 ae 0e 00    	add    %al,0xeae03(%rcx)
     d1f:	00 1c a7             	add    %bl,(%rdi,%riz,4)
     d22:	00 81 03 ae 0e 00    	add    %al,0xeae03(%rcx)
	...
     d30:	1d 1c a8 00 e9       	sbb    $0xe900a81c,%eax
     d35:	03 a2 00 00 00 1c    	add    0x1c000000(%rdx),%esp
     d3b:	a9 00 ea 03 bc       	test   $0xbc03ea00,%eax
     d40:	04 00                	add    $0x0,%al
    struct lb_stats* icmp_ptb_v4_stats =
     d42:	00 1d 1c a5 00 eb    	add    %bl,-0x14ff5ae4(%rip)        # ffffffffeb00b264 <server_id_map+0x36fef6d8f264>
     d48:	03 de                	add    %esi,%ebx
    if (!icmp_ptb_v4_stats) {
     d4a:	08 00                	or     %al,(%rax)
     d4c:	00 1d 1c 07 00 eb    	add    %bl,-0x14fff8e4(%rip)        # ffffffffeb00146e <server_id_map+0x36fef6d8546e>
     d52:	03 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ebp
      return XDP_DROP;
     d58:	1c a6                	sbb    $0xa6,%al
     d5a:	00 eb                	add    %ch,%bl
     d5c:	03 a2 00 00 00 1c    	add    0x1c000000(%rdx),%esp
    icmp_ptb_v4_stats->v1 += 1;
     d62:	14 00                	adc    $0x0,%al
     d64:	eb 03                	jmp    d69 <balancer_ingress+0xd69>
     d66:	ae                   	scas   %es:(%rdi),%al
     d67:	0e                   	(bad)
     d68:	00 00                	add    %al,(%rax)
     d6a:	1c a7                	sbb    $0xa7,%al
     d6c:	00 eb                	add    %ch,%bl
     d6e:	03 ae 0e 00 00 00    	add    0xe(%rsi),%ebp
    __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);
     d74:	00 00                	add    %al,(%rax)
     d76:	00 1d 1c a5 00 08    	add    %bl,0x800a51c(%rip)        # 800b298 <bpf_xdp_adjust_head+0x80032f8>
     d7c:	04 de                	add    $0xde,%al
     d7e:	08 00                	or     %al,(%rax)
     d80:	00 1d 1c 07 00 08    	add    %bl,0x800071c(%rip)        # 80014a2 <bpf_xdp_adjust_head+0x7ff9502>
     d86:	04 a9                	add    $0xa9,%al
     d88:	0e                   	(bad)
     d89:	00 00                	add    %al,(%rax)
     d8b:	1d 1c a6 00 08       	sbb    $0x800a61c,%eax
     d90:	04 a2                	add    $0xa2,%al
     d92:	00 00                	add    %al,(%rax)
     d94:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
     d97:	00 08                	add    %cl,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     d99:	04 ae                	add    $0xae,%al
     d9b:	0e                   	(bad)
     d9c:	00 00                	add    %al,(%rax)
     d9e:	1c a7                	sbb    $0xa7,%al
     da0:	00 08                	add    %cl,(%rax)
     da2:	04 ae                	add    $0xae,%al
     da4:	0e                   	(bad)
     da5:	00 00                	add    %al,(%rax)
      icmp_ptb_v4_stats->v2 += 1;
     da7:	00 00                	add    %al,(%rax)
     da9:	00 1d 1c a5 00 0e    	add    %bl,0xe00a51c(%rip)        # e00b2cb <bpf_xdp_adjust_head+0xe00332b>
     daf:	04 de                	add    $0xde,%al
     db1:	08 00                	or     %al,(%rax)
     db3:	00 1d 1c 07 00 0e    	add    %bl,0xe00071c(%rip)        # e0014d5 <bpf_xdp_adjust_head+0xdff9535>
  }
     db9:	04 a9                	add    $0xa9,%al
  off += sizeof(struct icmphdr);
     dbb:	0e                   	(bad)
     dbc:	00 00                	add    %al,(%rax)
     dbe:	1d 1c a6 00 0e       	sbb    $0xe00a61c,%eax
     dc3:	04 a2                	add    $0xa2,%al
     dc5:	00 00                	add    %al,(%rax)
     dc7:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
     dca:	00 0e                	add    %cl,(%rsi)
     dcc:	04 ae                	add    $0xae,%al
  iph = data + off;
     dce:	0e                   	(bad)
     dcf:	00 00                	add    %al,(%rax)
     dd1:	1c a7                	sbb    $0xa7,%al
     dd3:	00 0e                	add    %cl,(%rsi)
     dd5:	04 ae                	add    $0xae,%al
     dd7:	0e                   	(bad)
     dd8:	00 00                	add    %al,(%rax)
     dda:	00 00                	add    %al,(%rax)
     ddc:	00 1d 1c a5 00 16    	add    %bl,0x1600a51c(%rip)        # 1600b2fe <bpf_xdp_adjust_head+0x1600335e>
  if (iph + 1 > data_end) {
     de2:	04 de                	add    $0xde,%al
     de4:	08 00                	or     %al,(%rax)
     de6:	00 1d 1c 07 00 16    	add    %bl,0x1600071c(%rip)        # 16001508 <bpf_xdp_adjust_head+0x15ff9568>
     dec:	04 a9                	add    $0xa9,%al
     dee:	0e                   	(bad)
     def:	00 00                	add    %al,(%rax)
     df1:	1d 1c a6 00 16       	sbb    $0x1600a61c,%eax
     df6:	04 a2                	add    $0xa2,%al
     df8:	00 00                	add    %al,(%rax)
    return XDP_DROP;
     dfa:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
     dfd:	00 16                	add    %dl,(%rsi)
     dff:	04 ae                	add    $0xae,%al
     e01:	0e                   	(bad)
     e02:	00 00                	add    %al,(%rax)
     e04:	1c a7                	sbb    $0xa7,%al
  if (iph->ihl != 5) {
     e06:	00 16                	add    %dl,(%rsi)
     e08:	04 ae                	add    $0xae,%al
     e0a:	0e                   	(bad)
     e0b:	00 00                	add    %al,(%rax)
     e0d:	00 00                	add    %al,(%rax)
     e0f:	00 00                	add    %al,(%rax)
     e11:	0a 16                	or     (%rsi),%dl
     e13:	0e                   	(bad)
     e14:	00 00                	add    %al,(%rax)
     e16:	1e                   	(bad)
     e17:	90                   	nop
    return XDP_DROP;
     e18:	38 07                	cmp    %al,(%rdi)
     e1a:	3f                   	(bad)
     e1b:	0c 1f                	or     $0x1f,%al
     e1d:	87 de                	xchg   %ebx,%esi
     e1f:	08 00                	or     %al,(%rax)
     e21:	00 07                	add    %al,(%rdi)
     e23:	40 0c 00             	rex or $0x0,%al
  pckt->flow.proto = iph->protocol;
     e26:	1f                   	(bad)
     e27:	88 de                	mov    %bl,%dh
     e29:	08 00                	or     %al,(%rax)
     e2b:	00 07                	add    %al,(%rdi)
     e2d:	41 0c 08             	rex.B or $0x8,%al
     e30:	1f                   	(bad)
     e31:	89 de                	mov    %ebx,%esi
     e33:	08 00                	or     %al,(%rax)
     e35:	00 07                	add    %al,(%rdi)
     e37:	42 0c 10             	rex.X or $0x10,%al
  pckt->flags |= F_ICMP;
     e3a:	1f                   	(bad)
     e3b:	8a de                	mov    %dh,%bl
     e3d:	08 00                	or     %al,(%rax)
     e3f:	00 07                	add    %al,(%rdi)
     e41:	43 0c 18             	rex.XB or $0x18,%al
     e44:	1f                   	(bad)
     e45:	8b 6d 0e             	mov    0xe(%rbp),%ebp
     e48:	00 00                	add    %al,(%rax)
  pckt->flow.src = iph->daddr;
     e4a:	07                   	(bad)
     e4b:	44 0c 20             	rex.R or $0x20,%al
     e4e:	1f                   	(bad)
     e4f:	8d 74 0e 00          	lea    0x0(%rsi,%rcx,1),%esi
     e53:	00 07                	add    %al,(%rdi)
     e55:	45 0c 28             	rex.RB or $0x28,%al
     e58:	1f                   	(bad)
     e59:	8f                   	(bad)
     e5a:	a2 00 00 00 07 46 0c 	movabs %al,0x1f300c4607000000
     e61:	30 1f 
  pckt->flow.dst = iph->saddr;
     e63:	1f                   	(bad)
     e64:	a2 00 00 00 07 47 0c 	movabs %al,0x340c4707000000
     e6b:	34 00 
     e6d:	0a 72 0e             	or     0xe(%rdx),%dh
  return FURTHER_PROCESSING;
     e70:	00 00                	add    %al,(%rax)
     e72:	20 8c 0a 79 0e 00 00 	and    %cl,0xe79(%rdx,%rcx,1)
     e79:	20 8e 05 93 02 01    	and    %cl,0x1029305(%rsi)
}
     e7f:	0c 99                	or     $0x99,%al
    return parse_icmp(data, data_end, off, pckt);
     e81:	30 03                	xor    %al,(%rbx)
     e83:	2b 09                	sub    (%rcx),%ecx
     e85:	96                   	xchg   %eax,%esi
     e86:	53                   	push   %rbx
     e87:	02 00                	add    (%rax),%al
    return FURTHER_PROCESSING;
     e89:	00 03                	add    %al,(%rbx)
     e8b:	2c 00                	sub    $0x0,%al
     e8d:	09 97 a2 00 00 00    	or     %edx,0xa2(%rdi)
}
     e93:	03 2d 28 09 1f f9    	add    -0x6e0f6d8(%rip),%ebp        # fffffffff91f17c1 <server_id_map+0x36ff04f757c1>
     e99:	00 00                	add    %al,(%rax)
     e9b:	00 03                	add    %al,(%rbx)
     e9d:	2e 2c 09             	cs sub $0x9,%al
  if (action >= 0) {
     ea0:	98                   	cwtl
     ea1:	f9                   	stc
     ea2:	00 00                	add    %al,(%rax)
     ea4:	00 03                	add    %al,(%rbx)
     ea6:	30 2d 00 21 99 00    	xor    %ch,0x992100(%rip)        # 992fac <bpf_xdp_adjust_head+0x98b00c>
    return action;
     eac:	00 00                	add    %al,(%rax)
     eae:	21 a2 00 00 00 0c    	and    %esp,0xc000000(%rdx)
     eb4:	b1 08                	mov    $0x8,%cl
     eb6:	09 3a                	or     %edi,(%rdx)
  protocol = pckt.flow.proto;
     eb8:	09 ae 99 00 00 00    	or     %ebp,0x99(%rsi)
     ebe:	09 3b                	or     %edi,(%rbx)
     ec0:	00 09                	add    %cl,(%rcx)
     ec2:	af                   	scas   %es:(%rdi),%eax
     ec3:	f9                   	stc
  if (protocol == IPPROTO_TCP) {
     ec4:	00 00                	add    %al,(%rax)
     ec6:	00 09                	add    %cl,(%rcx)
     ec8:	3c 04                	cmp    $0x4,%al
     eca:	09 b0 7b 0e 00 00    	or     %esi,0xe7b(%rax)
     ed0:	09 3d 05 00 1a b4    	or     %edi,-0x4be5fffb(%rip)        # ffffffffb41a0edb <server_id_map+0x36febff24edb>
    if (!parse_tcp(data, data_end, is_ipv6, &pckt)) {
     ed6:	09 c3                	or     %eax,%ebx
     ed8:	01 99 00 00 00 1b    	add    %ebx,0x1b000000(%rcx)
     ede:	95                   	xchg   %eax,%ebp
     edf:	09 c4                	or     %eax,%esp
     ee1:	01 41 0f             	add    %eax,0xf(%rcx)
     ee4:	00 00                	add    %al,(%rax)
     ee6:	1b 9c 09 c5 01 a4 08 	sbb    0x8a401c5(%rcx,%rcx,1),%ebx
     eed:	00 00                	add    %al,(%rax)
     eef:	1b 91 09 c6 01 e1    	sbb    -0x1efe39f7(%rcx),%edx
     ef5:	00 00                	add    %al,(%rax)
     ef7:	00 1b                	add    %bl,(%rbx)
     ef9:	a1 09 c7 01 46 0f 00 	movabs 0x1b00000f4601c709,%eax
     f00:	00 1b 
     f02:	a0 09 c8 01 c6 09 00 	movabs 0x1b000009c601c809,%al
     f09:	00 1b 
     f0b:	87 09                	xchg   %ecx,(%rcx)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     f0d:	c9                   	leave
     f0e:	01 de                	add    %ebx,%esi
     f10:	08 00                	or     %al,(%rax)
     f12:	00 1b                	add    %bl,(%rbx)
     f14:	88 09                	mov    %cl,(%rcx)
     f16:	ca 01 de             	lret   $0xde01
     f19:	08 00                	or     %al,(%rax)
     f1b:	00 1b                	add    %bl,(%rbx)
     f1d:	92                   	xchg   %eax,%edx
     f1e:	09 cb                	or     %ecx,%ebx
     f20:	01 7b 0e             	add    %edi,0xe(%rbx)
     f23:	00 00                	add    %al,(%rax)
     f25:	1c b5                	sbb    $0xb5,%al
     f27:	09 cc                	or     %ecx,%esp
     f29:	01 e1                	add    %esp,%ecx
  __u64 off = calc_offset(is_ipv6, is_icmp);
     f2b:	00 00                	add    %al,(%rax)
     f2d:	00 1c b6             	add    %bl,(%rsi,%rsi,4)
     f30:	09 cd                	or     %ecx,%ebp
     f32:	01 4b 0f             	add    %ecx,0xf(%rbx)
     f35:	00 00                	add    %al,(%rax)
     f37:	1c c3                	sbb    $0xc3,%al
     f39:	09 ce                	or     %ecx,%esi
     f3b:	01 09                	add    %ecx,(%rcx)
     f3d:	10 00                	adc    %al,(%rax)
     f3f:	00 00                	add    %al,(%rax)
     f41:	0a 7f 0e             	or     0xe(%rdi),%bh
     f44:	00 00                	add    %al,(%rax)
     f46:	0a e1                	or     %cl,%ah
  __u64 off = sizeof(struct ethhdr);
     f48:	00 00                	add    %al,(%rax)
     f4a:	00 0a                	add    %cl,(%rdx)
     f4c:	50                   	push   %rax
     f4d:	0f 00 00             	sldt   (%rax)
     f50:	0c c2                	or     $0xc2,%al
  if (is_ipv6) {
     f52:	14 0f                	adc    $0xf,%al
     f54:	57                   	push   %rdi
     f55:	22 b7 f9 00 00 00    	and    0xf9(%rdi),%dh
    off += sizeof(struct ipv6hdr);
     f5b:	0f 59 01             	mulps  (%rcx),%xmm0
     f5e:	04 04                	add    $0x4,%al
     f60:	00 22                	add    %ah,(%rdx)
     f62:	7e f9                	jle    f5d <balancer_ingress+0xf5d>
     f64:	00 00                	add    %al,(%rax)
     f66:	00 0f                	add    %cl,(%rdi)
     f68:	5a                   	pop    %rdx
     f69:	01 04 00             	add    %eax,(%rax,%rax,1)
     f6c:	00 09                	add    %cl,(%rcx)
    if (is_icmp) {
     f6e:	98                   	cwtl
     f6f:	f9                   	stc
     f70:	00 00                	add    %al,(%rax)
     f72:	00 0f                	add    %cl,(%rdi)
     f74:	61                   	(bad)
     f75:	01 09                	add    %ecx,(%rcx)
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
     f77:	b8 f9 0f 00 00       	mov    $0xff9,%eax
     f7c:	0f 62 02             	punpckldq (%rdx),%mm0
     f7f:	09 ba f9 0f 00 00    	or     %edi,0xff9(%rdx)
     f85:	0f 63 04 09          	packsswb (%rcx,%rcx,1),%mm0
  } else {
     f89:	bb f9 0f 00 00       	mov    $0xff9,%ebx
    off += sizeof(struct iphdr);
     f8e:	0f 64 06             	pcmpgtb (%rsi),%mm0
     f91:	09 bc f9 00 00 00 0f 	or     %edi,0xf000000(%rcx,%rdi,8)
     f98:	65 08 09             	or     %cl,%gs:(%rcx)
     f9b:	9c                   	pushf
    if (is_icmp) {
     f9c:	f9                   	stc
     f9d:	00 00                	add    %al,(%rax)
     f9f:	00 0f                	add    %cl,(%rdi)
     fa1:	66 09 09             	or     %cx,(%rcx)
     fa4:	bd 01 10 00 00       	mov    $0x1001,%ebp
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
     fa9:	0f 67 0a             	packuswb (%rdx),%mm1
     fac:	0d b4 0f 00 00       	or     $0xfb4,%eax
     fb1:	0f 68 0c 0e          	punpckhbw (%rsi,%rcx,1),%mm1
     fb5:	08 0f                	or     %cl,(%rdi)
     fb7:	68 0d c0 0f 00       	push   $0xfc00d
  return off;
     fbc:	00 0f                	add    %cl,(%rdi)
     fbe:	68 00 08 08 0f       	push   $0xf080800
  __u64 off = calc_offset(is_ipv6, is_icmp);
     fc3:	68 09 bf b1 01       	push   $0x1b1bf09
  tcp = data + off;
     fc8:	00 00                	add    %al,(%rax)
     fca:	0f 68 00             	punpckhbw (%rax),%mm0
     fcd:	09 c0                	or     %eax,%eax
     fcf:	b1 01                	mov    $0x1,%cl
     fd1:	00 00                	add    %al,(%rax)
     fd3:	0f 68 04 00          	punpckhbw (%rax,%rax,1),%mm0
     fd7:	09 c1                	or     %eax,%ecx
     fd9:	e0 0f                	loopne fea <balancer_ingress+0xfea>
     fdb:	00 00                	add    %al,(%rax)
  if (tcp + 1 > data_end) {
     fdd:	0f 68 00             	punpckhbw (%rax),%mm0
     fe0:	08 08                	or     %cl,(%rax)
     fe2:	0f 68 09             	punpckhbw (%rcx),%mm1
     fe5:	bf b1 01 00 00       	mov    $0x1b1,%edi
     fea:	0f 68 00             	punpckhbw (%rax),%mm0
     fed:	09 c0                	or     %eax,%eax
     fef:	b1 01                	mov    $0x1,%cl
     ff1:	00 00                	add    %al,(%rax)
    return false;
     ff3:	0f 68 04 00          	punpckhbw (%rax,%rax,1),%mm0
     ff7:	00 00                	add    %al,(%rax)
     ff9:	0b c5                	or     %ebp,%eax
     ffb:	01 00                	add    %eax,(%rax)
     ffd:	00 b9 05 20 0b c5    	add    %bh,-0x3af4dffb(%rcx)
  if (tcp->syn) {
    1003:	01 00                	add    %eax,(%rax)
    1005:	00 be 05 26 0a 0e    	add    %bh,0xe0a2605(%rsi)
    100b:	10 00                	adc    %al,(%rax)
    100d:	00 0c ce             	add    %cl,(%rsi,%rcx,8)
    1010:	28 10                	sub    %dl,(%rax)
    1012:	76 22                	jbe    1036 <balancer_ingress+0x1036>
    1014:	c4                   	(bad)
    1015:	f9                   	stc
    1016:	00 00                	add    %al,(%rax)
    pckt->flags |= F_SYN_SET;
    1018:	00 10                	add    %dl,(%rax)
    101a:	78 01                	js     101d <balancer_ingress+0x101d>
    101c:	04 04                	add    $0x4,%al
    101e:	00 22                	add    %ah,(%rdx)
    1020:	7e f9                	jle    101b <balancer_ingress+0x101b>
    1022:	00 00                	add    %al,(%rax)
    1024:	00 10                	add    %dl,(%rax)
    1026:	79 01                	jns    1029 <balancer_ingress+0x1029>
    1028:	04 00                	add    $0x0,%al
  if (!is_icmp) {
    102a:	00 09                	add    %cl,(%rcx)
    102c:	c5 9c 10             	(bad)
    102f:	00 00                	add    %al,(%rax)
    1031:	10 80 01 09 c6 f9    	adc    %al,-0x639f6ff(%rax)
    pckt->flow.port16[0] = tcp->source;
    1037:	0f 00 00             	sldt   (%rax)
    103a:	10 82 04 09 c7 f9    	adc    %al,-0x638f6fc(%rdx)
    1040:	00 00                	add    %al,(%rax)
    1042:	00 10                	add    %dl,(%rax)
    1044:	83 06 09             	addl   $0x9,(%rsi)
    pckt->flow.port16[1] = tcp->dest;
    1047:	c8 f9 00 00          	enter  $0xf9,$0x0
    104b:	00 10                	add    %dl,(%rax)
    104d:	84 07                	test   %al,(%rdi)
    104f:	0d 57 10 00 00       	or     $0x1057,%eax
    1054:	10 86 08 0e 20 10    	adc    %al,0x10200e08(%rsi)
    105a:	86 0d 63 10 00 00    	xchg   %cl,0x1063(%rip)        # 20c3 <balancer_ingress+0x20c3>
    pckt->flow.port16[0] = tcp->dest;
    1060:	10 86 00 08 20 10    	adc    %al,0x10200800(%rsi)
    1066:	86 09                	xchg   %cl,(%rcx)
    1068:	bf a8 10 00 00       	mov    $0x10a8,%edi
    106d:	10 86 00 09 c0 a8    	adc    %al,-0x573ff700(%rsi)
    1073:	10 00                	adc    %al,(%rax)
    pckt->flow.port16[1] = tcp->source;
    1075:	00 10                	add    %dl,(%rax)
    1077:	86 10                	xchg   %dl,(%rax)
    1079:	00 09                	add    %cl,(%rcx)
    107b:	c1 83 10 00 00 10 86 	roll   $0x86,0x10000010(%rbx)
    1082:	00 08                	add    %cl,(%rax)
    1084:	20 10                	and    %dl,(%rax)
    1086:	86 09                	xchg   %cl,(%rcx)
    1088:	bf a8 10 00 00       	mov    $0x10a8,%edi
  return true;
    108d:	10 86 00 09 c0 a8    	adc    %al,-0x573ff700(%rsi)
    1093:	10 00                	adc    %al,(%rax)
    1095:	00 10                	add    %dl,(%rax)
    1097:	86 10                	xchg   %dl,(%rax)
    1099:	00 00                	add    %al,(%rax)
      return XDP_DROP;
    109b:	00 03                	add    %al,(%rbx)
    109d:	f9                   	stc
    109e:	00 00                	add    %al,(%rax)
    10a0:	00 04 47             	add    %al,(%rdi,%rax,2)
    10a3:	00 00                	add    %al,(%rax)
    10a5:	00 03                	add    %al,(%rbx)
    10a7:	00 0c cd 10 11 21 09 	add    %cl,0x9211110(,%rcx,8)
  } else if (protocol == IPPROTO_UDP) {
    10ae:	c9                   	leave
    10af:	b6 10                	mov    $0x10,%dh
    10b1:	00 00                	add    %al,(%rax)
    10b3:	11 28                	adc    %ebp,(%rax)
    10b5:	00 0e                	add    %cl,(%rsi)
    10b7:	10 11                	adc    %dl,(%rcx)
    10b9:	22 09                	and    (%rcx),%cl
    10bb:	ca d7 10             	lret   $0x10d7
    if (!parse_udp(data, data_end, is_ipv6, &pckt)) {
    10be:	00 00                	add    %al,(%rax)
    10c0:	11 23                	adc    %esp,(%rbx)
    10c2:	00 09                	add    %cl,(%rcx)
    10c4:	cb                   	lret
    10c5:	e3 10                	jrcxz  10d7 <balancer_ingress+0x10d7>
    10c7:	00 00                	add    %al,(%rax)
    10c9:	11 25 00 09 cc b9    	adc    %esp,-0x4633f700(%rip)        # ffffffffb9cc19cf <server_id_map+0x36fec5a459cf>
    10cf:	01 00                	add    %eax,(%rax)
    10d1:	00 11                	add    %dl,(%rcx)
    10d3:	26 00 00             	es add %al,(%rax)
    10d6:	00 03                	add    %al,(%rbx)
    10d8:	f9                   	stc
    10d9:	00 00                	add    %al,(%rax)
    10db:	00 04 47             	add    %al,(%rdi,%rax,2)
    10de:	00 00                	add    %al,(%rax)
    10e0:	00 10                	add    %dl,(%rax)
    10e2:	00 03                	add    %al,(%rbx)
    10e4:	f9                   	stc
    10e5:	0f 00 00             	sldt   (%rax)
    10e8:	04 47                	add    $0x47,%al
    10ea:	00 00                	add    %al,(%rax)
    10ec:	00 08                	add    %cl,(%rax)
    10ee:	00 1a                	add    %bl,(%rdx)
    10f0:	cf                   	iret
    10f1:	0b 53 01             	or     0x1(%rbx),%edx
    10f4:	99                   	cltd
    10f5:	00 00                	add    %al,(%rax)
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
    10f7:	00 1b                	add    %bl,(%rbx)
    10f9:	87 0b                	xchg   %ecx,(%rbx)
    10fb:	54                   	push   %rsp
    10fc:	01 de                	add    %ebx,%esi
    10fe:	08 00                	or     %al,(%rax)
    1100:	00 1b                	add    %bl,(%rbx)
    1102:	88 0b                	mov    %cl,(%rbx)
    1104:	55                   	push   %rbp
    1105:	01 de                	add    %ebx,%esi
    1107:	08 00                	or     %al,(%rax)
    1109:	00 1b                	add    %bl,(%rbx)
    110b:	d0 0b                	rorb   (%rbx)
    110d:	56                   	push   %rsi
    110e:	01 e1                	add    %esp,%ecx
    1110:	00 00                	add    %al,(%rax)
    1112:	00 1b                	add    %bl,(%rbx)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    1114:	95                   	xchg   %eax,%ebp
    1115:	0b 57 01             	or     0x1(%rdi),%edx
    1118:	41 0f 00 00          	sldt   (%r8)
    111c:	1b 9c 0b 58 01 f9 00 	sbb    0xf90158(%rbx,%rcx,1),%ebx
    1123:	00 00                	add    %al,(%rax)
    1125:	00 23                	add    %ah,(%rbx)
    1127:	d1 0b                	rorl   (%rbx)
    1129:	e4 99                	in     $0x99,%al
    112b:	00 00                	add    %al,(%rax)
    112d:	00 24 87             	add    %ah,(%rdi,%rax,4)
    1130:	0b e5                	or     %ebp,%esp
  __u64 off = sizeof(struct ethhdr);
    1132:	de 08                	fimuls (%rax)
    1134:	00 00                	add    %al,(%rax)
    1136:	24 88                	and    $0x88,%al
    1138:	0b e6                	or     %esi,%esp
    113a:	de 08                	fimuls (%rax)
  if (is_ipv6) {
    113c:	00 00                	add    %al,(%rax)
    113e:	24 d0                	and    $0xd0,%al
    1140:	0b e7                	or     %edi,%esp
    1142:	e1 00                	loope  1144 <balancer_ingress+0x1144>
    1144:	00 00                	add    %al,(%rax)
    off += sizeof(struct ipv6hdr);
    1146:	24 95                	and    $0x95,%al
    1148:	0b e8                	or     %eax,%ebp
    114a:	41 0f 00 00          	sldt   (%r8)
    114e:	25 d2 0b e9 a7       	and    $0xa7e90bd2,%eax
    1153:	11 00                	adc    %eax,(%rax)
    1155:	00 25 c3 0b ea 09    	add    %ah,0x9ea0bc3(%rip)        # 9ea1d1e <bpf_xdp_adjust_head+0x9e99d7e>
    if (is_icmp) {
    115b:	10 00                	adc    %al,(%rax)
    115d:	00 1d 25 a2 0b f8    	add    %bl,-0x7f45ddb(%rip)        # fffffffff80bb388 <server_id_map+0x36ff03e3f388>
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
    1163:	a2 00 00 00 25 ed 0b 	movabs %al,0xbcf90bed25000000
    116a:	f9 bc 
    116c:	04 00                	add    $0x0,%al
    116e:	00 25 ee 0b ff a2    	add    %ah,-0x5d00f412(%rip)        # ffffffffa2ff1d62 <server_id_map+0x36feaed75d62>
    off += sizeof(struct iphdr);
    1174:	00 00                	add    %al,(%rax)
    1176:	00 1d 25 a5 0b fa    	add    %bl,-0x5f45adb(%rip)        # fffffffffa0bb6a1 <server_id_map+0x36ff05e3f6a1>
    117c:	de 08                	fimuls (%rax)
    117e:	00 00                	add    %al,(%rax)
    1180:	1d 25 07 0b fa       	sbb    $0xfa0b0725,%eax
    1185:	a9 0e 00 00 1d       	test   $0x1d00000e,%eax
    if (is_icmp) {
    118a:	25 a6 0b fa a2       	and    $0xa2fa0ba6,%eax
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
    118f:	00 00                	add    %al,(%rax)
    1191:	00 25 14 0b fa ae    	add    %ah,-0x5105f4ec(%rip)        # ffffffffaefa1cab <server_id_map+0x36febad25cab>
    1197:	0e                   	(bad)
    1198:	00 00                	add    %al,(%rax)
    119a:	25 a7 0b fa ae       	and    $0xaefa0ba7,%eax
    119f:	0e                   	(bad)
    11a0:	00 00                	add    %al,(%rax)
    11a2:	00 00                	add    %al,(%rax)
  return off;
    11a4:	00 00                	add    %al,(%rax)
    11a6:	00 0a                	add    %cl,(%rdx)
    11a8:	ac                   	lods   %ds:(%rsi),%al
    11a9:	11 00                	adc    %eax,(%rax)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    11ab:	00 0c ec             	add    %cl,(%rsp,%rbp,8)
    11ae:	08 12                	or     %dl,(%rdx)
    11b0:	08 09                	or     %cl,(%rcx)
  udp = data + off;
    11b2:	d3 f9                	sar    %cl,%ecx
    11b4:	00 00                	add    %al,(%rax)
    11b6:	00 12                	add    %dl,(%rdx)
    11b8:	0a 00                	or     (%rax),%al
    11ba:	09 d4                	or     %edx,%esp
    11bc:	f9                   	stc
    11bd:	00 00                	add    %al,(%rax)
    11bf:	00 12                	add    %dl,(%rdx)
    11c1:	0b 01                	or     (%rcx),%eax
    11c3:	09 d5                	or     %edx,%ebp
    11c5:	01 10                	add    %edx,(%rax)
  if (udp + 1 > data_end) {
    11c7:	00 00                	add    %al,(%rax)
    11c9:	12 0c 02             	adc    (%rdx,%rax,1),%cl
    11cc:	09 d6                	or     %edx,%esi
    11ce:	d5                   	(bad)
    11cf:	11 00                	adc    %eax,(%rax)
    11d1:	00 12                	add    %dl,(%rdx)
    11d3:	3f                   	(bad)
    11d4:	04 0e                	add    $0xe,%al
    11d6:	04 12                	add    $0x12,%al
    11d8:	0f 09                	wbinvd
    11da:	d7                   	xlat   %ds:(%rbx)
    11db:	11 12                	adc    %edx,(%rdx)
    return false;
    11dd:	00 00                	add    %al,(%rax)
    11df:	12 10                	adc    (%rax),%dl
    11e1:	00 09                	add    %cl,(%rcx)
    11e3:	d8 1d 12 00 00 12    	fcomps 0x12000012(%rip)        # 120011fb <bpf_xdp_adjust_head+0x11ff925b>
  if (!is_icmp) {
    11e9:	11 00                	adc    %eax,(%rax)
    11eb:	09 d9                	or     %ebx,%ecx
    11ed:	29 12                	sub    %edx,(%rdx)
    pckt->flow.port16[0] = udp->source;
    11ef:	00 00                	add    %al,(%rax)
    11f1:	12 12                	adc    (%rdx),%dl
    11f3:	00 09                	add    %cl,(%rcx)
    11f5:	da 35 12 00 00 12    	fidivl 0x12000012(%rip)        # 1200120d <bpf_xdp_adjust_head+0x11ff926d>
    11fb:	17                   	(bad)
    11fc:	00 09                	add    %cl,(%rcx)
    11fe:	de 4d 12             	fimuls 0x12(%rbp)
    1201:	00 00                	add    %al,(%rax)
    1203:	12 28                	adc    (%rax),%ch
    pckt->flow.port16[1] = udp->dest;
    1205:	00 09                	add    %cl,(%rcx)
    1207:	e5 8f                	in     $0x8f,%eax
    1209:	12 00                	adc    (%rax),%al
    120b:	00 12                	add    %dl,(%rdx)
    120d:	3d 00 00 00 03       	cmp    $0x3000000,%eax
    1212:	b1 01                	mov    $0x1,%cl
    1214:	00 00                	add    %al,(%rax)
    1216:	04 47                	add    $0x47,%al
    1218:	00 00                	add    %al,(%rax)
  } else {
    121a:	00 01                	add    %al,(%rcx)
    pckt->flow.port16[0] = udp->dest;
    121c:	00 03                	add    %al,(%rbx)
    121e:	f9                   	stc
    121f:	0f 00 00             	sldt   (%rax)
    1222:	04 47                	add    $0x47,%al
    1224:	00 00                	add    %al,(%rax)
    1226:	00 02                	add    %al,(%rdx)
    1228:	00 03                	add    %al,(%rbx)
    122a:	f9                   	stc
    122b:	00 00                	add    %al,(%rax)
    122d:	00 04 47             	add    %al,(%rdi,%rax,2)
    1230:	00 00                	add    %al,(%rax)
    pckt->flow.port16[1] = udp->source;
    1232:	00 04 00             	add    %al,(%rax,%rax,1)
    1235:	0c dd                	or     $0xdd,%al
    1237:	04 12                	add    $0x12,%al
    1239:	14 09                	adc    $0x9,%al
    123b:	db f9                	(bad)
    123d:	0f 00 00             	sldt   (%rax)
    1240:	12 15 00 09 dc f9    	adc    -0x623f700(%rip),%dl        # fffffffff9dc1b46 <server_id_map+0x36ff05b45b46>
    1246:	0f 00 00             	sldt   (%rax)
  return true;
    1249:	12 16                	adc    (%rsi),%dl
    124b:	02 00                	add    (%rax),%al
    124d:	0c e4                	or     $0xe4,%al
    124f:	04 12                	add    $0x12,%al
    1251:	19 22                	sbb    %esp,(%rdx)
    1253:	df a2 00 00 00 12    	fbld   0x12000000(%rdx)
      return XDP_DROP;
    1259:	1b 04 05 1b 00 22 e0 	sbb    -0x1fddffe5(,%rax,1),%eax
    1260:	a2 00 00 00 12 1c 04 	movabs %al,0x1a01041c12000000
    1267:	01 1a 
    return XDP_PASS;
    1269:	00 22                	add    %ah,(%rdx)
    126b:	e1 a2                	loope  120f <balancer_ingress+0x120f>
    126d:	00 00                	add    %al,(%rax)
    126f:	00 12                	add    %dl,(%rdx)
    1271:	1d 04 01 19 00       	sbb    $0x190104,%eax
    1276:	22 e2                	and    %dl,%ah
  if (is_ipv6) {
    1278:	a2 00 00 00 12 1e 04 	movabs %al,0x1801041e12000000
    127f:	01 18 
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
    1281:	00 22                	add    %ah,(%rdx)
    1283:	e3 a2                	jrcxz  1227 <balancer_ingress+0x1227>
    1285:	00 00                	add    %al,(%rax)
    1287:	00 12                	add    %dl,(%rdx)
    1289:	1f                   	(bad)
    128a:	04 18                	add    $0x18,%al
    128c:	00 00                	add    %al,(%rax)
    128e:	00 0c eb             	add    %cl,(%rbx,%rbp,8)
    1291:	04 12                	add    $0x12,%al
    1293:	2a 09                	sub    (%rcx),%cl
    1295:	c8 f9 00 00          	enter  $0xf9,$0x0
    1299:	00 12                	add    %dl,(%rdx)
    129b:	2b 00                	sub    (%rax),%eax
  } else {
    129d:	22 df                	and    %bh,%bl
    vip.vip = pckt.flow.dst;
    129f:	f9                   	stc
    12a0:	00 00                	add    %al,(%rax)
    12a2:	00 12                	add    %dl,(%rdx)
    12a4:	2d 01 03 05 01       	sub    $0x1050301,%eax
    12a9:	22 e6                	and    %dh,%ah
  vip.port = pckt.flow.port16[1];
    12ab:	f9                   	stc
    12ac:	00 00                	add    %al,(%rax)
    12ae:	00 12                	add    %dl,(%rdx)
    12b0:	2e 01 02             	cs add %eax,(%rdx)
    12b3:	03 01                	add    (%rcx),%eax
    12b5:	22 e7                	and    %bh,%ah
    12b7:	f9                   	stc
  vip.proto = pckt.flow.proto;
    12b8:	00 00                	add    %al,(%rax)
    12ba:	00 12                	add    %dl,(%rdx)
    12bc:	2f                   	(bad)
    12bd:	01 01                	add    %eax,(%rcx)
    12bf:	02 01                	add    (%rcx),%al
    12c1:	22 e8                	and    %al,%ch
    12c3:	f9                   	stc
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
    12c4:	00 00                	add    %al,(%rax)
    12c6:	00 12                	add    %dl,(%rdx)
    12c8:	30 01                	xor    %al,(%rcx)
    12ca:	01 01                	add    %eax,(%rcx)
    12cc:	01 22                	add    %esp,(%rdx)
    12ce:	e9 f9 00 00 00       	jmp    13cc <balancer_ingress+0x13cc>
    12d3:	12 31                	adc    (%rcx),%dh
    12d5:	01 01                	add    %eax,(%rcx)
    12d7:	00 01                	add    %al,(%rcx)
    12d9:	09 ea                	or     %ebp,%edx
    12db:	f9                   	stc
    12dc:	0f 00 00             	sldt   (%rax)
    12df:	12 3c 02             	adc    (%rdx,%rax,1),%bh
    12e2:	00 23                	add    %ah,(%rbx)
    12e4:	ef                   	out    %eax,(%dx)
    12e5:	0b 5e 99             	or     -0x67(%rsi),%ebx
    12e8:	00 00                	add    %al,(%rax)
    12ea:	00 24 87             	add    %ah,(%rdi,%rax,4)
    12ed:	0b 5f de             	or     -0x22(%rdi),%ebx
    12f0:	08 00                	or     %al,(%rax)
    12f2:	00 24 88             	add    %ah,(%rax,%rcx,4)
    12f5:	0b 60 de             	or     -0x22(%rax),%esp
    12f8:	08 00                	or     %al,(%rax)
    12fa:	00 25 c3 0b 61 09    	add    %ah,0x9610bc3(%rip)        # 9611ec3 <bpf_xdp_adjust_head+0x9609f23>
    1300:	10 00                	adc    %al,(%rax)
    1302:	00 25 d2 0b 62 a7    	add    %ah,-0x589df42e(%rip)        # ffffffffa7621eda <server_id_map+0x36feb33a5eda>
    1308:	11 00                	adc    %eax,(%rax)
    130a:	00 25 f0 0b 63 b9    	add    %ah,-0x469cf410(%rip)        # ffffffffb9631f00 <server_id_map+0x36fec53b5f00>
    1310:	01 00                	add    %eax,(%rax)
    1312:	00 25 d0 0b 64 e1    	add    %ah,-0x1e9bf430(%rip)        # ffffffffe1641ee8 <server_id_map+0x36feed3c5ee8>
    1318:	00 00                	add    %al,(%rax)
    131a:	00 00                	add    %al,(%rax)
    131c:	23 f1                	and    %ecx,%esi
    131e:	0b 28                	or     (%rax),%ebp
    1320:	99                   	cltd
    1321:	00 00                	add    %al,(%rax)
    1323:	00 24 87             	add    %ah,(%rdi,%rax,4)
    1326:	0b 29                	or     (%rcx),%ebp
    1328:	de 08                	fimuls (%rax)
    132a:	00 00                	add    %al,(%rax)
    132c:	24 88                	and    $0x88,%al
    132e:	0b 2a                	or     (%rdx),%ebp
    1330:	de 08                	fimuls (%rax)
    1332:	00 00                	add    %al,(%rax)
    1334:	25 f2 0b 2b 45       	and    $0x452b0bf2,%eax
    1339:	13 00                	adc    (%rax),%eax
    133b:	00 25 f7 0b 2c 6b    	add    %ah,0x6b2c0bf7(%rip)        # 6b2c1f38 <bpf_xdp_adjust_head+0x6b2b9f98>
  if (!vip_info) {
    1341:	13 00                	adc    (%rax),%eax
    1343:	00 00                	add    %al,(%rax)
    1345:	0a 4a 13             	or     0x13(%rdx),%cl
    1348:	00 00                	add    %al,(%rax)
    134a:	0c f6                	or     $0xf6,%al
    134c:	0e                   	(bad)
    vip.port = 0;
    134d:	13 ad 09 f3 6b 13    	adc    0x136bf309(%rbp),%ebp
    1353:	00 00                	add    %al,(%rax)
    1355:	13 ae 00 09 f4 6b    	adc    0x6bf40900(%rsi),%ebp
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
    135b:	13 00                	adc    (%rax),%eax
    135d:	00 13                	add    %dl,(%rbx)
    135f:	af                   	scas   %es:(%rdi),%eax
    1360:	06                   	(bad)
    1361:	09 f5                	or     %esi,%ebp
    1363:	f9                   	stc
    1364:	0f 00 00             	sldt   (%rax)
    1367:	13 b0 0c 00 03 01    	adc    0x103000c(%rax),%esi
    136d:	01 00                	add    %eax,(%rax)
    136f:	00 04 47             	add    %al,(%rdi,%rax,2)
    1372:	00 00                	add    %al,(%rax)
    1374:	00 06                	add    %al,(%rsi)
    1376:	00 1a                	add    %bl,(%rdx)
    1378:	f8                   	clc
    1379:	0b 13                	or     (%rbx),%edx
    137b:	01 99 00 00 00 1b    	add    %ebx,0x1b000000(%rcx)
    1381:	87 0b                	xchg   %ecx,(%rbx)
    1383:	14 01                	adc    $0x1,%al
    1385:	de 08                	fimuls (%rax)
    1387:	00 00                	add    %al,(%rax)
    1389:	1b 88 0b 15 01 de    	sbb    -0x21feeaf5(%rax),%ecx
    138f:	08 00                	or     %al,(%rax)
    1391:	00 1b                	add    %bl,(%rbx)
    1393:	d0 0b                	rorb   (%rbx)
    1395:	16                   	(bad)
    1396:	01 e1                	add    %esp,%ecx
    1398:	00 00                	add    %al,(%rax)
    139a:	00 1b                	add    %bl,(%rbx)
    139c:	95                   	xchg   %eax,%ebp
    139d:	0b 17                	or     (%rdi),%edx
    139f:	01 41 0f             	add    %eax,0xf(%rcx)
    13a2:	00 00                	add    %al,(%rax)
    13a4:	1c d2                	sbb    $0xd2,%al
    13a6:	0b 18                	or     (%rax),%ebx
    13a8:	01 08                	add    %ecx,(%rax)
    13aa:	14 00                	adc    $0x0,%al
    13ac:	00 1c b6             	add    %bl,(%rsi,%rsi,4)
    13af:	0b 19                	or     (%rcx),%ebx
    13b1:	01 4b 0f             	add    %ecx,0xf(%rbx)
    13b4:	00 00                	add    %al,(%rax)
    13b6:	1d 1c a2 0b 26       	sbb    $0x260ba21c,%eax
    13bb:	01 a2 00 00 00 26    	add    %esp,0x26000000(%rdx)
    13c1:	01 01                	add    %eax,(%rcx)
    13c3:	0b 27                	or     (%rdi),%esp
    13c5:	01 bc 04 00 00 1c ee 	add    %edi,-0x11e40000(%rsp,%rax,1)
    13cc:	0b 2d 01 c5 01 00    	or     0x1c501(%rip),%ebp        # 1d8d3 <bpf_xdp_adjust_head+0x15933>
    if (!vip_info) {
    13d2:	00 1d 1c a5 0b 28    	add    %bl,0x280ba51c(%rip)        # 280bb8f4 <bpf_xdp_adjust_head+0x280b3954>
    13d8:	01 de                	add    %ebx,%esi
    13da:	08 00                	or     %al,(%rax)
      return XDP_PASS;
    13dc:	00 1d 1c 07 0b 28    	add    %bl,0x280b071c(%rip)        # 280b1afe <bpf_xdp_adjust_head+0x280a9b5e>
    13e2:	01 a9 0e 00 00 1d    	add    %ebp,0x1d00000e(%rcx)
    13e8:	1c a6                	sbb    $0xa6,%al
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
    13ea:	0b 28                	or     (%rax),%ebp
    13ec:	01 a2 00 00 00 1c    	add    %esp,0x1c000000(%rdx)
    13f2:	14 0b                	adc    $0xb,%al
    13f4:	28 01                	sub    %al,(%rcx)
    13f6:	ae                   	scas   %es:(%rdi),%al
    13f7:	0e                   	(bad)
    13f8:	00 00                	add    %al,(%rax)
    13fa:	1c a7                	sbb    $0xa7,%al
        !(vip_info->flags & F_HASH_SRC_DST_PORT)) {
    13fc:	0b 28                	or     (%rax),%ebp
    13fe:	01 ae 0e 00 00 00    	add    %ebp,0xe(%rsi)
    1404:	00 00                	add    %al,(%rax)
    1406:	00 00                	add    %al,(%rax)
    1408:	0a 0d 14 00 00 27    	or     0x27000014(%rip),%cl        # 27001422 <bpf_xdp_adjust_head+0x26ff9482>
      pckt.flow.port16[1] = 0;
    140e:	00 01                	add    %al,(%rcx)
    1410:	08 14 59             	or     %dl,(%rcx,%rbx,2)
    1413:	09 07                	or     %eax,(%rdi)
    1415:	f9                   	stc
    1416:	00 00                	add    %al,(%rax)
  }
    1418:	00 14 5a             	add    %dl,(%rdx,%rbx,2)
  if (data_end - data > MAX_PCKT_SIZE) {
    141b:	00 09                	add    %cl,(%rcx)
    141d:	f9                   	stc
    141e:	f9                   	stc
    141f:	00 00                	add    %al,(%rax)
    1421:	00 14 5b             	add    %dl,(%rbx,%rbx,2)
    1424:	01 09                	add    %ecx,(%rcx)
    1426:	fa                   	cli
    1427:	01 10                	add    %edx,(%rax)
    1429:	00 00                	add    %al,(%rax)
    142b:	14 5c                	adc    $0x5c,%al
    142d:	02 09                	add    (%rcx),%cl
    142f:	fb                   	sti
    1430:	37                   	(bad)
    1431:	14 00                	adc    $0x0,%al
    return XDP_DROP;
    1433:	00 14 68             	add    %dl,(%rax,%rbp,2)
    1436:	04 0e                	add    $0xe,%al
    1438:	04 14                	add    $0x14,%al
    143a:	5d                   	pop    %rbp
    143b:	09 fc                	or     %edi,%esp
    143d:	44 14 00             	rex.R adc $0x0,%al
    1440:	00 14 61             	add    %dl,(%rcx,%riz,2)
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
    1443:	00 08                	add    %cl,(%rax)
    1445:	04 14                	add    $0x14,%al
    1447:	5e                   	pop    %rsi
    1448:	09 ba f9 0f 00 00    	or     %edi,0xff9(%rdx)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    144e:	14 5f                	adc    $0x5f,%al
    1450:	00 09                	add    %cl,(%rcx)
    1452:	dc f9                	fdivr  %st,%st(1)
    1454:	0f 00 00             	sldt   (%rax)
    1457:	14 60                	adc    $0x60,%al
    1459:	02 00                	add    (%rax),%al
    145b:	09 fd                	or     %edi,%ebp
    145d:	b1 01                	mov    $0x1,%cl
    145f:	00 00                	add    %al,(%rax)
    1461:	14 62                	adc    $0x62,%al
    1463:	00 09                	add    %cl,(%rcx)
    1465:	fe                   	(bad)
    1466:	6d                   	insl   (%dx),%es:(%rdi)
    1467:	14 00                	adc    $0x0,%al
    1469:	00 14 66             	add    %dl,(%rsi,%riz,2)
    146c:	00 08                	add    %cl,(%rax)
    146e:	04 14                	add    $0x14,%al
    1470:	63 09                	movsxd (%rcx),%ecx
    1472:	ff                   	(bad)
    1473:	f9                   	stc
    1474:	0f 00 00             	sldt   (%rax)
    1477:	14 64                	adc    $0x64,%al
    1479:	00 09                	add    %cl,(%rcx)
    147b:	ee                   	out    %al,(%dx)
    147c:	f9                   	stc
    147d:	0f 00 00             	sldt   (%rax)
    1480:	14 65                	adc    $0x65,%al
    1482:	02 00                	add    (%rax),%al
    1484:	09 df                	or     %ebx,%edi
    1486:	29 12                	sub    %edx,(%rdx)
    1488:	00 00                	add    %al,(%rax)
    148a:	14 67                	adc    $0x67,%al
    148c:	00 00                	add    %al,(%rax)
    148e:	00 28                	add    %ch,(%rax)
    1490:	02 01                	add    (%rcx),%al
    1492:	0b 3e                	or     (%rsi),%edi
    1494:	99                   	cltd
    1495:	00 00                	add    %al,(%rax)
    1497:	00 24 87             	add    %ah,(%rdi,%rax,4)
    149a:	0b 3f                	or     (%rdi),%edi
    149c:	de 08                	fimuls (%rax)
    149e:	00 00                	add    %al,(%rax)
    14a0:	24 88                	and    $0x88,%al
    14a2:	0b 40 de             	or     -0x22(%rax),%eax
    14a5:	08 00                	or     %al,(%rax)
    14a7:	00 25 b6 0b 41 4b    	add    %ah,0x4b410bb6(%rip)        # 4b412063 <bpf_xdp_adjust_head+0x4b40a0c3>
    14ad:	0f 00 00             	sldt   (%rax)
    14b0:	25 d2 0b 42 08       	and    $0x8420bd2,%eax
    14b5:	14 00                	adc    $0x0,%al
    14b7:	00 25 f0 0b 43 a2    	add    %ah,-0x5dbcf410(%rip)        # ffffffffa24320ad <server_id_map+0x36feae1b60ad>
    14bd:	00 00                	add    %al,(%rax)
    14bf:	00 29                	add    %ch,(%rcx)
    14c1:	03 01                	add    (%rcx),%eax
    14c3:	0b 44 e1 00          	or     0x0(%rcx,%riz,8),%eax
  if (!data_stats) {
    14c7:	00 00                	add    %al,(%rax)
    14c9:	25 d0 0b 45 e1       	and    $0xe1450bd0,%eax
    14ce:	00 00                	add    %al,(%rax)
    return XDP_DROP;
    14d0:	00 00                	add    %al,(%rax)
    14d2:	2a 04 01             	sub    (%rcx,%rax,1),%al
    14d5:	0c 32                	or     $0x32,%al
    14d7:	24 b6                	and    $0xb6,%al
    14d9:	0c 33                	or     $0x33,%al
    14db:	de 08                	fimuls (%rax)
    14dd:	00 00                	add    %al,(%rax)
  data_stats->v1 += 1;
    14df:	2b 03                	sub    (%rbx),%eax
    14e1:	01 0c 34             	add    %ecx,(%rsp,%rsi,1)
    14e4:	46 0f 00 00          	rex.RX sldt (%rax)
    14e8:	29 05 01 0c 35 c6    	sub    %eax,-0x39caf3ff(%rip)        # ffffffffc63520ef <server_id_map+0x36fed20d60ef>
    14ee:	09 00                	or     %eax,(%rax)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
    14f0:	00 1d 29 06 01 0c    	add    %bl,0xc010629(%rip)        # c011b1f <bpf_xdp_adjust_head+0xc009b7f>
    14f6:	37                   	(bad)
    14f7:	99                   	cltd
    14f8:	00 00                	add    %al,(%rax)
    14fa:	00 00                	add    %al,(%rax)
    14fc:	00 28                	add    %ch,(%rax)
    14fe:	07                   	(bad)
    14ff:	01 0c 1d c5 01 00 00 	add    %ecx,0x1c5(,%rbx,1)
    pckt.flow.port16[0] = 0;
    1506:	2b 03                	sub    (%rbx),%eax
    1508:	01 0c 1e             	add    %ecx,(%rsi,%rbx,1)
  vip_num = vip_info->vip_num;
    150b:	e1 00                	loope  150d <balancer_ingress+0x150d>
    150d:	00 00                	add    %al,(%rax)
    150f:	29 06                	sub    %eax,(%rsi)
    1511:	01 0c 1f             	add    %ecx,(%rdi,%rbx,1)
    1514:	99                   	cltd
    1515:	00 00                	add    %al,(%rax)
    1517:	00 00                	add    %al,(%rax)
    1519:	28 08                	sub    %cl,(%rax)
  __u32 cpu_num = bpf_get_smp_processor_id();
    151b:	01 09                	add    %ecx,(%rcx)
    151d:	75 7b                	jne    159a <balancer_ingress+0x159a>
    151f:	0e                   	(bad)
    1520:	00 00                	add    %al,(%rax)
    1522:	24 87                	and    $0x87,%al
    1524:	09 76 de             	or     %esi,-0x22(%rsi)
    1527:	08 00                	or     %al,(%rax)
    1529:	00 24 88             	add    %ah,(%rax,%rcx,4)
    152c:	09 77 de             	or     %esi,-0x22(%rdi)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
    152f:	08 00                	or     %al,(%rax)
    1531:	00 24 92             	add    %ah,(%rdx,%rdx,4)
    1534:	09 78 7b             	or     %edi,0x7b(%rax)
    1537:	0e                   	(bad)
    1538:	00 00                	add    %al,(%rax)
    153a:	24 95                	and    $0x95,%al
    153c:	09 79 41             	or     %edi,0x41(%rcx)
    153f:	0f 00 00             	sldt   (%rax)
    1542:	25 aa 09 7a 7b       	and    $0x7b7a09aa,%eax
    1547:	0e                   	(bad)
    1548:	00 00                	add    %al,(%rax)
    154a:	25 d0 09 7b e1       	and    $0xe17b09d0,%eax
    154f:	00 00                	add    %al,(%rax)
    1551:	00 29                	add    %ch,(%rcx)
    1553:	09 01                	or     %eax,(%rcx)
    1555:	09 7c 5c 15          	or     %edi,0x15(%rsp,%rbx,2)
    1559:	00 00                	add    %al,(%rax)
    155b:	00 0a                	add    %cl,(%rdx)
    155d:	61                   	(bad)
    155e:	15 00 00 27 1b       	adc    $0x1b270000,%eax
    1563:	01 14 15 19 2c 0a 01 	add    %edx,0x10a2c19(,%rdx,1)
    156a:	f9                   	stc
    156b:	0f 00 00             	sldt   (%rax)
    156e:	15 1a 00 2c 0b       	adc    $0xb2c001a,%eax
    1573:	01 f9                	add    %edi,%ecx
    1575:	0f 00 00             	sldt   (%rax)
    1578:	15 1b 02 2c 0c       	adc    $0xc2c021b,%eax
    157d:	01 b1 01 00 00 15    	add    %esi,0x15000001(%rcx)
    1583:	1c 04                	sbb    $0x4,%al
    1585:	2c 0d                	sub    $0xd,%al
    1587:	01 b1 01 00 00 15    	add    %esi,0x15000001(%rcx)
    158d:	1d 08 2d 0e 01       	sbb    $0x10e2d08,%eax
    1592:	c5 01 00             	(bad)
    1595:	00 15 1f 02 01 0f    	add    %dl,0xf01021f(%rip)        # f0117ba <bpf_xdp_adjust_head+0xf00981a>
    159b:	0c 2d                	or     $0x2d,%al
    159d:	0f 01 c5             	pconfig
    15a0:	01 00                	add    %eax,(%rax)
    15a2:	00 15 20 02 03 0c    	add    %dl,0xc030220(%rip)        # c0317c8 <bpf_xdp_adjust_head+0xc029828>
    15a8:	0c 2d                	or     $0x2d,%al
  if (!lru_map) {
    15aa:	10 01                	adc    %al,(%rcx)
    15ac:	c5 01 00             	(bad)
    15af:	00 15 21 02 04 08    	add    %dl,0x8040221(%rip)        # 80417d6 <bpf_xdp_adjust_head+0x8039836>
    15b5:	0c 2d                	or     $0x2d,%al
    15b7:	11 01                	adc    %eax,(%rcx)
    lru_map = &fallback_cache;
    15b9:	c5 01 00             	(bad)
    15bc:	00 15 22 02 01 07    	add    %dl,0x7010222(%rip)        # 70117e4 <bpf_xdp_adjust_head+0x7009844>
    15c2:	0c 2d                	or     $0x2d,%al
    15c4:	12 01                	adc    (%rcx),%al
    15c6:	c5 01 00             	(bad)
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
    15c9:	00 15 23 02 01 06    	add    %dl,0x6010223(%rip)        # 60117f2 <bpf_xdp_adjust_head+0x6009852>
    15cf:	0c 2d                	or     $0x2d,%al
    15d1:	13 01                	adc    (%rcx),%eax
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
    15d3:	c5 01 00             	(bad)
    15d6:	00 15 24 02 01 05    	add    %dl,0x5010224(%rip)        # 5011800 <bpf_xdp_adjust_head+0x5009860>
    15dc:	0c 2d                	or     $0x2d,%al
    15de:	14 01                	adc    $0x1,%al
    15e0:	c5 01 00             	(bad)
    15e3:	00 15 25 02 01 04    	add    %dl,0x4010225(%rip)        # 401180e <bpf_xdp_adjust_head+0x400986e>
    15e9:	0c 2d                	or     $0x2d,%al
    15eb:	15 01 c5 01 00       	adc    $0x1c501,%eax
    15f0:	00 15 26 02 01 03    	add    %dl,0x3010226(%rip)        # 301181c <bpf_xdp_adjust_head+0x300987c>
    15f6:	0c 2d                	or     $0x2d,%al
    15f8:	16                   	(bad)
    15f9:	01 c5                	add    %eax,%ebp
    15fb:	01 00                	add    %eax,(%rax)
    15fd:	00 15 27 02 01 02    	add    %dl,0x2010227(%rip)        # 201182a <bpf_xdp_adjust_head+0x200988a>
    1603:	0c 2d                	or     $0x2d,%al
    1605:	17                   	(bad)
    1606:	01 c5                	add    %eax,%ebp
    1608:	01 00                	add    %eax,(%rax)
    160a:	00 15 28 02 01 01    	add    %dl,0x1010228(%rip)        # 1011838 <bpf_xdp_adjust_head+0x1009898>
    1610:	0c 2d                	or     $0x2d,%al
    1612:	18 01                	sbb    %al,(%rcx)
    1614:	c5 01 00             	(bad)
    1617:	00 15 29 02 01 00    	add    %dl,0x10229(%rip)        # 11846 <bpf_xdp_adjust_head+0x98a6>
    161d:	0c 2c                	or     $0x2c,%al
    161f:	19 01                	sbb    %eax,(%rcx)
    1621:	f9                   	stc
    1622:	0f 00 00             	sldt   (%rax)
    1625:	15 39 0e 09 bd       	adc    $0xbd090e39,%eax
    162a:	01 10                	add    %edx,(%rax)
    162c:	00 00                	add    %al,(%rax)
    162e:	15 3a 10 2c 1a       	adc    $0x1a2c103a,%eax
    1633:	01 f9                	add    %edi,%ecx
    1635:	0f 00 00             	sldt   (%rax)
    1638:	15 3b 12 00 28       	adc    $0x2800123b,%eax
    163d:	1c 01                	sbb    $0x1,%al
    163f:	09 49 e1             	or     %ecx,-0x1f(%rcx)
    1642:	00 00                	add    %al,(%rax)
    1644:	00 24 92             	add    %ah,(%rdx,%rdx,4)
    1647:	09 4a 7b             	or     %ecx,0x7b(%rdx)
    164a:	0e                   	(bad)
    164b:	00 00                	add    %al,(%rax)
    164d:	24 aa                	and    $0xaa,%al
    if (!lru_stats) {
    164f:	09 4b 7b             	or     %ecx,0x7b(%rbx)
    1652:	0e                   	(bad)
    1653:	00 00                	add    %al,(%rax)
    1655:	25 d0 09 4c e1       	and    $0xe14c09d0,%eax
      return XDP_DROP;
    165a:	00 00                	add    %al,(%rax)
    165c:	00 00                	add    %al,(%rax)
    165e:	28 1d 01 09 5b 7b    	sub    %bl,0x7b5b0901(%rip)        # 7b5b1f65 <bpf_xdp_adjust_head+0x7b5a9fc5>
    1664:	0e                   	(bad)
    1665:	00 00                	add    %al,(%rax)
    lru_stats->v1 += 1;
    1667:	24 87                	and    $0x87,%al
    1669:	09 5c de 08          	or     %ebx,0x8(%rsi,%rbx,8)
    166d:	00 00                	add    %al,(%rax)
    166f:	24 88                	and    $0x88,%al
    1671:	09 5d de             	or     %ebx,-0x22(%rbp)
    1674:	08 00                	or     %al,(%rax)
    1676:	00 24 92             	add    %ah,(%rdx,%rdx,4)
  if ((vip_info->flags & F_QUIC_VIP)) {
    1679:	09 5e 7b             	or     %ebx,0x7b(%rsi)
    167c:	0e                   	(bad)
    167d:	00 00                	add    %al,(%rax)
    167f:	24 95                	and    $0x95,%al
    1681:	09 5f 41             	or     %ebx,0x41(%rdi)
    1684:	0f 00 00             	sldt   (%rax)
    1687:	25 aa 09 60 7b       	and    $0x7b6009aa,%eax
    168c:	0e                   	(bad)
    bool is_icmp = (pckt.flags & F_ICMP);
    168d:	00 00                	add    %al,(%rax)
    168f:	25 d0 09 61 e1       	and    $0xe16109d0,%eax
    1694:	00 00                	add    %al,(%rax)
    1696:	00 29                	add    %ch,(%rcx)
    1698:	1e                   	(bad)
    1699:	01 09                	add    %ecx,(%rcx)
    169b:	62 a1 16 00 00       	(bad)
    16a0:	00 0a                	add    %cl,(%rdx)
    16a2:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    16a3:	16                   	(bad)
    16a4:	00 00                	add    %al,(%rax)
    if (is_icmp) {
    16a6:	27                   	(bad)
    16a7:	20 01                	and    %al,(%rcx)
    16a9:	08 16                	or     %dl,(%rsi)
    16ab:	17                   	(bad)
    16ac:	2c 0a                	sub    $0xa,%al
    16ae:	01 f9                	add    %edi,%ecx
    16b0:	0f 00 00             	sldt   (%rax)
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
    16b3:	16                   	(bad)
    16b4:	18 00                	sbb    %al,(%rax)
    16b6:	2c 0b                	sub    $0xb,%al
    16b8:	01 f9                	add    %edi,%ecx
    16ba:	0f 00 00             	sldt   (%rax)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    16bd:	16                   	(bad)
    16be:	19 02                	sbb    %eax,(%rdx)
    16c0:	2c 1f                	sub    $0x1f,%al
    16c2:	01 f9                	add    %edi,%ecx
    16c4:	0f 00 00             	sldt   (%rax)
    16c7:	16                   	(bad)
    16c8:	1a 04 09             	sbb    (%rcx,%rcx,1),%al
    16cb:	bd 01 10 00 00       	mov    $0x1001,%ebp
    16d0:	16                   	(bad)
    16d1:	1b 06                	sbb    (%rsi),%eax
    16d3:	00 2e                	add    %ch,(%rsi)
    16d5:	21 01                	and    %eax,(%rcx)
    16d7:	0b 44 01 7b          	or     0x7b(%rcx,%rax,1),%eax
    16db:	0e                   	(bad)
    16dc:	00 00                	add    %al,(%rax)
    16de:	1b 87 0b 44 01 de    	sbb    -0x21febbf5(%rdi),%eax
    16e4:	08 00                	or     %al,(%rax)
    16e6:	00 1b                	add    %bl,(%rbx)
    16e8:	88 0b                	mov    %cl,(%rbx)
    16ea:	44 01 de             	add    %r11d,%esi
    16ed:	08 00                	or     %al,(%rax)
    16ef:	00 1b                	add    %bl,(%rbx)
    16f1:	92                   	xchg   %eax,%edx
    16f2:	0b 44 01 7b          	or     0x7b(%rcx,%rax,1),%eax
    16f6:	0e                   	(bad)
    16f7:	00 00                	add    %al,(%rax)
    16f9:	1c d0                	sbb    $0xd0,%al
    16fb:	0b 45 01             	or     0x1(%rbp),%eax
    16fe:	e1 00                	loope  1700 <balancer_ingress+0x1700>
    1700:	00 00                	add    %al,(%rax)
    1702:	1d 1c d2 0b 47       	sbb    $0x470bd21c,%eax
    1707:	01 a7 11 00 00 00    	add    %esp,0x11(%rdi)
    170d:	1d 1c d2 0b 4c       	sbb    $0x4c0bd21c,%eax
    1712:	01 08                	add    %ecx,(%rax)
    1714:	14 00                	adc    $0x0,%al
    1716:	00 00                	add    %al,(%rax)
    1718:	00 2e                	add    %ch,(%rsi)
    171a:	22 01                	and    (%rcx),%al
    171c:	09 53 01             	or     %edx,0x1(%rbx)
    171f:	b3 0e                	mov    $0xe,%bl
    1721:	00 00                	add    %al,(%rax)
    1723:	1b 87 09 54 01 de    	sbb    -0x21feabf7(%rdi),%eax
    1729:	08 00                	or     %al,(%rax)
    172b:	00 1b                	add    %bl,(%rbx)
    172d:	88 09                	mov    %cl,(%rcx)
    172f:	55                   	push   %rbp
    1730:	01 de                	add    %ebx,%esi
    1732:	08 00                	or     %al,(%rax)
    1734:	00 1b                	add    %bl,(%rbx)
    1736:	92                   	xchg   %eax,%edx
      if (!data_stats) {
    1737:	09 56 01             	or     %edx,0x1(%rsi)
    173a:	7b 0e                	jnp    174a <balancer_ingress+0x174a>
    173c:	00 00                	add    %al,(%rax)
    173e:	1b 95 09 57 01 41    	sbb    0x41015709(%rbp),%edx
        return XDP_DROP;
    1744:	0f 00 00             	sldt   (%rax)
    1747:	26 23 01             	es and (%rcx),%eax
    174a:	09 58 01             	or     %ebx,0x1(%rax)
    174d:	b3 0e                	mov    $0xe,%bl
    174f:	00 00                	add    %al,(%rax)
      data_stats->v1 += 1;
    1751:	1c aa                	sbb    $0xaa,%al
    1753:	09 5f 01             	or     %ebx,0x1(%rdi)
    1756:	7b 0e                	jnp    1766 <balancer_ingress+0x1766>
    1758:	00 00                	add    %al,(%rax)
    175a:	1c d0                	sbb    $0xd0,%al
    175c:	09 60 01             	or     %esp,0x1(%rax)
    175f:	e1 00                	loope  1761 <balancer_ingress+0x1761>
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    1761:	00 00                	add    %al,(%rax)
    1763:	26 24 01             	es and $0x1,%al
    1766:	09 67 01             	or     %esp,0x1(%rdi)
    1769:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    176a:	08 00                	or     %al,(%rax)
    176c:	00 26                	add    %ah,(%rsi)
    176e:	25 01 09 68 01       	and    $0x1680901,%eax
    1773:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    1774:	08 00                	or     %al,(%rax)
    1776:	00 26                	add    %ah,(%rsi)
    1778:	26 01 09             	es add %ecx,(%rcx)
    177b:	69 01 a4 08 00 00    	imul   $0x8a4,(%rcx),%eax
    1781:	26 27                	es (bad)
    1783:	01 09                	add    %ecx,(%rcx)
    1785:	8c 01                	mov    %es,(%rcx)
    1787:	f9                   	stc
    1788:	00 00                	add    %al,(%rax)
    178a:	00 1d 26 28 01 09    	add    %bl,0x9012826(%rip)        # 9013fb6 <bpf_xdp_adjust_head+0x900c016>
  __u64 off = sizeof(struct ethhdr);
    1790:	7b 01                	jnp    1793 <balancer_ingress+0x1793>
    1792:	cb                   	lret
    1793:	09 00                	or     %eax,(%rax)
    1795:	00 00                	add    %al,(%rax)
  if (is_ipv6) {
    1797:	00 2f                	add    %ch,(%rdi)
    1799:	29 01                	sub    %eax,(%rcx)
    179b:	00 35 02 1b ac 00    	add    %dh,0xac1b02(%rip)        # ac32a3 <bpf_xdp_adjust_head+0xabb303>
    struct icmp6hdr* icmp_hdr = data + off + sizeof(struct ipv6hdr);
    17a1:	36 02 df             	ss add %bh,%bl
    17a4:	05 00 00 1b af       	add    $0xaf1b0000,%eax
    17a9:	00 37                	add    %dh,(%rdi)
    17ab:	02 f9                	add    %cl,%bh
    17ad:	00 00                	add    %al,(%rax)
    17af:	00 00                	add    %al,(%rax)
    17b1:	2e 2a 01             	cs sub (%rcx),%al
    17b4:	00 67 02             	add    %ah,0x2(%rdi)
    17b7:	99                   	cltd
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
    17b8:	00 00                	add    %al,(%rax)
    17ba:	00 1b                	add    %bl,(%rbx)
    17bc:	95                   	xchg   %eax,%ebp
    17bd:	00 68 02             	add    %ch,0x2(%rax)
    17c0:	41 0f 00 00          	sldt   (%r8)
    17c4:	1b a4 00 69 02 de 08 	sbb    0x8de0269(%rax,%rax,1),%esp
    17cb:	00 00                	add    %al,(%rax)
    17cd:	26 2b 01             	es sub (%rcx),%eax
        (icmp_hdr->icmp6_code == ICMPV6_PORT_UNREACH));
    17d0:	00 6a 02             	add    %ch,0x2(%rdx)
    17d3:	cb                   	lret
    17d4:	02 00                	add    (%rax),%al
    17d6:	00 26                	add    %ah,(%rsi)
    17d8:	2c 01                	sub    $0x1,%al
    17da:	00 73 02             	add    %dh,0x2(%rbx)
    17dd:	e1 00                	loope  17df <balancer_ingress+0x17df>
    17df:	00 00                	add    %al,(%rax)
    17e1:	26 2d 01 00 77 02    	es sub $0x2770001,%eax
    17e7:	d0 02                	rolb   (%rdx)
    17e9:	00 00                	add    %al,(%rax)
    17eb:	00 28                	add    %ch,(%rax)
    return (
    17ed:	2e 01 00             	cs add %eax,(%rax)
    17f0:	26 7b 0e             	es jnp 1801 <balancer_ingress+0x1801>
    17f3:	00 00                	add    %al,(%rax)
    17f5:	2b 2c 01             	sub    (%rcx,%rax,1),%ebp
    struct icmphdr* icmp_hdr = data + off + sizeof(struct iphdr);
    17f8:	00 27                	add    %ah,(%rdi)
    17fa:	46 0f 00 00          	rex.RX sldt (%rax)
    17fe:	29 2f                	sub    %ebp,(%rdi)
    1800:	01 00                	add    %eax,(%rax)
    1802:	28 a2 00 00 00 29    	sub    %ah,0x29000000(%rdx)
    1808:	30 01                	xor    %al,(%rcx)
    180a:	00 29                	add    %ch,(%rcx)
    180c:	bc 04 00 00 1d       	mov    $0x1d000004,%esp
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    1811:	25 a5 00 2a de       	and    $0xde2a00a5,%eax
    1816:	08 00                	or     %al,(%rax)
    1818:	00 1d 25 07 00 2a    	add    %bl,0x2a000725(%rip)        # 2a001f43 <bpf_xdp_adjust_head+0x29ff9fa3>
    181e:	a9 0e 00 00 1d       	test   $0x1d00000e,%eax
    1823:	25 a6 00 2a a2       	and    $0xa22a00a6,%eax
        (icmp_hdr->code == ICMP_HOST_UNREACH));
    1828:	00 00                	add    %al,(%rax)
    182a:	00 25 14 00 2a ae    	add    %ah,-0x51d5ffec(%rip)        # ffffffffae2a1844 <server_id_map+0x36feba025844>
    1830:	0e                   	(bad)
    1831:	00 00                	add    %al,(%rax)
    1833:	25 a7 00 2a ae       	and    $0xae2a00a7,%eax
    1838:	0e                   	(bad)
    1839:	00 00                	add    %al,(%rax)
    183b:	00 00                	add    %al,(%rax)
    183d:	00 00                	add    %al,(%rax)
    183f:	2f                   	(bad)
    1840:	31 01                	xor    %eax,(%rcx)
    1842:	00 7e 02             	add    %bh,0x2(%rsi)
    return (
    1845:	1b 20                	sbb    (%rax),%esp
    1847:	00 7e 02             	add    %bh,0x2(%rsi)
    184a:	a2 00 00 00 30 32 01 	movabs %al,0x7e00013230000000
    1851:	00 7e 
    1853:	02 7b 0e             	add    0xe(%rbx),%bh
    1856:	00 00                	add    %al,(%rax)
        data_stats->v2 += 1;
    1858:	30 33                	xor    %dh,(%rbx)
    185a:	01 00                	add    %eax,(%rax)
    185c:	7e 02                	jle    1860 <balancer_ingress+0x1860>
    185e:	7b 0e                	jnp    186e <balancer_ingress+0x186e>
    1860:	00 00                	add    %al,(%rax)
    1862:	26 34 01             	es xor $0x1,%al
    1865:	00 7f 02             	add    %bh,0x2(%rdi)
    1868:	bc 04 00 00 1d       	mov    $0x1d000004,%esp
    } else {
    186d:	1c a5                	sbb    $0xa5,%al
    186f:	00 80 02 de 08 00    	add    %al,0x8de02(%rax)
      __u32 quic_packets_stats_key = 0;
    1875:	00 1d 1c 07 00 80    	add    %bl,-0x7ffff8e4(%rip)        # ffffffff80001f97 <server_id_map+0x36fe8bd85f97>
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
    187b:	02 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ch
    1881:	1c a6                	sbb    $0xa6,%al
    1883:	00 80 02 a2 00 00    	add    %al,0xa202(%rax)
    1889:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
    188c:	00 80 02 ae 0e 00    	add    %al,0xeae02(%rax)
    1892:	00 1c a7             	add    %bl,(%rdi,%riz,4)
    1895:	00 80 02 ae 0e 00    	add    %al,0xeae02(%rax)
    189b:	00 00                	add    %al,(%rax)
    189d:	00 00                	add    %al,(%rax)
    189f:	00 2a                	add    %ch,(%rdx)
    18a1:	35 01 00 b0 2b       	xor    $0x2bb00001,%eax
    18a6:	36 01 00             	ss add %eax,(%rax)
    18a9:	b1 10                	mov    $0x10,%cl
    18ab:	19 00                	sbb    %eax,(%rax)
    18ad:	00 24 95 00 b2 41 0f 	add    %ah,0xf41b200(,%rdx,4)
    18b4:	00 00                	add    %al,(%rax)
    18b6:	24 a4                	and    $0xa4,%al
    18b8:	00 b3 de 08 00 00    	add    %dh,0x8de(%rbx)
    18be:	2b 37                	sub    (%rdi),%esi
    18c0:	01 00                	add    %eax,(%rax)
    18c2:	b4 7b                	mov    $0x7b,%ah
    18c4:	0e                   	(bad)
    18c5:	00 00                	add    %al,(%rax)
    18c7:	29 2b                	sub    %ebp,(%rbx)
    18c9:	01 00                	add    %eax,(%rax)
    18cb:	b5 cb                	mov    $0xcb,%ch
    18cd:	02 00                	add    (%rax),%al
    18cf:	00 29                	add    %ch,(%rcx)
    18d1:	2c 01                	sub    $0x1,%al
    18d3:	00 b6 e1 00 00 00    	add    %dh,0xe1(%rsi)
    18d9:	25 09 00 b7 a2       	and    $0xa2b70009,%eax
    18de:	00 00                	add    %al,(%rax)
    18e0:	00 1d 25 a5 00 c5    	add    %bl,-0x3aff5adb(%rip)        # ffffffffc500be0b <server_id_map+0x36fed0d8fe0b>
    18e6:	de 08                	fimuls (%rax)
    18e8:	00 00                	add    %al,(%rax)
    18ea:	1d 25 07 00 c5       	sbb    $0xc5000725,%eax
      struct lb_quic_packets_stats* quic_packets_stats =
    18ef:	a9 0e 00 00 1d       	test   $0x1d00000e,%eax
    18f4:	25 a6 00 c5 a2       	and    $0xa2c500a6,%eax
      if (!quic_packets_stats) {
    18f9:	00 00                	add    %al,(%rax)
    18fb:	00 25 14 00 c5 ae    	add    %ah,-0x513affec(%rip)        # ffffffffaec51915 <server_id_map+0x36feba9d5915>
        return XDP_DROP;
    1901:	0e                   	(bad)
    1902:	00 00                	add    %al,(%rax)
    1904:	25 a7 00 c5 ae       	and    $0xaec500a7,%eax
    1909:	0e                   	(bad)
    190a:	00 00                	add    %al,(%rax)
    190c:	00 00                	add    %al,(%rax)
      struct quic_parse_result qpr = parse_quic(data, data_end, is_ipv6, &pckt);
    190e:	00 00                	add    %al,(%rax)
    1910:	0a 29                	or     (%rcx),%ch
    1912:	04 00                	add    $0x0,%al
    1914:	00 2e                	add    %ch,(%rsi)
    1916:	38 01                	cmp    %al,(%rcx)
    1918:	00 8c 02 99 00 00 00 	add    %cl,0x99(%rdx,%rax,1)
    191f:	1b 25 00 8d 02 10    	sbb    0x10028d00(%rip),%esp        # 1002a625 <bpf_xdp_adjust_head+0x10022685>
    1925:	19 00                	sbb    %eax,(%rax)
    1927:	00 1b                	add    %bl,(%rbx)
    1929:	95                   	xchg   %eax,%ebp
    192a:	00 8e 02 41 0f 00    	add    %cl,0xf4102(%rsi)
    1930:	00 1b                	add    %bl,(%rbx)
    1932:	9a                   	(bad)
    1933:	00 8f 02 d1 01 00    	add    %cl,0x1d102(%rdi)
    1939:	00 1b                	add    %bl,(%rbx)
    193b:	17                   	(bad)
    193c:	00 90 02 75 01 00    	add    %dl,0x17502(%rax)
    1942:	00 26                	add    %ah,(%rsi)
    1944:	2c 01                	sub    $0x1,%al
  struct quic_parse_result result = {
    1946:	00 91 02 e1 00 00    	add    %dl,0xe102(%rcx)
    194c:	00 1d 26 39 01 00    	add    %bl,0x13926(%rip)        # 15278 <bpf_xdp_adjust_head+0xd2d8>
    1952:	95                   	xchg   %eax,%ebp
    1953:	02 de                	add    %dh,%bl
    1955:	08 00                	or     %al,(%rax)
    1957:	00 1d 1c a5 00 95    	add    %bl,-0x6aff5ae4(%rip)        # ffffffff9500be79 <server_id_map+0x36fea0d8fe79>
  bool is_icmp = (pckt->flags & F_ICMP);
    195d:	02 de                	add    %dh,%bl
    195f:	08 00                	or     %al,(%rax)
    1961:	00 1d 1c 07 00 95    	add    %bl,-0x6afff8e4(%rip)        # ffffffff95002083 <server_id_map+0x36fea0d86083>
    1967:	02 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ch
    196d:	1c a6                	sbb    $0xa6,%al
    196f:	00 95 02 a2 00 00    	add    %dl,0xa202(%rbp)
    1975:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
    1978:	00 95 02 ae 0e 00    	add    %dl,0xeae02(%rbp)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    197e:	00 1c a7             	add    %bl,(%rdi,%riz,4)
    1981:	00 95 02 ae 0e 00    	add    %dl,0xeae02(%rbp)
    1987:	00 00                	add    %al,(%rax)
    1989:	00 00                	add    %al,(%rax)
    198b:	1d 26 3a 01 00       	sbb    $0x13a26,%eax
    1990:	97                   	xchg   %eax,%edi
    1991:	02 de                	add    %dh,%bl
    1993:	08 00                	or     %al,(%rax)
    1995:	00 1d 1c a2 00 9c    	add    %bl,-0x63ff5de4(%rip)        # ffffffff9c00bbb7 <server_id_map+0x36fea7d8fbb7>
  __u64 off = sizeof(struct ethhdr);
    199b:	02 a2 00 00 00 26    	add    0x26000000(%rdx),%ah
  if (is_ipv6) {
    19a1:	3b 01                	cmp    (%rcx),%eax
    19a3:	00 9d 02 bc 04 00    	add    %bl,0x4bc02(%rbp)
    19a9:	00 1d 1c a5 00 9d    	add    %bl,-0x62ff5ae4(%rip)        # ffffffff9d00becb <server_id_map+0x36fea8d8fecb>
    off += sizeof(struct ipv6hdr);
    19af:	02 de                	add    %dh,%bl
    19b1:	08 00                	or     %al,(%rax)
    19b3:	00 1d 1c 07 00 9d    	add    %bl,-0x62fff8e4(%rip)        # ffffffff9d0020d5 <server_id_map+0x36fea8d860d5>
    19b9:	02 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ch
    if (is_icmp) {
    19bf:	1c a6                	sbb    $0xa6,%al
    19c1:	00 9d 02 a2 00 00    	add    %bl,0xa202(%rbp)
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
    19c7:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
    19ca:	00 9d 02 ae 0e 00    	add    %bl,0xeae02(%rbp)
    19d0:	00 1c a7             	add    %bl,(%rdi,%riz,4)
    19d3:	00 9d 02 ae 0e 00    	add    %bl,0xeae02(%rbp)
	...
    off += sizeof(struct iphdr);
    19e1:	28 3c 01             	sub    %bh,(%rcx,%rax,1)
    19e4:	00 57 7b             	add    %dl,0x7b(%rdi)
    19e7:	0e                   	(bad)
    19e8:	00 00                	add    %al,(%rax)
    19ea:	2b 36                	sub    (%rsi),%esi
    if (is_icmp) {
    19ec:	01 00                	add    %eax,(%rax)
    19ee:	58                   	pop    %rax
    19ef:	10 19                	adc    %bl,(%rcx)
    19f1:	00 00                	add    %al,(%rax)
    19f3:	24 95                	and    $0x95,%al
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
    19f5:	00 59 41             	add    %bl,0x41(%rcx)
    19f8:	0f 00 00             	sldt   (%rax)
    19fb:	24 9a                	and    $0x9a,%al
    19fd:	00 5a d1             	add    %bl,-0x2f(%rdx)
    1a00:	01 00                	add    %eax,(%rax)
    1a02:	00 24 92             	add    %ah,(%rdx,%rdx,4)
    1a05:	00 5b 7b             	add    %bl,0x7b(%rbx)
  return off;
    1a08:	0e                   	(bad)
    1a09:	00 00                	add    %al,(%rax)
    1a0b:	24 a4                	and    $0xa4,%al
    1a0d:	00 5c de 08          	add    %bl,0x8(%rsi,%rbx,8)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    1a11:	00 00                	add    %al,(%rax)
    1a13:	29 2d 01 00 5e d0    	sub    %ebp,-0x2fa1ffff(%rip)        # ffffffffd05e1a1a <server_id_map+0x36fedc365a1a>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1a19:	02 00                	add    (%rax),%al
    1a1b:	00 29                	add    %ch,(%rcx)
    1a1d:	3d 01 00 5f 7b       	cmp    $0x7b5f0001,%eax
    1a22:	0e                   	(bad)
    1a23:	00 00                	add    %al,(%rax)
    1a25:	29 3e                	sub    %edi,(%rsi)
    1a27:	01 00                	add    %eax,(%rax)
    1a29:	60                   	(bad)
    1a2a:	7b 0e                	jnp    1a3a <balancer_ingress+0x1a3a>
    1a2c:	00 00                	add    %al,(%rax)
    1a2e:	25 b2 00 61 9d       	and    $0x9d6100b2,%eax
    1a33:	00 00                	add    %al,(%rax)
    return result;
    1a35:	00 29                	add    %ch,(%rcx)
    1a37:	2c 01                	sub    $0x1,%al
    1a39:	00 62 e1             	add    %ah,-0x1f(%rdx)
  __u8* quic_data = data + off + sizeof(struct udphdr);
    1a3c:	00 00                	add    %al,(%rax)
    1a3e:	00 29                	add    %ch,(%rcx)
    1a40:	3f                   	(bad)
    1a41:	01 00                	add    %eax,(%rax)
    1a43:	63 a2 00 00 00 25    	movsxd 0x25000000(%rdx),%esp
    1a49:	09 00                	or     %eax,(%rax)
    1a4b:	64 a2 00 00 00 1d 29 	movabs %al,%fs:0x140291d000000
    1a52:	40 01 00 
  __u8* pkt_type = quic_data;
    1a55:	86 7b 0e             	xchg   %bh,0xe(%rbx)
    1a58:	00 00                	add    %al,(%rax)
    1a5a:	1d 25 a5 00 92       	sbb    $0x9200a525,%eax
    1a5f:	de 08                	fimuls (%rax)
  __u8* connId = NULL;
    1a61:	00 00                	add    %al,(%rax)
    1a63:	1d 25 07 00 92       	sbb    $0x92000725,%eax
    1a68:	a9 0e 00 00 1d       	test   $0x1d00000e,%eax
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    1a6d:	25 a6 00 92 a2       	and    $0xa29200a6,%eax
    1a72:	00 00                	add    %al,(%rax)
    1a74:	00 25 14 00 92 ae    	add    %ah,-0x516dffec(%rip)        # ffffffffae921a8e <server_id_map+0x36feba6a5a8e>
    1a7a:	0e                   	(bad)
    1a7b:	00 00                	add    %al,(%rax)
    1a7d:	25 a7 00 92 ae       	and    $0xae9200a7,%eax
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1a82:	0e                   	(bad)
    1a83:	00 00                	add    %al,(%rax)
    1a85:	00 00                	add    %al,(%rax)
    1a87:	00 00                	add    %al,(%rax)
    1a89:	1d 25 a5 00 9f       	sbb    $0x9f00a525,%eax
    1a8e:	de 08                	fimuls (%rax)
    1a90:	00 00                	add    %al,(%rax)
    1a92:	1d 25 07 00 9f       	sbb    $0x9f000725,%eax
      return result;
    1a97:	a9 0e 00 00 1d       	test   $0x1d00000e,%eax
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1a9c:	25 a6 00 9f a2       	and    $0xa29f00a6,%eax
    1aa1:	00 00                	add    %al,(%rax)
    1aa3:	00 25 14 00 9f ae    	add    %ah,-0x5160ffec(%rip)        # ffffffffae9f1abd <server_id_map+0x36feba775abd>
    1aa9:	0e                   	(bad)
    1aaa:	00 00                	add    %al,(%rax)
    1aac:	25 a7 00 9f ae       	and    $0xae9f00a7,%eax
      result.is_initial = true;
    1ab1:	0e                   	(bad)
    1ab2:	00 00                	add    %al,(%rax)
      return result;
    1ab4:	00 00                	add    %al,(%rax)
    1ab6:	00 00                	add    %al,(%rax)
    1ab8:	28 41 01             	sub    %al,0x1(%rcx)
    struct quic_long_header* long_header = (struct quic_long_header*)quic_data;
    1abb:	00 19                	add    %bl,(%rcx)
    1abd:	a2 00 00 00 24 95 00 	movabs %al,0x411a009524000000
    1ac4:	1a 41 
    1ac6:	0f 00 00             	sldt   (%rax)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1ac9:	2b 40 01             	sub    0x1(%rax),%eax
    1acc:	00 1b                	add    %bl,(%rbx)
    1ace:	7b 0e                	jnp    1ade <balancer_ingress+0x1ade>
    1ad0:	00 00                	add    %al,(%rax)
    1ad2:	00 31                	add    %dh,(%rcx)
    1ad4:	42 01 00             	rex.X add %eax,(%rax)
      return result;
    1ad7:	4d 29 43 01          	sub    %r8,0x1(%r11)
    1adb:	00 4e a2             	add    %cl,-0x5e(%rsi)
    connId = long_header->dst_connection_id;
    1ade:	00 00                	add    %al,(%rax)
    1ae0:	00 29                	add    %ch,(%rcx)
    1ae2:	44 01 00             	add    %r8d,(%rax)
    1ae5:	4f bc 04 00 00 1d 25 	rex.WRXB movabs $0x5000a5251d000004,%r12
    1aec:	a5 00 50 
  } else {
    1aef:	de 08                	fimuls (%rax)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    1af1:	00 00                	add    %al,(%rax)
    1af3:	1d 25 07 00 50       	sbb    $0x50000725,%eax
    1af8:	a9 0e 00 00 1d       	test   $0x1d00000e,%eax
    1afd:	25 a6 00 50 a2       	and    $0xa25000a6,%eax
    1b02:	00 00                	add    %al,(%rax)
      return result;
    1b04:	00 25 14 00 50 ae    	add    %ah,-0x51afffec(%rip)        # ffffffffae501b1e <server_id_map+0x36feba285b1e>
    connId = ((struct quic_short_header*)quic_data)->connection_id;
    1b0a:	0e                   	(bad)
    1b0b:	00 00                	add    %al,(%rax)
    1b0d:	25 a7 00 50 ae       	and    $0xae5000a7,%eax
    1b12:	0e                   	(bad)
    1b13:	00 00                	add    %al,(%rax)
    1b15:	00 00                	add    %al,(%rax)
    1b17:	00 00                	add    %al,(%rax)
    1b19:	31 45 01             	xor    %eax,0x1(%rbp)
  if (!connId) {
    1b1c:	00 42 29             	add    %al,0x29(%rdx)
    1b1f:	43 01 00             	rex.XB add %eax,(%r8)
    1b22:	43 a2 00 00 00 29 44 	rex.XB movabs %al,0x4400014429000000
    1b29:	01 00 44 
  __u8 connIdVersion = (connId[0] >> 6);
    1b2c:	bc 04 00 00 1d       	mov    $0x1d000004,%esp
    1b31:	25 a5 00 45 de       	and    $0xde4500a5,%eax
    1b36:	08 00                	or     %al,(%rax)
    1b38:	00 1d 25 07 00 45    	add    %bl,0x45000725(%rip)        # 45002263 <bpf_xdp_adjust_head+0x44ffa2c3>
  result.cid_version = connIdVersion;
    1b3e:	a9 0e 00 00 1d       	test   $0x1d00000e,%eax
    1b43:	25 a6 00 45 a2       	and    $0xa24500a6,%eax
    1b48:	00 00                	add    %al,(%rax)
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    1b4a:	00 25 14 00 45 ae    	add    %ah,-0x51baffec(%rip)        # ffffffffae451b64 <server_id_map+0x36feba1d5b64>
    1b50:	0e                   	(bad)
    1b51:	00 00                	add    %al,(%rax)
    1b53:	25 a7 00 45 ae       	and    $0xae4500a7,%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    1b58:	0e                   	(bad)
    1b59:	00 00                	add    %al,(%rax)
    1b5b:	00 00                	add    %al,(%rax)
    1b5d:	00 00                	add    %al,(%rax)
    1b5f:	2e 46 01 00          	cs rex.RX add %r8d,(%rax)
    1b63:	43 02 99 00 00 00 1b 	rex.XB add 0x1b000000(%r9),%bl
    1b6a:	17                   	(bad)
    1b6b:	00 44 02 75          	add    %al,0x75(%rdx,%rax,1)
    1b6f:	01 00                	add    %eax,(%rax)
    1b71:	00 1b                	add    %bl,(%rbx)
    1b73:	95                   	xchg   %eax,%ebp
    1b74:	00 45 02             	add    %al,0x2(%rbp)
    1b77:	41 0f 00 00          	sldt   (%r8)
    1b7b:	1b 9a 00 46 02 d1    	sbb    -0x2efdba00(%rdx),%ebx
    1b81:	01 00                	add    %eax,(%rax)
    1b83:	00 1b                	add    %bl,(%rbx)
    result.server_id =
    1b85:	92                   	xchg   %eax,%edx
    1b86:	00 47 02             	add    %al,0x2(%rdi)
    1b89:	7b 0e                	jnp    1b99 <balancer_ingress+0x1b99>
    return result;
    1b8b:	00 00                	add    %al,(%rax)
    1b8d:	26 47 01 00          	es rex.RXB add %r8d,(%r8)
  } else if (connIdVersion == QUIC_CONNID_VERSION_V2) {
    1b91:	49 02 a2 00 00 00 26 	rex.WB add 0x26000000(%r10),%spl
    1b98:	48 01 00             	add    %rax,(%rax)
    1b9b:	4a 02 75 01          	rex.WX add 0x1(%rbp),%sil
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1b9f:	00 00                	add    %al,(%rax)
    1ba1:	26 49 01 00          	es add %rax,(%r8)
    1ba5:	4f 02 7b 0e          	rex.WRXB add 0xe(%r11),%r15b
    1ba9:	00 00                	add    %al,(%rax)
    1bab:	26 4a 01 00          	es rex.WX add %rax,(%rax)
    1baf:	55                   	push   %rbp
    1bb0:	02 7b 0e             	add    0xe(%rbx),%bh
    1bb3:	00 00                	add    %al,(%rax)
    1bb5:	26 4b 01 00          	es rex.WXB add %rax,(%r8)
    1bb9:	56                   	push   %rsi
    1bba:	02 7b 0e             	add    0xe(%rbx),%bh
    1bbd:	00 00                	add    %al,(%rax)
    1bbf:	26 4c 01 00          	es add %r8,(%rax)
    1bc3:	57                   	push   %rdi
    1bc4:	02 7b 0e             	add    0xe(%rbx),%bh
    1bc7:	00 00                	add    %al,(%rax)
    1bc9:	1d 1c a5 00 4b       	sbb    $0x4b00a51c,%eax
    return result;
    1bce:	02 de                	add    %dh,%bl
  } else if (connIdVersion == QUIC_CONNID_VERSION_V3) {
    1bd0:	08 00                	or     %al,(%rax)
    1bd2:	00 1d 1c 07 00 4b    	add    %bl,0x4b00071c(%rip)        # 4b0022f4 <bpf_xdp_adjust_head+0x4affa354>
    1bd8:	02 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ch
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1bde:	1c a6                	sbb    $0xa6,%al
    1be0:	00 4b 02             	add    %cl,0x2(%rbx)
    1be3:	a2 00 00 00 1c 14 00 	movabs %al,0x24b00141c000000
    1bea:	4b 02 
    1bec:	ae                   	scas   %es:(%rdi),%al
    1bed:	0e                   	(bad)
    1bee:	00 00                	add    %al,(%rax)
    1bf0:	1c a7                	sbb    $0xa7,%al
    1bf2:	00 4b 02             	add    %cl,0x2(%rbx)
    1bf5:	ae                   	scas   %es:(%rdi),%al
    1bf6:	0e                   	(bad)
    1bf7:	00 00                	add    %al,(%rax)
    1bf9:	00 00                	add    %al,(%rax)
    1bfb:	00 1d 1c a8 00 59    	add    %bl,0x5900a81c(%rip)        # 5900c41d <bpf_xdp_adjust_head+0x5900447d>
    1c01:	02 a2 00 00 00 26    	add    0x26000000(%rdx),%ah
    1c07:	4d 01 00             	add    %r8,(%r8)
    1c0a:	5a                   	pop    %rdx
    1c0b:	02 9d 00 00 00 1d    	add    0x1d000000(%rbp),%bl
    1c11:	1c a5                	sbb    $0xa5,%al
    1c13:	00 5a 02             	add    %bl,0x2(%rdx)
    result.server_id =
    1c16:	de 08                	fimuls (%rax)
    1c18:	00 00                	add    %al,(%rax)
    1c1a:	1d 1c 07 00 5a       	sbb    $0x5a00071c,%eax
}
    1c1f:	02 a9 0e 00 00 1d    	add    0x1d00000e(%rcx),%ch
    1c25:	1c a6                	sbb    $0xa6,%al
    1c27:	00 5a 02             	add    %bl,0x2(%rdx)
    1c2a:	a2 00 00 00 1c 14 00 	movabs %al,0x25a00141c000000
    1c31:	5a 02 
      if (qpr.server_id > 0) {
    1c33:	ae                   	scas   %es:(%rdi),%al
    1c34:	0e                   	(bad)
    1c35:	00 00                	add    %al,(%rax)
    1c37:	1c a7                	sbb    $0xa7,%al
        increment_quic_cid_version_stats(quic_packets_stats, qpr.cid_version);
    1c39:	00 5a 02             	add    %bl,0x2(%rdx)
    1c3c:	ae                   	scas   %es:(%rdi),%al
    1c3d:	0e                   	(bad)
    1c3e:	00 00                	add    %al,(%rax)
    1c40:	00 00                	add    %al,(%rax)
    1c42:	00 00                	add    %al,(%rax)
    1c44:	00 28                	add    %ch,(%rax)
    1c46:	4e 01 0d 2a 7b 0e 00 	rex.WRX add %r9,0xe7b2a(%rip)        # e9777 <bpf_xdp_adjust_head+0xe17d7>
    1c4d:	00 24 86             	add    %ah,(%rsi,%rax,4)
    1c50:	0d 2b 11 0e 00       	or     $0xe112b,%eax
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1c55:	00 24 94             	add    %ah,(%rsp,%rdx,4)
    1c58:	0d 2c ae 00 00       	or     $0xae2c,%eax
    1c5d:	00 24 92             	add    %ah,(%rdx,%rdx,4)
    quic_packets_stats->cid_v1 += 1;
    1c60:	0d 2d 7b 0e 00       	or     $0xe7b2d,%eax
    1c65:	00 24 95 0d 2e 41 0f 	add    %ah,0xf412e0d(,%rdx,4)
    1c6c:	00 00                	add    %al,(%rax)
    1c6e:	24 25                	and    $0x25,%al
    1c70:	0d 2f 29 04 00       	or     $0x4292f,%eax
  } else if (cid_version == QUIC_CONNID_VERSION_V2) {
    1c75:	00 24 a0             	add    %ah,(%rax,%riz,4)
    1c78:	0d 30 a2 00 00       	or     $0xa230,%eax
    1c7d:	00 25 87 0d 31 de    	add    %ah,-0x21cef279(%rip)        # ffffffffde312a0a <server_id_map+0x36feea096a0a>
    quic_packets_stats->cid_v2 += 1;
    1c83:	08 00                	or     %al,(%rax)
    1c85:	00 25 88 0d 32 de    	add    %ah,-0x21cdf278(%rip)        # ffffffffde322a13 <server_id_map+0x36feea0a6a13>
    1c8b:	08 00                	or     %al,(%rax)
    1c8d:	00 25 c3 0d 33 09    	add    %ah,0x9330dc3(%rip)        # 9332a56 <bpf_xdp_adjust_head+0x932aab6>
  } else if (cid_version == QUIC_CONNID_VERSION_V3) {
    1c93:	10 00                	adc    %al,(%rax)
    1c95:	00 29                	add    %ch,(%rcx)
    1c97:	4f 01 0d 34 45 13 00 	rex.WRXB add %r9,0x134534(%rip)        # 1361d2 <bpf_xdp_adjust_head+0x12e232>
    1c9e:	00 29                	add    %ch,(%rcx)
    1ca0:	50                   	push   %rax
    quic_packets_stats->cid_v3 += 1;
    1ca1:	01 0d 35 45 13 00    	add    %ecx,0x134535(%rip)        # 1361dc <bpf_xdp_adjust_head+0x12e23c>
    1ca7:	00 25 c6 0d 36 c5    	add    %ah,-0x3ac9f23a(%rip)        # ffffffffc5362a73 <server_id_map+0x36fed10e6a73>
    1cad:	01 00                	add    %eax,(%rax)
    1caf:	00 25 bf 0d 37 c1    	add    %ah,-0x3ec8f241(%rip)        # ffffffffc1372a74 <server_id_map+0x36fecd0f6a74>
  } else {
    1cb5:	1c 00                	sbb    $0x0,%al
    quic_packets_stats->cid_v0 += 1;
    1cb7:	00 25 1d 0d 38 f9    	add    %ah,-0x6c7f2e3(%rip)        # fffffffff93829da <server_id_map+0x36ff051069da>
    1cbd:	00 00                	add    %al,(%rax)
    1cbf:	00 00                	add    %al,(%rax)
    1cc1:	03 a2 00 00 00 04    	add    0x4000000(%rdx),%esp
    1cc7:	47 00 00             	rex.RXB add %r8b,(%r8)
    1cca:	00 04 00             	add    %al,(%rax,%rax,1)
        __u32 key = qpr.server_id;
    1ccd:	2a 51 01             	sub    0x1(%rcx),%dl
    1cd0:	0e                   	(bad)
    1cd1:	21 24 1a             	and    %esp,(%rdx,%rbx,1)
    1cd4:	0e                   	(bad)
    1cd5:	21 c5                	and    %eax,%ebp
    1cd7:	01 00                	add    %eax,(%rax)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1cd9:	00 24 23             	add    %ah,(%rbx,%riz,1)
    1cdc:	0e                   	(bad)
    1cdd:	21 b1 01 00 00 24    	and    %esi,0x24000001(%rcx)
    1ce3:	bf 0e 21 9d 00       	mov    $0x9d210e,%edi
    1ce8:	00 00                	add    %al,(%rax)
    1cea:	00 2a                	add    %ch,(%rdx)
    1cec:	52                   	push   %rdx
    1ced:	01 0e                	add    %ecx,(%rsi)
    1cef:	4c 24 c3             	rex.WR and $0xc3,%al
    1cf2:	0e                   	(bad)
    1cf3:	4d 09 10             	or     %r10,(%r8)
    1cf6:	00 00                	add    %al,(%rax)
    1cf8:	2b 53 01             	sub    0x1(%rbx),%edx
    1cfb:	0e                   	(bad)
    1cfc:	4e f9                	rex.WRX stc
    1cfe:	00 00                	add    %al,(%rax)
    1d00:	00 24 bf             	add    %ah,(%rdi,%rdi,4)
    1d03:	0e                   	(bad)
    1d04:	4f 9d                	rex.WRXB popf
    1d06:	00 00                	add    %al,(%rax)
    1d08:	00 24 c0             	add    %ah,(%rax,%rax,8)
    1d0b:	0e                   	(bad)
    1d0c:	50                   	push   %rax
    1d0d:	9d                   	popf
    1d0e:	00 00                	add    %al,(%rax)
    1d10:	00 24 c6             	add    %ah,(%rsi,%rax,8)
    1d13:	0e                   	(bad)
    1d14:	51                   	push   %rcx
    1d15:	c5 01 00             	(bad)
    1d18:	00 24 1d 0e 52 f9 00 	add    %ah,0xf9520e(,%rbx,1)
    1d1f:	00 00                	add    %al,(%rax)
    1d21:	00 28                	add    %ch,(%rax)
    1d23:	54                   	push   %rsp
    1d24:	01 0d 58 7b 0e 00    	add    %ecx,0xe7b58(%rip)        # e9882 <bpf_xdp_adjust_head+0xe18e2>
    1d2a:	00 24 86             	add    %ah,(%rsi,%rax,4)
    1d2d:	0d 59 11 0e 00       	or     $0xe1159,%eax
    1d32:	00 24 94             	add    %ah,(%rsp,%rdx,4)
    1d35:	0d 5a ae 00 00       	or     $0xae5a,%eax
    1d3a:	00 24 95 0d 5b 41 0f 	add    %ah,0xf415b0d(,%rdx,4)
    1d41:	00 00                	add    %al,(%rax)
    1d43:	24 25                	and    $0x25,%al
    1d45:	0d 5c 29 04 00       	or     $0x4295c,%eax
    1d4a:	00 24 a0             	add    %ah,(%rax,%riz,4)
    1d4d:	0d 5d a2 00 00       	or     $0xa25d,%eax
    1d52:	00 25 87 0d 5e de    	add    %ah,-0x21a1f279(%rip)        # ffffffffde5e2adf <server_id_map+0x36feea366adf>
        if (real_pos) {
    1d58:	08 00                	or     %al,(%rax)
    1d5a:	00 25 88 0d 5f de    	add    %ah,-0x21a0f278(%rip)        # ffffffffde5f2ae8 <server_id_map+0x36feea376ae8>
    1d60:	08 00                	or     %al,(%rax)
          key = *real_pos;
    1d62:	00 25 b6 0d 60 4b    	add    %ah,0x4b600db6(%rip)        # 4b602b1e <bpf_xdp_adjust_head+0x4b5fab7e>
    1d68:	0f 00 00             	sldt   (%rax)
    1d6b:	29 4f 01             	sub    %ecx,0x1(%rdi)
    1d6e:	0d 61 45 13 00       	or     $0x134561,%eax
          if (key == 0) {
    1d73:	00 29                	add    %ch,(%rcx)
    1d75:	50                   	push   %rax
    1d76:	01 0d 62 45 13 00    	add    %ecx,0x134562(%rip)        # 1362de <bpf_xdp_adjust_head+0x12e33e>
            quic_packets_stats->cid_invalid_server_id += 1;
    1d7c:	00 29                	add    %ch,(%rcx)
    1d7e:	55                   	push   %rbp
    1d7f:	01 0d 63 a2 00 00    	add    %ecx,0xa263(%rip)        # bfe8 <bpf_xdp_adjust_head+0x4048>
    1d85:	00 29                	add    %ch,(%rcx)
    1d87:	03 01                	add    (%rcx),%eax
    1d89:	0d 64 e1 00 00       	or     $0xe164,%eax
            quic_packets_stats->cid_invalid_server_id_sample = qpr.server_id;
    1d8e:	00 00                	add    %al,(%rax)
    1d90:	28 56 01             	sub    %dl,0x1(%rsi)
    1d93:	0e                   	(bad)
    1d94:	28 a2 00 00 00 24    	sub    %ah,0x24000000(%rdx)
    1d9a:	1a 0e                	sbb    (%rsi),%cl
    1d9c:	29 c5                	sub    %eax,%ebp
    1d9e:	01 00                	add    %eax,(%rax)
            quic_packets_stats->ch_routed += 1;
    1da0:	00 24 23             	add    %ah,(%rbx,%riz,1)
    1da3:	0e                   	(bad)
    1da4:	2a b1 01 00 00 29    	sub    0x29000001(%rcx),%dh
    1daa:	57                   	push   %rdi
    1dab:	01 0e                	add    %ecx,(%rsi)
    1dad:	2b a2 00 00 00 00    	sub    0x0(%rdx),%esp
          } else {
    1db3:	2a 58 01             	sub    0x1(%rax),%bl
            pckt.real_index = key;
    1db6:	0e                   	(bad)
    1db7:	31 24 b6             	xor    %esp,(%rsi,%rsi,4)
    1dba:	0e                   	(bad)
    1dbb:	32 4b 0f             	xor    0xf(%rbx),%cl
    1dbe:	00 00                	add    %al,(%rax)
    1dc0:	24 98                	and    $0x98,%al
            dst = bpf_map_lookup_elem(&reals, &key);
    1dc2:	0e                   	(bad)
    1dc3:	33 f9                	xor    %ecx,%edi
    1dc5:	00 00                	add    %al,(%rax)
    1dc7:	00 24 bf             	add    %ah,(%rdi,%rdi,4)
    1dca:	0e                   	(bad)
    1dcb:	34 a2                	xor    $0xa2,%al
    1dcd:	00 00                	add    %al,(%rax)
    1dcf:	00 24 c0             	add    %ah,(%rax,%rax,8)
    1dd2:	0e                   	(bad)
    1dd3:	35 a2 00 00 00       	xor    $0xa2,%eax
    1dd8:	24 a0                	and    $0xa0,%al
    1dda:	0e                   	(bad)
    1ddb:	36 c5 01 00          	(bad)
    1ddf:	00 24 1d 0e 37 f9 00 	add    %ah,0xf9370e(,%rbx,1)
    1de6:	00 00                	add    %al,(%rax)
    1de8:	29 03                	sub    %eax,(%rbx)
    1dea:	01 0e                	add    %ecx,(%rsi)
    1dec:	38 e1                	cmp    %ah,%cl
    1dee:	00 00                	add    %al,(%rax)
    1df0:	00 00                	add    %al,(%rax)
    1df2:	32 17                	xor    (%rdi),%dl
    1df4:	80 77 00 00          	xorb   $0x0,0x0(%rdi)
    1df8:	01 56 59             	add    %edx,0x59(%rsi)
    1dfb:	01 00                	add    %eax,(%rax)
    1dfd:	31 04 99             	xor    %eax,(%rcx,%rbx,4)
    1e00:	00 00                	add    %al,(%rax)
    1e02:	00 33                	add    %dh,(%rbx)
    1e04:	03 91 f8 50 5e 01    	add    0x15e50f8(%rcx),%edx
    1e0a:	00 31                	add    %dh,(%rcx)
    1e0c:	04 11                	add    $0x11,%al
    1e0e:	0e                   	(bad)
    1e0f:	00 00                	add    %al,(%rax)
    1e11:	34 03                	xor    $0x3,%al
    1e13:	91                   	xchg   %eax,%ecx
    1e14:	f0 50                	lock push %rax
    1e16:	87 00                	xchg   %eax,(%rax)
    1e18:	32 04 de             	xor    (%rsi,%rbx,8),%al
    1e1b:	08 00                	or     %al,(%rax)
    1e1d:	00 34 03             	add    %dh,(%rbx,%rax,1)
    1e20:	91                   	xchg   %eax,%ecx
    1e21:	e8 50 88 00 33       	call   3300a676 <bpf_xdp_adjust_head+0x330026d6>
    1e26:	04 de                	add    $0xde,%al
    1e28:	08 00                	or     %al,(%rax)
    1e2a:	00 34 03             	add    %dh,(%rbx,%rax,1)
    1e2d:	91                   	xchg   %eax,%ecx
    1e2e:	e0 50                	loopne 1e80 <balancer_ingress+0x1e80>
    1e30:	f2 00 34 04          	repnz add %dh,(%rsp,%rax,1)
    1e34:	45 13 00             	adc    (%r8),%r8d
    1e37:	00 35 03 91 dc 50    	add    %dh,0x50dc9103(%rip)        # 50dcaf40 <bpf_xdp_adjust_head+0x50dc2fa0>
            if (!dst) {
    1e3d:	5f                   	pop    %rdi
    1e3e:	01 00                	add    %eax,(%rax)
    1e40:	35 04 a2 00 00       	xor    $0xa204,%eax
    1e45:	00 34 03             	add    %dh,(%rbx,%rax,1)
              quic_packets_stats->cid_unknown_real_dropped += 1;
    1e48:	91                   	xchg   %eax,%ecx
    1e49:	d8 50 91             	fcoms  -0x6f(%rax)
    1e4c:	00 36                	add    %dh,(%rsi)
    1e4e:	04 a2                	add    $0xa2,%al
    1e50:	00 00                	add    %al,(%rax)
    1e52:	00 36                	add    %dh,(%rsi)
    1e54:	30 0a                	xor    %cl,(%rdx)
    1e56:	00 00                	add    %al,(%rax)
    1e58:	18 0c 3b             	sbb    %cl,(%rbx,%rdi,1)
              return XDP_DROP;
    1e5b:	00 00                	add    %al,(%rax)
    1e5d:	00 41 04             	add    %al,0x4(%rcx)
    1e60:	0c 37                	or     $0x37,%al
    1e62:	03 91 88 5c 39 0a    	add    0xa395c88(%rcx),%edx
            int res = check_and_update_real_index_in_lru(&pckt, lru_map);
    1e68:	00 00                	add    %al,(%rax)
    1e6a:	37                   	(bad)
    1e6b:	03 91 80 5c 42 0a    	add    0xa425c80(%rcx),%edx
    1e71:	00 00                	add    %al,(%rax)
    1e73:	37                   	(bad)
    1e74:	03 91 ff 5b 4b 0a    	add    0xa4b5bff(%rcx),%edx
    1e7a:	00 00                	add    %al,(%rax)
    1e7c:	38 03                	cmp    %al,(%rbx)
    1e7e:	91                   	xchg   %eax,%ecx
    1e7f:	f0 5b                	lock pop %rbx
    1e81:	54                   	push   %rsp
    1e82:	0a 00                	or     (%rax),%al
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1e84:	00 38                	add    %bh,(%rax)
    1e86:	03 91 e8 5b 5d 0a    	add    0xa5d5be8(%rcx),%edx
    1e8c:	00 00                	add    %al,(%rax)
    1e8e:	38 03                	cmp    %al,(%rbx)
    1e90:	91                   	xchg   %eax,%ecx
    1e91:	e0 5b                	loopne 1eee <balancer_ingress+0x1eee>
    1e93:	66 0a 00             	data16 or (%rax),%al
    1e96:	00 38                	add    %bh,(%rax)
    1e98:	03 91 d8 5b 6f 0a    	add    0xa6f5bd8(%rcx),%edx
    1e9e:	00 00                	add    %al,(%rax)
    1ea0:	38 03                	cmp    %al,(%rbx)
    1ea2:	91                   	xchg   %eax,%ecx
    1ea3:	a8 5b                	test   $0x5b,%al
    1ea5:	78 0a                	js     1eb1 <balancer_ingress+0x1eb1>
    1ea7:	00 00                	add    %al,(%rax)
  if (dst_lru) {
    1ea9:	38 03                	cmp    %al,(%rbx)
    1eab:	91                   	xchg   %eax,%ecx
    1eac:	90                   	nop
    1ead:	5b                   	pop    %rbx
    1eae:	81 0a 00 00 38 03    	orl    $0x3380000,(%rdx)
    if (dst_lru->pos == pckt->real_index) {
    1eb4:	91                   	xchg   %eax,%ecx
    1eb5:	88 5b 8a             	mov    %bl,-0x76(%rbx)
    1eb8:	0a 00                	or     (%rax),%al
    1eba:	00 38                	add    %bh,(%rax)
    1ebc:	03 91 80 5b 93 0a    	add    0xa935b80(%rcx),%edx
    1ec2:	00 00                	add    %al,(%rax)
    1ec4:	38 03                	cmp    %al,(%rbx)
    1ec6:	91                   	xchg   %eax,%ecx
      return DST_MATCH_IN_LRU;
    1ec7:	ff 5a 9c             	lcall  *-0x64(%rdx)
    1eca:	0a 00                	or     (%rax),%al
    1ecc:	00 38                	add    %bh,(%rax)
    1ece:	03 91 fc 5a a5 0a    	add    0xaa55afc(%rcx),%edx
    1ed4:	00 00                	add    %al,(%rax)
      dst_lru->pos = pckt->real_index;
    1ed6:	38 03                	cmp    %al,(%rbx)
    1ed8:	91                   	xchg   %eax,%ecx
    1ed9:	f8                   	clc
    1eda:	5a                   	pop    %rdx
    1edb:	ae                   	scas   %es:(%rdi),%al
    1edc:	0a 00                	or     (%rax),%al
    1ede:	00 38                	add    %bh,(%rax)
    1ee0:	03 91 f4 5a b7 0a    	add    0xab75af4(%rcx),%edx
    1ee6:	00 00                	add    %al,(%rax)
    1ee8:	38 03                	cmp    %al,(%rbx)
      return DST_MISMATCH_IN_LRU;
    1eea:	91                   	xchg   %eax,%ecx
    1eeb:	f0 5a                	lock pop %rdx
    1eed:	c0 0a 00             	rorb   $0x0,(%rdx)
    1ef0:	00 38                	add    %bh,(%rax)
    1ef2:	03 91 ee 5a c9 0a    	add    0xac95aee(%rcx),%edx
    1ef8:	00 00                	add    %al,(%rax)
    1efa:	38 03                	cmp    %al,(%rbx)
    1efc:	91                   	xchg   %eax,%ecx
    1efd:	e0 5a                	loopne 1f59 <balancer_ingress+0x1f59>
    1eff:	d2 0a                	rorb   %cl,(%rdx)
    1f01:	00 00                	add    %al,(%rax)
    1f03:	38 03                	cmp    %al,(%rbx)
    1f05:	91                   	xchg   %eax,%ecx
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1f06:	9c                   	pushf
    1f07:	5a                   	pop    %rdx
    1f08:	db 0a                	fisttpl (%rdx)
    1f0a:	00 00                	add    %al,(%rax)
    1f0c:	38 03                	cmp    %al,(%rbx)
    1f0e:	91                   	xchg   %eax,%ecx
    1f0f:	f4                   	hlt
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1f10:	59                   	pop    %rcx
    1f11:	e4 0a                	in     $0xa,%al
    1f13:	00 00                	add    %al,(%rax)
    1f15:	38 03                	cmp    %al,(%rbx)
    1f17:	91                   	xchg   %eax,%ecx
    1f18:	e8 59 ed 0a 00       	call   b0c76 <bpf_xdp_adjust_head+0xa8cd6>
    1f1d:	00 36                	add    %dh,(%rsi)
    1f1f:	d4                   	(bad)
    1f20:	0e                   	(bad)
    1f21:	00 00                	add    %al,(%rax)
    1f23:	19 d4                	sbb    %edx,%esp
    1f25:	02 00                	add    (%rax),%al
    1f27:	00 00                	add    %al,(%rax)
    1f29:	ba 02 0c 37 03       	mov    $0x3370c02,%edx
    1f2e:	91                   	xchg   %eax,%ecx
    1f2f:	e8 5c dd 0e 00       	call   efc90 <bpf_xdp_adjust_head+0xe7cf0>
    1f34:	00 37                	add    %dh,(%rdi)
    1f36:	03 91 e0 5c e6 0e    	add    0xee65ce0(%rcx),%edx
    1f3c:	00 00                	add    %al,(%rax)
    1f3e:	37                   	(bad)
    1f3f:	03 91 d8 5c ef 0e    	add    0xeef5cd8(%rcx),%edx
    1f45:	00 00                	add    %al,(%rax)
    1f47:	37                   	(bad)
    1f48:	03 91 d0 5c f8 0e    	add    0xef85cd0(%rcx),%edx
    1f4e:	00 00                	add    %al,(%rax)
    1f50:	37                   	(bad)
    1f51:	03 91 c8 5c 01 0f    	add    0xf015cc8(%rcx),%edx
    1f57:	00 00                	add    %al,(%rax)
    1f59:	37                   	(bad)
    1f5a:	03 91 c0 5c 0a 0f    	add    0xf0a5cc0(%rcx),%edx
    1f60:	00 00                	add    %al,(%rax)
    1f62:	37                   	(bad)
    1f63:	03 91 b8 5c 13 0f    	add    0xf135cb8(%rcx),%edx
    1f69:	00 00                	add    %al,(%rax)
    1f6b:	37                   	(bad)
    1f6c:	03 91 b7 5c 1c 0f    	add    0xf1c5cb7(%rcx),%edx
    1f72:	00 00                	add    %al,(%rax)
    1f74:	38 03                	cmp    %al,(%rbx)
    1f76:	91                   	xchg   %eax,%ecx
    1f77:	a8 5c                	test   $0x5c,%al
    1f79:	25 0f 00 00 38       	and    $0x3800000f,%eax
    1f7e:	03 91 a0 5c 2e 0f    	add    0xf2e5ca0(%rcx),%edx
  struct lb_stats* conn_rate_stats =
    1f84:	00 00                	add    %al,(%rax)
    1f86:	38 03                	cmp    %al,(%rbx)
    1f88:	91                   	xchg   %eax,%ecx
    1f89:	98                   	cwtl
    1f8a:	5c                   	pop    %rsp
  if (!conn_rate_stats) {
    1f8b:	37                   	(bad)
    1f8c:	0f 00 00             	sldt   (%rax)
    1f8f:	00 36                	add    %dh,(%rsi)
    1f91:	ef                   	out    %eax,(%dx)
    1f92:	10 00                	adc    %al,(%rax)
    1f94:	00 1a                	add    %bl,(%rdx)
    return true;
    1f96:	9d                   	popf
    1f97:	09 00                	or     %eax,(%rax)
    1f99:	00 00                	add    %al,(%rax)
    1f9b:	bf 02 0c 37 03       	mov    $0x3370c02,%edi
    1fa0:	91                   	xchg   %eax,%ecx
  *cur_time = bpf_ktime_get_ns();
    1fa1:	f0 5d                	lock pop %rbp
    1fa3:	f8                   	clc
    1fa4:	10 00                	adc    %al,(%rax)
    1fa6:	00 37                	add    %dh,(%rdi)
    1fa8:	03 91 e8 5d 01 11    	add    0x11015de8(%rcx),%edx
    1fae:	00 00                	add    %al,(%rax)
    1fb0:	37                   	(bad)
    1fb1:	03 91 e0 5d 0a 11    	add    0x110a5de0(%rcx),%edx
    1fb7:	00 00                	add    %al,(%rax)
    1fb9:	37                   	(bad)
    1fba:	03 91 d8 5d 13 11    	add    0x11135dd8(%rcx),%edx
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1fc0:	00 00                	add    %al,(%rax)
    1fc2:	37                   	(bad)
    1fc3:	03 91 d7 5d 1c 11    	add    0x111c5dd7(%rcx),%edx
    1fc9:	00 00                	add    %al,(%rax)
    1fcb:	36 26 11 00          	ss es adc %eax,(%rax)
    1fcf:	00 1b                	add    %bl,(%rbx)
    1fd1:	ec                   	in     (%dx),%al
    1fd2:	03 00                	add    (%rax),%eax
    1fd4:	00 0b                	add    %cl,(%rbx)
    1fd6:	5a                   	pop    %rdx
    1fd7:	01 0c 37             	add    %ecx,(%rdi,%rsi,1)
    conn_rate_stats->v1 = 1;
    1fda:	03 91 b8 72 2e 11    	add    0x112e72b8(%rcx),%edx
    1fe0:	00 00                	add    %al,(%rax)
    1fe2:	37                   	(bad)
    1fe3:	03 91 b0 72 36 11    	add    0x113672b0(%rcx),%edx
    conn_rate_stats->v2 = *cur_time;
    1fe9:	00 00                	add    %al,(%rax)
    1feb:	37                   	(bad)
    1fec:	03 91 a8 72 3e 11    	add    0x113e72a8(%rcx),%edx
    1ff2:	00 00                	add    %al,(%rax)
    1ff4:	37                   	(bad)
    1ff5:	03 91 a0 72 46 11    	add    0x114672a0(%rcx),%edx
    1ffb:	00 00                	add    %al,(%rax)
  } else {
    1ffd:	38 03                	cmp    %al,(%rbx)
    conn_rate_stats->v1 += 1;
    1fff:	91                   	xchg   %eax,%ecx
    2000:	98                   	cwtl
    2001:	72 4e                	jb     2051 <balancer_ingress+0x2051>
    2003:	11 00                	adc    %eax,(%rax)
    2005:	00 38                	add    %bh,(%rax)
    2007:	03 91 90 72 56 11    	add    0x11567290(%rcx),%edx
    200d:	00 00                	add    %al,(%rax)
    200f:	39 e3                	cmp    %esp,%ebx
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2011:	12 00                	adc    (%rax),%al
    2013:	00 1c 8d 01 00 00 0b 	add    %bl,0xb000001(,%rcx,4)
    201a:	f0 0c 37             	lock or $0x37,%al
    201d:	03 91 c8 74 eb 12    	add    0x12eb74c8(%rcx),%edx
      return true;
    2023:	00 00                	add    %al,(%rax)
    2025:	37                   	(bad)
    2026:	03 91 c0 74 f3 12    	add    0x12f374c0(%rcx),%edx
  return false;
    202c:	00 00                	add    %al,(%rax)
    202e:	38 03                	cmp    %al,(%rbx)
    2030:	91                   	xchg   %eax,%ecx
    2031:	b8 74 fb 12 00       	mov    $0x12fb74,%eax
  if (is_under_flood(&cur_time)) {
    2036:	00 38                	add    %bh,(%rax)
    2038:	03 91 b0 74 03 13    	add    0x130374b0(%rcx),%edx
    return DST_NOT_FOUND_IN_LRU;
    203e:	00 00                	add    %al,(%rax)
    2040:	38 03                	cmp    %al,(%rbx)
    2042:	91                   	xchg   %eax,%ecx
    2043:	a0 74 0b 13 00 00 38 	movabs 0x9103380000130b74,%al
    204a:	03 91 
  struct real_pos_lru new_dst_lru = {};
    204c:	98                   	cwtl
    204d:	74 13                	je     2062 <balancer_ingress+0x2062>
    204f:	13 00                	adc    (%rax),%eax
    2051:	00 39                	add    %bh,(%rcx)
    2053:	1c 13                	sbb    $0x13,%al
    2055:	00 00                	add    %al,(%rax)
    2057:	1d 5e 00 00 00       	sbb    $0x5e,%eax
    205c:	0b 76 0a             	or     0xa(%rsi),%esi
  new_dst_lru.pos = pckt->real_index;
    205f:	37                   	(bad)
    2060:	03 91 d0 75 24 13    	add    0x132475d0(%rcx),%edx
    2066:	00 00                	add    %al,(%rax)
    2068:	37                   	(bad)
    2069:	03 91 c8 75 2c 13    	add    0x132c75c8(%rcx),%edx
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    206f:	00 00                	add    %al,(%rax)
    2071:	38 03                	cmp    %al,(%rbx)
    2073:	91                   	xchg   %eax,%ecx
    2074:	c0 75 34 13          	shlb   $0x13,0x34(%rbp)
    2078:	00 00                	add    %al,(%rax)
    207a:	38 03                	cmp    %al,(%rbx)
    207c:	91                   	xchg   %eax,%ecx
    207d:	ba 75 3c 13 00       	mov    $0x133c75,%edx
    2082:	00 00                	add    %al,(%rax)
    2084:	00 3a                	add    %bh,(%rdx)
    2086:	1e                   	(bad)
    2087:	ee                   	out    %al,(%dx)
    2088:	00 00                	add    %al,(%rax)
    208a:	00 38                	add    %bh,(%rax)
    208c:	03 91 8c 72 5f 11    	add    0x115f728c(%rcx),%edx
    2092:	00 00                	add    %al,(%rax)
    2094:	38 03                	cmp    %al,(%rbx)
  return DST_NOT_FOUND_IN_LRU;
    2096:	91                   	xchg   %eax,%ecx
    2097:	80 72 67 11          	xorb   $0x11,0x67(%rdx)
    209b:	00 00                	add    %al,(%rax)
    209d:	38 03                	cmp    %al,(%rbx)
}
    209f:	91                   	xchg   %eax,%ecx
    20a0:	dc 71 6f             	fdivl  0x6f(%rcx)
    20a3:	11 00                	adc    %eax,(%rax)
            int res = check_and_update_real_index_in_lru(&pckt, lru_map);
    20a5:	00 3a                	add    %bh,(%rdx)
    20a7:	1f                   	(bad)
    20a8:	74 00                	je     20aa <balancer_ingress+0x20aa>
    20aa:	00 00                	add    %al,(%rax)
            if (res == DST_MATCH_IN_LRU) {
    20ac:	38 03                	cmp    %al,(%rbx)
    20ae:	91                   	xchg   %eax,%ecx
    20af:	f8                   	clc
    20b0:	71 78                	jno    212a <balancer_ingress+0x212a>
    20b2:	11 00                	adc    %eax,(%rax)
              quic_packets_stats->dst_match_in_lru += 1;
    20b4:	00 3b                	add    %bh,(%rbx)
    20b6:	00 38                	add    %bh,(%rax)
    20b8:	03 91 f4 71 81 11    	add    0x118171f4(%rcx),%edx
    20be:	00 00                	add    %al,(%rax)
    20c0:	3a 20                	cmp    (%rax),%ah
    20c2:	4a 00 00             	rex.WX add %al,(%rax)
    20c5:	00 38                	add    %bh,(%rax)
            } else if (res == DST_MISMATCH_IN_LRU) {
    20c7:	03 91 f0 71 8a 11    	add    0x118a71f0(%rcx),%edx
    20cd:	00 00                	add    %al,(%rax)
    20cf:	38 03                	cmp    %al,(%rbx)
    20d1:	91                   	xchg   %eax,%ecx
    20d2:	ec                   	in     (%dx),%al
    20d3:	71 92                	jno    2067 <balancer_ingress+0x2067>
    20d5:	11 00                	adc    %eax,(%rax)
    20d7:	00 38                	add    %bh,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    20d9:	03 91 e8 71 9a 11    	add    0x119a71e8(%rcx),%edx
    20df:	00 00                	add    %al,(%rax)
    20e1:	00 00                	add    %al,(%rax)
    20e3:	00 00                	add    %al,(%rax)
    20e5:	00 36                	add    %dh,(%rsi)
    20e7:	77 13                	ja     20fc <balancer_ingress+0x20fc>
    20e9:	00 00                	add    %al,(%rax)
    20eb:	21 fe                	and    %edi,%esi
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    20ed:	04 00                	add    $0x0,%al
    20ef:	00 0b                	add    %cl,(%rbx)
    20f1:	5c                   	pop    %rsp
    20f2:	01 0c 37             	add    %ecx,(%rdi,%rsi,1)
    20f5:	03 91 88 74 80 13    	add    0x13807488(%rcx),%edx
    20fb:	00 00                	add    %al,(%rax)
    20fd:	37                   	(bad)
    20fe:	03 91 80 74 89 13    	add    0x13897480(%rcx),%edx
    2104:	00 00                	add    %al,(%rax)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2106:	37                   	(bad)
    2107:	03 91 f8 73 92 13    	add    0x139273f8(%rcx),%edx
    210d:	00 00                	add    %al,(%rax)
    210f:	37                   	(bad)
    2110:	03 91 f0 73 9b 13    	add    0x139b73f0(%rcx),%edx
    2116:	00 00                	add    %al,(%rax)
    2118:	38 03                	cmp    %al,(%rbx)
    211a:	91                   	xchg   %eax,%ecx
    211b:	e8 73 a4 13 00       	call   13c593 <bpf_xdp_adjust_head+0x1345f3>
    2120:	00 38                	add    %bh,(%rax)
    2122:	03 91 e0 73 ad 13    	add    0x13ad73e0(%rcx),%edx
    2128:	00 00                	add    %al,(%rax)
    212a:	36 8f                	ss (bad)
    212c:	14 00                	adc    $0x0,%al
    212e:	00 22                	add    %ah,(%rdx)
    2130:	9b                   	fwait
    2131:	02 00                	add    (%rax),%al
    2133:	00 0b                	add    %cl,(%rbx)
    2135:	1f                   	(bad)
    2136:	01 0c 37             	add    %ecx,(%rdi,%rsi,1)
    2139:	03 91 88 76 98 14    	add    0x14987688(%rcx),%edx
    213f:	00 00                	add    %al,(%rax)
    2141:	37                   	(bad)
    2142:	03 91 80 76 a0 14    	add    0x14a07680(%rcx),%edx
    2148:	00 00                	add    %al,(%rax)
    214a:	38 03                	cmp    %al,(%rbx)
    214c:	91                   	xchg   %eax,%ecx
    214d:	f8                   	clc
    214e:	75 a8                	jne    20f8 <balancer_ingress+0x20f8>
    2150:	14 00                	adc    $0x0,%al
    2152:	00 38                	add    %bh,(%rax)
    2154:	03 91 f0 75 b0 14    	add    0x14b075f0(%rcx),%edx
    215a:	00 00                	add    %al,(%rax)
    215c:	38 03                	cmp    %al,(%rbx)
    215e:	91                   	xchg   %eax,%ecx
    215f:	ec                   	in     (%dx),%al
    2160:	75 b8                	jne    211a <balancer_ingress+0x211a>
    2162:	14 00                	adc    $0x0,%al
    2164:	00 38                	add    %bh,(%rax)
    2166:	03 91 e0 75 c0 14    	add    0x14c075e0(%rcx),%edx
    216c:	00 00                	add    %al,(%rax)
    216e:	38 03                	cmp    %al,(%rbx)
    2170:	91                   	xchg   %eax,%ecx
    2171:	d8 75 c9             	fdivs  -0x37(%rbp)
    2174:	14 00                	adc    $0x0,%al
    2176:	00 39                	add    %bh,(%rcx)
    2178:	d2 14 00             	rclb   %cl,(%rax,%rax,1)
  struct lb_stats* per_vip_stats =
    217b:	00 23                	add    %ah,(%rbx)
    217d:	df 00                	filds  (%rax)
    217f:	00 00                	add    %al,(%rax)
  if (!per_vip_stats) {
    2181:	0b 59 03             	or     0x3(%rcx),%ebx
    2184:	37                   	(bad)
    2185:	03 91 d0 77 d7 14    	add    0x14d777d0(%rcx),%edx
    return;
    218b:	00 00                	add    %al,(%rax)
  if (newConn) {
    218d:	37                   	(bad)
    218e:	03 91 c8 77 df 14    	add    0x14df77c8(%rcx),%edx
    2194:	00 00                	add    %al,(%rax)
    per_vip_stats->v1 += 1;
    2196:	38 03                	cmp    %al,(%rbx)
    2198:	91                   	xchg   %eax,%ecx
    2199:	c0 77 e8 14          	shlb   $0x14,-0x18(%rdi)
    219d:	00 00                	add    %al,(%rax)
    219f:	3a 24 4f             	cmp    (%rdi,%rcx,2),%ah
    21a2:	00 00                	add    %al,(%rax)
    21a4:	00 38                	add    %bh,(%rax)
    21a6:	03 91 bc 77 f2 14    	add    0x14f277bc(%rcx),%edx
  if (misMatchInLRU) {
    21ac:	00 00                	add    %al,(%rax)
    21ae:	00 39                	add    %bh,(%rcx)
    per_vip_stats->v2 += 1;
    21b0:	fd                   	std
    21b1:	14 00                	adc    $0x0,%al
    21b3:	00 25 62 00 00 00    	add    %ah,0x62(%rip)        # 221b <balancer_ingress+0x221b>
    21b9:	0c 3a                	or     $0x3a,%al
    21bb:	0b 37                	or     (%rdi),%esi
    21bd:	03 91 e0 77 06 15    	add    0x150677e0(%rcx),%edx
            } else {
    21c3:	00 00                	add    %al,(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    21c5:	38 03                	cmp    %al,(%rbx)
    21c7:	91                   	xchg   %eax,%ecx
    21c8:	dc 77 0f             	fdivl  0xf(%rdi)
    21cb:	15 00 00 00 00       	adc    $0x0,%eax
    21d0:	39 1c 13             	cmp    %ebx,(%rbx,%rdx,1)
    21d3:	00 00                	add    %al,(%rax)
    21d5:	26 5e                	es pop %rsi
    21d7:	00 00                	add    %al,(%rax)
    21d9:	00 0b                	add    %cl,(%rbx)
            quic_packets_stats->cid_routed += 1;
    21db:	5b                   	pop    %rbx
    21dc:	0a 37                	or     (%rdi),%dh
    21de:	03 91 b0 76 24 13    	add    0x132476b0(%rcx),%edx
    21e4:	00 00                	add    %al,(%rax)
    21e6:	37                   	(bad)
    21e7:	03 91 a8 76 2c 13    	add    0x132c76a8(%rcx),%edx
        } else {
    21ed:	00 00                	add    %al,(%rax)
          quic_packets_stats->cid_invalid_server_id += 1;
    21ef:	38 03                	cmp    %al,(%rbx)
    21f1:	91                   	xchg   %eax,%ecx
    21f2:	a0 76 34 13 00 00 38 	movabs 0x9103380000133476,%al
    21f9:	03 91 
    21fb:	9a                   	(bad)
    21fc:	76 3c                	jbe    223a <balancer_ingress+0x223a>
    21fe:	13 00                	adc    (%rax),%eax
    2200:	00 00                	add    %al,(%rax)
          quic_packets_stats->cid_invalid_server_id_sample = qpr.server_id;
    2202:	00 3a                	add    %bh,(%rdx)
    2204:	27                   	(bad)
    2205:	f7 00 00 00 38 03    	testl  $0x3380000,(%rax)
    220b:	91                   	xchg   %eax,%ecx
    220c:	dc 73 b7             	fdivl  -0x49(%rbx)
    220f:	13 00                	adc    (%rax),%eax
    2211:	00 38                	add    %bh,(%rax)
    2213:	03 91 d0 73 c0 13    	add    0x13c073d0(%rcx),%edx
          quic_packets_stats->ch_routed += 1;
    2219:	00 00                	add    %al,(%rax)
    221b:	38 03                	cmp    %al,(%rbx)
    221d:	91                   	xchg   %eax,%ecx
    221e:	ae                   	scas   %es:(%rdi),%al
    221f:	73 ca                	jae    21eb <balancer_ingress+0x21eb>
    2221:	13 00                	adc    (%rax),%eax
    2223:	00 3a                	add    %bh,(%rdx)
      } else if (!qpr.is_initial) {
    2225:	28 74 00 00          	sub    %dh,0x0(%rax,%rax,1)
    2229:	00 38                	add    %bh,(%rax)
    222b:	03 91 c8 73 d4 13    	add    0x13d473c8(%rcx),%edx
    2231:	00 00                	add    %al,(%rax)
        quic_packets_stats->ch_routed += 1;
    2233:	3b 01                	cmp    (%rcx),%eax
    2235:	38 03                	cmp    %al,(%rbx)
    2237:	91                   	xchg   %eax,%ecx
    2238:	c4                   	(bad)
    2239:	73 de                	jae    2219 <balancer_ingress+0x2219>
    223b:	13 00                	adc    (%rax),%eax
    223d:	00 3a                	add    %bh,(%rdx)
    223f:	29 4a 00             	sub    %ecx,0x0(%rdx)
    2242:	00 00                	add    %al,(%rax)
      } else {
    2244:	38 03                	cmp    %al,(%rbx)
    2246:	91                   	xchg   %eax,%ecx
    2247:	c0 73 e8 13          	shlb   $0x13,-0x18(%rbx)
        quic_packets_stats->cid_initial += 1;
    224b:	00 00                	add    %al,(%rax)
    224d:	38 03                	cmp    %al,(%rbx)
    224f:	91                   	xchg   %eax,%ecx
    2250:	bc 73 f1 13 00       	mov    $0x13f173,%esp
    2255:	00 38                	add    %bh,(%rax)
    2257:	03 91 b8 73 fa 13    	add    0x13fa73b8(%rcx),%edx
	...
            vip_num, /* new conn */ true, /* mismatch in lru */ false);
    2265:	36 19 15 00 00 2a 85 	ss sbb %edx,-0x7ad60000(%rip)        # ffffffff852a226c <server_id_map+0x36fe9102626c>
    226c:	01 00                	add    %eax,(%rax)
    226e:	00 00                	add    %al,(%rax)
    2270:	f3 02 0a             	repz add (%rdx),%cl
    2273:	37                   	(bad)
    2274:	03 91 d8 5e 22 15    	add    0x15225ed8(%rcx),%edx
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    227a:	00 00                	add    %al,(%rax)
    227c:	37                   	(bad)
    227d:	03 91 d0 5e 2a 15    	add    0x152a5ed0(%rcx),%edx
    2283:	00 00                	add    %al,(%rax)
    2285:	37                   	(bad)
    2286:	03 91 cf 5e 32 15    	add    0x15325ecf(%rcx),%edx
    228c:	00 00                	add    %al,(%rax)
    228e:	37                   	(bad)
    228f:	03 91 c0 5e 3a 15    	add    0x153a5ec0(%rcx),%edx
    2295:	00 00                	add    %al,(%rax)
    2297:	38 03                	cmp    %al,(%rbx)
    2299:	91                   	xchg   %eax,%ecx
    229a:	bf 5e 42 15 00       	mov    $0x15425e,%edi
    229f:	00 38                	add    %bh,(%rax)
    22a1:	03 91 b0 5e 4a 15    	add    0x154a5eb0(%rcx),%edx
    22a7:	00 00                	add    %al,(%rax)
    22a9:	38 03                	cmp    %al,(%rbx)
    22ab:	91                   	xchg   %eax,%ecx
    22ac:	a8 5e                	test   $0x5e,%al
    22ae:	52                   	push   %rdx
    22af:	15 00 00 39 3c       	adc    $0x3c390000,%eax
    22b4:	16                   	(bad)
    22b5:	00 00                	add    %al,(%rax)
    22b7:	2b 79 00             	sub    0x0(%rcx),%edi
    22ba:	00 00                	add    %al,(%rax)
    22bc:	09 7b 0f             	or     %edi,0xf(%rbx)
    22bf:	37                   	(bad)
    22c0:	03 91 d7 78 45 16    	add    0x164578d7(%rcx),%edx
    22c6:	00 00                	add    %al,(%rax)
    22c8:	37                   	(bad)
    22c9:	03 91 d6 78 4d 16    	add    0x164d78d6(%rcx),%edx
    22cf:	00 00                	add    %al,(%rax)
    22d1:	38 03                	cmp    %al,(%rbx)
    22d3:	91                   	xchg   %eax,%ecx
    22d4:	c8 78 55 16          	enter  $0x5578,$0x16
    22d8:	00 00                	add    %al,(%rax)
    22da:	00 00                	add    %al,(%rax)
    22dc:	36 5e                	ss pop %rsi
    22de:	16                   	(bad)
    22df:	00 00                	add    %al,(%rax)
    22e1:	2c 58                	sub    $0x58,%al
    22e3:	01 00                	add    %eax,(%rax)
    22e5:	00 00                	add    %al,(%rax)
    22e7:	f7 02 0a 37 03 91    	testl  $0x9103370a,(%rdx)
  struct lb_stats* per_vip_stats =
    22ed:	d8 5f 67             	fcomps 0x67(%rdi)
    22f0:	16                   	(bad)
  if (!per_vip_stats) {
    22f1:	00 00                	add    %al,(%rax)
    22f3:	37                   	(bad)
    22f4:	03 91 d0 5f 6f 16    	add    0x166f5fd0(%rcx),%edx
    22fa:	00 00                	add    %al,(%rax)
    return;
    22fc:	37                   	(bad)
  if (newConn) {
    22fd:	03 91 cf 5f 77 16    	add    0x16775fcf(%rcx),%edx
    2303:	00 00                	add    %al,(%rax)
    2305:	37                   	(bad)
    per_vip_stats->v1 += 1;
    2306:	03 91 c0 5f 7f 16    	add    0x167f5fc0(%rcx),%edx
    230c:	00 00                	add    %al,(%rax)
    230e:	38 03                	cmp    %al,(%rbx)
    2310:	91                   	xchg   %eax,%ecx
    2311:	bf 5f 87 16 00       	mov    $0x16875f,%edi
    2316:	00 38                	add    %bh,(%rax)
  if (misMatchInLRU) {
    2318:	03 91 b0 5f 8f 16    	add    0x168f5fb0(%rcx),%edx
    231e:	00 00                	add    %al,(%rax)
    per_vip_stats->v2 += 1;
    2320:	38 03                	cmp    %al,(%rbx)
    2322:	91                   	xchg   %eax,%ecx
    2323:	a8 5f                	test   $0x5f,%al
    2325:	97                   	xchg   %eax,%edi
    2326:	16                   	(bad)
    2327:	00 00                	add    %al,(%rax)
    2329:	39 3c 16             	cmp    %edi,(%rsi,%rdx,1)
    232c:	00 00                	add    %al,(%rax)
    232e:	2d 79 00 00 00       	sub    $0x79,%eax
    2333:	09 61 0f             	or     %esp,0xf(%rcx)
    2336:	37                   	(bad)
    2337:	03 91 b7 78 45 16    	add    0x164578b7(%rcx),%edx
  original_sport = pckt.flow.port16[0];
    233d:	00 00                	add    %al,(%rax)
    233f:	37                   	(bad)
    2340:	03 91 b6 78 4d 16    	add    0x164d78b6(%rcx),%edx
    2346:	00 00                	add    %al,(%rax)
    2348:	38 03                	cmp    %al,(%rbx)
  if (!dst) {
    234a:	91                   	xchg   %eax,%ecx
    234b:	a8 78                	test   $0x78,%al
    234d:	55                   	push   %rbp
    234e:	16                   	(bad)
    234f:	00 00                	add    %al,(%rax)
    2351:	00 00                	add    %al,(%rax)
    2353:	3a 2e                	cmp    (%rsi),%ch
    2355:	74 00                	je     2357 <balancer_ingress+0x2357>
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    2357:	00 00                	add    %al,(%rax)
    2359:	38 03                	cmp    %al,(%rbx)
    235b:	91                   	xchg   %eax,%ecx
    235c:	d8 5a f7             	fcomps -0x9(%rdx)
    235f:	0a 00                	or     (%rax),%al
    2361:	00 3b                	add    %bh,(%rbx)
    2363:	02 38                	add    (%rax),%bh
    2365:	03 91 d4 5a 01 0b    	add    0xb015ad4(%rcx),%edx
    236b:	00 00                	add    %al,(%rax)
    236d:	3a 2f                	cmp    (%rdi),%ch
    236f:	4a 00 00             	rex.WX add %al,(%rax)
    2372:	00 38                	add    %bh,(%rax)
    2374:	03 91 d0 5a 0b 0b    	add    0xb0b5ad0(%rcx),%edx
        !(vip_info->flags & F_LRU_BYPASS)) {
    237a:	00 00                	add    %al,(%rax)
    237c:	38 03                	cmp    %al,(%rbx)
    237e:	91                   	xchg   %eax,%ecx
    237f:	cc                   	int3
    2380:	5a                   	pop    %rdx
    2381:	14 0b                	adc    $0xb,%al
    2383:	00 00                	add    %al,(%rax)
    2385:	38 03                	cmp    %al,(%rbx)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    2387:	91                   	xchg   %eax,%ecx
    2388:	c8 5a 1d 0b          	enter  $0x1d5a,$0xb
    238c:	00 00                	add    %al,(%rax)
      connection_table_lookup(&dst, &pckt, lru_map, /*isGlobalLru=*/false);
    238e:	00 00                	add    %al,(%rax)
    2390:	00 3a                	add    %bh,(%rdx)
    2392:	30 74 00 00          	xor    %dh,0x0(%rax,%rax,1)
    2396:	00 38                	add    %bh,(%rax)
    2398:	03 91 b8 5a 2a 0b    	add    0xb2a5ab8(%rcx),%edx
    239e:	00 00                	add    %al,(%rax)
    23a0:	3b 03                	cmp    (%rbx),%eax
    23a2:	38 03                	cmp    %al,(%rbx)
    23a4:	91                   	xchg   %eax,%ecx
    23a5:	b4 5a                	mov    $0x5a,%ah
    23a7:	34 0b                	xor    $0xb,%al
    23a9:	00 00                	add    %al,(%rax)
    23ab:	3a 31                	cmp    (%rcx),%dh
    23ad:	4a 00 00             	rex.WX add %al,(%rax)
    23b0:	00 38                	add    %bh,(%rax)
    23b2:	03 91 b0 5a 3e 0b    	add    0xb3e5ab0(%rcx),%edx
    23b8:	00 00                	add    %al,(%rax)
    23ba:	38 03                	cmp    %al,(%rbx)
    23bc:	91                   	xchg   %eax,%ecx
    23bd:	ac                   	lods   %ds:(%rsi),%al
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    23be:	5a                   	pop    %rdx
    23bf:	47 0b 00             	rex.RXB or (%r8),%r8d
    23c2:	00 38                	add    %bh,(%rax)
    23c4:	03 91 a8 5a 50 0b    	add    0xb505aa8(%rcx),%edx
    23ca:	00 00                	add    %al,(%rax)
    23cc:	00 00                	add    %al,(%rax)
    23ce:	00 3a                	add    %bh,(%rdx)
    23d0:	32 74 00 00          	xor    0x0(%rax,%rax,1),%dh
    23d4:	00 38                	add    %bh,(%rax)
    23d6:	03 91 90 5a 5d 0b    	add    0xb5d5a90(%rcx),%edx
    23dc:	00 00                	add    %al,(%rax)
    23de:	3b 04 38             	cmp    (%rax,%rdi,1),%eax
    23e1:	03 91 8c 5a 67 0b    	add    0xb675a8c(%rcx),%edx
  if (!dst_lru) {
    23e7:	00 00                	add    %al,(%rax)
    23e9:	3a 33                	cmp    (%rbx),%dh
    23eb:	4a 00 00             	rex.WX add %al,(%rax)
    return;
    23ee:	00 38                	add    %bh,(%rax)
    23f0:	03 91 88 5a 71 0b    	add    0xb715a88(%rcx),%edx
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    23f6:	00 00                	add    %al,(%rax)
    23f8:	38 03                	cmp    %al,(%rbx)
    23fa:	91                   	xchg   %eax,%ecx
    23fb:	84 5a 7a             	test   %bl,0x7a(%rdx)
    23fe:	0b 00                	or     (%rax),%eax
    2400:	00 38                	add    %bh,(%rax)
    2402:	03 91 80 5a 83 0b    	add    0xb835a80(%rcx),%edx
    2408:	00 00                	add    %al,(%rax)
    cur_time = bpf_ktime_get_ns();
    240a:	00 00                	add    %al,(%rax)
    240c:	00 3a                	add    %bh,(%rdx)
    240e:	34 74                	xor    $0x74,%al
    2410:	00 00                	add    %al,(%rax)
    2412:	00 38                	add    %bh,(%rax)
    2414:	03 91 e0 59 90 0b    	add    0xb9059e0(%rcx),%edx
    241a:	00 00                	add    %al,(%rax)
    241c:	3b 05 38 03 91 dc    	cmp    -0x236efcc8(%rip),%eax        # ffffffffdc91275a <server_id_map+0x36fee869675a>
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    2422:	59                   	pop    %rcx
    2423:	9a                   	(bad)
    2424:	0b 00                	or     (%rax),%eax
    2426:	00 3a                	add    %bh,(%rdx)
    2428:	35 4a 00 00 00       	xor    $0x4a,%eax
    242d:	38 03                	cmp    %al,(%rbx)
    242f:	91                   	xchg   %eax,%ecx
    2430:	d8 59 a4             	fcomps -0x5c(%rcx)
    2433:	0b 00                	or     (%rax),%eax
    2435:	00 38                	add    %bh,(%rax)
    2437:	03 91 d4 59 ad 0b    	add    0xbad59d4(%rcx),%edx
    243d:	00 00                	add    %al,(%rax)
    243f:	38 03                	cmp    %al,(%rbx)
      return;
    2441:	91                   	xchg   %eax,%ecx
    2442:	d0 59 b6             	rcrb   -0x4a(%rcx)
    2445:	0b 00                	or     (%rax),%eax
    dst_lru->atime = cur_time;
    2447:	00 00                	add    %al,(%rax)
    2449:	00 00                	add    %al,(%rax)
    244b:	3a 36                	cmp    (%rsi),%dh
    244d:	c0 00 00             	rolb   $0x0,(%rax)
    2450:	00 38                	add    %bh,(%rax)
    2452:	03 91 c4 59 c3 0b    	add    0xbc359c4(%rcx),%edx
  key = dst_lru->pos;
    2458:	00 00                	add    %al,(%rax)
    245a:	38 03                	cmp    %al,(%rbx)
    245c:	91                   	xchg   %eax,%ecx
    245d:	b8 59 cc 0b 00       	mov    $0xbcc59,%eax
    2462:	00 3a                	add    %bh,(%rdx)
    2464:	37                   	(bad)
    2465:	74 00                	je     2467 <balancer_ingress+0x2467>
  pckt->real_index = key;
    2467:	00 00                	add    %al,(%rax)
    2469:	38 03                	cmp    %al,(%rbx)
    246b:	91                   	xchg   %eax,%ecx
    246c:	b0 59                	mov    $0x59,%al
    246e:	d6                   	(bad)
    246f:	0b 00                	or     (%rax),%eax
    2471:	00 3b                	add    %bh,(%rbx)
    2473:	06                   	(bad)
    2474:	38 03                	cmp    %al,(%rbx)
    2476:	91                   	xchg   %eax,%ecx
  *real = bpf_map_lookup_elem(&reals, &key);
    2477:	ac                   	lods   %ds:(%rsi),%al
    2478:	59                   	pop    %rcx
    2479:	e0 0b                	loopne 2486 <balancer_ingress+0x2486>
    247b:	00 00                	add    %al,(%rax)
    247d:	3a 38                	cmp    (%rax),%bh
    247f:	4a 00 00             	rex.WX add %al,(%rax)
    2482:	00 38                	add    %bh,(%rax)
    2484:	03 91 a8 59 ea 0b    	add    0xbea59a8(%rcx),%edx
    248a:	00 00                	add    %al,(%rax)
    248c:	38 03                	cmp    %al,(%rbx)
    248e:	91                   	xchg   %eax,%ecx
    248f:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    2490:	59                   	pop    %rcx
    2491:	f3 0b 00             	repz or (%rax),%eax
    2494:	00 38                	add    %bh,(%rax)
    2496:	03 91 a0 59 fc 0b    	add    0xbfc59a0(%rcx),%edx
    249c:	00 00                	add    %al,(%rax)
    249e:	00 00                	add    %al,(%rax)
    24a0:	00 00                	add    %al,(%rax)
    24a2:	3a 39                	cmp    (%rcx),%bh
    24a4:	ae                   	scas   %es:(%rdi),%al
    24a5:	0c 00                	or     $0x0,%al
    24a7:	00 38                	add    %bh,(%rax)
    24a9:	03 91 97 59 0a 0c    	add    0xc0a5997(%rcx),%edx
    24af:	00 00                	add    %al,(%rax)
    24b1:	3a 3a                	cmp    (%rdx),%bh
    24b3:	be 01 00 00 38       	mov    $0x38000001,%esi
    24b8:	03 91 90 59 14 0c    	add    0xc145990(%rcx),%edx
    24be:	00 00                	add    %al,(%rax)
    24c0:	38 03                	cmp    %al,(%rbx)
    24c2:	91                   	xchg   %eax,%ecx
    24c3:	88 59 1d             	mov    %bl,0x1d(%rcx)
    24c6:	0c 00                	or     $0x0,%al
    24c8:	00 3a                	add    %bh,(%rdx)
    24ca:	3b 74 00 00          	cmp    0x0(%rax,%rax,1),%esi
    24ce:	00 38                	add    %bh,(%rax)
    24d0:	03 91 80 59 27 0c    	add    0xc275980(%rcx),%edx
    24d6:	00 00                	add    %al,(%rax)
    24d8:	3b 07                	cmp    (%rdi),%eax
    24da:	38 03                	cmp    %al,(%rbx)
    24dc:	91                   	xchg   %eax,%ecx
    24dd:	fc                   	cld
    24de:	58                   	pop    %rax
    24df:	31 0c 00             	xor    %ecx,(%rax,%rax,1)
    24e2:	00 3a                	add    %bh,(%rdx)
    24e4:	3c 4a                	cmp    $0x4a,%al
    24e6:	00 00                	add    %al,(%rax)
    24e8:	00 38                	add    %bh,(%rax)
    24ea:	03 91 f8 58 3b 0c    	add    0xc3b58f8(%rcx),%edx
    24f0:	00 00                	add    %al,(%rax)
    24f2:	38 03                	cmp    %al,(%rbx)
    24f4:	91                   	xchg   %eax,%ecx
    }
    24f5:	f4                   	hlt
    24f6:	58                   	pop    %rax
    check_udp_flow_migration(&dst, &pckt, vip_info, &vip);
    24f7:	44 0c 00             	rex.R or $0x0,%al
    24fa:	00 38                	add    %bh,(%rax)
    24fc:	03 91 f0 58 4d 0c    	add    0xc4d58f0(%rcx),%edx
    2502:	00 00                	add    %al,(%rax)
    2504:	00 00                	add    %al,(%rax)
    2506:	00 36                	add    %dh,(%rsi)
    2508:	d4                   	(bad)
    2509:	16                   	(bad)
    250a:	00 00                	add    %al,(%rax)
    250c:	3d c2 00 00 00       	cmp    $0xc2,%eax
    2511:	00 65 03             	add    %ah,0x3(%rbp)
    2514:	0b 37                	or     (%rdi),%esi
    2516:	03 91 d0 60 de 16    	add    0x16de60d0(%rcx),%edx
    251c:	00 00                	add    %al,(%rax)
    251e:	37                   	(bad)
    251f:	03 91 c8 60 e7 16    	add    0x16e760c8(%rcx),%edx
    2525:	00 00                	add    %al,(%rax)
    2527:	37                   	(bad)
    2528:	03 91 c7 60 f0 16    	add    0x16f060c7(%rcx),%edx
    252e:	00 00                	add    %al,(%rax)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    2530:	38 03                	cmp    %al,(%rbx)
    2532:	91                   	xchg   %eax,%ecx
    2533:	b8 60 f9 16 00       	mov    $0x16f960,%eax
    2538:	00 3a                	add    %bh,(%rdx)
    253a:	3e 58                	ds pop %rax
    253c:	00 00                	add    %al,(%rax)
    253e:	00 38                	add    %bh,(%rax)
    2540:	03 91 b0 60 03 17    	add    0x170360b0(%rcx),%edx
    2546:	00 00                	add    %al,(%rax)
    2548:	00 3a                	add    %bh,(%rdx)
    254a:	3f                   	(bad)
    254b:	56                   	push   %rsi
    254c:	00 00                	add    %al,(%rax)
    254e:	00 38                	add    %bh,(%rax)
    2550:	03 91 a8 60 0e 17    	add    0x170e60a8(%rcx),%edx
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    2556:	00 00                	add    %al,(%rax)
    2558:	00 00                	add    %al,(%rax)
    255a:	00 3a                	add    %bh,(%rdx)
    255c:	40 c3                	rex ret
    255e:	0a 00                	or     (%rax),%al
    2560:	00 38                	add    %bh,(%rax)
    2562:	03 91 e4 58 5b 0c    	add    0xc5b58e4(%rcx),%edx
    2568:	00 00                	add    %al,(%rax)
    256a:	38 03                	cmp    %al,(%rbx)
    256c:	91                   	xchg   %eax,%ecx
    256d:	d8 58 64             	fcomps 0x64(%rax)
    2570:	0c 00                	or     $0x0,%al
    2572:	00 38                	add    %bh,(%rax)
    2574:	03 91 b0 58 6d 0c    	add    0xc6d58b0(%rcx),%edx
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    257a:	00 00                	add    %al,(%rax)
    257c:	3a 41 74             	cmp    0x74(%rcx),%al
    257f:	00 00                	add    %al,(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2581:	00 38                	add    %bh,(%rax)
    2583:	03 91 d0 58 77 0c    	add    0xc7758d0(%rcx),%edx
    2589:	00 00                	add    %al,(%rax)
    258b:	3b 08                	cmp    (%rax),%ecx
    258d:	38 03                	cmp    %al,(%rbx)
    258f:	91                   	xchg   %eax,%ecx
    2590:	cc                   	int3
    2591:	58                   	pop    %rax
    2592:	81 0c 00 00 3a 42 4a 	orl    $0x4a423a00,(%rax,%rax,1)
    2599:	00 00                	add    %al,(%rax)
    259b:	00 38                	add    %bh,(%rax)
    259d:	03 91 c8 58 8b 0c    	add    0xc8b58c8(%rcx),%edx
    25a3:	00 00                	add    %al,(%rax)
    25a5:	38 03                	cmp    %al,(%rbx)
    25a7:	91                   	xchg   %eax,%ecx
    25a8:	c4                   	(bad)
    25a9:	58                   	pop    %rax
    25aa:	94                   	xchg   %eax,%esp
    25ab:	0c 00                	or     $0x0,%al
    25ad:	00 38                	add    %bh,(%rax)
    25af:	03 91 c0 58 9d 0c    	add    0xc9d58c0(%rcx),%edx
    25b5:	00 00                	add    %al,(%rax)
    25b7:	00 00                	add    %al,(%rax)
    25b9:	00 36                	add    %dh,(%rsi)
    25bb:	19 17                	sbb    %edx,(%rdi)
    25bd:	00 00                	add    %al,(%rax)
    25bf:	43 df 02             	rex.XB filds (%r10)
    25c2:	00 00                	add    %al,(%rax)
    25c4:	00 6f 03             	add    %ch,0x3(%rdi)
    25c7:	26 37                	es (bad)
    25c9:	03 91 e0 61 23 17    	add    0x172361e0(%rcx),%edx
    25cf:	00 00                	add    %al,(%rax)
    25d1:	37                   	(bad)
    25d2:	03 91 d8 61 2c 17    	add    0x172c61d8(%rcx),%edx
    25d8:	00 00                	add    %al,(%rax)
    25da:	37                   	(bad)
    25db:	03 91 d7 61 35 17    	add    0x173561d7(%rcx),%edx
    25e1:	00 00                	add    %al,(%rax)
    25e3:	37                   	(bad)
    25e4:	03 91 c8 61 3e 17    	add    0x173e61c8(%rcx),%edx
    25ea:	00 00                	add    %al,(%rax)
    25ec:	38 03                	cmp    %al,(%rbx)
    25ee:	91                   	xchg   %eax,%ecx
    25ef:	e8 61 47 17 00       	call   176d55 <bpf_xdp_adjust_head+0x16edb5>
  struct lb_stats* conn_rate_stats =
    25f4:	00 38                	add    %bh,(%rax)
    25f6:	03 91 c7 61 51 17    	add    0x175161c7(%rcx),%edx
  if (!conn_rate_stats) {
    25fc:	00 00                	add    %al,(%rax)
    25fe:	38 03                	cmp    %al,(%rbx)
    2600:	91                   	xchg   %eax,%ecx
    2601:	b8 61 5a 17 00       	mov    $0x175a61,%eax
    return true;
    2606:	00 38                	add    %bh,(%rax)
    2608:	03 91 b0 61 63 17    	add    0x176361b0(%rcx),%edx
    260e:	00 00                	add    %al,(%rax)
    2610:	38 03                	cmp    %al,(%rbx)
  *cur_time = bpf_ktime_get_ns();
    2612:	91                   	xchg   %eax,%ecx
    2613:	a8 61                	test   $0x61,%al
    2615:	6d                   	insl   (%dx),%es:(%rdi)
    2616:	17                   	(bad)
    2617:	00 00                	add    %al,(%rax)
    2619:	38 03                	cmp    %al,(%rbx)
    261b:	91                   	xchg   %eax,%ecx
    261c:	a0 61 77 17 00 00 38 	movabs 0x9103380000177761,%al
    2623:	03 91 
    2625:	97                   	xchg   %eax,%edi
    2626:	61                   	(bad)
    2627:	81 17 00 00 36 3c    	adcl   $0x3c360000,(%rdi)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    262d:	16                   	(bad)
    262e:	00 00                	add    %al,(%rax)
    2630:	44 79 00             	rex.R jns 2633 <balancer_ingress+0x2633>
    2633:	00 00                	add    %al,(%rax)
    2635:	09 60 01             	or     %esp,0x1(%rax)
    2638:	0f 37                	getsec
    263a:	03 91 97 78 45 16    	add    0x16457897(%rcx),%edx
    2640:	00 00                	add    %al,(%rax)
    2642:	37                   	(bad)
    2643:	03 91 96 78 4d 16    	add    0x164d7896(%rcx),%edx
    2649:	00 00                	add    %al,(%rax)
    conn_rate_stats->v1 = 1;
    264b:	38 03                	cmp    %al,(%rbx)
    264d:	91                   	xchg   %eax,%ecx
    264e:	88 78 55             	mov    %bh,0x55(%rax)
    2651:	16                   	(bad)
    2652:	00 00                	add    %al,(%rax)
    2654:	00 3a                	add    %bh,(%rdx)
    2656:	45 6e                	rex.RB outsb %ds:(%rsi),(%dx)
    conn_rate_stats->v2 = *cur_time;
    2658:	00 00                	add    %al,(%rax)
    265a:	00 38                	add    %bh,(%rax)
    265c:	03 91 98 61 8c 17    	add    0x178c6198(%rcx),%edx
    2662:	00 00                	add    %al,(%rax)
    2664:	00 00                	add    %al,(%rax)
    2666:	3a 46 f1             	cmp    -0xf(%rsi),%al
    2669:	05 00 00 38 03       	add    $0x3380000,%eax
  } else {
    266e:	91                   	xchg   %eax,%ecx
    conn_rate_stats->v1 += 1;
    266f:	ac                   	lods   %ds:(%rsi),%al
    2670:	58                   	pop    %rax
    2671:	aa                   	stos   %al,%es:(%rdi)
    2672:	0c 00                	or     $0x0,%al
    2674:	00 38                	add    %bh,(%rax)
    2676:	03 91 a0 58 b3 0c    	add    0xcb358a0(%rcx),%edx
    267c:	00 00                	add    %al,(%rax)
    267e:	36 98                	ss cwtl
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2680:	17                   	(bad)
    2681:	00 00                	add    %al,(%rax)
    2683:	47 76 00             	rex.RXB jbe 2686 <balancer_ingress+0x2686>
    2686:	00 00                	add    %al,(%rax)
    2688:	00 73 03             	add    %dh,0x3(%rbx)
    268b:	09 37                	or     %esi,(%rdi)
    268d:	03 91 d8 62 9e 17    	add    0x179e62d8(%rcx),%edx
      return true;
    2693:	00 00                	add    %al,(%rax)
    2695:	37                   	(bad)
    2696:	03 91 d7 62 a7 17    	add    0x17a762d7(%rcx),%edx
  return false;
    269c:	00 00                	add    %al,(%rax)
    269e:	00 3a                	add    %bh,(%rdx)
    26a0:	48 74 00             	rex.W je 26a3 <balancer_ingress+0x26a3>
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    26a3:	00 00                	add    %al,(%rax)
    26a5:	38 03                	cmp    %al,(%rbx)
    26a7:	91                   	xchg   %eax,%ecx
    26a8:	98                   	cwtl
    26a9:	58                   	pop    %rax
    26aa:	bd 0c 00 00 3b       	mov    $0x3b00000c,%ebp
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    26af:	09 38                	or     %edi,(%rax)
    26b1:	03 91 94 58 c7 0c    	add    0xcc75894(%rcx),%edx
    26b7:	00 00                	add    %al,(%rax)
    26b9:	3a 49 4a             	cmp    0x4a(%rcx),%cl
    26bc:	00 00                	add    %al,(%rax)
    26be:	00 38                	add    %bh,(%rax)
    26c0:	03 91 90 58 d1 0c    	add    0xcd15890(%rcx),%edx
    26c6:	00 00                	add    %al,(%rax)
    26c8:	38 03                	cmp    %al,(%rbx)
    26ca:	91                   	xchg   %eax,%ecx
    26cb:	8c 58 da             	mov    %ds,-0x26(%rax)
    26ce:	0c 00                	or     $0x0,%al
    26d0:	00 38                	add    %bh,(%rax)
    26d2:	03 91 88 58 e3 0c    	add    0xce35888(%rcx),%edx
    26d8:	00 00                	add    %al,(%rax)
    26da:	00 00                	add    %al,(%rax)
    26dc:	00 3a                	add    %bh,(%rdx)
    26de:	4a 38 04 00          	rex.WX cmp %al,(%rax,%r8,1)
    26e2:	00 38                	add    %bh,(%rax)
    26e4:	03 91 dc 57 f0 0c    	add    0xcf057dc(%rcx),%edx
    26ea:	00 00                	add    %al,(%rax)
    26ec:	3a 4b 74             	cmp    0x74(%rbx),%cl
    26ef:	00 00                	add    %al,(%rax)
    26f1:	00 38                	add    %bh,(%rax)
    26f3:	03 91 f8 57 fa 0c    	add    0xcfa57f8(%rcx),%edx
    26f9:	00 00                	add    %al,(%rax)
    26fb:	3b 0a                	cmp    (%rdx),%ecx
    26fd:	38 03                	cmp    %al,(%rbx)
    26ff:	91                   	xchg   %eax,%ecx
    2700:	f4                   	hlt
    2701:	57                   	push   %rdi
    2702:	04 0d                	add    $0xd,%al
    2704:	00 00                	add    %al,(%rax)
    2706:	3a 4c 4a 00          	cmp    0x0(%rdx,%rcx,2),%cl
    270a:	00 00                	add    %al,(%rax)
    270c:	38 03                	cmp    %al,(%rbx)
    270e:	91                   	xchg   %eax,%ecx
    270f:	f0 57                	lock push %rdi
    2711:	0e                   	(bad)
    2712:	0d 00 00 38 03       	or     $0x3380000,%eax
    2717:	91                   	xchg   %eax,%ecx
    2718:	ec                   	in     (%dx),%al
    2719:	57                   	push   %rdi
    271a:	17                   	(bad)
    271b:	0d 00 00 38 03       	or     $0x3380000,%eax
    2720:	91                   	xchg   %eax,%ecx
    2721:	e8 57 20 0d 00       	call   d477d <bpf_xdp_adjust_head+0xcc7dd>
    2726:	00 00                	add    %al,(%rax)
    2728:	00 00                	add    %al,(%rax)
    272a:	36 b1 17             	ss mov $0x17,%cl
    if (down_reals_map) {
    272d:	00 00                	add    %al,(%rax)
    272f:	4d 21 02             	and    %r8,(%r10)
    2732:	00 00                	add    %al,(%rax)
    2734:	00 89 03 17 37 03    	add    %cl,0x3371703(%rcx)
    273a:	91                   	xchg   %eax,%ecx
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    273b:	98                   	cwtl
    273c:	63 bb 17 00 00 37    	movsxd 0x37000017(%rbx),%edi
    2742:	03 91 90 63 c4 17    	add    0x17c46390(%rcx),%edx
    2748:	00 00                	add    %al,(%rax)
    274a:	38 03                	cmp    %al,(%rbx)
    274c:	91                   	xchg   %eax,%ecx
    274d:	88 63 cd             	mov    %ah,-0x33(%rbx)
    2750:	17                   	(bad)
    2751:	00 00                	add    %al,(%rax)
    2753:	38 03                	cmp    %al,(%rbx)
    2755:	91                   	xchg   %eax,%ecx
    2756:	80 63 d7 17          	andb   $0x17,-0x29(%rbx)
    275a:	00 00                	add    %al,(%rax)
    275c:	38 03                	cmp    %al,(%rbx)
    275e:	91                   	xchg   %eax,%ecx
    275f:	f0 62 e1 17 00 00    	(bad)
      if (down_real) {
    2765:	36 ec                	ss in  (%dx),%al
    2767:	17                   	(bad)
    2768:	00 00                	add    %al,(%rax)
    276a:	4e 2c 01             	rex.WRX sub $0x1,%al
    276d:	00 00                	add    %al,(%rax)
    276f:	00 74 02 07          	add    %dh,0x7(%rdx,%rax,1)
        *dst = NULL;
    2773:	37                   	(bad)
    2774:	03 91 c8 7b f5 17    	add    0x17f57bc8(%rcx),%edx
    277a:	00 00                	add    %al,(%rax)
    277c:	38 03                	cmp    %al,(%rbx)
    277e:	91                   	xchg   %eax,%ecx
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
    277f:	c4                   	(bad)
    2780:	7b fe                	jnp    2780 <balancer_ingress+0x2780>
    2782:	17                   	(bad)
    2783:	00 00                	add    %al,(%rax)
    2785:	38 03                	cmp    %al,(%rbx)
    2787:	91                   	xchg   %eax,%ecx
    2788:	b8 7b 07 18 00       	mov    $0x18077b,%eax
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    278d:	00 3a                	add    %bh,(%rdx)
    278f:	4f 74 00             	rex.WRXB je 2792 <balancer_ingress+0x2792>
    2792:	00 00                	add    %al,(%rax)
    2794:	38 03                	cmp    %al,(%rbx)
    2796:	91                   	xchg   %eax,%ecx
    2797:	b0 7b                	mov    $0x7b,%al
    2799:	11 18                	adc    %ebx,(%rax)
    279b:	00 00                	add    %al,(%rax)
    279d:	3b 0b                	cmp    (%rbx),%ecx
    279f:	38 03                	cmp    %al,(%rbx)
    27a1:	91                   	xchg   %eax,%ecx
    27a2:	ac                   	lods   %ds:(%rsi),%al
    27a3:	7b 1a                	jnp    27bf <balancer_ingress+0x27bf>
    27a5:	18 00                	sbb    %al,(%rax)
    27a7:	00 3a                	add    %bh,(%rdx)
    27a9:	50                   	push   %rax
    27aa:	4a 00 00             	rex.WX add %al,(%rax)
    27ad:	00 38                	add    %bh,(%rax)
    27af:	03 91 a8 7b 23 18    	add    0x18237ba8(%rcx),%edx
    27b5:	00 00                	add    %al,(%rax)
    27b7:	38 03                	cmp    %al,(%rbx)
    27b9:	91                   	xchg   %eax,%ecx
    27ba:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    27bb:	7b 2b                	jnp    27e8 <balancer_ingress+0x27e8>
    27bd:	18 00                	sbb    %al,(%rax)
    27bf:	00 38                	add    %bh,(%rax)
    27c1:	03 91 a0 7b 33 18    	add    0x18337ba0(%rcx),%edx
    27c7:	00 00                	add    %al,(%rax)
    27c9:	00 00                	add    %al,(%rax)
    27cb:	00 00                	add    %al,(%rax)
    27cd:	00 36                	add    %dh,(%rsi)
    27cf:	3f                   	(bad)
    27d0:	18 00                	sbb    %al,(%rax)
    27d2:	00 51 bd             	add    %dl,-0x43(%rcx)
    27d5:	00 00                	add    %al,(%rax)
    27d7:	00 00                	add    %al,(%rax)
    27d9:	8e 03                	mov    (%rbx),%es
    27db:	0f 37                	getsec
    27dd:	03 91 8c 64 45 18    	add    0x1845648c(%rcx),%edx
    27e3:	00 00                	add    %al,(%rax)
    27e5:	37                   	(bad)
    27e6:	03 91 8b 64 4e 18    	add    0x184e648b(%rcx),%edx
    27ec:	00 00                	add    %al,(%rax)
    27ee:	37                   	(bad)
    27ef:	03 91 8a 64 58 18    	add    0x1858648a(%rcx),%edx
    27f5:	00 00                	add    %al,(%rax)
    27f7:	38 03                	cmp    %al,(%rbx)
    27f9:	91                   	xchg   %eax,%ecx
    27fa:	80 64 62 18 00       	andb   $0x0,0x18(%rdx,%riz,2)
    27ff:	00 3a                	add    %bh,(%rdx)
    2801:	51                   	push   %rcx
    2802:	74 00                	je     2804 <balancer_ingress+0x2804>
        if (stats_data) {
    2804:	00 00                	add    %al,(%rax)
    2806:	38 03                	cmp    %al,(%rbx)
    2808:	91                   	xchg   %eax,%ecx
    2809:	f8                   	clc
    280a:	63 6d 18             	movsxd 0x18(%rbp),%ebp
    280d:	00 00                	add    %al,(%rax)
          stats_data->v1 += 1;
    280f:	3b 0c 38             	cmp    (%rax,%rdi,1),%ecx
    2812:	03 91 f4 63 77 18    	add    0x187763f4(%rcx),%edx
    2818:	00 00                	add    %al,(%rax)
    281a:	3a 52 4a             	cmp    0x4a(%rdx),%dl
    281d:	00 00                	add    %al,(%rax)
      }
    281f:	00 38                	add    %bh,(%rax)
    }
    2821:	03 91 f0 63 81 18    	add    0x188163f0(%rcx),%edx
    if (!dst) {
    2827:	00 00                	add    %al,(%rax)
    2829:	38 03                	cmp    %al,(%rbx)
    282b:	91                   	xchg   %eax,%ecx
    282c:	ec                   	in     (%dx),%al
    282d:	63 8a 18 00 00 38    	movsxd 0x38000018(%rdx),%ecx
      if (pckt.flow.proto == IPPROTO_TCP) {
    2833:	03 91 e8 63 93 18    	add    0x189363e8(%rcx),%edx
	...
    2841:	36 3f                	ss (bad)
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
    2843:	18 00                	sbb    %al,(%rax)
    2845:	00 53 bd             	add    %dl,-0x43(%rbx)
    2848:	00 00                	add    %al,(%rax)
    284a:	00 00                	add    %al,(%rax)
    284c:	a1 03 09 37 03 91 bc 	movabs 0x4564bc9103370903,%eax
    2853:	64 45 
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    2855:	18 00                	sbb    %al,(%rax)
    2857:	00 37                	add    %dh,(%rdi)
    2859:	03 91 bb 64 4e 18    	add    0x184e64bb(%rcx),%edx
    285f:	00 00                	add    %al,(%rax)
    2861:	37                   	(bad)
    2862:	03 91 ba 64 58 18    	add    0x185864ba(%rcx),%edx
    2868:	00 00                	add    %al,(%rax)
    286a:	38 03                	cmp    %al,(%rbx)
    286c:	91                   	xchg   %eax,%ecx
    286d:	b0 64                	mov    $0x64,%al
    286f:	62                   	(bad)
    2870:	18 00                	sbb    %al,(%rax)
    2872:	00 3a                	add    %bh,(%rdx)
    2874:	53                   	push   %rbx
    2875:	74 00                	je     2877 <balancer_ingress+0x2877>
    2877:	00 00                	add    %al,(%rax)
    2879:	38 03                	cmp    %al,(%rbx)
    287b:	91                   	xchg   %eax,%ecx
    287c:	a8 64                	test   $0x64,%al
    287e:	6d                   	insl   (%dx),%es:(%rdi)
    287f:	18 00                	sbb    %al,(%rax)
    2881:	00 3b                	add    %bh,(%rbx)
    2883:	0d 38 03 91 a4       	or     $0xa4910338,%eax
    2888:	64 77 18             	fs ja  28a3 <balancer_ingress+0x28a3>
    288b:	00 00                	add    %al,(%rax)
    288d:	3a 54 4a 00          	cmp    0x0(%rdx,%rcx,2),%dl
    2891:	00 00                	add    %al,(%rax)
    2893:	38 03                	cmp    %al,(%rbx)
    2895:	91                   	xchg   %eax,%ecx
    2896:	a0 64 81 18 00 00 38 	movabs 0x9103380000188164,%al
    289d:	03 91 
    289f:	9c                   	pushf
    28a0:	64 8a 18             	mov    %fs:(%rax),%bl
    28a3:	00 00                	add    %al,(%rax)
    28a5:	38 03                	cmp    %al,(%rbx)
    28a7:	91                   	xchg   %eax,%ecx
    28a8:	98                   	cwtl
    28a9:	64 93                	fs xchg %eax,%ebx
    28ab:	18 00                	sbb    %al,(%rax)
    28ad:	00 00                	add    %al,(%rax)
    28af:	00 00                	add    %al,(%rax)
    28b1:	00 00                	add    %al,(%rax)
    28b3:	00 36                	add    %dh,(%rsi)
    28b5:	a0 18 00 00 55 37 01 	movabs 0x13755000018,%al
    28bc:	00 00 
    28be:	00 d7                	add    %dl,%bh
    28c0:	03 07                	add    (%rdi),%eax
        struct lb_stats* lru_stats =
    28c2:	37                   	(bad)
    28c3:	03 91 f0 65 a5 18    	add    0x18a565f0(%rcx),%edx
        if (!lru_stats) {
    28c9:	00 00                	add    %al,(%rax)
    28cb:	37                   	(bad)
    28cc:	03 91 e8 65 ae 18    	add    0x18ae65e8(%rcx),%edx
          return XDP_DROP;
    28d2:	00 00                	add    %al,(%rax)
    28d4:	37                   	(bad)
    28d5:	03 91 e0 65 b6 18    	add    0x18b665e0(%rcx),%edx
    28db:	00 00                	add    %al,(%rax)
    28dd:	37                   	(bad)
    28de:	03 91 df 65 be 18    	add    0x18be65df(%rcx),%edx
        if (pckt.flags & F_SYN_SET) {
    28e4:	00 00                	add    %al,(%rax)
    28e6:	38 03                	cmp    %al,(%rbx)
    28e8:	91                   	xchg   %eax,%ecx
    28e9:	d0 65 c7             	shlb   -0x39(%rbp)
    28ec:	18 00                	sbb    %al,(%rax)
    28ee:	00 38                	add    %bh,(%rax)
          lru_stats->v1 += 1;
    28f0:	03 91 c8 65 d0 18    	add    0x18d065c8(%rcx),%edx
    28f6:	00 00                	add    %al,(%rax)
    28f8:	38 03                	cmp    %al,(%rbx)
    28fa:	91                   	xchg   %eax,%ecx
    28fb:	c4                   	(bad)
    28fc:	65 d9 18             	fstps  %gs:(%rax)
    28ff:	00 00                	add    %al,(%rax)
        } else {
    2901:	3a 56 74             	cmp    0x74(%rsi),%dl
          lru_stats->v2 += 1;
    2904:	00 00                	add    %al,(%rax)
    2906:	00 38                	add    %bh,(%rax)
    2908:	03 91 b8 65 e2 18    	add    0x18e265b8(%rcx),%edx
    290e:	00 00                	add    %al,(%rax)
    2910:	3b 0e                	cmp    (%rsi),%ecx
    2912:	38 03                	cmp    %al,(%rbx)
    2914:	91                   	xchg   %eax,%ecx
    2915:	b4 65                	mov    $0x65,%ah
      }
    2917:	eb 18                	jmp    2931 <balancer_ingress+0x2931>
      if (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6, lru_map)) {
    2919:	00 00                	add    %al,(%rax)
    291b:	3a 57 4a             	cmp    0x4a(%rdi),%dl
    291e:	00 00                	add    %al,(%rax)
    2920:	00 38                	add    %bh,(%rax)
    2922:	03 91 b0 65 f4 18    	add    0x18f465b0(%rcx),%edx
    2928:	00 00                	add    %al,(%rax)
    292a:	38 03                	cmp    %al,(%rbx)
    292c:	91                   	xchg   %eax,%ecx
    292d:	ac                   	lods   %ds:(%rsi),%al
    292e:	65 fc                	gs cld
    2930:	18 00                	sbb    %al,(%rax)
    2932:	00 38                	add    %bh,(%rax)
    2934:	03 91 a8 65 04 19    	add    0x190465a8(%rcx),%edx
    293a:	00 00                	add    %al,(%rax)
    293c:	00 00                	add    %al,(%rax)
    293e:	00 00                	add    %al,(%rax)
    2940:	36 15 19 00 00 58    	ss adc $0x58000019,%eax
    2946:	f6 02 00             	testb  $0x0,(%rdx)
    2949:	00 00                	add    %al,(%rax)
    294b:	e4 03                	in     $0x3,%al
    294d:	05 37 03 91 d0       	add    $0xd0910337,%eax
    2952:	67 1f                	addr32 (bad)
    2954:	19 00                	sbb    %eax,(%rax)
    2956:	00 37                	add    %dh,(%rdi)
    2958:	03 91 c8 67 28 19    	add    0x192867c8(%rcx),%edx
    295e:	00 00                	add    %al,(%rax)
  struct real_pos_lru new_dst_lru = {};
    2960:	37                   	(bad)
    2961:	03 91 c0 67 31 19    	add    0x193167c0(%rcx),%edx
    2967:	00 00                	add    %al,(%rax)
    2969:	37                   	(bad)
    296a:	03 91 b8 67 3a 19    	add    0x193a67b8(%rcx),%edx
    2970:	00 00                	add    %al,(%rax)
    2972:	38 03                	cmp    %al,(%rbx)
    2974:	91                   	xchg   %eax,%ecx
    2975:	b0 67                	mov    $0x67,%al
  bool under_flood = false;
    2977:	43 19 00             	rex.XB sbb %eax,(%r8)
    297a:	00 36                	add    %dh,(%rsi)
    297c:	ec                   	in     (%dx),%al
    297d:	17                   	(bad)
  bool src_found = false;
    297e:	00 00                	add    %al,(%rax)
    2980:	59                   	pop    %rcx
    2981:	2c 01                	sub    $0x1,%al
    2983:	00 00                	add    %al,(%rax)
  __u64 cur_time = 0;
    2985:	00 93 02 32 37 03    	add    %dl,0x3373202(%rbx)
    298b:	91                   	xchg   %eax,%ecx
    298c:	c8 7a f5 17          	enter  $0xf57a,$0x17
    2990:	00 00                	add    %al,(%rax)
    2992:	38 03                	cmp    %al,(%rbx)
    2994:	91                   	xchg   %eax,%ecx
    2995:	c4                   	(bad)
    2996:	7a fe                	jp     2996 <balancer_ingress+0x2996>
    2998:	17                   	(bad)
    2999:	00 00                	add    %al,(%rax)
    299b:	38 03                	cmp    %al,(%rbx)
    299d:	91                   	xchg   %eax,%ecx
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    299e:	b8 7a 07 18 00       	mov    $0x18077a,%eax
    29a3:	00 3a                	add    %bh,(%rdx)
    29a5:	5a                   	pop    %rdx
    29a6:	74 00                	je     29a8 <balancer_ingress+0x29a8>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    29a8:	00 00                	add    %al,(%rax)
    29aa:	38 03                	cmp    %al,(%rbx)
    29ac:	91                   	xchg   %eax,%ecx
    29ad:	b0 7a                	mov    $0x7a,%al
    29af:	11 18                	adc    %ebx,(%rax)
    29b1:	00 00                	add    %al,(%rax)
    29b3:	3b 0f                	cmp    (%rdi),%ecx
    29b5:	38 03                	cmp    %al,(%rbx)
    29b7:	91                   	xchg   %eax,%ecx
    29b8:	ac                   	lods   %ds:(%rsi),%al
    29b9:	7a 1a                	jp     29d5 <balancer_ingress+0x29d5>
    29bb:	18 00                	sbb    %al,(%rax)
    29bd:	00 3a                	add    %bh,(%rdx)
    29bf:	5b                   	pop    %rbx
    29c0:	4a 00 00             	rex.WX add %al,(%rax)
    29c3:	00 38                	add    %bh,(%rax)
    29c5:	03 91 a8 7a 23 18    	add    0x18237aa8(%rcx),%edx
    29cb:	00 00                	add    %al,(%rax)
    29cd:	38 03                	cmp    %al,(%rbx)
    29cf:	91                   	xchg   %eax,%ecx
    29d0:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    29d1:	7a 2b                	jp     29fe <balancer_ingress+0x29fe>
    29d3:	18 00                	sbb    %al,(%rax)
    29d5:	00 38                	add    %bh,(%rax)
    29d7:	03 91 a0 7a 33 18    	add    0x18337aa0(%rcx),%edx
    29dd:	00 00                	add    %al,(%rax)
    29df:	00 00                	add    %al,(%rax)
    29e1:	00 00                	add    %al,(%rax)
    29e3:	3a 5c 76 01          	cmp    0x1(%rsi,%rsi,2),%bl
    29e7:	00 00                	add    %al,(%rax)
    29e9:	38 03                	cmp    %al,(%rbx)
    29eb:	91                   	xchg   %eax,%ecx
    29ec:	a8 67                	test   $0x67,%al
    29ee:	4e 19 00             	rex.WRX sbb %r8,(%rax)
    29f1:	00 3a                	add    %bh,(%rdx)
    29f3:	5c                   	pop    %rsp
    29f4:	77 00                	ja     29f6 <balancer_ingress+0x29f6>
    29f6:	00 00                	add    %al,(%rax)
    29f8:	38 03                	cmp    %al,(%rbx)
    29fa:	91                   	xchg   %eax,%ecx
    29fb:	a0 67 59 19 00 00 3b 	movabs 0x38103b0000195967,%al
    2a02:	10 38 
    2a04:	03 91 9c 67 63 19    	add    0x1963679c(%rcx),%edx
    2a0a:	00 00                	add    %al,(%rax)
    2a0c:	3a 5d 4d             	cmp    0x4d(%rbp),%bl
    2a0f:	00 00                	add    %al,(%rax)
    2a11:	00 38                	add    %bh,(%rax)
    2a13:	03 91 98 67 6d 19    	add    0x196d6798(%rcx),%edx
    2a19:	00 00                	add    %al,(%rax)
    2a1b:	38 03                	cmp    %al,(%rbx)
  struct lb_stats* conn_rate_stats =
    2a1d:	91                   	xchg   %eax,%ecx
    2a1e:	94                   	xchg   %eax,%esp
    2a1f:	67 76 19             	addr32 jbe 2a3b <balancer_ingress+0x2a3b>
    2a22:	00 00                	add    %al,(%rax)
  if (!conn_rate_stats) {
    2a24:	38 03                	cmp    %al,(%rbx)
    2a26:	91                   	xchg   %eax,%ecx
    2a27:	90                   	nop
    2a28:	67 7f 19             	addr32 jg 2a44 <balancer_ingress+0x2a44>
    2a2b:	00 00                	add    %al,(%rax)
    return true;
    2a2d:	00 00                	add    %al,(%rax)
    2a2f:	00 3a                	add    %bh,(%rdx)
    2a31:	5e                   	pop    %rsi
    2a32:	e8 00 00 00 38       	call   38002a37 <bpf_xdp_adjust_head+0x37ffaa97>
    2a37:	03 91 80 67 8c 19    	add    0x198c6780(%rcx),%edx
  *cur_time = bpf_ktime_get_ns();
    2a3d:	00 00                	add    %al,(%rax)
    2a3f:	3a 5f b0             	cmp    -0x50(%rdi),%bl
    2a42:	00 00                	add    %al,(%rax)
    2a44:	00 38                	add    %bh,(%rax)
    2a46:	03 91 fc 66 97 19    	add    0x199766fc(%rcx),%edx
    2a4c:	00 00                	add    %al,(%rax)
    2a4e:	38 03                	cmp    %al,(%rbx)
    2a50:	91                   	xchg   %eax,%ecx
    2a51:	f0 66 a0 19 00 00 3a 	lock data16 movabs 0x74603a000019,%al
    2a58:	60 74 00 00 
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    2a5c:	00 38                	add    %bh,(%rax)
    2a5e:	03 91 e8 66 ab 19    	add    0x19ab66e8(%rcx),%edx
    2a64:	00 00                	add    %al,(%rax)
    2a66:	3b 11                	cmp    (%rcx),%edx
    2a68:	38 03                	cmp    %al,(%rbx)
    2a6a:	91                   	xchg   %eax,%ecx
    2a6b:	e4 66                	in     $0x66,%al
    2a6d:	b5 19                	mov    $0x19,%ch
    2a6f:	00 00                	add    %al,(%rax)
    2a71:	3a 61 4a             	cmp    0x4a(%rcx),%ah
    conn_rate_stats->v1 = 1;
    2a74:	00 00                	add    %al,(%rax)
    2a76:	00 38                	add    %bh,(%rax)
    2a78:	03 91 e0 66 bf 19    	add    0x19bf66e0(%rcx),%edx
    2a7e:	00 00                	add    %al,(%rax)
    conn_rate_stats->v2 = *cur_time;
    2a80:	38 03                	cmp    %al,(%rbx)
    2a82:	91                   	xchg   %eax,%ecx
    2a83:	dc 66 c8             	fsubl  -0x38(%rsi)
    2a86:	19 00                	sbb    %eax,(%rax)
    2a88:	00 38                	add    %bh,(%rax)
    2a8a:	03 91 d8 66 d1 19    	add    0x19d166d8(%rcx),%edx
	...
    conn_rate_stats->v1 += 1;
    2a98:	00 3a                	add    %bh,(%rdx)
    2a9a:	62 d5                	(bad)
    2a9c:	00 00                	add    %al,(%rax)
    2a9e:	00 38                	add    %bh,(%rax)
    2aa0:	03 91 d8 57 31 0d    	add    0xd3157d8(%rcx),%edx
    2aa6:	00 00                	add    %al,(%rax)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2aa8:	38 03                	cmp    %al,(%rbx)
    2aaa:	91                   	xchg   %eax,%ecx
    2aab:	d0 57 3a             	rclb   0x3a(%rdi)
    2aae:	0d 00 00 3a 63       	or     $0x633a0000,%eax
    2ab3:	74 00                	je     2ab5 <balancer_ingress+0x2ab5>
    2ab5:	00 00                	add    %al,(%rax)
    2ab7:	38 03                	cmp    %al,(%rbx)
      return true;
    2ab9:	91                   	xchg   %eax,%ecx
    2aba:	c8 57 44 0d          	enter  $0x4457,$0xd
    2abe:	00 00                	add    %al,(%rax)
    2ac0:	3b 12                	cmp    (%rdx),%edx
    2ac2:	38 03                	cmp    %al,(%rbx)
  return false;
    2ac4:	91                   	xchg   %eax,%ecx
    2ac5:	c4                   	(bad)
    2ac6:	57                   	push   %rdi
    2ac7:	4e 0d 00 00 3a 64    	rex.WRX or $0x643a0000,%rax
}
    2acd:	4a 00 00             	rex.WX add %al,(%rax)
  under_flood = is_under_flood(&cur_time);
    2ad0:	00 38                	add    %bh,(%rax)
    2ad2:	03 91 c0 57 58 0d    	add    0xd5857c0(%rcx),%edx
  if (!src_found) {
    2ad8:	00 00                	add    %al,(%rax)
    2ada:	38 03                	cmp    %al,(%rbx)
    2adc:	91                   	xchg   %eax,%ecx
    2add:	bc 57 61 0d 00       	mov    $0xd6157,%esp
    2ae2:	00 38                	add    %bh,(%rax)
    2ae4:	03 91 b8 57 6a 0d    	add    0xd6a57b8(%rcx),%edx
    bool hash_16bytes = is_ipv6;
    2aea:	00 00                	add    %al,(%rax)
    2aec:	00 00                	add    %al,(%rax)
    2aee:	00 00                	add    %al,(%rax)
    2af0:	36 e1 19             	ss loope 2b0c <balancer_ingress+0x2b0c>
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    2af3:	00 00                	add    %al,(%rax)
    2af5:	65 a2 05 00 00 00 fa 	movabs %al,%gs:0x370c03fa00000005
    2afc:	03 0c 37 
    2aff:	03 91 f8 69 ea 19    	add    0x19ea69f8(%rcx),%edx
      pckt->flow.port16[0] = pckt->flow.port16[1];
    2b05:	00 00                	add    %al,(%rax)
    2b07:	37                   	(bad)
    2b08:	03 91 f0 69 f3 19    	add    0x19f369f0(%rcx),%edx
    2b0e:	00 00                	add    %al,(%rax)
    2b10:	37                   	(bad)
    2b11:	03 91 e8 69 fb 19    	add    0x19fb69e8(%rcx),%edx
    2b17:	00 00                	add    %al,(%rax)
    2b19:	37                   	(bad)
      memset(pckt->flow.srcv6, 0, 16);
    2b1a:	03 91 e7 69 03 1a    	add    0x1a0369e7(%rcx),%edx
    2b20:	00 00                	add    %al,(%rax)
    2b22:	37                   	(bad)
    2b23:	03 91 d8 69 0b 1a    	add    0x1a0b69d8(%rcx),%edx
    2b29:	00 00                	add    %al,(%rax)
    2b2b:	38 03                	cmp    %al,(%rbx)
    2b2d:	91                   	xchg   %eax,%ecx
    2b2e:	c8 69 13 1a          	enter  $0x1369,$0x1a
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    2b32:	00 00                	add    %al,(%rax)
    2b34:	38 03                	cmp    %al,(%rbx)
    2b36:	91                   	xchg   %eax,%ecx
    2b37:	c7                   	(bad)
    2b38:	69 1c 1a 00 00 38 03 	imul   $0x3380000,(%rdx,%rbx,1),%ebx
    2b3f:	91                   	xchg   %eax,%ecx
    2b40:	c6                   	(bad)
    2b41:	69 25 1a 00 00 38 03 	imul   $0x69b89103,0x3800001a(%rip),%esp        # 38002b65 <bpf_xdp_adjust_head+0x37ffabc5>
    2b48:	91 b8 69 
    2b4b:	2e 1a 00             	cs sbb (%rax),%al
  if (hash_16bytes) {
    2b4e:	00 38                	add    %bh,(%rax)
    2b50:	03 91 b0 69 36 1a    	add    0x1a3669b0(%rcx),%edx
    2b56:	00 00                	add    %al,(%rax)
        jhash(pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6),
    2b58:	38 03                	cmp    %al,(%rbx)
    2b5a:	91                   	xchg   %eax,%ecx
    2b5b:	ac                   	lods   %ds:(%rsi),%al
    2b5c:	69 3f 1a 00 00 38    	imul   $0x3800001a,(%rdi),%edi
    2b62:	03 91 a8 69 48 1a    	add    0x1a4869a8(%rcx),%edx
    2b68:	00 00                	add    %al,(%rax)
    2b6a:	39 ec                	cmp    %ebp,%esp
    2b6c:	17                   	(bad)
    2b6d:	00 00                	add    %al,(%rax)
        pckt->flow.ports,
    2b6f:	66 32 01             	data16 xor (%rcx),%al
    2b72:	00 00                	add    %al,(%rax)
    2b74:	00 66 11             	add    %ah,0x11(%rsi)
    2b77:	37                   	(bad)
    2b78:	03 91 c8 79 f5 17    	add    0x17f579c8(%rcx),%edx
    return jhash_2words(
    2b7e:	00 00                	add    %al,(%rax)
    2b80:	38 03                	cmp    %al,(%rbx)
    2b82:	91                   	xchg   %eax,%ecx
    2b83:	c4                   	(bad)
    2b84:	79 fe                	jns    2b84 <balancer_ingress+0x2b84>
    2b86:	17                   	(bad)
    2b87:	00 00                	add    %al,(%rax)
    2b89:	38 03                	cmp    %al,(%rbx)
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    2b8b:	91                   	xchg   %eax,%ecx
    2b8c:	b8 79 07 18 00       	mov    $0x180779,%eax
    2b91:	00 3a                	add    %bh,(%rdx)
    2b93:	67 74 00             	addr32 je 2b96 <balancer_ingress+0x2b96>
    2b96:	00 00                	add    %al,(%rax)
    2b98:	38 03                	cmp    %al,(%rbx)
    2b9a:	91                   	xchg   %eax,%ecx
    2b9b:	b0 79                	mov    $0x79,%al
    2b9d:	11 18                	adc    %ebx,(%rax)
    2b9f:	00 00                	add    %al,(%rax)
    2ba1:	3b 13                	cmp    (%rbx),%edx
    2ba3:	38 03                	cmp    %al,(%rbx)
    2ba5:	91                   	xchg   %eax,%ecx
    2ba6:	ac                   	lods   %ds:(%rsi),%al
    2ba7:	79 1a                	jns    2bc3 <balancer_ingress+0x2bc3>
    2ba9:	18 00                	sbb    %al,(%rax)
    2bab:	00 3a                	add    %bh,(%rdx)
    2bad:	68 4a 00 00 00       	push   $0x4a
}
    2bb2:	38 03                	cmp    %al,(%rbx)
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    2bb4:	91                   	xchg   %eax,%ecx
    2bb5:	a8 79                	test   $0x79,%al
    2bb7:	23 18                	and    (%rax),%ebx
    2bb9:	00 00                	add    %al,(%rax)
    2bbb:	38 03                	cmp    %al,(%rbx)
    2bbd:	91                   	xchg   %eax,%ecx
    2bbe:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    2bbf:	79 2b                	jns    2bec <balancer_ingress+0x2bec>
    2bc1:	18 00                	sbb    %al,(%rax)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    2bc3:	00 38                	add    %bh,(%rax)
    2bc5:	03 91 a0 79 33 18    	add    0x183379a0(%rcx),%edx
    2bcb:	00 00                	add    %al,(%rax)
    2bcd:	00 00                	add    %al,(%rax)
    2bcf:	00 00                	add    %al,(%rax)
    2bd1:	3a 69 57             	cmp    0x57(%rcx),%ch
    2bd4:	02 00                	add    (%rax),%al
    2bd6:	00 38                	add    %bh,(%rax)
    2bd8:	03 91 a7 69 51 1a    	add    0x1a5169a7(%rcx),%edx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    2bde:	00 00                	add    %al,(%rax)
    2be0:	39 b8 1a 00 00 6a    	cmp    %edi,0x6a00001a(%rax)
    2be6:	66 00 00             	data16 add %al,(%rax)
    2be9:	00 00                	add    %al,(%rax)
    2beb:	8f                   	(bad)
    2bec:	0c 37                	or     $0x37,%al
    2bee:	03 91 e8 7b c1 1a    	add    0x1ac17be8(%rcx),%edx
    2bf4:	00 00                	add    %al,(%rax)
    2bf6:	37                   	(bad)
    2bf7:	03 91 e7 7b c9 1a    	add    0x1ac97be7(%rcx),%edx
    2bfd:	00 00                	add    %al,(%rax)
    2bff:	00 3a                	add    %bh,(%rdx)
    2c01:	6b 74 00 00 00       	imul   $0x0,0x0(%rax,%rax,1),%esi
    2c06:	38 03                	cmp    %al,(%rbx)
    2c08:	91                   	xchg   %eax,%ecx
    2c09:	98                   	cwtl
    2c0a:	69 5b 1a 00 00 3b 14 	imul   $0x143b0000,0x1a(%rbx),%ebx
    2c11:	38 03                	cmp    %al,(%rbx)
    2c13:	91                   	xchg   %eax,%ecx
    2c14:	94                   	xchg   %eax,%esp
    2c15:	69 64 1a 00 00 3a 6c 	imul   $0x4a6c3a00,0x0(%rdx,%rbx,1),%esp
    2c1c:	4a 
    2c1d:	00 00                	add    %al,(%rax)
    2c1f:	00 38                	add    %bh,(%rax)
    2c21:	03 91 90 69 6d 1a    	add    0x1a6d6990(%rcx),%edx
    2c27:	00 00                	add    %al,(%rax)
    2c29:	38 03                	cmp    %al,(%rbx)
    2c2b:	91                   	xchg   %eax,%ecx
    2c2c:	8c 69 75             	mov    %gs,0x75(%rcx)
    2c2f:	1a 00                	sbb    (%rax),%al
    2c31:	00 38                	add    %bh,(%rax)
    2c33:	03 91 88 69 7d 1a    	add    0x1a7d6988(%rcx),%edx
    2c39:	00 00                	add    %al,(%rax)
    2c3b:	00 00                	add    %al,(%rax)
    2c3d:	00 39                	add    %bh,(%rcx)
    2c3f:	d3 1a                	rcrl   %cl,(%rdx)
    2c41:	00 00                	add    %al,(%rax)
    2c43:	6d                   	insl   (%dx),%es:(%rdi)
    2c44:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    2c45:	00 00                	add    %al,(%rax)
    2c47:	00 00                	add    %al,(%rax)
    2c49:	9a                   	(bad)
    2c4a:	07                   	(bad)
    2c4b:	38 03                	cmp    %al,(%rbx)
    2c4d:	91                   	xchg   %eax,%ecx
    2c4e:	d4                   	(bad)
    2c4f:	7c d8                	jl     2c29 <balancer_ingress+0x2c29>
    2c51:	1a 00                	sbb    (%rax),%al
    2c53:	00 38                	add    %bh,(%rax)
    2c55:	03 91 c8 7c e1 1a    	add    0x1ae17cc8(%rcx),%edx
    if (!real_pos) {
    2c5b:	00 00                	add    %al,(%rax)
    2c5d:	3a 6e 74             	cmp    0x74(%rsi),%ch
    2c60:	00 00                	add    %al,(%rax)
      return false;
    2c62:	00 38                	add    %bh,(%rax)
    2c64:	03 91 c0 7c eb 1a    	add    0x1aeb7cc0(%rcx),%edx
    2c6a:	00 00                	add    %al,(%rax)
    2c6c:	3b 15 38 03 91 bc    	cmp    -0x436efcc8(%rip),%edx        # ffffffffbc912faa <server_id_map+0x36fec8696faa>
    key = *real_pos;
    2c72:	7c f4                	jl     2c68 <balancer_ingress+0x2c68>
    2c74:	1a 00                	sbb    (%rax),%al
    2c76:	00 3a                	add    %bh,(%rdx)
    2c78:	6f                   	outsl  %ds:(%rsi),(%dx)
    2c79:	4a 00 00             	rex.WX add %al,(%rax)
    2c7c:	00 38                	add    %bh,(%rax)
    if (key == 0) {
    2c7e:	03 91 b8 7c fd 1a    	add    0x1afd7cb8(%rcx),%edx
    2c84:	00 00                	add    %al,(%rax)
    2c86:	38 03                	cmp    %al,(%rbx)
    2c88:	91                   	xchg   %eax,%ecx
    2c89:	b4 7c                	mov    $0x7c,%ah
  __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
    2c8b:	05 1b 00 00 38       	add    $0x3800001b,%eax
    2c90:	03 91 b0 7c 0d 1b    	add    0x1b0d7cb0(%rcx),%edx
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    2c96:	00 00                	add    %al,(%rax)
    2c98:	00 00                	add    %al,(%rax)
    2c9a:	00 00                	add    %al,(%rax)
    2c9c:	00 3a                	add    %bh,(%rdx)
    2c9e:	70 74                	jo     2d14 <balancer_ingress+0x2d14>
    2ca0:	00 00                	add    %al,(%rax)
    2ca2:	00 38                	add    %bh,(%rax)
    2ca4:	03 91 f8 68 8a 1a    	add    0x1a8a68f8(%rcx),%edx
    2caa:	00 00                	add    %al,(%rax)
    2cac:	3b 16                	cmp    (%rsi),%edx
    2cae:	38 03                	cmp    %al,(%rbx)
    2cb0:	91                   	xchg   %eax,%ecx
    2cb1:	f4                   	hlt
    2cb2:	68 93 1a 00 00       	push   $0x1a93
    2cb7:	3a 71 4a             	cmp    0x4a(%rcx),%dh
    2cba:	00 00                	add    %al,(%rax)
    2cbc:	00 38                	add    %bh,(%rax)
    2cbe:	03 91 f0 68 9c 1a    	add    0x1a9c68f0(%rcx),%edx
    2cc4:	00 00                	add    %al,(%rax)
    2cc6:	38 03                	cmp    %al,(%rbx)
    2cc8:	91                   	xchg   %eax,%ecx
    2cc9:	ec                   	in     (%dx),%al
    2cca:	68 a4 1a 00 00       	push   $0x1aa4
    2ccf:	38 03                	cmp    %al,(%rbx)
    2cd1:	91                   	xchg   %eax,%ecx
    2cd2:	e8 68 ac 1a 00       	call   1ad93f <bpf_xdp_adjust_head+0x1a599f>
    2cd7:	00 00                	add    %al,(%rax)
    2cd9:	00 00                	add    %al,(%rax)
    2cdb:	39 19                	cmp    %ebx,(%rcx)
    2cdd:	1b 00                	sbb    (%rax),%eax
    2cdf:	00 72 a2             	add    %dh,-0x5e(%rdx)
    2ce2:	00 00                	add    %al,(%rax)
    2ce4:	00 00                	add    %al,(%rax)
    2ce6:	a3 05 38 03 91 b4 7d 	movabs %eax,0x1b1e7db491033805
    2ced:	1e 1b 
    2cef:	00 00                	add    %al,(%rax)
    2cf1:	38 03                	cmp    %al,(%rbx)
    2cf3:	91                   	xchg   %eax,%ecx
    2cf4:	a8 7d                	test   $0x7d,%al
    2cf6:	27                   	(bad)
    2cf7:	1b 00                	sbb    (%rax),%eax
    2cf9:	00 3a                	add    %bh,(%rdx)
    2cfb:	73 74                	jae    2d71 <balancer_ingress+0x2d71>
    2cfd:	00 00                	add    %al,(%rax)
    2cff:	00 38                	add    %bh,(%rax)
    2d01:	03 91 a0 7d 31 1b    	add    0x1b317da0(%rcx),%edx
    2d07:	00 00                	add    %al,(%rax)
  struct lb_stats* ch_drop_stats =
    2d09:	3b 17                	cmp    (%rdi),%edx
    2d0b:	38 03                	cmp    %al,(%rbx)
    2d0d:	91                   	xchg   %eax,%ecx
    2d0e:	9c                   	pushf
  if (!ch_drop_stats) {
    2d0f:	7d 3a                	jge    2d4b <balancer_ingress+0x2d4b>
    2d11:	1b 00                	sbb    (%rax),%eax
    2d13:	00 3a                	add    %bh,(%rdx)
    2d15:	74 4a                	je     2d61 <balancer_ingress+0x2d61>
    2d17:	00 00                	add    %al,(%rax)
    return;
    2d19:	00 38                	add    %bh,(%rax)
  ch_drop_stats->v2 += 1;
    2d1b:	03 91 98 7d 43 1b    	add    0x1b437d98(%rcx),%edx
    2d21:	00 00                	add    %al,(%rax)
    2d23:	38 03                	cmp    %al,(%rbx)
    2d25:	91                   	xchg   %eax,%ecx
    2d26:	94                   	xchg   %eax,%esp
    2d27:	7d 4b                	jge    2d74 <balancer_ingress+0x2d74>
    2d29:	1b 00                	sbb    (%rax),%eax
    2d2b:	00 38                	add    %bh,(%rax)
    2d2d:	03 91 90 7d 53 1b    	add    0x1b537d90(%rcx),%edx
      return false;
    2d33:	00 00                	add    %al,(%rax)
    2d35:	00 00                	add    %al,(%rax)
    2d37:	00 00                	add    %al,(%rax)
    2d39:	00 36                	add    %dh,(%rsi)
  }
    2d3b:	5f                   	pop    %rdi
  pckt->real_index = key;
    2d3c:	1b 00                	sbb    (%rax),%eax
    2d3e:	00 75 91             	add    %dh,-0x6f(%rbp)
    2d41:	02 00                	add    (%rax),%al
    2d43:	00 00                	add    %al,(%rax)
    2d45:	ff 03                	incl   (%rbx)
    2d47:	0b 37                	or     (%rdi),%esi
    2d49:	03 91 a0 6c 69 1b    	add    0x1b696ca0(%rcx),%edx
  *real = bpf_map_lookup_elem(&reals, &key);
    2d4f:	00 00                	add    %al,(%rax)
    2d51:	37                   	(bad)
    2d52:	03 91 98 6c 72 1b    	add    0x1b726c98(%rcx),%edx
    2d58:	00 00                	add    %al,(%rax)
    2d5a:	37                   	(bad)
    2d5b:	03 91 90 6c 7b 1b    	add    0x1b7b6c90(%rcx),%edx
    2d61:	00 00                	add    %al,(%rax)
    2d63:	37                   	(bad)
    2d64:	03 91 8f 6c 84 1b    	add    0x1b846c8f(%rcx),%edx
    2d6a:	00 00                	add    %al,(%rax)
    2d6c:	38 03                	cmp    %al,(%rbx)
    2d6e:	91                   	xchg   %eax,%ecx
    2d6f:	88 6c 8d 1b          	mov    %ch,0x1b(%rbp,%rcx,4)
    2d73:	00 00                	add    %al,(%rax)
    2d75:	38 03                	cmp    %al,(%rbx)
    2d77:	91                   	xchg   %eax,%ecx
    2d78:	80 6c 97 1b 00       	subb   $0x0,0x1b(%rdi,%rdx,4)
    2d7d:	00 38                	add    %bh,(%rax)
    2d7f:	03 91 df 6b a1 1b    	add    0x1ba16bdf(%rcx),%edx
    2d85:	00 00                	add    %al,(%rax)
    2d87:	38 03                	cmp    %al,(%rbx)
    2d89:	91                   	xchg   %eax,%ecx
    2d8a:	de 6b ab             	fisubrs -0x55(%rbx)
    2d8d:	1b 00                	sbb    (%rax),%eax
    2d8f:	00 38                	add    %bh,(%rax)
    2d91:	03 91 dd 6b b5 1b    	add    0x1bb56bdd(%rcx),%edx
    2d97:	00 00                	add    %al,(%rax)
    2d99:	38 03                	cmp    %al,(%rbx)
    2d9b:	91                   	xchg   %eax,%ecx
    2d9c:	dc 6b bf             	fsubrl -0x41(%rbx)
    2d9f:	1b 00                	sbb    (%rax),%eax
    2da1:	00 3a                	add    %bh,(%rdx)
    2da3:	76 74                	jbe    2e19 <balancer_ingress+0x2e19>
    2da5:	00 00                	add    %al,(%rax)
    2da7:	00 38                	add    %bh,(%rax)
    2da9:	03 91 f8 6b ca 1b    	add    0x1bca6bf8(%rcx),%edx
    2daf:	00 00                	add    %al,(%rax)
    2db1:	3b 18                	cmp    (%rax),%ebx
    2db3:	38 03                	cmp    %al,(%rbx)
    2db5:	91                   	xchg   %eax,%ecx
    2db6:	f4                   	hlt
    2db7:	6b d4 1b             	imul   $0x1b,%esp,%edx
    2dba:	00 00                	add    %al,(%rax)
    2dbc:	3a 77 4a             	cmp    0x4a(%rdi),%dh
    2dbf:	00 00                	add    %al,(%rax)
    2dc1:	00 38                	add    %bh,(%rax)
    2dc3:	03 91 f0 6b de 1b    	add    0x1bde6bf0(%rcx),%edx
    2dc9:	00 00                	add    %al,(%rax)
  if (!(*real)) {
    2dcb:	38 03                	cmp    %al,(%rbx)
    2dcd:	91                   	xchg   %eax,%ecx
    2dce:	ec                   	in     (%dx),%al
    2dcf:	6b e7 1b             	imul   $0x1b,%edi,%esp
    2dd2:	00 00                	add    %al,(%rax)
    2dd4:	38 03                	cmp    %al,(%rbx)
    2dd6:	91                   	xchg   %eax,%ecx
    2dd7:	e8 6b f0 1b 00       	call   1c1e47 <bpf_xdp_adjust_head+0x1b9ea7>
  __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
    2ddc:	00 00                	add    %al,(%rax)
    2dde:	00 00                	add    %al,(%rax)
    2de0:	3a 78 af             	cmp    -0x51(%rax),%bh
    2de3:	00 00                	add    %al,(%rax)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    2de5:	00 38                	add    %bh,(%rax)
    2de7:	03 91 d8 6b fd 1b    	add    0x1bfd6bd8(%rcx),%edx
    2ded:	00 00                	add    %al,(%rax)
    2def:	38 03                	cmp    %al,(%rbx)
    2df1:	91                   	xchg   %eax,%ecx
    2df2:	d0 6b 06             	shrb   0x6(%rbx)
    2df5:	1c 00                	sbb    $0x0,%al
    2df7:	00 3a                	add    %bh,(%rdx)
    2df9:	79 74                	jns    2e6f <balancer_ingress+0x2e6f>
    2dfb:	00 00                	add    %al,(%rax)
    2dfd:	00 38                	add    %bh,(%rax)
    2dff:	03 91 c8 6b 11 1c    	add    0x1c116bc8(%rcx),%edx
    2e05:	00 00                	add    %al,(%rax)
    2e07:	3b 19                	cmp    (%rcx),%ebx
    2e09:	38 03                	cmp    %al,(%rbx)
    2e0b:	91                   	xchg   %eax,%ecx
    2e0c:	c4                   	(bad)
    2e0d:	6b 1b 1c             	imul   $0x1c,(%rbx),%ebx
    2e10:	00 00                	add    %al,(%rax)
    2e12:	3a 7a 4a             	cmp    0x4a(%rdx),%bh
    2e15:	00 00                	add    %al,(%rax)
    2e17:	00 38                	add    %bh,(%rax)
    2e19:	03 91 c0 6b 25 1c    	add    0x1c256bc0(%rcx),%edx
    2e1f:	00 00                	add    %al,(%rax)
    2e21:	38 03                	cmp    %al,(%rbx)
    2e23:	91                   	xchg   %eax,%ecx
    2e24:	bc 6b 2e 1c 00       	mov    $0x1c2e6b,%esp
    2e29:	00 38                	add    %bh,(%rax)
    2e2b:	03 91 b8 6b 37 1c    	add    0x1c376bb8(%rcx),%edx
    2e31:	00 00                	add    %al,(%rax)
    2e33:	00 00                	add    %al,(%rax)
    2e35:	00 00                	add    %al,(%rax)
    2e37:	00 3a                	add    %bh,(%rdx)
    2e39:	7b 74                	jnp    2eaf <balancer_ingress+0x2eaf>
    2e3b:	00 00                	add    %al,(%rax)
    2e3d:	00 38                	add    %bh,(%rax)
    2e3f:	03 91 a8 57 78 0d    	add    0xd7857a8(%rcx),%edx
    2e45:	00 00                	add    %al,(%rax)
    2e47:	3b 1a                	cmp    (%rdx),%ebx
    2e49:	38 03                	cmp    %al,(%rbx)
    2e4b:	91                   	xchg   %eax,%ecx
    2e4c:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    2e4d:	57                   	push   %rdi
    2e4e:	82                   	(bad)
    2e4f:	0d 00 00 3a 7c       	or     $0x7c3a0000,%eax
    2e54:	4a 00 00             	rex.WX add %al,(%rax)
    2e57:	00 38                	add    %bh,(%rax)
  struct lb_stats* ch_drop_stats =
    2e59:	03 91 a0 57 8c 0d    	add    0xd8c57a0(%rcx),%edx
    2e5f:	00 00                	add    %al,(%rax)
  if (!ch_drop_stats) {
    2e61:	38 03                	cmp    %al,(%rbx)
    2e63:	91                   	xchg   %eax,%ecx
    2e64:	9c                   	pushf
    2e65:	57                   	push   %rdi
    2e66:	95                   	xchg   %eax,%ebp
    2e67:	0d 00 00 38 03       	or     $0x3380000,%eax
  ch_drop_stats->v1 += 1;
    2e6c:	91                   	xchg   %eax,%ecx
    2e6d:	98                   	cwtl
    2e6e:	57                   	push   %rdi
    2e6f:	9e                   	sahf
    2e70:	0d 00 00 00 00       	or     $0x0,%eax
    2e75:	00 3a                	add    %bh,(%rdx)
    2e77:	7d 74                	jge    2eed <balancer_ingress+0x2eed>
    2e79:	00 00                	add    %al,(%rax)
    2e7b:	00 38                	add    %bh,(%rax)
    return false;
    2e7d:	03 91 88 57 ab 0d    	add    0xdab5788(%rcx),%edx
    2e83:	00 00                	add    %al,(%rax)
    2e85:	3b 1b                	cmp    (%rbx),%ebx
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    2e87:	38 03                	cmp    %al,(%rbx)
    2e89:	91                   	xchg   %eax,%ecx
    2e8a:	84 57 b5             	test   %dl,-0x4b(%rdi)
    2e8d:	0d 00 00 3a 7e       	or     $0x7e3a0000,%eax
    2e92:	4a 00 00             	rex.WX add %al,(%rax)
    2e95:	00 38                	add    %bh,(%rax)
    2e97:	03 91 80 57 bf 0d    	add    0xdbf5780(%rcx),%edx
    2e9d:	00 00                	add    %al,(%rax)
    2e9f:	38 03                	cmp    %al,(%rbx)
    2ea1:	91                   	xchg   %eax,%ecx
    2ea2:	fc                   	cld
    2ea3:	56                   	push   %rsi
    2ea4:	c8 0d 00 00          	enter  $0xd,$0x0
    2ea8:	38 03                	cmp    %al,(%rbx)
    if (pckt->flow.proto == IPPROTO_UDP) {
    2eaa:	91                   	xchg   %eax,%ecx
    2eab:	f8                   	clc
    2eac:	56                   	push   %rsi
    2ead:	d1 0d 00 00 00 00    	rorl   0x0(%rip)        # 2eb3 <balancer_ingress+0x2eb3>
    2eb3:	00 3a                	add    %bh,(%rdx)
    2eb5:	7f 74                	jg     2f2b <balancer_ingress+0x2f2b>
    2eb7:	00 00                	add    %al,(%rax)
    2eb9:	00 38                	add    %bh,(%rax)
      new_dst_lru.atime = cur_time;
    2ebb:	03 91 e8 56 de 0d    	add    0xdde56e8(%rcx),%edx
    2ec1:	00 00                	add    %al,(%rax)
    2ec3:	3b 1c 38             	cmp    (%rax,%rdi,1),%ebx
    2ec6:	03 91 e4 56 e8 0d    	add    0xde856e4(%rcx),%edx
    new_dst_lru.pos = key;
    2ecc:	00 00                	add    %al,(%rax)
    2ece:	3a 80 01 4a 00 00    	cmp    0x4a01(%rax),%al
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    2ed4:	00 38                	add    %bh,(%rax)
    2ed6:	03 91 e0 56 f2 0d    	add    0xdf256e0(%rcx),%edx
    2edc:	00 00                	add    %al,(%rax)
    2ede:	38 03                	cmp    %al,(%rbx)
    2ee0:	91                   	xchg   %eax,%ecx
    2ee1:	dc 56 fb             	fcoml  -0x5(%rsi)
    2ee4:	0d 00 00 38 03       	or     $0x3380000,%eax
    2ee9:	91                   	xchg   %eax,%ecx
    2eea:	d8 56 04             	fcoms  0x4(%rsi)
    2eed:	0e                   	(bad)
    2eee:	00 00                	add    %al,(%rax)
    2ef0:	00 00                	add    %al,(%rax)
    2ef2:	00 36                	add    %dh,(%rsi)
    2ef4:	45 1c 00             	rex.RB sbb $0x0,%al
    2ef7:	00 81 01 73 03 00    	add    %al,0x37301(%rcx)
  return true;
    2efd:	00 00                	add    %al,(%rax)
    2eff:	24 04                	and    $0x4,%al
      if (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6, lru_map)) {
    2f01:	0a 37                	or     (%rdi),%dh
    2f03:	03 91 a0 6e 4e 1c    	add    0x1c4e6ea0(%rcx),%edx
    2f09:	00 00                	add    %al,(%rax)
        return XDP_DROP;
    2f0b:	37                   	(bad)
    2f0c:	03 91 98 6e 56 1c    	add    0x1c566e98(%rcx),%edx
    2f12:	00 00                	add    %al,(%rax)
    2f14:	37                   	(bad)
    2f15:	03 91 97 6e 5e 1c    	add    0x1c5e6e97(%rcx),%edx
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    2f1b:	00 00                	add    %al,(%rax)
    2f1d:	37                   	(bad)
    2f1e:	03 91 88 6e 66 1c    	add    0x1c666e88(%rcx),%edx
    2f24:	00 00                	add    %al,(%rax)
    2f26:	37                   	(bad)
    2f27:	03 91 80 6e 6e 1c    	add    0x1c6e6e80(%rcx),%edx
    2f2d:	00 00                	add    %al,(%rax)
    2f2f:	37                   	(bad)
    2f30:	03 91 fc 6d 76 1c    	add    0x1c766dfc(%rcx),%edx
    2f36:	00 00                	add    %al,(%rax)
    2f38:	38 03                	cmp    %al,(%rbx)
    2f3a:	91                   	xchg   %eax,%ecx
    2f3b:	f0 6d                	lock insl (%dx),%es:(%rdi)
    2f3d:	7e 1c                	jle    2f5b <balancer_ingress+0x2f5b>
    2f3f:	00 00                	add    %al,(%rax)
    2f41:	38 03                	cmp    %al,(%rbx)
    2f43:	91                   	xchg   %eax,%ecx
    2f44:	e8 6d 86 1c 00       	call   1cb5b6 <bpf_xdp_adjust_head+0x1c3616>
    2f49:	00 38                	add    %bh,(%rax)
    2f4b:	03 91 e0 6d 8e 1c    	add    0x1c8e6de0(%rcx),%edx
  __u32 vip_miss_stats_key = 0;
    2f51:	00 00                	add    %al,(%rax)
    2f53:	38 03                	cmp    %al,(%rbx)
    2f55:	91                   	xchg   %eax,%ecx
    2f56:	d8 6d 96             	fsubrs -0x6a(%rbp)
    2f59:	1c 00                	sbb    $0x0,%al
      bpf_map_lookup_elem(&vip_miss_stats, &vip_miss_stats_key);
    2f5b:	00 38                	add    %bh,(%rax)
    2f5d:	03 91 d0 6d 9f 1c    	add    0x1c9f6dd0(%rcx),%edx
    2f63:	00 00                	add    %al,(%rax)
    2f65:	38 03                	cmp    %al,(%rbx)
    2f67:	91                   	xchg   %eax,%ecx
    2f68:	ce                   	(bad)
    2f69:	6d                   	insl   (%dx),%es:(%rdi)
    2f6a:	a8 1c                	test   $0x1c,%al
    2f6c:	00 00                	add    %al,(%rax)
    2f6e:	38 03                	cmp    %al,(%rbx)
    2f70:	91                   	xchg   %eax,%ecx
    2f71:	b0 6d                	mov    $0x6d,%al
    2f73:	b0 1c                	mov    $0x1c,%al
    2f75:	00 00                	add    %al,(%rax)
    2f77:	38 03                	cmp    %al,(%rbx)
    2f79:	91                   	xchg   %eax,%ecx
    2f7a:	af                   	scas   %es:(%rdi),%eax
    2f7b:	6d                   	insl   (%dx),%es:(%rdi)
    2f7c:	b8 1c 00 00 39       	mov    $0x3900001c,%eax
    2f81:	cd 1c                	int    $0x1c
    2f83:	00 00                	add    %al,(%rax)
    2f85:	82                   	(bad)
    2f86:	01 42 00             	add    %eax,0x0(%rdx)
    2f89:	00 00                	add    %al,(%rax)
    2f8b:	0d 4b 05 37 03       	or     $0x337054b,%eax
    2f90:	91                   	xchg   %eax,%ecx
    2f91:	e6 7d                	out    %al,$0x7d
    2f93:	d2 1c 00             	rcrb   %cl,(%rax,%rax,1)
    2f96:	00 37                	add    %dh,(%rdi)
    2f98:	03 91 e0 7d da 1c    	add    0x1cda7de0(%rcx),%edx
    2f9e:	00 00                	add    %al,(%rax)
    2fa0:	37                   	(bad)
    2fa1:	03 91 d8 7d e2 1c    	add    0x1ce27dd8(%rcx),%edx
    2fa7:	00 00                	add    %al,(%rax)
    2fa9:	00 39                	add    %bh,(%rcx)
    2fab:	cd 1c                	int    $0x1c
    2fad:	00 00                	add    %al,(%rax)
    2faf:	83 01 42             	addl   $0x42,(%rcx)
    2fb2:	00 00                	add    %al,(%rax)
    2fb4:	00 0d 4f 05 37 03    	add    %cl,0x337054f(%rip)        # 3373509 <bpf_xdp_adjust_head+0x336b569>
    2fba:	91                   	xchg   %eax,%ecx
    2fbb:	fa                   	cli
    2fbc:	7d d2                	jge    2f90 <balancer_ingress+0x2f90>
    2fbe:	1c 00                	sbb    $0x0,%al
    2fc0:	00 37                	add    %dh,(%rdi)
    2fc2:	03 91 f4 7d da 1c    	add    0x1cda7df4(%rcx),%edx
    2fc8:	00 00                	add    %al,(%rax)
    2fca:	37                   	(bad)
    2fcb:	03 91 e8 7d e2 1c    	add    0x1ce27de8(%rcx),%edx
  struct vip_definition* lru_miss_stat_vip =
    2fd1:	00 00                	add    %al,(%rax)
    2fd3:	00 39                	add    %bh,(%rcx)
    2fd5:	eb 1c                	jmp    2ff3 <balancer_ingress+0x2ff3>
  if (!lru_miss_stat_vip) {
    2fd7:	00 00                	add    %al,(%rax)
    2fd9:	84 01                	test   %al,(%rcx)
    2fdb:	e1 00                	loope  2fdd <balancer_ingress+0x2fdd>
    2fdd:	00 00                	add    %al,(%rax)
    2fdf:	0d 53 03 37 03       	or     $0x3370353,%eax
    return XDP_DROP;
    2fe4:	91                   	xchg   %eax,%ecx
    2fe5:	c0 7e f0 1c          	sarb   $0x1c,-0x10(%rsi)
    2fe9:	00 00                	add    %al,(%rax)
    2feb:	37                   	(bad)
    2fec:	03 91 bf 7e f8 1c    	add    0x1cf87ebf(%rcx),%edx
  bool address_match = (is_ipv6 &&
    2ff2:	00 00                	add    %al,(%rax)
    2ff4:	37                   	(bad)
    2ff5:	03 91 b0 7e 01 1d    	add    0x1d017eb0(%rcx),%edx
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    2ffb:	00 00                	add    %al,(%rax)
    2ffd:	37                   	(bad)
    2ffe:	03 91 a8 7e 09 1d    	add    0x1d097ea8(%rcx),%edx
    3004:	00 00                	add    %al,(%rax)
    3006:	37                   	(bad)
    3007:	03 91 a6 7e 11 1d    	add    0x1d117ea6(%rcx),%edx
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    300d:	00 00                	add    %al,(%rax)
    300f:	37                   	(bad)
    3010:	03 91 a5 7e 19 1d    	add    0x1d197ea5(%rcx),%edx
    3016:	00 00                	add    %al,(%rax)
    3018:	00 00                	add    %al,(%rax)
    301a:	36 22 1d 00 00 85 01 	ss and 0x1850000(%rip),%bl        # 1853021 <bpf_xdp_adjust_head+0x184b081>
    3021:	33 03                	xor    (%rbx),%eax
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    3023:	00 00                	add    %al,(%rax)
    3025:	00 28                	add    %ch,(%rax)
    3027:	04 0a                	add    $0xa,%al
    3029:	37                   	(bad)
    302a:	03 91 80 70 2b 1d    	add    0x1d2b7080(%rcx),%edx
    3030:	00 00                	add    %al,(%rax)
    3032:	37                   	(bad)
    3033:	03 91 f8 6f 33 1d    	add    0x1d336ff8(%rcx),%edx
                         lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
    3039:	00 00                	add    %al,(%rax)
    303b:	37                   	(bad)
    303c:	03 91 f0 6f 3b 1d    	add    0x1d3b6ff0(%rcx),%edx
    3042:	00 00                	add    %al,(%rax)
    3044:	37                   	(bad)
    3045:	03 91 e8 6f 43 1d    	add    0x1d436fe8(%rcx),%edx
    304b:	00 00                	add    %al,(%rax)
    304d:	37                   	(bad)
    304e:	03 91 e4 6f 4b 1d    	add    0x1d4b6fe4(%rcx),%edx
    3054:	00 00                	add    %al,(%rax)
      (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
    3056:	38 03                	cmp    %al,(%rbx)
    3058:	91                   	xchg   %eax,%ecx
    3059:	d8 6f 53             	fsubrs 0x53(%rdi)
    305c:	1d 00 00 38 03       	sbb    $0x3380000,%eax
    3061:	91                   	xchg   %eax,%ecx
    3062:	d0 6f 5b             	shrb   0x5b(%rdi)
    3065:	1d 00 00 38 03       	sbb    $0x3380000,%eax
    306a:	91                   	xchg   %eax,%ecx
    306b:	c8 6f 63 1d          	enter  $0x636f,$0x1d
    306f:	00 00                	add    %al,(%rax)
    3071:	38 03                	cmp    %al,(%rbx)
    3073:	91                   	xchg   %eax,%ecx
    3074:	c0 6f 6b 1d          	shrb   $0x1d,0x6b(%rdi)
    3078:	00 00                	add    %al,(%rax)
    307a:	38 03                	cmp    %al,(%rbx)
    307c:	91                   	xchg   %eax,%ecx
    307d:	b8 6f 74 1d 00       	mov    $0x1d746f,%eax
    3082:	00 38                	add    %bh,(%rax)
    3084:	03 91 b4 6f 7d 1d    	add    0x1d7d6fb4(%rcx),%edx
    308a:	00 00                	add    %al,(%rax)
    308c:	38 03                	cmp    %al,(%rbx)
    308e:	91                   	xchg   %eax,%ecx
    308f:	a8 6f                	test   $0x6f,%al
    3091:	86 1d 00 00 39 90    	xchg   %bl,-0x6fc70000(%rip)        # ffffffff90393097 <server_id_map+0x36fe9c117097>
  bool address_match = (is_ipv6 &&
    3097:	1d 00 00 86 01       	sbb    $0x1860000,%eax
  bool port_match = lru_miss_stat_vip->port == vip->port;
    309c:	52                   	push   %rdx
    309d:	00 00                	add    %al,(%rax)
    309f:	00 0d 63 12 37 03    	add    %cl,0x3371263(%rip)        # 3374308 <bpf_xdp_adjust_head+0x336c368>
    30a5:	91                   	xchg   %eax,%ecx
    30a6:	de 7e 99             	fidivrs -0x67(%rsi)
    30a9:	1d 00 00 37 03       	sbb    $0x3370000,%eax
    30ae:	91                   	xchg   %eax,%ecx
    30af:	d8 7e a1             	fdivrs -0x5f(%rsi)
    30b2:	1d 00 00 38 03       	sbb    $0x3380000,%eax
    30b7:	91                   	xchg   %eax,%ecx
    30b8:	d4                   	(bad)
    30b9:	7e a9                	jle    3064 <balancer_ingress+0x3064>
    30bb:	1d 00 00 00 39       	sbb    $0x39000000,%eax
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    30c0:	b3 1d                	mov    $0x1d,%bl
    30c2:	00 00                	add    %al,(%rax)
    30c4:	87 01                	xchg   %eax,(%rcx)
    30c6:	57                   	push   %rdi
    30c7:	01 00                	add    %eax,(%rax)
    30c9:	00 0d 75 03 37 02    	add    %cl,0x2370375(%rip)        # 2373444 <bpf_xdp_adjust_head+0x236b4a4>
    30cf:	91                   	xchg   %eax,%ecx
    30d0:	48 b8 1d 00 00 37 02 	movabs $0xc04791023700001d,%rax
    30d7:	91 47 c0 
    30da:	1d 00 00 37 02       	sbb    $0x2370000,%eax
    30df:	91                   	xchg   %eax,%ecx
  bool vip_match = address_match && port_match && proto_match;
    30e0:	40 c8 1d 00 00       	rex enter $0x1d,$0x0
    30e5:	37                   	(bad)
    30e6:	03 91 bc 7f d0 1d    	add    0x1dd07fbc(%rcx),%edx
    30ec:	00 00                	add    %al,(%rax)
    30ee:	37                   	(bad)
    30ef:	03 91 ba 7f d8 1d    	add    0x1dd87fba(%rcx),%edx
    30f5:	00 00                	add    %al,(%rax)
    30f7:	37                   	(bad)
    30f8:	03 91 b9 7f e0 1d    	add    0x1de07fb9(%rcx),%edx
    30fe:	00 00                	add    %al,(%rax)
    3100:	38 03                	cmp    %al,(%rbx)
    3102:	91                   	xchg   %eax,%ecx
    3103:	b0 7f                	mov    $0x7f,%al
    3105:	e8 1d 00 00 39       	call   39003127 <bpf_xdp_adjust_head+0x38ffb187>
    310a:	d2 14 00             	rclb   %cl,(%rax,%rax,1)
    310d:	00 88 01 a0 00 00    	add    %cl,0xa001(%rax)
    3113:	00 0e                	add    %cl,(%rsi)
    3115:	48 03 37             	add    (%rdi),%rsi
    3118:	02 91 68 d7 14 00    	add    0x14d768(%rcx),%dl
  if (vip_match) {
    311e:	00 37                	add    %dh,(%rdi)
    3120:	02 91 60 df 14 00    	add    0x14df60(%rcx),%dl
    3126:	00 38                	add    %bh,(%rax)
    3128:	02 91 58 e8 14 00    	add    0x14e858(%rcx),%dl
    __u32 lru_stats_key = pckt->real_index;
    312e:	00 3a                	add    %bh,(%rdx)
    3130:	89 01                	mov    %eax,(%rcx)
    3132:	3a 00                	cmp    (%rax),%al
    3134:	00 00                	add    %al,(%rax)
    3136:	38 02                	cmp    %al,(%rdx)
    3138:	91                   	xchg   %eax,%ecx
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    3139:	54                   	push   %rsp
    313a:	f2 14 00             	repnz adc $0x0,%al
    313d:	00 00                	add    %al,(%rax)
    313f:	39 fd                	cmp    %edi,%ebp
    3141:	14 00                	adc    $0x0,%al
    3143:	00 8a 01 47 00 00    	add    %cl,0x4701(%rdx)
    3149:	00 0c 3a             	add    %cl,(%rdx,%rdi,1)
    314c:	0b 37                	or     (%rdi),%esi
    314e:	02 91 78 06 15 00    	add    0x150678(%rcx),%dl
    3154:	00 38                	add    %bh,(%rax)
    3156:	02 91 74 0f 15 00    	add    0x150f74(%rcx),%dl
    315c:	00 00                	add    %al,(%rax)
    315e:	00 00                	add    %al,(%rax)
    3160:	00 00                	add    %al,(%rax)
    3162:	36 30 0a             	ss xor %cl,(%rdx)
    3165:	00 00                	add    %al,(%rax)
    3167:	8b 01                	mov    (%rcx),%eax
    3169:	5d                   	pop    %rbp
    316a:	3b 00                	cmp    (%rax),%eax
    316c:	00 00                	add    %al,(%rax)
    316e:	43 04 0c             	rex.XB add $0xc,%al
    3171:	37                   	(bad)
    3172:	03 91 c0 56 39 0a    	add    0xa3956c0(%rcx),%edx
    3178:	00 00                	add    %al,(%rax)
    317a:	37                   	(bad)
    317b:	03 91 b8 56 42 0a    	add    0xa4256b8(%rcx),%edx
    3181:	00 00                	add    %al,(%rax)
    3183:	37                   	(bad)
    3184:	03 91 b7 56 4b 0a    	add    0xa4b56b7(%rcx),%edx
    318a:	00 00                	add    %al,(%rax)
    318c:	38 03                	cmp    %al,(%rbx)
    318e:	91                   	xchg   %eax,%ecx
    318f:	a8 56                	test   $0x56,%al
    3191:	54                   	push   %rsp
    3192:	0a 00                	or     (%rax),%al
    3194:	00 38                	add    %bh,(%rax)
    3196:	03 91 a0 56 5d 0a    	add    0xa5d56a0(%rcx),%edx
    319c:	00 00                	add    %al,(%rax)
    319e:	38 03                	cmp    %al,(%rbx)
    31a0:	91                   	xchg   %eax,%ecx
    31a1:	98                   	cwtl
    31a2:	56                   	push   %rsi
    31a3:	66 0a 00             	data16 or (%rax),%al
    31a6:	00 38                	add    %bh,(%rax)
    31a8:	03 91 90 56 6f 0a    	add    0xa6f5690(%rcx),%edx
    31ae:	00 00                	add    %al,(%rax)
    31b0:	38 03                	cmp    %al,(%rbx)
    31b2:	91                   	xchg   %eax,%ecx
    31b3:	e0 55                	loopne 320a <balancer_ingress+0x320a>
    if (!lru_miss_stat) {
    31b5:	78 0a                	js     31c1 <balancer_ingress+0x31c1>
    31b7:	00 00                	add    %al,(%rax)
    31b9:	38 03                	cmp    %al,(%rbx)
    31bb:	91                   	xchg   %eax,%ecx
    31bc:	c8 55 81 0a          	enter  $0x8155,$0xa
      return XDP_DROP;
    31c0:	00 00                	add    %al,(%rax)
    31c2:	38 03                	cmp    %al,(%rbx)
    31c4:	91                   	xchg   %eax,%ecx
    31c5:	c0 55 8a 0a          	rclb   $0xa,-0x76(%rbp)
    31c9:	00 00                	add    %al,(%rax)
    *lru_miss_stat += 1;
    31cb:	38 03                	cmp    %al,(%rbx)
    31cd:	91                   	xchg   %eax,%ecx
    31ce:	b8 55 93 0a 00       	mov    $0xa9355,%eax
    31d3:	00 38                	add    %bh,(%rax)
    31d5:	03 91 b7 55 9c 0a    	add    0xa9c55b7(%rcx),%edx
  return FURTHER_PROCESSING;
    31db:	00 00                	add    %al,(%rax)
    31dd:	38 03                	cmp    %al,(%rbx)
    31df:	91                   	xchg   %eax,%ecx
    31e0:	b4 55                	mov    $0x55,%ah
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    31e2:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    31e3:	0a 00                	or     (%rax),%al
    31e5:	00 38                	add    %bh,(%rax)
    31e7:	03 91 b0 55 ae 0a    	add    0xaae55b0(%rcx),%edx
        return XDP_DROP;
    31ed:	00 00                	add    %al,(%rax)
    31ef:	38 03                	cmp    %al,(%rbx)
    31f1:	91                   	xchg   %eax,%ecx
    31f2:	ac                   	lods   %ds:(%rsi),%al
    31f3:	55                   	push   %rbp
    31f4:	b7 0a                	mov    $0xa,%bh
    31f6:	00 00                	add    %al,(%rax)
    31f8:	38 03                	cmp    %al,(%rbx)
      data_stats->v2 += 1;
    31fa:	91                   	xchg   %eax,%ecx
    31fb:	a8 55                	test   $0x55,%al
    31fd:	c0 0a 00             	rorb   $0x0,(%rdx)
    3200:	00 38                	add    %bh,(%rax)
    3202:	03 91 a6 55 c9 0a    	add    0xac955a6(%rcx),%edx
    3208:	00 00                	add    %al,(%rax)
    320a:	38 03                	cmp    %al,(%rbx)
    320c:	91                   	xchg   %eax,%ecx
  }
    320d:	98                   	cwtl
    320e:	55                   	push   %rbp
  cval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos);
    320f:	d2 0a                	rorb   %cl,(%rdx)
    3211:	00 00                	add    %al,(%rax)
    3213:	38 03                	cmp    %al,(%rbx)
    3215:	91                   	xchg   %eax,%ecx
    3216:	d4                   	(bad)
    3217:	54                   	push   %rsp
    3218:	db 0a                	fisttpl (%rdx)
    321a:	00 00                	add    %al,(%rax)
    321c:	38 03                	cmp    %al,(%rbx)
    321e:	91                   	xchg   %eax,%ecx
    321f:	ac                   	lods   %ds:(%rsi),%al
    3220:	54                   	push   %rsp
    3221:	e4 0a                	in     $0xa,%al
    3223:	00 00                	add    %al,(%rax)
    3225:	38 03                	cmp    %al,(%rbx)
    3227:	91                   	xchg   %eax,%ecx
    3228:	a0 54 ed 0a 00 00 36 	movabs 0xed43600000aed54,%al
    322f:	d4 0e 
    3231:	00 00                	add    %al,(%rax)
    3233:	8c 01                	mov    %es,(%rcx)
    3235:	d4                   	(bad)
    3236:	02 00                	add    (%rax),%al
    3238:	00 00                	add    %al,(%rax)
    323a:	ba 02 0c 37 03       	mov    $0x3370c02,%edx
    323f:	91                   	xchg   %eax,%ecx
    3240:	c8 5d dd 0e          	enter  $0xdd5d,$0xe
    3244:	00 00                	add    %al,(%rax)
    3246:	37                   	(bad)
    3247:	03 91 c0 5d e6 0e    	add    0xee65dc0(%rcx),%edx
    324d:	00 00                	add    %al,(%rax)
    324f:	37                   	(bad)
    3250:	03 91 b8 5d ef 0e    	add    0xeef5db8(%rcx),%edx
    3256:	00 00                	add    %al,(%rax)
    3258:	37                   	(bad)
    3259:	03 91 b0 5d f8 0e    	add    0xef85db0(%rcx),%edx
    325f:	00 00                	add    %al,(%rax)
    3261:	37                   	(bad)
    3262:	03 91 a8 5d 01 0f    	add    0xf015da8(%rcx),%edx
    3268:	00 00                	add    %al,(%rax)
    326a:	37                   	(bad)
    326b:	03 91 a0 5d 0a 0f    	add    0xf0a5da0(%rcx),%edx
    3271:	00 00                	add    %al,(%rax)
    3273:	37                   	(bad)
    3274:	03 91 98 5d 13 0f    	add    0xf135d98(%rcx),%edx
    327a:	00 00                	add    %al,(%rax)
    327c:	37                   	(bad)
    327d:	03 91 97 5d 1c 0f    	add    0xf1c5d97(%rcx),%edx
    3283:	00 00                	add    %al,(%rax)
    3285:	38 03                	cmp    %al,(%rbx)
    3287:	91                   	xchg   %eax,%ecx
    3288:	88 5d 25             	mov    %bl,0x25(%rbp)
  if (!cval) {
    328b:	0f 00 00             	sldt   (%rax)
    328e:	38 03                	cmp    %al,(%rbx)
    3290:	91                   	xchg   %eax,%ecx
    3291:	80 5d 2e 0f          	sbbb   $0xf,0x2e(%rbp)
    return XDP_DROP;
    3295:	00 00                	add    %al,(%rax)
    3297:	38 03                	cmp    %al,(%rbx)
    3299:	91                   	xchg   %eax,%ecx
    329a:	f8                   	clc
    329b:	5c                   	pop    %rsp
    329c:	37                   	(bad)
    329d:	0f 00 00             	sldt   (%rax)
    32a0:	00 36                	add    %dh,(%rsi)
    32a2:	ef                   	out    %eax,(%dx)
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    32a3:	10 00                	adc    %al,(%rax)
    32a5:	00 8d 01 9d 09 00    	add    %cl,0x99d01(%rbp)
    32ab:	00 00                	add    %al,(%rax)
    32ad:	bf 02 0c 37 03       	mov    $0x3370c02,%edi
    32b2:	91                   	xchg   %eax,%ecx
    32b3:	98                   	cwtl
    32b4:	5e                   	pop    %rsi
    32b5:	f8                   	clc
    32b6:	10 00                	adc    %al,(%rax)
    32b8:	00 37                	add    %dh,(%rdi)
    32ba:	03 91 90 5e 01 11    	add    0x11015e90(%rcx),%edx
    32c0:	00 00                	add    %al,(%rax)
    32c2:	37                   	(bad)
    32c3:	03 91 88 5e 0a 11    	add    0x110a5e88(%rcx),%edx
    32c9:	00 00                	add    %al,(%rax)
    32cb:	37                   	(bad)
    32cc:	03 91 80 5e 13 11    	add    0x11135e80(%rcx),%edx
    32d2:	00 00                	add    %al,(%rax)
    32d4:	37                   	(bad)
    32d5:	03 91 ff 5d 1c 11    	add    0x111c5dff(%rcx),%edx
    32db:	00 00                	add    %al,(%rax)
    32dd:	36 26 11 00          	ss es adc %eax,(%rax)
    32e1:	00 8e 01 ec 03 00    	add    %cl,0x3ec01(%rsi)
    32e7:	00 0b                	add    %cl,(%rbx)
    32e9:	5a                   	pop    %rdx
    32ea:	01 0c 37             	add    %ecx,(%rdi,%rsi,1)
    32ed:	03 91 d0 71 2e 11    	add    0x112e71d0(%rcx),%edx
    32f3:	00 00                	add    %al,(%rax)
    32f5:	37                   	(bad)
    32f6:	03 91 c8 71 36 11    	add    0x113671c8(%rcx),%edx
    32fc:	00 00                	add    %al,(%rax)
    32fe:	37                   	(bad)
    32ff:	03 91 c0 71 3e 11    	add    0x113e71c0(%rcx),%edx
    3305:	00 00                	add    %al,(%rax)
    3307:	37                   	(bad)
    3308:	03 91 b8 71 46 11    	add    0x114671b8(%rcx),%edx
    330e:	00 00                	add    %al,(%rax)
    3310:	38 03                	cmp    %al,(%rbx)
    3312:	91                   	xchg   %eax,%ecx
    3313:	b0 71                	mov    $0x71,%al
    3315:	4e 11 00             	rex.WRX adc %r8,(%rax)
    3318:	00 38                	add    %bh,(%rax)
    331a:	03 91 a8 71 56 11    	add    0x115671a8(%rcx),%edx
  if (!data_stats) {
    3320:	00 00                	add    %al,(%rax)
    3322:	39 e3                	cmp    %esp,%ebx
    3324:	12 00                	adc    (%rax),%al
    3326:	00 8f 01 8d 01 00    	add    %cl,0x18d01(%rdi)
    return XDP_DROP;
    332c:	00 0b                	add    %cl,(%rbx)
    332e:	f0 0c 37             	lock or $0x37,%al
    3331:	03 91 88 75 eb 12    	add    0x12eb7588(%rcx),%edx
  data_stats->v1 += 1;
    3337:	00 00                	add    %al,(%rax)
    3339:	37                   	(bad)
    333a:	03 91 80 75 f3 12    	add    0x12f37580(%rcx),%edx
    3340:	00 00                	add    %al,(%rax)
    3342:	38 03                	cmp    %al,(%rbx)
    3344:	91                   	xchg   %eax,%ecx
    3345:	f8                   	clc
    3346:	74 fb                	je     3343 <balancer_ingress+0x3343>
  data_stats->v2 += pkt_bytes;
    3348:	12 00                	adc    (%rax),%al
    334a:	00 38                	add    %bh,(%rax)
    334c:	03 91 f0 74 03 13    	add    0x130374f0(%rcx),%edx
    3352:	00 00                	add    %al,(%rax)
    3354:	38 03                	cmp    %al,(%rbx)
    3356:	91                   	xchg   %eax,%ecx
    3357:	e0 74                	loopne 33cd <balancer_ingress+0x33cd>
    3359:	0b 13                	or     (%rbx),%edx
    335b:	00 00                	add    %al,(%rax)
    335d:	38 03                	cmp    %al,(%rbx)
    335f:	91                   	xchg   %eax,%ecx
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    3360:	d8 74 13 13          	fdivs  0x13(%rbx,%rdx,1)
    3364:	00 00                	add    %al,(%rax)
    3366:	39 1c 13             	cmp    %ebx,(%rbx,%rdx,1)
    3369:	00 00                	add    %al,(%rax)
    336b:	90                   	nop
    336c:	01 5e 00             	add    %ebx,0x0(%rsi)
    336f:	00 00                	add    %al,(%rax)
    3371:	0b 76 0a             	or     0xa(%rsi),%esi
    3374:	37                   	(bad)
    3375:	03 91 b0 75 24 13    	add    0x132475b0(%rcx),%edx
    337b:	00 00                	add    %al,(%rax)
    337d:	37                   	(bad)
    337e:	03 91 a8 75 2c 13    	add    0x132c75a8(%rcx),%edx
    3384:	00 00                	add    %al,(%rax)
    3386:	38 03                	cmp    %al,(%rbx)
    3388:	91                   	xchg   %eax,%ecx
    3389:	a0 75 34 13 00 00 38 	movabs 0x9103380000133475,%al
    3390:	03 91 
    3392:	9a                   	(bad)
    3393:	75 3c                	jne    33d1 <balancer_ingress+0x33d1>
    3395:	13 00                	adc    (%rax),%eax
    3397:	00 00                	add    %al,(%rax)
    3399:	00 3a                	add    %bh,(%rdx)
    339b:	91                   	xchg   %eax,%ecx
    339c:	01 ee                	add    %ebp,%esi
    339e:	00 00                	add    %al,(%rax)
    33a0:	00 38                	add    %bh,(%rax)
    33a2:	03 91 a4 71 5f 11    	add    0x115f71a4(%rcx),%edx
    33a8:	00 00                	add    %al,(%rax)
    33aa:	38 03                	cmp    %al,(%rbx)
    33ac:	91                   	xchg   %eax,%ecx
    33ad:	98                   	cwtl
    33ae:	71 67                	jno    3417 <balancer_ingress+0x3417>
    33b0:	11 00                	adc    %eax,(%rax)
    33b2:	00 38                	add    %bh,(%rax)
    33b4:	03 91 f4 70 6f 11    	add    0x116f70f4(%rcx),%edx
    33ba:	00 00                	add    %al,(%rax)
    33bc:	3a 92 01 74 00 00    	cmp    0x7401(%rdx),%dl
    33c2:	00 38                	add    %bh,(%rax)
    33c4:	03 91 90 71 78 11    	add    0x11787190(%rcx),%edx
    33ca:	00 00                	add    %al,(%rax)
    33cc:	3b 1d 38 03 91 8c    	cmp    -0x736efcc8(%rip),%ebx        # ffffffff8c91370a <server_id_map+0x36fe9869770a>
    33d2:	71 81                	jno    3355 <balancer_ingress+0x3355>
    33d4:	11 00                	adc    %eax,(%rax)
    33d6:	00 3a                	add    %bh,(%rdx)
    33d8:	93                   	xchg   %eax,%ebx
    33d9:	01 4a 00             	add    %ecx,0x0(%rdx)
  if (!data_stats) {
    33dc:	00 00                	add    %al,(%rax)
    33de:	38 03                	cmp    %al,(%rbx)
    33e0:	91                   	xchg   %eax,%ecx
    33e1:	88 71 8a             	mov    %dh,-0x76(%rcx)
    33e4:	11 00                	adc    %eax,(%rax)
    return XDP_DROP;
    33e6:	00 38                	add    %bh,(%rax)
    33e8:	03 91 84 71 92 11    	add    0x11927184(%rcx),%edx
    33ee:	00 00                	add    %al,(%rax)
    33f0:	38 03                	cmp    %al,(%rbx)
    33f2:	91                   	xchg   %eax,%ecx
    33f3:	80 71 9a 11          	xorb   $0x11,-0x66(%rcx)
  data_stats->v1 += 1;
    33f7:	00 00                	add    %al,(%rax)
    33f9:	00 00                	add    %al,(%rax)
    33fb:	00 00                	add    %al,(%rax)
    33fd:	00 36                	add    %dh,(%rsi)
    33ff:	77 13                	ja     3414 <balancer_ingress+0x3414>
    3401:	00 00                	add    %al,(%rax)
    3403:	94                   	xchg   %eax,%esp
    3404:	01 fe                	add    %edi,%esi
  data_stats->v2 += pkt_bytes;
    3406:	04 00                	add    $0x0,%al
    3408:	00 0b                	add    %cl,(%rbx)
    340a:	5c                   	pop    %rsp
    340b:	01 0c 37             	add    %ecx,(%rdi,%rsi,1)
    340e:	03 91 a0 73 80 13    	add    0x138073a0(%rcx),%edx
    3414:	00 00                	add    %al,(%rax)
    3416:	37                   	(bad)
    3417:	03 91 98 73 89 13    	add    0x13897398(%rcx),%edx
  pckt.flow.port16[0] = original_sport;
    341d:	00 00                	add    %al,(%rax)
    341f:	37                   	(bad)
    3420:	03 91 90 73 92 13    	add    0x13927390(%rcx),%edx
    3426:	00 00                	add    %al,(%rax)
    3428:	37                   	(bad)
    3429:	03 91 88 73 9b 13    	add    0x139b7388(%rcx),%edx
  if (dst->flags & F_IPV6) {
    342f:	00 00                	add    %al,(%rax)
    3431:	38 03                	cmp    %al,(%rbx)
    3433:	91                   	xchg   %eax,%ecx
    3434:	80 73 a4 13          	xorb   $0x13,-0x5c(%rbx)
    3438:	00 00                	add    %al,(%rax)
    343a:	38 03                	cmp    %al,(%rbx)
    343c:	91                   	xchg   %eax,%ecx
    343d:	f8                   	clc
    343e:	72 ad                	jb     33ed <balancer_ingress+0x33ed>
    3440:	13 00                	adc    (%rax),%eax
    if (!PCKT_ENCAP_V6(xdp, cval, is_ipv6, &pckt, dst, pkt_bytes)) {
    3442:	00 36                	add    %dh,(%rsi)
    3444:	8f                   	(bad)
    3445:	14 00                	adc    $0x0,%al
    3447:	00 95 01 9b 02 00    	add    %dl,0x29b01(%rbp)
    344d:	00 0b                	add    %cl,(%rbx)
    344f:	1f                   	(bad)
    3450:	01 0c 37             	add    %ecx,(%rdi,%rsi,1)
    3453:	03 91 e8 76 98 14    	add    0x149876e8(%rcx),%edx
    3459:	00 00                	add    %al,(%rax)
    345b:	37                   	(bad)
    345c:	03 91 e0 76 a0 14    	add    0x14a076e0(%rcx),%edx
    3462:	00 00                	add    %al,(%rax)
    3464:	38 03                	cmp    %al,(%rbx)
    3466:	91                   	xchg   %eax,%ecx
    3467:	d8 76 a8             	fdivs  -0x58(%rsi)
    346a:	14 00                	adc    $0x0,%al
    346c:	00 38                	add    %bh,(%rax)
    346e:	03 91 d0 76 b0 14    	add    0x14b076d0(%rcx),%edx
    3474:	00 00                	add    %al,(%rax)
    3476:	38 03                	cmp    %al,(%rbx)
    3478:	91                   	xchg   %eax,%ecx
    3479:	cc                   	int3
    347a:	76 b8                	jbe    3434 <balancer_ingress+0x3434>
    347c:	14 00                	adc    $0x0,%al
    347e:	00 38                	add    %bh,(%rax)
    3480:	03 91 c0 76 c0 14    	add    0x14c076c0(%rcx),%edx
    3486:	00 00                	add    %al,(%rax)
    3488:	38 03                	cmp    %al,(%rbx)
    348a:	91                   	xchg   %eax,%ecx
    348b:	b8 76 c9 14 00       	mov    $0x14c976,%eax
    3490:	00 39                	add    %bh,(%rcx)
    3492:	d2 14 00             	rclb   %cl,(%rax,%rax,1)
    3495:	00 96 01 df 00 00    	add    %dl,0xdf01(%rsi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    349b:	00 0b                	add    %cl,(%rbx)
    349d:	59                   	pop    %rcx
    349e:	03 37                	add    (%rdi),%esi
    34a0:	03 91 b0 77 d7 14    	add    0x14d777b0(%rcx),%edx
    34a6:	00 00                	add    %al,(%rax)
    34a8:	37                   	(bad)
    34a9:	03 91 a8 77 df 14    	add    0x14df77a8(%rcx),%edx
    34af:	00 00                	add    %al,(%rax)
    34b1:	38 03                	cmp    %al,(%rbx)
    34b3:	91                   	xchg   %eax,%ecx
    34b4:	a0 77 e8 14 00 00 3a 	movabs 0x1973a000014e877,%al
    34bb:	97 01 
    return false;
    34bd:	4f 00 00             	rex.WRXB add %r8b,(%r8)
    34c0:	00 38                	add    %bh,(%rax)
  data = (void*)(long)xdp->data;
    34c2:	03 91 9c 77 f2 14    	add    0x14f2779c(%rcx),%edx
    34c8:	00 00                	add    %al,(%rax)
    34ca:	00 39                	add    %bh,(%rcx)
    34cc:	fd                   	std
    34cd:	14 00                	adc    $0x0,%al
    34cf:	00 98 01 62 00 00    	add    %bl,0x6201(%rax)
  data_end = (void*)(long)xdp->data_end;
    34d5:	00 0c 3a             	add    %cl,(%rdx,%rdi,1)
    34d8:	0b 37                	or     (%rdi),%esi
    34da:	03 91 f0 77 06 15    	add    0x150677f0(%rcx),%edx
    34e0:	00 00                	add    %al,(%rax)
    34e2:	38 03                	cmp    %al,(%rbx)
    34e4:	91                   	xchg   %eax,%ecx
  new_eth = data;
    34e5:	ec                   	in     (%dx),%al
    34e6:	77 0f                	ja     34f7 <balancer_ingress+0x34f7>
    34e8:	15 00 00 00 00       	adc    $0x0,%eax
    34ed:	39 1c 13             	cmp    %ebx,(%rbx,%rdx,1)
    34f0:	00 00                	add    %al,(%rax)
    34f2:	99                   	cltd
  ip6h = data + sizeof(struct ethhdr);
    34f3:	01 5e 00             	add    %ebx,0x0(%rsi)
    34f6:	00 00                	add    %al,(%rax)
    34f8:	0b 5b 0a             	or     0xa(%rbx),%ebx
    34fb:	37                   	(bad)
    34fc:	03 91 90 77 24 13    	add    0x13247790(%rcx),%edx
    3502:	00 00                	add    %al,(%rax)
    3504:	37                   	(bad)
  old_eth = data + sizeof(struct ipv6hdr);
    3505:	03 91 88 77 2c 13    	add    0x132c7788(%rcx),%edx
    350b:	00 00                	add    %al,(%rax)
    350d:	38 03                	cmp    %al,(%rbx)
    350f:	91                   	xchg   %eax,%ecx
    3510:	80 77 34 13          	xorb   $0x13,0x34(%rdi)
    3514:	00 00                	add    %al,(%rax)
    3516:	38 03                	cmp    %al,(%rbx)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    3518:	91                   	xchg   %eax,%ecx
    3519:	fa                   	cli
    351a:	76 3c                	jbe    3558 <balancer_ingress+0x3558>
    351c:	13 00                	adc    (%rax),%eax
    351e:	00 00                	add    %al,(%rax)
    3520:	00 3a                	add    %bh,(%rdx)
    3522:	9a                   	(bad)
    3523:	01 f7                	add    %esi,%edi
    3525:	00 00                	add    %al,(%rax)
    3527:	00 38                	add    %bh,(%rax)
    3529:	03 91 f4 72 b7 13    	add    0x13b772f4(%rcx),%edx
    352f:	00 00                	add    %al,(%rax)
    3531:	38 03                	cmp    %al,(%rbx)
    3533:	91                   	xchg   %eax,%ecx
    3534:	e8 72 c0 13 00       	call   13f5ab <bpf_xdp_adjust_head+0x13760b>
    3539:	00 38                	add    %bh,(%rax)
    353b:	03 91 c6 72 ca 13    	add    0x13ca72c6(%rcx),%edx
    3541:	00 00                	add    %al,(%rax)
    3543:	3a 9b 01 74 00 00    	cmp    0x7401(%rbx),%bl
    3549:	00 38                	add    %bh,(%rax)
    354b:	03 91 e0 72 d4 13    	add    0x13d472e0(%rcx),%edx
    3551:	00 00                	add    %al,(%rax)
    3553:	3b 1e                	cmp    (%rsi),%ebx
    3555:	38 03                	cmp    %al,(%rbx)
    3557:	91                   	xchg   %eax,%ecx
    3558:	dc 72 de             	fdivl  -0x22(%rdx)
    355b:	13 00                	adc    (%rax),%eax
    return false;
    355d:	00 3a                	add    %bh,(%rdx)
    355f:	9c                   	pushf
    3560:	01 4a 00             	add    %ecx,0x0(%rdx)
    3563:	00 00                	add    %al,(%rax)
    3565:	38 03                	cmp    %al,(%rbx)
    3567:	91                   	xchg   %eax,%ecx
  memcpy(new_eth->h_dest, cval->mac, 6);
    3568:	d8 72 e8             	fdivs  -0x18(%rdx)
    356b:	13 00                	adc    (%rax),%eax
    356d:	00 38                	add    %bh,(%rax)
    356f:	03 91 d4 72 f1 13    	add    0x13f172d4(%rcx),%edx
    3575:	00 00                	add    %al,(%rax)
    3577:	38 03                	cmp    %al,(%rbx)
    3579:	91                   	xchg   %eax,%ecx
    357a:	d0 72 fa             	shlb   -0x6(%rdx)
    357d:	13 00                	adc    (%rax),%eax
    357f:	00 00                	add    %al,(%rax)
    3581:	00 00                	add    %al,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    3583:	00 00                	add    %al,(%rax)
    3585:	00 36                	add    %dh,(%rsi)
    3587:	19 15 00 00 9d 01    	sbb    %edx,0x19d0000(%rip)        # 19d358d <bpf_xdp_adjust_head+0x19cb5ed>
    358d:	85 01                	test   %eax,(%rcx)
    358f:	00 00                	add    %al,(%rax)
    3591:	00 f3                	add    %dh,%bl
    3593:	02 0a                	add    (%rdx),%cl
    3595:	37                   	(bad)
    3596:	03 91 98 5f 22 15    	add    0x15225f98(%rcx),%edx
    359c:	00 00                	add    %al,(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    359e:	37                   	(bad)
    359f:	03 91 90 5f 2a 15    	add    0x152a5f90(%rcx),%edx
    35a5:	00 00                	add    %al,(%rax)
    35a7:	37                   	(bad)
    35a8:	03 91 8f 5f 32 15    	add    0x15325f8f(%rcx),%edx
  if (is_ipv6) {
    35ae:	00 00                	add    %al,(%rax)
    35b0:	37                   	(bad)
    35b1:	03 91 80 5f 3a 15    	add    0x153a5f80(%rcx),%edx
    proto = IPPROTO_IPV6;
    35b7:	00 00                	add    %al,(%rax)
    35b9:	38 03                	cmp    %al,(%rbx)
    35bb:	91                   	xchg   %eax,%ecx
    35bc:	ff 5e 42             	lcall  *0x42(%rsi)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
    35bf:	15 00 00 38 03       	adc    $0x3380000,%eax
    35c4:	91                   	xchg   %eax,%ecx
    35c5:	f0 5e                	lock pop %rsi
    35c7:	4a 15 00 00 38 03    	rex.WX adc $0x3380000,%rax
    35cd:	91                   	xchg   %eax,%ecx
    35ce:	e8 5e 52 15 00       	call   158831 <bpf_xdp_adjust_head+0x150891>
    35d3:	00 39                	add    %bh,(%rcx)
    35d5:	3c 16                	cmp    $0x16,%al
    35d7:	00 00                	add    %al,(%rax)
    35d9:	9e                   	sahf
    35da:	01 79 00             	add    %edi,0x0(%rcx)
    35dd:	00 00                	add    %al,(%rax)
    35df:	09 7b 0f             	or     %edi,0xf(%rbx)
    35e2:	37                   	(bad)
    35e3:	03 91 c7 78 45 16    	add    0x164578c7(%rcx),%edx
    35e9:	00 00                	add    %al,(%rax)
    35eb:	37                   	(bad)
    35ec:	03 91 c6 78 4d 16    	add    0x164d78c6(%rcx),%edx
  saddr[0] = IPIP_V6_PREFIX1;
    35f2:	00 00                	add    %al,(%rax)
    35f4:	38 03                	cmp    %al,(%rbx)
    35f6:	91                   	xchg   %eax,%ecx
    35f7:	b8 78 55 16 00       	mov    $0x165578,%eax
  saddr[1] = IPIP_V6_PREFIX2;
    35fc:	00 00                	add    %al,(%rax)
    35fe:	00 36                	add    %dh,(%rsi)
    3600:	5e                   	pop    %rsi
    3601:	16                   	(bad)
    3602:	00 00                	add    %al,(%rax)
    3604:	9f                   	lahf
    3605:	01 58 01             	add    %ebx,0x1(%rax)
    3608:	00 00                	add    %al,(%rax)
  saddr[2] = IPIP_V6_PREFIX3;
    360a:	00 f7                	add    %dh,%bh
    360c:	02 0a                	add    (%rdx),%cl
    360e:	37                   	(bad)
    360f:	03 91 98 60 67 16    	add    0x16676098(%rcx),%edx
    3615:	00 00                	add    %al,(%rax)
  saddr[3] = src ^ port;
    3617:	37                   	(bad)
    3618:	03 91 90 60 6f 16    	add    0x166f6090(%rcx),%edx
    361e:	00 00                	add    %al,(%rax)
    3620:	37                   	(bad)
    3621:	03 91 8f 60 77 16    	add    0x1677608f(%rcx),%edx
    3627:	00 00                	add    %al,(%rax)
    3629:	37                   	(bad)
    362a:	03 91 80 60 7f 16    	add    0x167f6080(%rcx),%edx
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    3630:	00 00                	add    %al,(%rax)
    3632:	38 03                	cmp    %al,(%rbx)
    3634:	91                   	xchg   %eax,%ecx
    3635:	ff 5f 87             	lcall  *-0x79(%rdi)
    3638:	16                   	(bad)
    3639:	00 00                	add    %al,(%rax)
    363b:	38 03                	cmp    %al,(%rbx)
    363d:	91                   	xchg   %eax,%ecx
    363e:	f0 5f                	lock pop %rdi
    3640:	8f                   	(bad)
  } else {
    3641:	16                   	(bad)
    3642:	00 00                	add    %al,(%rax)
    3644:	38 03                	cmp    %al,(%rbx)
    proto = IPPROTO_IPIP;
    3646:	91                   	xchg   %eax,%ecx
    3647:	e8 5f 97 16 00       	call   16cdab <bpf_xdp_adjust_head+0x164e0b>
    364c:	00 39                	add    %bh,(%rcx)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
    364e:	3c 16                	cmp    $0x16,%al
    3650:	00 00                	add    %al,(%rax)
    3652:	a0 01 79 00 00 00 09 	movabs 0xf61090000007901,%al
    3659:	61 0f 
    365b:	37                   	(bad)
    365c:	03 91 a7 78 45 16    	add    0x164578a7(%rcx),%edx
    3662:	00 00                	add    %al,(%rax)
    3664:	37                   	(bad)
    3665:	03 91 a6 78 4d 16    	add    0x164d78a6(%rcx),%edx
    366b:	00 00                	add    %al,(%rax)
    366d:	38 03                	cmp    %al,(%rbx)
    366f:	91                   	xchg   %eax,%ecx
    3670:	98                   	cwtl
    3671:	78 55                	js     36c8 <balancer_ingress+0x36c8>
    3673:	16                   	(bad)
    3674:	00 00                	add    %al,(%rax)
    3676:	00 00                	add    %al,(%rax)
    3678:	3a a1 01 74 00 00    	cmp    0x7401(%rcx),%ah
  saddr[0] = IPIP_V6_PREFIX1;
    367e:	00 38                	add    %bh,(%rax)
    3680:	03 91 90 55 f7 0a    	add    0xaf75590(%rcx),%edx
    3686:	00 00                	add    %al,(%rax)
    3688:	3b 1f                	cmp    (%rdi),%ebx
  saddr[1] = IPIP_V6_PREFIX2;
    368a:	38 03                	cmp    %al,(%rbx)
    368c:	91                   	xchg   %eax,%ecx
    368d:	8c 55 01             	mov    %ss,0x1(%rbp)
    3690:	0b 00                	or     (%rax),%eax
    3692:	00 3a                	add    %bh,(%rdx)
    3694:	a2 01 4a 00 00 00 38 	movabs %al,0x9103380000004a01
    369b:	03 91 
  saddr[2] = IPIP_V6_PREFIX3;
    369d:	88 55 0b             	mov    %dl,0xb(%rbp)
    36a0:	0b 00                	or     (%rax),%eax
    36a2:	00 38                	add    %bh,(%rax)
    36a4:	03 91 84 55 14 0b    	add    0xb145584(%rcx),%edx
  saddr[3] = src ^ port;
    36aa:	00 00                	add    %al,(%rax)
    36ac:	38 03                	cmp    %al,(%rbx)
    36ae:	91                   	xchg   %eax,%ecx
    36af:	80 55 1d 0b          	adcb   $0xb,0x1d(%rbp)
    36b3:	00 00                	add    %al,(%rax)
    36b5:	00 00                	add    %al,(%rax)
    36b7:	00 3a                	add    %bh,(%rdx)
    36b9:	a3 01 74 00 00 00 38 	movabs %eax,0x9103380000007401
    36c0:	03 91 
    payload_len = pkt_bytes;
    36c2:	f0 54                	lock push %rsp
    36c4:	2a 0b                	sub    (%rbx),%cl
    36c6:	00 00                	add    %al,(%rax)
    36c8:	3b 20                	cmp    (%rax),%esp
    36ca:	38 03                	cmp    %al,(%rbx)
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    36cc:	91                   	xchg   %eax,%ecx
    36cd:	ec                   	in     (%dx),%al
    36ce:	54                   	push   %rsp
    36cf:	34 0b                	xor    $0xb,%al
    36d1:	00 00                	add    %al,(%rax)
    36d3:	3a a4 01 4a 00 00 00 	cmp    0x4a(%rcx,%rax,1),%ah
    36da:	38 03                	cmp    %al,(%rbx)
    36dc:	91                   	xchg   %eax,%ecx
    36dd:	e8 54 3e 0b 00       	call   b7536 <bpf_xdp_adjust_head+0xaf596>
    36e2:	00 38                	add    %bh,(%rax)
    36e4:	03 91 e4 54 47 0b    	add    0xb4754e4(%rcx),%edx
    36ea:	00 00                	add    %al,(%rax)
    36ec:	38 03                	cmp    %al,(%rbx)
    36ee:	91                   	xchg   %eax,%ecx
    36ef:	e0 54                	loopne 3745 <balancer_ingress+0x3745>
    36f1:	50                   	push   %rax
    36f2:	0b 00                	or     (%rax),%eax
    36f4:	00 00                	add    %al,(%rax)
    36f6:	00 00                	add    %al,(%rax)
    36f8:	3a a5 01 74 00 00    	cmp    0x7401(%rbp),%ah
    36fe:	00 38                	add    %bh,(%rax)
    3700:	03 91 c8 54 5d 0b    	add    0xb5d54c8(%rcx),%edx
    3706:	00 00                	add    %al,(%rax)
    3708:	3b 21                	cmp    (%rcx),%esp
    370a:	38 03                	cmp    %al,(%rbx)
    370c:	91                   	xchg   %eax,%ecx
    370d:	c4                   	(bad)
    370e:	54                   	push   %rsp
    370f:	67 0b 00             	or     (%eax),%eax
    3712:	00 3a                	add    %bh,(%rdx)
    3714:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    3715:	01 4a 00             	add    %ecx,0x0(%rdx)
    3718:	00 00                	add    %al,(%rax)
    371a:	38 03                	cmp    %al,(%rbx)
    371c:	91                   	xchg   %eax,%ecx
    371d:	c0 54 71 0b 00       	rclb   $0x0,0xb(%rcx,%rsi,2)
  ip6h->version = 6;
    3722:	00 38                	add    %bh,(%rax)
    3724:	03 91 bc 54 7a 0b    	add    0xb7a54bc(%rcx),%edx
    372a:	00 00                	add    %al,(%rax)
    372c:	38 03                	cmp    %al,(%rbx)
    372e:	91                   	xchg   %eax,%ecx
    372f:	b8 54 83 0b 00       	mov    $0xb8354,%eax
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    3734:	00 00                	add    %al,(%rax)
    3736:	00 00                	add    %al,(%rax)
    3738:	3a a7 01 74 00 00    	cmp    0x7401(%rdi),%ah
    373e:	00 38                	add    %bh,(%rax)
    3740:	03 91 98 54 90 0b    	add    0xb905498(%rcx),%edx
    3746:	00 00                	add    %al,(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    3748:	3b 22                	cmp    (%rdx),%esp
    374a:	38 03                	cmp    %al,(%rbx)
    374c:	91                   	xchg   %eax,%ecx
    374d:	94                   	xchg   %eax,%esp
    374e:	54                   	push   %rsp
    374f:	9a                   	(bad)
    3750:	0b 00                	or     (%rax),%eax
    3752:	00 3a                	add    %bh,(%rdx)
    3754:	a8 01                	test   $0x1,%al
    3756:	4a 00 00             	rex.WX add %al,(%rax)
    3759:	00 38                	add    %bh,(%rax)
    375b:	03 91 90 54 a4 0b    	add    0xba45490(%rcx),%edx
    3761:	00 00                	add    %al,(%rax)
    3763:	38 03                	cmp    %al,(%rbx)
    3765:	91                   	xchg   %eax,%ecx
    3766:	8c 54 ad 0b          	mov    %ss,0xb(%rbp,%rbp,4)
    376a:	00 00                	add    %al,(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    376c:	38 03                	cmp    %al,(%rbx)
    376e:	91                   	xchg   %eax,%ecx
    376f:	88 54 b6 0b          	mov    %dl,0xb(%rsi,%rsi,4)
    3773:	00 00                	add    %al,(%rax)
    3775:	00 00                	add    %al,(%rax)
    3777:	00 3a                	add    %bh,(%rdx)
    3779:	a9 01 c0 00 00       	test   $0xc001,%eax
    377e:	00 38                	add    %bh,(%rax)
    3780:	03 91 fc 53 c3 0b    	add    0xbc353fc(%rcx),%edx
  ip6h->nexthdr = proto;
    3786:	00 00                	add    %al,(%rax)
    3788:	38 03                	cmp    %al,(%rbx)
    378a:	91                   	xchg   %eax,%ecx
    378b:	f0 53                	lock push %rbx
    378d:	cc                   	int3
    378e:	0b 00                	or     (%rax),%eax
    3790:	00 3a                	add    %bh,(%rdx)
    3792:	aa                   	stos   %al,%es:(%rdi)
    3793:	01 74 00 00          	add    %esi,0x0(%rax,%rax,1)
  ip6h->payload_len = bpf_htons(payload_len);
    3797:	00 38                	add    %bh,(%rax)
    3799:	03 91 e8 53 d6 0b    	add    0xbd653e8(%rcx),%edx
    379f:	00 00                	add    %al,(%rax)
    37a1:	3b 23                	cmp    (%rbx),%esp
    37a3:	38 03                	cmp    %al,(%rbx)
    37a5:	91                   	xchg   %eax,%ecx
    37a6:	e4 53                	in     $0x53,%al
    37a8:	e0 0b                	loopne 37b5 <balancer_ingress+0x37b5>
    37aa:	00 00                	add    %al,(%rax)
    37ac:	3a ab 01 4a 00 00    	cmp    0x4a01(%rbx),%ch
    37b2:	00 38                	add    %bh,(%rax)
    37b4:	03 91 e0 53 ea 0b    	add    0xbea53e0(%rcx),%edx
    37ba:	00 00                	add    %al,(%rax)
    37bc:	38 03                	cmp    %al,(%rbx)
  ip6h->hop_limit = DEFAULT_TTL;
    37be:	91                   	xchg   %eax,%ecx
    37bf:	dc 53 f3             	fcoml  -0xd(%rbx)
    37c2:	0b 00                	or     (%rax),%eax
    37c4:	00 38                	add    %bh,(%rax)
    37c6:	03 91 d8 53 fc 0b    	add    0xbfc53d8(%rcx),%edx
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    37cc:	00 00                	add    %al,(%rax)
    37ce:	00 00                	add    %al,(%rax)
    37d0:	00 00                	add    %al,(%rax)
    37d2:	3a ac 01 ae 0c 00 00 	cmp    0xcae(%rcx,%rax,1),%ch
    37d9:	38 03                	cmp    %al,(%rbx)
    37db:	91                   	xchg   %eax,%ecx
    37dc:	cf                   	iret
    37dd:	53                   	push   %rbx
    37de:	0a 0c 00             	or     (%rax,%rax,1),%cl
    37e1:	00 3a                	add    %bh,(%rdx)
    37e3:	ad                   	lods   %ds:(%rsi),%eax
    37e4:	01 be 01 00 00 38    	add    %edi,0x38000001(%rsi)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    37ea:	03 91 c8 53 14 0c    	add    0xc1453c8(%rcx),%edx
    37f0:	00 00                	add    %al,(%rax)
    37f2:	38 03                	cmp    %al,(%rbx)
    37f4:	91                   	xchg   %eax,%ecx
    37f5:	c0 53 1d 0c          	rclb   $0xc,0x1d(%rbx)
    37f9:	00 00                	add    %al,(%rax)
    37fb:	3a ae 01 74 00 00    	cmp    0x7401(%rsi),%ch
    3801:	00 38                	add    %bh,(%rax)
  return true;
    3803:	03 91 b8 53 27 0c    	add    0xc2753b8(%rcx),%edx
    3809:	00 00                	add    %al,(%rax)
    380b:	3b 24 38             	cmp    (%rax,%rdi,1),%esp
    380e:	03 91 b4 53 31 0c    	add    0xc3153b4(%rcx),%edx
      return XDP_DROP;
    3814:	00 00                	add    %al,(%rax)
    3816:	3a af 01 4a 00 00    	cmp    0x4a01(%rdi),%ch
    381c:	00 38                	add    %bh,(%rax)
    381e:	03 91 b0 53 3b 0c    	add    0xc3b53b0(%rcx),%edx
  } else {
    3824:	00 00                	add    %al,(%rax)
    if (!PCKT_ENCAP_V4(xdp, cval, &pckt, dst, pkt_bytes)) {
    3826:	38 03                	cmp    %al,(%rbx)
    3828:	91                   	xchg   %eax,%ecx
    3829:	ac                   	lods   %ds:(%rsi),%al
    382a:	53                   	push   %rbx
    382b:	44 0c 00             	rex.R or $0x0,%al
    382e:	00 38                	add    %bh,(%rax)
    3830:	03 91 a8 53 4d 0c    	add    0xc4d53a8(%rcx),%edx
    3836:	00 00                	add    %al,(%rax)
    3838:	00 00                	add    %al,(%rax)
    383a:	00 36                	add    %dh,(%rsi)
    383c:	d4                   	(bad)
    383d:	16                   	(bad)
    383e:	00 00                	add    %al,(%rax)
    3840:	b0 01                	mov    $0x1,%al
    3842:	c2 00 00             	ret    $0x0
    3845:	00 00                	add    %al,(%rax)
    3847:	65 03 0b             	add    %gs:(%rbx),%ecx
    384a:	37                   	(bad)
    384b:	03 91 88 61 de 16    	add    0x16de6188(%rcx),%edx
    3851:	00 00                	add    %al,(%rax)
    3853:	37                   	(bad)
    3854:	03 91 80 61 e7 16    	add    0x16e76180(%rcx),%edx
    385a:	00 00                	add    %al,(%rax)
    385c:	37                   	(bad)
    385d:	03 91 ff 60 f0 16    	add    0x16f060ff(%rcx),%edx
    3863:	00 00                	add    %al,(%rax)
    3865:	38 03                	cmp    %al,(%rbx)
    3867:	91                   	xchg   %eax,%ecx
    3868:	f0 60                	lock (bad)
    386a:	f9                   	stc
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    386b:	16                   	(bad)
    386c:	00 00                	add    %al,(%rax)
    386e:	3a b1 01 58 00 00    	cmp    0x5801(%rcx),%dh
    3874:	00 38                	add    %bh,(%rax)
    3876:	03 91 e8 60 03 17    	add    0x170360e8(%rcx),%edx
    387c:	00 00                	add    %al,(%rax)
    387e:	00 3a                	add    %bh,(%rdx)
    3880:	b2 01                	mov    $0x1,%dl
    3882:	56                   	push   %rsi
    3883:	00 00                	add    %al,(%rax)
    3885:	00 38                	add    %bh,(%rax)
    3887:	03 91 e0 60 0e 17    	add    0x170e60e0(%rcx),%edx
  __u32 ip_suffix = bpf_htons(port);
    388d:	00 00                	add    %al,(%rax)
    388f:	00 00                	add    %al,(%rax)
    3891:	00 3a                	add    %bh,(%rdx)
    3893:	b3 01                	mov    $0x1,%bl
    3895:	c3                   	ret
    3896:	0a 00                	or     (%rax),%al
    3898:	00 38                	add    %bh,(%rax)
    389a:	03 91 9c 53 5b 0c    	add    0xc5b539c(%rcx),%edx
    38a0:	00 00                	add    %al,(%rax)
    38a2:	38 03                	cmp    %al,(%rbx)
    38a4:	91                   	xchg   %eax,%ecx
    38a5:	90                   	nop
    38a6:	53                   	push   %rbx
    38a7:	64 0c 00             	fs or  $0x0,%al
    38aa:	00 38                	add    %bh,(%rax)
  ip_suffix <<= 16;
    38ac:	03 91 e8 52 6d 0c    	add    0xc6d52e8(%rcx),%edx
    38b2:	00 00                	add    %al,(%rax)
    38b4:	3a b4 01 74 00 00 00 	cmp    0x74(%rcx,%rax,1),%dh
  ip_suffix ^= src;
    38bb:	38 03                	cmp    %al,(%rbx)
    38bd:	91                   	xchg   %eax,%ecx
    38be:	88 53 77             	mov    %dl,0x77(%rbx)
    38c1:	0c 00                	or     $0x0,%al
    38c3:	00 3b                	add    %bh,(%rbx)
    38c5:	25 38 03 91 84       	and    $0x84910338,%eax
    38ca:	53                   	push   %rbx
    38cb:	81 0c 00 00 3a b5 01 	orl    $0x1b53a00,(%rax,%rax,1)
  return ((0xFFFF0000 & ip_suffix) | IPIP_V4_PREFIX);
    38d2:	4a 00 00             	rex.WX add %al,(%rax)
    38d5:	00 38                	add    %bh,(%rax)
    38d7:	03 91 80 53 8b 0c    	add    0xc8b5380(%rcx),%edx
    38dd:	00 00                	add    %al,(%rax)
    38df:	38 03                	cmp    %al,(%rbx)
    38e1:	91                   	xchg   %eax,%ecx
    38e2:	fc                   	cld
    38e3:	52                   	push   %rdx
  __u64 csum = 0;
    38e4:	94                   	xchg   %eax,%esp
    38e5:	0c 00                	or     $0x0,%al
    38e7:	00 38                	add    %bh,(%rax)
    38e9:	03 91 f8 52 9d 0c    	add    0xc9d52f8(%rcx),%edx
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    38ef:	00 00                	add    %al,(%rax)
    38f1:	00 00                	add    %al,(%rax)
    38f3:	00 36                	add    %dh,(%rsi)
    38f5:	19 17                	sbb    %edx,(%rdi)
    38f7:	00 00                	add    %al,(%rax)
    38f9:	b6 01                	mov    $0x1,%dh
    38fb:	df 02                	filds  (%rdx)
    38fd:	00 00                	add    %al,(%rax)
    38ff:	00 6f 03             	add    %ch,0x3(%rdi)
    3902:	26 37                	es (bad)
    3904:	03 91 c0 62 23 17    	add    0x172362c0(%rcx),%edx
    390a:	00 00                	add    %al,(%rax)
    390c:	37                   	(bad)
    390d:	03 91 b8 62 2c 17    	add    0x172c62b8(%rcx),%edx
    return false;
    3913:	00 00                	add    %al,(%rax)
    3915:	37                   	(bad)
    3916:	03 91 b7 62 35 17    	add    0x173562b7(%rcx),%edx
  data = (void*)(long)xdp->data;
    391c:	00 00                	add    %al,(%rax)
    391e:	37                   	(bad)
    391f:	03 91 a8 62 3e 17    	add    0x173e62a8(%rcx),%edx
    3925:	00 00                	add    %al,(%rax)
    3927:	38 03                	cmp    %al,(%rbx)
    3929:	91                   	xchg   %eax,%ecx
    392a:	c8 62 47 17          	enter  $0x4762,$0x17
  data_end = (void*)(long)xdp->data_end;
    392e:	00 00                	add    %al,(%rax)
    3930:	38 03                	cmp    %al,(%rbx)
    3932:	91                   	xchg   %eax,%ecx
    3933:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    3934:	62 51 17 00 00       	(bad)
    3939:	38 03                	cmp    %al,(%rbx)
    393b:	91                   	xchg   %eax,%ecx
    393c:	98                   	cwtl
    393d:	62                   	(bad)
  new_eth = data;
    393e:	5a                   	pop    %rdx
    393f:	17                   	(bad)
    3940:	00 00                	add    %al,(%rax)
    3942:	38 03                	cmp    %al,(%rbx)
    3944:	91                   	xchg   %eax,%ecx
    3945:	90                   	nop
    3946:	62 63 17 00 00       	(bad)
    394b:	38 03                	cmp    %al,(%rbx)
  iph = data + sizeof(struct ethhdr);
    394d:	91                   	xchg   %eax,%ecx
    394e:	88 62 6d             	mov    %ah,0x6d(%rdx)
    3951:	17                   	(bad)
    3952:	00 00                	add    %al,(%rax)
    3954:	38 03                	cmp    %al,(%rbx)
    3956:	91                   	xchg   %eax,%ecx
    3957:	80 62 77 17          	andb   $0x17,0x77(%rdx)
    395b:	00 00                	add    %al,(%rax)
    395d:	38 03                	cmp    %al,(%rbx)
  old_eth = data + sizeof(struct iphdr);
    395f:	91                   	xchg   %eax,%ecx
    3960:	f7 61 81             	mull   -0x7f(%rcx)
    3963:	17                   	(bad)
    3964:	00 00                	add    %al,(%rax)
    3966:	36 3c 16             	ss cmp $0x16,%al
    3969:	00 00                	add    %al,(%rax)
    396b:	b7 01                	mov    $0x1,%bh
    396d:	79 00                	jns    396f <balancer_ingress+0x396f>
    396f:	00 00                	add    %al,(%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    3971:	09 60 01             	or     %esp,0x1(%rax)
    3974:	0f 37                	getsec
    3976:	03 91 87 78 45 16    	add    0x16457887(%rcx),%edx
    397c:	00 00                	add    %al,(%rax)
    397e:	37                   	(bad)
    397f:	03 91 86 78 4d 16    	add    0x164d7886(%rcx),%edx
    3985:	00 00                	add    %al,(%rax)
    3987:	38 03                	cmp    %al,(%rbx)
    3989:	91                   	xchg   %eax,%ecx
    398a:	f8                   	clc
    398b:	77 55                	ja     39e2 <balancer_ingress+0x39e2>
    398d:	16                   	(bad)
    398e:	00 00                	add    %al,(%rax)
    3990:	00 3a                	add    %bh,(%rdx)
    3992:	b8 01 6e 00 00       	mov    $0x6e01,%eax
    3997:	00 38                	add    %bh,(%rax)
    3999:	03 91 f8 61 8c 17    	add    0x178c61f8(%rcx),%edx
    399f:	00 00                	add    %al,(%rax)
    39a1:	00 00                	add    %al,(%rax)
    39a3:	3a b9 01 f1 05 00    	cmp    0x5f101(%rcx),%bh
    39a9:	00 38                	add    %bh,(%rax)
    39ab:	03 91 e4 52 aa 0c    	add    0xcaa52e4(%rcx),%edx
    39b1:	00 00                	add    %al,(%rax)
    39b3:	38 03                	cmp    %al,(%rbx)
    return false;
    39b5:	91                   	xchg   %eax,%ecx
    39b6:	d8 52 b3             	fcoms  -0x4d(%rdx)
    39b9:	0c 00                	or     $0x0,%al
    39bb:	00 36                	add    %dh,(%rsi)
    39bd:	98                   	cwtl
    39be:	17                   	(bad)
    39bf:	00 00                	add    %al,(%rax)
  memcpy(new_eth->h_dest, cval->mac, 6);
    39c1:	ba 01 76 00 00       	mov    $0x7601,%edx
    39c6:	00 00                	add    %al,(%rax)
    39c8:	73 03                	jae    39cd <balancer_ingress+0x39cd>
    39ca:	09 37                	or     %esi,(%rdi)
    39cc:	03 91 e8 62 9e 17    	add    0x179e62e8(%rcx),%edx
    39d2:	00 00                	add    %al,(%rax)
    39d4:	37                   	(bad)
    39d5:	03 91 e7 62 a7 17    	add    0x17a762e7(%rcx),%edx
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    39db:	00 00                	add    %al,(%rax)
    39dd:	00 3a                	add    %bh,(%rdx)
    39df:	bb 01 74 00 00       	mov    $0x7401,%ebx
    39e4:	00 38                	add    %bh,(%rax)
    39e6:	03 91 d0 52 bd 0c    	add    0xcbd52d0(%rcx),%edx
    39ec:	00 00                	add    %al,(%rax)
    39ee:	3b 26                	cmp    (%rsi),%esp
    39f0:	38 03                	cmp    %al,(%rbx)
    39f2:	91                   	xchg   %eax,%ecx
    39f3:	cc                   	int3
    39f4:	52                   	push   %rdx
    39f5:	c7                   	(bad)
  new_eth->h_proto = BE_ETH_P_IP;
    39f6:	0c 00                	or     $0x0,%al
    39f8:	00 3a                	add    %bh,(%rdx)
    39fa:	bc 01 4a 00 00       	mov    $0x4a01,%esp
    39ff:	00 38                	add    %bh,(%rax)
    3a01:	03 91 c8 52 d1 0c    	add    0xcd152c8(%rcx),%edx
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    3a07:	00 00                	add    %al,(%rax)
    3a09:	38 03                	cmp    %al,(%rbx)
    3a0b:	91                   	xchg   %eax,%ecx
    3a0c:	c4                   	(bad)
    3a0d:	52                   	push   %rdx
    3a0e:	da 0c 00             	fimull (%rax,%rax,1)
    3a11:	00 38                	add    %bh,(%rax)
    3a13:	03 91 c0 52 e3 0c    	add    0xce352c0(%rcx),%edx
    3a19:	00 00                	add    %al,(%rax)
    3a1b:	00 00                	add    %al,(%rax)
    3a1d:	00 3a                	add    %bh,(%rdx)
    3a1f:	bd 01 38 04 00       	mov    $0x43801,%ebp
    3a24:	00 38                	add    %bh,(%rax)
    3a26:	03 91 94 52 f0 0c    	add    0xcf05294(%rcx),%edx
    3a2c:	00 00                	add    %al,(%rax)
    3a2e:	3a be 01 74 00 00    	cmp    0x7401(%rsi),%bh
    3a34:	00 38                	add    %bh,(%rax)
    3a36:	03 91 b0 52 fa 0c    	add    0xcfa52b0(%rcx),%edx
    3a3c:	00 00                	add    %al,(%rax)
    3a3e:	3b 27                	cmp    (%rdi),%esp
  __u64 csum = 0;
    3a40:	38 03                	cmp    %al,(%rbx)
    3a42:	91                   	xchg   %eax,%ecx
    3a43:	ac                   	lods   %ds:(%rsi),%al
    3a44:	52                   	push   %rdx
    3a45:	04 0d                	add    $0xd,%al
    3a47:	00 00                	add    %al,(%rax)
  iph->version = 4;
    3a49:	3a bf 01 4a 00 00    	cmp    0x4a01(%rdi),%bh
    3a4f:	00 38                	add    %bh,(%rax)
    3a51:	03 91 a8 52 0e 0d    	add    0xd0e52a8(%rcx),%edx
  iph->ihl = 5;
    3a57:	00 00                	add    %al,(%rax)
    3a59:	38 03                	cmp    %al,(%rbx)
    3a5b:	91                   	xchg   %eax,%ecx
    3a5c:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    3a5d:	52                   	push   %rdx
    3a5e:	17                   	(bad)
    3a5f:	0d 00 00 38 03       	or     $0x3380000,%eax
  iph->frag_off = 0;
    3a64:	91                   	xchg   %eax,%ecx
    3a65:	a0 52 20 0d 00 00 00 	movabs 0xd2052,%al
    3a6c:	00 00 
  iph->protocol = proto;
    3a6e:	36 b1 17             	ss mov $0x17,%cl
    3a71:	00 00                	add    %al,(%rax)
    3a73:	c0 01 21             	rolb   $0x21,(%rcx)
    3a76:	02 00                	add    (%rax),%al
  iph->check = 0;
    3a78:	00 00                	add    %al,(%rax)
    3a7a:	89 03                	mov    %eax,(%rbx)
    3a7c:	17                   	(bad)
    3a7d:	37                   	(bad)
    3a7e:	03 91 d0 63 bb 17    	add    0x17bb63d0(%rcx),%edx
  iph->tos = tos;
    3a84:	00 00                	add    %al,(%rax)
    3a86:	37                   	(bad)
    3a87:	03 91 c8 63 c4 17    	add    0x17c463c8(%rcx),%edx
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    3a8d:	00 00                	add    %al,(%rax)
    3a8f:	38 03                	cmp    %al,(%rbx)
    3a91:	91                   	xchg   %eax,%ecx
    3a92:	c0 63 cd 17          	shlb   $0x17,-0x33(%rbx)
    3a96:	00 00                	add    %al,(%rax)
    3a98:	38 03                	cmp    %al,(%rbx)
    3a9a:	91                   	xchg   %eax,%ecx
    3a9b:	b8 63 d7 17 00       	mov    $0x17d763,%eax
    3aa0:	00 38                	add    %bh,(%rax)
    3aa2:	03 91 a8 63 e1 17    	add    0x17e163a8(%rcx),%edx
    3aa8:	00 00                	add    %al,(%rax)
    3aaa:	36 ec                	ss in  (%dx),%al
    3aac:	17                   	(bad)
    3aad:	00 00                	add    %al,(%rax)
    3aaf:	c1 01 2c             	roll   $0x2c,(%rcx)
  iph->id = 0;
    3ab2:	01 00                	add    %eax,(%rax)
    3ab4:	00 00                	add    %al,(%rax)
    3ab6:	74 02                	je     3aba <balancer_ingress+0x3aba>
    3ab8:	07                   	(bad)
    3ab9:	37                   	(bad)
    3aba:	03 91 88 7b f5 17    	add    0x17f57b88(%rcx),%edx
  iph->daddr = daddr;
    3ac0:	00 00                	add    %al,(%rax)
    3ac2:	38 03                	cmp    %al,(%rbx)
    3ac4:	91                   	xchg   %eax,%ecx
    3ac5:	84 7b fe             	test   %bh,-0x2(%rbx)
  iph->saddr = saddr;
    3ac8:	17                   	(bad)
    3ac9:	00 00                	add    %al,(%rax)
    3acb:	38 03                	cmp    %al,(%rbx)
    3acd:	91                   	xchg   %eax,%ecx
    3ace:	f8                   	clc
    3acf:	7a 07                	jp     3ad8 <balancer_ingress+0x3ad8>
  iph->ttl = DEFAULT_TTL;
    3ad1:	18 00                	sbb    %al,(%rax)
    3ad3:	00 3a                	add    %bh,(%rdx)
    3ad5:	c2 01 74             	ret    $0x7401
  ipv4_csum_inline(iph, &csum);
    3ad8:	00 00                	add    %al,(%rax)
    3ada:	00 38                	add    %bh,(%rax)
    3adc:	03 91 f0 7a 11 18    	add    0x18117af0(%rcx),%edx
    3ae2:	00 00                	add    %al,(%rax)
    3ae4:	3b 28                	cmp    (%rax),%ebp
    3ae6:	38 03                	cmp    %al,(%rbx)
  __u16* next_iph_u16 = (__u16*)iph;
    3ae8:	91                   	xchg   %eax,%ecx
    3ae9:	ec                   	in     (%dx),%al
    3aea:	7a 1a                	jp     3b06 <balancer_ingress+0x3b06>
    3aec:	18 00                	sbb    %al,(%rax)
    3aee:	00 3a                	add    %bh,(%rdx)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    3af0:	c3                   	ret
    3af1:	01 4a 00             	add    %ecx,0x0(%rdx)
    3af4:	00 00                	add    %al,(%rax)
    3af6:	38 03                	cmp    %al,(%rbx)
    3af8:	91                   	xchg   %eax,%ecx
    3af9:	e8 7a 23 18 00       	call   185e78 <bpf_xdp_adjust_head+0x17ded8>
    3afe:	00 38                	add    %bh,(%rax)
    3b00:	03 91 e4 7a 2b 18    	add    0x182b7ae4(%rcx),%edx
    *csum += *next_iph_u16++;
    3b06:	00 00                	add    %al,(%rax)
    3b08:	38 03                	cmp    %al,(%rbx)
    3b0a:	91                   	xchg   %eax,%ecx
    3b0b:	e0 7a                	loopne 3b87 <balancer_ingress+0x3b87>
    3b0d:	33 18                	xor    (%rax),%ebx
    3b0f:	00 00                	add    %al,(%rax)
    3b11:	00 00                	add    %al,(%rax)
    3b13:	00 00                	add    %al,(%rax)
    3b15:	00 36                	add    %dh,(%rsi)
    3b17:	3f                   	(bad)
    3b18:	18 00                	sbb    %al,(%rax)
    3b1a:	00 c4                	add    %al,%ah
    3b1c:	01 bd 00 00 00 00    	add    %edi,0x0(%rbp)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    3b22:	8e 03                	mov    (%rbx),%es
    3b24:	0f 37                	getsec
    3b26:	03 91 ec 64 45 18    	add    0x184564ec(%rcx),%edx
  *csum = csum_fold_helper(*csum);
    3b2c:	00 00                	add    %al,(%rax)
    3b2e:	37                   	(bad)
    3b2f:	03 91 eb 64 4e 18    	add    0x184e64eb(%rcx),%edx
  for (i = 0; i < 4; i++) {
    3b35:	00 00                	add    %al,(%rax)
    3b37:	37                   	(bad)
    3b38:	03 91 ea 64 58 18    	add    0x185864ea(%rcx),%edx
    3b3e:	00 00                	add    %al,(%rax)
    3b40:	38 03                	cmp    %al,(%rbx)
    if (csum >> 16)
    3b42:	91                   	xchg   %eax,%ecx
    3b43:	e0 64                	loopne 3ba9 <balancer_ingress+0x3ba9>
    3b45:	62                   	(bad)
    3b46:	18 00                	sbb    %al,(%rax)
    3b48:	00 3a                	add    %bh,(%rdx)
    3b4a:	c4 01 74 00          	(bad)
    3b4e:	00 00                	add    %al,(%rax)
      csum = (csum & 0xffff) + (csum >> 16);
    3b50:	38 03                	cmp    %al,(%rbx)
    3b52:	91                   	xchg   %eax,%ecx
    3b53:	d8 64 6d 18          	fsubs  0x18(%rbp,%rbp,2)
    3b57:	00 00                	add    %al,(%rax)
    3b59:	3b 29                	cmp    (%rcx),%ebp
    3b5b:	38 03                	cmp    %al,(%rbx)
    3b5d:	91                   	xchg   %eax,%ecx
    3b5e:	d4                   	(bad)
    3b5f:	64 77 18             	fs ja  3b7a <balancer_ingress+0x3b7a>
    3b62:	00 00                	add    %al,(%rax)
    3b64:	3a c5                	cmp    %ch,%al
    3b66:	01 4a 00             	add    %ecx,0x0(%rdx)
  for (i = 0; i < 4; i++) {
    3b69:	00 00                	add    %al,(%rax)
    3b6b:	38 03                	cmp    %al,(%rbx)
    3b6d:	91                   	xchg   %eax,%ecx
    3b6e:	d0 64 81 18          	shlb   0x18(%rcx,%rax,4)
    3b72:	00 00                	add    %al,(%rax)
  return ~csum;
    3b74:	38 03                	cmp    %al,(%rbx)
    3b76:	91                   	xchg   %eax,%ecx
    3b77:	cc                   	int3
    3b78:	64 8a 18             	mov    %fs:(%rax),%bl
    3b7b:	00 00                	add    %al,(%rax)
  *csum = csum_fold_helper(*csum);
    3b7d:	38 03                	cmp    %al,(%rbx)
    3b7f:	91                   	xchg   %eax,%ecx
    3b80:	c8 64 93 18          	enter  $0x9364,$0x18
	...
  iph->check = csum;
    3b8c:	36 3f                	ss (bad)
    3b8e:	18 00                	sbb    %al,(%rax)
    3b90:	00 c6                	add    %al,%dh
    3b92:	01 bd 00 00 00 00    	add    %edi,0x0(%rbp)
  return true;
    3b98:	a1 03 09 37 03 91 9c 	movabs 0x45659c9103370903,%eax
    3b9f:	65 45 
    3ba1:	18 00                	sbb    %al,(%rax)
    3ba3:	00 37                	add    %dh,(%rdi)
    3ba5:	03 91 9b 65 4e 18    	add    0x184e659b(%rcx),%edx
      return XDP_DROP;
    3bab:	00 00                	add    %al,(%rax)
    3bad:	37                   	(bad)
    3bae:	03 91 9a 65 58 18    	add    0x1858659a(%rcx),%edx
    3bb4:	00 00                	add    %al,(%rax)
  return XDP_TX;
    3bb6:	38 03                	cmp    %al,(%rbx)
    3bb8:	91                   	xchg   %eax,%ecx
    3bb9:	90                   	nop
    3bba:	65 62                	gs (bad)
    3bbc:	18 00                	sbb    %al,(%rax)
    3bbe:	00 3a                	add    %bh,(%rdx)
}
    3bc0:	c6 01 74             	movb   $0x74,(%rcx)
    3bc3:	00 00                	add    %al,(%rax)
    return process_packet(ctx, nh_off, false);
    3bc5:	00 38                	add    %bh,(%rax)
    3bc7:	03 91 88 65 6d 18    	add    0x186d6588(%rcx),%edx
    3bcd:	00 00                	add    %al,(%rax)
    3bcf:	3b 2a                	cmp    (%rdx),%ebp
  } else if (eth_proto == BE_ETH_P_IPV6) {
    3bd1:	38 03                	cmp    %al,(%rbx)
    3bd3:	91                   	xchg   %eax,%ecx
    3bd4:	84 65 77             	test   %ah,0x77(%rbp)
    3bd7:	18 00                	sbb    %al,(%rax)
    3bd9:	00 3a                	add    %bh,(%rdx)
    3bdb:	c7 01 4a 00 00 00    	movl   $0x4a,(%rcx)
    return process_packet(ctx, nh_off, true);
    3be1:	38 03                	cmp    %al,(%rbx)
    3be3:	91                   	xchg   %eax,%ecx
    3be4:	80 65 81 18          	andb   $0x18,-0x7f(%rbp)
    3be8:	00 00                	add    %al,(%rax)
    3bea:	38 03                	cmp    %al,(%rbx)
    3bec:	91                   	xchg   %eax,%ecx
    3bed:	fc                   	cld
    3bee:	64 8a 18             	mov    %fs:(%rax),%bl
    3bf1:	00 00                	add    %al,(%rax)
    3bf3:	38 03                	cmp    %al,(%rbx)
    3bf5:	91                   	xchg   %eax,%ecx
    3bf6:	f8                   	clc
    3bf7:	64 93                	fs xchg %eax,%ebx
    3bf9:	18 00                	sbb    %al,(%rax)
    3bfb:	00 00                	add    %al,(%rax)
    3bfd:	00 00                	add    %al,(%rax)
    3bff:	00 00                	add    %al,(%rax)
    3c01:	00 36                	add    %dh,(%rsi)
  void* data = (void*)(long)xdp->data;
    3c03:	a0 18 00 00 c8 01 37 	movabs 0x13701c8000018,%al
    3c0a:	01 00 
    3c0c:	00 00                	add    %al,(%rax)
    3c0e:	d7                   	xlat   %ds:(%rbx)
    3c0f:	03 07                	add    (%rdi),%eax
    3c11:	37                   	(bad)
    3c12:	03 91 c8 66 a5 18    	add    0x18a566c8(%rcx),%edx
  void* data_end = (void*)(long)xdp->data_end;
    3c18:	00 00                	add    %al,(%rax)
    3c1a:	37                   	(bad)
    3c1b:	03 91 c0 66 ae 18    	add    0x18ae66c0(%rcx),%edx
    3c21:	00 00                	add    %al,(%rax)
    3c23:	37                   	(bad)
    3c24:	03 91 b8 66 b6 18    	add    0x18b666b8(%rcx),%edx
  struct real_definition* dst = NULL;
    3c2a:	00 00                	add    %al,(%rax)
    3c2c:	37                   	(bad)
    3c2d:	03 91 b7 66 be 18    	add    0x18be66b7(%rcx),%edx
  struct packet_description pckt = {};
    3c33:	00 00                	add    %al,(%rax)
    3c35:	38 03                	cmp    %al,(%rbx)
    3c37:	91                   	xchg   %eax,%ecx
    3c38:	a8 66                	test   $0x66,%al
    3c3a:	c7                   	(bad)
    3c3b:	18 00                	sbb    %al,(%rax)
    3c3d:	00 38                	add    %bh,(%rax)
    3c3f:	03 91 a0 66 d0 18    	add    0x18d066a0(%rcx),%edx
    3c45:	00 00                	add    %al,(%rax)
    3c47:	38 03                	cmp    %al,(%rbx)
    3c49:	91                   	xchg   %eax,%ecx
    3c4a:	9c                   	pushf
    3c4b:	66 d9 18             	data16 fstps (%rax)
    3c4e:	00 00                	add    %al,(%rax)
    3c50:	3a c9                	cmp    %cl,%cl
    3c52:	01 74 00 00          	add    %esi,0x0(%rax,%rax,1)
    3c56:	00 38                	add    %bh,(%rax)
    3c58:	03 91 90 66 e2 18    	add    0x18e26690(%rcx),%edx
    3c5e:	00 00                	add    %al,(%rax)
    3c60:	3b 2b                	cmp    (%rbx),%ebp
    3c62:	38 03                	cmp    %al,(%rbx)
    3c64:	91                   	xchg   %eax,%ecx
    3c65:	8c 66 eb             	mov    %fs,-0x15(%rsi)
  struct vip_definition vip = {};
    3c68:	18 00                	sbb    %al,(%rax)
    3c6a:	00 3a                	add    %bh,(%rdx)
    3c6c:	ca 01 4a             	lret   $0x4a01
    3c6f:	00 00                	add    %al,(%rax)
    3c71:	00 38                	add    %bh,(%rax)
    3c73:	03 91 88 66 f4 18    	add    0x18f46688(%rcx),%edx
    3c79:	00 00                	add    %al,(%rax)
    3c7b:	38 03                	cmp    %al,(%rbx)
    3c7d:	91                   	xchg   %eax,%ecx
    3c7e:	84 66 fc             	test   %ah,-0x4(%rsi)
    3c81:	18 00                	sbb    %al,(%rax)
    3c83:	00 38                	add    %bh,(%rax)
    3c85:	03 91 80 66 04 19    	add    0x19046680(%rcx),%edx
  __u32 mac_addr_pos = 0;
    3c8b:	00 00                	add    %al,(%rax)
    3c8d:	00 00                	add    %al,(%rax)
    3c8f:	00 00                	add    %al,(%rax)
  __u64 th_off = 0;
    3c91:	36 15 19 00 00 cb    	ss adc $0xcb000019,%eax
    3c97:	01 f6                	add    %esi,%esi
    3c99:	02 00                	add    (%rax),%al
    3c9b:	00 00                	add    %al,(%rax)
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
    3c9d:	e4 03                	in     $0x3,%al
    3c9f:	05 37 03 91 d8       	add    $0xd8910337,%eax
    3ca4:	68 1f 19 00 00       	push   $0x191f
    3ca9:	37                   	(bad)
    3caa:	03 91 d0 68 28 19    	add    0x192868d0(%rcx),%edx
    3cb0:	00 00                	add    %al,(%rax)
    3cb2:	37                   	(bad)
    3cb3:	03 91 c8 68 31 19    	add    0x193168c8(%rcx),%edx
    3cb9:	00 00                	add    %al,(%rax)
    3cbb:	37                   	(bad)
    3cbc:	03 91 c0 68 3a 19    	add    0x193a68c0(%rcx),%edx
    3cc2:	00 00                	add    %al,(%rax)
    3cc4:	38 03                	cmp    %al,(%rbx)
    3cc6:	91                   	xchg   %eax,%ecx
    3cc7:	b8 68 43 19 00       	mov    $0x194368,%eax
    3ccc:	00 36                	add    %dh,(%rsi)
    3cce:	ec                   	in     (%dx),%al
    3ccf:	17                   	(bad)
    3cd0:	00 00                	add    %al,(%rax)
    3cd2:	cc                   	int3
    3cd3:	01 2c 01             	add    %ebp,(%rcx,%rax,1)
    3cd6:	00 00                	add    %al,(%rax)
    3cd8:	00 93 02 32 37 03    	add    %dl,0x3373202(%rbx)
    3cde:	91                   	xchg   %eax,%ecx
    3cdf:	88 7a f5             	mov    %bh,-0xb(%rdx)
    3ce2:	17                   	(bad)
    3ce3:	00 00                	add    %al,(%rax)
    3ce5:	38 03                	cmp    %al,(%rbx)
    3ce7:	91                   	xchg   %eax,%ecx
    3ce8:	84 7a fe             	test   %bh,-0x2(%rdx)
    3ceb:	17                   	(bad)
    3cec:	00 00                	add    %al,(%rax)
    3cee:	38 03                	cmp    %al,(%rbx)
    3cf0:	91                   	xchg   %eax,%ecx
    3cf1:	f8                   	clc
    3cf2:	79 07                	jns    3cfb <balancer_ingress+0x3cfb>
    3cf4:	18 00                	sbb    %al,(%rax)
    3cf6:	00 3a                	add    %bh,(%rdx)
    3cf8:	cd 01                	int    $0x1
    3cfa:	74 00                	je     3cfc <balancer_ingress+0x3cfc>
    3cfc:	00 00                	add    %al,(%rax)
    3cfe:	38 03                	cmp    %al,(%rbx)
    3d00:	91                   	xchg   %eax,%ecx
    3d01:	f0 79 11             	lock jns 3d15 <balancer_ingress+0x3d15>
    3d04:	18 00                	sbb    %al,(%rax)
    3d06:	00 3b                	add    %bh,(%rbx)
    3d08:	2c 38                	sub    $0x38,%al
    3d0a:	03 91 ec 79 1a 18    	add    0x181a79ec(%rcx),%edx
  if (is_ipv6) {
    3d10:	00 00                	add    %al,(%rax)
    3d12:	3a ce                	cmp    %dh,%cl
    3d14:	01 4a 00             	add    %ecx,0x0(%rdx)
    3d17:	00 00                	add    %al,(%rax)
    ip6h = data + nh_off;
    3d19:	38 03                	cmp    %al,(%rbx)
    3d1b:	91                   	xchg   %eax,%ecx
    3d1c:	e8 79 23 18 00       	call   18609a <bpf_xdp_adjust_head+0x17e0fa>
    3d21:	00 38                	add    %bh,(%rax)
    3d23:	03 91 e4 79 2b 18    	add    0x182b79e4(%rcx),%edx
    3d29:	00 00                	add    %al,(%rax)
    3d2b:	38 03                	cmp    %al,(%rbx)
    3d2d:	91                   	xchg   %eax,%ecx
    if (ip6h + 1 > data_end) {
    3d2e:	e0 79                	loopne 3da9 <balancer_ingress+0x3da9>
    3d30:	33 18                	xor    (%rax),%ebx
    3d32:	00 00                	add    %al,(%rax)
    3d34:	00 00                	add    %al,(%rax)
    3d36:	00 00                	add    %al,(%rax)
    3d38:	3a cf                	cmp    %bh,%cl
    3d3a:	01 76 01             	add    %esi,0x1(%rsi)
    3d3d:	00 00                	add    %al,(%rax)
    3d3f:	38 03                	cmp    %al,(%rbx)
    3d41:	91                   	xchg   %eax,%ecx
    3d42:	b0 68                	mov    $0x68,%al
    3d44:	4e 19 00             	rex.WRX sbb %r8,(%rax)
      return XDP_DROP;
    3d47:	00 3a                	add    %bh,(%rdx)
    3d49:	cf                   	iret
    3d4a:	01 77 00             	add    %esi,0x0(%rdi)
    3d4d:	00 00                	add    %al,(%rax)
    3d4f:	38 03                	cmp    %al,(%rbx)
    3d51:	91                   	xchg   %eax,%ecx
    3d52:	a8 68                	test   $0x68,%al
    iph_len = sizeof(struct ipv6hdr);
    3d54:	59                   	pop    %rcx
    3d55:	19 00                	sbb    %eax,(%rax)
    3d57:	00 3b                	add    %bh,(%rbx)
    3d59:	2d 38 03 91 a4       	sub    $0xa4910338,%eax
    3d5e:	68 63 19 00 00       	push   $0x1963
    *protocol = ip6h->nexthdr;
    3d63:	3a d0                	cmp    %al,%dl
    3d65:	01 4d 00             	add    %ecx,0x0(%rbp)
    3d68:	00 00                	add    %al,(%rax)
    3d6a:	38 03                	cmp    %al,(%rbx)
    3d6c:	91                   	xchg   %eax,%ecx
    3d6d:	a0 68 6d 19 00 00 38 	movabs 0x9103380000196d68,%al
    3d74:	03 91 
    pckt->flow.proto = *protocol;
    3d76:	9c                   	pushf
    3d77:	68 76 19 00 00       	push   $0x1976
    3d7c:	38 03                	cmp    %al,(%rbx)
    3d7e:	91                   	xchg   %eax,%ecx
    3d7f:	98                   	cwtl
    3d80:	68 7f 19 00 00       	push   $0x197f
    pckt->tos = (ip6h->priority << 4) & 0xF0;
    3d85:	00 00                	add    %al,(%rax)
    3d87:	00 3a                	add    %bh,(%rdx)
    3d89:	d1 01                	roll   (%rcx)
    3d8b:	e8 00 00 00 38       	call   38003d90 <bpf_xdp_adjust_head+0x37ffbdf0>
    3d90:	03 91 88 68 8c 19    	add    0x198c6888(%rcx),%edx
    3d96:	00 00                	add    %al,(%rax)
    3d98:	3a d2                	cmp    %dl,%dl
    3d9a:	01 b0 00 00 00 38    	add    %esi,0x38000000(%rax)
    3da0:	03 91 84 68 97 19    	add    0x19976884(%rcx),%edx
    3da6:	00 00                	add    %al,(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
    3da8:	38 03                	cmp    %al,(%rbx)
    3daa:	91                   	xchg   %eax,%ecx
    3dab:	f8                   	clc
    3dac:	67 a0 19 00 00 3a    	addr32 mov 0x3a000019,%al
    3db2:	d3 01                	roll   %cl,(%rcx)
    3db4:	74 00                	je     3db6 <balancer_ingress+0x3db6>
    3db6:	00 00                	add    %al,(%rax)
    3db8:	38 03                	cmp    %al,(%rbx)
    3dba:	91                   	xchg   %eax,%ecx
    3dbb:	f0 67 ab             	lock stos %eax,%es:(%edi)
    3dbe:	19 00                	sbb    %eax,(%rax)
    3dc0:	00 3b                	add    %bh,(%rbx)
    3dc2:	2e 38 03             	cs cmp %al,(%rbx)
    3dc5:	91                   	xchg   %eax,%ecx
    3dc6:	ec                   	in     (%dx),%al
    3dc7:	67 b5 19             	addr32 mov $0x19,%ch
    3dca:	00 00                	add    %al,(%rax)
    3dcc:	3a d4                	cmp    %ah,%dl
    3dce:	01 4a 00             	add    %ecx,0x0(%rdx)
    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
    3dd1:	00 00                	add    %al,(%rax)
    3dd3:	38 03                	cmp    %al,(%rbx)
    3dd5:	91                   	xchg   %eax,%ecx
    3dd6:	e8 67 bf 19 00       	call   19fd42 <bpf_xdp_adjust_head+0x197da2>
    3ddb:	00 38                	add    %bh,(%rax)
    3ddd:	03 91 e4 67 c8 19    	add    0x19c867e4(%rcx),%edx
    3de3:	00 00                	add    %al,(%rax)
    3de5:	38 03                	cmp    %al,(%rbx)
    3de7:	91                   	xchg   %eax,%ecx
    3de8:	e0 67                	loopne 3e51 <balancer_ingress+0x3e51>
    3dea:	d1 19                	rcrl   (%rcx)
	...
    3df4:	00 3a                	add    %bh,(%rdx)
    3df6:	d5                   	(bad)
    3df7:	01 d5                	add    %edx,%ebp
    3df9:	00 00                	add    %al,(%rax)
    3dfb:	00 38                	add    %bh,(%rax)
    *th_off += nh_off + iph_len;
    3dfd:	03 91 90 52 31 0d    	add    0xd315290(%rcx),%edx
    3e03:	00 00                	add    %al,(%rax)
    3e05:	38 03                	cmp    %al,(%rbx)
    3e07:	91                   	xchg   %eax,%ecx
    3e08:	88 52 3a             	mov    %dl,0x3a(%rdx)
    3e0b:	0d 00 00 3a d6       	or     $0xd63a0000,%eax
    3e10:	01 74 00 00          	add    %esi,0x0(%rax,%rax,1)
    3e14:	00 38                	add    %bh,(%rax)
    3e16:	03 91 80 52 44 0d    	add    0xd445280(%rcx),%edx
    if (*protocol == IPPROTO_FRAGMENT) {
    3e1c:	00 00                	add    %al,(%rax)
    3e1e:	3b 2f                	cmp    (%rdi),%ebp
    3e20:	38 03                	cmp    %al,(%rbx)
    3e22:	91                   	xchg   %eax,%ecx
    3e23:	fc                   	cld
    3e24:	51                   	push   %rcx
    3e25:	4e 0d 00 00 3a d7    	rex.WRX or $0xffffffffd73a0000,%rax
      return XDP_DROP;
    3e2b:	01 4a 00             	add    %ecx,0x0(%rdx)
    3e2e:	00 00                	add    %al,(%rax)
    3e30:	38 03                	cmp    %al,(%rbx)
    3e32:	91                   	xchg   %eax,%ecx
    3e33:	f8                   	clc
    3e34:	51                   	push   %rcx
    } else if (*protocol == IPPROTO_ICMPV6) {
    3e35:	58                   	pop    %rax
    3e36:	0d 00 00 38 03       	or     $0x3380000,%eax
    3e3b:	91                   	xchg   %eax,%ecx
    3e3c:	f4                   	hlt
    3e3d:	51                   	push   %rcx
    3e3e:	61                   	(bad)
    3e3f:	0d 00 00 38 03       	or     $0x3380000,%eax
      return FURTHER_PROCESSING;
    3e44:	91                   	xchg   %eax,%ecx
    3e45:	f0 51                	lock push %rcx
    3e47:	6a 0d                	push   $0xd
    3e49:	00 00                	add    %al,(%rax)
    3e4b:	00 00                	add    %al,(%rax)
    3e4d:	00 00                	add    %al,(%rax)
    3e4f:	36 e1 19             	ss loope 3e6b <balancer_ingress+0x3e6b>
    3e52:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
    3e54:	d8 01                	fadds  (%rcx)
    3e56:	a2 05 00 00 00 fa 03 	movabs %al,0x370c03fa00000005
    3e5d:	0c 37 
    3e5f:	03 91 a0 6b ea 19    	add    0x19ea6ba0(%rcx),%edx
    3e65:	00 00                	add    %al,(%rax)
    3e67:	37                   	(bad)
    3e68:	03 91 98 6b f3 19    	add    0x19f36b98(%rcx),%edx
    3e6e:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
    3e70:	37                   	(bad)
    3e71:	03 91 90 6b fb 19    	add    0x19fb6b90(%rcx),%edx
    3e77:	00 00                	add    %al,(%rax)
    3e79:	37                   	(bad)
    3e7a:	03 91 8f 6b 03 1a    	add    0x1a036b8f(%rcx),%edx
    3e80:	00 00                	add    %al,(%rax)
    3e82:	37                   	(bad)
    3e83:	03 91 80 6b 0b 1a    	add    0x1a0b6b80(%rcx),%edx
    3e89:	00 00                	add    %al,(%rax)
    3e8b:	38 03                	cmp    %al,(%rbx)
    3e8d:	91                   	xchg   %eax,%ecx
  } else {
    3e8e:	f0 6a 13             	lock push $0x13
    3e91:	1a 00                	sbb    (%rax),%al
    iph = data + nh_off;
    3e93:	00 38                	add    %bh,(%rax)
    3e95:	03 91 ef 6a 1c 1a    	add    0x1a1c6aef(%rcx),%edx
    3e9b:	00 00                	add    %al,(%rax)
    3e9d:	38 03                	cmp    %al,(%rbx)
    3e9f:	91                   	xchg   %eax,%ecx
    3ea0:	ee                   	out    %al,(%dx)
    3ea1:	6a 25                	push   $0x25
    3ea3:	1a 00                	sbb    (%rax),%al
    3ea5:	00 38                	add    %bh,(%rax)
    3ea7:	03 91 e0 6a 2e 1a    	add    0x1a2e6ae0(%rcx),%edx
    if (iph + 1 > data_end) {
    3ead:	00 00                	add    %al,(%rax)
    3eaf:	38 03                	cmp    %al,(%rbx)
    3eb1:	91                   	xchg   %eax,%ecx
    3eb2:	d8 6a 36             	fsubrs 0x36(%rdx)
    3eb5:	1a 00                	sbb    (%rax),%al
    3eb7:	00 38                	add    %bh,(%rax)
    3eb9:	03 91 d4 6a 3f 1a    	add    0x1a3f6ad4(%rcx),%edx
      return XDP_DROP;
    3ebf:	00 00                	add    %al,(%rax)
    3ec1:	38 03                	cmp    %al,(%rbx)
    3ec3:	91                   	xchg   %eax,%ecx
    3ec4:	d0 6a 48             	shrb   0x48(%rdx)
    3ec7:	1a 00                	sbb    (%rax),%al
    3ec9:	00 39                	add    %bh,(%rcx)
    3ecb:	ec                   	in     (%dx),%al
    3ecc:	17                   	(bad)
    3ecd:	00 00                	add    %al,(%rax)
    if (iph->ihl != 5) {
    3ecf:	d9 01                	flds   (%rcx)
    3ed1:	32 01                	xor    (%rcx),%al
    3ed3:	00 00                	add    %al,(%rax)
    3ed5:	00 66 11             	add    %ah,0x11(%rsi)
    3ed8:	37                   	(bad)
    3ed9:	03 91 88 79 f5 17    	add    0x17f57988(%rcx),%edx
    3edf:	00 00                	add    %al,(%rax)
      return XDP_DROP;
    3ee1:	38 03                	cmp    %al,(%rbx)
    3ee3:	91                   	xchg   %eax,%ecx
    3ee4:	84 79 fe             	test   %bh,-0x2(%rcx)
    3ee7:	17                   	(bad)
    3ee8:	00 00                	add    %al,(%rax)
    3eea:	38 03                	cmp    %al,(%rbx)
    3eec:	91                   	xchg   %eax,%ecx
    3eed:	f8                   	clc
    3eee:	78 07                	js     3ef7 <balancer_ingress+0x3ef7>
    pckt->tos = iph->tos;
    3ef0:	18 00                	sbb    %al,(%rax)
    3ef2:	00 3a                	add    %bh,(%rdx)
    3ef4:	da 01                	fiaddl (%rcx)
    3ef6:	74 00                	je     3ef8 <balancer_ingress+0x3ef8>
    3ef8:	00 00                	add    %al,(%rax)
    3efa:	38 03                	cmp    %al,(%rbx)
    3efc:	91                   	xchg   %eax,%ecx
    3efd:	f0 78 11             	lock js 3f11 <balancer_ingress+0x3f11>
    3f00:	18 00                	sbb    %al,(%rax)
    3f02:	00 3b                	add    %bh,(%rbx)
    *protocol = iph->protocol;
    3f04:	30 38                	xor    %bh,(%rax)
    3f06:	03 91 ec 78 1a 18    	add    0x181a78ec(%rcx),%edx
    3f0c:	00 00                	add    %al,(%rax)
    3f0e:	3a db                	cmp    %bl,%bl
    3f10:	01 4a 00             	add    %ecx,0x0(%rdx)
    3f13:	00 00                	add    %al,(%rax)
    3f15:	38 03                	cmp    %al,(%rbx)
    pckt->flow.proto = *protocol;
    3f17:	91                   	xchg   %eax,%ecx
    3f18:	e8 78 23 18 00       	call   186295 <bpf_xdp_adjust_head+0x17e2f5>
    3f1d:	00 38                	add    %bh,(%rax)
    3f1f:	03 91 e4 78 2b 18    	add    0x182b78e4(%rcx),%edx
    3f25:	00 00                	add    %al,(%rax)
    3f27:	38 03                	cmp    %al,(%rbx)
    3f29:	91                   	xchg   %eax,%ecx
    *pkt_bytes = bpf_ntohs(iph->tot_len);
    3f2a:	e0 78                	loopne 3fa4 <balancer_ingress+0x3fa4>
    3f2c:	33 18                	xor    (%rax),%ebx
    3f2e:	00 00                	add    %al,(%rax)
    3f30:	00 00                	add    %al,(%rax)
    3f32:	00 00                	add    %al,(%rax)
    3f34:	3a dc                	cmp    %ah,%bl
    3f36:	01 57 02             	add    %edx,0x2(%rdi)
    3f39:	00 00                	add    %al,(%rax)
    3f3b:	38 03                	cmp    %al,(%rbx)
    3f3d:	91                   	xchg   %eax,%ecx
    3f3e:	cf                   	iret
    3f3f:	6a 51                	push   $0x51
    3f41:	1a 00                	sbb    (%rax),%al
    3f43:	00 39                	add    %bh,(%rcx)
    3f45:	b8 1a 00 00 dd       	mov    $0xdd00001a,%eax
    3f4a:	01 66 00             	add    %esp,0x0(%rsi)
    3f4d:	00 00                	add    %al,(%rax)
    3f4f:	00 8f 0c 37 03 91    	add    %cl,-0x6efcc8f4(%rdi)
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;
    3f55:	d8 7b c1             	fdivrs -0x3f(%rbx)
    3f58:	1a 00                	sbb    (%rax),%al
    3f5a:	00 37                	add    %dh,(%rdi)
    3f5c:	03 91 d7 7b c9 1a    	add    0x1ac97bd7(%rcx),%edx
    3f62:	00 00                	add    %al,(%rax)
    3f64:	00 3a                	add    %bh,(%rdx)
    3f66:	de 01                	fiadds (%rcx)
    3f68:	74 00                	je     3f6a <balancer_ingress+0x3f6a>
    3f6a:	00 00                	add    %al,(%rax)
    3f6c:	38 03                	cmp    %al,(%rbx)
    if (iph->frag_off & PCKT_FRAGMENTED) {
    3f6e:	91                   	xchg   %eax,%ecx
    3f6f:	c0 6a 5b 1a          	shrb   $0x1a,0x5b(%rdx)
    3f73:	00 00                	add    %al,(%rax)
    3f75:	3b 31                	cmp    (%rcx),%esi
    3f77:	38 03                	cmp    %al,(%rbx)
    3f79:	91                   	xchg   %eax,%ecx
    3f7a:	bc 6a 64 1a 00       	mov    $0x1a646a,%esp
    3f7f:	00 3a                	add    %bh,(%rdx)
    3f81:	df 01                	filds  (%rcx)
      return XDP_DROP;
    3f83:	4a 00 00             	rex.WX add %al,(%rax)
    3f86:	00 38                	add    %bh,(%rax)
    3f88:	03 91 b8 6a 6d 1a    	add    0x1a6d6ab8(%rcx),%edx
    if (*protocol == IPPROTO_ICMP) {
    3f8e:	00 00                	add    %al,(%rax)
    3f90:	38 03                	cmp    %al,(%rbx)
    3f92:	91                   	xchg   %eax,%ecx
    3f93:	b4 6a                	mov    $0x6a,%ah
    3f95:	75 1a                	jne    3fb1 <balancer_ingress+0x3fb1>
    3f97:	00 00                	add    %al,(%rax)
    3f99:	38 03                	cmp    %al,(%rbx)
    3f9b:	91                   	xchg   %eax,%ecx
    3f9c:	b0 6a                	mov    $0x6a,%al
      return FURTHER_PROCESSING;
    3f9e:	7d 1a                	jge    3fba <balancer_ingress+0x3fba>
    3fa0:	00 00                	add    %al,(%rax)
    3fa2:	00 00                	add    %al,(%rax)
    3fa4:	00 39                	add    %bh,(%rcx)
    3fa6:	d3 1a                	rcrl   %cl,(%rdx)
    3fa8:	00 00                	add    %al,(%rax)
      pckt->flow.src = iph->saddr;
    3faa:	e0 01                	loopne 3fad <balancer_ingress+0x3fad>
    3fac:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    3fad:	00 00                	add    %al,(%rax)
    3faf:	00 00                	add    %al,(%rax)
    3fb1:	9a                   	(bad)
    3fb2:	07                   	(bad)
    3fb3:	38 03                	cmp    %al,(%rbx)
    3fb5:	91                   	xchg   %eax,%ecx
    3fb6:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    3fb7:	7c d8                	jl     3f91 <balancer_ingress+0x3f91>
    3fb9:	1a 00                	sbb    (%rax),%al
    3fbb:	00 38                	add    %bh,(%rax)
      pckt->flow.dst = iph->daddr;
    3fbd:	03 91 98 7c e1 1a    	add    0x1ae17c98(%rcx),%edx
    3fc3:	00 00                	add    %al,(%rax)
    3fc5:	3a e1                	cmp    %cl,%ah
    3fc7:	01 74 00 00          	add    %esi,0x0(%rax,%rax,1)
    3fcb:	00 38                	add    %bh,(%rax)
    3fcd:	03 91 90 7c eb 1a    	add    0x1aeb7c90(%rcx),%edx
  return FURTHER_PROCESSING;
    3fd3:	00 00                	add    %al,(%rax)
    3fd5:	3b 32                	cmp    (%rdx),%esi
    3fd7:	38 03                	cmp    %al,(%rbx)
    3fd9:	91                   	xchg   %eax,%ecx
}
    3fda:	8c 7c f4 1a          	mov    %?,0x1a(%rsp,%rsi,8)
    3fde:	00 00                	add    %al,(%rax)
  action = parse_l3_headers(
    3fe0:	3a e2                	cmp    %dl,%ah
    3fe2:	01 4a 00             	add    %ecx,0x0(%rdx)
    3fe5:	00 00                	add    %al,(%rax)
  if (action >= 0) {
    3fe7:	38 03                	cmp    %al,(%rbx)
    3fe9:	91                   	xchg   %eax,%ecx
    3fea:	88 7c fd 1a          	mov    %bh,0x1a(%rbp,%rdi,8)
    3fee:	00 00                	add    %al,(%rax)
    return action;
    3ff0:	38 03                	cmp    %al,(%rbx)
    3ff2:	91                   	xchg   %eax,%ecx
    3ff3:	84 7c 05 1b          	test   %bh,0x1b(%rbp,%rax,1)
    3ff7:	00 00                	add    %al,(%rax)
    3ff9:	38 03                	cmp    %al,(%rbx)
    3ffb:	91                   	xchg   %eax,%ecx
    3ffc:	80 7c 0d 1b 00       	cmpb   $0x0,0x1b(%rbp,%rcx,1)
  action = handle_if_icmp(data, data_end, th_off, &pckt, protocol);
    4001:	00 00                	add    %al,(%rax)
    4003:	00 00                	add    %al,(%rax)
    4005:	00 00                	add    %al,(%rax)
    4007:	3a e3                	cmp    %bl,%ah
    4009:	01 74 00 00          	add    %esi,0x0(%rax,%rax,1)
    400d:	00 38                	add    %bh,(%rax)
    400f:	03 91 a0 6a 8a 1a    	add    0x1a8a6aa0(%rcx),%edx
    4015:	00 00                	add    %al,(%rax)
    4017:	3b 33                	cmp    (%rbx),%esi
    4019:	38 03                	cmp    %al,(%rbx)
    401b:	91                   	xchg   %eax,%ecx
    401c:	9c                   	pushf
    401d:	6a 93                	push   $0xffffffffffffff93
    401f:	1a 00                	sbb    (%rax),%al
    4021:	00 3a                	add    %bh,(%rdx)
    4023:	e4 01                	in     $0x1,%al
    4025:	4a 00 00             	rex.WX add %al,(%rax)
    4028:	00 38                	add    %bh,(%rax)
    402a:	03 91 98 6a 9c 1a    	add    0x1a9c6a98(%rcx),%edx
    4030:	00 00                	add    %al,(%rax)
    4032:	38 03                	cmp    %al,(%rbx)
    4034:	91                   	xchg   %eax,%ecx
    4035:	94                   	xchg   %eax,%esp
    4036:	6a a4                	push   $0xffffffffffffffa4
    4038:	1a 00                	sbb    (%rax),%al
    403a:	00 38                	add    %bh,(%rax)
    403c:	03 91 90 6a ac 1a    	add    0x1aac6a90(%rcx),%edx
    4042:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
    4044:	00 00                	add    %al,(%rax)
    4046:	00 39                	add    %bh,(%rcx)
    4048:	19 1b                	sbb    %ebx,(%rbx)
    404a:	00 00                	add    %al,(%rax)
    404c:	e5 01                	in     $0x1,%eax
    404e:	a2 00 00 00 00 a3 05 	movabs %al,0x33805a300000000
    4055:	38 03 
    return parse_icmpv6(data, data_end, off, pckt);
    4057:	91                   	xchg   %eax,%ecx
    4058:	84 7d 1e             	test   %bh,0x1e(%rbp)
    405b:	1b 00                	sbb    (%rax),%eax
    405d:	00 38                	add    %bh,(%rax)
    405f:	03 91 f8 7c 27 1b    	add    0x1b277cf8(%rcx),%edx
    4065:	00 00                	add    %al,(%rax)
    4067:	3a e6                	cmp    %dh,%ah
    4069:	01 74 00 00          	add    %esi,0x0(%rax,%rax,1)
    406d:	00 38                	add    %bh,(%rax)
    406f:	03 91 f0 7c 31 1b    	add    0x1b317cf0(%rcx),%edx
    4075:	00 00                	add    %al,(%rax)
    4077:	3b 34 38             	cmp    (%rax,%rdi,1),%esi
    407a:	03 91 ec 7c 3a 1b    	add    0x1b3a7cec(%rcx),%edx
    4080:	00 00                	add    %al,(%rax)
    4082:	3a e7                	cmp    %bh,%ah
    4084:	01 4a 00             	add    %ecx,0x0(%rdx)
    4087:	00 00                	add    %al,(%rax)
    4089:	38 03                	cmp    %al,(%rbx)
    408b:	91                   	xchg   %eax,%ecx
  icmp_hdr = data + off;
    408c:	e8 7c 43 1b 00       	call   1b840d <bpf_xdp_adjust_head+0x1b046d>
    4091:	00 38                	add    %bh,(%rax)
    4093:	03 91 e4 7c 4b 1b    	add    0x1b4b7ce4(%rcx),%edx
    4099:	00 00                	add    %al,(%rax)
    409b:	38 03                	cmp    %al,(%rbx)
    409d:	91                   	xchg   %eax,%ecx
    409e:	e0 7c                	loopne 411c <balancer_ingress+0x411c>
    40a0:	53                   	push   %rbx
  if (icmp_hdr + 1 > data_end) {
    40a1:	1b 00                	sbb    (%rax),%eax
    40a3:	00 00                	add    %al,(%rax)
    40a5:	00 00                	add    %al,(%rax)
    40a7:	00 00                	add    %al,(%rax)
    40a9:	36 5f                	ss pop %rdi
    40ab:	1b 00                	sbb    (%rax),%eax
    40ad:	00 e8                	add    %ch,%al
    40af:	01 91 02 00 00 00    	add    %edx,0x2(%rcx)
    40b5:	ff 03                	incl   (%rbx)
    40b7:	0b 37                	or     (%rdi),%esi
    return XDP_DROP;
    40b9:	03 91 a0 6d 69 1b    	add    0x1b696da0(%rcx),%edx
    40bf:	00 00                	add    %al,(%rax)
    40c1:	37                   	(bad)
    40c2:	03 91 98 6d 72 1b    	add    0x1b726d98(%rcx),%edx
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
    40c8:	00 00                	add    %al,(%rax)
    40ca:	37                   	(bad)
    40cb:	03 91 90 6d 7b 1b    	add    0x1b7b6d90(%rcx),%edx
    40d1:	00 00                	add    %al,(%rax)
    40d3:	37                   	(bad)
    40d4:	03 91 8f 6d 84 1b    	add    0x1b846d8f(%rcx),%edx
    40da:	00 00                	add    %al,(%rax)
    return send_icmp6_reply(data, data_end);
    40dc:	38 03                	cmp    %al,(%rbx)
    40de:	91                   	xchg   %eax,%ecx
    40df:	88 6d 8d             	mov    %ch,-0x73(%rbp)
    40e2:	1b 00                	sbb    (%rax),%eax
    40e4:	00 38                	add    %bh,(%rax)
    40e6:	03 91 80 6d 97 1b    	add    0x1b976d80(%rcx),%edx
    40ec:	00 00                	add    %al,(%rax)
    40ee:	38 03                	cmp    %al,(%rbx)
    40f0:	91                   	xchg   %eax,%ecx
    40f1:	df 6c a1 1b          	fildll 0x1b(%rcx,%riz,4)
    40f5:	00 00                	add    %al,(%rax)
    40f7:	38 03                	cmp    %al,(%rbx)
  __u64 off = 0;
    40f9:	91                   	xchg   %eax,%ecx
    40fa:	de 6c ab 1b          	fisubrs 0x1b(%rbx,%rbp,4)
    40fe:	00 00                	add    %al,(%rax)
    4100:	38 03                	cmp    %al,(%rbx)
    4102:	91                   	xchg   %eax,%ecx
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
    4103:	dd 6c b5 1b          	(bad)  0x1b(%rbp,%rsi,4)
    4107:	00 00                	add    %al,(%rax)
    4109:	38 03                	cmp    %al,(%rbx)
    410b:	91                   	xchg   %eax,%ecx
    410c:	dc 6c bf 1b          	fsubrl 0x1b(%rdi,%rdi,4)
    4110:	00 00                	add    %al,(%rax)
    4112:	3a e9                	cmp    %cl,%ch
    4114:	01 74 00 00          	add    %esi,0x0(%rax,%rax,1)
       sizeof(struct icmp6hdr)) > data_end) {
    4118:	00 38                	add    %bh,(%rax)
    411a:	03 91 f8 6c ca 1b    	add    0x1bca6cf8(%rcx),%edx
    return XDP_DROP;
    4120:	00 00                	add    %al,(%rax)
    4122:	3b 35 38 03 91 f4    	cmp    -0xb6efcc8(%rip),%esi        # fffffffff4914460 <server_id_map+0x36ff00698460>
    4128:	6c                   	insb   (%dx),%es:(%rdi)
    4129:	d4                   	(bad)
    412a:	1b 00                	sbb    (%rax),%eax
    412c:	00 3a                	add    %bh,(%rdx)
  off += sizeof(struct ethhdr);
    412e:	ea                   	(bad)
    412f:	01 4a 00             	add    %ecx,0x0(%rdx)
    4132:	00 00                	add    %al,(%rax)
    4134:	38 03                	cmp    %al,(%rbx)
    4136:	91                   	xchg   %eax,%ecx
    4137:	f0 6c                	lock insb (%dx),%es:(%rdi)
    4139:	de 1b                	ficomps (%rbx)
    413b:	00 00                	add    %al,(%rax)
    413d:	38 03                	cmp    %al,(%rbx)
    413f:	91                   	xchg   %eax,%ecx
  ip6h = data + off;
    4140:	ec                   	in     (%dx),%al
    4141:	6c                   	insb   (%dx),%es:(%rdi)
    4142:	e7 1b                	out    %eax,$0x1b
    4144:	00 00                	add    %al,(%rax)
    4146:	38 03                	cmp    %al,(%rbx)
    4148:	91                   	xchg   %eax,%ecx
    4149:	e8 6c f0 1b 00       	call   1c31ba <bpf_xdp_adjust_head+0x1bb21a>
    414e:	00 00                	add    %al,(%rax)
    4150:	00 00                	add    %al,(%rax)
    4152:	3a eb                	cmp    %bl,%ch
    4154:	01 af 00 00 00 38    	add    %ebp,0x38000000(%rdi)
  off += sizeof(struct ipv6hdr);
    415a:	03 91 d8 6c fd 1b    	add    0x1bfd6cd8(%rcx),%edx
    4160:	00 00                	add    %al,(%rax)
    4162:	38 03                	cmp    %al,(%rbx)
    4164:	91                   	xchg   %eax,%ecx
    4165:	d0 6c 06 1c          	shrb   0x1c(%rsi,%rax,1)
  icmp_hdr = data + off;
    4169:	00 00                	add    %al,(%rax)
    416b:	3a ec                	cmp    %ah,%ch
    416d:	01 74 00 00          	add    %esi,0x0(%rax,%rax,1)
    4171:	00 38                	add    %bh,(%rax)
    4173:	03 91 c8 6c 11 1c    	add    0x1c116cc8(%rcx),%edx
    4179:	00 00                	add    %al,(%rax)
    417b:	3b 36                	cmp    (%rsi),%esi
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
    417d:	38 03                	cmp    %al,(%rbx)
    417f:	91                   	xchg   %eax,%ecx
    4180:	c4                   	(bad)
    4181:	6c                   	insb   (%dx),%es:(%rdi)
    4182:	1b 1c 00             	sbb    (%rax,%rax,1),%ebx
    4185:	00 3a                	add    %bh,(%rdx)
  icmp_hdr->icmp6_cksum -= 0x0001;
    4187:	ed                   	in     (%dx),%eax
    4188:	01 4a 00             	add    %ecx,0x0(%rdx)
    418b:	00 00                	add    %al,(%rax)
    418d:	38 03                	cmp    %al,(%rbx)
    418f:	91                   	xchg   %eax,%ecx
    4190:	c0 6c 25 1c 00       	shrb   $0x0,0x1c(%rbp,%riz,1)
    4195:	00 38                	add    %bh,(%rax)
    4197:	03 91 bc 6c 2e 1c    	add    0x1c2e6cbc(%rcx),%edx
  ip6h->hop_limit = DEFAULT_TTL;
    419d:	00 00                	add    %al,(%rax)
    419f:	38 03                	cmp    %al,(%rbx)
    41a1:	91                   	xchg   %eax,%ecx
    41a2:	b8 6c 37 1c 00       	mov    $0x1c376c,%eax
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
    41a7:	00 00                	add    %al,(%rax)
    41a9:	00 00                	add    %al,(%rax)
    41ab:	00 00                	add    %al,(%rax)
    41ad:	3a ee                	cmp    %dh,%ch
    41af:	01 74 00 00          	add    %esi,0x0(%rax,%rax,1)
    41b3:	00 38                	add    %bh,(%rax)
    41b5:	03 91 e0 51 78 0d    	add    0xd7851e0(%rcx),%edx
    41bb:	00 00                	add    %al,(%rax)
    41bd:	3b 37                	cmp    (%rdi),%esi
    41bf:	38 03                	cmp    %al,(%rbx)
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
    41c1:	91                   	xchg   %eax,%ecx
    41c2:	dc 51 82             	fcoml  -0x7e(%rcx)
    41c5:	0d 00 00 3a ef       	or     $0xef3a0000,%eax
    41ca:	01 4a 00             	add    %ecx,0x0(%rdx)
    41cd:	00 00                	add    %al,(%rax)
    41cf:	38 03                	cmp    %al,(%rbx)
    41d1:	91                   	xchg   %eax,%ecx
    41d2:	d8 51 8c             	fcoms  -0x74(%rcx)
    41d5:	0d 00 00 38 03       	or     $0x3380000,%eax
    41da:	91                   	xchg   %eax,%ecx
    41db:	d4                   	(bad)
    41dc:	51                   	push   %rcx
    41dd:	95                   	xchg   %eax,%ebp
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
    41de:	0d 00 00 38 03       	or     $0x3380000,%eax
    41e3:	91                   	xchg   %eax,%ecx
    41e4:	d0 51 9e             	rclb   -0x62(%rcx)
    41e7:	0d 00 00 00 00       	or     $0x0,%eax
    41ec:	00 3a                	add    %bh,(%rdx)
    41ee:	f0 01 74 00 00       	lock add %esi,0x0(%rax,%rax,1)
    41f3:	00 38                	add    %bh,(%rax)
    41f5:	03 91 c0 51 ab 0d    	add    0xdab51c0(%rcx),%edx
  return swap_mac_and_send(data, data_end);
    41fb:	00 00                	add    %al,(%rax)
    41fd:	3b 38                	cmp    (%rax),%edi
    41ff:	38 03                	cmp    %al,(%rbx)
    4201:	91                   	xchg   %eax,%ecx
    4202:	bc 51 b5 0d 00       	mov    $0xdb551,%esp
    4207:	00 3a                	add    %bh,(%rdx)
    4209:	f1                   	int1
    420a:	01 4a 00             	add    %ecx,0x0(%rdx)
    420d:	00 00                	add    %al,(%rax)
    420f:	38 03                	cmp    %al,(%rbx)
    4211:	91                   	xchg   %eax,%ecx
    4212:	b8 51 bf 0d 00       	mov    $0xdbf51,%eax
  eth = data;
    4217:	00 38                	add    %bh,(%rax)
    4219:	03 91 b4 51 c8 0d    	add    0xdc851b4(%rcx),%edx
    421f:	00 00                	add    %al,(%rax)
    4221:	38 03                	cmp    %al,(%rbx)
    4223:	91                   	xchg   %eax,%ecx
    4224:	b0 51                	mov    $0x51,%al
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
    4226:	d1 0d 00 00 00 00    	rorl   0x0(%rip)        # 422c <balancer_ingress+0x422c>
    422c:	00 3a                	add    %bh,(%rdx)
    422e:	f2 01 74 00 00       	repnz add %esi,0x0(%rax,%rax,1)
    4233:	00 38                	add    %bh,(%rax)
    4235:	03 91 a0 51 de 0d    	add    0xdde51a0(%rcx),%edx
    423b:	00 00                	add    %al,(%rax)
    423d:	3b 39                	cmp    (%rcx),%edi
    423f:	38 03                	cmp    %al,(%rbx)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
    4241:	91                   	xchg   %eax,%ecx
    4242:	9c                   	pushf
    4243:	51                   	push   %rcx
    4244:	e8 0d 00 00 3a       	call   3a004256 <bpf_xdp_adjust_head+0x39ffc2b6>
    4249:	f3 01 4a 00          	repz add %ecx,0x0(%rdx)
    424d:	00 00                	add    %al,(%rax)
    424f:	38 03                	cmp    %al,(%rbx)
    4251:	91                   	xchg   %eax,%ecx
    4252:	98                   	cwtl
    4253:	51                   	push   %rcx
    4254:	f2 0d 00 00 38 03    	repnz or $0x3380000,%eax
    425a:	91                   	xchg   %eax,%ecx
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
    425b:	94                   	xchg   %eax,%esp
    425c:	51                   	push   %rcx
    425d:	fb                   	sti
    425e:	0d 00 00 38 03       	or     $0x3380000,%eax
    4263:	91                   	xchg   %eax,%ecx
    4264:	90                   	nop
    4265:	51                   	push   %rcx
    4266:	04 0e                	add    $0xe,%al
    4268:	00 00                	add    %al,(%rax)
    426a:	00 00                	add    %al,(%rax)
    426c:	00 36                	add    %dh,(%rsi)
    426e:	45 1c 00             	rex.RB sbb $0x0,%al
    4271:	00 f4                	add    %dh,%ah
    4273:	01 73 03             	add    %esi,0x3(%rbx)
  return swap_mac_and_send(data, data_end);
    4276:	00 00                	add    %al,(%rax)
    4278:	00 24 04             	add    %ah,(%rsp,%rax,1)
    427b:	0a 37                	or     (%rdi),%dh
    427d:	03 91 98 6f 4e 1c    	add    0x1c4e6f98(%rcx),%edx
}
    4283:	00 00                	add    %al,(%rax)
    return send_icmp6_reply(data, data_end);
    4285:	37                   	(bad)
    4286:	03 91 90 6f 56 1c    	add    0x1c566f90(%rcx),%edx
    428c:	00 00                	add    %al,(%rax)
    428e:	37                   	(bad)
    428f:	03 91 8f 6f 5e 1c    	add    0x1c5e6f8f(%rcx),%edx
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
    4295:	00 00                	add    %al,(%rax)
    4297:	37                   	(bad)
    4298:	03 91 80 6f 66 1c    	add    0x1c666f80(%rcx),%edx
    429e:	00 00                	add    %al,(%rax)
      (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {
    42a0:	37                   	(bad)
    42a1:	03 91 f8 6e 6e 1c    	add    0x1c6e6ef8(%rcx),%edx
    42a7:	00 00                	add    %al,(%rax)
    42a9:	37                   	(bad)
    42aa:	03 91 f4 6e 76 1c    	add    0x1c766ef4(%rcx),%edx
    return XDP_PASS;
    42b0:	00 00                	add    %al,(%rax)
    42b2:	38 03                	cmp    %al,(%rbx)
    42b4:	91                   	xchg   %eax,%ecx
    42b5:	e8 6e 7e 1c 00       	call   1cc128 <bpf_xdp_adjust_head+0x1c4188>
    42ba:	00 38                	add    %bh,(%rax)
    42bc:	03 91 e0 6e 86 1c    	add    0x1c866ee0(%rcx),%edx
  if (icmp_hdr->icmp6_type == ICMPV6_PKT_TOOBIG) {
    42c2:	00 00                	add    %al,(%rax)
    42c4:	38 03                	cmp    %al,(%rbx)
    42c6:	91                   	xchg   %eax,%ecx
    42c7:	d8 6e 8e             	fsubrs -0x72(%rsi)
    42ca:	1c 00                	sbb    $0x0,%al
    42cc:	00 38                	add    %bh,(%rax)
    42ce:	03 91 d0 6e 96 1c    	add    0x1c966ed0(%rcx),%edx
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
    42d4:	00 00                	add    %al,(%rax)
    42d6:	38 03                	cmp    %al,(%rbx)
    42d8:	91                   	xchg   %eax,%ecx
    42d9:	c8 6e 9f 1c          	enter  $0x9f6e,$0x1c
        bpf_map_lookup_elem(&stats, &stats_key);
    42dd:	00 00                	add    %al,(%rax)
    42df:	38 03                	cmp    %al,(%rbx)
    42e1:	91                   	xchg   %eax,%ecx
    42e2:	c6                   	(bad)
    42e3:	6e                   	outsb  %ds:(%rsi),(%dx)
    42e4:	a8 1c                	test   $0x1c,%al
    42e6:	00 00                	add    %al,(%rax)
    42e8:	38 03                	cmp    %al,(%rbx)
    42ea:	91                   	xchg   %eax,%ecx
    42eb:	b0 6e                	mov    $0x6e,%al
    42ed:	b0 1c                	mov    $0x1c,%al
    42ef:	00 00                	add    %al,(%rax)
    42f1:	38 03                	cmp    %al,(%rbx)
    42f3:	91                   	xchg   %eax,%ecx
    42f4:	af                   	scas   %es:(%rdi),%eax
    42f5:	6e                   	outsb  %ds:(%rsi),(%dx)
    42f6:	b8 1c 00 00 39       	mov    $0x3900001c,%eax
    42fb:	cd 1c                	int    $0x1c
    42fd:	00 00                	add    %al,(%rax)
    42ff:	f5                   	cmc
    4300:	01 42 00             	add    %eax,0x0(%rdx)
    4303:	00 00                	add    %al,(%rax)
    4305:	0d 4b 05 37 03       	or     $0x337054b,%eax
    430a:	91                   	xchg   %eax,%ecx
    430b:	c6                   	(bad)
    430c:	7d d2                	jge    42e0 <balancer_ingress+0x42e0>
    430e:	1c 00                	sbb    $0x0,%al
    4310:	00 37                	add    %dh,(%rdi)
    4312:	03 91 c0 7d da 1c    	add    0x1cda7dc0(%rcx),%edx
    4318:	00 00                	add    %al,(%rax)
    431a:	37                   	(bad)
    431b:	03 91 b8 7d e2 1c    	add    0x1ce27db8(%rcx),%edx
    4321:	00 00                	add    %al,(%rax)
    4323:	00 39                	add    %bh,(%rcx)
    4325:	cd 1c                	int    $0x1c
    4327:	00 00                	add    %al,(%rax)
    4329:	f6 01 42             	testb  $0x42,(%rcx)
    432c:	00 00                	add    %al,(%rax)
    432e:	00 0d 4f 05 37 03    	add    %cl,0x337054f(%rip)        # 3374883 <bpf_xdp_adjust_head+0x336c8e3>
    4334:	91                   	xchg   %eax,%ecx
    4335:	d6                   	(bad)
    4336:	7d d2                	jge    430a <balancer_ingress+0x430a>
    4338:	1c 00                	sbb    $0x0,%al
    433a:	00 37                	add    %dh,(%rdi)
    433c:	03 91 d0 7d da 1c    	add    0x1cda7dd0(%rcx),%edx
    4342:	00 00                	add    %al,(%rax)
    4344:	37                   	(bad)
    4345:	03 91 c8 7d e2 1c    	add    0x1ce27dc8(%rcx),%edx
    434b:	00 00                	add    %al,(%rax)
    434d:	00 39                	add    %bh,(%rcx)
    struct lb_stats* icmp_ptb_v6_stats =
    434f:	eb 1c                	jmp    436d <balancer_ingress+0x436d>
    4351:	00 00                	add    %al,(%rax)
    4353:	f7 01 e1 00 00 00    	testl  $0xe1,(%rcx)
    if (!icmp_ptb_v6_stats) {
    4359:	0d 53 03 37 03       	or     $0x3370353,%eax
    435e:	91                   	xchg   %eax,%ecx
      return XDP_DROP;
    435f:	98                   	cwtl
    4360:	7e f0                	jle    4352 <balancer_ingress+0x4352>
    4362:	1c 00                	sbb    $0x0,%al
    4364:	00 37                	add    %dh,(%rdi)
    4366:	03 91 97 7e f8 1c    	add    0x1cf87e97(%rcx),%edx
    436c:	00 00                	add    %al,(%rax)
    icmp_ptb_v6_stats->v1 += 1;
    436e:	37                   	(bad)
    436f:	03 91 88 7e 01 1d    	add    0x1d017e88(%rcx),%edx
    4375:	00 00                	add    %al,(%rax)
    4377:	37                   	(bad)
    4378:	03 91 80 7e 09 1d    	add    0x1d097e80(%rcx),%edx
    437e:	00 00                	add    %al,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
    4380:	37                   	(bad)
    4381:	03 91 fe 7d 11 1d    	add    0x1d117dfe(%rcx),%edx
    4387:	00 00                	add    %al,(%rax)
    4389:	37                   	(bad)
    438a:	03 91 fd 7d 19 1d    	add    0x1d197dfd(%rcx),%edx
    4390:	00 00                	add    %al,(%rax)
    4392:	00 00                	add    %al,(%rax)
    4394:	36 22 1d 00 00 f8 01 	ss and 0x1f80000(%rip),%bl        # 1f8439b <bpf_xdp_adjust_head+0x1f7c3fb>
    439b:	84 03                	test   %al,(%rbx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
    439d:	00 00                	add    %al,(%rax)
    439f:	00 28                	add    %ch,(%rax)
    43a1:	04 0a                	add    $0xa,%al
    43a3:	37                   	(bad)
    43a4:	03 91 e8 70 2b 1d    	add    0x1d2b70e8(%rcx),%edx
      icmp_ptb_v6_stats->v2 += 1;
    43aa:	00 00                	add    %al,(%rax)
    43ac:	37                   	(bad)
    43ad:	03 91 e0 70 33 1d    	add    0x1d3370e0(%rcx),%edx
    43b3:	00 00                	add    %al,(%rax)
    43b5:	37                   	(bad)
    43b6:	03 91 d8 70 3b 1d    	add    0x1d3b70d8(%rcx),%edx
  }
    43bc:	00 00                	add    %al,(%rax)
  off += sizeof(struct icmp6hdr);
    43be:	37                   	(bad)
    43bf:	03 91 d0 70 43 1d    	add    0x1d4370d0(%rcx),%edx
    43c5:	00 00                	add    %al,(%rax)
    43c7:	37                   	(bad)
    43c8:	03 91 cc 70 4b 1d    	add    0x1d4b70cc(%rcx),%edx
    43ce:	00 00                	add    %al,(%rax)
  ip6h = data + off;
    43d0:	38 03                	cmp    %al,(%rbx)
    43d2:	91                   	xchg   %eax,%ecx
    43d3:	c0 70 53 1d          	shlb   $0x1d,0x53(%rax)
    43d7:	00 00                	add    %al,(%rax)
    43d9:	38 03                	cmp    %al,(%rbx)
    43db:	91                   	xchg   %eax,%ecx
    43dc:	b8 70 5b 1d 00       	mov    $0x1d5b70,%eax
    43e1:	00 38                	add    %bh,(%rax)
    43e3:	03 91 b0 70 63 1d    	add    0x1d6370b0(%rcx),%edx
  if (ip6h + 1 > data_end) {
    43e9:	00 00                	add    %al,(%rax)
    43eb:	38 03                	cmp    %al,(%rbx)
    43ed:	91                   	xchg   %eax,%ecx
    43ee:	a8 70                	test   $0x70,%al
    43f0:	6b 1d 00 00 38 03 91 	imul   $0xffffff91,0x3380000(%rip),%ebx        # 33843f7 <bpf_xdp_adjust_head+0x337c457>
    43f7:	a0 70 74 1d 00 00 38 	movabs 0x91033800001d7470,%al
    43fe:	03 91 
    return XDP_DROP;
    4400:	9c                   	pushf
    4401:	70 7d                	jo     4480 <balancer_ingress+0x4480>
    4403:	1d 00 00 38 03       	sbb    $0x3380000,%eax
  pckt->flow.proto = ip6h->nexthdr;
    4408:	91                   	xchg   %eax,%ecx
    4409:	90                   	nop
    440a:	70 86                	jo     4392 <balancer_ingress+0x4392>
    440c:	1d 00 00 39 90       	sbb    $0x90390000,%eax
    4411:	1d 00 00 f9 01       	sbb    $0x1f90000,%eax
    4416:	52                   	push   %rdx
    4417:	00 00                	add    %al,(%rax)
    4419:	00 0d 63 12 37 03    	add    %cl,0x3371263(%rip)        # 3375682 <bpf_xdp_adjust_head+0x336d6e2>
  pckt->flags |= F_ICMP;
    441f:	91                   	xchg   %eax,%ecx
    4420:	d2 7e 99             	sarb   %cl,-0x67(%rsi)
    4423:	1d 00 00 37 03       	sbb    $0x3370000,%eax
    4428:	91                   	xchg   %eax,%ecx
    4429:	cc                   	int3
    442a:	7e a1                	jle    43cd <balancer_ingress+0x43cd>
    442c:	1d 00 00 38 03       	sbb    $0x3380000,%eax
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
    4431:	91                   	xchg   %eax,%ecx
    4432:	c8 7e a9 1d          	enter  $0xa97e,$0x1d
    4436:	00 00                	add    %al,(%rax)
    4438:	00 39                	add    %bh,(%rcx)
    443a:	b3 1d                	mov    $0x1d,%bl
    443c:	00 00                	add    %al,(%rax)
    443e:	fa                   	cli
    443f:	01 96 01 00 00 0d    	add    %edx,0xd000001(%rsi)
    4445:	75 03                	jne    444a <balancer_ingress+0x444a>
    4447:	37                   	(bad)
    4448:	03 91 f8 7e b8 1d    	add    0x1db87ef8(%rcx),%edx
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
    444e:	00 00                	add    %al,(%rax)
    4450:	37                   	(bad)
    4451:	03 91 f7 7e c0 1d    	add    0x1dc07ef7(%rcx),%edx
    4457:	00 00                	add    %al,(%rax)
    4459:	37                   	(bad)
    445a:	03 91 f0 7e c8 1d    	add    0x1dc87ef0(%rcx),%edx
    4460:	00 00                	add    %al,(%rax)
    4462:	37                   	(bad)
    4463:	03 91 ec 7e d0 1d    	add    0x1dd07eec(%rcx),%edx
  return FURTHER_PROCESSING;
    4469:	00 00                	add    %al,(%rax)
    446b:	37                   	(bad)
    446c:	03 91 ea 7e d8 1d    	add    0x1dd87eea(%rcx),%edx
}
    4472:	00 00                	add    %al,(%rax)
    4474:	37                   	(bad)
    4475:	03 91 e9 7e e0 1d    	add    0x1de07ee9(%rcx),%edx
    return parse_icmpv6(data, data_end, off, pckt);
    447b:	00 00                	add    %al,(%rax)
    447d:	38 03                	cmp    %al,(%rbx)
    447f:	91                   	xchg   %eax,%ecx
    4480:	e0 7e                	loopne 4500 <balancer_ingress+0x4500>
    4482:	e8 1d 00 00 39       	call   390044a4 <bpf_xdp_adjust_head+0x38ffc504>
  } else if (protocol == IPPROTO_ICMP) {
    4487:	d2 14 00             	rclb   %cl,(%rax,%rax,1)
    448a:	00 fb                	add    %bh,%bl
    448c:	01 a0 00 00 00 0e    	add    %esp,0xe000000(%rax)
    4492:	48 03 37             	add    (%rdi),%rsi
    return parse_icmp(data, data_end, off, pckt);
    4495:	03 91 98 7f d7 14    	add    0x14d77f98(%rcx),%edx
    449b:	00 00                	add    %al,(%rax)
    449d:	37                   	(bad)
    449e:	03 91 90 7f df 14    	add    0x14df7f90(%rcx),%edx
    44a4:	00 00                	add    %al,(%rax)
    44a6:	38 03                	cmp    %al,(%rbx)
    44a8:	91                   	xchg   %eax,%ecx
    44a9:	88 7f e8             	mov    %bh,-0x18(%rdi)
    44ac:	14 00                	adc    $0x0,%al
    44ae:	00 3a                	add    %bh,(%rdx)
    44b0:	fc                   	cld
    44b1:	01 3a                	add    %edi,(%rdx)
    44b3:	00 00                	add    %al,(%rax)
    44b5:	00 38                	add    %bh,(%rax)
    44b7:	03 91 84 7f f2 14    	add    0x14f27f84(%rcx),%edx
    44bd:	00 00                	add    %al,(%rax)
    44bf:	00 39                	add    %bh,(%rcx)
    44c1:	fd                   	std
    44c2:	14 00                	adc    $0x0,%al
    44c4:	00 fd                	add    %bh,%ch
    44c6:	01 47 00             	add    %eax,0x0(%rdi)
    44c9:	00 00                	add    %al,(%rax)
  icmp_hdr = data + off;
    44cb:	0c 3a                	or     $0x3a,%al
    44cd:	0b 37                	or     (%rdi),%esi
    44cf:	03 91 a8 7f 06 15    	add    0x15067fa8(%rcx),%edx
    44d5:	00 00                	add    %al,(%rax)
    44d7:	38 03                	cmp    %al,(%rbx)
    44d9:	91                   	xchg   %eax,%ecx
    44da:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    44db:	7f 0f                	jg     44ec <balancer_ingress+0x44ec>
    44dd:	15 00 00 00 00       	adc    $0x0,%eax
  if (icmp_hdr + 1 > data_end) {
    44e2:	00 00                	add    %al,(%rax)
    44e4:	00 00                	add    %al,(%rax)
    44e6:	3c fe                	cmp    $0xfe,%al
    44e8:	01 b7 03 00 00 01    	add    %esi,0x1000003(%rdi)
    44ee:	56                   	push   %rsi
    44ef:	5a                   	pop    %rdx
    44f0:	01 0a                	add    %ecx,(%rdx)
    44f2:	37                   	(bad)
    44f3:	28 0a                	sub    %cl,(%rdx)
    44f5:	00 00                	add    %al,(%rax)
    return XDP_DROP;
    44f7:	3d 02 91 78 09       	cmp    $0x9789102,%eax
    44fc:	0a 37                	or     (%rdi),%dh
    44fe:	ed                   	in     (%dx),%eax
    44ff:	45 00 00             	add    %r8b,(%r8)
    4502:	3e 02 91 74 60 01 0a 	ds add 0xa016074(%rcx),%dl
  if (icmp_hdr->type == ICMP_ECHO) {
    4509:	37                   	(bad)
    450a:	28 0a                	sub    %cl,(%rdx)
    450c:	00 00                	add    %al,(%rax)
    450e:	3e 02 91 70 61 01 0a 	ds add 0xa016170(%rcx),%dl
    4515:	37                   	(bad)
    4516:	28 0a                	sub    %cl,(%rdx)
    4518:	00 00                	add    %al,(%rax)
    return send_icmp_reply(data, data_end);
    451a:	3f                   	(bad)
    451b:	02 91 6c 62 01 0a    	add    0xa01626c(%rcx),%dl
    4521:	38 28                	cmp    %ch,(%rax)
    4523:	0a 00                	or     (%rax),%al
    4525:	00 3f                	add    %bh,(%rdi)
    4527:	02 91 68 63 01 0a    	add    0xa016368(%rcx),%dl
    452d:	38 28                	cmp    %ch,(%rax)
    452f:	0a 00                	or     (%rax),%al
    4531:	00 3f                	add    %bh,(%rdi)
    4533:	02 91 64 64 01 0a    	add    0xa016464(%rcx),%dl
  __u32 tmp_addr = 0;
    4539:	38 28                	cmp    %ch,(%rax)
    453b:	0a 00                	or     (%rax),%al
    453d:	00 3f                	add    %bh,(%rdi)
  __u64 csum = 0;
    453f:	02 91 58 65 01 0a    	add    0xa016558(%rcx),%dl
    4545:	39 f3                	cmp    %esi,%ebx
    4547:	45 00 00             	add    %r8b,(%r8)
  __u64 off = 0;
    454a:	00 3c ff             	add    %bh,(%rdi,%rdi,8)
    454d:	01 32                	add    %esi,(%rdx)
    454f:	00 00                	add    %al,(%rax)
    4551:	00 01                	add    %al,(%rcx)
    4553:	56                   	push   %rsi
    4554:	5b                   	pop    %rbx
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
    4555:	01 0a                	add    %ecx,(%rdx)
    4557:	6e                   	outsb  %ds:(%rsi),(%dx)
    4558:	28 0a                	sub    %cl,(%rdx)
    455a:	00 00                	add    %al,(%rax)
    455c:	3e 02 91 7c 62 01 0a 	ds add 0xa01627c(%rcx),%dl
    4563:	6e                   	outsb  %ds:(%rsi),(%dx)
    4564:	28 0a                	sub    %cl,(%rdx)
    4566:	00 00                	add    %al,(%rax)
       sizeof(struct icmphdr)) > data_end) {
    4568:	3e 02 91 78 63 01 0a 	ds add 0xa016378(%rcx),%dl
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
    456f:	6e                   	outsb  %ds:(%rsi),(%dx)
    4570:	28 0a                	sub    %cl,(%rdx)
    return XDP_DROP;
    4572:	00 00                	add    %al,(%rax)
    4574:	3e 02 91 74 61 01 0a 	ds add 0xa016174(%rcx),%dl
    457b:	6e                   	outsb  %ds:(%rsi),(%dx)
    457c:	28 0a                	sub    %cl,(%rdx)
    457e:	00 00                	add    %al,(%rax)
  off += sizeof(struct ethhdr);
    4580:	00 3c 80             	add    %bh,(%rax,%rax,4)
    4583:	02 18                	add    (%rax),%bl
    4585:	01 00                	add    %eax,(%rax)
    4587:	00 01                	add    %al,(%rcx)
    4589:	56                   	push   %rsi
    458a:	5c                   	pop    %rsp
    458b:	01 0a                	add    %ecx,(%rdx)
    458d:	66 28 0a             	data16 sub %cl,(%rdx)
    4590:	00 00                	add    %al,(%rax)
  iph = data + off;
    4592:	3e 02 91 7c 62 01 0a 	ds add 0xa01627c(%rcx),%dl
    4599:	66 28 0a             	data16 sub %cl,(%rdx)
    459c:	00 00                	add    %al,(%rax)
    459e:	3e 02 91 78 63 01 0a 	ds add 0xa016378(%rcx),%dl
    45a5:	66 28 0a             	data16 sub %cl,(%rdx)
  off += sizeof(struct iphdr);
    45a8:	00 00                	add    %al,(%rax)
    45aa:	3e 02 91 74 64 01 0a 	ds add 0xa016474(%rcx),%dl
    45b1:	66 28 0a             	data16 sub %cl,(%rdx)
    45b4:	00 00                	add    %al,(%rax)
    45b6:	3e 02 91 70 61 01 0a 	ds add 0xa016170(%rcx),%dl
  icmp_hdr = data + off;
    45bd:	66 28 0a             	data16 sub %cl,(%rdx)
    45c0:	00 00                	add    %al,(%rax)
    45c2:	00 3c 81             	add    %bh,(%rcx,%rax,4)
    45c5:	02 2a                	add    (%rdx),%ch
    45c7:	00 00                	add    %al,(%rax)
    45c9:	00 01                	add    %al,(%rcx)
    45cb:	56                   	push   %rsi
    45cc:	5d                   	pop    %rbp
    45cd:	01 0a                	add    %ecx,(%rdx)
  icmp_hdr->type = ICMP_ECHOREPLY;
    45cf:	07                   	(bad)
    45d0:	a2 00 00 00 3e 02 91 	movabs %al,0x667c91023e000000
    45d7:	7c 66 
  icmp_hdr->checksum += 0x0008;
    45d9:	01 0a                	add    %ecx,(%rdx)
    45db:	07                   	(bad)
    45dc:	a2 00 00 00 3e 02 91 	movabs %al,0x677891023e000000
    45e3:	78 67 
    45e5:	01 0a                	add    %ecx,(%rdx)
    45e7:	07                   	(bad)
    45e8:	aa                   	stos   %al,%es:(%rdi)
    45e9:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
    45eb:	00 00                	add    %al,(%rax)
    45ed:	0a f2                	or     %dl,%dh
    45ef:	45 00 00             	add    %r8b,(%r8)
    45f2:	40 0a f8             	or     %al,%dil
  tmp_addr = iph->daddr;
    45f5:	45 00 00             	add    %r8b,(%r8)
    45f8:	21 01                	and    %eax,(%rcx)
    45fa:	01 00                	add    %eax,(%rax)
	...

Disassembly of section .debug_rnglists:

0000000000000000 <.debug_rnglists>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	72 04                	jb     6 <balancer_ingress+0x6>
   2:	00 00                	add    %al,(%rax)
   4:	05 00 08 00 3b       	add    $0x3b000800,%eax
   9:	00 00                	add    %al,(%rax)
   b:	00 ec                	add    %ch,%ah
   d:	00 00                	add    %al,(%rax)
   f:	00 f9                	add    %bh,%cl
  11:	00 00                	add    %al,(%rax)
  13:	00 06                	add    %al,(%rsi)
  15:	01 00                	add    %eax,(%rax)
  void* data = (void*)(long)ctx->data;
  17:	00 13                	add    %dl,(%rbx)
  19:	01 00                	add    %eax,(%rax)
  1b:	00 20                	add    %ah,(%rax)
  1d:	01 00                	add    %eax,(%rax)
  1f:	00 2d 01 00 00 3a    	add    %ch,0x3a000001(%rip)        # 3a000026 <bpf_xdp_adjust_head+0x39ff8086>
  25:	01 00                	add    %eax,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
  27:	00 47 01             	add    %al,0x1(%rdi)
  2a:	00 00                	add    %al,(%rax)
  2c:	54                   	push   %rsp
  2d:	01 00                	add    %eax,(%rax)
  2f:	00 61 01             	add    %ah,0x1(%rcx)
  32:	00 00                	add    %al,(%rax)
  34:	6e                   	outsb  %ds:(%rsi),(%dx)
  35:	01 00                	add    %eax,(%rax)
  37:	00 7b 01             	add    %bh,0x1(%rbx)
  struct ethhdr* eth = data;
  3a:	00 00                	add    %al,(%rax)
  3c:	88 01                	mov    %al,(%rcx)
  3e:	00 00                	add    %al,(%rax)
  40:	95                   	xchg   %eax,%ebp
  41:	01 00                	add    %eax,(%rax)
  43:	00 a2 01 00 00 af    	add    %ah,-0x50ffffff(%rdx)
  nh_off = sizeof(struct ethhdr);
  49:	01 00                	add    %eax,(%rax)
  4b:	00 bc 01 00 00 c9 01 	add    %bh,0x1c90000(%rcx,%rax,1)
  if (data + nh_off > data_end) {
  52:	00 00                	add    %al,(%rax)
  54:	d6                   	(bad)
  55:	01 00                	add    %eax,(%rax)
  57:	00 e3                	add    %ah,%bl
  59:	01 00                	add    %eax,(%rax)
  5b:	00 f0                	add    %dh,%al
  5d:	01 00                	add    %eax,(%rax)
  5f:	00 fd                	add    %bh,%ch
  61:	01 00                	add    %eax,(%rax)
  63:	00 0a                	add    %cl,(%rdx)
  65:	02 00                	add    (%rax),%al
  67:	00 17                	add    %dl,(%rdi)
  69:	02 00                	add    (%rax),%al
    return XDP_DROP;
  6b:	00 24 02             	add    %ah,(%rdx,%rax,1)
  6e:	00 00                	add    %al,(%rax)
  70:	31 02                	xor    %eax,(%rdx)
  72:	00 00                	add    %al,(%rax)
  74:	3e 02 00             	ds add (%rax),%al
  77:	00 4b 02             	add    %cl,0x2(%rbx)
  eth_proto = eth->h_proto;
  7a:	00 00                	add    %al,(%rax)
  7c:	58                   	pop    %rax
  7d:	02 00                	add    (%rax),%al
  7f:	00 65 02             	add    %ah,0x2(%rbp)
  82:	00 00                	add    %al,(%rax)
  84:	76 02                	jbe    88 <balancer_ingress+0x88>
  86:	00 00                	add    %al,(%rax)
  88:	87 02                	xchg   %eax,(%rdx)
  if (eth_proto == BE_ETH_P_IP) {
  8a:	00 00                	add    %al,(%rax)
  8c:	98                   	cwtl
  8d:	02 00                	add    (%rax),%al
  8f:	00 a9 02 00 00 ba    	add    %ch,-0x45fffffe(%rcx)
  95:	02 00                	add    (%rax),%al
    return process_packet(ctx, nh_off, false);
  97:	00 cb                	add    %cl,%bl
  99:	02 00                	add    (%rax),%al
  9b:	00 dc                	add    %bl,%ah
  9d:	02 00                	add    (%rax),%al
  9f:	00 ed                	add    %ch,%ch
  a1:	02 00                	add    (%rax),%al
  a3:	00 fe                	add    %bh,%dh
  a5:	02 00                	add    (%rax),%al
  a7:	00 0f                	add    %cl,(%rdi)
  a9:	03 00                	add    (%rax),%eax
  ab:	00 20                	add    %ah,(%rax)
  ad:	03 00                	add    (%rax),%eax
  af:	00 31                	add    %dh,(%rcx)
  b1:	03 00                	add    (%rax),%eax
  b3:	00 42 03             	add    %al,0x3(%rdx)
  b6:	00 00                	add    %al,(%rax)
  b8:	53                   	push   %rbx
  void* data = (void*)(long)xdp->data;
  b9:	03 00                	add    (%rax),%eax
  bb:	00 64 03 00          	add    %ah,0x0(%rbx,%rax,1)
  bf:	00 75 03             	add    %dh,0x3(%rbp)
  c2:	00 00                	add    %al,(%rax)
  c4:	86 03                	xchg   %al,(%rbx)
  c6:	00 00                	add    %al,(%rax)
  c8:	97                   	xchg   %eax,%edi
  c9:	03 00                	add    (%rax),%eax
  void* data_end = (void*)(long)xdp->data_end;
  cb:	00 a8 03 00 00 b9    	add    %ch,-0x46fffffd(%rax)
  d1:	03 00                	add    (%rax),%eax
  d3:	00 ca                	add    %cl,%dl
  d5:	03 00                	add    (%rax),%eax
  d7:	00 db                	add    %bl,%bl
  d9:	03 00                	add    (%rax),%eax
  db:	00 ec                	add    %ch,%ah
  struct real_definition* dst = NULL;
  dd:	03 00                	add    (%rax),%eax
  df:	00 fd                	add    %bh,%ch
  e1:	03 00                	add    (%rax),%eax
  e3:	00 0e                	add    %cl,(%rsi)
  e5:	04 00                	add    $0x0,%al
  struct packet_description pckt = {};
  e7:	00 1f                	add    %bl,(%rdi)
  e9:	04 00                	add    $0x0,%al
  eb:	00 30                	add    %dh,(%rax)
  ed:	04 00                	add    $0x0,%al
  ef:	00 41 04             	add    %al,0x4(%rcx)
  f2:	00 00                	add    %al,(%rax)
  f4:	52                   	push   %rdx
  f5:	04 00                	add    $0x0,%al
  f7:	00 01                	add    %al,(%rcx)
  f9:	17                   	(bad)
  fa:	04 9c                	add    $0x9c,%al
  fc:	0f f0                	(bad)
  fe:	0f 04                	(bad)
 100:	f7 0f fe 0f 00 01    	testl  $0x1000ffe,(%rdi)
 106:	17                   	(bad)
 107:	04 d9                	add    $0xd9,%al
 109:	19 ad 1a 04 b4 1a    	sbb    %ebp,0x1ab4041a(%rbp)
 10f:	bb 1a 00 01 17       	mov    $0x1701001a,%ebx
 114:	04 cf                	add    $0xcf,%al
 116:	25 a3 26 04 aa       	and    $0xaa0426a3,%eax
 11b:	26 b1 26             	es mov $0x26,%cl
 11e:	00 01                	add    %al,(%rcx)
  struct vip_definition vip = {};
 120:	17                   	(bad)
 121:	04 e1                	add    $0xe1,%al
 123:	26 b5 27             	es mov $0x27,%ch
 126:	04 bc                	add    $0xbc,%al
 128:	27                   	(bad)
 129:	c3                   	ret
 12a:	27                   	(bad)
 12b:	00 01                	add    %al,(%rcx)
 12d:	17                   	(bad)
 12e:	04 d6                	add    $0xd6,%al
 130:	28 aa 29 04 b1 29    	sub    %ch,0x29b10429(%rdx)
 136:	b8 29 00 01 17       	mov    $0x17010029,%eax
 13b:	04 ba                	add    $0xba,%al
 13d:	2a 8e 2b 04 95 2b    	sub    0x2b95042b(%rsi),%cl
  __u32 mac_addr_pos = 0;
 143:	9c                   	pushf
 144:	2b 00                	sub    (%rax),%eax
 146:	01 17                	add    %edx,(%rdi)
  __u64 th_off = 0;
 148:	04 de                	add    $0xde,%al
 14a:	2b b2 2c 04 b9 2c    	sub    0x2cb9042c(%rdx),%esi
 150:	c0 2c 00 01          	shrb   $0x1,(%rax,%rax,1)
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
 154:	17                   	(bad)
 155:	04 c7                	add    $0xc7,%al
 157:	2d 9b 2e 04 a2       	sub    $0xa2042e9b,%eax
 15c:	2e a9 2e 00 01 17    	cs test $0x1701002e,%eax
 162:	04 85                	add    $0x85,%al
 164:	31 d9                	xor    %ebx,%ecx
 166:	31 04 e0             	xor    %eax,(%rax,%riz,8)
 169:	31 e7                	xor    %esp,%edi
 16b:	31 00                	xor    %eax,(%rax)
 16d:	01 17                	add    %edx,(%rdi)
 16f:	04 e4                	add    $0xe4,%al
 171:	39 b8 3a 04 bf 3a    	cmp    %edi,0x3abf043a(%rax)
 177:	c6                   	(bad)
 178:	3a 00                	cmp    (%rax),%al
 17a:	01 17                	add    %edx,(%rdi)
 17c:	04 cc                	add    $0xcc,%al
 17e:	3b a0 3c 04 a7 3c    	cmp    0x3ca7043c(%rax),%esp
 184:	ae                   	scas   %es:(%rdi),%al
 185:	3c 00                	cmp    $0x0,%al
 187:	01 17                	add    %edx,(%rdi)
 189:	04 9b                	add    $0x9b,%al
 18b:	3e ef                	ds out %eax,(%dx)
 18d:	3e 04 f6             	ds add $0xf6,%al
 190:	3e fd                	ds std
 192:	3e 00 01             	ds add %al,(%rcx)
 195:	17                   	(bad)
 196:	04 91                	add    $0x91,%al
 198:	42 e5 42             	rex.X in $0x42,%eax
 19b:	04 ec                	add    $0xec,%al
 19d:	42                   	rex.X
 19e:	f3 42 00 01          	repz rex.X add %al,(%rcx)
 1a2:	17                   	(bad)
 1a3:	04 81                	add    $0x81,%al
 1a5:	45 d5                	rex.RB (bad)
 1a7:	45 04 dc             	rex.RB add $0xdc,%al
 1aa:	45 e3 45             	rex.RB jrcxz 1f2 <balancer_ingress+0x1f2>
 1ad:	00 01                	add    %al,(%rcx)
 1af:	17                   	(bad)
 1b0:	04 82                	add    $0x82,%al
 1b2:	49 d6                	rex.WB (bad)
 1b4:	49 04 dd             	rex.WB add $0xdd,%al
 1b7:	49 e4 49             	rex.WB in $0x49,%al
 1ba:	00 01                	add    %al,(%rcx)
 1bc:	17                   	(bad)
 1bd:	04 8b                	add    $0x8b,%al
 1bf:	4b df 4b 04          	rex.WXB fisttps 0x4(%r11)
  if (is_ipv6) {
 1c3:	e6 4b                	out    %al,$0x4b
 1c5:	ed                   	in     (%dx),%eax
 1c6:	4b 00 01             	rex.WXB add %al,(%r9)
 1c9:	17                   	(bad)
 1ca:	04 ba                	add    $0xba,%al
 1cc:	4d 91                	rex.WRB xchg %rax,%r9
 1ce:	4e 04 98             	rex.WRX add $0x98,%al
    ip6h = data + nh_off;
 1d1:	4e 9f                	rex.WRX lahf
 1d3:	4e 00 01             	rex.WRX add %r8b,(%rcx)
 1d6:	17                   	(bad)
 1d7:	04 94                	add    $0x94,%al
 1d9:	4f e8 4f 04 ef 4f    	rex.WRXB call 4fef062e <bpf_xdp_adjust_head+0x4fee868e>
 1df:	f6 4f 00 01          	testb  $0x1,0x0(%rdi)
 1e3:	17                   	(bad)
 1e4:	04 d8                	add    $0xd8,%al
    if (ip6h + 1 > data_end) {
 1e6:	50                   	push   %rax
 1e7:	ac                   	lods   %ds:(%rsi),%al
 1e8:	51                   	push   %rcx
 1e9:	04 b3                	add    $0xb3,%al
 1eb:	51                   	push   %rcx
 1ec:	ba 51 00 01 17       	mov    $0x17010051,%edx
 1f1:	04 b3                	add    $0xb3,%al
 1f3:	53                   	push   %rbx
 1f4:	87 54 04 8e          	xchg   %edx,-0x72(%rsp,%rax,1)
 1f8:	54                   	push   %rsp
 1f9:	95                   	xchg   %eax,%ebp
 1fa:	54                   	push   %rsp
 1fb:	00 01                	add    %al,(%rcx)
      return XDP_DROP;
 1fd:	17                   	(bad)
 1fe:	04 e8                	add    $0xe8,%al
 200:	57                   	push   %rdi
 201:	bc 58 04 c3 58       	mov    $0x58c30458,%esp
 206:	ca 58 00             	lret   $0x58
 209:	01 17                	add    %edx,(%rdi)
    iph_len = sizeof(struct ipv6hdr);
 20b:	04 9f                	add    $0x9f,%al
 20d:	59                   	pop    %rcx
 20e:	f3 59                	repz pop %rcx
 210:	04 fa                	add    $0xfa,%al
 212:	59                   	pop    %rcx
 213:	81 5a 00 01 17 04 d7 	sbbl   $0xd7041701,0x0(%rdx)
    *protocol = ip6h->nexthdr;
 21a:	5a                   	pop    %rdx
 21b:	ab                   	stos   %eax,%es:(%rdi)
 21c:	5b                   	pop    %rbx
 21d:	04 b2                	add    $0xb2,%al
 21f:	5b                   	pop    %rbx
 220:	b9 5b 00 01 17       	mov    $0x1701005b,%ecx
 225:	04 f0                	add    $0xf0,%al
 227:	5b                   	pop    %rbx
 228:	c4                   	(bad)
    pckt->flow.proto = *protocol;
 229:	5c                   	pop    %rsp
 22a:	04 cb                	add    $0xcb,%al
 22c:	5c                   	pop    %rsp
 22d:	d2 5c 00 01          	rcrb   %cl,0x1(%rax,%rax,1)
 231:	17                   	(bad)
 232:	04 e6                	add    $0xe6,%al
 234:	5e                   	pop    %rsi
 235:	ba 5f 04 c1 5f       	mov    $0x5fc1045f,%edx
 23a:	c8 5f 00 01          	enter  $0x5f,$0x1
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 23e:	17                   	(bad)
 23f:	04 c4                	add    $0xc4,%al
 241:	62                   	(bad)
 242:	98                   	cwtl
 243:	63 04 9f             	movsxd (%rdi,%rbx,4),%eax
 246:	63 a6 63 00 01 17    	movsxd 0x17010063(%rsi),%esp
 24c:	04 9a                	add    $0x9a,%al
 24e:	64 ee                	fs out %al,(%dx)
 250:	64 04 f5             	fs add $0xf5,%al
 253:	64 fc                	fs cld
 255:	64 00 01             	add    %al,%fs:(%rcx)
 258:	17                   	(bad)
 259:	04 ae                	add    $0xae,%al
 25b:	65 82                	gs (bad)
 25d:	66 04 89             	data16 add $0x89,%al
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 260:	66 90                	xchg   %ax,%ax
 262:	66 00 01             	data16 add %al,(%rcx)
 265:	17                   	(bad)
 266:	04 eb                	add    $0xeb,%al
 268:	66 bf 67 04          	mov    $0x467,%di
 26c:	c6                   	(bad)
 26d:	67 cd 67             	addr32 int $0x67
 270:	00 01                	add    %al,(%rcx)
 272:	17                   	(bad)
 273:	04 e5                	add    $0xe5,%al
 275:	85 01                	test   %eax,(%rcx)
 277:	b9 86 01 04 c0       	mov    $0xc0040186,%ecx
 27c:	86 01                	xchg   %al,(%rcx)
 27e:	c7 86 01 00 01 17 04 	movl   $0x190a204,0x17010001(%rsi)
 285:	a2 90 01 
    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
 288:	f6 90 01 04 fd 90    	notb   -0x6f02fbff(%rax)
 28e:	01 84 91 01 00 01 17 	add    %eax,0x17010001(%rcx,%rdx,4)
 295:	04 98                	add    $0x98,%al
 297:	9c                   	pushf
 298:	01 ec                	add    %ebp,%esp
 29a:	9c                   	pushf
 29b:	01 04 f3             	add    %eax,(%rbx,%rsi,8)
 29e:	9c                   	pushf
 29f:	01 fa                	add    %edi,%edx
 2a1:	9c                   	pushf
 2a2:	01 00                	add    %eax,(%rax)
 2a4:	01 17                	add    %edx,(%rdi)
 2a6:	04 aa                	add    $0xaa,%al
 2a8:	9d                   	popf
 2a9:	01 fe                	add    %edi,%esi
 2ab:	9d                   	popf
 2ac:	01 04 85 9e 01 8c 9e 	add    %eax,-0x6173fe62(,%rax,4)
    *th_off += nh_off + iph_len;
 2b3:	01 00                	add    %eax,(%rax)
 2b5:	01 17                	add    %edx,(%rdi)
 2b7:	04 9f                	add    $0x9f,%al
 2b9:	9f                   	lahf
 2ba:	01 f3                	add    %esi,%ebx
 2bc:	9f                   	lahf
 2bd:	01 04 fa             	add    %eax,(%rdx,%rdi,8)
 2c0:	9f                   	lahf
 2c1:	01 81 a0 01 00 01    	add    %eax,0x10001a0(%rcx)
 2c7:	17                   	(bad)
 2c8:	04 83                	add    $0x83,%al
 2ca:	a1 01 d7 a1 01 04 de 	movabs 0x1a1de0401a1d701,%eax
 2d1:	a1 01 
    if (*protocol == IPPROTO_FRAGMENT) {
 2d3:	e5 a1                	in     $0xa1,%eax
 2d5:	01 00                	add    %eax,(%rax)
 2d7:	01 17                	add    %edx,(%rdi)
 2d9:	04 a7                	add    $0xa7,%al
 2db:	a2 01 fb a2 01 04 82 	movabs %al,0x1a3820401a2fb01
 2e2:	a3 01 
      return XDP_DROP;
 2e4:	89 a3 01 00 01 17    	mov    %esp,0x17010001(%rbx)
 2ea:	04 90                	add    $0x90,%al
    } else if (*protocol == IPPROTO_ICMPV6) {
 2ec:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
 2ed:	01 e4                	add    %esp,%esp
 2ef:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
 2f0:	01 04 eb             	add    %eax,(%rbx,%rbp,8)
 2f3:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
 2f4:	01 f2                	add    %esi,%edx
 2f6:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
 2f7:	01 00                	add    %eax,(%rax)
 2f9:	01 17                	add    %edx,(%rdi)
      return FURTHER_PROCESSING;
 2fb:	04 ce                	add    $0xce,%al
 2fd:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
 2fe:	01 a2 a8 01 04 a9    	add    %esp,-0x56fbfe58(%rdx)
 304:	a8 01                	test   $0x1,%al
 306:	b0 a8                	mov    $0xa8,%al
 308:	01 00                	add    %eax,(%rax)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 30a:	01 17                	add    %edx,(%rdi)
 30c:	04 ad                	add    $0xad,%al
 30e:	b0 01                	mov    $0x1,%al
 310:	81 b1 01 04 88 b1 01 	xorl   $0x1b18f01,-0x4e77fbff(%rcx)
 317:	8f b1 01 
 31a:	00 01                	add    %al,(%rcx)
 31c:	17                   	(bad)
 31d:	04 95                	add    $0x95,%al
 31f:	b2 01                	mov    $0x1,%dl
 321:	e9 b2 01 04 f0       	jmp    fffffffff00404d8 <server_id_map+0x36fefbdc44d8>
 326:	b2 01                	mov    $0x1,%dl
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 328:	f7 b2 01 00 01 17    	divl   0x17010001(%rdx)
 32e:	04 e4                	add    $0xe4,%al
 330:	b4 01                	mov    $0x1,%ah
 332:	b8 b5 01 04 bf       	mov    $0xbf0401b5,%eax
 337:	b5 01                	mov    $0x1,%ch
 339:	c6                   	(bad)
 33a:	b5 01                	mov    $0x1,%ch
 33c:	00 01                	add    %al,(%rcx)
 33e:	17                   	(bad)
 33f:	04 da                	add    $0xda,%al
 341:	b8 01 ae b9 01       	mov    $0x1b9ae01,%eax
  } else {
 346:	04 b5                	add    $0xb5,%al
 348:	b9 01 bc b9 01       	mov    $0x1b9bc01,%ecx
    iph = data + nh_off;
 34d:	00 01                	add    %al,(%rcx)
 34f:	17                   	(bad)
 350:	04 ca                	add    $0xca,%al
 352:	bb 01 9e bc 01       	mov    $0x1bc9e01,%ebx
 357:	04 a5                	add    $0xa5,%al
 359:	bc 01 ac bc 01       	mov    $0x1bcac01,%esp
 35e:	00 01                	add    %al,(%rcx)
    if (iph + 1 > data_end) {
 360:	17                   	(bad)
 361:	04 cb                	add    $0xcb,%al
 363:	bf 01 9f c0 01       	mov    $0x1c09f01,%edi
 368:	04 a6                	add    $0xa6,%al
 36a:	c0 01 ad             	rolb   $0xad,(%rcx)
 36d:	c0 01 00             	rolb   $0x0,(%rcx)
 370:	01 17                	add    %edx,(%rdi)
 372:	04 d4                	add    $0xd4,%al
 374:	c1 01 a8             	roll   $0xa8,(%rcx)
      return XDP_DROP;
 377:	c2 01 04             	ret    $0x401
 37a:	af                   	scas   %es:(%rdi),%eax
 37b:	c2 01 b6             	ret    $0xb601
 37e:	c2 01 00             	ret    $0x1
 381:	01 17                	add    %edx,(%rdi)
 383:	04 83                	add    $0x83,%al
    if (iph->ihl != 5) {
 385:	c4 01 da c4          	(bad)
 389:	01 04 e1             	add    %eax,(%rcx,%riz,8)
 38c:	c4 01 e8 c4          	(bad)
 390:	01 00                	add    %eax,(%rax)
 392:	01 17                	add    %edx,(%rdi)
 394:	04 dd                	add    $0xdd,%al
 396:	c5 01 b1             	(bad)
      return XDP_DROP;
 399:	c6 01 04             	movb   $0x4,(%rcx)
 39c:	b8 c6 01 bf c6       	mov    $0xc6bf01c6,%eax
 3a1:	01 00                	add    %eax,(%rax)
 3a3:	01 17                	add    %edx,(%rdi)
 3a5:	04 a1                	add    $0xa1,%al
    pckt->tos = iph->tos;
 3a7:	c7 01 f5 c7 01 04    	movl   $0x401c7f5,(%rcx)
 3ad:	fc                   	cld
 3ae:	c7 01 83 c8 01 00    	movl   $0x1c883,(%rcx)
 3b4:	01 17                	add    %edx,(%rdi)
 3b6:	04 fc                	add    $0xfc,%al
 3b8:	c9                   	leave
 3b9:	01 d0                	add    %edx,%eax
    *protocol = iph->protocol;
 3bb:	ca 01 04             	lret   $0x401
 3be:	d7                   	xlat   %ds:(%rbx)
 3bf:	ca 01 de             	lret   $0xde01
 3c2:	ca 01 00             	lret   $0x1
 3c5:	01 17                	add    %edx,(%rdi)
 3c7:	04 b1                	add    $0xb1,%al
 3c9:	ce                   	(bad)
 3ca:	01 85 cf 01 04 8c    	add    %eax,-0x73fbfe31(%rbp)
    pckt->flow.proto = *protocol;
 3d0:	cf                   	iret
 3d1:	01 93 cf 01 00 01    	add    %edx,0x10001cf(%rbx)
 3d7:	17                   	(bad)
 3d8:	04 e8                	add    $0xe8,%al
 3da:	cf                   	iret
 3db:	01 bc d0 01 04 c3 d0 	add    %edi,-0x2f3cfbff(%rax,%rdx,8)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
 3e2:	01 ca                	add    %ecx,%edx
 3e4:	d0 01                	rolb   (%rcx)
 3e6:	00 01                	add    %al,(%rcx)
 3e8:	17                   	(bad)
 3e9:	04 a0                	add    $0xa0,%al
 3eb:	d1 01                	roll   (%rcx)
 3ed:	f4                   	hlt
 3ee:	d1 01                	roll   (%rcx)
 3f0:	04 fb                	add    $0xfb,%al
 3f2:	d1 01                	roll   (%rcx)
 3f4:	82                   	(bad)
 3f5:	d2 01                	rolb   %cl,(%rcx)
 3f7:	00 01                	add    %al,(%rcx)
 3f9:	17                   	(bad)
 3fa:	04 b9                	add    $0xb9,%al
 3fc:	d2 01                	rolb   %cl,(%rcx)
 3fe:	8d                   	(bad)
 3ff:	d3 01                	roll   %cl,(%rcx)
 401:	04 94                	add    $0x94,%al
 403:	d3 01                	roll   %cl,(%rcx)
 405:	9b                   	fwait
 406:	d3 01                	roll   %cl,(%rcx)
 408:	00 01                	add    %al,(%rcx)
 40a:	17                   	(bad)
 40b:	04 af                	add    $0xaf,%al
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;
 40d:	d5                   	(bad)
 40e:	01 83 d6 01 04 8a    	add    %eax,-0x75fbfe2a(%rbx)
 414:	d6                   	(bad)
 415:	01 91 d6 01 00 01    	add    %edx,0x10001d6(%rcx)
 41b:	17                   	(bad)
 41c:	04 8d                	add    $0x8d,%al
 41e:	d9 01                	flds   (%rcx)
 420:	e1 d9                	loope  3fb <balancer_ingress+0x3fb>
 422:	01 04 e8             	add    %eax,(%rax,%rbp,8)
    if (iph->frag_off & PCKT_FRAGMENTED) {
 425:	d9 01                	flds   (%rcx)
 427:	ef                   	out    %eax,(%dx)
 428:	d9 01                	flds   (%rcx)
 42a:	00 01                	add    %al,(%rcx)
 42c:	17                   	(bad)
 42d:	04 e3                	add    $0xe3,%al
 42f:	da 01                	fiaddl (%rcx)
 431:	b7 db                	mov    $0xdb,%bh
 433:	01 04 be             	add    %eax,(%rsi,%rdi,4)
 436:	db 01                	fildl  (%rcx)
 438:	c5 db 01             	(bad)
      return XDP_DROP;
 43b:	00 01                	add    %al,(%rcx)
 43d:	17                   	(bad)
 43e:	04 f7                	add    $0xf7,%al
 440:	db 01                	fildl  (%rcx)
 442:	cb                   	lret
 443:	dc 01                	faddl  (%rcx)
    if (*protocol == IPPROTO_ICMP) {
 445:	04 d2                	add    $0xd2,%al
 447:	dc 01                	faddl  (%rcx)
 449:	d9 dc                	(bad)
 44b:	01 00                	add    %eax,(%rax)
 44d:	01 17                	add    %edx,(%rdi)
 44f:	04 b4                	add    $0xb4,%al
 451:	dd 01                	fldl   (%rcx)
 453:	88 de                	mov    %bl,%dh
      return FURTHER_PROCESSING;
 455:	01 04 8f             	add    %eax,(%rdi,%rcx,4)
 458:	de 01                	fiadds (%rcx)
 45a:	96                   	xchg   %eax,%esi
 45b:	de 01                	fiadds (%rcx)
 45d:	00 03                	add    %al,(%rbx)
 45f:	17                   	(bad)
      pckt->flow.src = iph->saddr;
 460:	80 ef 01             	sub    $0x1,%bh
 463:	03 fe                	add    %esi,%edi
 465:	01 b7 07 03 ff 01    	add    %esi,0x1ff0307(%rdi)
 46b:	32 03                	xor    (%rbx),%al
 46d:	80 02 98             	addb   $0x98,(%rdx)
 470:	02 03                	add    (%rbx),%al
 472:	81                   	.byte 0x81
      pckt->flow.dst = iph->daddr;
 473:	02 2a                	add    (%rdx),%ch
	...

Disassembly of section .debug_str_offsets:

0000000000000000 <.debug_str_offsets>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
   1:	05 00 00 05 00       	add    $0x50000,%eax
   6:	00 00                	add    %al,(%rax)
   8:	00 00                	add    %al,(%rax)
   a:	00 00                	add    %al,(%rax)
   c:	1c 00                	sbb    $0x0,%al
   e:	00 00                	add    %al,(%rax)
  10:	3a 00                	cmp    (%rax),%al
  12:	00 00                	add    %al,(%rax)
  14:	65 00 00             	add    %al,%gs:(%rax)
  void* data = (void*)(long)ctx->data;
  17:	00 c9                	add    %cl,%cl
  19:	00 00                	add    %al,(%rax)
  1b:	00 6e 00             	add    %ch,0x0(%rsi)
  1e:	00 00                	add    %al,(%rax)
  20:	82                   	(bad)
  21:	00 00                	add    %al,(%rax)
  23:	00 76 08             	add    %dh,0x8(%rsi)
  26:	00 00                	add    %al,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
  28:	95                   	xchg   %eax,%ebp
  29:	00 00                	add    %al,(%rax)
  2b:	00 8f 0b 00 00 8c    	add    %cl,-0x73fffff5(%rdi)
  31:	00 00                	add    %al,(%rax)
  33:	00 99 00 00 00 d7    	add    %bl,-0x29000000(%rcx)
  struct ethhdr* eth = data;
  39:	00 00                	add    %al,(%rax)
  3b:	00 9f 00 00 00 b2    	add    %bl,-0x4e000000(%rdi)
  41:	00 00                	add    %al,(%rax)
  43:	00 b8 00 00 00 d5    	add    %bh,-0x2b000000(%rax)
  nh_off = sizeof(struct ethhdr);
  49:	09 00                	or     %eax,(%rax)
  4b:	00 c0                	add    %al,%al
  4d:	00 00                	add    %al,(%rax)
  4f:	00 ce                	add    %cl,%dh
  if (data + nh_off > data_end) {
  51:	00 00                	add    %al,(%rax)
  53:	00 d3                	add    %dl,%bl
  55:	00 00                	add    %al,(%rax)
  57:	00 dd                	add    %bl,%ch
  59:	00 00                	add    %al,(%rax)
  5b:	00 e9                	add    %ch,%cl
  5d:	00 00                	add    %al,(%rax)
  5f:	00 f3                	add    %dh,%bl
  61:	00 00                	add    %al,(%rax)
  63:	00 fa                	add    %bh,%dl
  65:	0c 00                	or     $0x0,%al
  67:	00 fb                	add    %bh,%bl
  69:	00 00                	add    %al,(%rax)
    return XDP_DROP;
  6b:	00 02                	add    %al,(%rdx)
  6d:	01 00                	add    %eax,(%rax)
  6f:	00 c6                	add    %al,%dh
  71:	06                   	(bad)
  72:	00 00                	add    %al,(%rax)
  74:	08 01                	or     %al,(%rcx)
  76:	00 00                	add    %al,(%rax)
  78:	17                   	(bad)
  eth_proto = eth->h_proto;
  79:	01 00                	add    %eax,(%rax)
  7b:	00 fa                	add    %bh,%dl
  7d:	0d 00 00 1d 01       	or     $0x11d0000,%eax
  82:	00 00                	add    %al,(%rax)
  84:	ed                   	in     (%dx),%eax
  85:	00 00                	add    %al,(%rax)
  87:	00 2c 01             	add    %ch,(%rcx,%rax,1)
  if (eth_proto == BE_ETH_P_IP) {
  8a:	00 00                	add    %al,(%rax)
  8c:	34 01                	xor    $0x1,%al
  8e:	00 00                	add    %al,(%rax)
  90:	3d 01 00 00 9d       	cmp    $0x9d000001,%eax
  95:	0d 00 00 4c 01       	or     $0x14c0000,%eax
    return process_packet(ctx, nh_off, false);
  9a:	00 00                	add    %al,(%rax)
  9c:	41 0c 00             	rex.B or $0x0,%al
  9f:	00 52 01             	add    %dl,0x1(%rdx)
  a2:	00 00                	add    %al,(%rax)
  a4:	58                   	pop    %rax
  a5:	01 00                	add    %eax,(%rax)
  a7:	00 5e 01             	add    %bl,0x1(%rsi)
  aa:	00 00                	add    %al,(%rax)
  ac:	65 01 00             	add    %eax,%gs:(%rax)
  af:	00 77 07             	add    %dh,0x7(%rdi)
  b2:	00 00                	add    %al,(%rax)
  b4:	6e                   	outsb  %ds:(%rsi),(%dx)
  b5:	01 00                	add    %eax,(%rax)
  b7:	00 74 01 00          	add    %dh,0x0(%rcx,%rax,1)
  void* data = (void*)(long)xdp->data;
  bb:	00 81 01 00 00 8d    	add    %al,-0x72ffffff(%rcx)
  c1:	01 00                	add    %eax,(%rax)
  c3:	00 94 01 00 00 9d 01 	add    %dl,0x19d0000(%rcx,%rax,1)
  void* data_end = (void*)(long)xdp->data_end;
  ca:	00 00                	add    %al,(%rax)
  cc:	a3 01 00 00 b3 01 00 	movabs %eax,0x5e000001b3000001
  d3:	00 5e 
  d5:	02 00                	add    (%rax),%al
  d7:	00 65 02             	add    %ah,0x2(%rbp)
  da:	00 00                	add    %al,(%rax)
  struct real_definition* dst = NULL;
  dc:	bf 01 00 00 ca       	mov    $0xca000001,%edi
  e1:	0c 00                	or     $0x0,%al
  e3:	00 c8                	add    %cl,%al
  e5:	01 00                	add    %eax,(%rax)
  struct packet_description pckt = {};
  e7:	00 17                	add    %dl,(%rdi)
  e9:	0a 00                	or     (%rax),%al
  eb:	00 d7                	add    %dl,%bh
  ed:	01 00                	add    %eax,(%rax)
  ef:	00 e6                	add    %ah,%dh
  f1:	01 00                	add    %eax,(%rax)
  f3:	00 f0                	add    %dh,%al
  f5:	01 00                	add    %eax,(%rax)
  f7:	00 fc                	add    %bh,%ah
  f9:	01 00                	add    %eax,(%rax)
  fb:	00 12                	add    %dl,(%rdx)
  fd:	02 00                	add    (%rax),%al
  ff:	00 2f                	add    %ch,(%rdi)
 101:	02 00                	add    (%rax),%al
 103:	00 3a                	add    %bh,(%rdx)
 105:	02 00                	add    (%rax),%al
 107:	00 53 02             	add    %dl,0x2(%rbx)
 10a:	00 00                	add    %al,(%rax)
 10c:	5a                   	pop    %rdx
 10d:	02 00                	add    (%rax),%al
 10f:	00 61 02             	add    %ah,0x2(%rcx)
 112:	00 00                	add    %al,(%rax)
 114:	68 02 00 00 6f       	push   $0x6f000002
 119:	02 00                	add    (%rax),%al
 11b:	00 80 02 00 00 94    	add    %al,-0x6bfffffe(%rax)
  struct vip_definition vip = {};
 121:	02 00                	add    (%rax),%al
 123:	00 a9 02 00 00 bf    	add    %ch,-0x40fffffe(%rcx)
 129:	02 00                	add    (%rax),%al
 12b:	00 cf                	add    %cl,%bh
 12d:	02 00                	add    (%rax),%al
 12f:	00 e3                	add    %ah,%bl
 131:	02 00                	add    (%rax),%al
 133:	00 fe                	add    %bh,%dh
 135:	02 00                	add    (%rax),%al
 137:	00 0e                	add    %cl,(%rsi)
 139:	03 00                	add    (%rax),%eax
 13b:	00 1c 03             	add    %bl,(%rbx,%rax,1)
  __u32 mac_addr_pos = 0;
 13e:	00 00                	add    %al,(%rax)
 140:	2a 03                	sub    (%rbx),%al
 142:	00 00                	add    %al,(%rax)
 144:	35 03 00 00 3d       	xor    $0x3d000003,%eax
  __u64 th_off = 0;
 149:	03 00                	add    (%rax),%eax
 14b:	00 52 03             	add    %dl,0x3(%rdx)
 14e:	00 00                	add    %al,(%rax)
 150:	62 03                	(bad)
 152:	00 00                	add    %al,(%rax)
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
 154:	78 03                	js     159 <balancer_ingress+0x159>
 156:	00 00                	add    %al,(%rax)
 158:	91                   	xchg   %eax,%ecx
 159:	03 00                	add    (%rax),%eax
 15b:	00 aa 03 00 00 bb    	add    %ch,-0x44fffffd(%rdx)
 161:	03 00                	add    (%rax),%eax
 163:	00 cf                	add    %cl,%bh
 165:	03 00                	add    (%rax),%eax
 167:	00 e3                	add    %ah,%bl
 169:	03 00                	add    (%rax),%eax
 16b:	00 ef                	add    %ch,%bh
 16d:	03 00                	add    (%rax),%eax
 16f:	00 f8                	add    %bh,%al
 171:	03 00                	add    (%rax),%eax
 173:	00 01                	add    %al,(%rcx)
 175:	04 00                	add    $0x0,%al
 177:	00 08                	add    %cl,(%rax)
 179:	04 00                	add    $0x0,%al
 17b:	00 15 04 00 00 20    	add    %dl,0x20000004(%rip)        # 20000185 <bpf_xdp_adjust_head+0x1fff81e5>
 181:	04 00                	add    $0x0,%al
 183:	00 2b                	add    %ch,(%rbx)
 185:	04 00                	add    $0x0,%al
 187:	00 38                	add    %bh,(%rax)
 189:	04 00                	add    $0x0,%al
 18b:	00 45 04             	add    %al,0x4(%rbp)
 18e:	00 00                	add    %al,(%rax)
 190:	52                   	push   %rdx
 191:	04 00                	add    $0x0,%al
 193:	00 5e 04             	add    %bl,0x4(%rsi)
 196:	00 00                	add    %al,(%rax)
 198:	6a 04                	push   $0x4
 19a:	00 00                	add    %al,(%rax)
 19c:	76 04                	jbe    1a2 <balancer_ingress+0x1a2>
 19e:	00 00                	add    %al,(%rax)
 1a0:	82                   	(bad)
 1a1:	04 00                	add    $0x0,%al
 1a3:	00 8e 04 00 00 99    	add    %cl,-0x66fffffc(%rsi)
 1a9:	04 00                	add    $0x0,%al
 1ab:	00 a6 04 00 00 b3    	add    %ah,-0x4cfffffc(%rsi)
 1b1:	04 00                	add    $0x0,%al
 1b3:	00 c0                	add    %al,%al
 1b5:	04 00                	add    $0x0,%al
 1b7:	00 cc                	add    %cl,%ah
 1b9:	04 00                	add    $0x0,%al
 1bb:	00 d8                	add    %bl,%al
 1bd:	04 00                	add    $0x0,%al
 1bf:	00 e3                	add    %ah,%bl
 1c1:	04 00                	add    $0x0,%al
  if (is_ipv6) {
 1c3:	00 ef                	add    %ch,%bh
 1c5:	04 00                	add    $0x0,%al
 1c7:	00 fe                	add    %bh,%dh
 1c9:	04 00                	add    $0x0,%al
 1cb:	00 0c 05 00 00 18 05 	add    %cl,0x5180000(,%rax,1)
    ip6h = data + nh_off;
 1d2:	00 00                	add    %al,(%rax)
 1d4:	25 05 00 00 32       	and    $0x32000005,%eax
 1d9:	05 00 00 3f 05       	add    $0x53f0000,%eax
 1de:	00 00                	add    %al,(%rax)
 1e0:	4f 05 00 00 5c 05    	rex.WRXB add $0x55c0000,%rax
    if (ip6h + 1 > data_end) {
 1e6:	00 00                	add    %al,(%rax)
 1e8:	6d                   	insl   (%dx),%es:(%rdi)
 1e9:	05 00 00 7d 05       	add    $0x57d0000,%eax
 1ee:	00 00                	add    %al,(%rax)
 1f0:	89 05 00 00 95 05    	mov    %eax,0x5950000(%rip)        # 59501f6 <bpf_xdp_adjust_head+0x5948256>
 1f6:	00 00                	add    %al,(%rax)
 1f8:	a3 05 00 00 ad 00 00 	movabs %eax,0x4d000000ad000005
 1ff:	00 4d 
      return XDP_DROP;
 201:	07                   	(bad)
 202:	00 00                	add    %al,(%rax)
 204:	af                   	scas   %es:(%rdi),%eax
 205:	05 00 00 bc 05       	add    $0x5bc0000,%eax
 20a:	00 00                	add    %al,(%rax)
    iph_len = sizeof(struct ipv6hdr);
 20c:	ce                   	(bad)
 20d:	05 00 00 c0 05       	add    $0x5c00000,%eax
 212:	00 00                	add    %al,(%rax)
 214:	df 05 00 00 9b 00    	filds  0x9b0000(%rip)        # 9b021a <bpf_xdp_adjust_head+0x9a827a>
    *protocol = ip6h->nexthdr;
 21a:	00 00                	add    %al,(%rax)
 21c:	f1                   	int1
 21d:	05 00 00 00 06       	add    $0x6000000,%eax
 222:	00 00                	add    %al,(%rax)
 224:	fa                   	cli
 225:	0a 00                	or     (%rax),%al
 227:	00 04 06             	add    %al,(%rsi,%rax,1)
    pckt->flow.proto = *protocol;
 22a:	00 00                	add    %al,(%rax)
 22c:	0d 06 00 00 17       	or     $0x17000006,%eax
 231:	06                   	(bad)
 232:	00 00                	add    %al,(%rax)
 234:	27                   	(bad)
 235:	06                   	(bad)
 236:	00 00                	add    %al,(%rax)
 238:	2b 06                	sub    (%rsi),%eax
 23a:	00 00                	add    %al,(%rax)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 23c:	38 06                	cmp    %al,(%rsi)
 23e:	00 00                	add    %al,(%rax)
 240:	3c 06                	cmp    $0x6,%al
 242:	00 00                	add    %al,(%rax)
 244:	49 06                	rex.WB (bad)
 246:	00 00                	add    %al,(%rax)
 248:	52                   	push   %rdx
 249:	06                   	(bad)
 24a:	00 00                	add    %al,(%rax)
 24c:	59                   	pop    %rcx
 24d:	06                   	(bad)
 24e:	00 00                	add    %al,(%rax)
 250:	60                   	(bad)
 251:	06                   	(bad)
 252:	00 00                	add    %al,(%rax)
 254:	68 06 00 00 6e       	push   $0x6e000006
 259:	06                   	(bad)
 25a:	00 00                	add    %al,(%rax)
 25c:	73 06                	jae    264 <balancer_ingress+0x264>
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 25e:	00 00                	add    %al,(%rax)
 260:	78 06                	js     268 <balancer_ingress+0x268>
 262:	00 00                	add    %al,(%rax)
 264:	7d 06                	jge    26c <balancer_ingress+0x26c>
 266:	00 00                	add    %al,(%rax)
 268:	88 06                	mov    %al,(%rsi)
 26a:	00 00                	add    %al,(%rax)
 26c:	8c 06                	mov    %es,(%rsi)
 26e:	00 00                	add    %al,(%rax)
 270:	9f                   	lahf
 271:	06                   	(bad)
 272:	00 00                	add    %al,(%rax)
 274:	a8 06                	test   $0x6,%al
 276:	00 00                	add    %al,(%rax)
 278:	b3 06                	mov    $0x6,%bl
 27a:	00 00                	add    %al,(%rax)
 27c:	bc 06 00 00 19       	mov    $0x19000006,%esp
 281:	04 00                	add    $0x0,%al
 283:	00 cb                	add    %cl,%bl
 285:	06                   	(bad)
 286:	00 00                	add    %al,(%rax)
    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
 288:	d8 06                	fadds  (%rsi)
 28a:	00 00                	add    %al,(%rax)
 28c:	e2 06                	loop   294 <balancer_ingress+0x294>
 28e:	00 00                	add    %al,(%rax)
 290:	8d 0c 00             	lea    (%rax,%rax,1),%ecx
 293:	00 e9                	add    %ch,%cl
 295:	06                   	(bad)
 296:	00 00                	add    %al,(%rax)
 298:	f1                   	int1
 299:	06                   	(bad)
 29a:	00 00                	add    %al,(%rax)
 29c:	f9                   	stc
 29d:	06                   	(bad)
 29e:	00 00                	add    %al,(%rax)
 2a0:	00 07                	add    %al,(%rdi)
 2a2:	00 00                	add    %al,(%rax)
 2a4:	04 07                	add    $0x7,%al
 2a6:	00 00                	add    %al,(%rax)
 2a8:	0e                   	(bad)
 2a9:	07                   	(bad)
 2aa:	00 00                	add    %al,(%rax)
 2ac:	1c 07                	sbb    $0x7,%al
 2ae:	00 00                	add    %al,(%rax)
 2b0:	26 07                	es (bad)
 2b2:	00 00                	add    %al,(%rax)
    *th_off += nh_off + iph_len;
 2b4:	2e 07                	cs (bad)
 2b6:	00 00                	add    %al,(%rax)
 2b8:	ac                   	lods   %ds:(%rsi),%al
 2b9:	02 00                	add    (%rax),%al
 2bb:	00 45 07             	add    %al,0x7(%rbp)
 2be:	00 00                	add    %al,(%rax)
 2c0:	08 02                	or     %al,(%rdx)
 2c2:	00 00                	add    %al,(%rax)
 2c4:	49 07                	rex.WB (bad)
 2c6:	00 00                	add    %al,(%rax)
 2c8:	55                   	push   %rbp
 2c9:	07                   	(bad)
 2ca:	00 00                	add    %al,(%rax)
 2cc:	60                   	(bad)
 2cd:	07                   	(bad)
    if (*protocol == IPPROTO_FRAGMENT) {
 2ce:	00 00                	add    %al,(%rax)
 2d0:	72 07                	jb     2d9 <balancer_ingress+0x2d9>
 2d2:	00 00                	add    %al,(%rax)
 2d4:	7b 07                	jnp    2dd <balancer_ingress+0x2dd>
 2d6:	00 00                	add    %al,(%rax)
 2d8:	7f 07                	jg     2e1 <balancer_ingress+0x2e1>
 2da:	00 00                	add    %al,(%rax)
 2dc:	90                   	nop
      return XDP_DROP;
 2dd:	07                   	(bad)
 2de:	00 00                	add    %al,(%rax)
 2e0:	98                   	cwtl
 2e1:	07                   	(bad)
 2e2:	00 00                	add    %al,(%rax)
 2e4:	9c                   	pushf
 2e5:	07                   	(bad)
 2e6:	00 00                	add    %al,(%rax)
 2e8:	a0 07 00 00 a8 07 00 	movabs 0xcb000007a8000007,%al
 2ef:	00 cb 
    } else if (*protocol == IPPROTO_ICMPV6) {
 2f1:	05 00 00 af 07       	add    $0x7af0000,%eax
 2f6:	00 00                	add    %al,(%rax)
 2f8:	b8 07 00 00 bc       	mov    $0xbc000007,%eax
      return FURTHER_PROCESSING;
 2fd:	07                   	(bad)
 2fe:	00 00                	add    %al,(%rax)
 300:	c2 07 00             	ret    $0x7
 303:	00 ca                	add    %cl,%dl
 305:	07                   	(bad)
 306:	00 00                	add    %al,(%rax)
 308:	d0 07                	rolb   (%rdi)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 30a:	00 00                	add    %al,(%rax)
 30c:	d6                   	(bad)
 30d:	07                   	(bad)
 30e:	00 00                	add    %al,(%rax)
 310:	dc 07                	faddl  (%rdi)
 312:	00 00                	add    %al,(%rax)
 314:	e2 07                	loop   31d <balancer_ingress+0x31d>
 316:	00 00                	add    %al,(%rax)
 318:	e7 07                	out    %eax,$0x7
 31a:	00 00                	add    %al,(%rax)
 31c:	f0 07                	lock (bad)
 31e:	00 00                	add    %al,(%rax)
 320:	f9                   	stc
 321:	07                   	(bad)
 322:	00 00                	add    %al,(%rax)
 324:	05 08 00 00 0d       	add    $0xd000008,%eax
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 329:	08 00                	or     %al,(%rax)
 32b:	00 17                	add    %dl,(%rdi)
 32d:	08 00                	or     %al,(%rax)
 32f:	00 1d 08 00 00 26    	add    %bl,0x26000008(%rip)        # 2600033d <bpf_xdp_adjust_head+0x25ff839d>
 335:	08 00                	or     %al,(%rax)
 337:	00 30                	add    %dh,(%rax)
 339:	08 00                	or     %al,(%rax)
 33b:	00 3a                	add    %bh,(%rdx)
 33d:	08 00                	or     %al,(%rax)
 33f:	00 43 08             	add    %al,0x8(%rbx)
 342:	00 00                	add    %al,(%rax)
 344:	4b 08 00             	rex.WXB or %al,(%r8)
  } else {
 347:	00 b4 07 00 00 5a 08 	add    %dh,0x85a0000(%rdi,%rax,1)
    iph = data + nh_off;
 34e:	00 00                	add    %al,(%rax)
 350:	67 08 00             	or     %al,(%eax)
 353:	00 70 08             	add    %dh,0x8(%rax)
 356:	00 00                	add    %al,(%rax)
 358:	7b 08                	jnp    362 <balancer_ingress+0x362>
 35a:	00 00                	add    %al,(%rax)
 35c:	86 08                	xchg   %cl,(%rax)
 35e:	00 00                	add    %al,(%rax)
    if (iph + 1 > data_end) {
 360:	92                   	xchg   %eax,%edx
 361:	08 00                	or     %al,(%rax)
 363:	00 9f 08 00 00 a9    	add    %bl,-0x56fffff8(%rdi)
 369:	08 00                	or     %al,(%rax)
 36b:	00 b3 08 00 00 bc    	add    %dh,-0x43fffff8(%rbx)
 371:	08 00                	or     %al,(%rax)
 373:	00 c3                	add    %al,%bl
 375:	08 00                	or     %al,(%rax)
      return XDP_DROP;
 377:	00 ce                	add    %cl,%dh
 379:	08 00                	or     %al,(%rax)
 37b:	00 d7                	add    %dl,%bh
 37d:	08 00                	or     %al,(%rax)
 37f:	00 e3                	add    %ah,%bl
 381:	08 00                	or     %al,(%rax)
 383:	00 ed                	add    %ch,%ch
    if (iph->ihl != 5) {
 385:	08 00                	or     %al,(%rax)
 387:	00 f6                	add    %dh,%dh
 389:	08 00                	or     %al,(%rax)
 38b:	00 ff                	add    %bh,%bh
 38d:	08 00                	or     %al,(%rax)
 38f:	00 09                	add    %cl,(%rcx)
 391:	09 00                	or     %eax,(%rax)
 393:	00 10                	add    %dl,(%rax)
 395:	09 00                	or     %eax,(%rax)
 397:	00 1a                	add    %bl,(%rdx)
      return XDP_DROP;
 399:	09 00                	or     %eax,(%rax)
 39b:	00 29                	add    %ch,(%rcx)
 39d:	09 00                	or     %eax,(%rax)
 39f:	00 31                	add    %dh,(%rcx)
 3a1:	09 00                	or     %eax,(%rax)
 3a3:	00 3d 09 00 00 48    	add    %bh,0x48000009(%rip)        # 480003b2 <bpf_xdp_adjust_head+0x47ff8412>
    pckt->tos = iph->tos;
 3a9:	09 00                	or     %eax,(%rax)
 3ab:	00 4e 09             	add    %cl,0x9(%rsi)
 3ae:	00 00                	add    %al,(%rax)
 3b0:	56                   	push   %rsi
 3b1:	09 00                	or     %eax,(%rax)
 3b3:	00 62 09             	add    %ah,0x9(%rdx)
 3b6:	00 00                	add    %al,(%rax)
 3b8:	6f                   	outsl  %ds:(%rsi),(%dx)
 3b9:	09 00                	or     %eax,(%rax)
    *protocol = iph->protocol;
 3bb:	00 78 09             	add    %bh,0x9(%rax)
 3be:	00 00                	add    %al,(%rax)
 3c0:	8a 09                	mov    (%rcx),%cl
 3c2:	00 00                	add    %al,(%rax)
 3c4:	8e 09                	mov    (%rcx),%cs
 3c6:	00 00                	add    %al,(%rax)
 3c8:	9f                   	lahf
 3c9:	09 00                	or     %eax,(%rax)
 3cb:	00 a8 09 00 00 50    	add    %ch,0x50000009(%rax)
    pckt->flow.proto = *protocol;
 3d1:	0d 00 00 ba 09       	or     $0x9ba0000,%eax
 3d6:	00 00                	add    %al,(%rax)
 3d8:	c1 09 00             	rorl   $0x0,(%rcx)
 3db:	00 f8                	add    %bh,%al
 3dd:	0d 00 00 ca 09       	or     $0x9ca0000,%eax
    *pkt_bytes = bpf_ntohs(iph->tot_len);
 3e2:	00 00                	add    %al,(%rax)
 3e4:	d1 09                	rorl   (%rcx)
 3e6:	00 00                	add    %al,(%rax)
 3e8:	d9 09                	(bad)  (%rcx)
 3ea:	00 00                	add    %al,(%rax)
 3ec:	81 08 00 00 e4 09    	orl    $0x9e40000,(%rax)
 3f2:	00 00                	add    %al,(%rax)
 3f4:	9c                   	pushf
 3f5:	08 00                	or     %al,(%rax)
 3f7:	00 de                	add    %bl,%dh
 3f9:	08 00                	or     %al,(%rax)
 3fb:	00 ed                	add    %ch,%ch
 3fd:	09 00                	or     %eax,(%rax)
 3ff:	00 f5                	add    %dh,%ch
 401:	09 00                	or     %eax,(%rax)
 403:	00 fa                	add    %bh,%dl
 405:	09 00                	or     %eax,(%rax)
 407:	00 03                	add    %al,(%rbx)
 409:	0a 00                	or     (%rax),%al
 40b:	00 0b                	add    %cl,(%rbx)
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;
 40d:	0a 00                	or     (%rax),%al
 40f:	00 1d 0a 00 00 2d    	add    %bl,0x2d00000a(%rip)        # 2d00041f <bpf_xdp_adjust_head+0x2cff847f>
 415:	0a 00                	or     (%rax),%al
 417:	00 32                	add    %dh,(%rdx)
 419:	0a 00                	or     (%rax),%al
 41b:	00 43 0a             	add    %al,0xa(%rbx)
 41e:	00 00                	add    %al,(%rax)
 420:	50                   	push   %rax
 421:	0a 00                	or     (%rax),%al
 423:	00 52 0a             	add    %dl,0xa(%rdx)
    if (iph->frag_off & PCKT_FRAGMENTED) {
 426:	00 00                	add    %al,(%rax)
 428:	63 0a                	movsxd (%rdx),%ecx
 42a:	00 00                	add    %al,(%rax)
 42c:	69 0a 00 00 c3 09    	imul   $0x9c30000,(%rdx),%ecx
 432:	00 00                	add    %al,(%rax)
 434:	bc 09 00 00 71       	mov    $0x71000009,%esp
      return XDP_DROP;
 439:	0a 00                	or     (%rax),%al
 43b:	00 6d 0a             	add    %ch,0xa(%rbp)
 43e:	00 00                	add    %al,(%rax)
 440:	75 0a                	jne    44c <balancer_ingress+0x44c>
 442:	00 00                	add    %al,(%rax)
 444:	78 0a                	js     450 <balancer_ingress+0x450>
    if (*protocol == IPPROTO_ICMP) {
 446:	00 00                	add    %al,(%rax)
 448:	7d 0a                	jge    454 <balancer_ingress+0x454>
 44a:	00 00                	add    %al,(%rax)
 44c:	82                   	(bad)
 44d:	0a 00                	or     (%rax),%al
 44f:	00 39                	add    %bh,(%rcx)
 451:	03 00                	add    (%rax),%eax
 453:	00 86 0a 00 00 8a    	add    %al,-0x75fffff6(%rsi)
      return FURTHER_PROCESSING;
 459:	0a 00                	or     (%rax),%al
 45b:	00 8e 0a 00 00 92    	add    %cl,-0x6dfffff6(%rsi)
      pckt->flow.src = iph->saddr;
 461:	0a 00                	or     (%rax),%al
 463:	00 96 0a 00 00 9a    	add    %dl,-0x65fffff6(%rsi)
 469:	0a 00                	or     (%rax),%al
 46b:	00 9e 0a 00 00 a5    	add    %bl,-0x5afffff6(%rsi)
 471:	0a 00                	or     (%rax),%al
      pckt->flow.dst = iph->daddr;
 473:	00 ad 0a 00 00 b4    	add    %ch,-0x4bfffff6(%rbp)
 479:	0a 00                	or     (%rax),%al
 47b:	00 c0                	add    %al,%al
 47d:	0a 00                	or     (%rax),%al
 47f:	00 c6                	add    %al,%dh
 481:	0a 00                	or     (%rax),%al
 483:	00 01                	add    %al,(%rcx)
 485:	08 00                	or     %al,(%rax)
  return FURTHER_PROCESSING;
 487:	00 ca                	add    %cl,%dl
 489:	0a 00                	or     (%rax),%al
 48b:	00 d1                	add    %dl,%cl
 48d:	0a 00                	or     (%rax),%al
 48f:	00 ea                	add    %ch,%dl
}
 491:	0a 00                	or     (%rax),%al
 493:	00 6b 07             	add    %ch,0x7(%rbx)
 496:	00 00                	add    %al,(%rax)
  action = parse_l3_headers(
 498:	f5                   	cmc
 499:	0a 00                	or     (%rax),%al
 49b:	00 ff                	add    %bh,%bh
  if (action >= 0) {
 49d:	0a 00                	or     (%rax),%al
 49f:	00 08                	add    %cl,(%rax)
 4a1:	0b 00                	or     (%rax),%eax
 4a3:	00 0f                	add    %cl,(%rdi)
 4a5:	0b 00                	or     (%rax),%eax
    return action;
 4a7:	00 d3                	add    %dl,%bl
 4a9:	05 00 00 1d 0b       	add    $0xb1d0000,%eax
 4ae:	00 00                	add    %al,(%rax)
 4b0:	3e 0b 00             	ds or  (%rax),%eax
 4b3:	00 6e 0b             	add    %ch,0xb(%rsi)
 4b6:	00 00                	add    %al,(%rax)
  action = handle_if_icmp(data, data_end, th_off, &pckt, protocol);
 4b8:	61                   	(bad)
 4b9:	0b 00                	or     (%rax),%eax
 4bb:	00 6a 0b             	add    %ch,0xb(%rdx)
 4be:	00 00                	add    %al,(%rax)
 4c0:	76 0b                	jbe    4cd <balancer_ingress+0x4cd>
 4c2:	00 00                	add    %al,(%rax)
 4c4:	85 0b                	test   %ecx,(%rbx)
 4c6:	00 00                	add    %al,(%rax)
 4c8:	93                   	xchg   %eax,%ebx
 4c9:	0b 00                	or     (%rax),%eax
 4cb:	00 a3 0b 00 00 c0    	add    %ah,-0x3ffffff5(%rbx)
 4d1:	0b 00                	or     (%rax),%eax
 4d3:	00 c8                	add    %cl,%al
 4d5:	0b 00                	or     (%rax),%eax
 4d7:	00 d6                	add    %dl,%dh
 4d9:	0b 00                	or     (%rax),%eax
 4db:	00 e4                	add    %ah,%ah
 4dd:	0b 00                	or     (%rax),%eax
 4df:	00 26                	add    %ah,(%rsi)
 4e1:	0c 00                	or     $0x0,%al
 4e3:	00 fc                	add    %bh,%ah
 4e5:	0b 00                	or     (%rax),%eax
 4e7:	00 08                	add    %cl,(%rax)
 4e9:	0c 00                	or     $0x0,%al
 4eb:	00 69 03             	add    %ch,0x3(%rcx)
 4ee:	00 00                	add    %al,(%rax)
 4f0:	21 0c 00             	and    %ecx,(%rax,%rax,1)
 4f3:	00 2b                	add    %ch,(%rbx)
 4f5:	0c 00                	or     $0x0,%al
 4f7:	00 36                	add    %dh,(%rsi)
 4f9:	0c 00                	or     $0x0,%al
  if (protocol == IPPROTO_ICMPV6) {
 4fb:	00 79 0b             	add    %bh,0xb(%rcx)
 4fe:	00 00                	add    %al,(%rax)
 500:	45 0c 00             	rex.RB or $0x0,%al
 503:	00 67 0c             	add    %ah,0xc(%rdi)
 506:	00 00                	add    %al,(%rax)
 508:	4f 0c 00             	rex.WRXB or $0x0,%al
    return parse_icmpv6(data, data_end, off, pckt);
 50b:	00 5c 0c 00          	add    %bl,0x0(%rsp,%rcx,1)
 50f:	00 6c 0c 00          	add    %ch,0x0(%rsp,%rcx,1)
 513:	00 85 0c 00 00 97    	add    %al,-0x68fffff4(%rbp)
 519:	0c 00                	or     $0x0,%al
 51b:	00 a5 0c 00 00 bf    	add    %ah,-0x40fffff4(%rbp)
 521:	0c 00                	or     $0x0,%al
 523:	00 d9                	add    %bl,%cl
 525:	0c 00                	or     $0x0,%al
 527:	00 ec                	add    %ch,%ah
 529:	0c 00                	or     $0x0,%al
 52b:	00 fe                	add    %bh,%dh
 52d:	0c 00                	or     $0x0,%al
 52f:	00 0c 0d 00 00 17 0d 	add    %cl,0xd170000(,%rcx,1)
 536:	00 00                	add    %al,(%rax)
 538:	23 0d 00 00 2d 0d    	and    0xd2d0000(%rip),%ecx        # d2d053e <bpf_xdp_adjust_head+0xd2c859e>
 53e:	00 00                	add    %al,(%rax)
 540:	3b 0d 00 00 44 0d    	cmp    0xd440000(%rip),%ecx        # d440546 <bpf_xdp_adjust_head+0xd4385a6>
  icmp_hdr = data + off;
 546:	00 00                	add    %al,(%rax)
 548:	4c 0d 00 00 54 0d    	rex.WR or $0xd540000,%rax
 54e:	00 00                	add    %al,(%rax)
 550:	6a 0d                	push   $0xd
 552:	00 00                	add    %al,(%rax)
 554:	78 0d                	js     563 <balancer_ingress+0x563>
 556:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 558:	7b 0d                	jnp    567 <balancer_ingress+0x567>
 55a:	00 00                	add    %al,(%rax)
 55c:	84 0d 00 00 8b 0d    	test   %cl,0xd8b0000(%rip)        # d8b0562 <bpf_xdp_adjust_head+0xd8a85c2>
 562:	00 00                	add    %al,(%rax)
 564:	a1 0d 00 00 ab 0d 00 	movabs 0xb900000dab00000d,%eax
 56b:	00 b9 
 56d:	0d 00 00 ca 0d       	or     $0xdca0000,%eax
    return XDP_DROP;
 572:	00 00                	add    %al,(%rax)
 574:	d0 0d 00 00 dd 0d    	rorb   0xddd0000(%rip)        # ddd057a <bpf_xdp_adjust_head+0xddc85da>
 57a:	00 00                	add    %al,(%rax)
 57c:	ec                   	in     (%dx),%al
 57d:	0d 00 00 f2 0d       	or     $0xdf20000,%eax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 582:	00 00                	add    %al,(%rax)
 584:	f6 0d 00 00 00 0e 00 	testb  $0x0,0xe000000(%rip)        # e00058b <bpf_xdp_adjust_head+0xdff85eb>
 58b:	00 07                	add    %al,(%rdi)
 58d:	0e                   	(bad)
 58e:	00 00                	add    %al,(%rax)
 590:	6d                   	insl   (%dx),%es:(%rdi)
 591:	09 00                	or     %eax,(%rax)
    return send_icmp6_reply(data, data_end);
 593:	00 0f                	add    %cl,(%rdi)
 595:	0e                   	(bad)
 596:	00 00                	add    %al,(%rax)
 598:	38 00                	cmp    %al,(%rax)
 59a:	00 00                	add    %al,(%rax)
 59c:	90                   	nop
 59d:	0a 00                	or     (%rax),%al
 59f:	00 11                	add    %dl,(%rcx)
 5a1:	0e                   	(bad)
 5a2:	00 00                	add    %al,(%rax)
 5a4:	16                   	(bad)
 5a5:	0e                   	(bad)
	...

Disassembly of section .debug_str:

0000000000000000 <.debug_str>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	44                   	rex.R
   1:	65 62                	gs (bad)
   3:	69 61 6e 20 63 6c 61 	imul   $0x616c6320,0x6e(%rcx),%esp
   a:	6e                   	outsb  %ds:(%rsi),(%dx)
   b:	67 20 76 65          	and    %dh,0x65(%esi)
   f:	72 73                	jb     84 <balancer_ingress+0x84>
  11:	69 6f 6e 20 31 34 2e 	imul   $0x2e343120,0x6e(%rdi),%ebp
  void* data = (void*)(long)ctx->data;
  18:	30 2e                	xor    %ch,(%rsi)
  1a:	36 00 6b 61          	ss add %ch,0x61(%rbx)
  1e:	74 72                	je     92 <balancer_ingress+0x92>
  20:	61                   	(bad)
  21:	6e                   	outsb  %ds:(%rsi),(%dx)
  22:	2f                   	(bad)
  23:	6c                   	insb   (%dx),%es:(%rdi)
  24:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
  void* data_end = (void*)(long)ctx->data_end;
  2b:	62 61 6c 61 6e       	(bad)
  30:	63 65 72             	movsxd 0x72(%rbp),%esp
  33:	2e 62                	cs (bad)
  35:	70 66                	jo     9d <balancer_ingress+0x9d>
  37:	2e 63 00             	cs movsxd (%rax),%eax
  struct ethhdr* eth = data;
  3a:	2f                   	(bad)
  3b:	72 6f                	jb     ac <balancer_ingress+0xac>
  3d:	6f                   	outsl  %ds:(%rsi),(%dx)
  3e:	74 2f                	je     6f <balancer_ingress+0x6f>
  40:	57                   	push   %rdi
  41:	6f                   	outsl  %ds:(%rsi),(%dx)
  42:	72 6b                	jb     af <balancer_ingress+0xaf>
  44:	73 70                	jae    b6 <balancer_ingress+0xb6>
  46:	61                   	(bad)
  nh_off = sizeof(struct ethhdr);
  47:	63 65 2f             	movsxd 0x2f(%rbp),%esp
  4a:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  4e:	61                   	(bad)
  4f:	6e                   	outsb  %ds:(%rsi),(%dx)
  50:	2f                   	(bad)
  if (data + nh_off > data_end) {
  51:	5f                   	pop    %rdi
  52:	62 75                	(bad)
  54:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
  5b:	73 
  5c:	2f                   	(bad)
  5d:	62                   	(bad)
  5e:	70 66                	jo     c6 <balancer_ingress+0xc6>
  60:	70 72                	jo     d4 <balancer_ingress+0xd4>
  62:	6f                   	outsl  %ds:(%rsi),(%dx)
  63:	67 00 5f 6c          	add    %bl,0x6c(%edi)
  67:	69 63 65 6e 73 65 00 	imul   $0x65736e,0x65(%rbx),%esp
    return XDP_DROP;
  6e:	5f                   	pop    %rdi
  6f:	5f                   	pop    %rdi
  70:	41 52                	push   %r10
  72:	52                   	push   %rdx
  73:	41 59                	pop    %r9
  75:	5f                   	pop    %rdi
  76:	53                   	push   %rbx
  77:	49 5a                	rex.WB pop %r10
  eth_proto = eth->h_proto;
  79:	45 5f                	rex.RB pop %r15
  7b:	54                   	push   %rsp
  7c:	59                   	pop    %rcx
  7d:	50                   	push   %rax
  7e:	45 5f                	rex.RB pop %r15
  80:	5f                   	pop    %rdi
  81:	00 63 74             	add    %ah,0x74(%rbx)
  84:	6c                   	insb   (%dx),%es:(%rdi)
  85:	5f                   	pop    %rdi
  86:	61                   	(bad)
  87:	72 72                	jb     fb <balancer_ingress+0xfb>
  89:	61                   	(bad)
  if (eth_proto == BE_ETH_P_IP) {
  8a:	79 00                	jns    8c <balancer_ingress+0x8c>
  8c:	75 6e                	jne    fc <balancer_ingress+0xfc>
  8e:	73 69                	jae    f9 <balancer_ingress+0xf9>
  90:	67 6e                	outsb  %ds:(%esi),(%dx)
  92:	65 64 20 69 6e       	gs and %ch,%fs:0x6e(%rcx)
    return process_packet(ctx, nh_off, false);
  97:	74 00                	je     99 <balancer_ingress+0x99>
  99:	5f                   	pop    %rdi
  9a:	5f                   	pop    %rdi
  9b:	75 33                	jne    d0 <balancer_ingress+0xd0>
  9d:	32 00                	xor    (%rax),%al
  9f:	75 6e                	jne    10f <balancer_ingress+0x10f>
  a1:	73 69                	jae    10c <balancer_ingress+0x10c>
  a3:	67 6e                	outsb  %ds:(%esi),(%dx)
  a5:	65 64 20 6c 6f 6e    	gs and %ch,%fs:0x6e(%rdi,%rbp,2)
  ab:	67 20 6c 6f 6e       	and    %ch,0x6e(%edi,%ebp,2)
  b0:	67 00 5f 5f          	add    %bl,0x5f(%edi)
  b4:	75 36                	jne    ec <balancer_ingress+0xec>
  b6:	34 00                	xor    $0x0,%al
  b8:	69 66 69 6e 64 65 78 	imul   $0x7865646e,0x69(%rsi),%esp
  void* data = (void*)(long)xdp->data;
  bf:	00 75 6e             	add    %dh,0x6e(%rbp)
  c2:	73 69                	jae    12d <balancer_ingress+0x12d>
  c4:	67 6e                	outsb  %ds:(%esi),(%dx)
  c6:	65 64 20 63 68       	gs and %ah,%fs:0x68(%rbx)
  void* data_end = (void*)(long)xdp->data_end;
  cb:	61                   	(bad)
  cc:	72 00                	jb     ce <balancer_ingress+0xce>
  ce:	5f                   	pop    %rdi
  cf:	5f                   	pop    %rdi
  d0:	75 38                	jne    10a <balancer_ingress+0x10a>
  d2:	00 63 74             	add    %ah,0x74(%rbx)
  d5:	6c                   	insb   (%dx),%es:(%rdi)
  d6:	5f                   	pop    %rdi
  d7:	76 61                	jbe    13a <balancer_ingress+0x13a>
  d9:	6c                   	insb   (%dx),%es:(%rdi)
  da:	75 65                	jne    141 <balancer_ingress+0x141>
  struct real_definition* dst = NULL;
  dc:	00 6d 61             	add    %ch,0x61(%rbp)
  df:	78 5f                	js     140 <balancer_ingress+0x140>
  e1:	65 6e                	outsb  %gs:(%rsi),(%dx)
  e3:	74 72                	je     157 <balancer_ingress+0x157>
  e5:	69 65 73 00 6d 61 70 	imul   $0x70616d00,0x73(%rbp),%esp
  struct packet_description pckt = {};
  ec:	5f                   	pop    %rdi
  ed:	66 6c                	data16 insb (%dx),%es:(%rdi)
  ef:	61                   	(bad)
  f0:	67 73 00             	addr32 jae f3 <balancer_ingress+0xf3>
  f3:	76 69                	jbe    15e <balancer_ingress+0x15e>
  f5:	70 5f                	jo     156 <balancer_ingress+0x156>
  f7:	6d                   	insl   (%dx),%es:(%rdi)
  f8:	61                   	(bad)
  f9:	70 00                	jo     fb <balancer_ingress+0xfb>
  fb:	5f                   	pop    %rdi
  fc:	5f                   	pop    %rdi
  fd:	62 65                	(bad)
  ff:	33 32                	xor    (%rdx),%esi
 101:	00 76 69             	add    %dh,0x69(%rsi)
 104:	70 76                	jo     17c <balancer_ingress+0x17c>
 106:	36 00 75 6e          	ss add %dh,0x6e(%rbp)
 10a:	73 69                	jae    175 <balancer_ingress+0x175>
 10c:	67 6e                	outsb  %ds:(%esi),(%dx)
 10e:	65 64 20 73 68       	gs and %dh,%fs:0x68(%rbx)
 113:	6f                   	outsl  %ds:(%rsi),(%dx)
 114:	72 74                	jb     18a <balancer_ingress+0x18a>
 116:	00 5f 5f             	add    %bl,0x5f(%rdi)
 119:	75 31                	jne    14c <balancer_ingress+0x14c>
 11b:	36 00 76 69          	ss add %dh,0x69(%rsi)
  struct vip_definition vip = {};
 11f:	70 5f                	jo     180 <balancer_ingress+0x180>
 121:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
 128:	69 
 129:	6f                   	outsl  %ds:(%rsi),(%dx)
 12a:	6e                   	outsb  %ds:(%rsi),(%dx)
 12b:	00 76 69             	add    %dh,0x69(%rsi)
 12e:	70 5f                	jo     18f <balancer_ingress+0x18f>
 130:	6e                   	outsb  %ds:(%rsi),(%dx)
 131:	75 6d                	jne    1a0 <balancer_ingress+0x1a0>
 133:	00 76 69             	add    %dh,0x69(%rsi)
 136:	70 5f                	jo     197 <balancer_ingress+0x197>
 138:	6d                   	insl   (%dx),%es:(%rdi)
 139:	65 74 61             	gs je  19d <balancer_ingress+0x19d>
 13c:	00 66 61             	add    %ah,0x61(%rsi)
  __u32 mac_addr_pos = 0;
 13f:	6c                   	insb   (%dx),%es:(%rdi)
 140:	6c                   	insb   (%dx),%es:(%rdi)
 141:	62 61                	(bad)
 143:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
 146:	63 61 63             	movsxd 0x63(%rcx),%esp
  __u64 th_off = 0;
 149:	68 65 00 73 72       	push   $0x72730065
 14e:	63 76 36             	movsxd 0x36(%rsi),%esi
 151:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
 155:	76 36                	jbe    18d <balancer_ingress+0x18d>
 157:	00 70 6f             	add    %dh,0x6f(%rax)
 15a:	72 74                	jb     1d0 <balancer_ingress+0x1d0>
 15c:	73 00                	jae    15e <balancer_ingress+0x15e>
 15e:	70 6f                	jo     1cf <balancer_ingress+0x1cf>
 160:	72 74                	jb     1d6 <balancer_ingress+0x1d6>
 162:	31 36                	xor    %esi,(%rsi)
 164:	00 66 6c             	add    %ah,0x6c(%rsi)
 167:	6f                   	outsl  %ds:(%rsi),(%dx)
 168:	77 5f                	ja     1c9 <balancer_ingress+0x1c9>
 16a:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 16e:	61                   	(bad)
 16f:	74 69                	je     1da <balancer_ingress+0x1da>
 171:	6d                   	insl   (%dx),%es:(%rdi)
 172:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
 176:	61                   	(bad)
 177:	6c                   	insb   (%dx),%es:(%rdi)
 178:	5f                   	pop    %rdi
 179:	70 6f                	jo     1ea <balancer_ingress+0x1ea>
 17b:	73 5f                	jae    1dc <balancer_ingress+0x1dc>
 17d:	6c                   	insb   (%dx),%es:(%rdi)
 17e:	72 75                	jb     1f5 <balancer_ingress+0x1f5>
 180:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
 184:	5f                   	pop    %rdi
 185:	6d                   	insl   (%dx),%es:(%rdi)
 186:	61                   	(bad)
 187:	70 70                	jo     1f9 <balancer_ingress+0x1f9>
 189:	69 6e 67 00 76 61 6c 	imul   $0x6c617600,0x67(%rsi),%ebp
 190:	75 65                	jne    1f7 <balancer_ingress+0x1f7>
 192:	73 00                	jae    194 <balancer_ingress+0x194>
 194:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 197:	72 69                	jb     202 <balancer_ingress+0x202>
 199:	6e                   	outsb  %ds:(%rsi),(%dx)
 19a:	67 73 00             	addr32 jae 19d <balancer_ingress+0x19d>
 19d:	72 65                	jb     204 <balancer_ingress+0x204>
 19f:	61                   	(bad)
 1a0:	6c                   	insb   (%dx),%es:(%rdi)
 1a1:	73 00                	jae    1a3 <balancer_ingress+0x1a3>
 1a3:	72 65                	jb     20a <balancer_ingress+0x20a>
 1a5:	61                   	(bad)
 1a6:	6c                   	insb   (%dx),%es:(%rdi)
 1a7:	5f                   	pop    %rdi
 1a8:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
 1af:	69 
 1b0:	6f                   	outsl  %ds:(%rsi),(%dx)
 1b1:	6e                   	outsb  %ds:(%rsi),(%dx)
 1b2:	00 72 65             	add    %dh,0x65(%rdx)
 1b5:	61                   	(bad)
 1b6:	6c                   	insb   (%dx),%es:(%rdi)
 1b7:	73 5f                	jae    218 <balancer_ingress+0x218>
 1b9:	73 74                	jae    22f <balancer_ingress+0x22f>
 1bb:	61                   	(bad)
 1bc:	74 73                	je     231 <balancer_ingress+0x231>
 1be:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 1c2:	73 74                	jae    238 <balancer_ingress+0x238>
  if (is_ipv6) {
 1c4:	61                   	(bad)
 1c5:	74 73                	je     23a <balancer_ingress+0x23a>
 1c7:	00 76 69             	add    %dh,0x69(%rsi)
 1ca:	70 5f                	jo     22b <balancer_ingress+0x22b>
 1cc:	6d                   	insl   (%dx),%es:(%rdi)
 1cd:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
    ip6h = data + nh_off;
 1d4:	74 73                	je     249 <balancer_ingress+0x249>
 1d6:	00 71 75             	add    %dh,0x75(%rcx)
 1d9:	69 63 5f 73 74 61 74 	imul   $0x74617473,0x5f(%rbx),%esp
 1e0:	73 5f                	jae    241 <balancer_ingress+0x241>
 1e2:	6d                   	insl   (%dx),%es:(%rdi)
 1e3:	61                   	(bad)
 1e4:	70 00                	jo     1e6 <balancer_ingress+0x1e6>
    if (ip6h + 1 > data_end) {
 1e6:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 1e9:	72 6f                	jb     25a <balancer_ingress+0x25a>
 1eb:	75 74                	jne    261 <balancer_ingress+0x261>
 1ed:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 1f2:	64 5f                	fs pop %rdi
 1f4:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
 1fb:	00 63 69             	add    %ah,0x69(%rbx)
      return XDP_DROP;
 1fe:	64 5f                	fs pop %rdi
 200:	69 6e 76 61 6c 69 64 	imul   $0x64696c61,0x76(%rsi),%ebp
 207:	5f                   	pop    %rdi
 208:	73 65                	jae    26f <balancer_ingress+0x26f>
 20a:	72 76                	jb     282 <balancer_ingress+0x282>
    iph_len = sizeof(struct ipv6hdr);
 20c:	65 72 5f             	gs jb  26e <balancer_ingress+0x26e>
 20f:	69 64 00 63 69 64 5f 	imul   $0x695f6469,0x63(%rax,%rax,1),%esp
 216:	69 
    *protocol = ip6h->nexthdr;
 217:	6e                   	outsb  %ds:(%rsi),(%dx)
 218:	76 61                	jbe    27b <balancer_ingress+0x27b>
 21a:	6c                   	insb   (%dx),%es:(%rdi)
 21b:	69 64 5f 73 65 72 76 	imul   $0x65767265,0x73(%rdi,%rbx,2),%esp
 222:	65 
 223:	72 5f                	jb     284 <balancer_ingress+0x284>
 225:	69 64 5f 73 61 6d 70 	imul   $0x6c706d61,0x73(%rdi,%rbx,2),%esp
 22c:	6c 
    pckt->flow.proto = *protocol;
 22d:	65 00 63 69          	add    %ah,%gs:0x69(%rbx)
 231:	64 5f                	fs pop %rdi
 233:	72 6f                	jb     2a4 <balancer_ingress+0x2a4>
 235:	75 74                	jne    2ab <balancer_ingress+0x2ab>
 237:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 23c:	64 5f                	fs pop %rdi
 23e:	75 6e                	jne    2ae <balancer_ingress+0x2ae>
 240:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
 244:	6e                   	outsb  %ds:(%rsi),(%dx)
 245:	5f                   	pop    %rdi
 246:	72 65                	jb     2ad <balancer_ingress+0x2ad>
 248:	61                   	(bad)
 249:	6c                   	insb   (%dx),%es:(%rdi)
 24a:	5f                   	pop    %rdi
 24b:	64 72 6f             	fs jb  2bd <balancer_ingress+0x2bd>
 24e:	70 70                	jo     2c0 <balancer_ingress+0x2c0>
 250:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
 255:	64 5f                	fs pop %rdi
 257:	76 30                	jbe    289 <balancer_ingress+0x289>
 259:	00 63 69             	add    %ah,0x69(%rbx)
 25c:	64 5f                	fs pop %rdi
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 25e:	76 31                	jbe    291 <balancer_ingress+0x291>
 260:	00 63 69             	add    %ah,0x69(%rbx)
 263:	64 5f                	fs pop %rdi
 265:	76 32                	jbe    299 <balancer_ingress+0x299>
 267:	00 63 69             	add    %ah,0x69(%rbx)
 26a:	64 5f                	fs pop %rdi
 26c:	76 33                	jbe    2a1 <balancer_ingress+0x2a1>
 26e:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 272:	5f                   	pop    %rdi
 273:	6d                   	insl   (%dx),%es:(%rdi)
 274:	61                   	(bad)
 275:	74 63                	je     2da <balancer_ingress+0x2da>
 277:	68 5f 69 6e 5f       	push   $0x5f6e695f
 27c:	6c                   	insb   (%dx),%es:(%rdi)
 27d:	72 75                	jb     2f4 <balancer_ingress+0x2f4>
 27f:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
 283:	5f                   	pop    %rdi
 284:	6d                   	insl   (%dx),%es:(%rdi)
 285:	69 73 6d 61 74 63 68 	imul   $0x68637461,0x6d(%rbx),%esi
    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
 28c:	5f                   	pop    %rdi
 28d:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
 294:	64 73 74             	fs jae 30b <balancer_ingress+0x30b>
 297:	5f                   	pop    %rdi
 298:	6e                   	outsb  %ds:(%rsi),(%dx)
 299:	6f                   	outsl  %ds:(%rsi),(%dx)
 29a:	74 5f                	je     2fb <balancer_ingress+0x2fb>
 29c:	66 6f                	outsw  %ds:(%rsi),(%dx)
 29e:	75 6e                	jne    30e <balancer_ingress+0x30e>
 2a0:	64 5f                	fs pop %rdi
 2a2:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
 2a9:	6c                   	insb   (%dx),%es:(%rdi)
 2aa:	62                   	(bad)
 2ab:	5f                   	pop    %rdi
 2ac:	71 75                	jno    323 <balancer_ingress+0x323>
 2ae:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
    *th_off += nh_off + iph_len;
 2b5:	65 74 73             	gs je  32b <balancer_ingress+0x32b>
 2b8:	5f                   	pop    %rdi
 2b9:	73 74                	jae    32f <balancer_ingress+0x32f>
 2bb:	61                   	(bad)
 2bc:	74 73                	je     331 <balancer_ingress+0x331>
 2be:	00 73 74             	add    %dh,0x74(%rbx)
 2c1:	61                   	(bad)
 2c2:	62                   	(bad)
 2c3:	6c                   	insb   (%dx),%es:(%rdi)
 2c4:	65 5f                	gs pop %rdi
 2c6:	72 74                	jb     33c <balancer_ingress+0x33c>
 2c8:	5f                   	pop    %rdi
 2c9:	73 74                	jae    33f <balancer_ingress+0x33f>
 2cb:	61                   	(bad)
 2cc:	74 73                	je     341 <balancer_ingress+0x341>
    if (*protocol == IPPROTO_FRAGMENT) {
 2ce:	00 69 6e             	add    %ch,0x6e(%rcx)
 2d1:	76 61                	jbe    334 <balancer_ingress+0x334>
 2d3:	6c                   	insb   (%dx),%es:(%rdi)
 2d4:	69 64 5f 70 61 63 6b 	imul   $0x656b6361,0x70(%rdi,%rbx,2),%esp
 2db:	65 
 2dc:	74 5f                	je     33d <balancer_ingress+0x33d>
      return XDP_DROP;
 2de:	74 79                	je     359 <balancer_ingress+0x359>
 2e0:	70 65                	jo     347 <balancer_ingress+0x347>
 2e2:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 2e6:	73 74                	jae    35c <balancer_ingress+0x35c>
 2e8:	61                   	(bad)
 2e9:	62                   	(bad)
 2ea:	6c                   	insb   (%dx),%es:(%rdi)
 2eb:	65 5f                	gs pop %rdi
    } else if (*protocol == IPPROTO_ICMPV6) {
 2ed:	72 74                	jb     363 <balancer_ingress+0x363>
 2ef:	5f                   	pop    %rdi
 2f0:	70 61                	jo     353 <balancer_ingress+0x353>
 2f2:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 2f5:	74 73                	je     36a <balancer_ingress+0x36a>
 2f7:	5f                   	pop    %rdi
 2f8:	73 74                	jae    36e <balancer_ingress+0x36e>
 2fa:	61                   	(bad)
      return FURTHER_PROCESSING;
 2fb:	74 73                	je     370 <balancer_ingress+0x370>
 2fd:	00 64 65 63          	add    %ah,0x63(%rbp,%riz,2)
 301:	61                   	(bad)
 302:	70 5f                	jo     363 <balancer_ingress+0x363>
 304:	76 69                	jbe    36f <balancer_ingress+0x36f>
 306:	70 5f                	jo     367 <balancer_ingress+0x367>
 308:	73 74                	jae    37e <balancer_ingress+0x37e>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 30a:	61                   	(bad)
 30b:	74 73                	je     380 <balancer_ingress+0x380>
 30d:	00 73 65             	add    %dh,0x65(%rbx)
 310:	72 76                	jb     388 <balancer_ingress+0x388>
 312:	65 72 5f             	gs jb  374 <balancer_ingress+0x374>
 315:	69 64 5f 6d 61 70 00 	imul   $0x74007061,0x6d(%rdi,%rbx,2),%esp
 31c:	74 
 31d:	70 72                	jo     391 <balancer_ingress+0x391>
 31f:	5f                   	pop    %rdi
 320:	73 74                	jae    396 <balancer_ingress+0x396>
 322:	61                   	(bad)
 323:	74 73                	je     398 <balancer_ingress+0x398>
 325:	5f                   	pop    %rdi
 326:	6d                   	insl   (%dx),%es:(%rdi)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 327:	61                   	(bad)
 328:	70 00                	jo     32a <balancer_ingress+0x32a>
 32a:	73 69                	jae    395 <balancer_ingress+0x395>
 32c:	64 5f                	fs pop %rdi
 32e:	72 6f                	jb     39f <balancer_ingress+0x39f>
 330:	75 74                	jne    3a6 <balancer_ingress+0x3a6>
 332:	65 64 00 74 63 70    	gs add %dh,%fs:0x70(%rbx,%riz,2)
 338:	5f                   	pop    %rdi
 339:	73 79                	jae    3b4 <balancer_ingress+0x3b4>
 33b:	6e                   	outsb  %ds:(%rsi),(%dx)
 33c:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
 340:	74 70                	je     3b2 <balancer_ingress+0x3b2>
 342:	72 5f                	jb     3a3 <balancer_ingress+0x3a3>
 344:	70 61                	jo     3a7 <balancer_ingress+0x3a7>
  } else {
 346:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 349:	74 73                	je     3be <balancer_ingress+0x3be>
    iph = data + nh_off;
 34b:	5f                   	pop    %rdi
 34c:	73 74                	jae    3c2 <balancer_ingress+0x3c2>
 34e:	61                   	(bad)
 34f:	74 73                	je     3c4 <balancer_ingress+0x3c4>
 351:	00 73 65             	add    %dh,0x65(%rbx)
 354:	72 76                	jb     3cc <balancer_ingress+0x3cc>
 356:	65 72 5f             	gs jb  3b8 <balancer_ingress+0x3b8>
 359:	69 64 5f 73 74 61 74 	imul   $0x73746174,0x73(%rdi,%rbx,2),%esp
 360:	73 
    if (iph + 1 > data_end) {
 361:	00 76 69             	add    %dh,0x69(%rsi)
 364:	70 5f                	jo     3c5 <balancer_ingress+0x3c5>
 366:	74 6f                	je     3d7 <balancer_ingress+0x3d7>
 368:	5f                   	pop    %rdi
 369:	64 6f                	outsl  %fs:(%rsi),(%dx)
 36b:	77 6e                	ja     3db <balancer_ingress+0x3db>
 36d:	5f                   	pop    %rdi
 36e:	72 65                	jb     3d5 <balancer_ingress+0x3d5>
 370:	61                   	(bad)
 371:	6c                   	insb   (%dx),%es:(%rdi)
 372:	73 5f                	jae    3d3 <balancer_ingress+0x3d3>
 374:	6d                   	insl   (%dx),%es:(%rdi)
 375:	61                   	(bad)
      return XDP_DROP;
 376:	70 00                	jo     378 <balancer_ingress+0x378>
 378:	62                   	(bad)
 379:	70 66                	jo     3e1 <balancer_ingress+0x3e1>
 37b:	5f                   	pop    %rdi
 37c:	67 65 74 5f          	addr32 gs je 3df <balancer_ingress+0x3df>
 380:	73 6d                	jae    3ef <balancer_ingress+0x3ef>
 382:	70 5f                	jo     3e3 <balancer_ingress+0x3e3>
 384:	70 72                	jo     3f8 <balancer_ingress+0x3f8>
    if (iph->ihl != 5) {
 386:	6f                   	outsl  %ds:(%rsi),(%dx)
 387:	63 65 73             	movsxd 0x73(%rbp),%esp
 38a:	73 6f                	jae    3fb <balancer_ingress+0x3fb>
 38c:	72 5f                	jb     3ed <balancer_ingress+0x3ed>
 38e:	69 64 00 72 65 61 6c 	imul   $0x5f6c6165,0x72(%rax,%rax,1),%esp
 395:	5f 
 396:	62                   	(bad)
 397:	70 66                	jo     3ff <balancer_ingress+0x3ff>
      return XDP_DROP;
 399:	5f                   	pop    %rdi
 39a:	6d                   	insl   (%dx),%es:(%rdi)
 39b:	61                   	(bad)
 39c:	70 5f                	jo     3fd <balancer_ingress+0x3fd>
 39e:	6c                   	insb   (%dx),%es:(%rdi)
 39f:	6f                   	outsl  %ds:(%rsi),(%dx)
 3a0:	6f                   	outsl  %ds:(%rsi),(%dx)
 3a1:	6b 75 70 5f          	imul   $0x5f,0x70(%rbp),%esi
 3a5:	65 6c                	gs insb (%dx),%es:(%rdi)
    pckt->tos = iph->tos;
 3a7:	65 6d                	gs insl (%dx),%es:(%rdi)
 3a9:	00 62 70             	add    %ah,0x70(%rdx)
 3ac:	66 5f                	pop    %di
 3ae:	6b 74 69 6d 65       	imul   $0x65,0x6d(%rcx,%rbp,2),%esi
 3b3:	5f                   	pop    %rdi
 3b4:	67 65 74 5f          	addr32 gs je 417 <balancer_ingress+0x417>
 3b8:	6e                   	outsb  %ds:(%rsi),(%dx)
 3b9:	73 00                	jae    3bb <balancer_ingress+0x3bb>
    *protocol = iph->protocol;
 3bb:	62                   	(bad)
 3bc:	70 66                	jo     424 <balancer_ingress+0x424>
 3be:	5f                   	pop    %rdi
 3bf:	6d                   	insl   (%dx),%es:(%rdi)
 3c0:	61                   	(bad)
 3c1:	70 5f                	jo     422 <balancer_ingress+0x422>
 3c3:	75 70                	jne    435 <balancer_ingress+0x435>
 3c5:	64 61                	fs (bad)
 3c7:	74 65                	je     42e <balancer_ingress+0x42e>
 3c9:	5f                   	pop    %rdi
 3ca:	65 6c                	gs insb (%dx),%es:(%rdi)
 3cc:	65 6d                	gs insl (%dx),%es:(%rdi)
    pckt->flow.proto = *protocol;
 3ce:	00 62 70             	add    %ah,0x70(%rdx)
 3d1:	66 5f                	pop    %di
 3d3:	78 64                	js     439 <balancer_ingress+0x439>
 3d5:	70 5f                	jo     436 <balancer_ingress+0x436>
 3d7:	61                   	(bad)
 3d8:	64 6a 75             	fs push $0x75
 3db:	73 74                	jae    451 <balancer_ingress+0x451>
 3dd:	5f                   	pop    %rdi
 3de:	68 65 61 64 00       	push   $0x646165
    *pkt_bytes = bpf_ntohs(iph->tot_len);
 3e3:	58                   	pop    %rax
 3e4:	44 50                	rex.R push %rax
 3e6:	5f                   	pop    %rdi
 3e7:	41                   	rex.B
 3e8:	42                   	rex.X
 3e9:	4f 52                	rex.WRXB push %r10
 3eb:	54                   	push   %rsp
 3ec:	45                   	rex.RB
 3ed:	44 00 58 44          	add    %r11b,0x44(%rax)
 3f1:	50                   	push   %rax
 3f2:	5f                   	pop    %rdi
 3f3:	44 52                	rex.R push %rdx
 3f5:	4f 50                	rex.WRXB push %r8
 3f7:	00 58 44             	add    %bl,0x44(%rax)
 3fa:	50                   	push   %rax
 3fb:	5f                   	pop    %rdi
 3fc:	50                   	push   %rax
 3fd:	41 53                	push   %r11
 3ff:	53                   	push   %rbx
 400:	00 58 44             	add    %bl,0x44(%rax)
 403:	50                   	push   %rax
 404:	5f                   	pop    %rdi
 405:	54                   	push   %rsp
 406:	58                   	pop    %rax
 407:	00 58 44             	add    %bl,0x44(%rax)
 40a:	50                   	push   %rax
 40b:	5f                   	pop    %rdi
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;
 40c:	52                   	push   %rdx
 40d:	45                   	rex.RB
 40e:	44                   	rex.R
 40f:	49 52                	rex.WB push %r10
 411:	45                   	rex.RB
 412:	43 54                	rex.XB push %r12
 414:	00 78 64             	add    %bh,0x64(%rax)
 417:	70 5f                	jo     478 <balancer_ingress+0x478>
 419:	61                   	(bad)
 41a:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
 41e:	6e                   	outsb  %ds:(%rsi),(%dx)
 41f:	00 49 50             	add    %cl,0x50(%rcx)
 422:	50                   	push   %rax
 423:	52                   	push   %rdx
    if (iph->frag_off & PCKT_FRAGMENTED) {
 424:	4f 54                	rex.WRXB push %r12
 426:	4f 5f                	rex.WRXB pop %r15
 428:	49 50                	rex.WB push %r8
 42a:	00 49 50             	add    %cl,0x50(%rcx)
 42d:	50                   	push   %rax
 42e:	52                   	push   %rdx
 42f:	4f 54                	rex.WRXB push %r12
 431:	4f 5f                	rex.WRXB pop %r15
 433:	49                   	rex.WB
 434:	43                   	rex.XB
 435:	4d 50                	rex.WRB push %r8
 437:	00 49 50             	add    %cl,0x50(%rcx)
      return XDP_DROP;
 43a:	50                   	push   %rax
 43b:	52                   	push   %rdx
 43c:	4f 54                	rex.WRXB push %r12
 43e:	4f 5f                	rex.WRXB pop %r15
 440:	49                   	rex.WB
 441:	47                   	rex.RXB
 442:	4d 50                	rex.WRB push %r8
 444:	00 49 50             	add    %cl,0x50(%rcx)
    if (*protocol == IPPROTO_ICMP) {
 447:	50                   	push   %rax
 448:	52                   	push   %rdx
 449:	4f 54                	rex.WRXB push %r12
 44b:	4f 5f                	rex.WRXB pop %r15
 44d:	49 50                	rex.WB push %r8
 44f:	49 50                	rex.WB push %r8
 451:	00 49 50             	add    %cl,0x50(%rcx)
      return FURTHER_PROCESSING;
 454:	50                   	push   %rax
 455:	52                   	push   %rdx
 456:	4f 54                	rex.WRXB push %r12
 458:	4f 5f                	rex.WRXB pop %r15
 45a:	54                   	push   %rsp
 45b:	43 50                	rex.XB push %r8
 45d:	00 49 50             	add    %cl,0x50(%rcx)
      pckt->flow.src = iph->saddr;
 460:	50                   	push   %rax
 461:	52                   	push   %rdx
 462:	4f 54                	rex.WRXB push %r12
 464:	4f 5f                	rex.WRXB pop %r15
 466:	45                   	rex.RB
 467:	47 50                	rex.RXB push %r8
 469:	00 49 50             	add    %cl,0x50(%rcx)
 46c:	50                   	push   %rax
 46d:	52                   	push   %rdx
 46e:	4f 54                	rex.WRXB push %r12
 470:	4f 5f                	rex.WRXB pop %r15
 472:	50                   	push   %rax
      pckt->flow.dst = iph->daddr;
 473:	55                   	push   %rbp
 474:	50                   	push   %rax
 475:	00 49 50             	add    %cl,0x50(%rcx)
 478:	50                   	push   %rax
 479:	52                   	push   %rdx
 47a:	4f 54                	rex.WRXB push %r12
 47c:	4f 5f                	rex.WRXB pop %r15
 47e:	55                   	push   %rbp
 47f:	44 50                	rex.R push %rax
 481:	00 49 50             	add    %cl,0x50(%rcx)
 484:	50                   	push   %rax
 485:	52                   	push   %rdx
 486:	4f 54                	rex.WRXB push %r12
  return FURTHER_PROCESSING;
 488:	4f 5f                	rex.WRXB pop %r15
 48a:	49                   	rex.WB
 48b:	44 50                	rex.R push %rax
 48d:	00 49 50             	add    %cl,0x50(%rcx)
 490:	50                   	push   %rax
}
 491:	52                   	push   %rdx
 492:	4f 54                	rex.WRXB push %r12
 494:	4f 5f                	rex.WRXB pop %r15
 496:	54                   	push   %rsp
  action = parse_l3_headers(
 497:	50                   	push   %rax
 498:	00 49 50             	add    %cl,0x50(%rcx)
 49b:	50                   	push   %rax
 49c:	52                   	push   %rdx
  if (action >= 0) {
 49d:	4f 54                	rex.WRXB push %r12
 49f:	4f 5f                	rex.WRXB pop %r15
 4a1:	44                   	rex.R
 4a2:	43                   	rex.XB
 4a3:	43 50                	rex.XB push %r8
 4a5:	00 49 50             	add    %cl,0x50(%rcx)
    return action;
 4a8:	50                   	push   %rax
 4a9:	52                   	push   %rdx
 4aa:	4f 54                	rex.WRXB push %r12
 4ac:	4f 5f                	rex.WRXB pop %r15
 4ae:	49 50                	rex.WB push %r8
 4b0:	56                   	push   %rsi
 4b1:	36 00 49 50          	ss add %cl,0x50(%rcx)
 4b5:	50                   	push   %rax
 4b6:	52                   	push   %rdx
  action = handle_if_icmp(data, data_end, th_off, &pckt, protocol);
 4b7:	4f 54                	rex.WRXB push %r12
 4b9:	4f 5f                	rex.WRXB pop %r15
 4bb:	52                   	push   %rdx
 4bc:	53                   	push   %rbx
 4bd:	56                   	push   %rsi
 4be:	50                   	push   %rax
 4bf:	00 49 50             	add    %cl,0x50(%rcx)
 4c2:	50                   	push   %rax
 4c3:	52                   	push   %rdx
 4c4:	4f 54                	rex.WRXB push %r12
 4c6:	4f 5f                	rex.WRXB pop %r15
 4c8:	47 52                	rex.RXB push %r10
 4ca:	45 00 49 50          	add    %r9b,0x50(%r9)
 4ce:	50                   	push   %rax
 4cf:	52                   	push   %rdx
 4d0:	4f 54                	rex.WRXB push %r12
 4d2:	4f 5f                	rex.WRXB pop %r15
 4d4:	45 53                	rex.RB push %r11
 4d6:	50                   	push   %rax
 4d7:	00 49 50             	add    %cl,0x50(%rcx)
 4da:	50                   	push   %rax
 4db:	52                   	push   %rdx
 4dc:	4f 54                	rex.WRXB push %r12
 4de:	4f 5f                	rex.WRXB pop %r15
 4e0:	41                   	rex.B
 4e1:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
 4e5:	50                   	push   %rax
 4e6:	52                   	push   %rdx
 4e7:	4f 54                	rex.WRXB push %r12
 4e9:	4f 5f                	rex.WRXB pop %r15
 4eb:	4d 54                	rex.WRB push %r12
 4ed:	50                   	push   %rax
 4ee:	00 49 50             	add    %cl,0x50(%rcx)
 4f1:	50                   	push   %rax
 4f2:	52                   	push   %rdx
 4f3:	4f 54                	rex.WRXB push %r12
 4f5:	4f 5f                	rex.WRXB pop %r15
 4f7:	42                   	rex.X
 4f8:	45                   	rex.RB
 4f9:	45 54                	rex.RB push %r12
  if (protocol == IPPROTO_ICMPV6) {
 4fb:	50                   	push   %rax
 4fc:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
 500:	50                   	push   %rax
 501:	52                   	push   %rdx
 502:	4f 54                	rex.WRXB push %r12
 504:	4f 5f                	rex.WRXB pop %r15
 506:	45                   	rex.RB
 507:	4e                   	rex.WRX
 508:	43                   	rex.XB
 509:	41 50                	push   %r8
    return parse_icmpv6(data, data_end, off, pckt);
 50b:	00 49 50             	add    %cl,0x50(%rcx)
 50e:	50                   	push   %rax
 50f:	52                   	push   %rdx
 510:	4f 54                	rex.WRXB push %r12
 512:	4f 5f                	rex.WRXB pop %r15
 514:	50                   	push   %rax
 515:	49                   	rex.WB
 516:	4d 00 49 50          	rex.WRB add %r9b,0x50(%r9)
 51a:	50                   	push   %rax
 51b:	52                   	push   %rdx
 51c:	4f 54                	rex.WRXB push %r12
 51e:	4f 5f                	rex.WRXB pop %r15
 520:	43                   	rex.XB
 521:	4f                   	rex.WRXB
 522:	4d 50                	rex.WRB push %r8
 524:	00 49 50             	add    %cl,0x50(%rcx)
 527:	50                   	push   %rax
 528:	52                   	push   %rdx
 529:	4f 54                	rex.WRXB push %r12
 52b:	4f 5f                	rex.WRXB pop %r15
 52d:	4c 32 54 50 00       	rex.WR xor 0x0(%rax,%rdx,2),%r10b
 532:	49 50                	rex.WB push %r8
 534:	50                   	push   %rax
 535:	52                   	push   %rdx
 536:	4f 54                	rex.WRXB push %r12
 538:	4f 5f                	rex.WRXB pop %r15
 53a:	53                   	push   %rbx
 53b:	43 54                	rex.XB push %r12
 53d:	50                   	push   %rax
 53e:	00 49 50             	add    %cl,0x50(%rcx)
 541:	50                   	push   %rax
 542:	52                   	push   %rdx
  icmp_hdr = data + off;
 543:	4f 54                	rex.WRXB push %r12
 545:	4f 5f                	rex.WRXB pop %r15
 547:	55                   	push   %rbp
 548:	44 50                	rex.R push %rax
 54a:	4c                   	rex.WR
 54b:	49 54                	rex.WB push %r12
 54d:	45 00 49 50          	add    %r9b,0x50(%r9)
 551:	50                   	push   %rax
 552:	52                   	push   %rdx
 553:	4f 54                	rex.WRXB push %r12
 555:	4f 5f                	rex.WRXB pop %r15
 557:	4d 50                	rex.WRB push %r8
  if (icmp_hdr + 1 > data_end) {
 559:	4c 53                	rex.WR push %rbx
 55b:	00 49 50             	add    %cl,0x50(%rcx)
 55e:	50                   	push   %rax
 55f:	52                   	push   %rdx
 560:	4f 54                	rex.WRXB push %r12
 562:	4f 5f                	rex.WRXB pop %r15
 564:	45 54                	rex.RB push %r12
 566:	48                   	rex.W
 567:	45 52                	rex.RB push %r10
 569:	4e                   	rex.WRX
 56a:	45 54                	rex.RB push %r12
 56c:	00 49 50             	add    %cl,0x50(%rcx)
    return XDP_DROP;
 56f:	50                   	push   %rax
 570:	52                   	push   %rdx
 571:	4f 54                	rex.WRXB push %r12
 573:	4f 5f                	rex.WRXB pop %r15
 575:	41                   	rex.B
 576:	47                   	rex.RXB
 577:	47                   	rex.RXB
 578:	46 52                	rex.RX push %rdx
 57a:	41                   	rex.B
 57b:	47 00 49 50          	rex.RXB add %r9b,0x50(%r9)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 57f:	50                   	push   %rax
 580:	52                   	push   %rdx
 581:	4f 54                	rex.WRXB push %r12
 583:	4f 5f                	rex.WRXB pop %r15
 585:	52                   	push   %rdx
 586:	41 57                	push   %r15
 588:	00 49 50             	add    %cl,0x50(%rcx)
 58b:	50                   	push   %rax
 58c:	52                   	push   %rdx
 58d:	4f 54                	rex.WRXB push %r12
 58f:	4f 5f                	rex.WRXB pop %r15
 591:	53                   	push   %rbx
 592:	4d                   	rex.WRB
    return send_icmp6_reply(data, data_end);
 593:	43 00 49 50          	rex.XB add %cl,0x50(%r9)
 597:	50                   	push   %rax
 598:	52                   	push   %rdx
 599:	4f 54                	rex.WRXB push %r12
 59b:	4f 5f                	rex.WRXB pop %r15
 59d:	4d 50                	rex.WRB push %r8
 59f:	54                   	push   %rsp
 5a0:	43 50                	rex.XB push %r8
 5a2:	00 49 50             	add    %cl,0x50(%rcx)
 5a5:	50                   	push   %rax
 5a6:	52                   	push   %rdx
 5a7:	4f 54                	rex.WRXB push %r12
 5a9:	4f 5f                	rex.WRXB pop %r15
 5ab:	4d                   	rex.WRB
 5ac:	41 58                	pop    %r8
 5ae:	00 63 6f             	add    %ah,0x6f(%rbx)
  __u64 off = 0;
 5b1:	6e                   	outsb  %ds:(%rsi),(%dx)
 5b2:	6e                   	outsb  %ds:(%rsi),(%dx)
 5b3:	5f                   	pop    %rdi
 5b4:	69 64 5f 6c 65 6e 73 	imul   $0x736e65,0x6c(%rdi,%rbx,2),%esp
 5bb:	00 
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 5bc:	64 73 74             	fs jae 633 <balancer_ingress+0x633>
 5bf:	5f                   	pop    %rdi
 5c0:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
 5c3:	6e                   	outsb  %ds:(%rsi),(%dx)
 5c4:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
 5c9:	6e                   	outsb  %ds:(%rsi),(%dx)
 5ca:	5f                   	pop    %rdi
 5cb:	69 64 00 71 75 69 63 	imul   $0x5f636975,0x71(%rax,%rax,1),%esp
 5d2:	5f 
       sizeof(struct icmp6hdr)) > data_end) {
 5d3:	6c                   	insb   (%dx),%es:(%rdi)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 5d4:	6f                   	outsl  %ds:(%rsi),(%dx)
 5d5:	6e                   	outsb  %ds:(%rsi),(%dx)
    return XDP_DROP;
 5d6:	67 5f                	addr32 pop %rdi
 5d8:	68 65 61 64 65       	push   $0x65646165
 5dd:	72 00                	jb     5df <balancer_ingress+0x5df>
 5df:	71 75                	jno    656 <balancer_ingress+0x656>
 5e1:	69 63 5f 73 68 6f 72 	imul   $0x726f6873,0x5f(%rbx),%esp
  off += sizeof(struct ethhdr);
 5e8:	74 5f                	je     649 <balancer_ingress+0x649>
 5ea:	68 65 61 64 65       	push   $0x65646165
 5ef:	72 00                	jb     5f1 <balancer_ingress+0x5f1>
 5f1:	70 72                	jo     665 <balancer_ingress+0x665>
 5f3:	6f                   	outsl  %ds:(%rsi),(%dx)
 5f4:	63 65 73             	movsxd 0x73(%rbp),%esp
  ip6h = data + off;
 5f7:	73 5f                	jae    658 <balancer_ingress+0x658>
 5f9:	70 61                	jo     65c <balancer_ingress+0x65c>
 5fb:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 5fe:	74 00                	je     600 <balancer_ingress+0x600>
 600:	78 64                	js     666 <balancer_ingress+0x666>
 602:	70 00                	jo     604 <balancer_ingress+0x604>
 604:	64 61                	fs (bad)
 606:	74 61                	je     669 <balancer_ingress+0x669>
 608:	5f                   	pop    %rdi
 609:	65 6e                	outsb  %gs:(%rsi),(%dx)
 60b:	64 00 64 61 74       	add    %ah,%fs:0x74(%rcx,%riz,2)
  off += sizeof(struct ipv6hdr);
 610:	61                   	(bad)
 611:	5f                   	pop    %rdi
 612:	6d                   	insl   (%dx),%es:(%rdi)
 613:	65 74 61             	gs je  677 <balancer_ingress+0x677>
 616:	00 64 61 74          	add    %ah,0x74(%rcx,%riz,2)
 61a:	61                   	(bad)
 61b:	5f                   	pop    %rdi
 61c:	68 61 72 64 5f       	push   $0x5f647261
  icmp_hdr = data + off;
 621:	73 74                	jae    697 <balancer_ingress+0x697>
 623:	61                   	(bad)
 624:	72 74                	jb     69a <balancer_ingress+0x69a>
 626:	00 72 78             	add    %dh,0x78(%rdx)
 629:	71 00                	jno    62b <balancer_ingress+0x62b>
 62b:	78 64                	js     691 <balancer_ingress+0x691>
 62d:	70 5f                	jo     68e <balancer_ingress+0x68e>
 62f:	72 78                	jb     6a9 <balancer_ingress+0x6a9>
 631:	71 5f                	jno    692 <balancer_ingress+0x692>
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
 633:	69 6e 66 6f 00 74 78 	imul   $0x7874006f,0x66(%rsi),%ebp
 63a:	71 00                	jno    63c <balancer_ingress+0x63c>
 63c:	78 64                	js     6a2 <balancer_ingress+0x6a2>
  icmp_hdr->icmp6_cksum -= 0x0001;
 63e:	70 5f                	jo     69f <balancer_ingress+0x69f>
 640:	74 78                	je     6ba <balancer_ingress+0x6ba>
 642:	71 5f                	jno    6a3 <balancer_ingress+0x6a3>
 644:	69 6e 66 6f 00 66 72 	imul   $0x7266006f,0x66(%rsi),%ebp
 64b:	61                   	(bad)
 64c:	6d                   	insl   (%dx),%es:(%rdi)
 64d:	65 5f                	gs pop %rdi
  ip6h->hop_limit = DEFAULT_TTL;
 64f:	73 7a                	jae    6cb <balancer_ingress+0x6cb>
 651:	00 78 64             	add    %bh,0x64(%rax)
 654:	70 5f                	jo     6b5 <balancer_ingress+0x6b5>
 656:	6d                   	insl   (%dx),%es:(%rdi)
 657:	64 00 6e 68          	add    %ch,%fs:0x68(%rsi)
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
 65b:	5f                   	pop    %rdi
 65c:	6f                   	outsl  %ds:(%rsi),(%dx)
 65d:	66 66 00 69 73       	data16 data16 add %ch,0x73(%rcx)
 662:	5f                   	pop    %rdi
 663:	69 70 76 36 00 5f 42 	imul   $0x425f0036,0x76(%rax),%esi
 66a:	6f                   	outsl  %ds:(%rsi),(%dx)
 66b:	6f                   	outsl  %ds:(%rsi),(%dx)
 66c:	6c                   	insb   (%dx),%es:(%rdi)
 66d:	00 63 76             	add    %ah,0x76(%rbx)
 670:	61                   	(bad)
 671:	6c                   	insb   (%dx),%es:(%rdi)
 672:	00 70 63             	add    %dh,0x63(%rax)
 675:	6b 74 00 66 6c       	imul   $0x6c,0x66(%rax,%rax,1),%esi
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
 67a:	6f                   	outsl  %ds:(%rsi),(%dx)
 67b:	77 00                	ja     67d <balancer_ingress+0x67d>
 67d:	72 65                	jb     6e4 <balancer_ingress+0x6e4>
 67f:	61                   	(bad)
 680:	6c                   	insb   (%dx),%es:(%rdi)
 681:	5f                   	pop    %rdi
 682:	69 6e 64 65 78 00 74 	imul   $0x74007865,0x64(%rsi),%ebp
 689:	6f                   	outsl  %ds:(%rsi),(%dx)
 68a:	73 00                	jae    68c <balancer_ingress+0x68c>
 68c:	70 61                	jo     6ef <balancer_ingress+0x6ef>
 68e:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 691:	74 5f                	je     6f2 <balancer_ingress+0x6f2>
 693:	64 65 73 63          	fs gs jae 6fa <balancer_ingress+0x6fa>
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
 697:	72 69                	jb     702 <balancer_ingress+0x702>
 699:	70 74                	jo     70f <balancer_ingress+0x70f>
 69b:	69 6f 6e 00 76 69 70 	imul   $0x70697600,0x6e(%rdi),%ebp
 6a2:	5f                   	pop    %rdi
 6a3:	69 6e 66 6f 00 64 61 	imul   $0x6164006f,0x66(%rsi),%ebp
 6aa:	74 61                	je     70d <balancer_ingress+0x70d>
 6ac:	5f                   	pop    %rdi
 6ad:	73 74                	jae    723 <balancer_ingress+0x723>
 6af:	61                   	(bad)
 6b0:	74 73                	je     725 <balancer_ingress+0x725>
  return swap_mac_and_send(data, data_end);
 6b2:	00 70 72             	add    %dh,0x72(%rax)
 6b5:	6f                   	outsl  %ds:(%rsi),(%dx)
 6b6:	74 6f                	je     727 <balancer_ingress+0x727>
 6b8:	63 6f 6c             	movsxd 0x6c(%rdi),%ebp
 6bb:	00 6f 72             	add    %ch,0x72(%rdi)
 6be:	69 67 69 6e 61 6c 5f 	imul   $0x5f6c616e,0x69(%rdi),%esp
 6c5:	73 70                	jae    737 <balancer_ingress+0x737>
 6c7:	6f                   	outsl  %ds:(%rsi),(%dx)
 6c8:	72 74                	jb     73e <balancer_ingress+0x73e>
 6ca:	00 6d 61             	add    %ch,0x61(%rbp)
 6cd:	63 5f 61             	movsxd 0x61(%rdi),%ebx
  eth = data;
 6d0:	64 64 72 5f          	fs fs jb 733 <balancer_ingress+0x733>
 6d4:	70 6f                	jo     745 <balancer_ingress+0x745>
 6d6:	73 00                	jae    6d8 <balancer_ingress+0x6d8>
 6d8:	70 6b                	jo     745 <balancer_ingress+0x745>
 6da:	74 5f                	je     73b <balancer_ingress+0x73b>
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 6dc:	62                   	(bad)
 6dd:	79 74                	jns    753 <balancer_ingress+0x753>
 6df:	65 73 00             	gs jae 6e2 <balancer_ingress+0x6e2>
 6e2:	74 68                	je     74c <balancer_ingress+0x74c>
 6e4:	5f                   	pop    %rdi
 6e5:	6f                   	outsl  %ds:(%rsi),(%dx)
 6e6:	66 66 00 63 70       	data16 data16 add %ah,0x70(%rbx)
 6eb:	75 5f                	jne    74c <balancer_ingress+0x74c>
 6ed:	6e                   	outsb  %ds:(%rsi),(%dx)
 6ee:	75 6d                	jne    75d <balancer_ingress+0x75d>
 6f0:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
 6f4:	5f                   	pop    %rdi
 6f5:	6d                   	insl   (%dx),%es:(%rdi)
 6f6:	61                   	(bad)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 6f7:	70 00                	jo     6f9 <balancer_ingress+0x6f9>
 6f9:	5f                   	pop    %rdi
 6fa:	5f                   	pop    %rdi
 6fb:	65 6c                	gs insb (%dx),%es:(%rdi)
 6fd:	65 6d                	gs insl (%dx),%es:(%rdi)
 6ff:	00 69 64             	add    %ch,0x64(%rcx)
 702:	78 00                	js     704 <balancer_ingress+0x704>
 704:	65 6c                	gs insb (%dx),%es:(%rdi)
 706:	65 6d                	gs insl (%dx),%es:(%rdi)
 708:	5f                   	pop    %rdi
 709:	73 69                	jae    774 <balancer_ingress+0x774>
 70b:	7a 65                	jp     772 <balancer_ingress+0x772>
 70d:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
 711:	5f                   	pop    %rdi
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 712:	73 74                	jae    788 <balancer_ingress+0x788>
 714:	61                   	(bad)
 715:	74 73                	je     78a <balancer_ingress+0x78a>
 717:	5f                   	pop    %rdi
 718:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 71c:	6c                   	insb   (%dx),%es:(%rdi)
 71d:	72 75                	jb     794 <balancer_ingress+0x794>
 71f:	5f                   	pop    %rdi
 720:	73 74                	jae    796 <balancer_ingress+0x796>
 722:	61                   	(bad)
 723:	74 73                	je     798 <balancer_ingress+0x798>
 725:	00 69 73             	add    %ch,0x73(%rcx)
 728:	5f                   	pop    %rdi
 729:	69 63 6d 70 00 71 75 	imul   $0x75710070,0x6d(%rbx),%esp
  return swap_mac_and_send(data, data_end);
 730:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
}
 737:	65 74 73             	gs je  7ad <balancer_ingress+0x7ad>
 73a:	5f                   	pop    %rdi
 73b:	73 74                	jae    7b1 <balancer_ingress+0x7b1>
    return send_icmp6_reply(data, data_end);
 73d:	61                   	(bad)
 73e:	74 73                	je     7b3 <balancer_ingress+0x7b3>
 740:	5f                   	pop    %rdi
 741:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 745:	71 70                	jno    7b7 <balancer_ingress+0x7b7>
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
 747:	72 00                	jb     749 <balancer_ingress+0x749>
 749:	63 69 64             	movsxd 0x64(%rcx),%ebp
 74c:	5f                   	pop    %rdi
 74d:	76 65                	jbe    7b4 <balancer_ingress+0x7b4>
 74f:	72 73                	jb     7c4 <balancer_ingress+0x7c4>
 751:	69 6f 6e 00 69 73 5f 	imul   $0x5f736900,0x6e(%rdi),%ebp
      (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {
 758:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
 75f:	00 71 75             	add    %dh,0x75(%rcx)
 762:	69 63 5f 70 61 72 73 	imul   $0x73726170,0x5f(%rbx),%esp
    return XDP_PASS;
 769:	65 5f                	gs pop %rdi
 76b:	72 65                	jb     7d2 <balancer_ingress+0x7d2>
 76d:	73 75                	jae    7e4 <balancer_ingress+0x7e4>
 76f:	6c                   	insb   (%dx),%es:(%rdi)
 770:	74 00                	je     772 <balancer_ingress+0x772>
 772:	72 65                	jb     7d9 <balancer_ingress+0x7d9>
  if (icmp_hdr->icmp6_type == ICMPV6_PKT_TOOBIG) {
 774:	61                   	(bad)
 775:	6c                   	insb   (%dx),%es:(%rdi)
 776:	5f                   	pop    %rdi
 777:	70 6f                	jo     7e8 <balancer_ingress+0x7e8>
 779:	73 00                	jae    77b <balancer_ingress+0x77b>
 77b:	72 65                	jb     7e2 <balancer_ingress+0x7e2>
 77d:	73 00                	jae    77f <balancer_ingress+0x77f>
 77f:	70 61                	jo     7e2 <balancer_ingress+0x7e2>
 781:	72 73                	jb     7f6 <balancer_ingress+0x7f6>
 783:	65 5f                	gs pop %rdi
 785:	6c                   	insb   (%dx),%es:(%rdi)
 786:	33 5f 68             	xor    0x68(%rdi),%ebx
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
 789:	65 61                	gs (bad)
 78b:	64 65 72 73          	fs gs jb 802 <balancer_ingress+0x802>
 78f:	00 69 70             	add    %ch,0x70(%rcx)
        bpf_map_lookup_elem(&stats, &stats_key);
 792:	68 5f 6c 65 6e       	push   $0x6e656c5f
 797:	00 69 70             	add    %ch,0x70(%rcx)
 79a:	68 00 69 68 6c       	push   $0x6c686900
 79f:	00 74 6f 74          	add    %dh,0x74(%rdi,%rbp,2)
 7a3:	5f                   	pop    %rdi
 7a4:	6c                   	insb   (%dx),%es:(%rdi)
 7a5:	65 6e                	outsb  %gs:(%rsi),(%dx)
 7a7:	00 5f 5f             	add    %bl,0x5f(%rdi)
 7aa:	62 65                	(bad)
 7ac:	31 36                	xor    %esi,(%rsi)
 7ae:	00 66 72             	add    %ah,0x72(%rsi)
 7b1:	61                   	(bad)
 7b2:	67 5f                	addr32 pop %rdi
 7b4:	6f                   	outsl  %ds:(%rsi),(%dx)
 7b5:	66 66 00 74 74 6c    	data16 data16 add %dh,0x6c(%rsp,%rsi,2)
 7bb:	00 63 68             	add    %ah,0x68(%rbx)
 7be:	65 63 6b 00          	movsxd %gs:0x0(%rbx),%ebp
 7c2:	5f                   	pop    %rdi
 7c3:	5f                   	pop    %rdi
 7c4:	73 75                	jae    83b <balancer_ingress+0x83b>
 7c6:	6d                   	insl   (%dx),%es:(%rdi)
 7c7:	31 36                	xor    %esi,(%rsi)
 7c9:	00 73 61             	add    %dh,0x61(%rbx)
 7cc:	64 64 72 00          	fs fs jb 7d0 <balancer_ingress+0x7d0>
 7d0:	64 61                	fs (bad)
 7d2:	64 64 72 00          	fs fs jb 7d6 <balancer_ingress+0x7d6>
 7d6:	61                   	(bad)
 7d7:	64 64 72 73          	fs fs jb 84e <balancer_ingress+0x84e>
 7db:	00 69 70             	add    %ch,0x70(%rcx)
 7de:	68 64 72 00 69       	push   $0x69007264
 7e3:	70 36                	jo     81b <balancer_ingress+0x81b>
 7e5:	68 00 70 72 69       	push   $0x69727000
 7ea:	6f                   	outsl  %ds:(%rsi),(%dx)
 7eb:	72 69                	jb     856 <balancer_ingress+0x856>
 7ed:	74 79                	je     868 <balancer_ingress+0x868>
 7ef:	00 66 6c             	add    %ah,0x6c(%rsi)
 7f2:	6f                   	outsl  %ds:(%rsi),(%dx)
 7f3:	77 5f                	ja     854 <balancer_ingress+0x854>
 7f5:	6c                   	insb   (%dx),%es:(%rdi)
 7f6:	62                   	(bad)
 7f7:	6c                   	insb   (%dx),%es:(%rdi)
 7f8:	00 70 61             	add    %dh,0x61(%rax)
 7fb:	79 6c                	jns    869 <balancer_ingress+0x869>
 7fd:	6f                   	outsl  %ds:(%rsi),(%dx)
 7fe:	61                   	(bad)
 7ff:	64 5f                	fs pop %rdi
 801:	6c                   	insb   (%dx),%es:(%rdi)
 802:	65 6e                	outsb  %gs:(%rsi),(%dx)
 804:	00 6e 65             	add    %ch,0x65(%rsi)
    struct lb_stats* icmp_ptb_v6_stats =
 807:	78 74                	js     87d <balancer_ingress+0x87d>
 809:	68 64 72 00 68       	push   $0x68007264
    if (!icmp_ptb_v6_stats) {
 80e:	6f                   	outsl  %ds:(%rsi),(%dx)
 80f:	70 5f                	jo     870 <balancer_ingress+0x870>
 811:	6c                   	insb   (%dx),%es:(%rdi)
 812:	69 6d 69 74 00 69 6e 	imul   $0x6e690074,0x69(%rbp),%ebp
      return XDP_DROP;
 819:	36 5f                	ss pop %rdi
 81b:	75 00                	jne    81d <balancer_ingress+0x81d>
 81d:	75 36                	jne    855 <balancer_ingress+0x855>
 81f:	5f                   	pop    %rdi
 820:	61                   	(bad)
 821:	64 64 72 38          	fs fs jb 85d <balancer_ingress+0x85d>
    icmp_ptb_v6_stats->v1 += 1;
 825:	00 75 36             	add    %dh,0x36(%rbp)
 828:	5f                   	pop    %rdi
 829:	61                   	(bad)
 82a:	64 64 72 31          	fs fs jb 85f <balancer_ingress+0x85f>
 82e:	36 00 75 36          	ss add %dh,0x36(%rbp)
 832:	5f                   	pop    %rdi
 833:	61                   	(bad)
 834:	64 64 72 33          	fs fs jb 86b <balancer_ingress+0x86b>
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 838:	32 00                	xor    (%rax),%al
 83a:	69 6e 36 5f 61 64 64 	imul   $0x6464615f,0x36(%rsi),%ebp
 841:	72 00                	jb     843 <balancer_ingress+0x843>
 843:	69 70 76 36 68 64 72 	imul   $0x72646836,0x76(%rax),%esi
 84a:	00 68 61             	add    %ch,0x61(%rax)
 84d:	6e                   	outsb  %ds:(%rsi),(%dx)
 84e:	64 6c                	fs insb (%dx),%es:(%rdi)
 850:	65 5f                	gs pop %rdi
 852:	69 66 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rsi),%esp
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 859:	00 70 61             	add    %dh,0x61(%rax)
 85c:	72 73                	jb     8d1 <balancer_ingress+0x8d1>
 85e:	65 5f                	gs pop %rdi
      icmp_ptb_v6_stats->v2 += 1;
 860:	69 63 6d 70 76 36 00 	imul   $0x367670,0x6d(%rbx),%esp
 867:	69 63 6d 70 5f 68 64 	imul   $0x64685f70,0x6d(%rbx),%esp
 86e:	72 00                	jb     870 <balancer_ingress+0x870>
 870:	69 63 6d 70 36 5f 74 	imul   $0x745f3670,0x6d(%rbx),%esp
  off += sizeof(struct icmp6hdr);
 877:	79 70                	jns    8e9 <balancer_ingress+0x8e9>
 879:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
 87d:	6d                   	insl   (%dx),%es:(%rdi)
 87e:	70 36                	jo     8b6 <balancer_ingress+0x8b6>
 880:	5f                   	pop    %rdi
 881:	63 6f 64             	movsxd 0x64(%rdi),%ebp
 884:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
  ip6h = data + off;
 888:	6d                   	insl   (%dx),%es:(%rdi)
 889:	70 36                	jo     8c1 <balancer_ingress+0x8c1>
 88b:	5f                   	pop    %rdi
 88c:	63 6b 73             	movsxd 0x73(%rbx),%ebp
 88f:	75 6d                	jne    8fe <balancer_ingress+0x8fe>
 891:	00 69 63             	add    %ch,0x63(%rcx)
 894:	6d                   	insl   (%dx),%es:(%rdi)
 895:	70 36                	jo     8cd <balancer_ingress+0x8cd>
 897:	5f                   	pop    %rdi
 898:	64 61                	fs (bad)
 89a:	74 61                	je     8fd <balancer_ingress+0x8fd>
  if (ip6h + 1 > data_end) {
 89c:	75 6e                	jne    90c <balancer_ingress+0x90c>
 89e:	00 75 6e             	add    %dh,0x6e(%rbp)
 8a1:	5f                   	pop    %rdi
 8a2:	64 61                	fs (bad)
 8a4:	74 61                	je     907 <balancer_ingress+0x907>
 8a6:	33 32                	xor    (%rdx),%esi
 8a8:	00 75 6e             	add    %dh,0x6e(%rbp)
 8ab:	5f                   	pop    %rdi
 8ac:	64 61                	fs (bad)
 8ae:	74 61                	je     911 <balancer_ingress+0x911>
 8b0:	31 36                	xor    %esi,(%rsi)
 8b2:	00 75 6e             	add    %dh,0x6e(%rbp)
    return XDP_DROP;
 8b5:	5f                   	pop    %rdi
 8b6:	64 61                	fs (bad)
 8b8:	74 61                	je     91b <balancer_ingress+0x91b>
 8ba:	38 00                	cmp    %al,(%rax)
 8bc:	75 5f                	jne    91d <balancer_ingress+0x91d>
 8be:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
  pckt->flow.proto = ip6h->nexthdr;
 8c2:	00 69 64             	add    %ch,0x64(%rcx)
 8c5:	65 6e                	outsb  %gs:(%rsi),(%dx)
 8c7:	74 69                	je     932 <balancer_ingress+0x932>
 8c9:	66 69 65 72 00 73    	imul   $0x7300,0x72(%rbp),%sp
 8cf:	65 71 75             	gs jno 947 <balancer_ingress+0x947>
 8d2:	65 6e                	outsb  %gs:(%rsi),(%dx)
  pckt->flags |= F_ICMP;
 8d4:	63 65 00             	movsxd 0x0(%rbp),%esp
 8d7:	69 63 6d 70 76 36 5f 	imul   $0x5f367670,0x6d(%rbx),%esp
 8de:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
 8e2:	00 75 5f             	add    %dh,0x5f(%rbp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 8e5:	6e                   	outsb  %ds:(%rsi),(%dx)
 8e6:	64 5f                	fs pop %rdi
 8e8:	61                   	(bad)
 8e9:	64 76 74             	fs jbe 960 <balancer_ingress+0x960>
 8ec:	00 72 65             	add    %dh,0x65(%rdx)
 8ef:	73 65                	jae    956 <balancer_ingress+0x956>
 8f1:	72 76                	jb     969 <balancer_ingress+0x969>
 8f3:	65 64 00 6f 76       	gs add %ch,%fs:0x76(%rdi)
 8f8:	65 72 72             	gs jb  96d <balancer_ingress+0x96d>
 8fb:	69 64 65 00 73 6f 6c 	imul   $0x696c6f73,0x0(%rbp,%riz,2),%esp
 902:	69 
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 903:	63 69 74             	movsxd 0x74(%rcx),%ebp
 906:	65 64 00 72 6f       	gs add %dh,%fs:0x6f(%rdx)
 90b:	75 74                	jne    981 <balancer_ingress+0x981>
 90d:	65 72 00             	gs jb  910 <balancer_ingress+0x910>
 910:	72 65                	jb     977 <balancer_ingress+0x977>
 912:	73 65                	jae    979 <balancer_ingress+0x979>
 914:	72 76                	jb     98c <balancer_ingress+0x98c>
 916:	65 64 32 00          	gs xor %fs:(%rax),%al
 91a:	69 63 6d 70 76 36 5f 	imul   $0x5f367670,0x6d(%rbx),%esp
  return FURTHER_PROCESSING;
 921:	6e                   	outsb  %ds:(%rsi),(%dx)
 922:	64 5f                	fs pop %rdi
 924:	61                   	(bad)
 925:	64 76 74             	fs jbe 99c <balancer_ingress+0x99c>
 928:	00 75 5f             	add    %dh,0x5f(%rbp)
}
 92b:	6e                   	outsb  %ds:(%rsi),(%dx)
 92c:	64 5f                	fs pop %rdi
 92e:	72 61                	jb     991 <balancer_ingress+0x991>
    return parse_icmpv6(data, data_end, off, pckt);
 930:	00 72 6f             	add    %dh,0x6f(%rdx)
 933:	75 74                	jne    9a9 <balancer_ingress+0x9a9>
 935:	65 72 5f             	gs jb  997 <balancer_ingress+0x997>
 938:	70 72                	jo     9ac <balancer_ingress+0x9ac>
  } else if (protocol == IPPROTO_ICMP) {
 93a:	65 66 00 68 6f       	data16 add %ch,%gs:0x6f(%rax)
 93f:	6d                   	insl   (%dx),%es:(%rdi)
 940:	65 5f                	gs pop %rdi
 942:	61                   	(bad)
 943:	67 65 6e             	outsb  %gs:(%esi),(%dx)
 946:	74 00                	je     948 <balancer_ingress+0x948>
 948:	6f                   	outsl  %ds:(%rsi),(%dx)
 949:	74 68                	je     9b3 <balancer_ingress+0x9b3>
    return parse_icmp(data, data_end, off, pckt);
 94b:	65 72 00             	gs jb  94e <balancer_ingress+0x94e>
 94e:	6d                   	insl   (%dx),%es:(%rdi)
 94f:	61                   	(bad)
 950:	6e                   	outsb  %ds:(%rsi),(%dx)
 951:	61                   	(bad)
 952:	67 65 64 00 72 74    	gs add %dh,%fs:0x74(%edx)
 958:	5f                   	pop    %rdi
 959:	6c                   	insb   (%dx),%es:(%rdi)
 95a:	69 66 65 74 69 6d 65 	imul   $0x656d6974,0x65(%rsi),%esp
 961:	00 69 63             	add    %ch,0x63(%rcx)
 964:	6d                   	insl   (%dx),%es:(%rdi)
 965:	70 76                	jo     9dd <balancer_ingress+0x9dd>
 967:	36 5f                	ss pop %rdi
 969:	6e                   	outsb  %ds:(%rsi),(%dx)
 96a:	64 5f                	fs pop %rdi
 96c:	72 61                	jb     9cf <balancer_ingress+0x9cf>
 96e:	00 69 63             	add    %ch,0x63(%rcx)
 971:	6d                   	insl   (%dx),%es:(%rdi)
 972:	70 36                	jo     9aa <balancer_ingress+0x9aa>
 974:	68 64 72 00 69       	push   $0x69007264
 979:	63 6d 70             	movsxd 0x70(%rbp),%ebp
 97c:	5f                   	pop    %rdi
 97d:	70 74                	jo     9f3 <balancer_ingress+0x9f3>
 97f:	62                   	(bad)
 980:	5f                   	pop    %rdi
 981:	76 36                	jbe    9b9 <balancer_ingress+0x9b9>
  icmp_hdr = data + off;
 983:	5f                   	pop    %rdi
 984:	73 74                	jae    9fa <balancer_ingress+0x9fa>
 986:	61                   	(bad)
 987:	74 73                	je     9fc <balancer_ingress+0x9fc>
 989:	00 6d 74             	add    %ch,0x74(%rbp)
 98c:	75 00                	jne    98e <balancer_ingress+0x98e>
 98e:	73 65                	jae    9f5 <balancer_ingress+0x9f5>
 990:	6e                   	outsb  %ds:(%rsi),(%dx)
 991:	64 5f                	fs pop %rdi
 993:	69 63 6d 70 36 5f 72 	imul   $0x725f3670,0x6d(%rbx),%esp
  if (icmp_hdr + 1 > data_end) {
 99a:	65 70 6c             	gs jo  a09 <balancer_ingress+0xa09>
 99d:	79 00                	jns    99f <balancer_ingress+0x99f>
 99f:	74 6d                	je     a0e <balancer_ingress+0xa0e>
 9a1:	70 5f                	jo     a02 <balancer_ingress+0xa02>
 9a3:	61                   	(bad)
 9a4:	64 64 72 00          	fs fs jb 9a8 <balancer_ingress+0x9a8>
 9a8:	73 77                	jae    a21 <balancer_ingress+0xa21>
 9aa:	61                   	(bad)
 9ab:	70 5f                	jo     a0c <balancer_ingress+0xa0c>
 9ad:	6d                   	insl   (%dx),%es:(%rdi)
    return XDP_DROP;
 9ae:	61                   	(bad)
 9af:	63 5f 61             	movsxd 0x61(%rdi),%ebx
 9b2:	6e                   	outsb  %ds:(%rsi),(%dx)
 9b3:	64 5f                	fs pop %rdi
 9b5:	73 65                	jae    a1c <balancer_ingress+0xa1c>
 9b7:	6e                   	outsb  %ds:(%rsi),(%dx)
 9b8:	64 00 68 5f          	add    %ch,%fs:0x5f(%rax)
 9bc:	64 65 73 74          	fs gs jae a34 <balancer_ingress+0xa34>
  if (icmp_hdr->type == ICMP_ECHO) {
 9c0:	00 68 5f             	add    %ch,0x5f(%rax)
 9c3:	73 6f                	jae    a34 <balancer_ingress+0xa34>
 9c5:	75 72                	jne    a39 <balancer_ingress+0xa39>
 9c7:	63 65 00             	movsxd 0x0(%rbp),%esp
 9ca:	65 74 68             	gs je  a35 <balancer_ingress+0xa35>
 9cd:	68 64 72 00 74       	push   $0x74007264
    return send_icmp_reply(data, data_end);
 9d2:	6d                   	insl   (%dx),%es:(%rdi)
 9d3:	70 5f                	jo     a34 <balancer_ingress+0xa34>
 9d5:	6d                   	insl   (%dx),%es:(%rdi)
 9d6:	61                   	(bad)
 9d7:	63 00                	movsxd (%rax),%eax
 9d9:	70 61                	jo     a3c <balancer_ingress+0xa3c>
 9db:	72 73                	jb     a50 <balancer_ingress+0xa50>
 9dd:	65 5f                	gs pop %rdi
 9df:	69 63 6d 70 00 63 68 	imul   $0x68630070,0x6d(%rbx),%esp
 9e6:	65 63 6b 73          	movsxd %gs:0x73(%rbx),%ebp
 9ea:	75 6d                	jne    a59 <balancer_ingress+0xa59>
  __u32 tmp_addr = 0;
 9ec:	00 67 61             	add    %ah,0x61(%rdi)
 9ef:	74 65                	je     a56 <balancer_ingress+0xa56>
 9f1:	77 61                	ja     a54 <balancer_ingress+0xa54>
 9f3:	79 00                	jns    9f5 <balancer_ingress+0x9f5>
 9f5:	66 72 61             	data16 jb a59 <balancer_ingress+0xa59>
  __u64 csum = 0;
 9f8:	67 00 5f 5f          	add    %bl,0x5f(%edi)
 9fc:	75 6e                	jne    a6c <balancer_ingress+0xa6c>
 9fe:	75 73                	jne    a73 <balancer_ingress+0xa73>
 a00:	65 64 00 69 63       	gs add %ch,%fs:0x63(%rcx)
  __u64 off = 0;
 a05:	6d                   	insl   (%dx),%es:(%rdi)
 a06:	70 68                	jo     a70 <balancer_ingress+0xa70>
 a08:	64 72 00             	fs jb  a0b <balancer_ingress+0xa0b>
 a0b:	69 63 6d 70 5f 70 74 	imul   $0x74705f70,0x6d(%rbx),%esp
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 a12:	62                   	(bad)
 a13:	5f                   	pop    %rdi
 a14:	76 34                	jbe    a4a <balancer_ingress+0xa4a>
 a16:	5f                   	pop    %rdi
 a17:	73 74                	jae    a8d <balancer_ingress+0xa8d>
 a19:	61                   	(bad)
 a1a:	74 73                	je     a8f <balancer_ingress+0xa8f>
 a1c:	00 73 65             	add    %dh,0x65(%rbx)
       sizeof(struct icmphdr)) > data_end) {
 a1f:	6e                   	outsb  %ds:(%rsi),(%dx)
 a20:	64 5f                	fs pop %rdi
 a22:	69 63 6d 70 5f 72 65 	imul   $0x65725f70,0x6d(%rbx),%esp
    return XDP_DROP;
 a29:	70 6c                	jo     a97 <balancer_ingress+0xa97>
 a2b:	79 00                	jns    a2d <balancer_ingress+0xa2d>
 a2d:	63 73 75             	movsxd 0x75(%rbx),%esi
 a30:	6d                   	insl   (%dx),%es:(%rdi)
 a31:	00 69 70             	add    %ch,0x70(%rcx)
 a34:	76 34                	jbe    a6a <balancer_ingress+0xa6a>
 a36:	5f                   	pop    %rdi
  off += sizeof(struct ethhdr);
 a37:	63 73 75             	movsxd 0x75(%rbx),%esi
 a3a:	6d                   	insl   (%dx),%es:(%rdi)
 a3b:	5f                   	pop    %rdi
 a3c:	69 6e 6c 69 6e 65 00 	imul   $0x656e69,0x6c(%rsi),%ebp
 a43:	6e                   	outsb  %ds:(%rsi),(%dx)
 a44:	65 78 74             	gs js  abb <balancer_ingress+0xabb>
 a47:	5f                   	pop    %rdi
 a48:	69 70 68 5f 75 31 36 	imul   $0x3631755f,0x68(%rax),%esi
  iph = data + off;
 a4f:	00 69 00             	add    %ch,0x0(%rcx)
 a52:	63 73 75             	movsxd 0x75(%rbx),%esi
 a55:	6d                   	insl   (%dx),%es:(%rdi)
 a56:	5f                   	pop    %rdi
 a57:	66 6f                	outsw  %ds:(%rsi),(%dx)
 a59:	6c                   	insb   (%dx),%es:(%rdi)
 a5a:	64 5f                	fs pop %rdi
 a5c:	68 65 6c 70 65       	push   $0x65706c65
  off += sizeof(struct iphdr);
 a61:	72 00                	jb     a63 <balancer_ingress+0xa63>
 a63:	70 61                	jo     ac6 <balancer_ingress+0xac6>
 a65:	72 73                	jb     ada <balancer_ingress+0xada>
 a67:	65 5f                	gs pop %rdi
 a69:	74 63                	je     ace <balancer_ingress+0xace>
 a6b:	70 00                	jo     a6d <balancer_ingress+0xa6d>
 a6d:	61                   	(bad)
 a6e:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
  icmp_hdr = data + off;
 a71:	73 65                	jae    ad8 <balancer_ingress+0xad8>
 a73:	71 00                	jno    a75 <balancer_ingress+0xa75>
 a75:	61                   	(bad)
 a76:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
 a7a:	73 31                	jae    aad <balancer_ingress+0xaad>
 a7c:	00 64 6f 66          	add    %ah,0x66(%rdi,%rbp,2)
 a80:	66 00 66 69          	data16 add %ah,0x69(%rsi)
 a84:	6e                   	outsb  %ds:(%rsi),(%dx)
  icmp_hdr->type = ICMP_ECHOREPLY;
 a85:	00 72 73             	add    %dh,0x73(%rdx)
 a88:	74 00                	je     a8a <balancer_ingress+0xa8a>
 a8a:	70 73                	jo     aff <balancer_ingress+0xaff>
 a8c:	68 00 61 63 6b       	push   $0x6b636100
  icmp_hdr->checksum += 0x0008;
 a91:	00 75 72             	add    %dh,0x72(%rbp)
 a94:	67 00 65 63          	add    %ah,0x63(%ebp)
 a98:	65 00 63 77          	add    %ah,%gs:0x77(%rbx)
 a9c:	72 00                	jb     a9e <balancer_ingress+0xa9e>
 a9e:	77 69                	ja     b09 <balancer_ingress+0xb09>
 aa0:	6e                   	outsb  %ds:(%rsi),(%dx)
  iph->ttl = DEFAULT_TTL;
 aa1:	64 6f                	outsl  %fs:(%rsi),(%dx)
 aa3:	77 00                	ja     aa5 <balancer_ingress+0xaa5>
 aa5:	75 72                	jne    b19 <balancer_ingress+0xb19>
 aa7:	67 5f                	addr32 pop %rdi
 aa9:	70 74                	jo     b1f <balancer_ingress+0xb1f>
 aab:	72 00                	jb     aad <balancer_ingress+0xaad>
  tmp_addr = iph->daddr;
 aad:	74 63                	je     b12 <balancer_ingress+0xb12>
 aaf:	70 68                	jo     b19 <balancer_ingress+0xb19>
 ab1:	64 72 00             	fs jb  ab4 <balancer_ingress+0xab4>
 ab4:	63 61 6c             	movsxd 0x6c(%rcx),%esp
 ab7:	63 5f 6f             	movsxd 0x6f(%rdi),%ebx
 aba:	66 66 73 65          	data16 data16 jae b23 <balancer_ingress+0xb23>
  iph->daddr = iph->saddr;
 abe:	74 00                	je     ac0 <balancer_ingress+0xac0>
 ac0:	70 61                	jo     b23 <balancer_ingress+0xb23>
 ac2:	72 73                	jb     b37 <balancer_ingress+0xb37>
 ac4:	65 5f                	gs pop %rdi
 ac6:	75 64                	jne    b2c <balancer_ingress+0xb2c>
 ac8:	70 00                	jo     aca <balancer_ingress+0xaca>
 aca:	75 64                	jne    b30 <balancer_ingress+0xb30>
 acc:	70 68                	jo     b36 <balancer_ingress+0xb36>
 ace:	64 72 00             	fs jb  ad1 <balancer_ingress+0xad1>
  iph->saddr = tmp_addr;
 ad1:	69 67 6e 6f 72 61 62 	imul   $0x6261726f,0x6e(%rdi),%esp
 ad8:	6c                   	insb   (%dx),%es:(%rdi)
 ad9:	65 5f                	gs pop %rdi
 adb:	71 75                	jno    b52 <balancer_ingress+0xb52>
 add:	69 63 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rbx),%esp
  iph->check = 0;
 ae4:	5f                   	pop    %rdi
 ae5:	63 6f 64             	movsxd 0x64(%rdi),%ebp
 ae8:	65 00 70 61          	add    %dh,%gs:0x61(%rax)
 aec:	72 73                	jb     b61 <balancer_ingress+0xb61>
  ipv4_csum_inline(iph, &csum);
 aee:	65 5f                	gs pop %rdi
 af0:	71 75                	jno    b67 <balancer_ingress+0xb67>
 af2:	69 63 00 71 75 69 63 	imul   $0x63697571,0x0(%rbx),%esp
 af9:	5f                   	pop    %rdi
 afa:	64 61                	fs (bad)
 afc:	74 61                	je     b5f <balancer_ingress+0xb5f>
 afe:	00 70 6b             	add    %dh,0x6b(%rax)
 b01:	74 5f                	je     b62 <balancer_ingress+0xb62>
 b03:	74 79                	je     b7e <balancer_ingress+0xb7e>
 b05:	70 65                	jo     b6c <balancer_ingress+0xb6c>
 b07:	00 63 6f             	add    %ah,0x6f(%rbx)
  __u16* next_iph_u16 = (__u16*)iph;
 b0a:	6e                   	outsb  %ds:(%rsi),(%dx)
 b0b:	6e                   	outsb  %ds:(%rsi),(%dx)
 b0c:	49                   	rex.WB
 b0d:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
 b11:	6e                   	outsb  %ds:(%rsi),(%dx)
 b12:	6e                   	outsb  %ds:(%rsi),(%dx)
 b13:	49                   	rex.WB
 b14:	64 56                	fs push %rsi
 b16:	65 72 73             	gs jb  b8c <balancer_ingress+0xb8c>
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
 b19:	69 6f 6e 00 69 6e 63 	imul   $0x636e6900,0x6e(%rdi),%ebp
 b20:	72 65                	jb     b87 <balancer_ingress+0xb87>
 b22:	6d                   	insl   (%dx),%es:(%rdi)
 b23:	65 6e                	outsb  %gs:(%rsi),(%dx)
 b25:	74 5f                	je     b86 <balancer_ingress+0xb86>
 b27:	71 75                	jno    b9e <balancer_ingress+0xb9e>
 b29:	69 63 5f 63 69 64 5f 	imul   $0x5f646963,0x5f(%rbx),%esp
    *csum += *next_iph_u16++;
 b30:	76 65                	jbe    b97 <balancer_ingress+0xb97>
 b32:	72 73                	jb     ba7 <balancer_ingress+0xba7>
 b34:	69 6f 6e 5f 73 74 61 	imul   $0x6174735f,0x6e(%rdi),%ebp
 b3b:	74 73                	je     bb0 <balancer_ingress+0xbb0>
 b3d:	00 63 68             	add    %ah,0x68(%rbx)
 b40:	65 63 6b 5f          	movsxd %gs:0x5f(%rbx),%ebp
 b44:	61                   	(bad)
 b45:	6e                   	outsb  %ds:(%rsi),(%dx)
 b46:	64 5f                	fs pop %rdi
 b48:	75 70                	jne    bba <balancer_ingress+0xbba>
 b4a:	64 61                	fs (bad)
 b4c:	74 65                	je     bb3 <balancer_ingress+0xbb3>
 b4e:	5f                   	pop    %rdi
 b4f:	72 65                	jb     bb6 <balancer_ingress+0xbb6>
 b51:	61                   	(bad)
 b52:	6c                   	insb   (%dx),%es:(%rdi)
 b53:	5f                   	pop    %rdi
 b54:	69 6e 64 65 78 5f 69 	imul   $0x695f7865,0x64(%rsi),%ebp
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
 b5b:	6e                   	outsb  %ds:(%rsi),(%dx)
 b5c:	5f                   	pop    %rdi
 b5d:	6c                   	insb   (%dx),%es:(%rdi)
 b5e:	72 75                	jb     bd5 <balancer_ingress+0xbd5>
 b60:	00 63 75             	add    %ah,0x75(%rbx)
 b63:	72 5f                	jb     bc4 <balancer_ingress+0xbc4>
 b65:	74 69                	je     bd0 <balancer_ingress+0xbd0>
  *csum = csum_fold_helper(*csum);
 b67:	6d                   	insl   (%dx),%es:(%rdi)
 b68:	65 00 6e 65          	add    %ch,%gs:0x65(%rsi)
 b6c:	77 5f                	ja     bcd <balancer_ingress+0xbcd>
 b6e:	64 73 74             	fs jae be5 <balancer_ingress+0xbe5>
 b71:	5f                   	pop    %rdi
 b72:	6c                   	insb   (%dx),%es:(%rdi)
 b73:	72 75                	jb     bea <balancer_ingress+0xbea>
 b75:	00 69 73             	add    %ch,0x73(%rcx)
  for (i = 0; i < 4; i++) {
 b78:	5f                   	pop    %rdi
 b79:	75 6e                	jne    be9 <balancer_ingress+0xbe9>
 b7b:	64 65 72 5f          	fs gs jb bde <balancer_ingress+0xbde>
 b7f:	66 6c                	data16 insb (%dx),%es:(%rdi)
 b81:	6f                   	outsl  %ds:(%rsi),(%dx)
 b82:	6f                   	outsl  %ds:(%rsi),(%dx)
 b83:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
 b87:	6e                   	outsb  %ds:(%rsi),(%dx)
 b88:	6e                   	outsb  %ds:(%rsi),(%dx)
 b89:	5f                   	pop    %rdi
    if (csum >> 16)
 b8a:	72 61                	jb     bed <balancer_ingress+0xbed>
 b8c:	74 65                	je     bf3 <balancer_ingress+0xbf3>
 b8e:	5f                   	pop    %rdi
 b8f:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 b93:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
 b96:	6e                   	outsb  %ds:(%rsi),(%dx)
 b97:	5f                   	pop    %rdi
 b98:	72 61                	jb     bfb <balancer_ingress+0xbfb>
 b9a:	74 65                	je     c01 <balancer_ingress+0xc01>
      csum = (csum & 0xffff) + (csum >> 16);
 b9c:	5f                   	pop    %rdi
 b9d:	73 74                	jae    c13 <balancer_ingress+0xc13>
 b9f:	61                   	(bad)
 ba0:	74 73                	je     c15 <balancer_ingress+0xc15>
 ba2:	00 69 6e             	add    %ch,0x6e(%rcx)
 ba5:	63 72 5f             	movsxd 0x5f(%rdx),%esi
 ba8:	73 65                	jae    c0f <balancer_ingress+0xc0f>
 baa:	72 76                	jb     c22 <balancer_ingress+0xc22>
 bac:	65 72 5f             	gs jb  c0e <balancer_ingress+0xc0e>
 baf:	69 64 5f 72 6f 75 74 	imul   $0x6974756f,0x72(%rdi,%rbx,2),%esp
 bb6:	69 
 bb7:	6e                   	outsb  %ds:(%rsi),(%dx)
 bb8:	67 5f                	addr32 pop %rdi
 bba:	73 74                	jae    c30 <balancer_ingress+0xc30>
 bbc:	61                   	(bad)
  for (i = 0; i < 4; i++) {
 bbd:	74 73                	je     c32 <balancer_ingress+0xc32>
 bbf:	00 6e 65             	add    %ch,0x65(%rsi)
 bc2:	77 43                	ja     c07 <balancer_ingress+0xc07>
 bc4:	6f                   	outsl  %ds:(%rsi),(%dx)
 bc5:	6e                   	outsb  %ds:(%rsi),(%dx)
 bc6:	6e                   	outsb  %ds:(%rsi),(%dx)
 bc7:	00 6d 69             	add    %ch,0x69(%rbp)
 bca:	73 4d                	jae    c19 <balancer_ingress+0xc19>
 bcc:	61                   	(bad)
 bcd:	74 63                	je     c32 <balancer_ingress+0xc32>
  return ~csum;
 bcf:	68 49 6e 4c 52       	push   $0x524c6e49
 bd4:	55                   	push   %rbp
 bd5:	00 70 65             	add    %dh,0x65(%rax)
 bd8:	72 5f                	jb     c39 <balancer_ingress+0xc39>
  *csum = csum_fold_helper(*csum);
 bda:	76 69                	jbe    c45 <balancer_ingress+0xc45>
 bdc:	70 5f                	jo     c3d <balancer_ingress+0xc3d>
 bde:	73 74                	jae    c54 <balancer_ingress+0xc54>
 be0:	61                   	(bad)
 be1:	74 73                	je     c56 <balancer_ingress+0xc56>
 be3:	00 63 6f             	add    %ah,0x6f(%rbx)
 be6:	6e                   	outsb  %ds:(%rsi),(%dx)
 be7:	6e                   	outsb  %ds:(%rsi),(%dx)
  iph->check = csum;
 be8:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
 bed:	6e                   	outsb  %ds:(%rsi),(%dx)
 bee:	5f                   	pop    %rdi
 bef:	74 61                	je     c52 <balancer_ingress+0xc52>
 bf1:	62                   	(bad)
 bf2:	6c                   	insb   (%dx),%es:(%rdi)
 bf3:	65 5f                	gs pop %rdi
 bf5:	6c                   	insb   (%dx),%es:(%rdi)
 bf6:	6f                   	outsl  %ds:(%rsi),(%dx)
 bf7:	6f                   	outsl  %ds:(%rsi),(%dx)
 bf8:	6b 75 70 00          	imul   $0x0,0x70(%rbp),%esi
 bfc:	69 73 47 6c 6f 62 61 	imul   $0x61626f6c,0x47(%rbx),%esi
  return swap_mac_and_send(data, data_end);
 c03:	6c                   	insb   (%dx),%es:(%rdi)
 c04:	4c 72 75             	rex.WR jb c7c <balancer_ingress+0xc7c>
 c07:	00 63 68             	add    %ah,0x68(%rbx)
 c0a:	65 63 6b 5f          	movsxd %gs:0x5f(%rbx),%ebp
 c0e:	75 64                	jne    c74 <balancer_ingress+0xc74>
 c10:	70 5f                	jo     c71 <balancer_ingress+0xc71>
 c12:	66 6c                	data16 insb (%dx),%es:(%rdi)
 c14:	6f                   	outsl  %ds:(%rsi),(%dx)
 c15:	77 5f                	ja     c76 <balancer_ingress+0xc76>
 c17:	6d                   	insl   (%dx),%es:(%rdi)
 c18:	69 67 72 61 74 69 6f 	imul   $0x6f697461,0x72(%rdi),%esp
  eth = data;
 c1f:	6e                   	outsb  %ds:(%rsi),(%dx)
 c20:	00 64 6f 77          	add    %ah,0x77(%rdi,%rbp,2)
 c24:	6e                   	outsb  %ds:(%rsi),(%dx)
 c25:	5f                   	pop    %rdi
 c26:	72 65                	jb     c8d <balancer_ingress+0xc8d>
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 c28:	61                   	(bad)
 c29:	6c                   	insb   (%dx),%es:(%rdi)
 c2a:	00 73 74             	add    %dh,0x74(%rbx)
 c2d:	61                   	(bad)
 c2e:	74 73                	je     ca3 <balancer_ingress+0xca3>
 c30:	5f                   	pop    %rdi
 c31:	64 61                	fs (bad)
 c33:	74 61                	je     c96 <balancer_ingress+0xc96>
 c35:	00 67 65             	add    %ah,0x65(%rdi)
 c38:	74 5f                	je     c99 <balancer_ingress+0xc99>
 c3a:	70 61                	jo     c9d <balancer_ingress+0xc9d>
 c3c:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 c3f:	74 5f                	je     ca0 <balancer_ingress+0xca0>
 c41:	64 73 74             	fs jae cb8 <balancer_ingress+0xcb8>
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 c44:	00 73 72             	add    %dh,0x72(%rbx)
 c47:	63 5f 66             	movsxd 0x66(%rdi),%ebx
 c4a:	6f                   	outsl  %ds:(%rsi),(%dx)
 c4b:	75 6e                	jne    cbb <balancer_ingress+0xcbb>
 c4d:	64 00 68 61          	add    %ch,%fs:0x61(%rax)
 c51:	73 68                	jae    cbb <balancer_ingress+0xcbb>
 c53:	5f                   	pop    %rdi
 c54:	31 36                	xor    %esi,(%rsi)
 c56:	62                   	(bad)
 c57:	79 74                	jns    ccd <balancer_ingress+0xccd>
 c59:	65 73 00             	gs jae c5c <balancer_ingress+0xc5c>
 c5c:	67 65 74 5f          	addr32 gs je cbf <balancer_ingress+0xcbf>
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 c60:	70 61                	jo     cc3 <balancer_ingress+0xcc3>
 c62:	63 6b 65             	movsxd 0x65(%rbx),%ebp
 c65:	74 5f                	je     cc6 <balancer_ingress+0xcc6>
 c67:	68 61 73 68 00       	push   $0x687361
 c6c:	69 6e 63 72 65 6d 65 	imul   $0x656d6572,0x63(%rsi),%ebp
 c73:	6e                   	outsb  %ds:(%rsi),(%dx)
 c74:	74 5f                	je     cd5 <balancer_ingress+0xcd5>
 c76:	63 68 5f             	movsxd 0x5f(%rax),%ebp
  return swap_mac_and_send(data, data_end);
 c79:	64 72 6f             	fs jb  ceb <balancer_ingress+0xceb>
 c7c:	70 5f                	jo     cdd <balancer_ingress+0xcdd>
 c7e:	72 65                	jb     ce5 <balancer_ingress+0xce5>
 c80:	61                   	(bad)
}
 c81:	6c                   	insb   (%dx),%es:(%rdi)
 c82:	5f                   	pop    %rdi
 c83:	30 00                	xor    %al,(%rax)
 c85:	63 68 5f             	movsxd 0x5f(%rax),%ebp
    return send_icmp_reply(data, data_end);
 c88:	64 72 6f             	fs jb  cfa <balancer_ingress+0xcfa>
 c8b:	70 5f                	jo     cec <balancer_ingress+0xcec>
 c8d:	73 74                	jae    d03 <balancer_ingress+0xd03>
 c8f:	61                   	(bad)
 c90:	74 73                	je     d05 <balancer_ingress+0xd05>
  if (icmp_hdr->type != ICMP_DEST_UNREACH) {
 c92:	5f                   	pop    %rdi
 c93:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 c97:	63 68 5f             	movsxd 0x5f(%rax),%ebp
 c9a:	64 72 6f             	fs jb  d0c <balancer_ingress+0xd0c>
 c9d:	70 5f                	jo     cfe <balancer_ingress+0xcfe>
 c9f:	73 74                	jae    d15 <balancer_ingress+0xd15>
    return XDP_PASS;
 ca1:	61                   	(bad)
 ca2:	74 73                	je     d17 <balancer_ingress+0xd17>
 ca4:	00 69 6e             	add    %ch,0x6e(%rcx)
 ca7:	63 72 65             	movsxd 0x65(%rdx),%esi
 caa:	6d                   	insl   (%dx),%es:(%rdi)
 cab:	65 6e                	outsb  %gs:(%rsi),(%dx)
 cad:	74 5f                	je     d0e <balancer_ingress+0xd0e>
 caf:	63 68 5f             	movsxd 0x5f(%rax),%ebp
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 cb2:	64 72 6f             	fs jb  d24 <balancer_ingress+0xd24>
 cb5:	70 5f                	jo     d16 <balancer_ingress+0xd16>
 cb7:	6e                   	outsb  %ds:(%rsi),(%dx)
 cb8:	6f                   	outsl  %ds:(%rsi),(%dx)
 cb9:	5f                   	pop    %rdi
 cba:	72 65                	jb     d21 <balancer_ingress+0xd21>
 cbc:	61                   	(bad)
 cbd:	6c                   	insb   (%dx),%es:(%rdi)
 cbe:	00 75 70             	add    %dh,0x70(%rbp)
 cc1:	64 61                	fs (bad)
 cc3:	74 65                	je     d2a <balancer_ingress+0xd2a>
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
 cc5:	5f                   	pop    %rdi
 cc6:	76 69                	jbe    d31 <balancer_ingress+0xd31>
 cc8:	70 5f                	jo     d29 <balancer_ingress+0xd29>
 cca:	6c                   	insb   (%dx),%es:(%rdi)
 ccb:	72 75                	jb     d42 <balancer_ingress+0xd42>
 ccd:	5f                   	pop    %rdi
        bpf_map_lookup_elem(&stats, &stats_key);
 cce:	6d                   	insl   (%dx),%es:(%rdi)
 ccf:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 cd6:	74 73                	je     d4b <balancer_ingress+0xd4b>
 cd8:	00 76 69             	add    %dh,0x69(%rsi)
 cdb:	70 5f                	jo     d3c <balancer_ingress+0xd3c>
 cdd:	6d                   	insl   (%dx),%es:(%rdi)
 cde:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 ce5:	74 73                	je     d5a <balancer_ingress+0xd5a>
 ce7:	5f                   	pop    %rdi
 ce8:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
 cec:	6c                   	insb   (%dx),%es:(%rdi)
 ced:	72 75                	jb     d64 <balancer_ingress+0xd64>
 cef:	5f                   	pop    %rdi
 cf0:	6d                   	insl   (%dx),%es:(%rdi)
 cf1:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 cf8:	74 5f                	je     d59 <balancer_ingress+0xd59>
 cfa:	76 69                	jbe    d65 <balancer_ingress+0xd65>
 cfc:	70 00                	jo     cfe <balancer_ingress+0xcfe>
 cfe:	61                   	(bad)
 cff:	64 64 72 65          	fs fs jb d68 <balancer_ingress+0xd68>
 d03:	73 73                	jae    d78 <balancer_ingress+0xd78>
 d05:	5f                   	pop    %rdi
 d06:	6d                   	insl   (%dx),%es:(%rdi)
 d07:	61                   	(bad)
 d08:	74 63                	je     d6d <balancer_ingress+0xd6d>
 d0a:	68 00 70 6f 72       	push   $0x726f7000
 d0f:	74 5f                	je     d70 <balancer_ingress+0xd70>
 d11:	6d                   	insl   (%dx),%es:(%rdi)
 d12:	61                   	(bad)
 d13:	74 63                	je     d78 <balancer_ingress+0xd78>
 d15:	68 00 70 72 6f       	push   $0x6f727000
 d1a:	74 6f                	je     d8b <balancer_ingress+0xd8b>
 d1c:	5f                   	pop    %rdi
 d1d:	6d                   	insl   (%dx),%es:(%rdi)
 d1e:	61                   	(bad)
 d1f:	74 63                	je     d84 <balancer_ingress+0xd84>
 d21:	68 00 76 69 70       	push   $0x70697600
 d26:	5f                   	pop    %rdi
 d27:	6d                   	insl   (%dx),%es:(%rdi)
 d28:	61                   	(bad)
 d29:	74 63                	je     d8e <balancer_ingress+0xd8e>
 d2b:	68 00 6c 72 75       	push   $0x75726c00
 d30:	5f                   	pop    %rdi
 d31:	6d                   	insl   (%dx),%es:(%rdi)
 d32:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
 d39:	74 00                	je     d3b <balancer_ingress+0xd3b>
 d3b:	65 6e                	outsb  %gs:(%rsi),(%dx)
 d3d:	63 61 70             	movsxd 0x70(%rcx),%esp
 d40:	5f                   	pop    %rdi
 d41:	76 36                	jbe    d79 <balancer_ingress+0xd79>
    struct lb_stats* icmp_ptb_v4_stats =
 d43:	00 6e 65             	add    %ch,0x65(%rsi)
 d46:	77 5f                	ja     da7 <balancer_ingress+0xda7>
 d48:	65 74 68             	gs je  db3 <balancer_ingress+0xdb3>
    if (!icmp_ptb_v4_stats) {
 d4b:	00 6f 6c             	add    %ch,0x6c(%rdi)
 d4e:	64 5f                	fs pop %rdi
 d50:	65 74 68             	gs je  dbb <balancer_ingress+0xdbb>
      return XDP_DROP;
 d53:	00 63 72             	add    %ah,0x72(%rbx)
 d56:	65 61                	gs (bad)
 d58:	74 65                	je     dbf <balancer_ingress+0xdbf>
 d5a:	5f                   	pop    %rdi
 d5b:	65 6e                	outsb  %gs:(%rsi),(%dx)
 d5d:	63 61 70             	movsxd 0x70(%rcx),%esp
 d60:	5f                   	pop    %rdi
 d61:	69 70 76 36 5f 73 72 	imul   $0x72735f36,0x76(%rax),%esi
    icmp_ptb_v4_stats->v1 += 1;
 d68:	63 00                	movsxd (%rax),%eax
 d6a:	63 72 65             	movsxd 0x65(%rdx),%esi
 d6d:	61                   	(bad)
 d6e:	74 65                	je     dd5 <balancer_ingress+0xdd5>
 d70:	5f                   	pop    %rdi
 d71:	76 36                	jbe    da9 <balancer_ingress+0xda9>
    __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);
 d73:	5f                   	pop    %rdi
 d74:	68 64 72 00 74       	push   $0x74007264
 d79:	63 00                	movsxd (%rax),%eax
 d7b:	65 6e                	outsb  %gs:(%rsi),(%dx)
 d7d:	63 61 70             	movsxd 0x70(%rcx),%esp
 d80:	5f                   	pop    %rdi
 d81:	76 34                	jbe    db7 <balancer_ingress+0xdb7>
 d83:	00 69 70             	add    %ch,0x70(%rcx)
 d86:	5f                   	pop    %rdi
 d87:	73 72                	jae    dfb <balancer_ingress+0xdfb>
 d89:	63 00                	movsxd (%rax),%eax
 d8b:	63 72 65             	movsxd 0x65(%rdx),%esi
 d8e:	61                   	(bad)
 d8f:	74 65                	je     df6 <balancer_ingress+0xdf6>
 d91:	5f                   	pop    %rdi
 d92:	65 6e                	outsb  %gs:(%rsi),(%dx)
 d94:	63 61 70             	movsxd 0x70(%rcx),%esp
 d97:	5f                   	pop    %rdi
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 d98:	69 70 76 34 5f 73 72 	imul   $0x72735f34,0x76(%rax),%esi
 d9f:	63 00                	movsxd (%rax),%eax
 da1:	69 70 5f 73 75 66 66 	imul   $0x66667573,0x5f(%rax),%esi
      icmp_ptb_v4_stats->v2 += 1;
 da8:	69 78 00 63 72 65 61 	imul   $0x61657263,0x0(%rax),%edi
 daf:	74 65                	je     e16 <balancer_ingress+0xe16>
 db1:	5f                   	pop    %rdi
 db2:	76 34                	jbe    de8 <balancer_ingress+0xde8>
 db4:	5f                   	pop    %rdi
 db5:	68 64 72 00 62       	push   $0x62007264
  }
 dba:	61                   	(bad)
  off += sizeof(struct icmphdr);
 dbb:	6c                   	insb   (%dx),%es:(%rdi)
 dbc:	61                   	(bad)
 dbd:	6e                   	outsb  %ds:(%rsi),(%dx)
 dbe:	63 65 72             	movsxd 0x72(%rbp),%esp
 dc1:	5f                   	pop    %rdi
 dc2:	69 6e 67 72 65 73 73 	imul   $0x73736572,0x67(%rsi),%ebp
 dc9:	00 6a 68             	add    %ch,0x68(%rdx)
 dcc:	61                   	(bad)
  iph = data + off;
 dcd:	73 68                	jae    e37 <balancer_ingress+0xe37>
 dcf:	00 6a 68             	add    %ch,0x68(%rdx)
 dd2:	61                   	(bad)
 dd3:	73 68                	jae    e3d <balancer_ingress+0xe3d>
 dd5:	5f                   	pop    %rdi
 dd6:	32 77 6f             	xor    0x6f(%rdi),%dh
 dd9:	72 64                	jb     e3f <balancer_ingress+0xe3f>
 ddb:	73 00                	jae    ddd <balancer_ingress+0xddd>
 ddd:	5f                   	pop    %rdi
 dde:	5f                   	pop    %rdi
 ddf:	6a 68                	push   $0x68
 de1:	61                   	(bad)
  if (iph + 1 > data_end) {
 de2:	73 68                	jae    e4c <balancer_ingress+0xe4c>
 de4:	5f                   	pop    %rdi
 de5:	6e                   	outsb  %ds:(%rsi),(%dx)
 de6:	77 6f                	ja     e57 <balancer_ingress+0xe57>
 de8:	72 64                	jb     e4e <balancer_ingress+0xe4e>
 dea:	73 00                	jae    dec <balancer_ingress+0xdec>
 dec:	72 6f                	jb     e5d <balancer_ingress+0xe5d>
 dee:	6c                   	insb   (%dx),%es:(%rdi)
 def:	33 32                	xor    (%rdx),%esi
 df1:	00 63 74             	add    %ah,0x74(%rbx)
 df4:	78 00                	js     df6 <balancer_ingress+0xdf6>
 df6:	65 74 68             	gs je  e61 <balancer_ingress+0xe61>
    return XDP_DROP;
 df9:	5f                   	pop    %rdi
 dfa:	70 72                	jo     e6e <balancer_ingress+0xe6e>
 dfc:	6f                   	outsl  %ds:(%rsi),(%dx)
 dfd:	74 6f                	je     e6e <balancer_ingress+0xe6e>
 dff:	00 6c 65 6e          	add    %ch,0x6e(%rbp,%riz,2)
 e03:	67 74 68             	addr32 je e6e <balancer_ingress+0xe6e>
  if (iph->ihl != 5) {
 e06:	00 69 6e             	add    %ch,0x6e(%rcx)
 e09:	69 74 76 61 6c 00 62 	imul   $0x62006c,0x61(%rsi,%rsi,2),%esi
 e10:	00 
 e11:	77 6f                	ja     e82 <balancer_ingress+0xe82>
 e13:	72 64                	jb     e79 <balancer_ingress+0xe79>
 e15:	00 73 68             	add    %dh,0x68(%rbx)
    return XDP_DROP;
 e18:	69                   	.byte 0x69
 e19:	66 74 00             	data16 je e1c <balancer_ingress+0xe1c>

Disassembly of section .debug_addr:

0000000000000000 <.debug_addr>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	14 08                	adc    $0x8,%al
   2:	00 00                	add    %al,(%rax)
   4:	05 00 08 00 d4       	add    $0xd4000800,%eax
   9:	7c 00                	jl     b <balancer_ingress+0xb>
   b:	00 00                	add    %al,(%rax)
   d:	00 00                	add    %al,(%rax)
   f:	00 00                	add    %al,(%rax)
  11:	20 97 51 81 88 ff    	and    %dl,-0x777eaf(%rdi)
  void* data = (void*)(long)ctx->data;
  17:	ff 00                	incl   (%rax)
  19:	40 11 3a             	rex adc %edi,(%rdx)
  1c:	81 88 ff ff 00 38 11 	orl    $0x88813a11,0x3800ffff(%rax)
  23:	3a 81 88 
  26:	ff                   	(bad)
  void* data_end = (void*)(long)ctx->data_end;
  27:	ff 00                	incl   (%rax)
  29:	a0 27 71 81 88 ff ff 	movabs 0x7000ffff88817127,%al
  30:	00 70 
  32:	1f                   	(bad)
  33:	e4 00                	in     $0x0,%al
  35:	c9                   	leave
  36:	ff                   	(bad)
  37:	ff 00                	incl   (%rax)
  struct ethhdr* eth = data;
  39:	30 50 52             	xor    %dl,0x52(%rax)
  3c:	00 c9                	add    %cl,%cl
  3e:	ff                   	(bad)
  3f:	ff 00                	incl   (%rax)
  41:	a0 0d 52 00 c9 ff ff 	movabs 0xc000ffffc900520d,%al
  48:	00 c0 
  nh_off = sizeof(struct ethhdr);
  4a:	11 52 00             	adc    %edx,0x0(%rdx)
  4d:	c9                   	leave
  4e:	ff                   	(bad)
  4f:	ff 00                	incl   (%rax)
  if (data + nh_off > data_end) {
  51:	24 97                	and    $0x97,%al
  53:	51                   	push   %rcx
  54:	81 88 ff ff 00 c0 24 	orl    $0x88812e24,-0x3fff0001(%rax)
  5b:	2e 81 88 
  5e:	ff                   	(bad)
  5f:	ff 00                	incl   (%rax)
  61:	28 97 51 81 88 ff    	sub    %dl,-0x777eaf(%rdi)
  67:	ff 00                	incl   (%rax)
  69:	2c 97                	sub    $0x97,%al
    return XDP_DROP;
  6b:	51                   	push   %rcx
  6c:	81 88 ff ff 00 c0 b4 	orl    $0x88811fb4,-0x3fff0001(%rax)
  73:	1f 81 88 
  76:	ff                   	(bad)
  77:	ff 00                	incl   (%rax)
  eth_proto = eth->h_proto;
  79:	c0 27 f4             	shlb   $0xf4,(%rdi)
  7c:	00 c9                	add    %cl,%cl
  7e:	ff                   	(bad)
  7f:	ff 00                	incl   (%rax)
  81:	30 97 51 81 88 ff    	xor    %dl,-0x777eaf(%rdi)
  87:	ff 00                	incl   (%rax)
  89:	80 b4 1f 81 88 ff ff 	xorb   $0x0,-0x777f(%rdi,%rbx,1)
  90:	00 
  if (eth_proto == BE_ETH_P_IP) {
  91:	20 11                	and    %dl,(%rcx)
  93:	3a 81 88 ff ff 80    	cmp    -0x7f000078(%rcx),%al
    return process_packet(ctx, nh_off, false);
  99:	7f 00                	jg     9b <balancer_ingress+0x9b>
  9b:	00 00                	add    %al,(%rax)
  9d:	00 00                	add    %al,(%rax)
  9f:	00 88 7f 00 00 00    	add    %cl,0x7f(%rax)
  a5:	00 00                	add    %al,(%rax)
  a7:	00 98 7f 00 00 00    	add    %bl,0x7f(%rax)
  ad:	00 00                	add    %al,(%rax)
  af:	00 90 7f 00 00 00    	add    %dl,0x7f(%rax)
  b5:	00 00                	add    %al,(%rax)
  b7:	00 a0 7f 00 00 00    	add    %ah,0x7f(%rax)
	...
  void* data = (void*)(long)xdp->data;
  c5:	00 00                	add    %al,(%rax)
  c7:	00 b9 00 00 00 00    	add    %bh,0x0(%rcx)
  void* data_end = (void*)(long)xdp->data_end;
  cd:	00 00                	add    %al,(%rax)
  cf:	00 c3                	add    %al,%bl
  d1:	01 00                	add    %eax,(%rax)
  d3:	00 00                	add    %al,(%rax)
  d5:	00 00                	add    %al,(%rax)
  d7:	00 fb                	add    %bh,%bl
  d9:	04 00                	add    $0x0,%al
  db:	00 00                	add    %al,(%rax)
  struct real_definition* dst = NULL;
  dd:	00 00                	add    %al,(%rax)
  df:	00 43 05             	add    %al,0x5(%rbx)
  e2:	00 00                	add    %al,(%rax)
  e4:	00 00                	add    %al,(%rax)
  e6:	00 00                	add    %al,(%rax)
  struct packet_description pckt = {};
  e8:	af                   	scas   %es:(%rdi),%eax
  e9:	05 00 00 00 00       	add    $0x0,%eax
  ee:	00 00                	add    %al,(%rax)
  f0:	ce                   	(bad)
  f1:	06                   	(bad)
  f2:	00 00                	add    %al,(%rax)
  f4:	00 00                	add    %al,(%rax)
  f6:	00 00                	add    %al,(%rax)
  f8:	87 07                	xchg   %eax,(%rdi)
  fa:	00 00                	add    %al,(%rax)
  fc:	00 00                	add    %al,(%rax)
  fe:	00 00                	add    %al,(%rax)
 100:	91                   	xchg   %eax,%ecx
 101:	07                   	(bad)
 102:	00 00                	add    %al,(%rax)
 104:	00 00                	add    %al,(%rax)
 106:	00 00                	add    %al,(%rax)
 108:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
 109:	07                   	(bad)
 10a:	00 00                	add    %al,(%rax)
 10c:	00 00                	add    %al,(%rax)
 10e:	00 00                	add    %al,(%rax)
 110:	82                   	(bad)
 111:	09 00                	or     %eax,(%rax)
 113:	00 00                	add    %al,(%rax)
 115:	00 00                	add    %al,(%rax)
 117:	00 ec                	add    %ch,%ah
 119:	09 00                	or     %eax,(%rax)
 11b:	00 00                	add    %al,(%rax)
 11d:	00 00                	add    %al,(%rax)
  struct vip_definition vip = {};
 11f:	00 09                	add    %cl,(%rcx)
 121:	0b 00                	or     (%rax),%eax
 123:	00 00                	add    %al,(%rax)
 125:	00 00                	add    %al,(%rax)
 127:	00 17                	add    %dl,(%rdi)
 129:	0b 00                	or     (%rax),%eax
 12b:	00 00                	add    %al,(%rax)
 12d:	00 00                	add    %al,(%rax)
 12f:	00 77 0b             	add    %dh,0xb(%rdi)
 132:	00 00                	add    %al,(%rax)
 134:	00 00                	add    %al,(%rax)
 136:	00 00                	add    %al,(%rax)
 138:	19 0c 00             	sbb    %ecx,(%rax,%rax,1)
 13b:	00 00                	add    %al,(%rax)
 13d:	00 00                	add    %al,(%rax)
  __u32 mac_addr_pos = 0;
 13f:	00 c4                	add    %al,%ah
 141:	0c 00                	or     $0x0,%al
 143:	00 00                	add    %al,(%rax)
 145:	00 00                	add    %al,(%rax)
 147:	00 ce                	add    %cl,%dh
  __u64 th_off = 0;
 149:	0c 00                	or     $0x0,%al
 14b:	00 00                	add    %al,(%rax)
 14d:	00 00                	add    %al,(%rax)
 14f:	00 e3                	add    %ah,%bl
 151:	0c 00                	or     $0x0,%al
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
 153:	00 00                	add    %al,(%rax)
 155:	00 00                	add    %al,(%rax)
 157:	00 0c 0f             	add    %cl,(%rdi,%rcx,1)
 15a:	00 00                	add    %al,(%rax)
 15c:	00 00                	add    %al,(%rax)
 15e:	00 00                	add    %al,(%rax)
 160:	47 0f 00 00          	rex.RXB sldt (%r8)
 164:	00 00                	add    %al,(%rax)
 166:	00 00                	add    %al,(%rax)
 168:	f6 10                	notb   (%rax)
 16a:	00 00                	add    %al,(%rax)
 16c:	00 00                	add    %al,(%rax)
 16e:	00 00                	add    %al,(%rax)
 170:	31 11                	xor    %edx,(%rcx)
 172:	00 00                	add    %al,(%rax)
 174:	00 00                	add    %al,(%rax)
 176:	00 00                	add    %al,(%rax)
 178:	c4                   	(bad)
 179:	12 00                	adc    (%rax),%al
 17b:	00 00                	add    %al,(%rax)
 17d:	00 00                	add    %al,(%rax)
 17f:	00 d9                	add    %bl,%cl
 181:	12 00                	adc    (%rax),%al
 183:	00 00                	add    %al,(%rax)
 185:	00 00                	add    %al,(%rax)
 187:	00 56 13             	add    %dl,0x13(%rsi)
 18a:	00 00                	add    %al,(%rax)
 18c:	00 00                	add    %al,(%rax)
 18e:	00 00                	add    %al,(%rax)
 190:	6b 13 00             	imul   $0x0,(%rbx),%edx
 193:	00 00                	add    %al,(%rax)
 195:	00 00                	add    %al,(%rax)
 197:	00 4b 14             	add    %cl,0x14(%rbx)
 19a:	00 00                	add    %al,(%rax)
 19c:	00 00                	add    %al,(%rax)
 19e:	00 00                	add    %al,(%rax)
 1a0:	60                   	(bad)
 1a1:	14 00                	adc    $0x0,%al
 1a3:	00 00                	add    %al,(%rax)
 1a5:	00 00                	add    %al,(%rax)
 1a7:	00 2f                	add    %ch,(%rdi)
 1a9:	15 00 00 00 00       	adc    $0x0,%eax
 1ae:	00 00                	add    %al,(%rax)
 1b0:	44 15 00 00 00 00    	rex.R adc $0x0,%eax
 1b6:	00 00                	add    %al,(%rax)
 1b8:	b8 15 00 00 00       	mov    $0x15,%eax
 1bd:	00 00                	add    %al,(%rax)
 1bf:	00 d3                	add    %dl,%bl
 1c1:	15 00 00 00 00       	adc    $0x0,%eax
  if (is_ipv6) {
 1c6:	00 00                	add    %al,(%rax)
 1c8:	e8 15 00 00 00       	call   1e2 <balancer_ingress+0x1e2>
 1cd:	00 00                	add    %al,(%rax)
 1cf:	00 8d 16 00 00 00    	add    %cl,0x16(%rbp)
    ip6h = data + nh_off;
 1d5:	00 00                	add    %al,(%rax)
 1d7:	00 b2 16 00 00 00    	add    %dh,0x16(%rdx)
 1dd:	00 00                	add    %al,(%rax)
 1df:	00 bc 16 00 00 00 00 	add    %bh,0x0(%rsi,%rdx,1)
    if (ip6h + 1 > data_end) {
 1e6:	00 00                	add    %al,(%rax)
 1e8:	d1 16                	rcll   (%rsi)
 1ea:	00 00                	add    %al,(%rax)
 1ec:	00 00                	add    %al,(%rax)
 1ee:	00 00                	add    %al,(%rax)
 1f0:	8b 17                	mov    (%rdi),%edx
 1f2:	00 00                	add    %al,(%rax)
 1f4:	00 00                	add    %al,(%rax)
 1f6:	00 00                	add    %al,(%rax)
 1f8:	9f                   	lahf
 1f9:	17                   	(bad)
 1fa:	00 00                	add    %al,(%rax)
      return XDP_DROP;
 1fc:	00 00                	add    %al,(%rax)
 1fe:	00 00                	add    %al,(%rax)
 200:	f7 17                	notl   (%rdi)
 202:	00 00                	add    %al,(%rax)
 204:	00 00                	add    %al,(%rax)
 206:	00 00                	add    %al,(%rax)
 208:	70 18                	jo     222 <balancer_ingress+0x222>
 20a:	00 00                	add    %al,(%rax)
    iph_len = sizeof(struct ipv6hdr);
 20c:	00 00                	add    %al,(%rax)
 20e:	00 00                	add    %al,(%rax)
 210:	7a 18                	jp     22a <balancer_ingress+0x22a>
 212:	00 00                	add    %al,(%rax)
 214:	00 00                	add    %al,(%rax)
    *protocol = ip6h->nexthdr;
 216:	00 00                	add    %al,(%rax)
 218:	8f                   	(bad)
 219:	18 00                	sbb    %al,(%rax)
 21b:	00 00                	add    %al,(%rax)
 21d:	00 00                	add    %al,(%rax)
 21f:	00 46 19             	add    %al,0x19(%rsi)
 222:	00 00                	add    %al,(%rax)
 224:	00 00                	add    %al,(%rax)
 226:	00 00                	add    %al,(%rax)
 228:	96                   	xchg   %eax,%esi
    pckt->flow.proto = *protocol;
 229:	19 00                	sbb    %eax,(%rax)
 22b:	00 00                	add    %al,(%rax)
 22d:	00 00                	add    %al,(%rax)
 22f:	00 82 1a 00 00 00    	add    %al,0x1a(%rdx)
 235:	00 00                	add    %al,(%rax)
 237:	00 39                	add    %bh,(%rcx)
 239:	1c 00                	sbb    $0x0,%al
 23b:	00 00                	add    %al,(%rax)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 23d:	00 00                	add    %al,(%rax)
 23f:	00 53 1c             	add    %dl,0x1c(%rbx)
 242:	00 00                	add    %al,(%rax)
 244:	00 00                	add    %al,(%rax)
 246:	00 00                	add    %al,(%rax)
 248:	d9 1c 00             	fstps  (%rax,%rax,1)
 24b:	00 00                	add    %al,(%rax)
 24d:	00 00                	add    %al,(%rax)
 24f:	00 ee                	add    %ch,%dh
 251:	1c 00                	sbb    $0x0,%al
 253:	00 00                	add    %al,(%rax)
 255:	00 00                	add    %al,(%rax)
 257:	00 b5 1d 00 00 00    	add    %dh,0x1d(%rbp)
 25d:	00 00                	add    %al,(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 25f:	00 c1                	add    %al,%cl
 261:	1d 00 00 00 00       	sbb    $0x0,%eax
 266:	00 00                	add    %al,(%rax)
 268:	d6                   	(bad)
 269:	1d 00 00 00 00       	sbb    $0x0,%eax
 26e:	00 00                	add    %al,(%rax)
 270:	84 1e                	test   %bl,(%rsi)
 272:	00 00                	add    %al,(%rax)
 274:	00 00                	add    %al,(%rax)
 276:	00 00                	add    %al,(%rax)
 278:	06                   	(bad)
 279:	1f                   	(bad)
 27a:	00 00                	add    %al,(%rax)
 27c:	00 00                	add    %al,(%rax)
 27e:	00 00                	add    %al,(%rax)
 280:	10 1f                	adc    %bl,(%rdi)
 282:	00 00                	add    %al,(%rax)
 284:	00 00                	add    %al,(%rax)
 286:	00 00                	add    %al,(%rax)
    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
 288:	25 1f 00 00 00       	and    $0x1f,%eax
 28d:	00 00                	add    %al,(%rax)
 28f:	00 06                	add    %al,(%rsi)
 291:	21 00                	and    %eax,(%rax)
 293:	00 00                	add    %al,(%rax)
 295:	00 00                	add    %al,(%rax)
 297:	00 1b                	add    %bl,(%rbx)
 299:	21 00                	and    %eax,(%rax)
 29b:	00 00                	add    %al,(%rax)
 29d:	00 00                	add    %al,(%rax)
 29f:	00 76 22             	add    %dh,0x22(%rsi)
 2a2:	00 00                	add    %al,(%rax)
 2a4:	00 00                	add    %al,(%rax)
 2a6:	00 00                	add    %al,(%rax)
 2a8:	8b 22                	mov    (%rdx),%esp
 2aa:	00 00                	add    %al,(%rax)
 2ac:	00 00                	add    %al,(%rax)
 2ae:	00 00                	add    %al,(%rax)
 2b0:	be 23 00 00 00       	mov    $0x23,%esi
    *th_off += nh_off + iph_len;
 2b5:	00 00                	add    %al,(%rax)
 2b7:	00 77 24             	add    %dh,0x24(%rdi)
 2ba:	00 00                	add    %al,(%rax)
 2bc:	00 00                	add    %al,(%rax)
 2be:	00 00                	add    %al,(%rax)
 2c0:	8c 24 00             	mov    %fs,(%rax,%rax,1)
 2c3:	00 00                	add    %al,(%rax)
 2c5:	00 00                	add    %al,(%rax)
 2c7:	00 2f                	add    %ch,(%rdi)
 2c9:	25 00 00 00 00       	and    $0x0,%eax
    if (*protocol == IPPROTO_FRAGMENT) {
 2ce:	00 00                	add    %al,(%rax)
 2d0:	76 25                	jbe    2f7 <balancer_ingress+0x2f7>
 2d2:	00 00                	add    %al,(%rax)
 2d4:	00 00                	add    %al,(%rax)
 2d6:	00 00                	add    %al,(%rax)
 2d8:	80 25 00 00 00 00 00 	andb   $0x0,0x0(%rip)        # 2df <balancer_ingress+0x2df>
      return XDP_DROP;
 2df:	00 95 25 00 00 00    	add    %dl,0x25(%rbp)
 2e5:	00 00                	add    %al,(%rax)
 2e7:	00 af 26 00 00 00    	add    %ch,0x26(%rdi)
    } else if (*protocol == IPPROTO_ICMPV6) {
 2ed:	00 00                	add    %al,(%rax)
 2ef:	00 c4                	add    %al,%ah
 2f1:	26 00 00             	es add %al,(%rax)
 2f4:	00 00                	add    %al,(%rax)
 2f6:	00 00                	add    %al,(%rax)
 2f8:	3b 27                	cmp    (%rdi),%esp
 2fa:	00 00                	add    %al,(%rax)
      return FURTHER_PROCESSING;
 2fc:	00 00                	add    %al,(%rax)
 2fe:	00 00                	add    %al,(%rax)
 300:	71 27                	jno    329 <balancer_ingress+0x329>
 302:	00 00                	add    %al,(%rax)
 304:	00 00                	add    %al,(%rax)
 306:	00 00                	add    %al,(%rax)
 308:	89 27                	mov    %esp,(%rdi)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 30a:	00 00                	add    %al,(%rax)
 30c:	00 00                	add    %al,(%rax)
 30e:	00 00                	add    %al,(%rax)
 310:	9e                   	sahf
 311:	27                   	(bad)
 312:	00 00                	add    %al,(%rax)
 314:	00 00                	add    %al,(%rax)
 316:	00 00                	add    %al,(%rax)
 318:	43 28 00             	rex.XB sub %al,(%r8)
 31b:	00 00                	add    %al,(%rax)
 31d:	00 00                	add    %al,(%rax)
 31f:	00 4d 28             	add    %cl,0x28(%rbp)
 322:	00 00                	add    %al,(%rax)
 324:	00 00                	add    %al,(%rax)
 326:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 328:	62                   	(bad)
 329:	28 00                	sub    %al,(%rax)
 32b:	00 00                	add    %al,(%rax)
 32d:	00 00                	add    %al,(%rax)
 32f:	00 5f 29             	add    %bl,0x29(%rdi)
 332:	00 00                	add    %al,(%rax)
 334:	00 00                	add    %al,(%rax)
 336:	00 00                	add    %al,(%rax)
 338:	9e                   	sahf
 339:	29 00                	sub    %eax,(%rax)
 33b:	00 00                	add    %al,(%rax)
 33d:	00 00                	add    %al,(%rax)
 33f:	00 a8 29 00 00 00    	add    %ch,0x29(%rax)
  } else {
 345:	00 00                	add    %al,(%rax)
 347:	00 bd 29 00 00 00    	add    %bh,0x29(%rbp)
    iph = data + nh_off;
 34d:	00 00                	add    %al,(%rax)
 34f:	00 e5                	add    %ah,%ch
 351:	2a 00                	sub    (%rax),%al
 353:	00 00                	add    %al,(%rax)
 355:	00 00                	add    %al,(%rax)
 357:	00 4e 2b             	add    %cl,0x2b(%rsi)
 35a:	00 00                	add    %al,(%rax)
 35c:	00 00                	add    %al,(%rax)
 35e:	00 00                	add    %al,(%rax)
    if (iph + 1 > data_end) {
 360:	dd 2b                	(bad)  (%rbx)
 362:	00 00                	add    %al,(%rax)
 364:	00 00                	add    %al,(%rax)
 366:	00 00                	add    %al,(%rax)
 368:	f2 2b 00             	repnz sub (%rax),%eax
 36b:	00 00                	add    %al,(%rax)
 36d:	00 00                	add    %al,(%rax)
 36f:	00 8a 2c 00 00 00    	add    %cl,0x2c(%rdx)
 375:	00 00                	add    %al,(%rax)
      return XDP_DROP;
 377:	00 94 2c 00 00 00 00 	add    %dl,0x0(%rsp,%rbp,1)
 37e:	00 00                	add    %al,(%rax)
 380:	a9 2c 00 00 00       	test   $0x2c,%eax
    if (iph->ihl != 5) {
 385:	00 00                	add    %al,(%rax)
 387:	00 4c 2d 00          	add    %cl,0x0(%rbp,%rbp,1)
 38b:	00 00                	add    %al,(%rax)
 38d:	00 00                	add    %al,(%rax)
 38f:	00 61 2d             	add    %ah,0x2d(%rcx)
 392:	00 00                	add    %al,(%rax)
 394:	00 00                	add    %al,(%rax)
 396:	00 00                	add    %al,(%rax)
      return XDP_DROP;
 398:	db 2d 00 00 00 00    	fldt   0x0(%rip)        # 39e <balancer_ingress+0x39e>
 39e:	00 00                	add    %al,(%rax)
 3a0:	e5 2d                	in     $0x2d,%eax
 3a2:	00 00                	add    %al,(%rax)
 3a4:	00 00                	add    %al,(%rax)
 3a6:	00 00                	add    %al,(%rax)
    pckt->tos = iph->tos;
 3a8:	fa                   	cli
 3a9:	2d 00 00 00 00       	sub    $0x0,%eax
 3ae:	00 00                	add    %al,(%rax)
 3b0:	51                   	push   %rcx
 3b1:	2f                   	(bad)
 3b2:	00 00                	add    %al,(%rax)
 3b4:	00 00                	add    %al,(%rax)
 3b6:	00 00                	add    %al,(%rax)
 3b8:	5b                   	pop    %rbx
 3b9:	2f                   	(bad)
 3ba:	00 00                	add    %al,(%rax)
    *protocol = iph->protocol;
 3bc:	00 00                	add    %al,(%rax)
 3be:	00 00                	add    %al,(%rax)
 3c0:	70 2f                	jo     3f1 <balancer_ingress+0x3f1>
 3c2:	00 00                	add    %al,(%rax)
 3c4:	00 00                	add    %al,(%rax)
 3c6:	00 00                	add    %al,(%rax)
 3c8:	29 31                	sub    %esi,(%rcx)
 3ca:	00 00                	add    %al,(%rax)
 3cc:	00 00                	add    %al,(%rax)
    pckt->flow.proto = *protocol;
 3ce:	00 00                	add    %al,(%rax)
 3d0:	39 31                	cmp    %esi,(%rcx)
 3d2:	00 00                	add    %al,(%rax)
 3d4:	00 00                	add    %al,(%rax)
 3d6:	00 00                	add    %al,(%rax)
 3d8:	4e 31 00             	rex.WRX xor %r8,(%rax)
 3db:	00 00                	add    %al,(%rax)
 3dd:	00 00                	add    %al,(%rax)
 3df:	00 0f                	add    %cl,(%rdi)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
 3e1:	32 00                	xor    (%rax),%al
 3e3:	00 00                	add    %al,(%rax)
 3e5:	00 00                	add    %al,(%rax)
 3e7:	00 24 32             	add    %ah,(%rdx,%rsi,1)
 3ea:	00 00                	add    %al,(%rax)
 3ec:	00 00                	add    %al,(%rax)
 3ee:	00 00                	add    %al,(%rax)
 3f0:	a3 32 00 00 00 00 00 	movabs %eax,0xb800000000000032
 3f7:	00 b8 
 3f9:	32 00                	xor    (%rax),%al
 3fb:	00 00                	add    %al,(%rax)
 3fd:	00 00                	add    %al,(%rax)
 3ff:	00 60 33             	add    %ah,0x33(%rax)
 402:	00 00                	add    %al,(%rax)
 404:	00 00                	add    %al,(%rax)
 406:	00 00                	add    %al,(%rax)
 408:	75 33                	jne    43d <balancer_ingress+0x43d>
 40a:	00 00                	add    %al,(%rax)
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;
 40c:	00 00                	add    %al,(%rax)
 40e:	00 00                	add    %al,(%rax)
 410:	96                   	xchg   %eax,%esi
 411:	34 00                	xor    $0x0,%al
 413:	00 00                	add    %al,(%rax)
 415:	00 00                	add    %al,(%rax)
 417:	00 ee                	add    %ch,%dh
 419:	35 00 00 00 00       	xor    $0x0,%eax
 41e:	00 00                	add    %al,(%rax)
 420:	7c 36                	jl     458 <balancer_ingress+0x458>
 422:	00 00                	add    %al,(%rax)
    if (iph->frag_off & PCKT_FRAGMENTED) {
 424:	00 00                	add    %al,(%rax)
 426:	00 00                	add    %al,(%rax)
 428:	21 37                	and    %esi,(%rdi)
 42a:	00 00                	add    %al,(%rax)
 42c:	00 00                	add    %al,(%rax)
 42e:	00 00                	add    %al,(%rax)
 430:	6b 38 00             	imul   $0x0,(%rax),%edi
 433:	00 00                	add    %al,(%rax)
 435:	00 00                	add    %al,(%rax)
 437:	00 8c 38 00 00 00 00 	add    %cl,0x0(%rax,%rdi,1)
      return XDP_DROP;
 43e:	00 00                	add    %al,(%rax)
 440:	40 3a 00             	rex cmp (%rax),%al
 443:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
 445:	00 00                	add    %al,(%rax)
 447:	00 e8                	add    %ch,%al
 449:	3a 00                	cmp    (%rax),%al
 44b:	00 00                	add    %al,(%rax)
 44d:	00 00                	add    %al,(%rax)
 44f:	00 f0                	add    %dh,%al
 451:	3a 00                	cmp    (%rax),%al
 453:	00 00                	add    %al,(%rax)
      return FURTHER_PROCESSING;
 455:	00 00                	add    %al,(%rax)
 457:	00 35 3b 00 00 00    	add    %dh,0x3b(%rip)        # 498 <balancer_ingress+0x498>
 45d:	00 00                	add    %al,(%rax)
 45f:	00 02                	add    %al,(%rdx)
      pckt->flow.src = iph->saddr;
 461:	3c 00                	cmp    $0x0,%al
 463:	00 00                	add    %al,(%rax)
 465:	00 00                	add    %al,(%rax)
 467:	00 0c 3d 00 00 00 00 	add    %cl,0x0(,%rdi,1)
 46e:	00 00                	add    %al,(%rax)
 470:	44                   	rex.R
 471:	40 00 00             	rex add %al,(%rax)
      pckt->flow.dst = iph->daddr;
 474:	00 00                	add    %al,(%rax)
 476:	00 00                	add    %al,(%rax)
 478:	8c 40 00             	mov    %es,0x0(%rax)
 47b:	00 00                	add    %al,(%rax)
 47d:	00 00                	add    %al,(%rax)
 47f:	00 f8                	add    %bh,%al
 481:	40 00 00             	rex add %al,(%rax)
 484:	00 00                	add    %al,(%rax)
 486:	00 00                	add    %al,(%rax)
  return FURTHER_PROCESSING;
 488:	17                   	(bad)
 489:	42 00 00             	rex.X add %al,(%rax)
 48c:	00 00                	add    %al,(%rax)
 48e:	00 00                	add    %al,(%rax)
 490:	d0 42 00             	rolb   0x0(%rdx)
}
 493:	00 00                	add    %al,(%rax)
 495:	00 00                	add    %al,(%rax)
  action = parse_l3_headers(
 497:	00 da                	add    %bl,%dl
 499:	42 00 00             	rex.X add %al,(%rax)
 49c:	00 00                	add    %al,(%rax)
  if (action >= 0) {
 49e:	00 00                	add    %al,(%rax)
 4a0:	ef                   	out    %eax,(%dx)
 4a1:	42 00 00             	rex.X add %al,(%rax)
 4a4:	00 00                	add    %al,(%rax)
    return action;
 4a6:	00 00                	add    %al,(%rax)
 4a8:	cb                   	lret
 4a9:	44 00 00             	add    %r8b,(%rax)
 4ac:	00 00                	add    %al,(%rax)
 4ae:	00 00                	add    %al,(%rax)
 4b0:	35 45 00 00 00       	xor    $0x45,%eax
 4b5:	00 00                	add    %al,(%rax)
  action = handle_if_icmp(data, data_end, th_off, &pckt, protocol);
 4b7:	00 52 46             	add    %dl,0x46(%rdx)
 4ba:	00 00                	add    %al,(%rax)
 4bc:	00 00                	add    %al,(%rax)
 4be:	00 00                	add    %al,(%rax)
 4c0:	60                   	(bad)
 4c1:	46 00 00             	rex.RX add %r8b,(%rax)
 4c4:	00 00                	add    %al,(%rax)
 4c6:	00 00                	add    %al,(%rax)
 4c8:	c0 46 00 00          	rolb   $0x0,0x0(%rsi)
 4cc:	00 00                	add    %al,(%rax)
 4ce:	00 00                	add    %al,(%rax)
 4d0:	62                   	(bad)
 4d1:	47 00 00             	rex.RXB add %r8b,(%r8)
 4d4:	00 00                	add    %al,(%rax)
 4d6:	00 00                	add    %al,(%rax)
 4d8:	0d 48 00 00 00       	or     $0x48,%eax
 4dd:	00 00                	add    %al,(%rax)
 4df:	00 17                	add    %dl,(%rdi)
 4e1:	48 00 00             	rex.W add %al,(%rax)
 4e4:	00 00                	add    %al,(%rax)
 4e6:	00 00                	add    %al,(%rax)
 4e8:	2c 48                	sub    $0x48,%al
 4ea:	00 00                	add    %al,(%rax)
 4ec:	00 00                	add    %al,(%rax)
 4ee:	00 00                	add    %al,(%rax)
 4f0:	55                   	push   %rbp
 4f1:	4a 00 00             	rex.WX add %al,(%rax)
 4f4:	00 00                	add    %al,(%rax)
 4f6:	00 00                	add    %al,(%rax)
 4f8:	90                   	nop
 4f9:	4a 00 00             	rex.WX add %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 4fc:	00 00                	add    %al,(%rax)
 4fe:	00 00                	add    %al,(%rax)
 500:	3f                   	(bad)
 501:	4c 00 00             	rex.WR add %r8b,(%rax)
 504:	00 00                	add    %al,(%rax)
 506:	00 00                	add    %al,(%rax)
 508:	7a 4c                	jp     556 <balancer_ingress+0x556>
 50a:	00 00                	add    %al,(%rax)
    return parse_icmpv6(data, data_end, off, pckt);
 50c:	00 00                	add    %al,(%rax)
 50e:	00 00                	add    %al,(%rax)
 510:	0d 4e 00 00 00       	or     $0x4e,%eax
 515:	00 00                	add    %al,(%rax)
 517:	00 22                	add    %ah,(%rdx)
 519:	4e 00 00             	rex.WRX add %r8b,(%rax)
 51c:	00 00                	add    %al,(%rax)
 51e:	00 00                	add    %al,(%rax)
 520:	9f                   	lahf
 521:	4e 00 00             	rex.WRX add %r8b,(%rax)
 524:	00 00                	add    %al,(%rax)
 526:	00 00                	add    %al,(%rax)
 528:	b4 4e                	mov    $0x4e,%ah
 52a:	00 00                	add    %al,(%rax)
 52c:	00 00                	add    %al,(%rax)
 52e:	00 00                	add    %al,(%rax)
 530:	94                   	xchg   %eax,%esp
 531:	4f 00 00             	rex.WRXB add %r8b,(%r8)
 534:	00 00                	add    %al,(%rax)
 536:	00 00                	add    %al,(%rax)
 538:	a9 4f 00 00 00       	test   $0x4f,%eax
 53d:	00 00                	add    %al,(%rax)
 53f:	00 78 50             	add    %bh,0x50(%rax)
 542:	00 00                	add    %al,(%rax)
  icmp_hdr = data + off;
 544:	00 00                	add    %al,(%rax)
 546:	00 00                	add    %al,(%rax)
 548:	8d 50 00             	lea    0x0(%rax),%edx
 54b:	00 00                	add    %al,(%rax)
 54d:	00 00                	add    %al,(%rax)
 54f:	00 01                	add    %al,(%rcx)
 551:	51                   	push   %rcx
 552:	00 00                	add    %al,(%rax)
 554:	00 00                	add    %al,(%rax)
 556:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 558:	1c 51                	sbb    $0x51,%al
 55a:	00 00                	add    %al,(%rax)
 55c:	00 00                	add    %al,(%rax)
 55e:	00 00                	add    %al,(%rax)
 560:	31 51 00             	xor    %edx,0x0(%rcx)
 563:	00 00                	add    %al,(%rax)
 565:	00 00                	add    %al,(%rax)
 567:	00 d6                	add    %dl,%dh
 569:	51                   	push   %rcx
 56a:	00 00                	add    %al,(%rax)
 56c:	00 00                	add    %al,(%rax)
 56e:	00 00                	add    %al,(%rax)
    return XDP_DROP;
 570:	fb                   	sti
 571:	51                   	push   %rcx
 572:	00 00                	add    %al,(%rax)
 574:	00 00                	add    %al,(%rax)
 576:	00 00                	add    %al,(%rax)
 578:	05 52 00 00 00       	add    $0x52,%eax
 57d:	00 00                	add    %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 57f:	00 1a                	add    %bl,(%rdx)
 581:	52                   	push   %rdx
 582:	00 00                	add    %al,(%rax)
 584:	00 00                	add    %al,(%rax)
 586:	00 00                	add    %al,(%rax)
 588:	d4                   	(bad)
 589:	52                   	push   %rdx
 58a:	00 00                	add    %al,(%rax)
 58c:	00 00                	add    %al,(%rax)
 58e:	00 00                	add    %al,(%rax)
 590:	e8 52 00 00 00       	call   5e7 <balancer_ingress+0x5e7>
    return send_icmp6_reply(data, data_end);
 595:	00 00                	add    %al,(%rax)
 597:	00 40 53             	add    %al,0x53(%rax)
 59a:	00 00                	add    %al,(%rax)
 59c:	00 00                	add    %al,(%rax)
 59e:	00 00                	add    %al,(%rax)
 5a0:	b9 53 00 00 00       	mov    $0x53,%ecx
 5a5:	00 00                	add    %al,(%rax)
 5a7:	00 c3                	add    %al,%bl
 5a9:	53                   	push   %rbx
 5aa:	00 00                	add    %al,(%rax)
 5ac:	00 00                	add    %al,(%rax)
 5ae:	00 00                	add    %al,(%rax)
  __u64 off = 0;
 5b0:	d8 53 00             	fcoms  0x0(%rbx)
 5b3:	00 00                	add    %al,(%rax)
 5b5:	00 00                	add    %al,(%rax)
 5b7:	00 8f 54 00 00 00    	add    %cl,0x54(%rdi)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 5bd:	00 00                	add    %al,(%rax)
 5bf:	00 df                	add    %bl,%bh
 5c1:	54                   	push   %rsp
 5c2:	00 00                	add    %al,(%rax)
 5c4:	00 00                	add    %al,(%rax)
 5c6:	00 00                	add    %al,(%rax)
 5c8:	cb                   	lret
 5c9:	55                   	push   %rbp
 5ca:	00 00                	add    %al,(%rax)
 5cc:	00 00                	add    %al,(%rax)
       sizeof(struct icmp6hdr)) > data_end) {
 5ce:	00 00                	add    %al,(%rax)
 5d0:	82                   	(bad)
 5d1:	57                   	push   %rdi
 5d2:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 5d4:	00 00                	add    %al,(%rax)
    return XDP_DROP;
 5d6:	00 00                	add    %al,(%rax)
 5d8:	9c                   	pushf
 5d9:	57                   	push   %rdi
 5da:	00 00                	add    %al,(%rax)
 5dc:	00 00                	add    %al,(%rax)
 5de:	00 00                	add    %al,(%rax)
 5e0:	22 58 00             	and    0x0(%rax),%bl
 5e3:	00 00                	add    %al,(%rax)
  off += sizeof(struct ethhdr);
 5e5:	00 00                	add    %al,(%rax)
 5e7:	00 37                	add    %dh,(%rdi)
 5e9:	58                   	pop    %rax
 5ea:	00 00                	add    %al,(%rax)
 5ec:	00 00                	add    %al,(%rax)
 5ee:	00 00                	add    %al,(%rax)
 5f0:	fe                   	(bad)
 5f1:	58                   	pop    %rax
 5f2:	00 00                	add    %al,(%rax)
 5f4:	00 00                	add    %al,(%rax)
 5f6:	00 00                	add    %al,(%rax)
  ip6h = data + off;
 5f8:	0a 59 00             	or     0x0(%rcx),%bl
 5fb:	00 00                	add    %al,(%rax)
 5fd:	00 00                	add    %al,(%rax)
 5ff:	00 1f                	add    %bl,(%rdi)
 601:	59                   	pop    %rcx
 602:	00 00                	add    %al,(%rax)
 604:	00 00                	add    %al,(%rax)
 606:	00 00                	add    %al,(%rax)
 608:	cd 59                	int    $0x59
 60a:	00 00                	add    %al,(%rax)
  off += sizeof(struct ipv6hdr);
 60c:	00 00                	add    %al,(%rax)
 60e:	00 00                	add    %al,(%rax)
 610:	4f 5a                	rex.WRXB pop %r10
 612:	00 00                	add    %al,(%rax)
 614:	00 00                	add    %al,(%rax)
 616:	00 00                	add    %al,(%rax)
 618:	59                   	pop    %rcx
 619:	5a                   	pop    %rdx
 61a:	00 00                	add    %al,(%rax)
 61c:	00 00                	add    %al,(%rax)
  icmp_hdr = data + off;
 61e:	00 00                	add    %al,(%rax)
 620:	6e                   	outsb  %ds:(%rsi),(%dx)
 621:	5a                   	pop    %rdx
 622:	00 00                	add    %al,(%rax)
 624:	00 00                	add    %al,(%rax)
 626:	00 00                	add    %al,(%rax)
 628:	4f 5c                	rex.WRXB pop %r12
 62a:	00 00                	add    %al,(%rax)
 62c:	00 00                	add    %al,(%rax)
 62e:	00 00                	add    %al,(%rax)
 630:	64 5c                	fs pop %rsp
 632:	00 00                	add    %al,(%rax)
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
 634:	00 00                	add    %al,(%rax)
 636:	00 00                	add    %al,(%rax)
 638:	bf 5d 00 00 00       	mov    $0x5d,%edi
  icmp_hdr->icmp6_cksum -= 0x0001;
 63d:	00 00                	add    %al,(%rax)
 63f:	00 d4                	add    %dl,%ah
 641:	5d                   	pop    %rbp
 642:	00 00                	add    %al,(%rax)
 644:	00 00                	add    %al,(%rax)
 646:	00 00                	add    %al,(%rax)
 648:	07                   	(bad)
 649:	5f                   	pop    %rdi
 64a:	00 00                	add    %al,(%rax)
 64c:	00 00                	add    %al,(%rax)
 64e:	00 00                	add    %al,(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
 650:	c0 5f 00 00          	rcrb   $0x0,0x0(%rdi)
 654:	00 00                	add    %al,(%rax)
 656:	00 00                	add    %al,(%rax)
 658:	d5                   	(bad)
 659:	5f                   	pop    %rdi
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
 65a:	00 00                	add    %al,(%rax)
 65c:	00 00                	add    %al,(%rax)
 65e:	00 00                	add    %al,(%rax)
 660:	78 60                	js     6c2 <balancer_ingress+0x6c2>
 662:	00 00                	add    %al,(%rax)
 664:	00 00                	add    %al,(%rax)
 666:	00 00                	add    %al,(%rax)
 668:	bf 60 00 00 00       	mov    $0x60,%edi
 66d:	00 00                	add    %al,(%rax)
 66f:	00 c9                	add    %cl,%cl
 671:	60                   	(bad)
 672:	00 00                	add    %al,(%rax)
 674:	00 00                	add    %al,(%rax)
 676:	00 00                	add    %al,(%rax)
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
 678:	de 60 00             	fisubs 0x0(%rax)
 67b:	00 00                	add    %al,(%rax)
 67d:	00 00                	add    %al,(%rax)
 67f:	00 f8                	add    %bh,%al
 681:	61                   	(bad)
 682:	00 00                	add    %al,(%rax)
 684:	00 00                	add    %al,(%rax)
 686:	00 00                	add    %al,(%rax)
 688:	0d 62 00 00 00       	or     $0x62,%eax
 68d:	00 00                	add    %al,(%rax)
 68f:	00 84 62 00 00 00 00 	add    %al,0x0(%rdx,%riz,2)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
 696:	00 00                	add    %al,(%rax)
 698:	ba 62 00 00 00       	mov    $0x62,%edx
 69d:	00 00                	add    %al,(%rax)
 69f:	00 d2                	add    %dl,%dl
 6a1:	62                   	(bad)
 6a2:	00 00                	add    %al,(%rax)
 6a4:	00 00                	add    %al,(%rax)
 6a6:	00 00                	add    %al,(%rax)
 6a8:	e7 62                	out    %eax,$0x62
 6aa:	00 00                	add    %al,(%rax)
 6ac:	00 00                	add    %al,(%rax)
 6ae:	00 00                	add    %al,(%rax)
 6b0:	8c 63 00             	mov    %fs,0x0(%rbx)
  return swap_mac_and_send(data, data_end);
 6b3:	00 00                	add    %al,(%rax)
 6b5:	00 00                	add    %al,(%rax)
 6b7:	00 96 63 00 00 00    	add    %dl,0x63(%rsi)
 6bd:	00 00                	add    %al,(%rax)
 6bf:	00 ab 63 00 00 00    	add    %ch,0x63(%rbx)
 6c5:	00 00                	add    %al,(%rax)
 6c7:	00 a8 64 00 00 00    	add    %ch,0x64(%rax)
 6cd:	00 00                	add    %al,(%rax)
  eth = data;
 6cf:	00 e7                	add    %ah,%bh
 6d1:	64 00 00             	add    %al,%fs:(%rax)
 6d4:	00 00                	add    %al,(%rax)
 6d6:	00 00                	add    %al,(%rax)
 6d8:	f1                   	int1
 6d9:	64 00 00             	add    %al,%fs:(%rax)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 6dc:	00 00                	add    %al,(%rax)
 6de:	00 00                	add    %al,(%rax)
 6e0:	06                   	(bad)
 6e1:	65 00 00             	add    %al,%gs:(%rax)
 6e4:	00 00                	add    %al,(%rax)
 6e6:	00 00                	add    %al,(%rax)
 6e8:	2e 66 00 00          	cs data16 add %al,(%rax)
 6ec:	00 00                	add    %al,(%rax)
 6ee:	00 00                	add    %al,(%rax)
 6f0:	97                   	xchg   %eax,%edi
 6f1:	66 00 00             	data16 add %al,(%rax)
 6f4:	00 00                	add    %al,(%rax)
 6f6:	00 00                	add    %al,(%rax)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 6f8:	26 67 00 00          	es add %al,(%eax)
 6fc:	00 00                	add    %al,(%rax)
 6fe:	00 00                	add    %al,(%rax)
 700:	3b 67 00             	cmp    0x0(%rdi),%esp
 703:	00 00                	add    %al,(%rax)
 705:	00 00                	add    %al,(%rax)
 707:	00 d3                	add    %dl,%bl
 709:	67 00 00             	add    %al,(%eax)
 70c:	00 00                	add    %al,(%rax)
 70e:	00 00                	add    %al,(%rax)
 710:	dd 67 00             	frstor 0x0(%rdi)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 713:	00 00                	add    %al,(%rax)
 715:	00 00                	add    %al,(%rax)
 717:	00 f2                	add    %dh,%dl
 719:	67 00 00             	add    %al,(%eax)
 71c:	00 00                	add    %al,(%rax)
 71e:	00 00                	add    %al,(%rax)
 720:	95                   	xchg   %eax,%ebp
 721:	68 00 00 00 00       	push   $0x0
 726:	00 00                	add    %al,(%rax)
 728:	aa                   	stos   %al,%es:(%rdi)
 729:	68 00 00 00 00       	push   $0x0
  return swap_mac_and_send(data, data_end);
 72e:	00 00                	add    %al,(%rax)
 730:	24 69                	and    $0x69,%al
 732:	00 00                	add    %al,(%rax)
 734:	00 00                	add    %al,(%rax)
}
 736:	00 00                	add    %al,(%rax)
 738:	2e 69 00 00 00 00 00 	cs imul $0x0,(%rax),%eax
    return send_icmp6_reply(data, data_end);
 73f:	00 43 69             	add    %al,0x69(%rbx)
 742:	00 00                	add    %al,(%rax)
 744:	00 00                	add    %al,(%rax)
 746:	00 00                	add    %al,(%rax)
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
 748:	9a                   	(bad)
 749:	6a 00                	push   $0x0
 74b:	00 00                	add    %al,(%rax)
 74d:	00 00                	add    %al,(%rax)
 74f:	00 a4 6a 00 00 00 00 	add    %ah,0x0(%rdx,%rbp,2)
      (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {
 756:	00 00                	add    %al,(%rax)
 758:	b9 6a 00 00 00       	mov    $0x6a,%ecx
 75d:	00 00                	add    %al,(%rax)
 75f:	00 72 6c             	add    %dh,0x6c(%rdx)
 762:	00 00                	add    %al,(%rax)
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
 764:	00 00                	add    %al,(%rax)
    return XDP_PASS;
 766:	00 00                	add    %al,(%rax)
 768:	82                   	(bad)
 769:	6c                   	insb   (%dx),%es:(%rdi)
 76a:	00 00                	add    %al,(%rax)
 76c:	00 00                	add    %al,(%rax)
 76e:	00 00                	add    %al,(%rax)
 770:	97                   	xchg   %eax,%edi
 771:	6c                   	insb   (%dx),%es:(%rdi)
 772:	00 00                	add    %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_PKT_TOOBIG) {
 774:	00 00                	add    %al,(%rax)
 776:	00 00                	add    %al,(%rax)
 778:	58                   	pop    %rax
 779:	6d                   	insl   (%dx),%es:(%rdi)
 77a:	00 00                	add    %al,(%rax)
 77c:	00 00                	add    %al,(%rax)
 77e:	00 00                	add    %al,(%rax)
 780:	6d                   	insl   (%dx),%es:(%rdi)
 781:	6d                   	insl   (%dx),%es:(%rdi)
 782:	00 00                	add    %al,(%rax)
 784:	00 00                	add    %al,(%rax)
 786:	00 00                	add    %al,(%rax)
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
 788:	ec                   	in     (%dx),%al
 789:	6d                   	insl   (%dx),%es:(%rdi)
 78a:	00 00                	add    %al,(%rax)
 78c:	00 00                	add    %al,(%rax)
 78e:	00 00                	add    %al,(%rax)
 790:	01 6e 00             	add    %ebp,0x0(%rsi)
        bpf_map_lookup_elem(&stats, &stats_key);
 793:	00 00                	add    %al,(%rax)
 795:	00 00                	add    %al,(%rax)
 797:	00 a9 6e 00 00 00    	add    %ch,0x6e(%rcx)
 79d:	00 00                	add    %al,(%rax)
 79f:	00 be 6e 00 00 00    	add    %bh,0x6e(%rsi)
 7a5:	00 00                	add    %al,(%rax)
 7a7:	00 df                	add    %bl,%bh
 7a9:	6f                   	outsl  %ds:(%rsi),(%dx)
 7aa:	00 00                	add    %al,(%rax)
 7ac:	00 00                	add    %al,(%rax)
 7ae:	00 00                	add    %al,(%rax)
 7b0:	37                   	(bad)
 7b1:	71 00                	jno    7b3 <balancer_ingress+0x7b3>
 7b3:	00 00                	add    %al,(%rax)
 7b5:	00 00                	add    %al,(%rax)
 7b7:	00 c5                	add    %al,%ch
 7b9:	71 00                	jno    7bb <balancer_ingress+0x7bb>
 7bb:	00 00                	add    %al,(%rax)
 7bd:	00 00                	add    %al,(%rax)
 7bf:	00 6a 72             	add    %ch,0x72(%rdx)
 7c2:	00 00                	add    %al,(%rax)
 7c4:	00 00                	add    %al,(%rax)
 7c6:	00 00                	add    %al,(%rax)
 7c8:	b4 73                	mov    $0x73,%ah
 7ca:	00 00                	add    %al,(%rax)
 7cc:	00 00                	add    %al,(%rax)
 7ce:	00 00                	add    %al,(%rax)
 7d0:	d5                   	(bad)
 7d1:	73 00                	jae    7d3 <balancer_ingress+0x7d3>
 7d3:	00 00                	add    %al,(%rax)
 7d5:	00 00                	add    %al,(%rax)
 7d7:	00 9b 75 00 00 00    	add    %bl,0x75(%rbx)
 7dd:	00 00                	add    %al,(%rax)
 7df:	00 7c 76 00          	add    %bh,0x0(%rsi,%rsi,2)
 7e3:	00 00                	add    %al,(%rax)
 7e5:	00 00                	add    %al,(%rax)
 7e7:	00 84 76 00 00 00 00 	add    %al,0x0(%rsi,%rsi,2)
 7ee:	00 00                	add    %al,(%rax)
 7f0:	c9                   	leave
 7f1:	76 00                	jbe    7f3 <balancer_ingress+0x7f3>
 7f3:	00 00                	add    %al,(%rax)
 7f5:	00 00                	add    %al,(%rax)
 7f7:	00 80 77 00 00 00    	add    %al,0x77(%rax)
 7fd:	00 00                	add    %al,(%rax)
 7ff:	00 40 7b             	add    %al,0x7b(%rax)
 802:	00 00                	add    %al,(%rax)
 804:	00 00                	add    %al,(%rax)
    struct lb_stats* icmp_ptb_v6_stats =
 806:	00 00                	add    %al,(%rax)
 808:	80 7b 00 00          	cmpb   $0x0,0x0(%rbx)
    if (!icmp_ptb_v6_stats) {
 80c:	00 00                	add    %al,(%rax)
 80e:	00 00                	add    %al,(%rax)
 810:	a0                   	.byte 0xa0
 811:	7c 00                	jl     813 <balancer_ingress+0x813>
 813:	00 00                	add    %al,(%rax)
 815:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_line:

0000000000000000 <.debug_line>:
int balancer_ingress(struct xdp_md* ctx) {
       0:	13 36                	adc    (%rsi),%esi
       2:	00 00                	add    %al,(%rax)
       4:	05 00 08 00 19       	add    $0x19000800,%eax
       9:	02 00                	add    (%rax),%al
       b:	00 01                	add    %al,(%rcx)
       d:	01 01                	add    %eax,(%rcx)
       f:	fb                   	sti
      10:	0e                   	(bad)
      11:	0d 00 01 01 01       	or     $0x1010100,%eax
  void* data = (void*)(long)ctx->data;
      16:	01 00                	add    %eax,(%rax)
      18:	00 00                	add    %al,(%rax)
      1a:	01 00                	add    %eax,(%rax)
      1c:	00 01                	add    %al,(%rcx)
      1e:	01 01                	add    %eax,(%rcx)
      20:	1f                   	(bad)
      21:	06                   	(bad)
      22:	00 00                	add    %al,(%rax)
      24:	00 00                	add    %al,(%rax)
      26:	2b 00                	sub    (%rax),%eax
  void* data_end = (void*)(long)ctx->data_end;
      28:	00 00                	add    %al,(%rax)
      2a:	3c 00                	cmp    $0x0,%al
      2c:	00 00                	add    %al,(%rax)
      2e:	55                   	push   %rbp
      2f:	00 00                	add    %al,(%rax)
      31:	00 68 00             	add    %ch,0x0(%rax)
      34:	00 00                	add    %al,(%rax)
      36:	97                   	xchg   %eax,%edi
      37:	00 00                	add    %al,(%rax)
  struct ethhdr* eth = data;
      39:	00 03                	add    %al,(%rbx)
      3b:	01 1f                	add    %ebx,(%rdi)
      3d:	02 0f                	add    (%rdi),%cl
      3f:	05 1e 17 b3 00       	add    $0xb3171e,%eax
      44:	00 00                	add    %al,(%rax)
      46:	00 29                	add    %ch,(%rcx)
  nh_off = sizeof(struct ethhdr);
      48:	b8 64 55 2d 42       	mov    $0x422d5564,%eax
      4d:	48 11 96 a1 56 28 f9 	adc    %rdx,-0x6d7a95f(%rsi)
  if (data + nh_off > data_end) {
      54:	61                   	(bad)
      55:	78 bb                	js     12 <balancer_ingress+0x12>
      57:	d1 00                	roll   (%rax)
      59:	00 00                	add    %al,(%rax)
      5b:	01 5b e9             	add    %ebx,-0x17(%rbx)
      5e:	d1 d0                	rcl    %eax
      60:	ad                   	lods   %ds:(%rsi),%eax
      61:	34 bd                	xor    $0xbd,%al
      63:	71 a1                	jno    6 <balancer_ingress+0x6>
      65:	66 7a 92             	data16 jp fffffffffffffffa <server_id_map+0x36ff0bd83ffa>
      68:	98                   	cwtl
      69:	70 c0                	jo     2b <balancer_ingress+0x2b>
    return XDP_DROP;
      6b:	11 e5                	adc    %esp,%ebp
      6d:	00 00                	add    %al,(%rax)
      6f:	00 02                	add    %al,(%rdx)
      71:	b8 10 f2 70 73       	mov    $0x7370f210,%eax
      76:	3e 10 63 19          	ds adc %ah,0x19(%rbx)
  eth_proto = eth->h_proto;
      7a:	b6 7e                	mov    $0x7e,%dh
      7c:	f5                   	cmc
      7d:	12 c6                	adc    %dh,%al
      7f:	24 6e                	and    $0x6e,%al
      81:	f0 00 00             	lock add %al,(%rax)
      84:	00 01                	add    %al,(%rcx)
      86:	bc 5f e5 9e a4       	mov    $0xa49ee55f,%esp
  if (eth_proto == BE_ETH_P_IP) {
      8b:	ca 18 d4             	lret   $0xd418
      8e:	61                   	(bad)
      8f:	6a 93                	push   $0xffffffffffffff93
      91:	aa                   	stos   %al,%es:(%rdi)
      92:	35 0e 3d 0b 03       	xor    $0x30b3d0e,%eax
    return process_packet(ctx, nh_off, false);
      97:	01 00                	add    %eax,(%rax)
      99:	00 01                	add    %al,(%rcx)
      9b:	b5 26                	mov    $0x26,%ch
      9d:	23 e8                	and    %eax,%ebp
      9f:	bc 42 2f 8a 08       	mov    $0x88a2f42,%esp
      a4:	35 23 90 b1 84       	xor    $0x84b19023,%eax
      a9:	d4                   	(bad)
      aa:	30 13                	xor    %dl,(%rbx)
      ac:	01 00                	add    %eax,(%rax)
      ae:	00 03                	add    %al,(%rbx)
      b0:	c0 ad e1 a1 a3 09 d6 	shrb   $0xd6,0x9a3a1e1(%rbp)
      b7:	89 6c e6 08          	mov    %ebp,0x8(%rsi,%riz,8)
  void* data = (void*)(long)xdp->data;
      bb:	0a 51 a2             	or     -0x5e(%rcx),%dl
      be:	d1 05 1b 01 00 00    	roll   0x11b(%rip)        # 1df <balancer_ingress+0x1df>
      c4:	04 e8                	add    $0xe8,%al
      c6:	8c 04 db             	mov    %es,(%rbx,%rbx,8)
      c9:	28 15 6b 93 cc 8f    	sub    %dl,-0x70336c95(%rip)        # ffffffff8fcc943a <server_id_map+0x36fe9ba4d43a>
  void* data_end = (void*)(long)xdp->data_end;
      cf:	39 e7                	cmp    %esp,%edi
      d1:	46 72 b3             	rex.RX jb 87 <balancer_ingress+0x87>
      d4:	4b 29 01             	rex.WXB sub %rax,(%r9)
      d7:	00 00                	add    %al,(%rax)
      d9:	04 1a                	add    $0x1a,%al
      db:	44 71 1e             	rex.R jno fc <balancer_ingress+0xfc>
  struct real_definition* dst = NULL;
      de:	c9                   	leave
      df:	6a fe                	push   $0xfffffffffffffffe
      e1:	11 5d c1             	adc    %ebx,-0x3f(%rbp)
      e4:	30 dc                	xor    %bl,%ah
      e6:	e0 25                	loopne 10d <balancer_ingress+0x10d>
  struct packet_description pckt = {};
      e8:	7a 60                	jp     14a <balancer_ingress+0x14a>
      ea:	2f                   	(bad)
      eb:	01 00                	add    %eax,(%rax)
      ed:	00 03                	add    %al,(%rbx)
      ef:	fc                   	cld
      f0:	de 28                	fisubrs (%rax)
      f2:	42 9f                	rex.X lahf
      f4:	cb                   	lret
      f5:	e6 6e                	out    %al,$0x6e
      f7:	10 9e 5f e5 b9 9c    	adc    %bl,-0x63461aa1(%rsi)
      fd:	cd 45                	int    $0x45
      ff:	34 01                	xor    $0x1,%al
     101:	00 00                	add    %al,(%rax)
     103:	01 dd                	add    %ebx,%ebp
     105:	5f                   	pop    %rdi
     106:	2d 0c a8 b9 51       	sub    $0x51b9a80c,%eax
     10b:	1e                   	(bad)
     10c:	8f a8 d1 c6          	(bad)
     110:	4e d3 b3 ac 43 01 00 	rex.WRX shlq %cl,0x143ac(%rbx)
     117:	00 05 02 65 bf 5d    	add    %al,0x5dbf6502(%rip)        # 5dbf661f <bpf_xdp_adjust_head+0x5dbee67f>
     11d:	da 79 6c             	fidivrl 0x6c(%rcx)
  struct vip_definition vip = {};
     120:	c0 b0 02 70 b2 7d c7 	shlb   $0xc7,0x7db27002(%rax)
     127:	a1 8e 4b 01 00 00 01 	movabs 0x5c24010000014b8e,%eax
     12e:	24 5c 
     130:	80 12 ea             	adcb   $0xea,(%rdx)
     133:	92                   	xchg   %eax,%edx
     134:	00 48 b4             	add    %cl,-0x4c(%rax)
     137:	e4 bf                	in     $0xbf,%al
     139:	3b 10                	cmp    (%rax),%edx
     13b:	c5 7e 15             	(bad)
  __u32 mac_addr_pos = 0;
     13e:	59                   	pop    %rcx
     13f:	01 00                	add    %eax,(%rax)
     141:	00 01                	add    %al,(%rcx)
     143:	f0 b1 d3             	lock mov $0xd3,%cl
     146:	dc 61 ec             	fsubl  -0x14(%rcx)
  __u64 th_off = 0;
     149:	02 2c e5 2a 49 e7 c4 	add    -0x3b18b6d6(,%riz,8),%ch
     150:	a9 2a d6 68 01       	test   $0x168d62a,%eax
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
     155:	00 00                	add    %al,(%rax)
     157:	01 5a 90             	add    %ebx,-0x70(%rdx)
     15a:	58                   	pop    %rax
     15b:	46 07                	rex.RX (bad)
     15d:	61                   	(bad)
     15e:	27                   	(bad)
     15f:	c3                   	ret
     160:	c1 4a e0 0e          	rorl   $0xe,-0x20(%rdx)
     164:	b0 62                	mov    $0x62,%al
     166:	0c ca                	or     $0xca,%al
     168:	75 01                	jne    16b <balancer_ingress+0x16b>
     16a:	00 00                	add    %al,(%rax)
     16c:	01 8a eb 55 f9 37    	add    %ecx,0x37f955eb(%rdx)
     172:	57                   	push   %rdi
     173:	66 5e                	pop    %si
     175:	31 61 34             	xor    %esp,0x34(%rcx)
     178:	d7                   	xlat   %ds:(%rbx)
     179:	5b                   	pop    %rbx
     17a:	72 4a                	jb     1c6 <balancer_ingress+0x1c6>
     17c:	48 85 01             	test   %rax,(%rcx)
     17f:	00 00                	add    %al,(%rax)
     181:	03 5c 58 d0          	add    -0x30(%rax,%rbx,2),%ebx
     185:	77 e9                	ja     170 <balancer_ingress+0x170>
     187:	10 b6 c2 58 85 5d    	adc    %dh,0x5d8558c2(%rsi)
     18d:	ca 54 d0             	lret   $0xd054
     190:	ec                   	in     (%dx),%al
     191:	22 8a 01 00 00 03    	and    0x3000001(%rdx),%cl
     197:	d2 88 e3 08 e1 42    	rorb   %cl,0x42e108e3(%rax)
     19d:	e5 1c                	in     $0x1c,%eax
     19f:	48 e7 42             	rex.W out %eax,$0x42
     1a2:	2f                   	(bad)
     1a3:	4f bb aa 3f 91 01 00 	rex.WRXB movabs $0xfc03000001913faa,%r11
     1aa:	00 03 fc 
     1ad:	a1 88 9f 02 74 df 06 	movabs 0x496e06df74029f88,%eax
     1b4:	6e 49 
     1b6:	cf                   	iret
     1b7:	4d 8d b8 01 1e 97 01 	lea    0x1971e01(%r8),%r15
     1be:	00 00                	add    %al,(%rax)
     1c0:	03 c5                	add    %ebp,%eax
     1c2:	73 77                	jae    23b <balancer_ingress+0x23b>
  if (is_ipv6) {
     1c4:	4d 0b 3c 9a          	or     (%r10,%rbx,4),%r15
     1c8:	61                   	(bad)
     1c9:	b5 51                	mov    $0x51,%ch
     1cb:	0b e7                	or     %edi,%esp
     1cd:	5a                   	pop    %rdx
     1ce:	6f                   	outsl  %ds:(%rsi),(%dx)
     1cf:	f3 74 a0             	repz je 172 <balancer_ingress+0x172>
    ip6h = data + nh_off;
     1d2:	01 00                	add    %eax,(%rax)
     1d4:	00 03                	add    %al,(%rbx)
     1d6:	16                   	(bad)
     1d7:	3f                   	(bad)
     1d8:	54                   	push   %rsp
     1d9:	fb                   	sti
     1da:	1a f2                	sbb    %dl,%dh
     1dc:	e2 1f                	loop   1fd <balancer_ingress+0x1fd>
     1de:	ea                   	(bad)
     1df:	41 0f 14 eb          	unpcklps %xmm11,%xmm5
     1e3:	18 fa                	sbb    %bh,%dl
    if (ip6h + 1 > data_end) {
     1e5:	76 52                	jbe    239 <balancer_ingress+0x239>
     1e7:	01 00                	add    %eax,(%rax)
     1e9:	00 03                	add    %al,(%rbx)
     1eb:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     1ec:	05 63 28 98 dc       	add    $0xdc982863,%eax
     1f1:	e5 46                	in     $0x46,%eax
     1f3:	63 8b 33 44 62 7d    	movsxd 0x7d624433(%rbx),%ecx
     1f9:	33 4b ab             	xor    -0x55(%rbx),%ecx
      return XDP_DROP;
     1fc:	01 00                	add    %eax,(%rax)
     1fe:	00 03                	add    %al,(%rbx)
     200:	5c                   	pop    %rsp
     201:	57                   	push   %rdi
     202:	70 df                	jo     1e3 <balancer_ingress+0x1e3>
     204:	b5 68                	mov    $0x68,%ch
     206:	97                   	xchg   %eax,%edi
     207:	d0 23                	shlb   (%rbx)
     209:	c1 9c 17 13 f3 42 24 	rcrl   $0xb1,0x2442f313(%rdi,%rdx,1)
     210:	b1 
    iph_len = sizeof(struct ipv6hdr);
     211:	01 00                	add    %eax,(%rax)
     213:	00 03                	add    %al,(%rbx)
     215:	45 bc 38 cb 16 db    	rex.RB mov $0xdb16cb38,%r12d
    *protocol = ip6h->nexthdr;
     21b:	bc 75 84 26 5a       	mov    $0x5a268475,%esp
     220:	fc                   	cld
     221:	29 89 c9 cc 04 00    	sub    %ecx,0x4ccc9(%rcx)
     227:	00 09                	add    %cl,(%rcx)
    pckt->flow.proto = *protocol;
     229:	02 00                	add    (%rax),%al
     22b:	00 00                	add    %al,(%rax)
     22d:	00 00                	add    %al,(%rax)
     22f:	00 00                	add    %al,(%rax)
     231:	00 03                	add    %al,(%rbx)
     233:	b0 08                	mov    $0x8,%al
     235:	01 05 1d 0a 08 59    	add    %eax,0x59080a1d(%rip)        # 59080c58 <bpf_xdp_adjust_head+0x59078cb8>
     23b:	05 22 06 74 05       	add    $0x5740622,%eax
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     240:	09 3c 05 21 06 75 05 	or     %edi,0x5750621(,%rax,1)
     247:	26 06                	es (bad)
     249:	74 05                	je     250 <balancer_ingress+0x250>
     24b:	09 4a 05             	or     %ecx,0x5(%rdx)
     24e:	18 06                	sbb    %al,(%rsi)
     250:	75 05                	jne    257 <balancer_ingress+0x257>
     252:	12 06                	adc    (%rsi),%al
     254:	74 05                	je     25b <balancer_ingress+0x25b>
     256:	0a 06                	or     (%rsi),%al
     258:	77 05                	ja     25f <balancer_ingress+0x25f>
     25a:	07                   	(bad)
     25b:	a0 05 0c 06 74 05 15 	movabs 0x590150574060c05,%al
     262:	90 05 
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     264:	07                   	(bad)
     265:	74 05                	je     26c <balancer_ingress+0x26c>
     267:	05 06 30 05 0f       	add    $0xf053006,%eax
     26c:	e7 05                	out    %eax,$0x5
     26e:	0d 06 ac 05 11       	or     $0x1105ac06,%eax
     273:	06                   	(bad)
     274:	68 05 07 06 74       	push   $0x74060705
     279:	05 1b 06 67 05       	add    $0x567061b,%eax
     27e:	20 06                	and    %al,(%rsi)
     280:	74 05                	je     287 <balancer_ingress+0x287>
     282:	1d 06 03 e8 7c       	sbb    $0x7ce80306,%eax
     287:	08 9e 05 22 06 74    	or     %bl,0x74062205(%rsi)
    *pkt_bytes = bpf_ntohs(ip6h->payload_len);
     28d:	05 09 3c 05 21       	add    $0x21053c09,%eax
     292:	06                   	(bad)
     293:	75 05                	jne    29a <balancer_ingress+0x29a>
     295:	26 06                	es (bad)
     297:	74 05                	je     29e <balancer_ingress+0x29e>
     299:	09 4a 05             	or     %ecx,0x5(%rdx)
     29c:	1b 06                	sbb    (%rsi),%eax
     29e:	76 05                	jbe    2a5 <balancer_ingress+0x2a5>
     2a0:	1d ad 05 19 02       	sbb    $0x21905ad,%eax
     2a5:	38 13                	cmp    %dl,(%rbx)
     2a7:	05 09 03 09 08       	add    $0x8090309,%eax
     2ac:	d6                   	(bad)
     2ad:	a0 05 19 ae 05 36 06 	movabs 0x574063605ae1905,%al
     2b4:	74 05 
    *th_off += nh_off + iph_len;
     2b6:	3c 74                	cmp    $0x74,%al
     2b8:	05 46 74 04 09       	add    $0x9047446,%eax
     2bd:	05 07 06 03 94       	add    $0x94030607,%eax
     2c2:	7e 02                	jle    2c6 <balancer_ingress+0x2c6>
     2c4:	5b                   	pop    %rbx
     2c5:	01 05 0c c9 05 11    	add    %eax,0x1105c90c(%rip)        # 1105cbd7 <bpf_xdp_adjust_head+0x11054c37>
     2cb:	06                   	(bad)
     2cc:	74 05                	je     2d3 <balancer_ingress+0x2d3>
    if (*protocol == IPPROTO_FRAGMENT) {
     2ce:	0a 74 05 09          	or     0x9(%rbp,%rax,1),%dh
     2d2:	06                   	(bad)
     2d3:	75 05                	jne    2da <balancer_ingress+0x2da>
     2d5:	0e                   	(bad)
     2d6:	06                   	(bad)
     2d7:	74 05                	je     2de <balancer_ingress+0x2de>
     2d9:	14 4a                	adc    $0x4a,%al
     2db:	05 12 74 05 09       	add    $0x9057412,%eax
      return XDP_DROP;
     2e0:	3c 05                	cmp    $0x5,%al
     2e2:	07                   	(bad)
     2e3:	06                   	(bad)
     2e4:	2f                   	(bad)
     2e5:	05 0d e7 05 11       	add    $0x1105e70d,%eax
     2ea:	ad                   	lods   %ds:(%rsi),%eax
     2eb:	05 17 06 74 05       	add    $0x5740617,%eax
    } else if (*protocol == IPPROTO_ICMPV6) {
     2f0:	06                   	(bad)
     2f1:	3c 05                	cmp    $0x5,%al
     2f3:	0f 74 05 19 06 2f 05 	pcmpeqb 0x52f0619(%rip),%mm0        # 52f0913 <bpf_xdp_adjust_head+0x52e8973>
     2fa:	18 06                	sbb    %al,(%rsi)
      return FURTHER_PROCESSING;
     2fc:	74 05                	je     303 <balancer_ingress+0x303>
     2fe:	05 2e 05 16 74       	add    $0x7416052e,%eax
     303:	05 12 06 3f 05       	add    $0x53f0612,%eax
     308:	18 06                	sbb    %al,(%rsi)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     30a:	74 05                	je     311 <balancer_ingress+0x311>
     30c:	12 4a 05             	adc    0x5(%rdx),%cl
     30f:	21 3c 05 27 3c 05 11 	and    %edi,0x11053c27(,%rax,1)
     316:	58                   	pop    %rax
     317:	05 05 2e 05 0f       	add    $0xf052e05,%eax
     31c:	74 05                	je     323 <balancer_ingress+0x323>
     31e:	11 06                	adc    %eax,(%rsi)
     320:	3d 05 1f 06 ac       	cmp    $0xac061f05,%eax
     325:	05 31 ac 05 37       	add    $0x3705ac31,%eax
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     32a:	3c 05                	cmp    $0x5,%al
     32c:	1b 3c 05 11 2e 05 05 	sbb    0x5052e11(,%rax,1),%edi
     333:	2e 05 0f 74 05 12    	cs add $0x1205740f,%eax
     339:	06                   	(bad)
     33a:	3e 06                	ds (bad)
     33c:	03 a3 7c 08 74 03    	add    0x374087c(%rbx),%esp
     342:	dd 03                	fldl   (%rbx)
     344:	66 05 06 3c          	add    $0x3c06,%ax
  } else {
     348:	05 10 74 06 3d       	add    $0x3d067410,%eax
    iph = data + nh_off;
     34d:	05 17 06 74 05       	add    $0x5740617,%eax
     352:	06                   	(bad)
     353:	74 05                	je     35a <balancer_ingress+0x35a>
     355:	0d 74 05 0a 06       	or     $0x60a0574,%eax
     35a:	67 05 09 06 74 05    	addr32 add $0x5740609,%eax
    if (iph + 1 > data_end) {
     360:	13 3c 05 09 3c 05 07 	adc    0x7053c09(,%rax,1),%edi
     367:	06                   	(bad)
     368:	30 05 11 e5 05 10    	xor    %al,0x1005e511(%rip)        # 1005e87f <bpf_xdp_adjust_head+0x100568df>
     36e:	06                   	(bad)
     36f:	74 05                	je     376 <balancer_ingress+0x376>
     371:	1a 3c 05 10 3c 05 07 	sbb    0x7053c10(,%rax,1),%bh
      return XDP_DROP;
     378:	06                   	(bad)
     379:	2f                   	(bad)
     37a:	05 0e e6 05 20       	add    $0x2005e60e,%eax
     37f:	06                   	(bad)
     380:	74 05                	je     387 <balancer_ingress+0x387>
     382:	07                   	(bad)
     383:	74 05                	je     38a <balancer_ingress+0x38a>
    if (iph->ihl != 5) {
     385:	0e                   	(bad)
     386:	06                   	(bad)
     387:	e5 05                	in     $0x5,%eax
     389:	20 06                	and    %al,(%rsi)
     38b:	74 05                	je     392 <balancer_ingress+0x392>
     38d:	07                   	(bad)
     38e:	74 05                	je     395 <balancer_ingress+0x395>
     390:	03 06                	add    (%rsi),%eax
     392:	f4                   	hlt
     393:	05 0b 59 05 10       	add    $0x1005590b,%eax
      return XDP_DROP;
     398:	06                   	(bad)
     399:	74 05                	je     3a0 <balancer_ingress+0x3a0>
     39b:	09 74 06 75          	or     %esi,0x75(%rsi,%rax,1)
     39f:	05 0d 06 74 05       	add    $0x574060d,%eax
     3a4:	13 4a 05             	adc    0x5(%rdx),%ecx
    pckt->tos = iph->tos;
     3a7:	11 74 05 09          	adc    %esi,0x9(%rbp,%rax,1)
     3ab:	3c 05                	cmp    $0x5,%al
     3ad:	07                   	(bad)
     3ae:	06                   	(bad)
     3af:	2f                   	(bad)
     3b0:	05 09 e7 05 0e       	add    $0xe05e709,%eax
     3b5:	06                   	(bad)
     3b6:	74 05                	je     3bd <balancer_ingress+0x3bd>
     3b8:	09 4a 05             	or     %ecx,0x5(%rdx)
    *protocol = iph->protocol;
     3bb:	12 3c 05 09 3c 05 07 	adc    0x7053c09(,%rax,1),%bh
     3c2:	06                   	(bad)
     3c3:	31 05 11 e6 05 16    	xor    %eax,0x1605e611(%rip)        # 1605e9da <bpf_xdp_adjust_head+0x16056a3a>
     3c9:	06                   	(bad)
     3ca:	74 05                	je     3d1 <balancer_ingress+0x3d1>
     3cc:	05 3c 05 0f 74       	add    $0x740f053c,%eax
    pckt->flow.proto = *protocol;
     3d1:	05 11 06 3d 05       	add    $0x53d0611,%eax
     3d6:	16                   	(bad)
     3d7:	06                   	(bad)
     3d8:	74 05                	je     3df <balancer_ingress+0x3df>
     3da:	06                   	(bad)
     3db:	3c 05                	cmp    $0x5,%al
     3dd:	0f 74 05 19 06 2f 05 	pcmpeqb 0x52f0619(%rip),%mm0        # 52f09fd <bpf_xdp_adjust_head+0x52e8a5d>
    *pkt_bytes = bpf_ntohs(iph->tot_len);
     3e4:	18 06                	sbb    %al,(%rsi)
     3e6:	74 05                	je     3ed <balancer_ingress+0x3ed>
     3e8:	05 2e 05 16 74       	add    $0x7416052e,%eax
     3ed:	05 12 06 3d 06       	add    $0x63d0612,%eax
     3f2:	03 8a 7c 08 74 03    	add    0x374087c(%rdx),%ecx
     3f8:	f6 03 66             	testb  $0x66,(%rbx)
     3fb:	05 06 3c 05 10       	add    $0x10053c06,%eax
     400:	74 06                	je     408 <balancer_ingress+0x408>
     402:	3d 05 17 06 74       	cmp    $0x74061705,%eax
     407:	05 06 4a 05 0d       	add    $0xd054a06,%eax
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;
     40c:	74 05                	je     413 <balancer_ingress+0x413>
     40e:	09 06                	or     %eax,(%rsi)
     410:	68 05 17 06 ac       	push   $0xffffffffac061705
     415:	05 09 82 05 07       	add    $0x7058209,%eax
     41a:	06                   	(bad)
     41b:	30 05 0a bc 05 09    	xor    %al,0x905bc0a(%rip)        # 905c02b <bpf_xdp_adjust_head+0x905408b>
     421:	06                   	(bad)
     422:	74 05                	je     429 <balancer_ingress+0x429>
    if (iph->frag_off & PCKT_FRAGMENTED) {
     424:	13 3c 05 09 3c 05 07 	adc    0x7053c09(,%rax,1),%edi
     42b:	06                   	(bad)
     42c:	2f                   	(bad)
     42d:	05 18 bc 05 1d       	add    $0x1d05bc18,%eax
     432:	06                   	(bad)
     433:	74 05                	je     43a <balancer_ingress+0x43a>
     435:	07                   	(bad)
     436:	3c 05                	cmp    $0x5,%al
     438:	16                   	(bad)
      return XDP_DROP;
     439:	74 05                	je     440 <balancer_ingress+0x440>
     43b:	18 06                	sbb    %al,(%rsi)
     43d:	2f                   	(bad)
     43e:	05 1d 06 74 05       	add    $0x574061d,%eax
     443:	07                   	(bad)
     444:	3c 05                	cmp    $0x5,%al
    if (*protocol == IPPROTO_ICMP) {
     446:	16                   	(bad)
     447:	74 05                	je     44e <balancer_ingress+0x44e>
     449:	03 06                	add    (%rsi),%eax
     44b:	3f                   	(bad)
     44c:	05 01 9f 04 00       	add    $0x49f01,%eax
     451:	05 0a 03 b5 01       	add    $0x1b5030a,%eax
      return FURTHER_PROCESSING;
     456:	66 05 0e 68          	add    $0x680e,%ax
     45a:	05 07 06 74 05       	add    $0x5740607,%eax
     45f:	0c 06                	or     $0x6,%al
      pckt->flow.src = iph->saddr;
     461:	2f                   	(bad)
     462:	05 05 06 66 05       	add    $0x5660605,%eax
     467:	1b 06                	sbb    (%rsi),%eax
     469:	ae                   	scas   %es:(%rdi),%al
     46a:	05 21 06 74 05       	add    $0x5740621,%eax
     46f:	2b 74 05 3a          	sub    0x3a(%rbp,%rax,1),%esi
      pckt->flow.dst = iph->daddr;
     473:	74 04                	je     479 <balancer_ingress+0x479>
     475:	0b 05 07 06 03 9a    	or     -0x65fcf9f9(%rip),%eax        # ffffffff9a030a82 <server_id_map+0x36fea5db4a82>
     47b:	7d 02                	jge    47f <balancer_ingress+0x47f>
     47d:	2f                   	(bad)
     47e:	01 05 10 06 74 05    	add    %eax,0x5740610(%rip)        # 5740a94 <bpf_xdp_adjust_head+0x5738af4>
     484:	07                   	(bad)
     485:	3c 05                	cmp    $0x5,%al
  return FURTHER_PROCESSING;
     487:	19 06                	sbb    %eax,(%rsi)
     489:	67 05 1f 06 74 05    	addr32 add $0x574061f,%eax
     48f:	29 74 05 2e          	sub    %esi,0x2e(%rbp,%rax,1)
}
     493:	74 05                	je     49a <balancer_ingress+0x49a>
     495:	0e                   	(bad)
     496:	06                   	(bad)
  action = parse_l3_headers(
     497:	03 91 7f 02 23 01    	add    0x123027f(%rcx),%edx
  if (action >= 0) {
     49d:	05 13 06 74 05       	add    $0x5740613,%eax
     4a2:	0c 74                	or     $0x74,%al
     4a4:	05 07 06 75 05       	add    $0x5750607,%eax
    return action;
     4a9:	10 06                	adc    %al,(%rsi)
     4ab:	74 05                	je     4b2 <balancer_ingress+0x4b2>
     4ad:	16                   	(bad)
     4ae:	4a 05 14 74 05 07    	rex.WX add $0x7057414,%rax
     4b4:	3c 05                	cmp    $0x5,%al
     4b6:	05 06 2f 05 07       	add    $0x7052f06,%eax
  action = handle_if_icmp(data, data_end, th_off, &pckt, protocol);
     4bb:	e6 05                	out    %al,$0x5
     4bd:	1c 06                	sbb    $0x6,%al
     4bf:	9e                   	sahf
     4c0:	05 07 58 05 1d       	add    $0x1d055807,%eax
     4c5:	06                   	(bad)
     4c6:	67 05 23 06 74 05    	addr32 add $0x5740623,%eax
     4cc:	09 06                	or     %eax,(%rsi)
     4ce:	03 f4                	add    %esp,%esi
     4d0:	7e 08                	jle    4da <balancer_ingress+0x4da>
     4d2:	4a 05 08 ad 05 0d    	rex.WX add $0xd05ad08,%rax
     4d8:	06                   	(bad)
     4d9:	74 05                	je     4e0 <balancer_ingress+0x4e0>
     4db:	25 4a 05 3e 4a       	and    $0x4a3e054a,%eax
     4e0:	05 21 06 4b 05       	add    $0x54b0621,%eax
     4e5:	07                   	(bad)
     4e6:	73 05                	jae    4ed <balancer_ingress+0x4ed>
     4e8:	05 30 05 07 e6       	add    $0xe6070530,%eax
     4ed:	05 0a 08 21 05       	add    $0x521080a,%eax
     4f2:	0f 06                	clts
     4f4:	74 05                	je     4fb <balancer_ingress+0x4fb>
     4f6:	08 74 05 07          	or     %dh,0x7(%rbp,%rax,1)
     4fa:	06                   	(bad)
  if (protocol == IPPROTO_ICMPV6) {
     4fb:	75 05                	jne    502 <balancer_ingress+0x502>
     4fd:	0e                   	(bad)
     4fe:	08 21                	or     %ah,(%rcx)
     500:	05 13 06 74 05       	add    $0x5740613,%eax
     505:	0c 74                	or     $0x74,%al
     507:	05 03 06 75 05       	add    $0x5750603,%eax
    return parse_icmpv6(data, data_end, off, pckt);
     50c:	18 06                	sbb    %al,(%rsi)
     50e:	74 05                	je     515 <balancer_ingress+0x515>
     510:	03 06                	add    (%rsi),%eax
     512:	40 05 19 06 74 05    	rex add $0x5740619,%eax
     518:	03 06                	add    (%rsi),%eax
     51a:	ad                   	lods   %ds:(%rsi),%eax
     51b:	05 13 06 74 05       	add    $0x5740613,%eax
     520:	14 06                	adc    $0x6,%al
     522:	4b 05 03 06 74 05    	rex.WXB add $0x5740603,%rax
     528:	0a 06                	or     (%rsi),%al
     52a:	08 59 05             	or     %bl,0x5(%rcx)
     52d:	21 06                	and    %eax,(%rsi)
     52f:	74 05                	je     536 <balancer_ingress+0x536>
     531:	03 74 05 0a          	add    0xa(%rbp,%rax,1),%esi
     535:	06                   	(bad)
     536:	f3 05 03 06 74 05    	repz add $0x5740603,%eax
     53c:	1c 06                	sbb    $0x6,%al
     53e:	08 59 05             	or     %bl,0x5(%rcx)
     541:	22 06                	and    (%rsi),%al
  icmp_hdr = data + off;
     543:	74 05                	je     54a <balancer_ingress+0x54a>
     545:	09 06                	or     %eax,(%rsi)
     547:	03 b7 7f 08 4a 05    	add    0x54a087f(%rdi),%esi
     54d:	07                   	(bad)
     54e:	06                   	(bad)
     54f:	74 05                	je     556 <balancer_ingress+0x556>
     551:	13 06                	adc    (%rsi),%eax
     553:	75 05                	jne    55a <balancer_ingress+0x55a>
     555:	03 06                	add    (%rsi),%eax
     557:	74 05                	je     55e <balancer_ingress+0x55e>
  if (icmp_hdr + 1 > data_end) {
     559:	0a 06                	or     (%rsi),%al
     55b:	08 3d 05 19 06 74    	or     %bh,0x74061905(%rip)        # 74061e66 <bpf_xdp_adjust_head+0x74059ec6>
     561:	05 03 74 05 0a       	add    $0xa057403,%eax
     566:	06                   	(bad)
     567:	c9                   	leave
     568:	05 03 06 74 06       	add    $0x6740603,%eax
     56d:	03 c6                	add    %esi,%eax
    return XDP_DROP;
     56f:	00 08                	add    %cl,(%rax)
     571:	2e 05 01 9f 05 05    	cs add $0x5059f01,%eax
     577:	03 f9                	add    %ecx,%edi
     579:	00 66 05             	add    %ah,0x5(%rsi)
     57c:	08 ae 05 1d 06 9e    	or     %ch,-0x61f9e2fb(%rsi)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     582:	05 33 3c 05 08       	add    $0x8053c33,%eax
     587:	06                   	(bad)
     588:	2f                   	(bad)
     589:	05 1d 06 9e 05       	add    $0x59e061d,%eax
     58e:	07                   	(bad)
     58f:	06                   	(bad)
     590:	3b 05 05 30 05 07    	cmp    0x7053005(%rip),%eax        # 705359b <bpf_xdp_adjust_head+0x704b5fb>
    return send_icmp6_reply(data, data_end);
     596:	e7 05                	out    %eax,$0x5
     598:	1c 06                	sbb    $0x6,%al
     59a:	9e                   	sahf
     59b:	05 07 3c 05 0b       	add    $0xb053c07,%eax
     5a0:	06                   	(bad)
     5a1:	67 05 09 a0 06 ac    	addr32 add $0xac06a009,%eax
     5a7:	9e                   	sahf
     5a8:	08 e4                	or     %ah,%ah
     5aa:	74 2e                	je     5da <balancer_ingress+0x5da>
     5ac:	08 f2                	or     %dh,%dl
     5ae:	74 74                	je     624 <balancer_ingress+0x624>
  __u64 off = 0;
     5b0:	05 16 06 73 05       	add    $0x5730616,%eax
     5b5:	0a 76 05             	or     0x5(%rsi),%dh
     5b8:	09 06                	or     %eax,(%rsi)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     5ba:	82                   	(bad)
     5bb:	05 07 06 2f 05       	add    $0x52f0607,%eax
     5c0:	05 e6 05 1b 06       	add    $0x61b05e6,%eax
     5c5:	74 05                	je     5cc <balancer_ingress+0x5cc>
     5c7:	11 06                	adc    %eax,(%rsi)
     5c9:	9f                   	lahf
     5ca:	06                   	(bad)
     5cb:	03 81 7e 08 20 05    	add    0x520087e(%rcx),%eax
       sizeof(struct icmp6hdr)) > data_end) {
     5d1:	0b 03                	or     (%rbx),%eax
     5d3:	ff 01                	incl   (%rcx)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     5d5:	66 05 0d 06          	add    $0x60d,%ax
    return XDP_DROP;
     5d9:	67 05 09 06 9e 05    	addr32 add $0x59e0609,%eax
     5df:	07                   	(bad)
     5e0:	06                   	(bad)
     5e1:	2f                   	(bad)
     5e2:	05 1d 06 74 05       	add    $0x574061d,%eax
  off += sizeof(struct ethhdr);
     5e7:	03 06                	add    (%rsi),%eax
     5e9:	bc 05 07 30 05       	mov    $0x5300705,%esp
     5ee:	0a 08                	or     (%rax),%cl
     5f0:	23 05 0f 06 74 05    	and    0x574060f(%rip),%eax        # 5740c05 <bpf_xdp_adjust_head+0x5738c65>
     5f6:	08 74 05 07          	or     %dh,0x7(%rbp,%rax,1)
  ip6h = data + off;
     5fa:	06                   	(bad)
     5fb:	75 05                	jne    602 <balancer_ingress+0x602>
     5fd:	0c 06                	or     $0x6,%al
     5ff:	74 05                	je     606 <balancer_ingress+0x606>
     601:	12 4a 05             	adc    0x5(%rdx),%cl
     604:	10 74 05 07          	adc    %dh,0x7(%rbp,%rax,1)
     608:	3c 05                	cmp    $0x5,%al
     60a:	05 06 2f 05 16       	add    $0x16052f06,%eax
  off += sizeof(struct ipv6hdr);
     60f:	bc 05 1c 06 74       	mov    $0x74061c05,%esp
     614:	05 03 3c 05 14       	add    $0x14053c03,%eax
     619:	74 05                	je     620 <balancer_ingress+0x620>
     61b:	03 06                	add    (%rsi),%eax
     61d:	3d 05 0f 06 74       	cmp    $0x74060f05,%eax
  icmp_hdr = data + off;
     622:	05 0a 06 9f 05       	add    $0x59f060a,%eax
     627:	1c 06                	sbb    $0x6,%al
     629:	74 05                	je     630 <balancer_ingress+0x630>
     62b:	03 74 05 0a          	add    0xa(%rbp,%rax,1),%esi
     62f:	06                   	(bad)
     630:	e5 05                	in     $0x5,%eax
     632:	1c 06                	sbb    $0x6,%al
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
     634:	74 05                	je     63b <balancer_ingress+0x63b>
     636:	03 74 06 f3          	add    -0xd(%rsi,%rax,1),%esi
     63a:	05 01 9f 05 05       	add    $0x5059f01,%eax
  icmp_hdr->icmp6_cksum -= 0x0001;
     63f:	03 c9                	add    %ecx,%ecx
     641:	00 66 05             	add    %ah,0x5(%rsi)
     644:	0e                   	(bad)
     645:	ad                   	lods   %ds:(%rsi),%eax
     646:	05 17 06 74 05       	add    $0x5740617,%eax
     64b:	0e                   	(bad)
     64c:	3c 05                	cmp    $0x5,%al
     64e:	17                   	(bad)
  ip6h->hop_limit = DEFAULT_TTL;
     64f:	06                   	(bad)
     650:	67 05 1d 06 74 05    	addr32 add $0x574061d,%eax
     656:	27                   	(bad)
     657:	74 05                	je     65e <balancer_ingress+0x65e>
     659:	2c 74                	sub    $0x74,%al
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
     65b:	05 0e 06 03 be       	add    $0xbe03060e,%eax
     660:	7f 02                	jg     664 <balancer_ingress+0x664>
     662:	23 01                	and    (%rcx),%eax
     664:	05 13 06 74 05       	add    $0x5740613,%eax
     669:	0c 74                	or     $0x74,%al
     66b:	05 07 06 75 05       	add    $0x5750607,%eax
     670:	10 06                	adc    %al,(%rsi)
     672:	74 05                	je     679 <balancer_ingress+0x679>
     674:	16                   	(bad)
     675:	4a 05 14 74 05 07    	rex.WX add $0x7057414,%rax
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
     67b:	3c 05                	cmp    $0x5,%al
     67d:	05 06 2f 05 07       	add    $0x7052f06,%eax
     682:	e6 05                	out    %al,$0x5
     684:	16                   	(bad)
     685:	06                   	(bad)
     686:	9e                   	sahf
     687:	05 07 3c 05 1c       	add    $0x1c053c07,%eax
     68c:	06                   	(bad)
     68d:	67 05 22 06 74 05    	addr32 add $0x5740622,%eax
     693:	09 06                	or     %eax,(%rsi)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
     695:	03 a4 7e 08 4a 9f ad 	add    -0x5260b5f8(%rsi,%rdi,2),%esp
     69c:	05 08 ae 05 0d       	add    $0xd05ae08,%eax
     6a1:	06                   	(bad)
     6a2:	74 05                	je     6a9 <balancer_ingress+0x6a9>
     6a4:	25 4a 05 3c 4a       	and    $0x4a3c054a,%eax
     6a9:	05 20 06 4b 05       	add    $0x54b0620,%eax
     6ae:	07                   	(bad)
     6af:	73 05                	jae    6b6 <balancer_ingress+0x6b6>
     6b1:	05 30 05 07 e6       	add    $0xe6070530,%eax
  return swap_mac_and_send(data, data_end);
     6b6:	05 09 08 21 05       	add    $0x5210809,%eax
     6bb:	0e                   	(bad)
     6bc:	06                   	(bad)
     6bd:	74 05                	je     6c4 <balancer_ingress+0x6c4>
     6bf:	07                   	(bad)
     6c0:	74 06                	je     6c8 <balancer_ingress+0x6c8>
     6c2:	75 05                	jne    6c9 <balancer_ingress+0x6c9>
     6c4:	0e                   	(bad)
     6c5:	08 21                	or     %ah,(%rcx)
     6c7:	05 13 06 74 05       	add    $0x5740613,%eax
     6cc:	0c 74                	or     $0x74,%al
  eth = data;
     6ce:	05 03 06 75 05       	add    $0x5750603,%eax
     6d3:	12 06                	adc    (%rsi),%al
     6d5:	74 05                	je     6dc <balancer_ingress+0x6dc>
     6d7:	03 06                	add    (%rsi),%eax
     6d9:	40 05 16 06 74 05    	rex add $0x5740616,%eax
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     6df:	03 06                	add    (%rsi),%eax
     6e1:	ad                   	lods   %ds:(%rsi),%eax
     6e2:	05 0c 06 74 05       	add    $0x574060c,%eax
     6e7:	0e                   	(bad)
     6e8:	06                   	(bad)
     6e9:	4b 05 13 06 74 05    	rex.WXB add $0x5740613,%rax
     6ef:	0c 3c                	or     $0x3c,%al
     6f1:	05 10 06 67 05       	add    $0x5670610,%eax
     6f6:	15 06 74 05 03       	adc    $0x3057406,%eax
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     6fb:	3c 05                	cmp    $0x5,%al
     6fd:	0e                   	(bad)
     6fe:	74 05                	je     705 <balancer_ingress+0x705>
     700:	10 06                	adc    %al,(%rsi)
     702:	3d 05 03 06 66       	cmp    $0x66060305,%eax
     707:	05 0e 74 05 03       	add    $0x305740e,%eax
     70c:	06                   	(bad)
     70d:	3d 05 0e 06 74       	cmp    $0x74060e05,%eax
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     712:	05 14 06 67 04       	add    $0x4670614,%eax
     717:	0c 05                	or     $0x5,%al
     719:	21 03                	and    %eax,(%rbx)
     71b:	5c                   	pop    %rsp
     71c:	08 ac 05 0a 06 74 05 	or     %ch,0x574060a(%rbp,%rax,1)
     723:	0c 06                	or     $0x6,%al
     725:	76 05                	jbe    72c <balancer_ingress+0x72c>
     727:	13 06                	adc    (%rsi),%eax
     729:	9e                   	sahf
     72a:	05 15 74 05 03       	add    $0x3057415,%eax
  return swap_mac_and_send(data, data_end);
     72f:	4a 05 1b 06 2f 05    	rex.WX add $0x52f061b,%rax
     735:	0e                   	(bad)
}
     736:	06                   	(bad)
     737:	08 4a 05             	or     %cl,0x5(%rdx)
     73a:	06                   	(bad)
     73b:	58                   	pop    %rax
    return send_icmp6_reply(data, data_end);
     73c:	05 0b 74 05 33       	add    $0x3305740b,%eax
     741:	06                   	(bad)
     742:	65 05 03 06 e4 05    	gs add $0x5e40603,%eax
  if ((icmp_hdr->icmp6_type != ICMPV6_PKT_TOOBIG) &&
     748:	1d 06 31 05 1c       	sbb    $0x1c053106,%eax
     74d:	06                   	(bad)
     74e:	74 05                	je     755 <balancer_ingress+0x755>
     750:	0a 06                	or     (%rsi),%al
     752:	03 67 9e             	add    -0x62(%rdi),%esp
     755:	05 11 06 9e 05       	add    $0x59e0611,%eax
      (icmp_hdr->icmp6_type != ICMPV6_DEST_UNREACH)) {
     75a:	03 74 05 09          	add    0x9(%rbp,%rax,1),%esi
     75e:	06                   	(bad)
     75f:	2f                   	(bad)
     760:	05 0e 06 74 05       	add    $0x574060e,%eax
    return XDP_PASS;
     765:	09 82 05 0f 06 2f    	or     %eax,0x2f060f05(%rdx)
     76b:	05 14 06 74 05       	add    $0x5740614,%eax
     770:	21 66 05             	and    %esp,0x5(%rsi)
     773:	26 74 05             	es je  77b <balancer_ingress+0x77b>
  if (icmp_hdr->icmp6_type == ICMPV6_PKT_TOOBIG) {
     776:	1e                   	(bad)
     777:	4a 05 0c 3c 05 17    	rex.WX add $0x17053c0c,%rax
     77d:	06                   	(bad)
     77e:	72 05                	jb     785 <balancer_ingress+0x785>
     780:	03 06                	add    (%rsi),%eax
     782:	e4 05                	in     $0x5,%al
     784:	0b 06                	or     (%rsi),%eax
     786:	32 05 0a 06 74 05    	xor    0x574060a(%rip),%al        # 5740d96 <bpf_xdp_adjust_head+0x5738df6>
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
     78c:	0b 06                	or     (%rsi),%eax
     78e:	03 15 4a 05 04 06    	add    0x604054a(%rip),%edx        # 6040cde <bpf_xdp_adjust_head+0x6038d3e>
        bpf_map_lookup_elem(&stats, &stats_key);
     794:	58                   	pop    %rax
     795:	05 09 74 04 0b       	add    $0xb047409,%eax
     79a:	05 10 06 03 20       	add    $0x20030610,%eax
     79f:	3c 05                	cmp    $0x5,%al
     7a1:	03 06                	add    (%rsi),%eax
     7a3:	9e                   	sahf
     7a4:	05 0e 74 05 1c       	add    $0x1c05740e,%eax
     7a9:	06                   	(bad)
     7aa:	4b 05 22 06 74 05    	rex.WXB add $0x5740622,%rax
     7b0:	09 06                	or     %eax,(%rsi)
     7b2:	03 52 08             	add    0x8(%rdx),%edx
     7b5:	4a 05 07 06 74 05    	rex.WX add $0x5740607,%rax
     7bb:	13 06                	adc    (%rsi),%eax
     7bd:	75 05                	jne    7c4 <balancer_ingress+0x7c4>
     7bf:	03 06                	add    (%rsi),%eax
     7c1:	74 05                	je     7c8 <balancer_ingress+0x7c8>
     7c3:	0a 06                	or     (%rsi),%al
     7c5:	08 3d 05 19 06 74    	or     %bh,0x74061905(%rip)        # 740620d0 <bpf_xdp_adjust_head+0x7405a130>
     7cb:	05 03 74 05 0a       	add    $0xa057403,%eax
     7d0:	06                   	(bad)
     7d1:	c9                   	leave
     7d2:	05 03 06 74 06       	add    $0x6740603,%eax
     7d7:	03 2b                	add    (%rbx),%ebp
     7d9:	08 2e                	or     %ch,(%rsi)
     7db:	05 01 9f 05 05       	add    $0x5059f01,%eax
     7e0:	03 c3                	add    %ebx,%eax
     7e2:	01 66 05             	add    %esp,0x5(%rsi)
     7e5:	07                   	(bad)
     7e6:	ae                   	scas   %es:(%rdi),%al
     7e7:	05 16 06 9e 05       	add    $0x59e0616,%eax
     7ec:	07                   	(bad)
     7ed:	3c 05                	cmp    $0x5,%al
     7ef:	05 06 2f 05 07       	add    $0x7052f06,%eax
     7f4:	e7 05                	out    %eax,$0x5
     7f6:	16                   	(bad)
     7f7:	06                   	(bad)
     7f8:	ac                   	lods   %ds:(%rsi),%al
     7f9:	05 07 3c 05 0b       	add    $0xb053c07,%eax
     7fe:	06                   	(bad)
     7ff:	67 05 09 a0 06 ac    	addr32 add $0xac06a009,%eax
    struct lb_stats* icmp_ptb_v6_stats =
     805:	9e                   	sahf
     806:	08 e4                	or     %ah,%ah
     808:	74 2e                	je     838 <balancer_ingress+0x838>
     80a:	08 f2                	or     %dh,%dl
    if (!icmp_ptb_v6_stats) {
     80c:	74 74                	je     882 <balancer_ingress+0x882>
     80e:	05 16 06 73 05       	add    $0x5730616,%eax
     813:	0a 76 05             	or     0x5(%rsi),%dh
      return XDP_DROP;
     816:	09 06                	or     %eax,(%rsi)
     818:	82                   	(bad)
     819:	05 07 06 2f 05       	add    $0x52f0607,%eax
     81e:	05 e6 05 1b 06       	add    $0x61b05e6,%eax
     823:	74 05                	je     82a <balancer_ingress+0x82a>
    icmp_ptb_v6_stats->v1 += 1;
     825:	11 06                	adc    %eax,(%rsi)
     827:	9f                   	lahf
     828:	06                   	(bad)
     829:	03 d3                	add    %ebx,%edx
     82b:	7d 08                	jge    835 <balancer_ingress+0x835>
     82d:	74 05                	je     834 <balancer_ingress+0x834>
     82f:	0b 03                	or     (%rbx),%eax
     831:	ad                   	lods   %ds:(%rsi),%eax
     832:	02 66 05             	add    0x5(%rsi),%ah
     835:	09 06                	or     %eax,(%rsi)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     837:	75 05                	jne    83e <balancer_ingress+0x83e>
     839:	0d 06 74 05 09       	or     $0x9057406,%eax
     83e:	58                   	pop    %rax
     83f:	05 07 06 2f 05       	add    $0x52f0607,%eax
     844:	1d 06 74 05 03       	sbb    $0x3057406,%eax
     849:	06                   	(bad)
     84a:	bc 05 07 30 05       	mov    $0x5300705,%esp
     84f:	09 08                	or     %ecx,(%rax)
     851:	21 05 0e 06 74 05    	and    %eax,0x574060e(%rip)        # 5740e65 <bpf_xdp_adjust_head+0x5738ec5>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     857:	07                   	(bad)
     858:	74 06                	je     860 <balancer_ingress+0x860>
     85a:	75 05                	jne    861 <balancer_ingress+0x861>
     85c:	0b 06                	or     (%rsi),%eax
     85e:	74 05                	je     865 <balancer_ingress+0x865>
      icmp_ptb_v6_stats->v2 += 1;
     860:	11 4a 05             	adc    %ecx,0x5(%rdx)
     863:	0f 74 05 07 3c 05 05 	pcmpeqb 0x5053c07(%rip),%mm0        # 5054471 <bpf_xdp_adjust_head+0x504c4d1>
     86a:	06                   	(bad)
     86b:	2f                   	(bad)
     86c:	05 07 bc 05 0c       	add    $0xc05bc07,%eax
     871:	06                   	(bad)
     872:	74 05                	je     879 <balancer_ingress+0x879>
  }
     874:	07                   	(bad)
  off += sizeof(struct icmp6hdr);
     875:	4a 05 10 3c 05 07    	rex.WX add $0x7053c10,%rax
     87b:	3c 05                	cmp    $0x5,%al
     87d:	05 06 2f 05 16       	add    $0x16052f06,%eax
     882:	bc 05 1b 06 74       	mov    $0x74061b05,%esp
  ip6h = data + off;
     887:	05 03 3c 05 14       	add    $0x14053c03,%eax
     88c:	74 05                	je     893 <balancer_ingress+0x893>
     88e:	03 06                	add    (%rsi),%eax
     890:	3d 05 0f 06 74       	cmp    $0x74060f05,%eax
     895:	05 14 06 9f 05       	add    $0x59f0614,%eax
     89a:	19 06                	sbb    %eax,(%rsi)
  if (ip6h + 1 > data_end) {
     89c:	74 05                	je     8a3 <balancer_ingress+0x8a3>
     89e:	03 3c 05 12 74 05 14 	add    0x14057412(,%rax,1),%edi
     8a5:	06                   	(bad)
     8a6:	2f                   	(bad)
     8a7:	05 19 06 74 05       	add    $0x5740619,%eax
     8ac:	03 3c 05 12 74 05 03 	add    0x3057412(,%rax,1),%edi
    return XDP_DROP;
     8b3:	06                   	(bad)
     8b4:	3d 05 01 9f 05       	cmp    $0x59f0105,%eax
     8b9:	05 03 1c 66 84       	add    $0x84661c03,%eax
     8be:	05 01 a0 04 00       	add    $0x4a001,%eax
  pckt->flow.proto = ip6h->nexthdr;
     8c3:	05 0a 03 df 02       	add    $0x2df030a,%eax
     8c8:	66 05 0e 67          	add    $0x670e,%ax
     8cc:	05 07 06 74 05       	add    $0x5740607,%eax
     8d1:	0c 06                	or     $0x6,%al
  pckt->flags |= F_ICMP;
     8d3:	2f                   	(bad)
     8d4:	05 05 06 66 05       	add    $0x5660605,%eax
     8d9:	18 06                	sbb    %al,(%rsi)
     8db:	ae                   	scas   %es:(%rdi),%al
     8dc:	05 0c 06 66 05       	add    $0x566060c,%eax
     8e1:	07                   	(bad)
     8e2:	06                   	(bad)
     8e3:	03 2f                	add    (%rdi),%ebp
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     8e5:	66 05 10 06          	add    $0x610,%ax
     8e9:	74 05                	je     8f0 <balancer_ingress+0x8f0>
     8eb:	07                   	(bad)
     8ec:	3c 05                	cmp    $0x5,%al
     8ee:	14 06                	adc    $0x6,%al
     8f0:	67 05 1a 06 74 05    	addr32 add $0x574061a,%eax
     8f6:	24 74                	and    $0x74,%al
     8f8:	04 09                	add    $0x9,%al
     8fa:	05 15 06 03 87       	add    $0x87030615,%eax
     8ff:	7b 02                	jnp    903 <balancer_ingress+0x903>
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     901:	2a 01                	sub    (%rcx),%al
     903:	05 21 06 ac 05       	add    $0x5ac0621,%eax
     908:	2b 3c 05 12 66 05 08 	sub    0x8056612(,%rax,1),%edi
     90f:	2e 05 1b 06 83 05    	cs add $0x583061b,%eax
     915:	24 06                	and    $0x6,%al
     917:	66 05 09 06          	add    $0x609,%ax
     91b:	03 51 08             	add    0x8(%rcx),%edx
     91e:	66 05 07 ad          	add    $0xad07,%ax
  return FURTHER_PROCESSING;
     922:	05 09 91 08 21       	add    $0x21089109,%eax
     927:	05 0b 91 05 03       	add    $0x305910b,%eax
}
     92c:	08 22                	or     %ah,(%rdx)
     92e:	05 09 2f 08 21       	add    $0x21082f09,%eax
    return parse_icmpv6(data, data_end, off, pckt);
     933:	05 0b 91 06 03       	add    $0x306910b,%eax
     938:	ab                   	stos   %eax,%es:(%rdi)
     939:	7f 08                	jg     943 <balancer_ingress+0x943>
  } else if (protocol == IPPROTO_ICMP) {
     93b:	20 05 0a 06 03 d8    	and    %al,-0x27fcf9f6(%rip)        # ffffffffd8030f4b <server_id_map+0x36fee3db4f4b>
     941:	00 2e                	add    %ch,(%rsi)
     943:	05 09 03 23 74       	add    $0x74230309,%eax
     948:	76 05                	jbe    94f <balancer_ingress+0x94f>
    return parse_icmp(data, data_end, off, pckt);
     94a:	0e                   	(bad)
     94b:	06                   	(bad)
     94c:	74 05                	je     953 <balancer_ingress+0x953>
     94e:	07                   	(bad)
     94f:	74 06                	je     957 <balancer_ingress+0x957>
     951:	76 05                	jbe    958 <balancer_ingress+0x958>
     953:	0b 06                	or     (%rsi),%eax
     955:	74 05                	je     95c <balancer_ingress+0x95c>
     957:	11 4a 05             	adc    %ecx,0x5(%rdx)
     95a:	0f 74 05 07 3c 05 05 	pcmpeqb 0x5053c07(%rip),%mm0        # 5054568 <bpf_xdp_adjust_head+0x504c5c8>
     961:	06                   	(bad)
     962:	2f                   	(bad)
     963:	05 07 bd 05 0c       	add    $0xc05bd07,%eax
     968:	06                   	(bad)
     969:	74 05                	je     970 <balancer_ingress+0x970>
     96b:	07                   	(bad)
     96c:	ba 4a 05 05 06       	mov    $0x605054a,%edx
     971:	2f                   	(bad)
     972:	05 11 06 74 05       	add    $0x5740611,%eax
     977:	07                   	(bad)
     978:	06                   	(bad)
     979:	a1 05 1c 91 05 21 06 	movabs 0x574062105911c05,%eax
     980:	74 05 
  icmp_hdr = data + off;
     982:	05 3c 05 1a 74       	add    $0x741a053c,%eax
     987:	05 1c 06 4b 05       	add    $0x54b061c,%eax
     98c:	21 06                	and    %eax,(%rsi)
     98e:	74 05                	je     995 <balancer_ingress+0x995>
     990:	05 4a 05 1a 74       	add    $0x741a054a,%eax
     995:	05 03 06 4b 05       	add    $0x54b0603,%eax
  if (icmp_hdr + 1 > data_end) {
     99a:	1c 31                	sbb    $0x31,%al
     99c:	05 21 06 74 05       	add    $0x5740621,%eax
     9a1:	05 4a 05 1a 74       	add    $0x741a054a,%eax
     9a6:	05 1c 06 4b 05       	add    $0x54b061c,%eax
     9ab:	21 06                	and    %eax,(%rsi)
     9ad:	74 05                	je     9b4 <balancer_ingress+0x9b4>
    return XDP_DROP;
     9af:	05 3c 05 1a 74       	add    $0x741a053c,%eax
     9b4:	05 03 06 4c 04       	add    $0x44c0603,%eax
     9b9:	00 05 09 03 e3 04    	add    %al,0x4e30309(%rip)        # 4e30cc8 <bpf_xdp_adjust_head+0x4e28d28>
  if (icmp_hdr->type == ICMP_ECHO) {
     9bf:	74 05                	je     9c6 <balancer_ingress+0x9c6>
     9c1:	07                   	(bad)
     9c2:	91                   	xchg   %eax,%ecx
     9c3:	05 03 e6 05 0e       	add    $0xe05e603,%eax
     9c8:	06                   	(bad)
     9c9:	58                   	pop    %rax
     9ca:	05 17 74 05 0e       	add    $0xe057417,%eax
     9cf:	3c 05                	cmp    $0x5,%al
    return send_icmp_reply(data, data_end);
     9d1:	14 06                	adc    $0x6,%al
     9d3:	67 05 1a 06 74 05    	addr32 add $0x574061a,%eax
     9d9:	24 74                	and    $0x74,%al
     9db:	04 09                	add    $0x9,%al
     9dd:	05 15 06 03 e9       	add    $0xe9030615,%eax
     9e2:	7a 02                	jp     9e6 <balancer_ingress+0x9e6>
     9e4:	2a 01                	sub    (%rcx),%al
     9e6:	05 21 06 ac 05       	add    $0x5ac0621,%eax
     9eb:	2b 3c 05 12 66 05 08 	sub    0x8056612(,%rax,1),%edi
  __u32 tmp_addr = 0;
     9f2:	2e 05 1b 06 83 05    	cs add $0x583061b,%eax
  __u64 csum = 0;
     9f8:	24 06                	and    $0x6,%al
     9fa:	66 05 09 06          	add    $0x609,%ax
     9fe:	03 6b 08             	add    0x8(%rbx),%ebp
  __u64 off = 0;
     a01:	66 05 07 ad          	add    $0xad07,%ax
     a05:	05 09 91 08 21       	add    $0x21089109,%eax
     a0a:	05 0b 91 05 03       	add    $0x305910b,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     a0f:	08 22                	or     %ah,(%rdx)
     a11:	05 09 2f 08 21       	add    $0x21082f09,%eax
     a16:	05 0b 91 06 03       	add    $0x306910b,%eax
     a1b:	ab                   	stos   %eax,%es:(%rdi)
     a1c:	7f 08                	jg     a26 <balancer_ingress+0xa26>
     a1e:	20 05 0a 06 03 d8    	and    %al,-0x27fcf9f6(%rip)        # ffffffffd803102e <server_id_map+0x36fee3db502e>
       sizeof(struct icmphdr)) > data_end) {
     a24:	00 2e                	add    %ch,(%rsi)
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     a26:	05 09 03 09 74       	add    $0x74090309,%eax
    return XDP_DROP;
     a2b:	76 05                	jbe    a32 <balancer_ingress+0xa32>
     a2d:	0e                   	(bad)
     a2e:	06                   	(bad)
     a2f:	74 05                	je     a36 <balancer_ingress+0xa36>
     a31:	07                   	(bad)
     a32:	74 06                	je     a3a <balancer_ingress+0xa3a>
     a34:	76 05                	jbe    a3b <balancer_ingress+0xa3b>
     a36:	0b 06                	or     (%rsi),%eax
  off += sizeof(struct ethhdr);
     a38:	74 05                	je     a3f <balancer_ingress+0xa3f>
     a3a:	11 4a 05             	adc    %ecx,0x5(%rdx)
     a3d:	0f 74 05 07 3c 05 05 	pcmpeqb 0x5053c07(%rip),%mm0        # 505464b <bpf_xdp_adjust_head+0x504c6ab>
     a44:	06                   	(bad)
     a45:	2f                   	(bad)
     a46:	05 07 93 05 1c       	add    $0x1c059307,%eax
  iph = data + off;
     a4b:	91                   	xchg   %eax,%ecx
     a4c:	05 21 06 74 05       	add    $0x5740621,%eax
     a51:	05 3c 05 1a 74       	add    $0x741a053c,%eax
     a56:	05 1c 06 4b 05       	add    $0x54b061c,%eax
     a5b:	21 06                	and    %eax,(%rsi)
     a5d:	74 05                	je     a64 <balancer_ingress+0xa64>
  off += sizeof(struct iphdr);
     a5f:	05 4a 05 1a 74       	add    $0x741a054a,%eax
     a64:	05 03 06 4b 05       	add    $0x54b0603,%eax
     a69:	1c 31                	sbb    $0x31,%al
     a6b:	05 21 06 74 05       	add    $0x5740621,%eax
  icmp_hdr = data + off;
     a70:	05 4a 05 1a 74       	add    $0x741a054a,%eax
     a75:	05 1c 06 4b 05       	add    $0x54b061c,%eax
     a7a:	21 06                	and    %eax,(%rsi)
     a7c:	74 05                	je     a83 <balancer_ingress+0xa83>
     a7e:	05 3c 05 1a 74       	add    $0x741a053c,%eax
     a83:	05 03 06 4c 04       	add    $0x44c0603,%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
     a88:	00 05 09 03 85 05    	add    %al,0x5850309(%rip)        # 5850d97 <bpf_xdp_adjust_head+0x5848df7>
     a8e:	74 05                	je     a95 <balancer_ingress+0xa95>
  icmp_hdr->checksum += 0x0008;
     a90:	07                   	(bad)
     a91:	91                   	xchg   %eax,%ecx
     a92:	06                   	(bad)
     a93:	03 88 7a e4 05 05    	add    0x505e47a(%rax),%ecx
     a99:	06                   	(bad)
     a9a:	03 87 06 2e 05 07    	add    0x7052e06(%rdi),%eax
     aa0:	e7 05                	out    %eax,$0x5
  iph->ttl = DEFAULT_TTL;
     aa2:	05 91 05 03 08       	add    $0x8030591,%eax
     aa7:	ad                   	lods   %ds:(%rsi),%eax
     aa8:	05 19 2f 05 0d       	add    $0xd052f19,%eax
  tmp_addr = iph->daddr;
     aad:	06                   	(bad)
     aae:	66 05 0e 06          	add    $0x60e,%ax
     ab2:	69 05 0c 06 74 05 19 	imul   $0x5750619,0x574060c(%rip),%eax        # 57410c8 <bpf_xdp_adjust_head+0x5739128>
     ab9:	06 75 05 
  iph->daddr = iph->saddr;
     abc:	0d 06 66 05 0e       	or     $0xe056606,%eax
     ac1:	06                   	(bad)
     ac2:	67 06                	addr32 (bad)
     ac4:	ac                   	lods   %ds:(%rsi),%al
     ac5:	9e                   	sahf
     ac6:	08 e4                	or     %ah,%ah
     ac8:	74 2e                	je     af8 <balancer_ingress+0xaf8>
     aca:	08 f2                	or     %dh,%dl
     acc:	74 74                	je     b42 <balancer_ingress+0xb42>
     ace:	05 0c 74 05 08       	add    $0x805740c,%eax
  iph->saddr = tmp_addr;
     ad3:	06                   	(bad)
     ad4:	75 05                	jne    adb <balancer_ingress+0xadb>
     ad6:	07                   	(bad)
     ad7:	06                   	(bad)
     ad8:	82                   	(bad)
     ad9:	05 0e 06 67 05       	add    $0x567060e,%eax
     ade:	10 91 06 ac 9e 08    	adc    %dl,0x89eac06(%rcx)
  iph->check = 0;
     ae4:	e4 74                	in     $0x74,%al
     ae6:	2e 08 f2             	cs or  %dh,%dl
     ae9:	74 74                	je     b5f <balancer_ingress+0xb5f>
     aeb:	05 0e 74 05 0a       	add    $0xa05740e,%eax
  ipv4_csum_inline(iph, &csum);
     af0:	06                   	(bad)
     af1:	75 05                	jne    af8 <balancer_ingress+0xaf8>
     af3:	09 06                	or     %eax,(%rsi)
     af5:	82                   	(bad)
     af6:	05 07 06 2f 05       	add    $0x52f0607,%eax
     afb:	0b e7                	or     %edi,%esp
     afd:	05 15 06 74 05       	add    $0x5740615,%eax
     b02:	1b 2e                	sbb    (%rsi),%ebp
     b04:	05 30 66 05 0b       	add    $0xb056630,%eax
  __u16* next_iph_u16 = (__u16*)iph;
     b09:	06                   	(bad)
     b0a:	2f                   	(bad)
     b0b:	05 15 06 74 05       	add    $0x5740615,%eax
     b10:	1b 2e                	sbb    (%rsi),%ebp
     b12:	05 09 06 81 05       	add    $0x5810609,%eax
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
     b17:	1b 32                	sbb    (%rdx),%esi
     b19:	05 03 92 05 07       	add    $0x7059203,%eax
     b1e:	30 05 12 06 74 05    	xor    %al,0x5740612(%rip)        # 5741136 <bpf_xdp_adjust_head+0x5739196>
     b24:	10 74 05 17          	adc    %dh,0x17(%rbp,%rax,1)
     b28:	3c 05                	cmp    $0x5,%al
     b2a:	07                   	(bad)
     b2b:	66 05 05 06          	add    $0x605,%ax
    *csum += *next_iph_u16++;
     b2f:	03 0f                	add    (%rdi),%ecx
     b31:	2e 05 09 e8 05 10    	cs add $0x1005e809,%eax
     b37:	9f                   	lahf
     b38:	06                   	(bad)
     b39:	ac                   	lods   %ds:(%rsi),%al
     b3a:	9e                   	sahf
     b3b:	08 e4                	or     %ah,%ah
     b3d:	74 2e                	je     b6d <balancer_ingress+0xb6d>
     b3f:	08 f2                	or     %dh,%dl
     b41:	74 74                	je     bb7 <balancer_ingress+0xbb7>
     b43:	05 0e 74 05 08       	add    $0x805740e,%eax
     b48:	06                   	(bad)
     b49:	75 05                	jne    b50 <balancer_ingress+0xb50>
     b4b:	07                   	(bad)
     b4c:	06                   	(bad)
     b4d:	82                   	(bad)
     b4e:	05 05 06 2f 05       	add    $0x52f0605,%eax
     b53:	03 e8                	add    %eax,%ebp
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
     b55:	05 12 06 74 05       	add    $0x5740612,%eax
     b5a:	08 06                	or     %al,(%rsi)
     b5c:	a0 05 12 06 74 05 18 	movabs 0x52e180574061205,%al
     b63:	2e 05 
     b65:	07                   	(bad)
  *csum = csum_fold_helper(*csum);
     b66:	66 05 19 06          	add    $0x619,%ax
     b6a:	31 05 0d 93 05 17    	xor    %eax,0x1705930d(%rip)        # 17059e7d <bpf_xdp_adjust_head+0x17051edd>
     b70:	06                   	(bad)
     b71:	74 05                	je     b78 <balancer_ingress+0xb78>
     b73:	0b 3c 05 13 06 67 05 	or     0x5670613(,%rax,1),%edi
  for (i = 0; i < 4; i++) {
     b7a:	09 06                	or     %eax,(%rsi)
     b7c:	e4 05                	in     $0x5,%al
     b7e:	13 06                	adc    (%rsi),%eax
     b80:	67 06                	addr32 (bad)
     b82:	ac                   	lods   %ds:(%rsi),%al
     b83:	9e                   	sahf
     b84:	08 e4                	or     %ah,%ah
     b86:	74 2e                	je     bb6 <balancer_ingress+0xbb6>
     b88:	08 f2                	or     %dh,%dl
    if (csum >> 16)
     b8a:	74 74                	je     c00 <balancer_ingress+0xc00>
     b8c:	05 09 74 05 08       	add    $0x8057409,%eax
     b91:	06                   	(bad)
     b92:	75 05                	jne    b99 <balancer_ingress+0xb99>
     b94:	07                   	(bad)
     b95:	06                   	(bad)
     b96:	82                   	(bad)
     b97:	05 0d 06 67 05       	add    $0x567060d,%eax
      csum = (csum & 0xffff) + (csum >> 16);
     b9c:	0b 08                	or     (%rax),%ecx
     b9e:	13 05 22 9f 06 ac    	adc    -0x53f960de(%rip),%eax        # ffffffffac06aac6 <server_id_map+0x36feb7deeac6>
     ba4:	9e                   	sahf
     ba5:	08 e4                	or     %ah,%ah
     ba7:	74 2e                	je     bd7 <balancer_ingress+0xbd7>
     ba9:	08 f2                	or     %dh,%dl
     bab:	74 74                	je     c21 <balancer_ingress+0xc21>
     bad:	05 16 74 05 0a       	add    $0xa057416,%eax
     bb2:	06                   	(bad)
     bb3:	75 05                	jne    bba <balancer_ingress+0xbba>
     bb5:	09 06                	or     %eax,(%rsi)
     bb7:	82                   	(bad)
     bb8:	05 07 06 2f 05       	add    $0x52f0607,%eax
  for (i = 0; i < 4; i++) {
     bbd:	05 e9 05 13 06       	add    $0x61305e9,%eax
     bc2:	74 05                	je     bc9 <balancer_ingress+0xbc9>
     bc4:	08 06                	or     %al,(%rsi)
     bc6:	a2 05 12 06 74 05 18 	movabs %al,0x52e180574061205
     bcd:	2e 05 
  return ~csum;
     bcf:	07                   	(bad)
     bd0:	66 05 15 06          	add    $0x615,%ax
     bd4:	67 05 20 06 74 05    	addr32 add $0x5740620,%eax
  *csum = csum_fold_helper(*csum);
     bda:	14 3c                	adc    $0x3c,%al
     bdc:	05 0a 66 05 09       	add    $0x905660a,%eax
     be1:	06                   	(bad)
     be2:	83 05 0d cf 05 25 9f 	addl   $0xffffff9f,0x2505cf0d(%rip)        # 2505daf6 <bpf_xdp_adjust_head+0x25055b56>
  iph->check = csum;
     be9:	06                   	(bad)
     bea:	ac                   	lods   %ds:(%rsi),%al
     beb:	9e                   	sahf
     bec:	08 e4                	or     %ah,%ah
     bee:	74 2e                	je     c1e <balancer_ingress+0xc1e>
     bf0:	08 f2                	or     %dh,%dl
     bf2:	74 74                	je     c68 <balancer_ingress+0xc68>
     bf4:	05 18 74 05 0c       	add    $0xc057418,%eax
     bf9:	06                   	(bad)
     bfa:	75 05                	jne    c01 <balancer_ingress+0xc01>
     bfc:	0b 06                	or     (%rsi),%eax
  return swap_mac_and_send(data, data_end);
     bfe:	82                   	(bad)
     bff:	05 09 06 2f 05       	add    $0x52f0609,%eax
     c04:	07                   	(bad)
     c05:	e6 05                	out    %al,$0x5
     c07:	16                   	(bad)
     c08:	06                   	(bad)
     c09:	74 05                	je     c10 <balancer_ingress+0xc10>
     c0b:	24 06                	and    $0x6,%al
     c0d:	a0 05 2a 06 74 05 34 	movabs 0x474340574062a05,%al
     c14:	74 04 
     c16:	0b 05 09 06 03 e0    	or     -0x1ffcf9f7(%rip),%eax        # ffffffffe0031225 <server_id_map+0x36feebdb5225>
  eth = data;
     c1c:	7b 08                	jnp    c26 <balancer_ingress+0xc26>
     c1e:	ac                   	lods   %ds:(%rsi),%al
     c1f:	05 07 ad 05 21       	add    $0x2105ad07,%eax
     c24:	91                   	xchg   %eax,%ecx
     c25:	05 26 06 74 05       	add    $0x5740626,%eax
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     c2a:	2c 74                	sub    $0x74,%al
     c2c:	05 16 4a 05 0a       	add    $0xa054a16,%eax
     c31:	06                   	(bad)
     c32:	76 05                	jbe    c39 <balancer_ingress+0xc39>
     c34:	1f                   	(bad)
     c35:	06                   	(bad)
     c36:	ac                   	lods   %ds:(%rsi),%al
     c37:	05 37 ac 05 0a       	add    $0xa05ac37,%eax
     c3c:	06                   	(bad)
     c3d:	2f                   	(bad)
     c3e:	05 1f 06 ac 03       	add    $0x3ac061f,%eax
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     c43:	b6 7d                	mov    $0x7d,%dh
     c45:	ba 05 05 06 03       	mov    $0x3060505,%edx
     c4a:	c8 02 66 05          	enter  $0x6602,$0x5
     c4e:	20 a2 05 25 06 74    	and    %ah,0x74062505(%rdx)
     c54:	05 2b 74 05 15       	add    $0x1505742b,%eax
     c59:	4a 05 0a 06 76 05    	rex.WX add $0x576060a,%rax
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     c5f:	19 06                	sbb    %eax,(%rsi)
     c61:	ac                   	lods   %ds:(%rsi),%al
     c62:	05 2f ac 05 0a       	add    $0xa05ac2f,%eax
     c67:	06                   	(bad)
     c68:	2f                   	(bad)
     c69:	05 19 06 ac 03       	add    $0x3ac0619,%eax
     c6e:	b1 7d                	mov    $0x7d,%cl
     c70:	ba 05 05 06 03       	mov    $0x3060505,%edx
     c75:	cd 02                	int    $0x2
  return swap_mac_and_send(data, data_end);
     c77:	66 04 00             	data16 add $0x0,%al
     c7a:	05 0b 03 98 04       	add    $0x498030b,%eax
     c7f:	82                   	(bad)
     c80:	05 09 ad 05 18       	add    $0x1805ad09,%eax
}
     c85:	06                   	(bad)
     c86:	74 05                	je     c8d <balancer_ingress+0xc8d>
    return send_icmp_reply(data, data_end);
     c88:	05 06 bc 05 0d       	add    $0xd05bc06,%eax
     c8d:	59                   	pop    %rcx
     c8e:	05 0b a0 06 ac       	add    $0xac06a00b,%eax
  if (icmp_hdr->type != ICMP_DEST_UNREACH) {
     c93:	9e                   	sahf
     c94:	08 e4                	or     %ah,%ah
     c96:	74 2e                	je     cc6 <balancer_ingress+0xcc6>
     c98:	08 f2                	or     %dh,%dl
     c9a:	74 74                	je     d10 <balancer_ingress+0xd10>
     c9c:	05 25 06 73 05       	add    $0x5730625,%eax
    return XDP_PASS;
     ca1:	0c 76                	or     $0x76,%al
     ca3:	05 0b 06 82 05       	add    $0x582060b,%eax
     ca8:	09 06                	or     %eax,(%rsi)
     caa:	2f                   	(bad)
     cab:	05 31 e6 05 37       	add    $0x3705e631,%eax
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     cb0:	06                   	(bad)
     cb1:	74 05                	je     cb8 <balancer_ingress+0xcb8>
     cb3:	41 74 04             	rex.B je cba <balancer_ingress+0xcba>
     cb6:	09 05 1c 06 03 e9    	or     %eax,-0x16fcf9e4(%rip)        # ffffffffe90312d8 <server_id_map+0x36fef4db52d8>
     cbc:	7b 02                	jnp    cc0 <balancer_ingress+0xcc0>
     cbe:	2a 01                	sub    (%rcx),%al
     cc0:	05 13 08 6d 05       	add    $0x56d0813,%eax
    __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
     cc5:	1f                   	(bad)
     cc6:	06                   	(bad)
     cc7:	ac                   	lods   %ds:(%rsi),%al
     cc8:	05 12 3c 05 08       	add    $0x8053c12,%eax
     ccd:	66 05 1b 06          	add    $0x61b,%ax
        bpf_map_lookup_elem(&stats, &stats_key);
     cd1:	83 05 24 06 66 05 09 	addl   $0x9,0x5660624(%rip)        # 56612fc <bpf_xdp_adjust_head+0x565935c>
     cd8:	06                   	(bad)
     cd9:	03 ec                	add    %esp,%ebp
     cdb:	7d 08                	jge    ce5 <balancer_ingress+0xce5>
     cdd:	66 05 07 ad          	add    $0xad07,%ax
     ce1:	05 09 91 08 21       	add    $0x21089109,%eax
     ce6:	05 0b 91 05 03       	add    $0x305910b,%eax
     ceb:	08 22                	or     %ah,(%rdx)
     ced:	05 09 2f 08 21       	add    $0x21082f09,%eax
     cf2:	05 0b 91 06 03       	add    $0x306910b,%eax
     cf7:	ab                   	stos   %eax,%es:(%rdi)
     cf8:	7f 08                	jg     d02 <balancer_ingress+0xd02>
     cfa:	20 05 0a 06 03 d8    	and    %al,-0x27fcf9f6(%rip)        # ffffffffd803130a <server_id_map+0x36fee3db530a>
     d00:	00 2e                	add    %ch,(%rsi)
     d02:	05 09 03 88 02       	add    $0x2880309,%eax
     d07:	74 05                	je     d0e <balancer_ingress+0xd0e>
     d09:	08 77 05             	or     %dh,0x5(%rdi)
     d0c:	0d 06 74 05 13       	or     $0x13057406,%eax
     d11:	74 05                	je     d18 <balancer_ingress+0xd18>
     d13:	2b 4a 05             	sub    0x5(%rdx),%ecx
     d16:	3b 4a 05             	cmp    0x5(%rdx),%ecx
     d19:	07                   	(bad)
     d1a:	74 05                	je     d21 <balancer_ingress+0xd21>
     d1c:	05 06 2f 05 15       	add    $0x15052f06,%eax
     d21:	5b                   	pop    %rbx
     d22:	05 1a 06 74 05       	add    $0x574061a,%eax
     d27:	20 74 05 09          	and    %dh,0x9(%rbp,%rax,1)
     d2b:	4a 05 14 06 75 05    	rex.WX add $0x5750614,%rax
     d31:	09 06                	or     %eax,(%rsi)
     d33:	74 06                	je     d3b <balancer_ingress+0xd3b>
     d35:	75 b2                	jne    ce9 <balancer_ingress+0xce9>
     d37:	05 08 06 74 05       	add    $0x5740608,%eax
     d3c:	12 3c 05 26 58 05 07 	adc    0x7055826(,%rax,1),%bh
    struct lb_stats* icmp_ptb_v4_stats =
     d43:	58                   	pop    %rax
     d44:	05 09 06 30 05       	add    $0x5300609,%eax
    if (!icmp_ptb_v4_stats) {
     d49:	13 06                	adc    (%rsi),%eax
     d4b:	74 05                	je     d52 <balancer_ingress+0xd52>
     d4d:	35 4a 05 09 74       	xor    $0x7409054a,%eax
     d52:	05 07 06 2f 05       	add    $0x52f0607,%eax
      return XDP_DROP;
     d57:	0b 5a 05             	or     0x5(%rdx),%ebx
     d5a:	0a 06                	or     (%rsi),%al
     d5c:	74 05                	je     d63 <balancer_ingress+0xd63>
     d5e:	14 3c                	adc    $0x3c,%al
     d60:	05 2d 3c 05 09       	add    $0x9053c2d,%eax
    icmp_ptb_v4_stats->v1 += 1;
     d65:	3c 05                	cmp    $0x5,%al
     d67:	19 06                	sbb    %eax,(%rsi)
     d69:	31 05 07 75 05 46    	xor    %eax,0x46057507(%rip)        # 46058276 <bpf_xdp_adjust_head+0x460502d6>
     d6f:	5b                   	pop    %rbx
     d70:	05 1e 06 74 05       	add    $0x574061e,%eax
    __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);
     d75:	09 06                	or     %eax,(%rsi)
     d77:	76 05                	jbe    d7e <balancer_ingress+0xd7e>
     d79:	23 06                	and    (%rsi),%eax
     d7b:	ac                   	lods   %ds:(%rsi),%al
     d7c:	05 09 3c 05 07       	add    $0x7053c09,%eax
     d81:	06                   	(bad)
     d82:	2f                   	(bad)
     d83:	05 0e 5a 05 1b       	add    $0x1b055a0e,%eax
     d88:	06                   	(bad)
     d89:	74 05                	je     d90 <balancer_ingress+0xd90>
     d8b:	0c 4a                	or     $0x4a,%al
     d8d:	05 03 06 75 05       	add    $0x5750603,%eax
     d92:	09 30                	or     %esi,(%rax)
     d94:	05 13 06 74 05       	add    $0x5740613,%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     d99:	36 4a 05 09 74 05 07 	ss rex.WX add $0x7057409,%rax
     da0:	06                   	(bad)
     da1:	2f                   	(bad)
     da2:	05 2a 5a 05 36       	add    $0x36055a2a,%eax
      icmp_ptb_v4_stats->v2 += 1;
     da7:	06                   	(bad)
     da8:	74 05                	je     daf <balancer_ingress+0xdaf>
     daa:	0c 4a                	or     $0x4a,%al
     dac:	05 08 06 76 05       	add    $0x5760608,%eax
     db1:	07                   	(bad)
     db2:	06                   	(bad)
     db3:	82                   	(bad)
     db4:	05 05 06 2f 05       	add    $0x52f0605,%eax
  }
     db9:	19 5b 05             	sbb    %ebx,0x5(%rbx)
  off += sizeof(struct icmphdr);
     dbc:	23 06                	and    (%rsi),%eax
     dbe:	9e                   	sahf
     dbf:	05 08 3c 05 18       	add    $0x18053c08,%eax
     dc4:	06                   	(bad)
     dc5:	67 05 16 06 66 05    	addr32 add $0x5660616,%eax
     dcb:	07                   	(bad)
     dcc:	06                   	(bad)
  iph = data + off;
     dcd:	67 05 15 06 74 05    	addr32 add $0x5740615,%eax
     dd3:	07                   	(bad)
     dd4:	3c 05                	cmp    $0x5,%al
     dd6:	0b 06                	or     (%rsi),%eax
     dd8:	32 05 15 06 9e 05    	xor    0x59e0615(%rip),%al        # 59e13f3 <bpf_xdp_adjust_head+0x59d9453>
     dde:	1d 3c 05 27 3c       	sbb    $0x3c27053c,%eax
  if (iph + 1 > data_end) {
     de3:	05 31 ac 05 24       	add    $0x2405ac31,%eax
     de8:	3c 05                	cmp    $0x5,%al
     dea:	3a 2e                	cmp    (%rsi),%ch
     dec:	05 44 ac 05 37       	add    $0x3705ac44,%eax
     df1:	3c 05                	cmp    $0x5,%al
     df3:	16                   	(bad)
     df4:	06                   	(bad)
     df5:	2d 05 05 68 05       	sub    $0x5680505,%eax
    return XDP_DROP;
     dfa:	0e                   	(bad)
     dfb:	59                   	pop    %rcx
     dfc:	05 1c 06 74 05       	add    $0x574061c,%eax
     e01:	0e                   	(bad)
     e02:	3c 05                	cmp    $0x5,%al
     e04:	19 06                	sbb    %eax,(%rsi)
  if (iph->ihl != 5) {
     e06:	2f                   	(bad)
     e07:	05 23 06 ac 05       	add    $0x5ac0623,%eax
     e0c:	2d 3c 05 37 ac       	sub    $0xac37053c,%eax
     e11:	05 2a 3c 05 40       	add    $0x40053c2a,%eax
     e16:	2e 05 3f 74 05 3d    	cs add $0x3d05743f,%eax
    return XDP_DROP;
     e1c:	4a 05 16 2e 05 05    	rex.WX add $0x5052e16,%rax
     e22:	06                   	(bad)
     e23:	67 05 0e 2f 05 1c    	addr32 add $0x1c052f0e,%eax
  pckt->flow.proto = iph->protocol;
     e29:	06                   	(bad)
     e2a:	74 05                	je     e31 <balancer_ingress+0xe31>
     e2c:	0e                   	(bad)
     e2d:	3c 05                	cmp    $0x5,%al
     e2f:	0a 06                	or     (%rsi),%al
     e31:	30 05 14 06 ac 05    	xor    %al,0x5ac0614(%rip)        # 5ac144b <bpf_xdp_adjust_head+0x5ab94ab>
     e37:	1e                   	(bad)
  pckt->flags |= F_ICMP;
     e38:	3c 05                	cmp    $0x5,%al
     e3a:	28 ac 05 1b 3c 05 32 	sub    %ch,0x32053c1b(%rbp,%rax,1)
     e41:	2e 05 3c ac 05 2f    	cs add $0x2f05ac3c,%eax
     e47:	3c 05                	cmp    $0x5,%al
  pckt->flow.src = iph->daddr;
     e49:	45                   	rex.RB
     e4a:	2e 05 44 74 05 42    	cs add $0x42057444,%eax
     e50:	4a 05 16 06 2d 05    	rex.WX add $0x52d0616,%rax
     e56:	03 69 05             	add    0x5(%rcx),%ebp
     e59:	01 2f                	add    %ebp,(%rdi)
     e5b:	04 00                	add    $0x0,%al
  pckt->flow.dst = iph->saddr;
     e5d:	05 26 03 d3 03       	add    $0x3d30326,%eax
     e62:	74 05                	je     e69 <balancer_ingress+0xe69>
     e64:	19 75 05             	sbb    %esi,0x5(%rbp)
     e67:	0b 06                	or     (%rsi),%eax
     e69:	74 05                	je     e70 <balancer_ingress+0xe70>
     e6b:	2a 06                	sub    (%rsi),%al
     e6d:	69 05 42 06 74 05 07 	imul   $0xc5030607,0x5740642(%rip),%eax        # 57414b9 <bpf_xdp_adjust_head+0x5739519>
     e74:	06 03 c5 
  return FURTHER_PROCESSING;
     e77:	7d 08                	jge    e81 <balancer_ingress+0xe81>
     e79:	2e 05 13 06 74 05    	cs add $0x5740613,%eax
}
     e7f:	07                   	(bad)
    return parse_icmp(data, data_end, off, pckt);
     e80:	3c 05                	cmp    $0x5,%al
     e82:	05 06 2f 05 20       	add    $0x20052f06,%eax
     e87:	06                   	(bad)
    return FURTHER_PROCESSING;
     e88:	74 05                	je     e8f <balancer_ingress+0xe8f>
     e8a:	03 06                	add    (%rsi),%eax
     e8c:	bb 05 0e 06 2e       	mov    $0x2e060e05,%ebx
     e91:	05 1a 74 05 0e       	add    $0xe05741a,%eax
}
     e96:	3c 05                	cmp    $0x5,%al
     e98:	05 06 2f 05 20       	add    $0x20052f06,%eax
     e9d:	06                   	(bad)
  if (action >= 0) {
     e9e:	74 05                	je     ea5 <balancer_ingress+0xea5>
     ea0:	03 06                	add    (%rsi),%eax
     ea2:	bb 05 0e 06 2e       	mov    $0x2e060e05,%ebx
    return action;
     ea7:	05 1a 74 05 0e       	add    $0xe05741a,%eax
     eac:	3c 05                	cmp    $0x5,%al
     eae:	05 06 2f 05 20       	add    $0x20052f06,%eax
     eb3:	06                   	(bad)
     eb4:	74 05                	je     ebb <balancer_ingress+0xebb>
     eb6:	03 06                	add    (%rsi),%eax
  protocol = pckt.flow.proto;
     eb8:	bb 05 05 2f 05       	mov    $0x52f0505,%ebx
     ebd:	20 06                	and    %al,(%rsi)
     ebf:	74 03                	je     ec4 <balancer_ingress+0xec4>
     ec1:	c1 7b ba 05          	sarl   $0x5,-0x46(%rbx)
  if (protocol == IPPROTO_TCP) {
     ec5:	19 06                	sbb    %eax,(%rsi)
     ec7:	03 f4                	add    %esp,%esi
     ec9:	06                   	(bad)
     eca:	4a 05 0f 06 66 05    	rex.WX add $0x566060f,%rax
     ed0:	1b 06                	sbb    (%rsi),%eax
     ed2:	67 06                	addr32 (bad)
    if (!parse_tcp(data, data_end, is_ipv6, &pckt)) {
     ed4:	ac                   	lods   %ds:(%rsi),%al
     ed5:	9e                   	sahf
     ed6:	08 e4                	or     %ah,%ah
     ed8:	74 2e                	je     f08 <balancer_ingress+0xf08>
     eda:	08 f2                	or     %dh,%dl
     edc:	74 74                	je     f52 <balancer_ingress+0xf52>
     ede:	05 10 74 05 0d       	add    $0xd057410,%eax
     ee3:	06                   	(bad)
     ee4:	75 06                	jne    eec <balancer_ingress+0xeec>
     ee6:	82                   	(bad)
     ee7:	05 12 06 68 05       	add    $0x5680612,%eax
     eec:	11 06                	adc    %eax,(%rsi)
     eee:	74 05                	je     ef5 <balancer_ingress+0xef5>
     ef0:	0f 2e 05 13 06 67 05 	ucomiss 0x5670613(%rip),%xmm0        # 567150a <bpf_xdp_adjust_head+0x566956a>
     ef7:	0f 06                	clts
     ef9:	74 05                	je     f00 <balancer_ingress+0xf00>
     efb:	0d 06 31 05 37       	or     $0x37053106,%eax
     f00:	06                   	(bad)
     f01:	74 05                	je     f08 <balancer_ingress+0xf08>
     f03:	40 06                	rex (bad)
     f05:	bb 05 0d 06 74       	mov    $0x74060d05,%ebx
     f0a:	05 3e 74 05 0d       	add    $0xd05743e,%eax
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
     f0f:	06                   	(bad)
     f10:	4b 05 2b 06 74 05    	rex.WXB add $0x574062b,%rax
     f16:	0b 06                	or     (%rsi),%eax
     f18:	9f                   	lahf
     f19:	05 1f 59 05 1d       	add    $0x1d05591f,%eax
     f1e:	06                   	(bad)
     f1f:	66 05 13 06          	add    $0x613,%ax
     f23:	67 06                	addr32 (bad)
     f25:	ac                   	lods   %ds:(%rsi),%al
     f26:	9e                   	sahf
     f27:	08 e4                	or     %ah,%ah
     f29:	74 2e                	je     f59 <balancer_ingress+0xf59>
  __u64 off = calc_offset(is_ipv6, is_icmp);
     f2b:	08 f2                	or     %dh,%dl
     f2d:	74 74                	je     fa3 <balancer_ingress+0xfa3>
     f2f:	05 11 74 05 12       	add    $0x12057411,%eax
     f34:	06                   	(bad)
     f35:	75 05                	jne    f3c <balancer_ingress+0xf3c>
     f37:	11 06                	adc    %eax,(%rsi)
     f39:	82                   	(bad)
     f3a:	05 0f 06 30 05       	add    $0x530060f,%eax
     f3f:	3c 06                	cmp    $0x6,%al
     f41:	74 05                	je     f48 <balancer_ingress+0xf48>
     f43:	0f 06                	clts
     f45:	bd 05 41 e6 05       	mov    $0x5e64105,%ebp
  __u64 off = sizeof(struct ethhdr);
     f4a:	22 03                	and    (%rbx),%al
     f4c:	e1 7d                	loope  fcb <balancer_ingress+0xfcb>
     f4e:	08 ac 05 3b 06 c8 05 	or     %ch,0x5c8063b(%rbp,%rax,1)
  if (is_ipv6) {
     f55:	45 74 05             	rex.RB je f5d <balancer_ingress+0xf5d>
     f58:	22 74 05 18          	and    0x18(%rbp,%rax,1),%dh
    off += sizeof(struct ipv6hdr);
     f5c:	2e 05 07 06 75 06    	cs add $0x6750607,%eax
     f62:	82                   	(bad)
     f63:	05 09 06 2f 05       	add    $0x52f0609,%eax
     f68:	12 06                	adc    (%rsi),%al
     f6a:	74 05                	je     f71 <balancer_ingress+0xf71>
     f6c:	19 2e                	sbb    %ebp,(%rsi)
    if (is_icmp) {
     f6e:	05 16 74 05 09       	add    $0x9057416,%eax
     f73:	3c 05                	cmp    $0x5,%al
     f75:	07                   	(bad)
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
     f76:	06                   	(bad)
     f77:	2f                   	(bad)
     f78:	05 16 e6 05 1c       	add    $0x1c05e616,%eax
     f7d:	06                   	(bad)
     f7e:	74 05                	je     f85 <balancer_ingress+0xf85>
     f80:	07                   	(bad)
     f81:	3c 05                	cmp    $0x5,%al
     f83:	14 74                	adc    $0x74,%al
     f85:	05 07 06 2f 06       	add    $0x62f0607,%eax
    off += sizeof(struct iphdr);
     f8a:	03 90 7b e4 05 09    	add    0x905e47b(%rax),%edx
     f90:	06                   	(bad)
     f91:	03 28                	add    (%rax),%ebp
     f93:	d6                   	(bad)
     f94:	05 07 a0 06 ac       	add    $0xac06a007,%eax
     f99:	9e                   	sahf
     f9a:	08 e4                	or     %ah,%ah
    if (is_icmp) {
     f9c:	74 2e                	je     fcc <balancer_ingress+0xfcc>
     f9e:	08 f2                	or     %dh,%dl
     fa0:	74 74                	je     1016 <balancer_ingress+0x1016>
     fa2:	05 14 06 73 05       	add    $0x5730614,%eax
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
     fa7:	08 76 05             	or     %dh,0x5(%rsi)
     faa:	07                   	(bad)
     fab:	06                   	(bad)
     fac:	82                   	(bad)
     fad:	05 05 06 2f 05       	add    $0x52f0605,%eax
     fb2:	0f bc 05 04 06 08 20 	bsf    0x20080604(%rip),%eax        # 200815bd <bpf_xdp_adjust_head+0x2007961d>
  return off;
     fb9:	05 0d 74 05 09       	add    $0x905740d,%eax
     fbe:	06                   	(bad)
     fbf:	40 05 08 06 74 05    	rex add $0x5740608,%eax
  __u64 off = calc_offset(is_ipv6, is_icmp);
     fc5:	14 3c                	adc    $0x3c,%al
  tcp = data + off;
     fc7:	05 12 74 05 29       	add    $0x29057412,%eax
     fcc:	4a 05 07 66 05 05    	rex.WX add $0x5056607,%rax
     fd2:	06                   	(bad)
     fd3:	30 05 19 06 74 05    	xor    %al,0x5740619(%rip)        # 57415f2 <bpf_xdp_adjust_head+0x5739652>
     fd9:	1c 06                	sbb    $0x6,%al
     fdb:	75 05                	jne    fe2 <balancer_ingress+0xfe2>
  if (tcp + 1 > data_end) {
     fdd:	1b 06                	sbb    (%rsi),%eax
     fdf:	74 05                	je     fe6 <balancer_ingress+0xfe6>
     fe1:	05 3c 05 19 74       	add    $0x7419053c,%eax
     fe6:	05 03 06 4b 05       	add    $0x54b0603,%eax
     feb:	05 2f 05 19 06       	add    $0x619052f,%eax
     ff0:	74 05                	je     ff7 <balancer_ingress+0xff7>
     ff2:	09 06                	or     %eax,(%rsi)
    return false;
     ff4:	9f                   	lahf
     ff5:	05 1d 06 74 05       	add    $0x574061d,%eax
     ffa:	09 74 05 07          	or     %esi,0x7(%rbp,%rax,1)
     ffe:	06                   	(bad)
  if (tcp->syn) {
     fff:	31 06                	xor    %eax,(%rsi)
    1001:	03 45 90             	add    -0x70(%rbp),%eax
    1004:	05 03 06 03 3e       	add    $0x3e030603,%eax
    1009:	2e 05 07 03 b6 04    	cs add $0x4b60307,%eax
    100f:	74 05                	je     1016 <balancer_ingress+0x1016>
    1011:	05 ad 05 17 bc       	add    $0xbc1705ad,%eax
    1016:	05 15 08 59 05       	add    $0x5590815,%eax
    pckt->flags |= F_SYN_SET;
    101b:	1b 06                	sbb    (%rsi),%eax
    101d:	74 05                	je     1024 <balancer_ingress+0x1024>
    101f:	13 3c 05 03 06 67 05 	adc    0x5670603(,%rax,1),%edi
    1026:	17                   	(bad)
    1027:	06                   	(bad)
    1028:	c8 05 21 74          	enter  $0x2105,$0x74
  if (!is_icmp) {
    102c:	05 2d 74 05 03       	add    $0x305742d,%eax
    1031:	74 06                	je     1039 <balancer_ingress+0x1039>
    pckt->flow.port16[0] = tcp->source;
    1033:	4b 05 01 9f 05 11    	rex.WXB add $0x11059f01,%rax
    1039:	03 8e 02 66 05 15    	add    0x15056602(%rsi),%ecx
    103f:	67 05 11 06 74 05    	addr32 add $0x5740611,%eax
    1045:	0f 06                	clts
    pckt->flow.port16[1] = tcp->dest;
    1047:	2f                   	(bad)
    1048:	05 34 06 74 05       	add    $0x5740634,%eax
    104d:	0d 06 bb 05 1c       	or     $0x1c05bb06,%eax
    1052:	06                   	(bad)
    1053:	58                   	pop    %rax
    1054:	05 18 74 05 0f       	add    $0xf057418,%eax
    1059:	06                   	(bad)
    105a:	67 05 37 06 74 05    	addr32 add $0x5740637,%eax
    pckt->flow.port16[0] = tcp->dest;
    1060:	13 06                	adc    (%rsi),%eax
    1062:	bc 05 07 03 f1       	mov    $0xf1030705,%esp
    1067:	7d 08                	jge    1071 <balancer_ingress+0x1071>
    1069:	90                   	nop
    106a:	06                   	(bad)
    106b:	ac                   	lods   %ds:(%rsi),%al
    106c:	9e                   	sahf
    106d:	08 e4                	or     %ah,%ah
    106f:	74 2e                	je     109f <balancer_ingress+0x109f>
    1071:	08 f2                	or     %dh,%dl
    1073:	74 74                	je     10e9 <balancer_ingress+0x10e9>
    pckt->flow.port16[1] = tcp->source;
    1075:	05 14 06 73 05       	add    $0x5730614,%eax
    107a:	08 76 05             	or     %dh,0x5(%rsi)
    107d:	07                   	(bad)
    107e:	06                   	(bad)
    107f:	82                   	(bad)
    1080:	05 05 06 2f 05       	add    $0x52f0605,%eax
    1085:	07                   	(bad)
    1086:	30 05 05 91 05 17    	xor    %al,0x17059105(%rip)        # 1705a191 <bpf_xdp_adjust_head+0x170521f1>
  return true;
    108c:	06                   	(bad)
    108d:	74 05                	je     1094 <balancer_ingress+0x1094>
    108f:	07                   	(bad)
    1090:	06                   	(bad)
    1091:	a0 05 05 91 05 17 06 	movabs 0x574061705910505,%al
    1098:	74 05 
      return XDP_DROP;
    109a:	0d 06 03 88 02       	or     $0x2880306,%eax
    109f:	ba 05 0f 30 05       	mov    $0x5300f05,%edx
    10a4:	38 06                	cmp    %al,(%rsi)
    10a6:	74 03                	je     10ab <balancer_ingress+0x10ab>
    10a8:	ee                   	out    %al,(%dx)
  } else if (protocol == IPPROTO_UDP) {
    10a9:	78 ba                	js     1065 <balancer_ingress+0x1065>
    10ab:	05 0d 06 03 94       	add    $0x9403060d,%eax
    10b0:	07                   	(bad)
    10b1:	2e 05 2c 06 74 05    	cs add $0x574062c,%eax
    10b7:	09 06                	or     %eax,(%rsi)
    10b9:	bc 05 0b 30 05       	mov    $0x5300b05,%esp
    if (!parse_udp(data, data_end, is_ipv6, &pckt)) {
    10be:	35 06 74 05 3e       	xor    $0x3e057406,%eax
    10c3:	06                   	(bad)
    10c4:	bb 05 0b 06 74       	mov    $0x74060b05,%ebx
    10c9:	05 3c 74 05 0b       	add    $0xb05743c,%eax
    10ce:	06                   	(bad)
    10cf:	4b 05 29 06 74 05    	rex.WXB add $0x5740629,%rax
    10d5:	07                   	(bad)
    10d6:	06                   	(bad)
    10d7:	a0 05 12 06 58 05 09 	movabs 0x9206090558061205,%al
    10de:	06 92 
    10e0:	05 27 06 74 05       	add    $0x5740627,%eax
    10e5:	07                   	(bad)
    10e6:	06                   	(bad)
    10e7:	9f                   	lahf
    10e8:	05 09 59 05 29       	add    $0x29055909,%eax
    10ed:	06                   	(bad)
    10ee:	74 05                	je     10f5 <balancer_ingress+0x10f5>
    10f0:	0d 06 bc 05 07       	or     $0x705bc06,%eax
    10f5:	03 de                	add    %esi,%ebx
  bool is_icmp = !((pckt->flags & F_ICMP) == 0);
    10f7:	7d 08                	jge    1101 <balancer_ingress+0x1101>
    10f9:	90                   	nop
    10fa:	06                   	(bad)
    10fb:	ac                   	lods   %ds:(%rsi),%al
    10fc:	9e                   	sahf
    10fd:	08 e4                	or     %ah,%ah
    10ff:	74 2e                	je     112f <balancer_ingress+0x112f>
    1101:	08 f2                	or     %dh,%dl
    1103:	74 74                	je     1179 <balancer_ingress+0x1179>
    1105:	05 14 06 73 05       	add    $0x5730614,%eax
    110a:	08 76 05             	or     %dh,0x5(%rsi)
    110d:	07                   	(bad)
    110e:	06                   	(bad)
    110f:	82                   	(bad)
    1110:	05 05 06 2f 05       	add    $0x52f0605,%eax
  __u64 off = calc_offset(is_ipv6, is_icmp);
    1115:	07                   	(bad)
    1116:	30 05 05 91 05 17    	xor    %al,0x17059105(%rip)        # 1705a221 <bpf_xdp_adjust_head+0x17052281>
    111c:	06                   	(bad)
    111d:	74 05                	je     1124 <balancer_ingress+0x1124>
    111f:	07                   	(bad)
    1120:	06                   	(bad)
    1121:	a0 05 05 91 05 17 06 	movabs 0x374061705910505,%al
    1128:	74 03 
    112a:	f8                   	clc
    112b:	7a ba                	jp     10e7 <balancer_ingress+0x10e7>
    112d:	05 03 06 03 a5       	add    $0xa5030603,%eax
  __u64 off = sizeof(struct ethhdr);
    1132:	07                   	(bad)
    1133:	66 05 14 03          	add    $0x314,%ax
    1137:	0a 2e                	or     (%rsi),%ch
    1139:	05 12 06 74 05       	add    $0x5740612,%eax
  if (is_ipv6) {
    113e:	08 06                	or     %al,(%rsi)
    1140:	76 05                	jbe    1147 <balancer_ingress+0x1147>
    1142:	07                   	(bad)
    1143:	06                   	(bad)
    1144:	82                   	(bad)
    off += sizeof(struct ipv6hdr);
    1145:	05 0a 06 03 24       	add    $0x2403060a,%eax
    114a:	66 05 0e 06          	add    $0x60e,%ax
    114e:	82                   	(bad)
    114f:	05 13 66 05 1e       	add    $0x1e056613,%eax
    1154:	74 05                	je     115b <balancer_ingress+0x115b>
    1156:	2b 66 05             	sub    0x5(%rsi),%esp
    if (is_icmp) {
    1159:	0b 06                	or     (%rsi),%eax
    115b:	67 05 15 06 74 05    	addr32 add $0x5740615,%eax
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
    1161:	1b 2e                	sbb    (%rsi),%ebp
    1163:	05 09 06 65 05       	add    $0x5650609,%eax
    1168:	2c 68                	sub    $0x68,%al
    116a:	05 0d 03 e1 79       	add    $0x79e1030d,%eax
    116f:	02 31                	add    (%rcx),%dh
    1171:	01 05 26 06 c8 05    	add    %eax,0x5c80626(%rip)        # 5c8179d <bpf_xdp_adjust_head+0x5c797fd>
    off += sizeof(struct iphdr);
    1177:	30 74 05 0d          	xor    %dh,0xd(%rbp,%rax,1)
    117b:	74 05                	je     1182 <balancer_ingress+0x1182>
    117d:	0b 2e                	or     (%rsi),%ebp
    117f:	05 08 06 75 05       	add    $0x5750608,%eax
    1184:	07                   	(bad)
    1185:	06                   	(bad)
    if (is_icmp) {
    1186:	82                   	(bad)
    1187:	05 05 06 2f 05       	add    $0x52f0605,%eax
    118c:	14 5a                	adc    $0x5a,%al
    118e:	05 17 06 90 05       	add    $0x5900617,%eax
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
    1193:	28 ac 05 07 3c 05 10 	sub    %ch,0x10053c07(%rbp,%rax,1)
    119a:	06                   	(bad)
    119b:	2f                   	(bad)
    119c:	05 0e 06 e4 05       	add    $0x5e4060e,%eax
    11a1:	09 06                	or     %eax,(%rsi)
  return off;
    11a3:	75 05                	jne    11aa <balancer_ingress+0x11aa>
    11a5:	14 06                	adc    $0x6,%al
    11a7:	74 05                	je     11ae <balancer_ingress+0x11ae>
    11a9:	12 74 05 09          	adc    0x9(%rbp,%rax,1),%dh
  __u64 off = calc_offset(is_ipv6, is_icmp);
    11ad:	4a 05 23 9e 05 09    	rex.WX add $0x9059e23,%rax
  udp = data + off;
    11b3:	3c 05                	cmp    $0x5,%al
    11b5:	07                   	(bad)
    11b6:	06                   	(bad)
    11b7:	2f                   	(bad)
    11b8:	05 16 5a 05 05       	add    $0x5055a16,%eax
    11bd:	06                   	(bad)
    11be:	74 05                	je     11c5 <balancer_ingress+0x11c5>
    11c0:	14 74                	adc    $0x74,%al
    11c2:	05 09 06 4c 05       	add    $0x54c0609,%eax
  if (udp + 1 > data_end) {
    11c7:	12 06                	adc    (%rsi),%al
    11c9:	74 05                	je     11d0 <balancer_ingress+0x11d0>
    11cb:	07                   	(bad)
    11cc:	2e 05 16 06 67 05    	cs add $0x5670616,%eax
    11d2:	03 06                	add    (%rsi),%eax
    11d4:	66 05 14 74          	add    $0x7414,%ax
    11d8:	05 0b 06 3d 06       	add    $0x63d060b,%eax
    return false;
    11dd:	ac                   	lods   %ds:(%rsi),%al
    11de:	9e                   	sahf
    11df:	08 e4                	or     %ah,%ah
    11e1:	74 2e                	je     1211 <balancer_ingress+0x1211>
    11e3:	08 f2                	or     %dh,%dl
    11e5:	74 74                	je     125b <balancer_ingress+0x125b>
  if (!is_icmp) {
    11e7:	05 04 74 05 09       	add    $0x9057404,%eax
    11ec:	74 05                	je     11f3 <balancer_ingress+0x11f3>
    11ee:	05 06 03 93 06       	add    $0x6930306,%eax
    pckt->flow.port16[0] = udp->source;
    11f3:	3c 05                	cmp    $0x5,%al
    11f5:	2b 03                	sub    (%rbx),%eax
    11f7:	0c 2e                	or     $0x2e,%al
    11f9:	05 07 03 ae 7d       	add    $0x7dae0307,%eax
    11fe:	02 38                	add    (%rax),%bh
    1200:	01 05 0b 06 82 05    	add    %eax,0x582060b(%rip)        # 5821811 <bpf_xdp_adjust_head+0x5819871>
    pckt->flow.port16[1] = udp->dest;
    1206:	0e                   	(bad)
    1207:	66 05 1f ac          	add    $0xac1f,%ax
    120b:	05 2e 3c 05 07       	add    $0x7053c2e,%eax
    1210:	06                   	(bad)
    1211:	67 05 11 06 74 05    	addr32 add $0x5740611,%eax
    1217:	17                   	(bad)
    1218:	2e 05 2e 82 03 ed    	cs add $0xed03822e,%eax
    pckt->flow.port16[0] = udp->dest;
    121e:	7a 66                	jp     1286 <balancer_ingress+0x1286>
    1220:	05 09 06 03 28       	add    $0x28030609,%eax
    1225:	d6                   	(bad)
    1226:	05 07 a0 06 ac       	add    $0xac06a007,%eax
    122b:	9e                   	sahf
    122c:	08 e4                	or     %ah,%ah
    122e:	74 2e                	je     125e <balancer_ingress+0x125e>
    1230:	08 f2                	or     %dh,%dl
    pckt->flow.port16[1] = udp->source;
    1232:	74 74                	je     12a8 <balancer_ingress+0x12a8>
    1234:	05 14 06 73 05       	add    $0x5730614,%eax
    1239:	08 76 05             	or     %dh,0x5(%rsi)
    123c:	07                   	(bad)
    123d:	06                   	(bad)
    123e:	82                   	(bad)
    123f:	05 05 06 2f 05       	add    $0x52f0605,%eax
    1244:	0f bc 05 04 06 08 20 	bsf    0x20080604(%rip),%eax        # 2008184f <bpf_xdp_adjust_head+0x200798af>
  return true;
    124b:	05 0d 74 05 09       	add    $0x905740d,%eax
    1250:	06                   	(bad)
    1251:	40 05 08 06 74 05    	rex add $0x5740608,%eax
      return XDP_DROP;
    1257:	14 3c                	adc    $0x3c,%al
    1259:	05 12 74 05 29       	add    $0x29057412,%eax
    125e:	4a 05 07 66 05 05    	rex.WX add $0x5056607,%rax
    1264:	06                   	(bad)
    1265:	30 05 19 06 74 05    	xor    %al,0x5740619(%rip)        # 5741884 <bpf_xdp_adjust_head+0x57398e4>
    return XDP_PASS;
    126b:	1c 06                	sbb    $0x6,%al
    126d:	75 05                	jne    1274 <balancer_ingress+0x1274>
    126f:	1b 06                	sbb    (%rsi),%eax
    1271:	74 05                	je     1278 <balancer_ingress+0x1278>
    1273:	05 3c 05 19 74       	add    $0x7419053c,%eax
  if (is_ipv6) {
    1278:	05 03 06 4b 05       	add    $0x54b0603,%eax
    127d:	05 2f 05 19 06       	add    $0x619052f,%eax
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
    1282:	74 05                	je     1289 <balancer_ingress+0x1289>
    1284:	09 06                	or     %eax,(%rsi)
    1286:	9f                   	lahf
    1287:	05 1d 06 74 05       	add    $0x574061d,%eax
    128c:	09 74 05 07          	or     %esi,0x7(%rbp,%rax,1)
    1290:	06                   	(bad)
    1291:	31 06                	xor    %eax,(%rsi)
    1293:	03 45 90             	add    -0x70(%rbp),%eax
    1296:	05 03 06 03 3e       	add    $0x3e030603,%eax
    129b:	2e 05 07 03 d4 04    	cs add $0x4d40307,%eax
    vip.vip = pckt.flow.dst;
    12a1:	74 05                	je     12a8 <balancer_ingress+0x12a8>
    12a3:	1c cb                	sbb    $0xcb,%al
    12a5:	06                   	(bad)
    12a6:	ac                   	lods   %ds:(%rsi),%al
    12a7:	9e                   	sahf
    12a8:	02 23                	add    (%rbx),%ah
  vip.port = pckt.flow.port16[1];
    12aa:	12 74 2e 08          	adc    0x8(%rsi,%rbp,1),%dh
    12ae:	f2 74 74             	bnd je 1325 <balancer_ingress+0x1325>
    12b1:	05 0b 74 05 09       	add    $0x905740b,%eax
    12b6:	06                   	(bad)
    12b7:	75 06                	jne    12bf <balancer_ingress+0x12bf>
  vip.proto = pckt.flow.proto;
    12b9:	82                   	(bad)
    12ba:	05 19 06 67 05       	add    $0x5670619,%eax
    12bf:	32 06                	xor    (%rsi),%al
    12c1:	c8 05 43 74          	enter  $0x4305,$0x74
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
    12c5:	05 49 74 05 19       	add    $0x19057449,%eax
    12ca:	4a 05 0d 2e 05 0b    	rex.WX add $0xb052e0d,%rax
    12d0:	06                   	(bad)
    12d1:	75 06                	jne    12d9 <balancer_ingress+0x12d9>
    12d3:	82                   	(bad)
    12d4:	05 0a 06 69 05       	add    $0x569060a,%eax
    12d9:	0e                   	(bad)
    12da:	06                   	(bad)
    12db:	74 05                	je     12e2 <balancer_ingress+0x12e2>
    12dd:	0f 06                	clts
    12df:	75 05                	jne    12e6 <balancer_ingress+0x12e6>
    12e1:	27                   	(bad)
    12e2:	9f                   	lahf
    12e3:	06                   	(bad)
    12e4:	ac                   	lods   %ds:(%rsi),%al
    12e5:	9e                   	sahf
    12e6:	08 e4                	or     %ah,%ah
    12e8:	74 2e                	je     1318 <balancer_ingress+0x1318>
    12ea:	08 f2                	or     %dh,%dl
    12ec:	74 74                	je     1362 <balancer_ingress+0x1362>
    12ee:	05 1a 74 05 0d       	add    $0xd05741a,%eax
    12f3:	06                   	(bad)
    12f4:	75 06                	jne    12fc <balancer_ingress+0x12fc>
    12f6:	82                   	(bad)
    12f7:	05 0b 06 2f 05       	add    $0x52f060b,%eax
    12fc:	1a 06                	sbb    (%rsi),%al
    12fe:	74 05                	je     1305 <balancer_ingress+0x1305>
    1300:	07                   	(bad)
    1301:	06                   	(bad)
    1302:	a0 05 05 2f 05 03 2f 	movabs 0xa052f03052f0505,%al
    1309:	05 0a 
    130b:	03 c4                	add    %esp,%eax
    130d:	02 2e                	add    (%rsi),%ch
    130f:	05 09 06 82 05       	add    $0x5820609,%eax
    1314:	0b 06                	or     (%rsi),%eax
    1316:	67 05 1b 06 74 05    	addr32 add $0x574061b,%eax
    131c:	0b 3c 05 0f 06 67 05 	or     0x567060f(,%rax,1),%edi
    1323:	0d a0 06 ac 9e       	or     $0x9eac06a0,%eax
    1328:	08 e4                	or     %ah,%ah
    132a:	74 2e                	je     135a <balancer_ingress+0x135a>
    132c:	08 f2                	or     %dh,%dl
    132e:	74 74                	je     13a4 <balancer_ingress+0x13a4>
    1330:	05 1a 06 73 05       	add    $0x573061a,%eax
    1335:	0e                   	(bad)
    1336:	76 05                	jbe    133d <balancer_ingress+0x133d>
    1338:	0d 06 82 05 0b       	or     $0xb058206,%eax
    133d:	06                   	(bad)
    133e:	2f                   	(bad)
  if (!vip_info) {
    133f:	05 0d e6 05 18       	add    $0x1805e60d,%eax
    1344:	06                   	(bad)
    1345:	74 05                	je     134c <balancer_ingress+0x134c>
    1347:	0d 66 05 0b 06       	or     $0x60b0566,%eax
    134c:	30 05 19 06 74 05    	xor    %al,0x5740619(%rip)        # 574196b <bpf_xdp_adjust_head+0x57399cb>
    vip.port = 0;
    1352:	09 06                	or     %eax,(%rsi)
    1354:	9f                   	lahf
    1355:	05 0b 33 05 19       	add    $0x1905330b,%eax
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
    135a:	06                   	(bad)
    135b:	74 05                	je     1362 <balancer_ingress+0x1362>
    135d:	07                   	(bad)
    135e:	06                   	(bad)
    135f:	bc 05 28 2f 05       	mov    $0x52f2805,%esp
    1364:	32 06                	xor    (%rsi),%al
    1366:	74 05                	je     136d <balancer_ingress+0x136d>
    1368:	3b 66 05             	cmp    0x5(%rsi),%esp
    136b:	17                   	(bad)
    136c:	06                   	(bad)
    136d:	03 e4                	add    %esp,%esp
    136f:	78 02                	js     1373 <balancer_ingress+0x1373>
    1371:	3a 01                	cmp    (%rcx),%al
    1373:	05 08 08 75 75       	add    $0x75750808,%eax
    1378:	05 09 76 03 46       	add    $0x46037609,%eax
    137d:	08 82 05 07 a0 06    	or     %al,0x6a00705(%rdx)
    1383:	ac                   	lods   %ds:(%rsi),%al
    1384:	9e                   	sahf
    1385:	08 e4                	or     %ah,%ah
    1387:	74 2e                	je     13b7 <balancer_ingress+0x13b7>
    1389:	08 f2                	or     %dh,%dl
    138b:	74 74                	je     1401 <balancer_ingress+0x1401>
    138d:	05 14 06 73 05       	add    $0x5730614,%eax
    1392:	08 76 05             	or     %dh,0x5(%rsi)
    1395:	07                   	(bad)
    1396:	06                   	(bad)
    1397:	82                   	(bad)
    1398:	05 05 06 2f 05       	add    $0x52f0605,%eax
    139d:	0f bc 05 04 06 08 20 	bsf    0x20080604(%rip),%eax        # 200819a8 <bpf_xdp_adjust_head+0x20079a08>
    13a4:	05 0d 74 05 09       	add    $0x905740d,%eax
    13a9:	06                   	(bad)
    13aa:	40 05 08 06 74 05    	rex add $0x5740608,%eax
    13b0:	14 3c                	adc    $0x3c,%al
    13b2:	05 12 74 05 29       	add    $0x29057412,%eax
    13b7:	4a 05 07 66 05 05    	rex.WX add $0x5056607,%rax
    13bd:	06                   	(bad)
    13be:	30 05 19 06 74 05    	xor    %al,0x5740619(%rip)        # 57419dd <bpf_xdp_adjust_head+0x5739a3d>
    13c4:	1c 06                	sbb    $0x6,%al
    13c6:	75 05                	jne    13cd <balancer_ingress+0x13cd>
    13c8:	1b 06                	sbb    (%rsi),%eax
    13ca:	74 05                	je     13d1 <balancer_ingress+0x13d1>
    13cc:	05 3c 05 19 74       	add    $0x7419053c,%eax
    if (!vip_info) {
    13d1:	05 03 06 4b 05       	add    $0x54b0603,%eax
    13d6:	05 2f 05 19 06       	add    $0x619052f,%eax
      return XDP_PASS;
    13db:	74 05                	je     13e2 <balancer_ingress+0x13e2>
    13dd:	09 06                	or     %eax,(%rsi)
    13df:	9f                   	lahf
    13e0:	05 1d 06 74 05       	add    $0x574061d,%eax
    13e5:	09 74 05 07          	or     %esi,0x7(%rbp,%rax,1)
    13e9:	06                   	(bad)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
    13ea:	31 06                	xor    %eax,(%rsi)
    13ec:	03 45 90             	add    -0x70(%rbp),%eax
    13ef:	05 03 06 03 3e       	add    $0x3e030603,%eax
    13f4:	2e 05 01 75 05 0f    	cs add $0xf057501,%eax
    13fa:	03 27                	add    (%rdi),%esp
        !(vip_info->flags & F_HASH_SRC_DST_PORT)) {
    13fc:	66 05 07 03          	add    $0x307,%ax
    1400:	1f                   	(bad)
    1401:	82                   	(bad)
    1402:	05 19 c9 05 0a       	add    $0xa05c919,%eax
    1407:	06                   	(bad)
    1408:	66 05 09 06          	add    $0x609,%ax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
    140c:	84 05 13 06 74 05    	test   %al,0x5740613(%rip)        # 5741a25 <bpf_xdp_adjust_head+0x5739a85>
      pckt.flow.port16[1] = 0;
    1412:	19 2e                	sbb    %ebp,(%rsi)
    1414:	05 09 66 05 1e       	add    $0x1e056609,%eax
  if (data_end - data > MAX_PCKT_SIZE) {
    1419:	06                   	(bad)
    141a:	32 05 07 06 ac 05    	xor    0x5ac0607(%rip),%al        # 5ac1a27 <bpf_xdp_adjust_head+0x5ab9a87>
    1420:	1c 74                	sbb    $0x74,%al
    1422:	05 0e 06 4b 05       	add    $0x54b060e,%eax
    1427:	07                   	(bad)
    1428:	06                   	(bad)
    1429:	74 05                	je     1430 <balancer_ingress+0x1430>
    142b:	1c 06                	sbb    $0x6,%al
    142d:	08 14 05 22 06 74 05 	or     %dl,0x5740622(,%rax,1)
    return XDP_DROP;
    1434:	07                   	(bad)
    1435:	06                   	(bad)
    1436:	03 8d 7f 08 4a 05    	add    0x54a087f(%rbp),%ecx
    143c:	0f 92 05 09 06 08 12 	setb   0x12080609(%rip)        # 12081a4c <bpf_xdp_adjust_head+0x12079aac>
  __u32 stats_key = MAX_VIPS + LRU_CNTRS;
    1443:	06                   	(bad)
    1444:	75 05                	jne    144b <balancer_ingress+0x144b>
    1446:	14 06                	adc    $0x6,%al
    1448:	74 05                	je     144f <balancer_ingress+0x144f>
    144a:	0c 06                	or     $0x6,%al
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    144c:	80 05 05 06 58 05 19 	addb   $0x19,0x5580605(%rip)        # 5581a58 <bpf_xdp_adjust_head+0x5579ab8>
    1453:	06                   	(bad)
    1454:	87 05 24 06 74 05    	xchg   %eax,0x5740624(%rip)        # 5741a7e <bpf_xdp_adjust_head+0x5739ade>
    145a:	29 2e                	sub    %ebp,(%rsi)
    145c:	05 34 74 05 0c       	add    $0xc057434,%eax
    1461:	82                   	(bad)
    1462:	05 05 58 05 01       	add    $0x1055805,%eax
    1467:	06                   	(bad)
    1468:	68 05 30 03 eb       	push   $0xffffffffeb033005
    146d:	00 66 05             	add    %ah,0x5(%rsi)
    1470:	0a 06                	or     (%rsi),%al
    1472:	90                   	nop
    1473:	05 18 06 67 05       	add    $0x5670618,%eax
    1478:	15 06 74 05 2b       	adc    $0x2b057406,%eax
    147d:	74 05                	je     1484 <balancer_ingress+0x1484>
    147f:	09 66 05             	or     %esp,0x5(%rsi)
    1482:	10 06                	adc    %al,(%rsi)
    1484:	68 06 ac 9e 08       	push   $0x89eac06
    1489:	e4 74                	in     $0x74,%al
    148b:	2e 08 f2             	cs or  %dh,%dl
    148e:	74 74                	je     1504 <balancer_ingress+0x1504>
    1490:	05 0e 74 05 0a       	add    $0xa05740e,%eax
    1495:	06                   	(bad)
    1496:	75 05                	jne    149d <balancer_ingress+0x149d>
    1498:	09 06                	or     %eax,(%rsi)
    149a:	82                   	(bad)
    149b:	05 07 06 2f 05       	add    $0x52f0607,%eax
    14a0:	0c bc                	or     $0xbc,%al
    14a2:	05 0b 06 74 05       	add    $0x574060b,%eax
    14a7:	09 2e                	or     %ebp,(%rsi)
    14a9:	05 0d 06 67 05       	add    $0x567060d,%eax
    14ae:	09 06                	or     %eax,(%rsi)
    14b0:	74 06                	je     14b8 <balancer_ingress+0x14b8>
    14b2:	03 b7 7f 66 05 07    	add    0x705667f(%rdi),%esi
    14b8:	a0 06 ac 9e 08 e4 74 	movabs 0x82e74e4089eac06,%al
    14bf:	2e 08 
    14c1:	f2 74 74             	bnd je 1538 <balancer_ingress+0x1538>
    14c4:	05 14 06 73 05       	add    $0x5730614,%eax
  if (!data_stats) {
    14c9:	08 76 05             	or     %dh,0x5(%rsi)
    14cc:	07                   	(bad)
    14cd:	06                   	(bad)
    14ce:	82                   	(bad)
    14cf:	05 05 06 2f 05       	add    $0x52f0605,%eax
    return XDP_DROP;
    14d4:	03 30                	add    (%rax),%esi
    14d6:	05 15 06 74 05       	add    $0x5740615,%eax
    14db:	07                   	(bad)
    14dc:	06                   	(bad)
    14dd:	03 c7                	add    %edi,%eax
  data_stats->v1 += 1;
    14df:	00 ba 05 03 bc 05    	add    %bh,0x5bc0305(%rdx)
    14e5:	16                   	(bad)
    14e6:	2f                   	(bad)
    14e7:	05 03 06 66 05       	add    $0x5660603,%eax
    14ec:	14 74                	adc    $0x74,%al
    14ee:	05 0b 06 3d 06       	add    $0x63d060b,%eax
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
    14f3:	ac                   	lods   %ds:(%rsi),%al
    14f4:	9e                   	sahf
    14f5:	08 e4                	or     %ah,%ah
    14f7:	74 2e                	je     1527 <balancer_ingress+0x1527>
    14f9:	08 f2                	or     %dh,%dl
    14fb:	74 74                	je     1571 <balancer_ingress+0x1571>
    14fd:	05 04 74 05 09       	add    $0x9057404,%eax
    pckt.flow.port16[0] = 0;
    1502:	74 05                	je     1509 <balancer_ingress+0x1509>
    1504:	0a 06                	or     (%rsi),%al
    1506:	3d 05 08 06 74       	cmp    $0x74060805,%eax
  vip_num = vip_info->vip_num;
    150b:	05 07 4a 05 09       	add    $0x9054a07,%eax
    1510:	06                   	(bad)
    1511:	03 a3 7f 66 05 07    	add    0x705667f(%rbx),%esp
    1517:	a0 06 ac 9e 08 e4 74 	movabs 0x82e74e4089eac06,%al
    151e:	2e 08 
  __u32 cpu_num = bpf_get_smp_processor_id();
    1520:	f2 74 74             	bnd je 1597 <balancer_ingress+0x1597>
    1523:	05 14 06 73 05       	add    $0x5730614,%eax
    1528:	08 76 05             	or     %dh,0x5(%rsi)
    152b:	07                   	(bad)
    152c:	06                   	(bad)
    152d:	82                   	(bad)
    152e:	05 05 06 2f 05       	add    $0x52f0605,%eax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
    1533:	03 30                	add    (%rax),%esi
    1535:	05 15 06 74 05       	add    $0x5740615,%eax
    153a:	05 06 03 db 00       	add    $0xdb0306,%eax
    153f:	9e                   	sahf
    1540:	05 07 92 05 0f       	add    $0xf059207,%eax
    1545:	06                   	(bad)
    1546:	82                   	(bad)
    1547:	05 14 2e 05 1e       	add    $0x1e052e14,%eax
    154c:	74 05                	je     1553 <balancer_ingress+0x1553>
    154e:	24 2e                	and    $0x2e,%al
    1550:	05 34 66 05 07       	add    $0x7056634,%eax
    1555:	2e 05 09 06 91 05    	cs add $0x5910609,%eax
    155b:	1a 06                	sbb    (%rsi),%al
    155d:	ac                   	lods   %ds:(%rsi),%al
    155e:	05 09 3c 05 1b       	add    $0x1b053c09,%eax
    1563:	06                   	(bad)
    1564:	2f                   	(bad)
    1565:	05 19 06 74 05       	add    $0x5740619,%eax
    156a:	17                   	(bad)
    156b:	06                   	(bad)
    156c:	76 05                	jbe    1573 <balancer_ingress+0x1573>
    156e:	15 06 66 05 05       	adc    $0x5056606,%eax
    1573:	06                   	(bad)
    1574:	67 05 19 06 c8 05    	addr32 add $0x5c80619,%eax
    157a:	23 74 05 2f          	and    0x2f(%rbp,%rax,1),%esi
    157e:	74 05                	je     1585 <balancer_ingress+0x1585>
    1580:	05 74 05 03 06       	add    $0x6030574,%eax
    1585:	4c 05 0b 03 cd 06    	rex.WR add $0x6cd030b,%rax
    158b:	74 05                	je     1592 <balancer_ingress+0x1592>
    158d:	09 91 05 32 e8 05    	or     %edx,0x5e83205(%rcx)
    1593:	3c 06                	cmp    $0x6,%al
    1595:	74 05                	je     159c <balancer_ingress+0x159c>
    1597:	09 06                	or     %eax,(%rsi)
    1599:	03 ca                	add    %edx,%ecx
    159b:	7c 02                	jl     159f <balancer_ingress+0x159f>
    159d:	31 01                	xor    %eax,(%rcx)
    159f:	05 07 a0 06 ac       	add    $0xac06a007,%eax
    15a4:	9e                   	sahf
    15a5:	08 e4                	or     %ah,%ah
    15a7:	74 2e                	je     15d7 <balancer_ingress+0x15d7>
    15a9:	08 f2                	or     %dh,%dl
  if (!lru_map) {
    15ab:	74 74                	je     1621 <balancer_ingress+0x1621>
    15ad:	05 1a 06 73 05       	add    $0x573061a,%eax
    15b2:	08 76 05             	or     %dh,0x5(%rsi)
    15b5:	07                   	(bad)
    15b6:	06                   	(bad)
    15b7:	82                   	(bad)
    lru_map = &fallback_cache;
    15b8:	05 05 06 2f 05       	add    $0x52f0605,%eax
    15bd:	21 e6                	and    %esp,%esi
    15bf:	05 1a 91 05 39       	add    $0x3905911a,%eax
    15c4:	06                   	(bad)
    15c5:	90                   	nop
    15c6:	05 36 74 05 47       	add    $0x47057436,%eax
    __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
    15cb:	2e 05 1a 06 2f 05    	cs add $0x52f061a,%eax
    15d1:	39 06                	cmp    %eax,(%rsi)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
    15d3:	9e                   	sahf
    15d4:	05 36 74 05 47       	add    $0x47057436,%eax
    15d9:	3c 05                	cmp    $0x5,%al
    15db:	1a 06                	sbb    (%rsi),%al
    15dd:	2f                   	(bad)
    15de:	05 39 06 9e 05       	add    $0x59e0639,%eax
    15e3:	36 74 05             	ss je  15eb <balancer_ingress+0x15eb>
    15e6:	47 3c 05             	rex.RXB cmp $0x5,%al
    15e9:	1a 06                	sbb    (%rsi),%al
    15eb:	2f                   	(bad)
    15ec:	05 39 06 9e 05       	add    $0x59e0639,%eax
    15f1:	36 74 05             	ss je  15f9 <balancer_ingress+0x15f9>
    15f4:	49 ac                	rex.WB lods %ds:(%rsi),%al
    15f6:	05 11 06 2f 05       	add    $0x52f0611,%eax
    15fb:	14 06                	adc    $0x6,%al
    15fd:	08 12                	or     %dl,(%rdx)
    15ff:	05 27 74 05 2e       	add    $0x2e057427,%eax
    1604:	2e 05 2b 74 03 ac    	cs add $0xac03742b,%eax
    160a:	7b ac                	jnp    15b8 <balancer_ingress+0x15b8>
    160c:	05 08 06 03 cf       	add    $0xcf030608,%eax
    1611:	04 08                	add    $0x8,%al
    1613:	20 05 15 88 05 30    	and    %al,0x30058815(%rip)        # 30059e2e <bpf_xdp_adjust_head+0x30051e8e>
    1619:	06                   	(bad)
    161a:	ac                   	lods   %ds:(%rsi),%al
    161b:	05 2d ac 05 08       	add    $0x805ac2d,%eax
    1620:	58                   	pop    %rax
    1621:	05 31 06 83 05       	add    $0x5830631,%eax
    1626:	36 06                	ss (bad)
    1628:	74 05                	je     162f <balancer_ingress+0x162f>
    162a:	16                   	(bad)
    162b:	3c 05                	cmp    $0x5,%al
    162d:	2f                   	(bad)
    162e:	74 05                	je     1635 <balancer_ingress+0x1635>
    1630:	16                   	(bad)
    1631:	3c 05                	cmp    $0x5,%al
    1633:	08 58 05             	or     %bl,0x5(%rax)
    1636:	22 06                	and    (%rsi),%al
    1638:	83 05 30 06 08 12 05 	addl   $0x5,0x12080630(%rip)        # 12081c6f <bpf_xdp_adjust_head+0x12079ccf>
    163f:	33 08                	xor    (%rax),%ecx
    1641:	12 03                	adc    (%rbx),%al
    1643:	a9 7b ba 05 08       	test   $0x805ba7b,%eax
    1648:	03 d7                	add    %edi,%edx
    164a:	04 66                	add    $0x66,%al
    164c:	05 07 06 83 05       	add    $0x5830607,%eax
    if (!lru_stats) {
    1651:	1b c9                	sbb    %ecx,%ecx
    1653:	05 21 06 74 05       	add    $0x5740621,%eax
      return XDP_DROP;
    1658:	0b 3c 05 1c 06 67 06 	or     0x667061c(,%rax,1),%edi
    165f:	ac                   	lods   %ds:(%rsi),%al
    1660:	9e                   	sahf
    1661:	08 e4                	or     %ah,%ah
    1663:	74 2e                	je     1693 <balancer_ingress+0x1693>
    1665:	08 f2                	or     %dh,%dl
    lru_stats->v1 += 1;
    1667:	74 74                	je     16dd <balancer_ingress+0x16dd>
    1669:	05 0c 74 05 0a       	add    $0xa05740c,%eax
    166e:	06                   	(bad)
    166f:	75 05                	jne    1676 <balancer_ingress+0x1676>
    1671:	09 06                	or     %eax,(%rsi)
    1673:	82                   	(bad)
    1674:	05 07 06 2f 05       	add    $0x52f0607,%eax
  if ((vip_info->flags & F_QUIC_VIP)) {
    1679:	06                   	(bad)
    167a:	bc 05 14 06 74       	mov    $0x74061405,%esp
    167f:	05 03 06 76 05       	add    $0x5760603,%eax
    1684:	45 03 9f 03 9e 05 0b 	add    0xb059e03(%r15),%r11d
    168b:	06                   	(bad)
    168c:	74 05                	je     1693 <balancer_ingress+0x1693>
    bool is_icmp = (pckt.flags & F_ICMP);
    168e:	09 06                	or     %eax,(%rsi)
    1690:	2f                   	(bad)
    1691:	05 07 e8 05 16       	add    $0x1605e807,%eax
    1696:	06                   	(bad)
    1697:	74 05                	je     169e <balancer_ingress+0x169e>
    1699:	03 06                	add    (%rsi),%eax
    169b:	bc 05 0a 30 06       	mov    $0x6300a05,%esp
    16a0:	ac                   	lods   %ds:(%rsi),%al
    16a1:	9e                   	sahf
    16a2:	08 e4                	or     %ah,%ah
    16a4:	74 2e                	je     16d4 <balancer_ingress+0x16d4>
    if (is_icmp) {
    16a6:	08 f2                	or     %dh,%dl
    16a8:	74 74                	je     171e <balancer_ingress+0x171e>
    16aa:	05 08 74 06 76       	add    $0x76067408,%eax
    16af:	05 07 06 82 05       	add    $0x5820607,%eax
      __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
    16b4:	05 06 2f 05 10       	add    $0x10052f06,%eax
    16b9:	e7 06                	out    %eax,$0x6
    16bb:	ac                   	lods   %ds:(%rsi),%al
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    16bc:	9e                   	sahf
    16bd:	08 e4                	or     %ah,%ah
    16bf:	74 2e                	je     16ef <balancer_ingress+0x16ef>
    16c1:	08 f2                	or     %dh,%dl
    16c3:	74 74                	je     1739 <balancer_ingress+0x1739>
    16c5:	05 0e 74 05 08       	add    $0x805740e,%eax
    16ca:	06                   	(bad)
    16cb:	75 05                	jne    16d2 <balancer_ingress+0x16d2>
    16cd:	07                   	(bad)
    16ce:	06                   	(bad)
    16cf:	82                   	(bad)
    16d0:	05 05 06 2f 05       	add    $0x52f0605,%eax
    16d5:	03 e6                	add    %esi,%esp
    16d7:	05 12 06 74 05       	add    $0x5740612,%eax
    16dc:	15 06 9f 05 03       	adc    $0x3059f06,%eax
    16e1:	06                   	(bad)
    16e2:	90                   	nop
    16e3:	05 12 74 05 10       	add    $0x10057412,%eax
    16e8:	06                   	(bad)
    16e9:	85 06                	test   %eax,(%rsi)
    16eb:	ac                   	lods   %ds:(%rsi),%al
    16ec:	9e                   	sahf
    16ed:	08 e4                	or     %ah,%ah
    16ef:	74 2e                	je     171f <balancer_ingress+0x171f>
    16f1:	08 f2                	or     %dh,%dl
    16f3:	74 74                	je     1769 <balancer_ingress+0x1769>
    16f5:	05 0e 74 05 08       	add    $0x805740e,%eax
    16fa:	06                   	(bad)
    16fb:	75 05                	jne    1702 <balancer_ingress+0x1702>
    16fd:	07                   	(bad)
    16fe:	06                   	(bad)
    16ff:	82                   	(bad)
    1700:	05 05 06 2f 05       	add    $0x52f0605,%eax
    1705:	03 e6                	add    %esi,%esp
    1707:	05 12 06 74 05       	add    $0x5740612,%eax
    170c:	15 06 9f 05 03       	adc    $0x3059f06,%eax
    1711:	06                   	(bad)
    1712:	90                   	nop
    1713:	05 12 74 05 19       	add    $0x19057412,%eax
    1718:	06                   	(bad)
    1719:	89 05 17 06 74 05    	mov    %eax,0x5740617(%rip)        # 5741d36 <bpf_xdp_adjust_head+0x5739d96>
    171f:	07                   	(bad)
    1720:	06                   	(bad)
    1721:	75 05                	jne    1728 <balancer_ingress+0x1728>
    1723:	12 06                	adc    (%rsi),%al
    1725:	ac                   	lods   %ds:(%rsi),%al
    1726:	05 07 66 05 18       	add    $0x18056607,%eax
    172b:	06                   	(bad)
    172c:	67 05 1d 06 74 05    	addr32 add $0x574061d,%eax
    1732:	23 74 05 33          	and    0x33(%rbp,%rax,1),%esi
    1736:	66 05 38 74          	add    $0x7438,%ax
      if (!data_stats) {
    173a:	04 0d                	add    $0xd,%al
    173c:	05 07 06 03 96       	add    $0x96030607,%eax
        return XDP_DROP;
    1741:	78 02                	js     1745 <balancer_ingress+0x1745>
    1743:	39 01                	cmp    %eax,(%rcx)
    1745:	05 1c 06 c8 05       	add    $0x5c8061c,%eax
    174a:	07                   	(bad)
    174b:	74 9e                	je     16eb <balancer_ingress+0x16eb>
    174d:	05 05 06 2f 05       	add    $0x52f0605,%eax
      data_stats->v1 += 1;
    1752:	17                   	(bad)
    1753:	bc 05 1c 06 74       	mov    $0x74061c05,%esp
    1758:	05 08 3c 05 1b       	add    $0x1b053c08,%eax
    175d:	06                   	(bad)
    175e:	75 05                	jne    1765 <balancer_ingress+0x1765>
    1760:	20 06                	and    %al,(%rsi)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    1762:	74 05                	je     1769 <balancer_ingress+0x1769>
    1764:	0c 4a                	or     $0x4a,%al
    1766:	05 0d 06 75 05       	add    $0x575060d,%eax
    176b:	0b 06                	or     (%rsi),%eax
    176d:	74 05                	je     1774 <balancer_ingress+0x1774>
    176f:	0a 06                	or     (%rsi),%al
    1771:	75 05                	jne    1778 <balancer_ingress+0x1778>
    1773:	0f 06                	clts
    1775:	74 05                	je     177c <balancer_ingress+0x177c>
    1777:	08 4a 05             	or     %cl,0x5(%rdx)
    177a:	0d 06 75 05 12       	or     $0x12057506,%eax
    177f:	06                   	(bad)
    1780:	74 05                	je     1787 <balancer_ingress+0x1787>
    1782:	0b 4a 05             	or     0x5(%rdx),%ecx
    1785:	07                   	(bad)
    1786:	06                   	(bad)
    1787:	75 05                	jne    178e <balancer_ingress+0x178e>
    1789:	0f 06                	clts
  __u64 off = sizeof(struct ethhdr);
    178b:	74 05                	je     1792 <balancer_ingress+0x1792>
    178d:	15 4a 05 13 74       	adc    $0x7413054a,%eax
    1792:	05 1e 3c 05 21       	add    $0x21053c1e,%eax
  if (is_ipv6) {
    1797:	2e 05 29 74 05 2f    	cs add $0x2f057429,%eax
    179d:	4a 05 2d 74 05 38    	rex.WX add $0x3805742d,%rax
    struct icmp6hdr* icmp_hdr = data + off + sizeof(struct ipv6hdr);
    17a3:	3c 05                	cmp    $0x5,%al
    17a5:	3b 2e                	cmp    (%rsi),%ebp
    17a7:	05 40 74 05 46       	add    $0x46057440,%eax
    17ac:	4a 05 44 74 05 07    	rex.WX add $0x7057444,%rax
    17b2:	3c 05                	cmp    $0x5,%al
    17b4:	05 06 2f 05 0a       	add    $0xa052f06,%eax
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
    17b9:	bc 05 1b 06 74       	mov    $0x74061b05,%esp
    17be:	05 03 74 05 0a       	add    $0xa057403,%eax
    17c3:	06                   	(bad)
    17c4:	bb 05 1d 06 74       	mov    $0x74061d05,%ebx
    17c9:	05 03 74 06 c9       	add    $0xc9067403,%eax
    17ce:	05 14 06 74 05       	add    $0x5740614,%eax
        (icmp_hdr->icmp6_code == ICMPV6_PORT_UNREACH));
    17d3:	07                   	(bad)
    17d4:	06                   	(bad)
    17d5:	68 05 0b c9 05       	push   $0x5c90b05
    17da:	1b 75 05             	sbb    0x5(%rbp),%esi
    17dd:	31 06                	xor    %eax,(%rsi)
    17df:	ac                   	lods   %ds:(%rsi),%al
    17e0:	05 46 9e 04 0e       	add    $0xe049e46,%eax
    17e5:	05 03 06 03 57       	add    $0x57030603,%eax
    17ea:	08 9e 05 0c 06 74    	or     %bl,0x74060c05(%rsi)
    return (
    17f0:	05 03 06 67 05       	add    $0x5670603,%eax
    17f5:	0c 06                	or     $0x6,%al
    struct icmphdr* icmp_hdr = data + off + sizeof(struct iphdr);
    17f7:	74 05                	je     17fe <balancer_ingress+0x17fe>
    17f9:	03 06                	add    (%rsi),%eax
    17fb:	75 05                	jne    1802 <balancer_ingress+0x1802>
    17fd:	0c 06                	or     $0x6,%al
    17ff:	74 05                	je     1806 <balancer_ingress+0x1806>
    1801:	0e                   	(bad)
    1802:	06                   	(bad)
    1803:	75 05                	jne    180a <balancer_ingress+0x180a>
    1805:	14 06                	adc    $0x6,%al
    1807:	66 05 12 74          	add    $0x7412,%ax
    180b:	05 03 2e 05 0c       	add    $0xc052e03,%eax
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    1810:	74 04                	je     1816 <balancer_ingress+0x1816>
    1812:	0d 05 13 06 03       	or     $0x3061305,%eax
    1817:	27                   	(bad)
    1818:	3c 05                	cmp    $0x5,%al
    181a:	1d 06 66 05 11       	sbb    $0x11056606,%eax
    181f:	4a 05 03 06 75 05    	rex.WX add $0x5750603,%rax
    1825:	0b 59 05             	or     0x5(%rcx),%ebx
        (icmp_hdr->code == ICMP_HOST_UNREACH));
    1828:	1b 75 05             	sbb    0x5(%rbp),%esi
    182b:	31 06                	xor    %eax,(%rsi)
    182d:	ac                   	lods   %ds:(%rsi),%al
    182e:	05 3c 74 05 41       	add    $0x4105743c,%eax
    1833:	2e 04 0e             	cs add $0xe,%al
    1836:	05 03 06 03 53       	add    $0x53030603,%eax
    183b:	08 9e 05 0c 06 74    	or     %bl,0x74060c05(%rsi)
    1841:	05 03 06 67 05       	add    $0x5670603,%eax
    return (
    1846:	0c 06                	or     $0x6,%al
    1848:	74 05                	je     184f <balancer_ingress+0x184f>
    184a:	03 06                	add    (%rsi),%eax
    184c:	75 05                	jne    1853 <balancer_ingress+0x1853>
    184e:	0c 06                	or     $0x6,%al
    1850:	74 05                	je     1857 <balancer_ingress+0x1857>
    1852:	0e                   	(bad)
    1853:	06                   	(bad)
    1854:	75 05                	jne    185b <balancer_ingress+0x185b>
    1856:	14 06                	adc    $0x6,%al
        data_stats->v2 += 1;
    1858:	66 05 12 74          	add    $0x7412,%ax
    185c:	05 03 2e 05 0c       	add    $0xc052e03,%eax
    1861:	74 04                	je     1867 <balancer_ingress+0x1867>
    1863:	0d 05 13 06 03       	or     $0x3061305,%eax
    1868:	2b 3c 05 11 06 66 06 	sub    0x6660611(,%rax,1),%edi
    } else {
    186f:	77 05                	ja     1876 <balancer_ingress+0x1876>
      __u32 quic_packets_stats_key = 0;
    1871:	17                   	(bad)
    1872:	06                   	(bad)
    1873:	74 05                	je     187a <balancer_ingress+0x187a>
    1875:	1d 74 05 22 4a       	sbb    $0x4a220574,%eax
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
    187a:	05 29 74 05 35       	add    $0x35057429,%eax
    187f:	74 05                	je     1886 <balancer_ingress+0x1886>
    1881:	42 74 04             	rex.X je 1888 <balancer_ingress+0x1888>
    1884:	0e                   	(bad)
    1885:	05 03 02 2f 12       	add    $0x122f0203,%eax
    188a:	05 11 74 05 0a       	add    $0xa057411,%eax
    188f:	06                   	(bad)
    1890:	9f                   	lahf
    1891:	05 10 06 74 05       	add    $0x5740610,%eax
    1896:	03 4a 05             	add    0x5(%rdx),%ecx
    1899:	15 06 ae 05 18       	adc    $0x1805ae06,%eax
    189e:	06                   	(bad)
    189f:	74 05                	je     18a6 <balancer_ingress+0x18a6>
    18a1:	20 58 05             	and    %bl,0x5(%rax)
    18a4:	14 3c                	adc    $0x3c,%al
    18a6:	05 03 2e 05 12       	add    $0x12052e03,%eax
    18ab:	74 05                	je     18b2 <balancer_ingress+0x18b2>
    18ad:	18 06                	sbb    %al,(%rsi)
    18af:	bb 05 1b 06 74       	mov    $0x74061b05,%ebx
    18b4:	05 23 3c 05 17       	add    $0x17053c23,%eax
    18b9:	3c 05                	cmp    $0x5,%al
    18bb:	03 2e                	add    (%rsi),%ebp
    18bd:	05 15 74 05 13       	add    $0x13057415,%eax
    18c2:	06                   	(bad)
    18c3:	40 05 03 06 66 05    	rex add $0x5660603,%eax
    18c9:	11 74 05 17          	adc    %esi,0x17(%rbp,%rax,1)
    18cd:	06                   	(bad)
    18ce:	3d 06 03 a4 7f       	cmp    $0x7fa40306,%eax
    18d3:	08 3c 03             	or     %bh,(%rbx,%rax,1)
    18d6:	dc 00                	faddl  (%rax)
    18d8:	66 05 03 3c          	add    $0x3c03,%ax
    18dc:	05 15 74 05 03       	add    $0x3057415,%eax
    18e1:	06                   	(bad)
    18e2:	4b 05 13 06 74 05    	rex.WXB add $0x5740613,%rax
    18e8:	0a 06                	or     (%rsi),%al
    18ea:	4b 05 21 06 74 05    	rex.WXB add $0x5740621,%rax
      struct lb_quic_packets_stats* quic_packets_stats =
    18f0:	03 74 05 0a          	add    0xa(%rbp,%rax,1),%esi
    18f4:	06                   	(bad)
      if (!quic_packets_stats) {
    18f5:	e5 05                	in     $0x5,%eax
    18f7:	21 06                	and    %eax,(%rsi)
    18f9:	74 05                	je     1900 <balancer_ingress+0x1900>
    18fb:	03 74 04 0d          	add    0xd(%rsp,%rax,1),%esi
        return XDP_DROP;
    18ff:	06                   	(bad)
    1900:	03 76 e4             	add    -0x1c(%rsi),%esi
    1903:	04 00                	add    $0x0,%al
    1905:	05 09 03 cf 07       	add    $0x7cf0309,%eax
    190a:	74 05                	je     1911 <balancer_ingress+0x1911>
    190c:	07                   	(bad)
    190d:	91                   	xchg   %eax,%ecx
      struct quic_parse_result qpr = parse_quic(data, data_end, is_ipv6, &pckt);
    190e:	05 03 e6 05 18       	add    $0x1805e603,%eax
    1913:	59                   	pop    %rcx
    1914:	05 1d 06 74 05       	add    $0x574061d,%eax
    1919:	2a 74 05 2f          	sub    0x2f(%rbp,%rax,1),%dh
    191d:	74 04                	je     1923 <balancer_ingress+0x1923>
    191f:	0d 05 28 06 03       	or     $0x3062805,%eax
    1924:	bb 78 02 30 01       	mov    $0x1300278,%ebx
    1929:	05 3e 06 ac 05       	add    $0x5ac063e,%eax
    192e:	49 74 04             	rex.WB je 1935 <balancer_ingress+0x1935>
    1931:	0e                   	(bad)
    1932:	05 15 06 03 48       	add    $0x48030615,%eax
    1937:	e4 06                	in     $0x6,%al
    1939:	03 55 08             	add    0x8(%rbp),%edx
    193c:	3c 05                	cmp    $0x5,%al
    193e:	09 03                	or     %eax,(%rbx)
    1940:	2b 66 05             	sub    0x5(%rsi),%esp
    1943:	0d 06 67 05 10       	or     $0x10056706,%eax
  struct quic_parse_result result = {
    1948:	e5 05                	in     $0x5,%eax
    194a:	0d 06 66 05 19       	or     $0x19056606,%eax
    194f:	06                   	(bad)
    1950:	d7                   	xlat   %ds:(%rbx)
    1951:	05 24 06 9e 04       	add    $0x49e0624,%eax
    1956:	0d 05 09 06 03       	or     $0x3060905,%eax
    195b:	35 58 67 05 07       	xor    $0x7056758,%eax
  bool is_icmp = (pckt->flags & F_ICMP);
    1960:	ae                   	scas   %es:(%rdi),%al
    1961:	05 1c 06 c8 05       	add    $0x5c8061c,%eax
    1966:	07                   	(bad)
    1967:	74 9e                	je     1907 <balancer_ingress+0x1907>
    1969:	05 05 06 2f 05       	add    $0x52f0605,%eax
    196e:	17                   	(bad)
    196f:	bc 05 1c 06 74       	mov    $0x74061c05,%esp
    1974:	05 08 3c 05 1b       	add    $0x1b053c08,%eax
  __u64 off = calc_offset(is_ipv6, is_icmp);
    1979:	06                   	(bad)
    197a:	75 05                	jne    1981 <balancer_ingress+0x1981>
    197c:	20 06                	and    %al,(%rsi)
    197e:	74 05                	je     1985 <balancer_ingress+0x1985>
    1980:	0c 4a                	or     $0x4a,%al
    1982:	05 0d 06 75 05       	add    $0x575060d,%eax
    1987:	0b 06                	or     (%rsi),%eax
    1989:	74 05                	je     1990 <balancer_ingress+0x1990>
    198b:	09 06                	or     %eax,(%rsi)
    198d:	75 05                	jne    1994 <balancer_ingress+0x1994>
    198f:	0e                   	(bad)
    1990:	06                   	(bad)
    1991:	74 05                	je     1998 <balancer_ingress+0x1998>
    1993:	07                   	(bad)
    1994:	4a 05 0d 06 75 05    	rex.WX add $0x575060d,%rax
  __u64 off = sizeof(struct ethhdr);
    199a:	12 06                	adc    (%rsi),%al
    199c:	74 05                	je     19a3 <balancer_ingress+0x19a3>
    199e:	0b 4a 05             	or     0x5(%rdx),%ecx
  if (is_ipv6) {
    19a1:	07                   	(bad)
    19a2:	06                   	(bad)
    19a3:	75 05                	jne    19aa <balancer_ingress+0x19aa>
    19a5:	0f 06                	clts
    19a7:	74 05                	je     19ae <balancer_ingress+0x19ae>
    19a9:	15 4a 05 13 74       	adc    $0x7413054a,%eax
    off += sizeof(struct ipv6hdr);
    19ae:	05 1e 3c 05 21       	add    $0x21053c1e,%eax
    19b3:	2e 05 29 74 05 2f    	cs add $0x2f057429,%eax
    19b9:	4a 05 2d 74 05 38    	rex.WX add $0x3805742d,%rax
    if (is_icmp) {
    19bf:	3c 05                	cmp    $0x5,%al
    19c1:	3b 2e                	cmp    (%rsi),%ebp
    19c3:	05 3f 74 05 45       	add    $0x4505743f,%eax
      off += (sizeof(struct icmp6hdr) + sizeof(struct ipv6hdr));
    19c8:	4a 05 43 74 05 07    	rex.WX add $0x7057443,%rax
    19ce:	3c 05                	cmp    $0x5,%al
    19d0:	05 06 2f 05 0a       	add    $0xa052f06,%eax
    19d5:	bc 05 1b 06 74       	mov    $0x74061b05,%esp
    off += sizeof(struct iphdr);
    19da:	05 03 74 05 0a       	add    $0xa057403,%eax
    19df:	06                   	(bad)
    19e0:	bb 05 1d 06 74       	mov    $0x74061d05,%ebx
    19e5:	05 03 74 06 c9       	add    $0xc9067403,%eax
    19ea:	05 14 06 74 05       	add    $0x5740614,%eax
    if (is_icmp) {
    19ef:	11 06                	adc    %eax,(%rsi)
    19f1:	68 05 16 06 74       	push   $0x74061605
      off += (sizeof(struct icmphdr) + sizeof(struct iphdr));
    19f6:	05 1c 74 05 21       	add    $0x2105741c,%eax
    19fb:	4a 05 29 66 05 2e    	rex.WX add $0x2e056629,%rax
    1a01:	74 05                	je     1a08 <balancer_ingress+0x1a08>
    1a03:	33 2e                	xor    (%rsi),%ebp
    1a05:	04 0e                	add    $0xe,%al
    1a07:	05 09 06 03 43       	add    $0x43030609,%eax
  return off;
    1a0c:	08 ac 05 03 83 05 10 	or     %ch,0x10058303(%rbp,%rax,1)
  __u64 off = calc_offset(is_ipv6, is_icmp);
    1a13:	06                   	(bad)
    1a14:	4a 05 03 06 9f 05    	rex.WX add $0x59f0603,%rax
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1a1a:	0c 06                	or     $0x6,%al
    1a1c:	4a 05 03 06 9f 05    	rex.WX add $0x59f0603,%rax
    1a22:	11 06                	adc    %eax,(%rsi)
    1a24:	4a 05 13 06 67 05    	rex.WX add $0x5670613,%rax
    1a2a:	03 06                	add    (%rsi),%eax
    1a2c:	3c 05                	cmp    $0x5,%al
    1a2e:	11 4a 05             	adc    %ecx,0x5(%rdx)
    1a31:	03 06                	add    (%rsi),%eax
    1a33:	3d 05 0e 06 4a       	cmp    $0x4a060e05,%eax
    return result;
    1a38:	06                   	(bad)
    1a39:	68 05 03 06 3c       	push   $0x3c060305
  __u8* quic_data = data + off + sizeof(struct udphdr);
    1a3e:	05 0c 4a 05 12       	add    $0x12054a0c,%eax
    1a43:	06                   	(bad)
    1a44:	40 06                	rex (bad)
    1a46:	03 bd 7f 08 4a 03    	add    0x34a087f(%rbp),%edi
    1a4c:	c3                   	ret
    1a4d:	00 66 05             	add    %ah,0x5(%rsi)
    1a50:	03 3c 05 10 4a 05 03 	add    0x3054a10(,%rax,1),%edi
  __u8* pkt_type = quic_data;
    1a57:	06                   	(bad)
    1a58:	4b 05 0b 06 4a 05    	rex.WXB add $0x54a060b,%rax
    1a5e:	10 06                	adc    %al,(%rsi)
    1a60:	67 05 03 06 3c 05    	addr32 add $0x53c0603,%eax
  __u8* connId = NULL;
    1a66:	0e                   	(bad)
    1a67:	4a 05 10 06 3d 05    	rex.WX add $0x53d0610,%rax
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    1a6d:	03 06                	add    (%rsi),%eax
    1a6f:	3c 05                	cmp    $0x5,%al
    1a71:	0e                   	(bad)
    1a72:	4a 05 03 06 3d 05    	rex.WX add $0x53d0603,%rax
    1a78:	0c 06                	or     $0x6,%al
    1a7a:	4a 05 14 06 4b 04    	rex.WX add $0x44b0614,%rax
    1a80:	0c 05                	or     $0x5,%al
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1a82:	21 03                	and    %eax,(%rbx)
    1a84:	6d                   	insl   (%dx),%es:(%rdi)
    1a85:	f2 05 0a 06 4a 05    	repnz add $0x54a060a,%eax
    1a8b:	0c 06                	or     $0x6,%al
    1a8d:	4c 05 13 06 74 05    	rex.WR add $0x5740613,%rax
    1a93:	15 4a 05 03 4a       	adc    $0x4a03054a,%eax
      return result;
    1a98:	05 1b 06 2f 05       	add    $0x52f061b,%eax
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1a9d:	0e                   	(bad)
    1a9e:	06                   	(bad)
    1a9f:	e4 05                	in     $0x5,%al
    1aa1:	06                   	(bad)
    1aa2:	58                   	pop    %rax
    1aa3:	05 0b 4a 05 33       	add    $0x33054a0b,%eax
    1aa8:	06                   	(bad)
    1aa9:	65 05 03 06 90 05    	gs add $0x5900603,%eax
      result.is_initial = true;
    1aaf:	1d 06 31 05 1c       	sbb    $0x1c053106,%eax
      return result;
    1ab4:	06                   	(bad)
    1ab5:	4a 05 0a 06 03 67    	rex.WX add $0x6703060a,%rax
    struct quic_long_header* long_header = (struct quic_long_header*)quic_data;
    1abb:	74 05                	je     1ac2 <balancer_ingress+0x1ac2>
    1abd:	11 06                	adc    %eax,(%rsi)
    1abf:	74 05                	je     1ac6 <balancer_ingress+0x1ac6>
    1ac1:	03 4a 05             	add    0x5(%rdx),%ecx
    1ac4:	09 06                	or     %eax,(%rsi)
    1ac6:	2f                   	(bad)
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1ac7:	05 0e 06 4a 05       	add    $0x54a060e,%eax
    1acc:	09 82 05 0f 06 2f    	or     %eax,0x2f060f05(%rdx)
    1ad2:	05 14 06 4a 05       	add    $0x54a0614,%eax
      return result;
    1ad7:	21 66 05             	and    %esp,0x5(%rsi)
    1ada:	26 4a 05 1e 4a 05 0c 	es rex.WX add $0xc054a1e,%rax
    connId = long_header->dst_connection_id;
    1ae1:	3c 05                	cmp    $0x5,%al
    1ae3:	17                   	(bad)
    1ae4:	06                   	(bad)
    1ae5:	48 05 03 06 90 05    	add    $0x5900603,%rax
    1aeb:	0b 06                	or     (%rsi),%eax
    1aed:	32 05 0a 06 4a 05    	xor    0x54a060a(%rip),%al        # 54a20fd <bpf_xdp_adjust_head+0x549a15d>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    1af3:	0b 06                	or     (%rsi),%eax
    1af5:	03 15 4a 05 04 06    	add    0x604054a(%rip),%edx        # 6042045 <bpf_xdp_adjust_head+0x603a0a5>
    1afb:	58                   	pop    %rax
    1afc:	05 09 4a 04 0e       	add    $0xe044a09,%eax
    1b01:	05 10 06 03 0f       	add    $0xf030610,%eax
      return result;
    1b06:	3c 05                	cmp    $0x5,%al
    1b08:	03 06                	add    (%rsi),%eax
    connId = ((struct quic_short_header*)quic_data)->connection_id;
    1b0a:	74 05                	je     1b11 <balancer_ingress+0x1b11>
    1b0c:	0e                   	(bad)
    1b0d:	4a 04 0d             	rex.WX add $0xd,%al
    1b10:	05 03 06 03 2e       	add    $0x2e030603,%eax
    1b15:	4a 04 00             	rex.WX add $0x0,%al
    1b18:	05 09 03 b1 07       	add    $0x7b10309,%eax
  if (!connId) {
    1b1d:	74 05                	je     1b24 <balancer_ingress+0x1b24>
    1b1f:	07                   	(bad)
    1b20:	91                   	xchg   %eax,%ecx
    1b21:	06                   	(bad)
    1b22:	03 d7                	add    %edi,%edx
    1b24:	77 ba                	ja     1ae0 <balancer_ingress+0x1ae0>
    return result;
    1b26:	05 03 06 03 ad       	add    $0xad030603,%eax
  __u8 connIdVersion = (connId[0] >> 6);
    1b2b:	08 2e                	or     %ch,(%rsi)
    1b2d:	05 01 9f 05 05       	add    $0x5059f01,%eax
    1b32:	03 13                	add    (%rbx),%edx
    1b34:	66 05 18 ad          	add    $0xad18,%ax
    1b38:	05 0e 06 9e 05       	add    $0x59e060e,%eax
  result.cid_version = connIdVersion;
    1b3d:	1b 06                	sbb    (%rsi),%eax
    1b3f:	67 05 20 06 74 05    	addr32 add $0x5740620,%eax
    1b45:	1d 06 03 e6 7c       	sbb    $0x7ce60306,%eax
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    1b4a:	08 9e 05 22 06 74    	or     %bl,0x74062205(%rsi)
    1b50:	05 09 3c 05 21       	add    $0x21053c09,%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    1b55:	06                   	(bad)
    1b56:	75 05                	jne    1b5d <balancer_ingress+0x1b5d>
    1b58:	26 06                	es (bad)
    1b5a:	74 05                	je     1b61 <balancer_ingress+0x1b61>
    1b5c:	09 4a 05             	or     %ecx,0x5(%rdx)
    1b5f:	1b 06                	sbb    (%rsi),%eax
    1b61:	76 05                	jbe    1b68 <balancer_ingress+0x1b68>
    1b63:	1d ad 05 19 02       	sbb    $0x21905ad,%eax
    1b68:	38 13                	cmp    %dl,(%rbx)
    1b6a:	05 09 03 09 08       	add    $0x8090309,%eax
    1b6f:	d6                   	(bad)
    1b70:	a0 05 19 ae 05 36 06 	movabs 0x574063605ae1905,%al
    1b77:	74 05 
    1b79:	3c 74                	cmp    $0x74,%al
    1b7b:	05 46 74 04 09       	add    $0x9047446,%eax
    1b80:	05 07 06 03 94       	add    $0x94030607,%eax
    result.server_id =
    1b85:	7e 02                	jle    1b89 <balancer_ingress+0x1b89>
    1b87:	5b                   	pop    %rbx
    1b88:	01 05 0c c9 05 11    	add    %eax,0x1105c90c(%rip)        # 1105e49a <bpf_xdp_adjust_head+0x110564fa>
    return result;
    1b8e:	06                   	(bad)
    1b8f:	74 05                	je     1b96 <balancer_ingress+0x1b96>
  } else if (connIdVersion == QUIC_CONNID_VERSION_V2) {
    1b91:	0a 74 05 09          	or     0x9(%rbp,%rax,1),%dh
    1b95:	06                   	(bad)
    1b96:	75 05                	jne    1b9d <balancer_ingress+0x1b9d>
    1b98:	0e                   	(bad)
    1b99:	06                   	(bad)
    1b9a:	74 05                	je     1ba1 <balancer_ingress+0x1ba1>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1b9c:	14 4a                	adc    $0x4a,%al
    1b9e:	05 12 74 05 09       	add    $0x9057412,%eax
    1ba3:	3c 05                	cmp    $0x5,%al
    1ba5:	07                   	(bad)
    1ba6:	06                   	(bad)
    1ba7:	2f                   	(bad)
    1ba8:	05 0d e7 05 11       	add    $0x1105e70d,%eax
    1bad:	ad                   	lods   %ds:(%rsi),%eax
    1bae:	05 17 06 74 05       	add    $0x5740617,%eax
    1bb3:	06                   	(bad)
    1bb4:	3c 05                	cmp    $0x5,%al
    1bb6:	0f 74 05 19 06 2f 05 	pcmpeqb 0x52f0619(%rip),%mm0        # 52f21d6 <bpf_xdp_adjust_head+0x52ea236>
    1bbd:	18 06                	sbb    %al,(%rsi)
    1bbf:	74 05                	je     1bc6 <balancer_ingress+0x1bc6>
    1bc1:	05 2e 05 16 74       	add    $0x7416052e,%eax
    1bc6:	05 12 06 3f 05       	add    $0x53f0612,%eax
    1bcb:	18 06                	sbb    %al,(%rsi)
    return result;
    1bcd:	74 05                	je     1bd4 <balancer_ingress+0x1bd4>
  } else if (connIdVersion == QUIC_CONNID_VERSION_V3) {
    1bcf:	12 4a 05             	adc    0x5(%rdx),%cl
    1bd2:	21 3c 05 27 3c 05 11 	and    %edi,0x11053c27(,%rax,1)
    1bd9:	58                   	pop    %rax
    1bda:	05 05 2e 05 0f       	add    $0xf052e05,%eax
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1bdf:	74 05                	je     1be6 <balancer_ingress+0x1be6>
    1be1:	11 06                	adc    %eax,(%rsi)
    1be3:	3d 05 1f 06 ac       	cmp    $0xac061f05,%eax
    1be8:	05 31 ac 05 37       	add    $0x3705ac31,%eax
    1bed:	3c 05                	cmp    $0x5,%al
    1bef:	1b 3c 05 11 2e 05 05 	sbb    0x5052e11(,%rax,1),%edi
    1bf6:	2e 05 0f 74 05 12    	cs add $0x1205740f,%eax
    1bfc:	06                   	(bad)
    1bfd:	3e 06                	ds (bad)
    1bff:	03 a3 7c 08 74 03    	add    0x374087c(%rbx),%esp
    1c05:	dd 03                	fldl   (%rbx)
    1c07:	66 05 06 3c          	add    $0x3c06,%ax
    1c0b:	05 10 74 06 3d       	add    $0x3d067410,%eax
    1c10:	05 17 06 74 05       	add    $0x5740617,%eax
    1c15:	06                   	(bad)
    result.server_id =
    1c16:	74 05                	je     1c1d <balancer_ingress+0x1c1d>
    1c18:	0d 74 05 0a 06       	or     $0x60a0574,%eax
  return result;
    1c1d:	67 05 09 06 74 05    	addr32 add $0x5740609,%eax
}
    1c23:	13 3c 05 09 3c 05 07 	adc    0x7053c09(,%rax,1),%edi
    1c2a:	06                   	(bad)
    1c2b:	30 05 11 e5 05 10    	xor    %al,0x1005e511(%rip)        # 10060142 <bpf_xdp_adjust_head+0x100581a2>
      if (qpr.server_id > 0) {
    1c31:	06                   	(bad)
    1c32:	74 05                	je     1c39 <balancer_ingress+0x1c39>
    1c34:	1a 3c 05 10 3c 05 07 	sbb    0x7053c10(,%rax,1),%bh
        increment_quic_cid_version_stats(quic_packets_stats, qpr.cid_version);
    1c3b:	06                   	(bad)
    1c3c:	2f                   	(bad)
    1c3d:	05 0e e6 05 20       	add    $0x2005e60e,%eax
    1c42:	06                   	(bad)
    1c43:	74 05                	je     1c4a <balancer_ingress+0x1c4a>
    1c45:	07                   	(bad)
    1c46:	74 05                	je     1c4d <balancer_ingress+0x1c4d>
    1c48:	0e                   	(bad)
    1c49:	06                   	(bad)
    1c4a:	e5 05                	in     $0x5,%eax
    1c4c:	20 06                	and    %al,(%rsi)
    1c4e:	74 05                	je     1c55 <balancer_ingress+0x1c55>
    1c50:	07                   	(bad)
    1c51:	74 05                	je     1c58 <balancer_ingress+0x1c58>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1c53:	03 06                	add    (%rsi),%eax
    1c55:	f4                   	hlt
    1c56:	05 0b 59 05 10       	add    $0x1005590b,%eax
    1c5b:	06                   	(bad)
    1c5c:	74 05                	je     1c63 <balancer_ingress+0x1c63>
    1c5e:	09 74 06 75          	or     %esi,0x75(%rsi,%rax,1)
    quic_packets_stats->cid_v1 += 1;
    1c62:	05 0d 06 74 05       	add    $0x574060d,%eax
    1c67:	13 4a 05             	adc    0x5(%rdx),%ecx
    1c6a:	11 74 05 09          	adc    %esi,0x9(%rbp,%rax,1)
    1c6e:	3c 05                	cmp    $0x5,%al
    1c70:	07                   	(bad)
    1c71:	06                   	(bad)
  } else if (cid_version == QUIC_CONNID_VERSION_V2) {
    1c72:	2f                   	(bad)
    1c73:	05 09 e7 05 0e       	add    $0xe05e709,%eax
    1c78:	06                   	(bad)
    1c79:	74 05                	je     1c80 <balancer_ingress+0x1c80>
    1c7b:	09 4a 05             	or     %ecx,0x5(%rdx)
    1c7e:	12 3c 05 09 3c 05 07 	adc    0x7053c09(,%rax,1),%bh
    quic_packets_stats->cid_v2 += 1;
    1c85:	06                   	(bad)
    1c86:	31 05 11 e6 05 16    	xor    %eax,0x1605e611(%rip)        # 1606029d <bpf_xdp_adjust_head+0x160582fd>
    1c8c:	06                   	(bad)
    1c8d:	74 05                	je     1c94 <balancer_ingress+0x1c94>
    1c8f:	05 3c 05 0f 74       	add    $0x740f053c,%eax
  } else if (cid_version == QUIC_CONNID_VERSION_V3) {
    1c94:	05 11 06 3d 05       	add    $0x53d0611,%eax
    1c99:	16                   	(bad)
    1c9a:	06                   	(bad)
    1c9b:	74 05                	je     1ca2 <balancer_ingress+0x1ca2>
    1c9d:	06                   	(bad)
    1c9e:	3c 05                	cmp    $0x5,%al
    1ca0:	0f 74 05 19 06 2f 05 	pcmpeqb 0x52f0619(%rip),%mm0        # 52f22c0 <bpf_xdp_adjust_head+0x52ea320>
    quic_packets_stats->cid_v3 += 1;
    1ca7:	18 06                	sbb    %al,(%rsi)
    1ca9:	74 05                	je     1cb0 <balancer_ingress+0x1cb0>
    1cab:	05 2e 05 16 74       	add    $0x7416052e,%eax
    1cb0:	05 12 06 3d 06       	add    $0x63d0612,%eax
  } else {
    1cb5:	03 8a 7c 08 74 03    	add    0x374087c(%rdx),%ecx
    quic_packets_stats->cid_v0 += 1;
    1cbb:	f6 03 66             	testb  $0x66,(%rbx)
    1cbe:	05 06 3c 05 10       	add    $0x10053c06,%eax
    1cc3:	74 06                	je     1ccb <balancer_ingress+0x1ccb>
    1cc5:	3d 05 17 06 74       	cmp    $0x74061705,%eax
    1cca:	05 06 4a 05 0d       	add    $0xd054a06,%eax
        __u32 key = qpr.server_id;
    1ccf:	74 05                	je     1cd6 <balancer_ingress+0x1cd6>
    1cd1:	09 06                	or     %eax,(%rsi)
    1cd3:	68 05 17 06 ac       	push   $0xffffffffac061705
    1cd8:	05 09 82 05 07       	add    $0x7058209,%eax
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1cdd:	06                   	(bad)
    1cde:	30 05 0a bc 05 09    	xor    %al,0x905bc0a(%rip)        # 905d8ee <bpf_xdp_adjust_head+0x905594e>
    1ce4:	06                   	(bad)
    1ce5:	74 05                	je     1cec <balancer_ingress+0x1cec>
    1ce7:	13 3c 05 09 3c 05 07 	adc    0x7053c09(,%rax,1),%edi
    1cee:	06                   	(bad)
    1cef:	2f                   	(bad)
    1cf0:	05 18 bc 05 1d       	add    $0x1d05bc18,%eax
    1cf5:	06                   	(bad)
    1cf6:	74 05                	je     1cfd <balancer_ingress+0x1cfd>
    1cf8:	07                   	(bad)
    1cf9:	3c 05                	cmp    $0x5,%al
    1cfb:	16                   	(bad)
    1cfc:	74 05                	je     1d03 <balancer_ingress+0x1d03>
    1cfe:	18 06                	sbb    %al,(%rsi)
    1d00:	2f                   	(bad)
    1d01:	05 1d 06 74 05       	add    $0x574061d,%eax
    1d06:	07                   	(bad)
    1d07:	3c 05                	cmp    $0x5,%al
    1d09:	16                   	(bad)
    1d0a:	74 05                	je     1d11 <balancer_ingress+0x1d11>
    1d0c:	03 06                	add    (%rsi),%eax
    1d0e:	3f                   	(bad)
    1d0f:	05 01 9f 04 00       	add    $0x49f01,%eax
    1d14:	05 0a 03 b5 01       	add    $0x1b5030a,%eax
    1d19:	66 05 0e 68          	add    $0x680e,%ax
    1d1d:	05 07 06 74 05       	add    $0x5740607,%eax
    1d22:	0c 06                	or     $0x6,%al
    1d24:	2f                   	(bad)
    1d25:	05 05 06 66 05       	add    $0x5660605,%eax
    1d2a:	1b 06                	sbb    (%rsi),%eax
    1d2c:	ae                   	scas   %es:(%rdi),%al
    1d2d:	05 21 06 74 05       	add    $0x5740621,%eax
    1d32:	2b 74 05 3a          	sub    0x3a(%rbp,%rax,1),%esi
    1d36:	74 04                	je     1d3c <balancer_ingress+0x1d3c>
    1d38:	0b 05 07 06 03 9a    	or     -0x65fcf9f9(%rip),%eax        # ffffffff9a032345 <server_id_map+0x36fea5db6345>
    1d3e:	7d 02                	jge    1d42 <balancer_ingress+0x1d42>
    1d40:	2f                   	(bad)
    1d41:	01 05 10 06 74 05    	add    %eax,0x5740610(%rip)        # 5742357 <bpf_xdp_adjust_head+0x573a3b7>
    1d47:	07                   	(bad)
    1d48:	3c 05                	cmp    $0x5,%al
    1d4a:	19 06                	sbb    %eax,(%rsi)
    1d4c:	67 05 1f 06 74 05    	addr32 add $0x574061f,%eax
    1d52:	29 74 05 2e          	sub    %esi,0x2e(%rbp,%rax,1)
        if (real_pos) {
    1d56:	74 05                	je     1d5d <balancer_ingress+0x1d5d>
    1d58:	0e                   	(bad)
    1d59:	06                   	(bad)
    1d5a:	03 91 7f 02 23 01    	add    0x123027f(%rcx),%edx
    1d60:	05 13 06 74 05       	add    $0x5740613,%eax
          key = *real_pos;
    1d65:	0c 74                	or     $0x74,%al
    1d67:	05 07 06 75 05       	add    $0x5750607,%eax
    1d6c:	10 06                	adc    %al,(%rsi)
    1d6e:	74 05                	je     1d75 <balancer_ingress+0x1d75>
    1d70:	16                   	(bad)
          if (key == 0) {
    1d71:	4a 05 14 74 05 07    	rex.WX add $0x7057414,%rax
    1d77:	3c 05                	cmp    $0x5,%al
    1d79:	05 06 2f 05 07       	add    $0x7052f06,%eax
            quic_packets_stats->cid_invalid_server_id += 1;
    1d7e:	e6 05                	out    %al,$0x5
    1d80:	1c 06                	sbb    $0x6,%al
    1d82:	9e                   	sahf
    1d83:	05 07 58 05 1d       	add    $0x1d055807,%eax
    1d88:	06                   	(bad)
    1d89:	67 05 23 06 74 05    	addr32 add $0x5740623,%eax
            quic_packets_stats->cid_invalid_server_id_sample = qpr.server_id;
    1d8f:	09 06                	or     %eax,(%rsi)
    1d91:	03 f4                	add    %esp,%esi
    1d93:	7e 08                	jle    1d9d <balancer_ingress+0x1d9d>
    1d95:	4a 05 08 ad 05 0d    	rex.WX add $0xd05ad08,%rax
    1d9b:	06                   	(bad)
    1d9c:	74 05                	je     1da3 <balancer_ingress+0x1da3>
    1d9e:	25 4a 05 3e 4a       	and    $0x4a3e054a,%eax
            quic_packets_stats->ch_routed += 1;
    1da3:	05 21 06 4b 05       	add    $0x54b0621,%eax
    1da8:	07                   	(bad)
    1da9:	73 05                	jae    1db0 <balancer_ingress+0x1db0>
    1dab:	05 30 05 07 e6       	add    $0xe6070530,%eax
          } else {
    1db0:	05 0a 08 21 05       	add    $0x521080a,%eax
            pckt.real_index = key;
    1db5:	0f 06                	clts
    1db7:	74 05                	je     1dbe <balancer_ingress+0x1dbe>
    1db9:	08 74 05 07          	or     %dh,0x7(%rbp,%rax,1)
    1dbd:	06                   	(bad)
    1dbe:	75 05                	jne    1dc5 <balancer_ingress+0x1dc5>
    1dc0:	0e                   	(bad)
            dst = bpf_map_lookup_elem(&reals, &key);
    1dc1:	08 21                	or     %ah,(%rcx)
    1dc3:	05 13 06 74 05       	add    $0x5740613,%eax
    1dc8:	0c 74                	or     $0x74,%al
    1dca:	05 03 06 75 05       	add    $0x5750603,%eax
    1dcf:	18 06                	sbb    %al,(%rsi)
    1dd1:	74 05                	je     1dd8 <balancer_ingress+0x1dd8>
    1dd3:	03 06                	add    (%rsi),%eax
    1dd5:	40 05 19 06 74 05    	rex add $0x5740619,%eax
    1ddb:	03 06                	add    (%rsi),%eax
    1ddd:	ad                   	lods   %ds:(%rsi),%eax
    1dde:	05 13 06 74 05       	add    $0x5740613,%eax
    1de3:	14 06                	adc    $0x6,%al
    1de5:	4b 05 03 06 74 05    	rex.WXB add $0x5740603,%rax
    1deb:	0a 06                	or     (%rsi),%al
    1ded:	08 59 05             	or     %bl,0x5(%rcx)
    1df0:	21 06                	and    %eax,(%rsi)
    1df2:	74 05                	je     1df9 <balancer_ingress+0x1df9>
    1df4:	03 74 05 0a          	add    0xa(%rbp,%rax,1),%esi
    1df8:	06                   	(bad)
    1df9:	f3 05 03 06 74 05    	repz add $0x5740603,%eax
    1dff:	1c 06                	sbb    $0x6,%al
    1e01:	08 59 05             	or     %bl,0x5(%rcx)
    1e04:	22 06                	and    (%rsi),%al
    1e06:	74 05                	je     1e0d <balancer_ingress+0x1e0d>
    1e08:	09 06                	or     %eax,(%rsi)
    1e0a:	03 b7 7f 08 4a 05    	add    0x54a087f(%rdi),%esi
    1e10:	07                   	(bad)
    1e11:	06                   	(bad)
    1e12:	74 05                	je     1e19 <balancer_ingress+0x1e19>
    1e14:	13 06                	adc    (%rsi),%eax
    1e16:	75 05                	jne    1e1d <balancer_ingress+0x1e1d>
    1e18:	03 06                	add    (%rsi),%eax
    1e1a:	74 05                	je     1e21 <balancer_ingress+0x1e21>
    1e1c:	0a 06                	or     (%rsi),%al
    1e1e:	08 3d 05 19 06 74    	or     %bh,0x74061905(%rip)        # 74063729 <bpf_xdp_adjust_head+0x7405b789>
    1e24:	05 03 74 05 0a       	add    $0xa057403,%eax
    1e29:	06                   	(bad)
    1e2a:	c9                   	leave
    1e2b:	05 03 06 74 06       	add    $0x6740603,%eax
    1e30:	03 c6                	add    %esi,%eax
    1e32:	00 08                	add    %cl,(%rax)
    1e34:	2e 05 01 9f 05 05    	cs add $0x5059f01,%eax
    1e3a:	03 f9                	add    %ecx,%edi
            if (!dst) {
    1e3c:	00 66 05             	add    %ah,0x5(%rsi)
    1e3f:	08 ae 05 1d 06 9e    	or     %ch,-0x61f9e2fb(%rsi)
    1e45:	05 33 3c 05 08       	add    $0x8053c33,%eax
              quic_packets_stats->cid_unknown_real_dropped += 1;
    1e4a:	06                   	(bad)
    1e4b:	2f                   	(bad)
    1e4c:	05 1d 06 9e 05       	add    $0x59e061d,%eax
    1e51:	07                   	(bad)
    1e52:	06                   	(bad)
    1e53:	3b 05 05 30 05 07    	cmp    0x7053005(%rip),%eax        # 7054e5e <bpf_xdp_adjust_head+0x704cebe>
              return XDP_DROP;
    1e59:	e7 05                	out    %eax,$0x5
    1e5b:	1c 06                	sbb    $0x6,%al
    1e5d:	9e                   	sahf
    1e5e:	05 07 3c 05 0b       	add    $0xb053c07,%eax
    1e63:	06                   	(bad)
    1e64:	67 05 09 a0 06 ac    	addr32 add $0xac06a009,%eax
            int res = check_and_update_real_index_in_lru(&pckt, lru_map);
    1e6a:	9e                   	sahf
    1e6b:	08 e4                	or     %ah,%ah
    1e6d:	74 2e                	je     1e9d <balancer_ingress+0x1e9d>
    1e6f:	08 f2                	or     %dh,%dl
    1e71:	74 74                	je     1ee7 <balancer_ingress+0x1ee7>
    1e73:	05 16 06 73 05       	add    $0x5730616,%eax
    1e78:	0a 76 05             	or     0x5(%rsi),%dh
    1e7b:	09 06                	or     %eax,(%rsi)
    1e7d:	82                   	(bad)
    1e7e:	05 07 06 2f 05       	add    $0x52f0607,%eax
    1e83:	05 e6 05 1b 06       	add    $0x61b05e6,%eax
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1e88:	74 05                	je     1e8f <balancer_ingress+0x1e8f>
    1e8a:	11 06                	adc    %eax,(%rsi)
    1e8c:	9f                   	lahf
    1e8d:	06                   	(bad)
    1e8e:	03 81 7e 08 20 05    	add    0x520087e(%rcx),%eax
    1e94:	0b 03                	or     (%rbx),%eax
    1e96:	ff 01                	incl   (%rcx)
    1e98:	66 05 0d 06          	add    $0x60d,%ax
    1e9c:	67 05 09 06 9e 05    	addr32 add $0x59e0609,%eax
    1ea2:	07                   	(bad)
    1ea3:	06                   	(bad)
    1ea4:	2f                   	(bad)
    1ea5:	05 1d 06 74 05       	add    $0x574061d,%eax
  if (dst_lru) {
    1eaa:	03 06                	add    (%rsi),%eax
    1eac:	bc 05 07 30 05       	mov    $0x5300705,%esp
    1eb1:	0a 08                	or     (%rax),%cl
    if (dst_lru->pos == pckt->real_index) {
    1eb3:	23 05 0f 06 74 05    	and    0x574060f(%rip),%eax        # 57424c8 <bpf_xdp_adjust_head+0x573a528>
    1eb9:	08 74 05 07          	or     %dh,0x7(%rbp,%rax,1)
    1ebd:	06                   	(bad)
    1ebe:	75 05                	jne    1ec5 <balancer_ingress+0x1ec5>
    1ec0:	0c 06                	or     $0x6,%al
    1ec2:	74 05                	je     1ec9 <balancer_ingress+0x1ec9>
    1ec4:	12 4a 05             	adc    0x5(%rdx),%cl
      return DST_MATCH_IN_LRU;
    1ec7:	10 74 05 07          	adc    %dh,0x7(%rbp,%rax,1)
    1ecb:	3c 05                	cmp    $0x5,%al
    1ecd:	05 06 2f 05 16       	add    $0x16052f06,%eax
    1ed2:	bc 05 1c 06 74       	mov    $0x74061c05,%esp
      dst_lru->pos = pckt->real_index;
    1ed7:	05 03 3c 05 14       	add    $0x14053c03,%eax
    1edc:	74 05                	je     1ee3 <balancer_ingress+0x1ee3>
    1ede:	03 06                	add    (%rsi),%eax
    1ee0:	3d 05 0f 06 74       	cmp    $0x74060f05,%eax
    1ee5:	05 0a 06 9f 05       	add    $0x59f060a,%eax
      return DST_MISMATCH_IN_LRU;
    1eea:	1c 06                	sbb    $0x6,%al
    1eec:	74 05                	je     1ef3 <balancer_ingress+0x1ef3>
    1eee:	03 74 05 0a          	add    0xa(%rbp,%rax,1),%esi
    1ef2:	06                   	(bad)
    1ef3:	e5 05                	in     $0x5,%eax
    1ef5:	1c 06                	sbb    $0x6,%al
    1ef7:	74 05                	je     1efe <balancer_ingress+0x1efe>
    1ef9:	03 74 06 f3          	add    -0xd(%rsi,%rax,1),%esi
    1efd:	05 01 9f 05 05       	add    $0x5059f01,%eax
    1f02:	03 c9                	add    %ecx,%ecx
    1f04:	00 66 05             	add    %ah,0x5(%rsi)
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    1f07:	0e                   	(bad)
    1f08:	ad                   	lods   %ds:(%rsi),%eax
    1f09:	05 17 06 74 05       	add    $0x5740617,%eax
    1f0e:	0e                   	(bad)
    1f0f:	3c 05                	cmp    $0x5,%al
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1f11:	17                   	(bad)
    1f12:	06                   	(bad)
    1f13:	67 05 1d 06 74 05    	addr32 add $0x574061d,%eax
    1f19:	27                   	(bad)
    1f1a:	74 05                	je     1f21 <balancer_ingress+0x1f21>
    1f1c:	2c 74                	sub    $0x74,%al
    1f1e:	05 0e 06 03 be       	add    $0xbe03060e,%eax
    1f23:	7f 02                	jg     1f27 <balancer_ingress+0x1f27>
    1f25:	23 01                	and    (%rcx),%eax
    1f27:	05 13 06 74 05       	add    $0x5740613,%eax
    1f2c:	0c 74                	or     $0x74,%al
    1f2e:	05 07 06 75 05       	add    $0x5750607,%eax
    1f33:	10 06                	adc    %al,(%rsi)
    1f35:	74 05                	je     1f3c <balancer_ingress+0x1f3c>
    1f37:	16                   	(bad)
    1f38:	4a 05 14 74 05 07    	rex.WX add $0x7057414,%rax
    1f3e:	3c 05                	cmp    $0x5,%al
    1f40:	05 06 2f 05 07       	add    $0x7052f06,%eax
    1f45:	e6 05                	out    %al,$0x5
    1f47:	16                   	(bad)
    1f48:	06                   	(bad)
    1f49:	9e                   	sahf
    1f4a:	05 07 3c 05 1c       	add    $0x1c053c07,%eax
    1f4f:	06                   	(bad)
    1f50:	67 05 22 06 74 05    	addr32 add $0x5740622,%eax
    1f56:	09 06                	or     %eax,(%rsi)
    1f58:	03 a4 7e 08 4a 9f ad 	add    -0x5260b5f8(%rsi,%rdi,2),%esp
    1f5f:	05 08 ae 05 0d       	add    $0xd05ae08,%eax
    1f64:	06                   	(bad)
    1f65:	74 05                	je     1f6c <balancer_ingress+0x1f6c>
    1f67:	25 4a 05 3c 4a       	and    $0x4a3c054a,%eax
    1f6c:	05 20 06 4b 05       	add    $0x54b0620,%eax
    1f71:	07                   	(bad)
    1f72:	73 05                	jae    1f79 <balancer_ingress+0x1f79>
    1f74:	05 30 05 07 e6       	add    $0xe6070530,%eax
    1f79:	05 09 08 21 05       	add    $0x5210809,%eax
    1f7e:	0e                   	(bad)
    1f7f:	06                   	(bad)
    1f80:	74 05                	je     1f87 <balancer_ingress+0x1f87>
    1f82:	07                   	(bad)
    1f83:	74 06                	je     1f8b <balancer_ingress+0x1f8b>
  struct lb_stats* conn_rate_stats =
    1f85:	75 05                	jne    1f8c <balancer_ingress+0x1f8c>
    1f87:	0e                   	(bad)
    1f88:	08 21                	or     %ah,(%rcx)
    1f8a:	05 13 06 74 05       	add    $0x5740613,%eax
  if (!conn_rate_stats) {
    1f8f:	0c 74                	or     $0x74,%al
    1f91:	05 03 06 75 05       	add    $0x5750603,%eax
    return true;
    1f96:	12 06                	adc    (%rsi),%al
    1f98:	74 05                	je     1f9f <balancer_ingress+0x1f9f>
    1f9a:	03 06                	add    (%rsi),%eax
    1f9c:	40 05 16 06 74 05    	rex add $0x5740616,%eax
  *cur_time = bpf_ktime_get_ns();
    1fa2:	03 06                	add    (%rsi),%eax
    1fa4:	ad                   	lods   %ds:(%rsi),%eax
    1fa5:	05 0c 06 74 05       	add    $0x574060c,%eax
    1faa:	0e                   	(bad)
    1fab:	06                   	(bad)
    1fac:	4b 05 13 06 74 05    	rex.WXB add $0x5740613,%rax
    1fb2:	0c 3c                	or     $0x3c,%al
    1fb4:	05 10 06 67 05       	add    $0x5670610,%eax
    1fb9:	15 06 74 05 03       	adc    $0x3057406,%eax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1fbe:	3c 05                	cmp    $0x5,%al
    1fc0:	0e                   	(bad)
    1fc1:	74 05                	je     1fc8 <balancer_ingress+0x1fc8>
    1fc3:	10 06                	adc    %al,(%rsi)
    1fc5:	3d 05 03 06 66       	cmp    $0x66060305,%eax
    1fca:	05 0e 74 05 03       	add    $0x305740e,%eax
    1fcf:	06                   	(bad)
    1fd0:	3d 05 0e 06 74       	cmp    $0x74060e05,%eax
    1fd5:	05 14 06 67 04       	add    $0x4670614,%eax
    conn_rate_stats->v1 = 1;
    1fda:	0c 05                	or     $0x5,%al
    1fdc:	21 03                	and    %eax,(%rbx)
    1fde:	5c                   	pop    %rsp
    1fdf:	08 ac 05 0a 06 74 05 	or     %ch,0x574060a(%rbp,%rax,1)
    1fe6:	0c 06                	or     $0x6,%al
    conn_rate_stats->v2 = *cur_time;
    1fe8:	76 05                	jbe    1fef <balancer_ingress+0x1fef>
    1fea:	13 06                	adc    (%rsi),%eax
    1fec:	9e                   	sahf
    1fed:	05 15 74 05 03       	add    $0x3057415,%eax
    1ff2:	4a 05 1b 06 2f 05    	rex.WX add $0x52f061b,%rax
    1ff8:	0e                   	(bad)
    1ff9:	06                   	(bad)
    1ffa:	08 4a 05             	or     %cl,0x5(%rdx)
  } else {
    1ffd:	06                   	(bad)
    1ffe:	58                   	pop    %rax
    conn_rate_stats->v1 += 1;
    1fff:	05 0b 74 05 33       	add    $0x3305740b,%eax
    2004:	06                   	(bad)
    2005:	65 05 03 06 e4 05    	gs add $0x5e40603,%eax
    200b:	1d 06 31 05 1c       	sbb    $0x1c053106,%eax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2010:	06                   	(bad)
    2011:	74 05                	je     2018 <balancer_ingress+0x2018>
    2013:	0a 06                	or     (%rsi),%al
    2015:	03 67 9e             	add    -0x62(%rdi),%esp
    2018:	05 11 06 9e 05       	add    $0x59e0611,%eax
    201d:	03 74 05 09          	add    0x9(%rbp,%rax,1),%esi
      return true;
    2021:	06                   	(bad)
    2022:	2f                   	(bad)
    2023:	05 0e 06 74 05       	add    $0x574060e,%eax
    2028:	09 82 05 0f 06 2f    	or     %eax,0x2f060f05(%rdx)
  return false;
    202e:	05 14 06 74 05       	add    $0x5740614,%eax
  if (is_under_flood(&cur_time)) {
    2033:	21 66 05             	and    %esp,0x5(%rsi)
    2036:	26 74 05             	es je  203e <balancer_ingress+0x203e>
    2039:	1e                   	(bad)
    203a:	4a 05 0c 3c 05 17    	rex.WX add $0x17053c0c,%rax
    return DST_NOT_FOUND_IN_LRU;
    2040:	06                   	(bad)
    2041:	72 05                	jb     2048 <balancer_ingress+0x2048>
    2043:	03 06                	add    (%rsi),%eax
    2045:	e4 05                	in     $0x5,%al
    2047:	0b 06                	or     (%rsi),%eax
  struct real_pos_lru new_dst_lru = {};
    2049:	32 05 0a 06 74 05    	xor    0x574060a(%rip),%al        # 5742659 <bpf_xdp_adjust_head+0x573a6b9>
    204f:	0b 06                	or     (%rsi),%eax
    2051:	03 15 4a 05 04 06    	add    0x604054a(%rip),%edx        # 60425a1 <bpf_xdp_adjust_head+0x603a601>
    2057:	58                   	pop    %rax
    2058:	05 09 74 04 0b       	add    $0xb047409,%eax
    205d:	05 10 06 03 20       	add    $0x20030610,%eax
  new_dst_lru.pos = pckt->real_index;
    2062:	3c 05                	cmp    $0x5,%al
    2064:	03 06                	add    (%rsi),%eax
    2066:	9e                   	sahf
    2067:	05 0e 74 05 1c       	add    $0x1c05740e,%eax
    206c:	06                   	(bad)
    206d:	4b 05 22 06 74 05    	rex.WXB add $0x5740622,%rax
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    2073:	09 06                	or     %eax,(%rsi)
    2075:	03 52 08             	add    0x8(%rdx),%edx
    2078:	4a 05 07 06 74 05    	rex.WX add $0x5740607,%rax
    207e:	13 06                	adc    (%rsi),%eax
    2080:	75 05                	jne    2087 <balancer_ingress+0x2087>
    2082:	03 06                	add    (%rsi),%eax
    2084:	74 05                	je     208b <balancer_ingress+0x208b>
    2086:	0a 06                	or     (%rsi),%al
    2088:	08 3d 05 19 06 74    	or     %bh,0x74061905(%rip)        # 74063993 <bpf_xdp_adjust_head+0x7405b9f3>
    208e:	05 03 74 05 0a       	add    $0xa057403,%eax
    2093:	06                   	(bad)
    2094:	c9                   	leave
  return DST_NOT_FOUND_IN_LRU;
    2095:	05 03 06 74 06       	add    $0x6740603,%eax
    209a:	03 2b                	add    (%rbx),%ebp
    209c:	08 2e                	or     %ch,(%rsi)
    209e:	05 01 9f 05 05       	add    $0x5059f01,%eax
}
    20a3:	03 c3                	add    %ebx,%eax
            int res = check_and_update_real_index_in_lru(&pckt, lru_map);
    20a5:	01 66 05             	add    %esp,0x5(%rsi)
    20a8:	07                   	(bad)
    20a9:	ae                   	scas   %es:(%rdi),%al
    20aa:	05 16 06 9e 05       	add    $0x59e0616,%eax
            if (res == DST_MATCH_IN_LRU) {
    20af:	07                   	(bad)
    20b0:	3c 05                	cmp    $0x5,%al
    20b2:	05 06 2f 05 07       	add    $0x7052f06,%eax
              quic_packets_stats->dst_match_in_lru += 1;
    20b7:	e7 05                	out    %eax,$0x5
    20b9:	16                   	(bad)
    20ba:	06                   	(bad)
    20bb:	ac                   	lods   %ds:(%rsi),%al
    20bc:	05 07 3c 05 0b       	add    $0xb053c07,%eax
    20c1:	06                   	(bad)
    20c2:	67 05 09 a0 06 ac    	addr32 add $0xac06a009,%eax
            } else if (res == DST_MISMATCH_IN_LRU) {
    20c8:	9e                   	sahf
    20c9:	08 e4                	or     %ah,%ah
    20cb:	74 2e                	je     20fb <balancer_ingress+0x20fb>
    20cd:	08 f2                	or     %dh,%dl
    20cf:	74 74                	je     2145 <balancer_ingress+0x2145>
    20d1:	05 16 06 73 05       	add    $0x5730616,%eax
    20d6:	0a 76 05             	or     0x5(%rsi),%dh
              quic_packets_stats->dst_mismatch_in_lru += 1;
    20d9:	09 06                	or     %eax,(%rsi)
    20db:	82                   	(bad)
    20dc:	05 07 06 2f 05       	add    $0x52f0607,%eax
    20e1:	05 e6 05 1b 06       	add    $0x61b05e6,%eax
    20e6:	74 05                	je     20ed <balancer_ingress+0x20ed>
    20e8:	11 06                	adc    %eax,(%rsi)
    20ea:	9f                   	lahf
    20eb:	06                   	(bad)
                  vip_num, /* new conn */ false, /* mismatch in lru */ true);
    20ec:	03 d3                	add    %ebx,%edx
    20ee:	7d 08                	jge    20f8 <balancer_ingress+0x20f8>
    20f0:	74 05                	je     20f7 <balancer_ingress+0x20f7>
    20f2:	0b 03                	or     (%rbx),%eax
    20f4:	ad                   	lods   %ds:(%rsi),%eax
    20f5:	02 66 05             	add    0x5(%rsi),%ah
    20f8:	09 06                	or     %eax,(%rsi)
    20fa:	75 05                	jne    2101 <balancer_ingress+0x2101>
    20fc:	0d 06 74 05 09       	or     $0x9057406,%eax
    2101:	58                   	pop    %rax
    2102:	05 07 06 2f 05       	add    $0x52f0607,%eax
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2107:	1d 06 74 05 03       	sbb    $0x3057406,%eax
    210c:	06                   	(bad)
    210d:	bc 05 07 30 05       	mov    $0x5300705,%esp
    2112:	09 08                	or     %ecx,(%rax)
    2114:	21 05 0e 06 74 05    	and    %eax,0x574060e(%rip)        # 5742728 <bpf_xdp_adjust_head+0x573a788>
    211a:	07                   	(bad)
    211b:	74 06                	je     2123 <balancer_ingress+0x2123>
    211d:	75 05                	jne    2124 <balancer_ingress+0x2124>
    211f:	0b 06                	or     (%rsi),%eax
    2121:	74 05                	je     2128 <balancer_ingress+0x2128>
    2123:	11 4a 05             	adc    %ecx,0x5(%rdx)
    2126:	0f 74 05 07 3c 05 05 	pcmpeqb 0x5053c07(%rip),%mm0        # 5055d34 <bpf_xdp_adjust_head+0x504dd94>
    212d:	06                   	(bad)
    212e:	2f                   	(bad)
    212f:	05 07 bc 05 0c       	add    $0xc05bc07,%eax
    2134:	06                   	(bad)
    2135:	74 05                	je     213c <balancer_ingress+0x213c>
    2137:	07                   	(bad)
    2138:	4a 05 10 3c 05 07    	rex.WX add $0x7053c10,%rax
    213e:	3c 05                	cmp    $0x5,%al
    2140:	05 06 2f 05 16       	add    $0x16052f06,%eax
    2145:	bc 05 1b 06 74       	mov    $0x74061b05,%esp
    214a:	05 03 3c 05 14       	add    $0x14053c03,%eax
    214f:	74 05                	je     2156 <balancer_ingress+0x2156>
    2151:	03 06                	add    (%rsi),%eax
    2153:	3d 05 0f 06 74       	cmp    $0x74060f05,%eax
    2158:	05 14 06 9f 05       	add    $0x59f0614,%eax
    215d:	19 06                	sbb    %eax,(%rsi)
    215f:	74 05                	je     2166 <balancer_ingress+0x2166>
    2161:	03 3c 05 12 74 05 14 	add    0x14057412(,%rax,1),%edi
    2168:	06                   	(bad)
    2169:	2f                   	(bad)
    216a:	05 19 06 74 05       	add    $0x5740619,%eax
    216f:	03 3c 05 12 74 05 03 	add    0x3057412(,%rax,1),%edi
    2176:	06                   	(bad)
    2177:	3d 05 01 9f 05       	cmp    $0x59f0105,%eax
  struct lb_stats* per_vip_stats =
    217c:	05 03 1c 66 84       	add    $0x84661c03,%eax
  if (!per_vip_stats) {
    2181:	05 01 a0 04 00       	add    $0x4a001,%eax
    2186:	05 0a 03 df 02       	add    $0x2df030a,%eax
    return;
    218b:	66 05 0e 67          	add    $0x670e,%ax
  if (newConn) {
    218f:	05 07 06 74 05       	add    $0x5740607,%eax
    2194:	0c 06                	or     $0x6,%al
    per_vip_stats->v1 += 1;
    2196:	2f                   	(bad)
    2197:	05 05 06 66 05       	add    $0x5660605,%eax
    219c:	18 06                	sbb    %al,(%rsi)
    219e:	ae                   	scas   %es:(%rdi),%al
    219f:	05 0c 06 66 05       	add    $0x566060c,%eax
    21a4:	07                   	(bad)
    21a5:	06                   	(bad)
    21a6:	03 2f                	add    (%rdi),%ebp
  if (misMatchInLRU) {
    21a8:	66 05 10 06          	add    $0x610,%ax
    21ac:	74 05                	je     21b3 <balancer_ingress+0x21b3>
    21ae:	07                   	(bad)
    21af:	3c 05                	cmp    $0x5,%al
    per_vip_stats->v2 += 1;
    21b1:	14 06                	adc    $0x6,%al
    21b3:	67 05 1a 06 74 05    	addr32 add $0x574061a,%eax
    21b9:	24 74                	and    $0x74,%al
    21bb:	04 09                	add    $0x9,%al
    21bd:	05 15 06 03 87       	add    $0x87030615,%eax
    21c2:	7b 02                	jnp    21c6 <balancer_ingress+0x21c6>
            } else {
    21c4:	2a 01                	sub    (%rcx),%al
              quic_packets_stats->dst_not_found_in_lru += 1;
    21c6:	05 21 06 ac 05       	add    $0x5ac0621,%eax
    21cb:	2b 3c 05 12 66 05 08 	sub    0x8056612(,%rax,1),%edi
    21d2:	2e 05 1b 06 83 05    	cs add $0x583061b,%eax
    21d8:	24 06                	and    $0x6,%al
            quic_packets_stats->cid_routed += 1;
    21da:	66 05 09 06          	add    $0x609,%ax
    21de:	03 51 08             	add    0x8(%rcx),%edx
    21e1:	66 05 07 ad          	add    $0xad07,%ax
    21e5:	05 09 91 08 21       	add    $0x21089109,%eax
    21ea:	05 0b 91 05 03       	add    $0x305910b,%eax
          quic_packets_stats->cid_invalid_server_id += 1;
    21ef:	08 22                	or     %ah,(%rdx)
    21f1:	05 09 2f 08 21       	add    $0x21082f09,%eax
    21f6:	05 0b 91 06 03       	add    $0x306910b,%eax
    21fb:	ab                   	stos   %eax,%es:(%rdi)
    21fc:	7f 08                	jg     2206 <balancer_ingress+0x2206>
    21fe:	20 05 0a 06 03 d8    	and    %al,-0x27fcf9f6(%rip)        # ffffffffd803280e <server_id_map+0x36fee3db680e>
          quic_packets_stats->cid_invalid_server_id_sample = qpr.server_id;
    2204:	00 2e                	add    %ch,(%rsi)
    2206:	05 09 03 23 74       	add    $0x74230309,%eax
    220b:	76 05                	jbe    2212 <balancer_ingress+0x2212>
    220d:	0e                   	(bad)
    220e:	06                   	(bad)
    220f:	74 05                	je     2216 <balancer_ingress+0x2216>
    2211:	07                   	(bad)
    2212:	74 06                	je     221a <balancer_ingress+0x221a>
          quic_packets_stats->ch_routed += 1;
    2214:	76 05                	jbe    221b <balancer_ingress+0x221b>
    2216:	0b 06                	or     (%rsi),%eax
    2218:	74 05                	je     221f <balancer_ingress+0x221f>
    221a:	11 4a 05             	adc    %ecx,0x5(%rdx)
    221d:	0f 74 05 07 3c 05 05 	pcmpeqb 0x5053c07(%rip),%mm0        # 5055e2b <bpf_xdp_adjust_head+0x504de8b>
    2224:	06                   	(bad)
      } else if (!qpr.is_initial) {
    2225:	2f                   	(bad)
    2226:	05 07 bd 05 0c       	add    $0xc05bd07,%eax
    222b:	06                   	(bad)
    222c:	74 05                	je     2233 <balancer_ingress+0x2233>
    222e:	07                   	(bad)
    222f:	ba 4a 05 05 06       	mov    $0x605054a,%edx
        quic_packets_stats->ch_routed += 1;
    2234:	2f                   	(bad)
    2235:	05 11 06 74 05       	add    $0x5740611,%eax
    223a:	07                   	(bad)
    223b:	06                   	(bad)
    223c:	a1 05 1c 91 05 21 06 	movabs 0x574062105911c05,%eax
    2243:	74 05 
      } else {
    2245:	05 3c 05 1a 74       	add    $0x741a053c,%eax
        quic_packets_stats->cid_initial += 1;
    224a:	05 1c 06 4b 05       	add    $0x54b061c,%eax
    224f:	21 06                	and    %eax,(%rsi)
    2251:	74 05                	je     2258 <balancer_ingress+0x2258>
    2253:	05 4a 05 1a 74       	add    $0x741a054a,%eax
    2258:	05 03 06 4b 05       	add    $0x54b0603,%eax
            vip_num, /* new conn */ true, /* mismatch in lru */ false);
    225d:	1c 31                	sbb    $0x31,%al
    225f:	05 21 06 74 05       	add    $0x5740621,%eax
    2264:	05 4a 05 1a 74       	add    $0x741a054a,%eax
    2269:	05 1c 06 4b 05       	add    $0x54b061c,%eax
    226e:	21 06                	and    %eax,(%rsi)
    2270:	74 05                	je     2277 <balancer_ingress+0x2277>
    2272:	05 3c 05 1a 74       	add    $0x741a053c,%eax
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2277:	05 03 06 4c 04       	add    $0x44c0603,%eax
    227c:	00 05 09 03 e3 04    	add    %al,0x4e30309(%rip)        # 4e3258b <bpf_xdp_adjust_head+0x4e2a5eb>
    2282:	74 05                	je     2289 <balancer_ingress+0x2289>
    2284:	07                   	(bad)
    2285:	91                   	xchg   %eax,%ecx
    2286:	05 03 e6 05 0e       	add    $0xe05e603,%eax
    228b:	06                   	(bad)
    228c:	58                   	pop    %rax
    228d:	05 17 74 05 0e       	add    $0xe057417,%eax
    2292:	3c 05                	cmp    $0x5,%al
    2294:	14 06                	adc    $0x6,%al
    2296:	67 05 1a 06 74 05    	addr32 add $0x574061a,%eax
    229c:	24 74                	and    $0x74,%al
    229e:	04 09                	add    $0x9,%al
    22a0:	05 15 06 03 e9       	add    $0xe9030615,%eax
    22a5:	7a 02                	jp     22a9 <balancer_ingress+0x22a9>
    22a7:	2a 01                	sub    (%rcx),%al
    22a9:	05 21 06 ac 05       	add    $0x5ac0621,%eax
    22ae:	2b 3c 05 12 66 05 08 	sub    0x8056612(,%rax,1),%edi
    22b5:	2e 05 1b 06 83 05    	cs add $0x583061b,%eax
    22bb:	24 06                	and    $0x6,%al
    22bd:	66 05 09 06          	add    $0x609,%ax
    22c1:	03 6b 08             	add    0x8(%rbx),%ebp
    22c4:	66 05 07 ad          	add    $0xad07,%ax
    22c8:	05 09 91 08 21       	add    $0x21089109,%eax
    22cd:	05 0b 91 05 03       	add    $0x305910b,%eax
    22d2:	08 22                	or     %ah,(%rdx)
    22d4:	05 09 2f 08 21       	add    $0x21082f09,%eax
    22d9:	05 0b 91 06 03       	add    $0x306910b,%eax
    22de:	ab                   	stos   %eax,%es:(%rdi)
    22df:	7f 08                	jg     22e9 <balancer_ingress+0x22e9>
    22e1:	20 05 0a 06 03 d8    	and    %al,-0x27fcf9f6(%rip)        # ffffffffd80328f1 <server_id_map+0x36fee3db68f1>
    22e7:	00 2e                	add    %ch,(%rsi)
    22e9:	05 09 03 09 74       	add    $0x74090309,%eax
  struct lb_stats* per_vip_stats =
    22ee:	76 05                	jbe    22f5 <balancer_ingress+0x22f5>
    22f0:	0e                   	(bad)
  if (!per_vip_stats) {
    22f1:	06                   	(bad)
    22f2:	74 05                	je     22f9 <balancer_ingress+0x22f9>
    22f4:	07                   	(bad)
    22f5:	74 06                	je     22fd <balancer_ingress+0x22fd>
    22f7:	76 05                	jbe    22fe <balancer_ingress+0x22fe>
    22f9:	0b 06                	or     (%rsi),%eax
    return;
    22fb:	74 05                	je     2302 <balancer_ingress+0x2302>
  if (newConn) {
    22fd:	11 4a 05             	adc    %ecx,0x5(%rdx)
    2300:	0f 74 05 07 3c 05 05 	pcmpeqb 0x5053c07(%rip),%mm0        # 5055f0e <bpf_xdp_adjust_head+0x504df6e>
    per_vip_stats->v1 += 1;
    2307:	06                   	(bad)
    2308:	2f                   	(bad)
    2309:	05 07 93 05 1c       	add    $0x1c059307,%eax
    230e:	91                   	xchg   %eax,%ecx
    230f:	05 21 06 74 05       	add    $0x5740621,%eax
    2314:	05 3c 05 1a 74       	add    $0x741a053c,%eax
  if (misMatchInLRU) {
    2319:	05 1c 06 4b 05       	add    $0x54b061c,%eax
    231e:	21 06                	and    %eax,(%rsi)
    per_vip_stats->v2 += 1;
    2320:	74 05                	je     2327 <balancer_ingress+0x2327>
    2322:	05 4a 05 1a 74       	add    $0x741a054a,%eax
    2327:	05 03 06 4b 05       	add    $0x54b0603,%eax
    232c:	1c 31                	sbb    $0x31,%al
    232e:	05 21 06 74 05       	add    $0x5740621,%eax
    2333:	05 4a 05 1a 74       	add    $0x741a054a,%eax
    2338:	05 1c 06 4b 05       	add    $0x54b061c,%eax
  original_sport = pckt.flow.port16[0];
    233d:	21 06                	and    %eax,(%rsi)
    233f:	74 05                	je     2346 <balancer_ingress+0x2346>
    2341:	05 3c 05 1a 74       	add    $0x741a053c,%eax
    2346:	05 03 06 4c 04       	add    $0x44c0603,%eax
  if (!dst) {
    234b:	00 05 09 03 85 05    	add    %al,0x5850309(%rip)        # 585265a <bpf_xdp_adjust_head+0x584a6ba>
    2351:	74 05                	je     2358 <balancer_ingress+0x2358>
    2353:	07                   	(bad)
    2354:	91                   	xchg   %eax,%ecx
    2355:	06                   	(bad)
    2356:	03 88 7a e4 05 05    	add    0x505e47a(%rax),%ecx
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    235c:	06                   	(bad)
    235d:	03 87 06 2e 05 07    	add    0x7052e06(%rdi),%eax
    2363:	e7 05                	out    %eax,$0x5
    2365:	05 91 05 03 08       	add    $0x8030591,%eax
    236a:	ad                   	lods   %ds:(%rsi),%eax
    236b:	05 19 2f 05 0d       	add    $0xd052f19,%eax
    2370:	06                   	(bad)
    2371:	66 05 0e 06          	add    $0x60e,%ax
    2375:	69 05 0c 06 74 05 19 	imul   $0x5750619,0x574060c(%rip),%eax        # 574298b <bpf_xdp_adjust_head+0x573a9eb>
    237c:	06 75 05 
        !(vip_info->flags & F_LRU_BYPASS)) {
    237f:	0d 06 66 05 0e       	or     $0xe056606,%eax
    2384:	06                   	(bad)
    2385:	67 06                	addr32 (bad)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    2387:	ac                   	lods   %ds:(%rsi),%al
    2388:	9e                   	sahf
    2389:	08 e4                	or     %ah,%ah
    238b:	74 2e                	je     23bb <balancer_ingress+0x23bb>
      connection_table_lookup(&dst, &pckt, lru_map, /*isGlobalLru=*/false);
    238d:	08 f2                	or     %dh,%dl
    238f:	74 74                	je     2405 <balancer_ingress+0x2405>
    2391:	05 0c 74 05 08       	add    $0x805740c,%eax
    2396:	06                   	(bad)
    2397:	75 05                	jne    239e <balancer_ingress+0x239e>
    2399:	07                   	(bad)
    239a:	06                   	(bad)
    239b:	82                   	(bad)
    239c:	05 0e 06 67 05       	add    $0x567060e,%eax
    23a1:	10 91 06 ac 9e 08    	adc    %dl,0x89eac06(%rcx)
    23a7:	e4 74                	in     $0x74,%al
    23a9:	2e 08 f2             	cs or  %dh,%dl
    23ac:	74 74                	je     2422 <balancer_ingress+0x2422>
    23ae:	05 0e 74 05 0a       	add    $0xa05740e,%eax
    23b3:	06                   	(bad)
    23b4:	75 05                	jne    23bb <balancer_ingress+0x23bb>
    23b6:	09 06                	or     %eax,(%rsi)
    23b8:	82                   	(bad)
    23b9:	05 07 06 2f 05       	add    $0x52f0607,%eax
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    23be:	0b e7                	or     %edi,%esp
    23c0:	05 15 06 74 05       	add    $0x5740615,%eax
    23c5:	1b 2e                	sbb    (%rsi),%ebp
    23c7:	05 30 66 05 0b       	add    $0xb056630,%eax
    23cc:	06                   	(bad)
    23cd:	2f                   	(bad)
    23ce:	05 15 06 74 05       	add    $0x5740615,%eax
    23d3:	1b 2e                	sbb    (%rsi),%ebp
    23d5:	05 09 06 81 05       	add    $0x5810609,%eax
    23da:	1b 32                	sbb    (%rdx),%esi
    23dc:	05 03 92 05 07       	add    $0x7059203,%eax
    23e1:	30 05 12 06 74 05    	xor    %al,0x5740612(%rip)        # 57429f9 <bpf_xdp_adjust_head+0x573aa59>
  if (!dst_lru) {
    23e7:	10 74 05 17          	adc    %dh,0x17(%rbp,%rax,1)
    23eb:	3c 05                	cmp    $0x5,%al
    return;
    23ed:	07                   	(bad)
    23ee:	66 05 05 06          	add    $0x605,%ax
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    23f2:	03 0f                	add    (%rdi),%ecx
    23f4:	2e 05 09 e8 05 10    	cs add $0x1005e809,%eax
    23fa:	9f                   	lahf
    23fb:	06                   	(bad)
    23fc:	ac                   	lods   %ds:(%rsi),%al
    23fd:	9e                   	sahf
    23fe:	08 e4                	or     %ah,%ah
    2400:	74 2e                	je     2430 <balancer_ingress+0x2430>
    2402:	08 f2                	or     %dh,%dl
    2404:	74 74                	je     247a <balancer_ingress+0x247a>
    2406:	05 0e 74 05 08       	add    $0x805740e,%eax
    cur_time = bpf_ktime_get_ns();
    240b:	06                   	(bad)
    240c:	75 05                	jne    2413 <balancer_ingress+0x2413>
    240e:	07                   	(bad)
    240f:	06                   	(bad)
    2410:	82                   	(bad)
    2411:	05 05 06 2f 05       	add    $0x52f0605,%eax
    2416:	03 e8                	add    %eax,%ebp
    2418:	05 12 06 74 05       	add    $0x5740612,%eax
    241d:	08 06                	or     %al,(%rsi)
    241f:	a0 05 12 06 74 05 18 	movabs 0x52e180574061205,%al
    2426:	2e 05 
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    2428:	07                   	(bad)
    2429:	66 05 19 06          	add    $0x619,%ax
    242d:	31 05 0d 93 05 17    	xor    %eax,0x1705930d(%rip)        # 1705b740 <bpf_xdp_adjust_head+0x170537a0>
    2433:	06                   	(bad)
    2434:	74 05                	je     243b <balancer_ingress+0x243b>
    2436:	0b 3c 05 13 06 67 05 	or     0x5670613(,%rax,1),%edi
    243d:	09 06                	or     %eax,(%rsi)
    243f:	e4 05                	in     $0x5,%al
      return;
    2441:	13 06                	adc    (%rsi),%eax
    2443:	67 06                	addr32 (bad)
    2445:	ac                   	lods   %ds:(%rsi),%al
    dst_lru->atime = cur_time;
    2446:	9e                   	sahf
    2447:	08 e4                	or     %ah,%ah
    2449:	74 2e                	je     2479 <balancer_ingress+0x2479>
    244b:	08 f2                	or     %dh,%dl
    244d:	74 74                	je     24c3 <balancer_ingress+0x24c3>
    244f:	05 09 74 05 08       	add    $0x8057409,%eax
    2454:	06                   	(bad)
    2455:	75 05                	jne    245c <balancer_ingress+0x245c>
    2457:	07                   	(bad)
  key = dst_lru->pos;
    2458:	06                   	(bad)
    2459:	82                   	(bad)
    245a:	05 0d 06 67 05       	add    $0x567060d,%eax
    245f:	0b 08                	or     (%rax),%ecx
    2461:	13 05 22 9f 06 ac    	adc    -0x53f960de(%rip),%eax        # ffffffffac06c389 <server_id_map+0x36feb7df0389>
  pckt->real_index = key;
    2467:	9e                   	sahf
    2468:	08 e4                	or     %ah,%ah
    246a:	74 2e                	je     249a <balancer_ingress+0x249a>
    246c:	08 f2                	or     %dh,%dl
    246e:	74 74                	je     24e4 <balancer_ingress+0x24e4>
    2470:	05 16 74 05 0a       	add    $0xa057416,%eax
    2475:	06                   	(bad)
    2476:	75 05                	jne    247d <balancer_ingress+0x247d>
  *real = bpf_map_lookup_elem(&reals, &key);
    2478:	09 06                	or     %eax,(%rsi)
    247a:	82                   	(bad)
    247b:	05 07 06 2f 05       	add    $0x52f0607,%eax
    2480:	05 e9 05 13 06       	add    $0x61305e9,%eax
    2485:	74 05                	je     248c <balancer_ingress+0x248c>
    2487:	08 06                	or     %al,(%rsi)
    2489:	a2 05 12 06 74 05 18 	movabs %al,0x52e180574061205
    2490:	2e 05 
    2492:	07                   	(bad)
    2493:	66 05 15 06          	add    $0x615,%ax
    2497:	67 05 20 06 74 05    	addr32 add $0x5740620,%eax
    249d:	14 3c                	adc    $0x3c,%al
    249f:	05 0a 66 05 09       	add    $0x905660a,%eax
    24a4:	06                   	(bad)
    24a5:	83 05 0d cf 05 25 9f 	addl   $0xffffff9f,0x2505cf0d(%rip)        # 2505f3b9 <bpf_xdp_adjust_head+0x25057419>
    24ac:	06                   	(bad)
    24ad:	ac                   	lods   %ds:(%rsi),%al
    24ae:	9e                   	sahf
    24af:	08 e4                	or     %ah,%ah
    24b1:	74 2e                	je     24e1 <balancer_ingress+0x24e1>
    24b3:	08 f2                	or     %dh,%dl
    24b5:	74 74                	je     252b <balancer_ingress+0x252b>
    24b7:	05 18 74 05 0c       	add    $0xc057418,%eax
    24bc:	06                   	(bad)
    24bd:	75 05                	jne    24c4 <balancer_ingress+0x24c4>
    24bf:	0b 06                	or     (%rsi),%eax
    24c1:	82                   	(bad)
    24c2:	05 09 06 2f 05       	add    $0x52f0609,%eax
    24c7:	07                   	(bad)
    24c8:	e6 05                	out    %al,$0x5
    24ca:	16                   	(bad)
    24cb:	06                   	(bad)
    24cc:	74 05                	je     24d3 <balancer_ingress+0x24d3>
    24ce:	24 06                	and    $0x6,%al
    24d0:	a0 05 2a 06 74 05 34 	movabs 0x474340574062a05,%al
    24d7:	74 04 
    24d9:	0b 05 09 06 03 e0    	or     -0x1ffcf9f7(%rip),%eax        # ffffffffe0032ae8 <server_id_map+0x36feebdb6ae8>
    24df:	7b 08                	jnp    24e9 <balancer_ingress+0x24e9>
    24e1:	ac                   	lods   %ds:(%rsi),%al
    24e2:	05 07 ad 05 21       	add    $0x2105ad07,%eax
    24e7:	91                   	xchg   %eax,%ecx
    24e8:	05 26 06 74 05       	add    $0x5740626,%eax
    24ed:	2c 74                	sub    $0x74,%al
    24ef:	05 16 4a 05 0a       	add    $0xa054a16,%eax
    24f4:	06                   	(bad)
    }
    24f5:	76 05                	jbe    24fc <balancer_ingress+0x24fc>
    check_udp_flow_migration(&dst, &pckt, vip_info, &vip);
    24f7:	1f                   	(bad)
    24f8:	06                   	(bad)
    24f9:	ac                   	lods   %ds:(%rsi),%al
    24fa:	05 37 ac 05 0a       	add    $0xa05ac37,%eax
    24ff:	06                   	(bad)
    2500:	2f                   	(bad)
    2501:	05 1f 06 ac 03       	add    $0x3ac061f,%eax
    2506:	b6 7d                	mov    $0x7d,%dh
    2508:	ba 05 05 06 03       	mov    $0x3060505,%edx
    250d:	c8 02 66 05          	enter  $0x6602,$0x5
    2511:	20 a2 05 25 06 74    	and    %ah,0x74062505(%rdx)
    2517:	05 2b 74 05 15       	add    $0x1505742b,%eax
    251c:	4a 05 0a 06 76 05    	rex.WX add $0x576060a,%rax
    2522:	19 06                	sbb    %eax,(%rsi)
    2524:	ac                   	lods   %ds:(%rsi),%al
    2525:	05 2f ac 05 0a       	add    $0xa05ac2f,%eax
    252a:	06                   	(bad)
    252b:	2f                   	(bad)
    252c:	05 19 06 ac 03       	add    $0x3ac0619,%eax
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    2531:	b1 7d                	mov    $0x7d,%cl
    2533:	ba 05 05 06 03       	mov    $0x3060505,%edx
    2538:	cd 02                	int    $0x2
    253a:	66 04 00             	data16 add $0x0,%al
    253d:	05 0b 03 98 04       	add    $0x498030b,%eax
    2542:	82                   	(bad)
    2543:	05 09 ad 05 18       	add    $0x1805ad09,%eax
    2548:	06                   	(bad)
    2549:	74 05                	je     2550 <balancer_ingress+0x2550>
    254b:	05 06 bc 05 0d       	add    $0xd05bc06,%eax
    2550:	59                   	pop    %rcx
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    2551:	05 0b a0 06 ac       	add    $0xac06a00b,%eax
    2556:	9e                   	sahf
    2557:	08 e4                	or     %ah,%ah
    2559:	74 2e                	je     2589 <balancer_ingress+0x2589>
    255b:	08 f2                	or     %dh,%dl
    255d:	74 74                	je     25d3 <balancer_ingress+0x25d3>
    255f:	05 25 06 73 05       	add    $0x5730625,%eax
    2564:	0c 76                	or     $0x76,%al
    2566:	05 0b 06 82 05       	add    $0x582060b,%eax
    256b:	09 06                	or     %eax,(%rsi)
    256d:	2f                   	(bad)
    256e:	05 31 e6 05 37       	add    $0x3705e631,%eax
    2573:	06                   	(bad)
    2574:	74 05                	je     257b <balancer_ingress+0x257b>
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    2576:	41 74 04             	rex.B je 257d <balancer_ingress+0x257d>
    2579:	09 05 1c 06 03 e9    	or     %eax,-0x16fcf9e4(%rip)        # ffffffffe9032b9b <server_id_map+0x36fef4db6b9b>
    257f:	7b 02                	jnp    2583 <balancer_ingress+0x2583>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2581:	2a 01                	sub    (%rcx),%al
    2583:	05 13 08 6d 05       	add    $0x56d0813,%eax
    2588:	1f                   	(bad)
    2589:	06                   	(bad)
    258a:	ac                   	lods   %ds:(%rsi),%al
    258b:	05 12 3c 05 08       	add    $0x8053c12,%eax
    2590:	66 05 1b 06          	add    $0x61b,%ax
    2594:	83 05 24 06 66 05 09 	addl   $0x9,0x5660624(%rip)        # 5662bbf <bpf_xdp_adjust_head+0x565ac1f>
    259b:	06                   	(bad)
    259c:	03 ec                	add    %esp,%ebp
    259e:	7d 08                	jge    25a8 <balancer_ingress+0x25a8>
    25a0:	66 05 07 ad          	add    $0xad07,%ax
    25a4:	05 09 91 08 21       	add    $0x21089109,%eax
    25a9:	05 0b 91 05 03       	add    $0x305910b,%eax
    25ae:	08 22                	or     %ah,(%rdx)
    25b0:	05 09 2f 08 21       	add    $0x21082f09,%eax
    25b5:	05 0b 91 06 03       	add    $0x306910b,%eax
    25ba:	ab                   	stos   %eax,%es:(%rdi)
    25bb:	7f 08                	jg     25c5 <balancer_ingress+0x25c5>
    25bd:	20 05 0a 06 03 d8    	and    %al,-0x27fcf9f6(%rip)        # ffffffffd8032bcd <server_id_map+0x36fee3db6bcd>
    25c3:	00 2e                	add    %ch,(%rsi)
    25c5:	05 09 03 88 02       	add    $0x2880309,%eax
    25ca:	74 05                	je     25d1 <balancer_ingress+0x25d1>
    25cc:	08 77 05             	or     %dh,0x5(%rdi)
    25cf:	0d 06 74 05 13       	or     $0x13057406,%eax
    25d4:	74 05                	je     25db <balancer_ingress+0x25db>
    25d6:	2b 4a 05             	sub    0x5(%rdx),%ecx
    25d9:	3b 4a 05             	cmp    0x5(%rdx),%ecx
    25dc:	07                   	(bad)
    25dd:	74 05                	je     25e4 <balancer_ingress+0x25e4>
    25df:	05 06 2f 05 15       	add    $0x15052f06,%eax
    25e4:	5b                   	pop    %rbx
    25e5:	05 1a 06 74 05       	add    $0x574061a,%eax
    25ea:	20 74 05 09          	and    %dh,0x9(%rbp,%rax,1)
    25ee:	4a 05 14 06 75 05    	rex.WX add $0x5750614,%rax
  struct lb_stats* conn_rate_stats =
    25f4:	09 06                	or     %eax,(%rsi)
    25f6:	74 06                	je     25fe <balancer_ingress+0x25fe>
    25f8:	75 b2                	jne    25ac <balancer_ingress+0x25ac>
    25fa:	05 08 06 74 05       	add    $0x5740608,%eax
  if (!conn_rate_stats) {
    25ff:	12 3c 05 26 58 05 07 	adc    0x7055826(,%rax,1),%bh
    return true;
    2606:	58                   	pop    %rax
    2607:	05 09 06 30 05       	add    $0x5300609,%eax
    260c:	13 06                	adc    (%rsi),%eax
    260e:	74 05                	je     2615 <balancer_ingress+0x2615>
    2610:	35 4a 05 09 74       	xor    $0x7409054a,%eax
  *cur_time = bpf_ktime_get_ns();
    2615:	05 07 06 2f 05       	add    $0x52f0607,%eax
    261a:	0b 5a 05             	or     0x5(%rdx),%ebx
    261d:	0a 06                	or     (%rsi),%al
    261f:	74 05                	je     2626 <balancer_ingress+0x2626>
    2621:	14 3c                	adc    $0x3c,%al
    2623:	05 2d 3c 05 09       	add    $0x9053c2d,%eax
    2628:	3c 05                	cmp    $0x5,%al
    262a:	19 06                	sbb    %eax,(%rsi)
    262c:	31 05 07 75 05 46    	xor    %eax,0x46057507(%rip)        # 46059b39 <bpf_xdp_adjust_head+0x46051b99>
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    2632:	5b                   	pop    %rbx
    2633:	05 1e 06 74 05       	add    $0x574061e,%eax
    2638:	09 06                	or     %eax,(%rsi)
    263a:	76 05                	jbe    2641 <balancer_ingress+0x2641>
    263c:	23 06                	and    (%rsi),%eax
    263e:	ac                   	lods   %ds:(%rsi),%al
    263f:	05 09 3c 05 07       	add    $0x7053c09,%eax
    2644:	06                   	(bad)
    2645:	2f                   	(bad)
    2646:	05 0e 5a 05 1b       	add    $0x1b055a0e,%eax
    conn_rate_stats->v1 = 1;
    264b:	06                   	(bad)
    264c:	74 05                	je     2653 <balancer_ingress+0x2653>
    264e:	0c 4a                	or     $0x4a,%al
    2650:	05 03 06 75 05       	add    $0x5750603,%eax
    2655:	09 30                	or     %esi,(%rax)
    2657:	05 13 06 74 05       	add    $0x5740613,%eax
    conn_rate_stats->v2 = *cur_time;
    265c:	36 4a 05 09 74 05 07 	ss rex.WX add $0x7057409,%rax
    2663:	06                   	(bad)
    2664:	2f                   	(bad)
    2665:	05 2a 5a 05 36       	add    $0x36055a2a,%eax
    266a:	06                   	(bad)
    266b:	74 05                	je     2672 <balancer_ingress+0x2672>
  } else {
    266d:	0c 4a                	or     $0x4a,%al
    conn_rate_stats->v1 += 1;
    266f:	05 08 06 76 05       	add    $0x5760608,%eax
    2674:	07                   	(bad)
    2675:	06                   	(bad)
    2676:	82                   	(bad)
    2677:	05 05 06 2f 05       	add    $0x52f0605,%eax
    267c:	19 5b 05             	sbb    %ebx,0x5(%rbx)
    267f:	23 06                	and    (%rsi),%eax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2681:	9e                   	sahf
    2682:	05 08 3c 05 18       	add    $0x18053c08,%eax
    2687:	06                   	(bad)
    2688:	67 05 16 06 66 05    	addr32 add $0x5660616,%eax
    268e:	07                   	(bad)
    268f:	06                   	(bad)
      return true;
    2690:	67 05 15 06 74 05    	addr32 add $0x5740615,%eax
    2696:	07                   	(bad)
    2697:	3c 05                	cmp    $0x5,%al
    2699:	0b 06                	or     (%rsi),%eax
  return false;
    269b:	32 05 15 06 9e 05    	xor    0x59e0615(%rip),%al        # 59e2cb6 <bpf_xdp_adjust_head+0x59dad16>
    26a1:	1d 3c 05 27 3c       	sbb    $0x3c27053c,%eax
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    26a6:	05 31 ac 05 24       	add    $0x2405ac31,%eax
    26ab:	3c 05                	cmp    $0x5,%al
    26ad:	3a 2e                	cmp    (%rsi),%ch
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    26af:	05 44 ac 05 37       	add    $0x3705ac44,%eax
    26b4:	3c 05                	cmp    $0x5,%al
    26b6:	16                   	(bad)
    26b7:	06                   	(bad)
    26b8:	2d 05 05 68 05       	sub    $0x5680505,%eax
    26bd:	0e                   	(bad)
    26be:	59                   	pop    %rcx
    26bf:	05 1c 06 74 05       	add    $0x574061c,%eax
    26c4:	0e                   	(bad)
    26c5:	3c 05                	cmp    $0x5,%al
    26c7:	19 06                	sbb    %eax,(%rsi)
    26c9:	2f                   	(bad)
    26ca:	05 23 06 ac 05       	add    $0x5ac0623,%eax
    26cf:	2d 3c 05 37 ac       	sub    $0xac37053c,%eax
    26d4:	05 2a 3c 05 40       	add    $0x40053c2a,%eax
    26d9:	2e 05 3f 74 05 3d    	cs add $0x3d05743f,%eax
    26df:	4a 05 16 2e 05 05    	rex.WX add $0x5052e16,%rax
    26e5:	06                   	(bad)
    26e6:	67 05 0e 2f 05 1c    	addr32 add $0x1c052f0e,%eax
    26ec:	06                   	(bad)
    26ed:	74 05                	je     26f4 <balancer_ingress+0x26f4>
    26ef:	0e                   	(bad)
    26f0:	3c 05                	cmp    $0x5,%al
    26f2:	0a 06                	or     (%rsi),%al
    26f4:	30 05 14 06 ac 05    	xor    %al,0x5ac0614(%rip)        # 5ac2d0e <bpf_xdp_adjust_head+0x5abad6e>
    26fa:	1e                   	(bad)
    26fb:	3c 05                	cmp    $0x5,%al
    26fd:	28 ac 05 1b 3c 05 32 	sub    %ch,0x32053c1b(%rbp,%rax,1)
    2704:	2e 05 3c ac 05 2f    	cs add $0x2f05ac3c,%eax
    270a:	3c 05                	cmp    $0x5,%al
    270c:	45                   	rex.RB
    270d:	2e 05 44 74 05 42    	cs add $0x42057444,%eax
    2713:	4a 05 16 06 2d 05    	rex.WX add $0x52d0616,%rax
    2719:	03 69 05             	add    0x5(%rcx),%ebp
    271c:	01 2f                	add    %ebp,(%rdi)
    271e:	04 00                	add    $0x0,%al
    2720:	05 26 03 d3 03       	add    $0x3d30326,%eax
    2725:	74 05                	je     272c <balancer_ingress+0x272c>
    2727:	19 75 05             	sbb    %esi,0x5(%rbp)
    272a:	0b 06                	or     (%rsi),%eax
    272c:	74 05                	je     2733 <balancer_ingress+0x2733>
    if (down_reals_map) {
    272e:	2a 06                	sub    (%rsi),%al
    2730:	69 05 42 06 74 05 07 	imul   $0xc5030607,0x5740642(%rip),%eax        # 5742d7c <bpf_xdp_adjust_head+0x573addc>
    2737:	06 03 c5 
    273a:	7d 08                	jge    2744 <balancer_ingress+0x2744>
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    273c:	2e 05 13 06 74 05    	cs add $0x5740613,%eax
    2742:	07                   	(bad)
    2743:	3c 05                	cmp    $0x5,%al
    2745:	05 06 2f 05 20       	add    $0x20052f06,%eax
    274a:	06                   	(bad)
    274b:	74 05                	je     2752 <balancer_ingress+0x2752>
    274d:	03 06                	add    (%rsi),%eax
    274f:	bb 05 0e 06 2e       	mov    $0x2e060e05,%ebx
    2754:	05 1a 74 05 0e       	add    $0xe05741a,%eax
    2759:	3c 05                	cmp    $0x5,%al
    275b:	05 06 2f 05 20       	add    $0x20052f06,%eax
    2760:	06                   	(bad)
    2761:	74 05                	je     2768 <balancer_ingress+0x2768>
      if (down_real) {
    2763:	03 06                	add    (%rsi),%eax
    2765:	bb 05 0e 06 2e       	mov    $0x2e060e05,%ebx
    276a:	05 1a 74 05 0e       	add    $0xe05741a,%eax
    276f:	3c 05                	cmp    $0x5,%al
        *dst = NULL;
    2771:	05 06 2f 05 20       	add    $0x20052f06,%eax
    2776:	06                   	(bad)
    2777:	74 05                	je     277e <balancer_ingress+0x277e>
    2779:	03 06                	add    (%rsi),%eax
    277b:	bb 05 05 2f 05       	mov    $0x52f0505,%ebx
        __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
    2780:	20 06                	and    %al,(%rsi)
    2782:	74 03                	je     2787 <balancer_ingress+0x2787>
    2784:	c1 7b ba 05          	sarl   $0x5,-0x46(%rbx)
    2788:	19 06                	sbb    %eax,(%rsi)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    278a:	03 f4                	add    %esp,%esi
    278c:	06                   	(bad)
    278d:	4a 05 0f 06 66 05    	rex.WX add $0x566060f,%rax
    2793:	1b 06                	sbb    (%rsi),%eax
    2795:	67 06                	addr32 (bad)
    2797:	ac                   	lods   %ds:(%rsi),%al
    2798:	9e                   	sahf
    2799:	08 e4                	or     %ah,%ah
    279b:	74 2e                	je     27cb <balancer_ingress+0x27cb>
    279d:	08 f2                	or     %dh,%dl
    279f:	74 74                	je     2815 <balancer_ingress+0x2815>
    27a1:	05 10 74 05 0d       	add    $0xd057410,%eax
    27a6:	06                   	(bad)
    27a7:	75 06                	jne    27af <balancer_ingress+0x27af>
    27a9:	82                   	(bad)
    27aa:	05 12 06 68 05       	add    $0x5680612,%eax
    27af:	11 06                	adc    %eax,(%rsi)
    27b1:	74 05                	je     27b8 <balancer_ingress+0x27b8>
    27b3:	0f 2e 05 13 06 67 05 	ucomiss 0x5670613(%rip),%xmm0        # 5672dcd <bpf_xdp_adjust_head+0x566ae2d>
    27ba:	0f 06                	clts
    27bc:	74 05                	je     27c3 <balancer_ingress+0x27c3>
    27be:	0d 06 31 05 37       	or     $0x37053106,%eax
    27c3:	06                   	(bad)
    27c4:	74 05                	je     27cb <balancer_ingress+0x27cb>
    27c6:	40 06                	rex (bad)
    27c8:	bb 05 0d 06 74       	mov    $0x74060d05,%ebx
    27cd:	05 3e 74 05 0d       	add    $0xd05743e,%eax
    27d2:	06                   	(bad)
    27d3:	4b 05 2b 06 74 05    	rex.WXB add $0x574062b,%rax
    27d9:	0b 06                	or     (%rsi),%eax
    27db:	9f                   	lahf
    27dc:	05 1f 59 05 1d       	add    $0x1d05591f,%eax
    27e1:	06                   	(bad)
    27e2:	66 05 13 06          	add    $0x613,%ax
    27e6:	67 06                	addr32 (bad)
    27e8:	ac                   	lods   %ds:(%rsi),%al
    27e9:	9e                   	sahf
    27ea:	08 e4                	or     %ah,%ah
    27ec:	74 2e                	je     281c <balancer_ingress+0x281c>
    27ee:	08 f2                	or     %dh,%dl
    27f0:	74 74                	je     2866 <balancer_ingress+0x2866>
    27f2:	05 11 74 05 12       	add    $0x12057411,%eax
    27f7:	06                   	(bad)
    27f8:	75 05                	jne    27ff <balancer_ingress+0x27ff>
    27fa:	11 06                	adc    %eax,(%rsi)
    27fc:	82                   	(bad)
    27fd:	05 0f 06 30 05       	add    $0x530060f,%eax
    2802:	3c 06                	cmp    $0x6,%al
        if (stats_data) {
    2804:	74 05                	je     280b <balancer_ingress+0x280b>
    2806:	0f 06                	clts
    2808:	bd 05 41 e6 05       	mov    $0x5e64105,%ebp
    280d:	22 03                	and    (%rbx),%al
          stats_data->v1 += 1;
    280f:	e1 7d                	loope  288e <balancer_ingress+0x288e>
    2811:	08 ac 05 3b 06 c8 05 	or     %ch,0x5c8063b(%rbp,%rax,1)
    2818:	45 74 05             	rex.RB je 2820 <balancer_ingress+0x2820>
    281b:	22 74 05 18          	and    0x18(%rbp,%rax,1),%dh
      }
    281f:	2e 05 07 06 75 06    	cs add $0x6750607,%eax
    if (!dst) {
    2825:	82                   	(bad)
    2826:	05 09 06 2f 05       	add    $0x52f0609,%eax
    282b:	12 06                	adc    (%rsi),%al
    282d:	74 05                	je     2834 <balancer_ingress+0x2834>
    282f:	19 2e                	sbb    %ebp,(%rsi)
    2831:	05 16 74 05 09       	add    $0x9057416,%eax
      if (pckt.flow.proto == IPPROTO_TCP) {
    2836:	3c 05                	cmp    $0x5,%al
    2838:	07                   	(bad)
    2839:	06                   	(bad)
    283a:	2f                   	(bad)
    283b:	05 16 e6 05 1c       	add    $0x1c05e616,%eax
    2840:	06                   	(bad)
    2841:	74 05                	je     2848 <balancer_ingress+0x2848>
        __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
    2843:	07                   	(bad)
    2844:	3c 05                	cmp    $0x5,%al
    2846:	14 74                	adc    $0x74,%al
    2848:	05 07 06 2f 06       	add    $0x62f0607,%eax
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    284d:	03 90 7b e4 05 09    	add    0x905e47b(%rax),%edx
    2853:	06                   	(bad)
    2854:	03 28                	add    (%rax),%ebp
    2856:	d6                   	(bad)
    2857:	05 07 a0 06 ac       	add    $0xac06a007,%eax
    285c:	9e                   	sahf
    285d:	08 e4                	or     %ah,%ah
    285f:	74 2e                	je     288f <balancer_ingress+0x288f>
    2861:	08 f2                	or     %dh,%dl
    2863:	74 74                	je     28d9 <balancer_ingress+0x28d9>
    2865:	05 14 06 73 05       	add    $0x5730614,%eax
    286a:	08 76 05             	or     %dh,0x5(%rsi)
    286d:	07                   	(bad)
    286e:	06                   	(bad)
    286f:	82                   	(bad)
    2870:	05 05 06 2f 05       	add    $0x52f0605,%eax
    2875:	0f bc 05 04 06 08 20 	bsf    0x20080604(%rip),%eax        # 20082e80 <bpf_xdp_adjust_head+0x2007aee0>
    287c:	05 0d 74 05 09       	add    $0x905740d,%eax
    2881:	06                   	(bad)
    2882:	40 05 08 06 74 05    	rex add $0x5740608,%eax
    2888:	14 3c                	adc    $0x3c,%al
    288a:	05 12 74 05 29       	add    $0x29057412,%eax
    288f:	4a 05 07 66 05 05    	rex.WX add $0x5056607,%rax
    2895:	06                   	(bad)
    2896:	30 05 19 06 74 05    	xor    %al,0x5740619(%rip)        # 5742eb5 <bpf_xdp_adjust_head+0x573af15>
    289c:	1c 06                	sbb    $0x6,%al
    289e:	75 05                	jne    28a5 <balancer_ingress+0x28a5>
    28a0:	1b 06                	sbb    (%rsi),%eax
    28a2:	74 05                	je     28a9 <balancer_ingress+0x28a9>
    28a4:	05 3c 05 19 74       	add    $0x7419053c,%eax
    28a9:	05 03 06 4b 05       	add    $0x54b0603,%eax
    28ae:	05 2f 05 19 06       	add    $0x619052f,%eax
    28b3:	74 05                	je     28ba <balancer_ingress+0x28ba>
    28b5:	09 06                	or     %eax,(%rsi)
    28b7:	9f                   	lahf
    28b8:	05 1d 06 74 05       	add    $0x574061d,%eax
    28bd:	09 74 05 07          	or     %esi,0x7(%rbp,%rax,1)
        struct lb_stats* lru_stats =
    28c1:	06                   	(bad)
    28c2:	31 06                	xor    %eax,(%rsi)
    28c4:	03 45 90             	add    -0x70(%rbp),%eax
    28c7:	05 03 06 03 3e       	add    $0x3e030603,%eax
        if (!lru_stats) {
    28cc:	2e 05 07 03 b6 04    	cs add $0x4b60307,%eax
          return XDP_DROP;
    28d2:	74 05                	je     28d9 <balancer_ingress+0x28d9>
    28d4:	05 ad 05 17 bc       	add    $0xbc1705ad,%eax
    28d9:	05 15 08 59 05       	add    $0x5590815,%eax
    28de:	1b 06                	sbb    (%rsi),%eax
    28e0:	74 05                	je     28e7 <balancer_ingress+0x28e7>
        if (pckt.flags & F_SYN_SET) {
    28e2:	13 3c 05 03 06 67 05 	adc    0x5670603(,%rax,1),%edi
    28e9:	17                   	(bad)
    28ea:	06                   	(bad)
    28eb:	c8 05 21 74          	enter  $0x2105,$0x74
    28ef:	05 2d 74 05 03       	add    $0x305742d,%eax
          lru_stats->v1 += 1;
    28f4:	74 06                	je     28fc <balancer_ingress+0x28fc>
    28f6:	4b 05 01 9f 05 11    	rex.WXB add $0x11059f01,%rax
    28fc:	03 8e 02 66 05 15    	add    0x15056602(%rsi),%ecx
        } else {
    2902:	67 05 11 06 74 05    	addr32 add $0x5740611,%eax
          lru_stats->v2 += 1;
    2908:	0f 06                	clts
    290a:	2f                   	(bad)
    290b:	05 34 06 74 05       	add    $0x5740634,%eax
    2910:	0d 06 bb 05 1c       	or     $0x1c05bb06,%eax
    2915:	06                   	(bad)
      }
    2916:	58                   	pop    %rax
    2917:	05 18 74 05 0f       	add    $0xf057418,%eax
      if (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6, lru_map)) {
    291c:	06                   	(bad)
    291d:	67 05 37 06 74 05    	addr32 add $0x5740637,%eax
    2923:	13 06                	adc    (%rsi),%eax
    2925:	bc 05 07 03 f1       	mov    $0xf1030705,%esp
    292a:	7d 08                	jge    2934 <balancer_ingress+0x2934>
    292c:	90                   	nop
    292d:	06                   	(bad)
    292e:	ac                   	lods   %ds:(%rsi),%al
    292f:	9e                   	sahf
    2930:	08 e4                	or     %ah,%ah
    2932:	74 2e                	je     2962 <balancer_ingress+0x2962>
    2934:	08 f2                	or     %dh,%dl
    2936:	74 74                	je     29ac <balancer_ingress+0x29ac>
    2938:	05 14 06 73 05       	add    $0x5730614,%eax
    293d:	08 76 05             	or     %dh,0x5(%rsi)
    2940:	07                   	(bad)
    2941:	06                   	(bad)
    2942:	82                   	(bad)
    2943:	05 05 06 2f 05       	add    $0x52f0605,%eax
    2948:	07                   	(bad)
    2949:	30 05 05 91 05 17    	xor    %al,0x17059105(%rip)        # 1705ba54 <bpf_xdp_adjust_head+0x17053ab4>
    294f:	06                   	(bad)
    2950:	74 05                	je     2957 <balancer_ingress+0x2957>
    2952:	07                   	(bad)
    2953:	06                   	(bad)
    2954:	a0 05 05 91 05 17 06 	movabs 0x574061705910505,%al
    295b:	74 05 
    295d:	0d 06 03 88 02       	or     $0x2880306,%eax
  struct real_pos_lru new_dst_lru = {};
    2962:	ba 05 0f 30 05       	mov    $0x5300f05,%edx
    2967:	38 06                	cmp    %al,(%rsi)
    2969:	74 03                	je     296e <balancer_ingress+0x296e>
    296b:	ee                   	out    %al,(%dx)
    296c:	78 ba                	js     2928 <balancer_ingress+0x2928>
    296e:	05 0d 06 03 94       	add    $0x9403060d,%eax
    2973:	07                   	(bad)
    2974:	2e 05 2c 06 74 05    	cs add $0x574062c,%eax
  bool under_flood = false;
    297a:	09 06                	or     %eax,(%rsi)
    297c:	bc 05 0b 30 05       	mov    $0x5300b05,%esp
  bool src_found = false;
    2981:	35 06 74 05 3e       	xor    $0x3e057406,%eax
  __u64 cur_time = 0;
    2986:	06                   	(bad)
    2987:	bb 05 0b 06 74       	mov    $0x74060b05,%ebx
    298c:	05 3c 74 05 0b       	add    $0xb05743c,%eax
    2991:	06                   	(bad)
    2992:	4b 05 29 06 74 05    	rex.WXB add $0x5740629,%rax
    2998:	07                   	(bad)
    2999:	06                   	(bad)
    299a:	a0 05 12 06 58 05 09 	movabs 0x9206090558061205,%al
    29a1:	06 92 
  __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
    29a3:	05 27 06 74 05       	add    $0x5740627,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    29a8:	07                   	(bad)
    29a9:	06                   	(bad)
    29aa:	9f                   	lahf
    29ab:	05 09 59 05 29       	add    $0x29055909,%eax
    29b0:	06                   	(bad)
    29b1:	74 05                	je     29b8 <balancer_ingress+0x29b8>
    29b3:	0d 06 bc 05 07       	or     $0x705bc06,%eax
    29b8:	03 de                	add    %esi,%ebx
    29ba:	7d 08                	jge    29c4 <balancer_ingress+0x29c4>
    29bc:	90                   	nop
    29bd:	06                   	(bad)
    29be:	ac                   	lods   %ds:(%rsi),%al
    29bf:	9e                   	sahf
    29c0:	08 e4                	or     %ah,%ah
    29c2:	74 2e                	je     29f2 <balancer_ingress+0x29f2>
    29c4:	08 f2                	or     %dh,%dl
    29c6:	74 74                	je     2a3c <balancer_ingress+0x2a3c>
    29c8:	05 14 06 73 05       	add    $0x5730614,%eax
    29cd:	08 76 05             	or     %dh,0x5(%rsi)
    29d0:	07                   	(bad)
    29d1:	06                   	(bad)
    29d2:	82                   	(bad)
    29d3:	05 05 06 2f 05       	add    $0x52f0605,%eax
    29d8:	07                   	(bad)
    29d9:	30 05 05 91 05 17    	xor    %al,0x17059105(%rip)        # 1705bae4 <bpf_xdp_adjust_head+0x17053b44>
    29df:	06                   	(bad)
    29e0:	74 05                	je     29e7 <balancer_ingress+0x29e7>
    29e2:	07                   	(bad)
    29e3:	06                   	(bad)
    29e4:	a0 05 05 91 05 17 06 	movabs 0x374061705910505,%al
    29eb:	74 03 
    29ed:	f8                   	clc
    29ee:	7a ba                	jp     29aa <balancer_ingress+0x29aa>
    29f0:	05 03 06 03 a5       	add    $0xa5030603,%eax
    29f5:	07                   	(bad)
    29f6:	66 05 14 03          	add    $0x314,%ax
    29fa:	0a 2e                	or     (%rsi),%ch
    29fc:	05 12 06 74 05       	add    $0x5740612,%eax
    2a01:	08 06                	or     %al,(%rsi)
    2a03:	76 05                	jbe    2a0a <balancer_ingress+0x2a0a>
    2a05:	07                   	(bad)
    2a06:	06                   	(bad)
    2a07:	82                   	(bad)
    2a08:	05 0a 06 03 24       	add    $0x2403060a,%eax
    2a0d:	66 05 0e 06          	add    $0x60e,%ax
    2a11:	82                   	(bad)
    2a12:	05 13 66 05 1e       	add    $0x1e056613,%eax
    2a17:	74 05                	je     2a1e <balancer_ingress+0x2a1e>
    2a19:	2b 66 05             	sub    0x5(%rsi),%esp
  struct lb_stats* conn_rate_stats =
    2a1c:	0b 06                	or     (%rsi),%eax
    2a1e:	67 05 15 06 74 05    	addr32 add $0x5740615,%eax
  if (!conn_rate_stats) {
    2a24:	1b 2e                	sbb    (%rsi),%ebp
    2a26:	05 09 06 65 05       	add    $0x5650609,%eax
    2a2b:	2c 68                	sub    $0x68,%al
    return true;
    2a2d:	05 0d 03 e1 79       	add    $0x79e1030d,%eax
    2a32:	02 31                	add    (%rcx),%dh
    2a34:	01 05 26 06 c8 05    	add    %eax,0x5c80626(%rip)        # 5c83060 <bpf_xdp_adjust_head+0x5c7b0c0>
  *cur_time = bpf_ktime_get_ns();
    2a3a:	30 74 05 0d          	xor    %dh,0xd(%rbp,%rax,1)
    2a3e:	74 05                	je     2a45 <balancer_ingress+0x2a45>
    2a40:	0b 2e                	or     (%rsi),%ebp
    2a42:	05 08 06 75 05       	add    $0x5750608,%eax
    2a47:	07                   	(bad)
    2a48:	06                   	(bad)
    2a49:	82                   	(bad)
    2a4a:	05 05 06 2f 05       	add    $0x52f0605,%eax
    2a4f:	14 5a                	adc    $0x5a,%al
    2a51:	05 17 06 90 05       	add    $0x5900617,%eax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    2a56:	28 ac 05 07 3c 05 10 	sub    %ch,0x10053c07(%rbp,%rax,1)
    2a5d:	06                   	(bad)
    2a5e:	2f                   	(bad)
    2a5f:	05 0e 06 e4 05       	add    $0x5e4060e,%eax
    2a64:	09 06                	or     %eax,(%rsi)
    2a66:	75 05                	jne    2a6d <balancer_ingress+0x2a6d>
    2a68:	14 06                	adc    $0x6,%al
    2a6a:	74 05                	je     2a71 <balancer_ingress+0x2a71>
    2a6c:	12 74 05 09          	adc    0x9(%rbp,%rax,1),%dh
    2a70:	4a 05 23 9e 05 09    	rex.WX add $0x9059e23,%rax
    conn_rate_stats->v1 = 1;
    2a76:	3c 05                	cmp    $0x5,%al
    2a78:	07                   	(bad)
    2a79:	06                   	(bad)
    2a7a:	2f                   	(bad)
    2a7b:	05 16 5a 05 05       	add    $0x5055a16,%eax
    conn_rate_stats->v2 = *cur_time;
    2a80:	06                   	(bad)
    2a81:	74 05                	je     2a88 <balancer_ingress+0x2a88>
    2a83:	14 74                	adc    $0x74,%al
    2a85:	05 09 06 4c 05       	add    $0x54c0609,%eax
    2a8a:	12 06                	adc    (%rsi),%al
    2a8c:	74 05                	je     2a93 <balancer_ingress+0x2a93>
    2a8e:	07                   	(bad)
    2a8f:	2e 05 16 06 67 05    	cs add $0x5670616,%eax
  } else {
    2a95:	03 06                	add    (%rsi),%eax
    conn_rate_stats->v1 += 1;
    2a97:	66 05 14 74          	add    $0x7414,%ax
    2a9b:	05 0b 06 3d 06       	add    $0x63d060b,%eax
    2aa0:	ac                   	lods   %ds:(%rsi),%al
    2aa1:	9e                   	sahf
    2aa2:	08 e4                	or     %ah,%ah
    2aa4:	74 2e                	je     2ad4 <balancer_ingress+0x2ad4>
    2aa6:	08 f2                	or     %dh,%dl
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2aa8:	74 74                	je     2b1e <balancer_ingress+0x2b1e>
    2aaa:	05 04 74 05 09       	add    $0x9057404,%eax
    2aaf:	74 05                	je     2ab6 <balancer_ingress+0x2ab6>
    2ab1:	05 06 03 93 06       	add    $0x6930306,%eax
    2ab6:	3c 05                	cmp    $0x5,%al
      return true;
    2ab8:	2b 03                	sub    (%rbx),%eax
    2aba:	0c 2e                	or     $0x2e,%al
    2abc:	05 07 03 ae 7d       	add    $0x7dae0307,%eax
    2ac1:	02 38                	add    (%rax),%bh
  return false;
    2ac3:	01 05 0b 06 82 05    	add    %eax,0x582060b(%rip)        # 58230d4 <bpf_xdp_adjust_head+0x581b134>
    2ac9:	0e                   	(bad)
}
    2aca:	66 05 1f ac          	add    $0xac1f,%ax
    2ace:	05 2e 3c 05 07       	add    $0x7053c2e,%eax
  under_flood = is_under_flood(&cur_time);
    2ad3:	06                   	(bad)
    2ad4:	67 05 11 06 74 05    	addr32 add $0x5740611,%eax
  if (!src_found) {
    2ada:	17                   	(bad)
    2adb:	2e 05 2e 82 03 ed    	cs add $0xed03822e,%eax
    2ae1:	7a 66                	jp     2b49 <balancer_ingress+0x2b49>
    2ae3:	05 09 06 03 28       	add    $0x28030609,%eax
    bool hash_16bytes = is_ipv6;
    2ae8:	d6                   	(bad)
    2ae9:	05 07 a0 06 ac       	add    $0xac06a007,%eax
    2aee:	9e                   	sahf
    2aef:	08 e4                	or     %ah,%ah
    2af1:	74 2e                	je     2b21 <balancer_ingress+0x2b21>
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    2af3:	08 f2                	or     %dh,%dl
    2af5:	74 74                	je     2b6b <balancer_ingress+0x2b6b>
    2af7:	05 14 06 73 05       	add    $0x5730614,%eax
    2afc:	08 76 05             	or     %dh,0x5(%rsi)
    2aff:	07                   	(bad)
    2b00:	06                   	(bad)
    2b01:	82                   	(bad)
    2b02:	05 05 06 2f 05       	add    $0x52f0605,%eax
      pckt->flow.port16[0] = pckt->flow.port16[1];
    2b07:	0f bc 05 04 06 08 20 	bsf    0x20080604(%rip),%eax        # 20083112 <bpf_xdp_adjust_head+0x2007b172>
    2b0e:	05 0d 74 05 09       	add    $0x905740d,%eax
    2b13:	06                   	(bad)
    2b14:	40 05 08 06 74 05    	rex add $0x5740608,%eax
      memset(pckt->flow.srcv6, 0, 16);
    2b1a:	14 3c                	adc    $0x3c,%al
    2b1c:	05 12 74 05 29       	add    $0x29057412,%eax
    2b21:	4a 05 07 66 05 05    	rex.WX add $0x5056607,%rax
    2b27:	06                   	(bad)
    2b28:	30 05 19 06 74 05    	xor    %al,0x5740619(%rip)        # 5743147 <bpf_xdp_adjust_head+0x573b1a7>
    2b2e:	1c 06                	sbb    $0x6,%al
    2b30:	75 05                	jne    2b37 <balancer_ingress+0x2b37>
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    2b32:	1b 06                	sbb    (%rsi),%eax
    2b34:	74 05                	je     2b3b <balancer_ingress+0x2b3b>
    2b36:	05 3c 05 19 74       	add    $0x7419053c,%eax
    2b3b:	05 03 06 4b 05       	add    $0x54b0603,%eax
    2b40:	05 2f 05 19 06       	add    $0x619052f,%eax
    2b45:	74 05                	je     2b4c <balancer_ingress+0x2b4c>
    2b47:	09 06                	or     %eax,(%rsi)
    2b49:	9f                   	lahf
    2b4a:	05 1d 06 74 05       	add    $0x574061d,%eax
  if (hash_16bytes) {
    2b4f:	09 74 05 07          	or     %esi,0x7(%rbp,%rax,1)
    2b53:	06                   	(bad)
    2b54:	31 06                	xor    %eax,(%rsi)
    2b56:	03 45 90             	add    -0x70(%rbp),%eax
        jhash(pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6),
    2b59:	05 03 06 03 3e       	add    $0x3e030603,%eax
    2b5e:	2e 05 07 03 d4 04    	cs add $0x4d40307,%eax
    2b64:	74 05                	je     2b6b <balancer_ingress+0x2b6b>
    2b66:	1c cb                	sbb    $0xcb,%al
    2b68:	06                   	(bad)
    2b69:	ac                   	lods   %ds:(%rsi),%al
    2b6a:	9e                   	sahf
    2b6b:	02 23                	add    (%rbx),%ah
    2b6d:	12 74 2e 08          	adc    0x8(%rsi,%rbp,1),%dh
        pckt->flow.ports,
    2b71:	f2 74 74             	bnd je 2be8 <balancer_ingress+0x2be8>
    2b74:	05 0b 74 05 09       	add    $0x905740b,%eax
    2b79:	06                   	(bad)
    2b7a:	75 06                	jne    2b82 <balancer_ingress+0x2b82>
    2b7c:	82                   	(bad)
    2b7d:	05 19 06 67 05       	add    $0x5670619,%eax
    return jhash_2words(
    2b82:	32 06                	xor    (%rsi),%al
    2b84:	c8 05 43 74          	enter  $0x4305,$0x74
    2b88:	05 49 74 05 19       	add    $0x19057449,%eax
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    2b8d:	4a 05 0d 2e 05 0b    	rex.WX add $0xb052e0d,%rax
    2b93:	06                   	(bad)
    2b94:	75 06                	jne    2b9c <balancer_ingress+0x2b9c>
    2b96:	82                   	(bad)
    2b97:	05 0a 06 69 05       	add    $0x569060a,%eax
    2b9c:	0e                   	(bad)
    2b9d:	06                   	(bad)
    2b9e:	74 05                	je     2ba5 <balancer_ingress+0x2ba5>
    2ba0:	0f 06                	clts
    2ba2:	75 05                	jne    2ba9 <balancer_ingress+0x2ba9>
    2ba4:	27                   	(bad)
    2ba5:	9f                   	lahf
    2ba6:	06                   	(bad)
    2ba7:	ac                   	lods   %ds:(%rsi),%al
    2ba8:	9e                   	sahf
    2ba9:	08 e4                	or     %ah,%ah
    2bab:	74 2e                	je     2bdb <balancer_ingress+0x2bdb>
    2bad:	08 f2                	or     %dh,%dl
}
    2baf:	74 74                	je     2c25 <balancer_ingress+0x2c25>
    2bb1:	05 1a 74 05 0d       	add    $0xd05741a,%eax
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    2bb6:	06                   	(bad)
    2bb7:	75 06                	jne    2bbf <balancer_ingress+0x2bbf>
    2bb9:	82                   	(bad)
    2bba:	05 0b 06 2f 05       	add    $0x52f060b,%eax
    2bbf:	1a 06                	sbb    (%rsi),%al
    2bc1:	74 05                	je     2bc8 <balancer_ingress+0x2bc8>
    key = RING_SIZE * (vip_info->vip_num) + hash;
    2bc3:	07                   	(bad)
    2bc4:	06                   	(bad)
    2bc5:	a0 05 05 2f 05 03 2f 	movabs 0xa052f03052f0505,%al
    2bcc:	05 0a 
    2bce:	03 c4                	add    %esp,%eax
    2bd0:	02 2e                	add    (%rsi),%ch
    2bd2:	05 09 06 82 05       	add    $0x5820609,%eax
    2bd7:	0b 06                	or     (%rsi),%eax
    2bd9:	67 05 1b 06 74 05    	addr32 add $0x574061b,%eax
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    2bdf:	0b 3c 05 0f 06 67 05 	or     0x567060f(,%rax,1),%edi
    2be6:	0d a0 06 ac 9e       	or     $0x9eac06a0,%eax
    2beb:	08 e4                	or     %ah,%ah
    2bed:	74 2e                	je     2c1d <balancer_ingress+0x2c1d>
    2bef:	08 f2                	or     %dh,%dl
    2bf1:	74 74                	je     2c67 <balancer_ingress+0x2c67>
    2bf3:	05 1a 06 73 05       	add    $0x573061a,%eax
    2bf8:	0e                   	(bad)
    2bf9:	76 05                	jbe    2c00 <balancer_ingress+0x2c00>
    2bfb:	0d 06 82 05 0b       	or     $0xb058206,%eax
    2c00:	06                   	(bad)
    2c01:	2f                   	(bad)
    2c02:	05 0d e6 05 18       	add    $0x1805e60d,%eax
    2c07:	06                   	(bad)
    2c08:	74 05                	je     2c0f <balancer_ingress+0x2c0f>
    2c0a:	0d 66 05 0b 06       	or     $0x60b0566,%eax
    2c0f:	30 05 19 06 74 05    	xor    %al,0x5740619(%rip)        # 574322e <bpf_xdp_adjust_head+0x573b28e>
    2c15:	09 06                	or     %eax,(%rsi)
    2c17:	9f                   	lahf
    2c18:	05 0b 33 05 19       	add    $0x1905330b,%eax
    2c1d:	06                   	(bad)
    2c1e:	74 05                	je     2c25 <balancer_ingress+0x2c25>
    2c20:	07                   	(bad)
    2c21:	06                   	(bad)
    2c22:	bc 05 28 2f 05       	mov    $0x52f2805,%esp
    2c27:	32 06                	xor    (%rsi),%al
    2c29:	74 05                	je     2c30 <balancer_ingress+0x2c30>
    2c2b:	3b 66 05             	cmp    0x5(%rsi),%esp
    2c2e:	17                   	(bad)
    2c2f:	06                   	(bad)
    2c30:	03 e4                	add    %esp,%esp
    2c32:	78 02                	js     2c36 <balancer_ingress+0x2c36>
    2c34:	3a 01                	cmp    (%rcx),%al
    2c36:	05 08 08 75 75       	add    $0x75750808,%eax
    2c3b:	05 09 76 03 46       	add    $0x46037609,%eax
    2c40:	08 82 05 07 a0 06    	or     %al,0x6a00705(%rdx)
    2c46:	ac                   	lods   %ds:(%rsi),%al
    2c47:	9e                   	sahf
    2c48:	08 e4                	or     %ah,%ah
    2c4a:	74 2e                	je     2c7a <balancer_ingress+0x2c7a>
    2c4c:	08 f2                	or     %dh,%dl
    2c4e:	74 74                	je     2cc4 <balancer_ingress+0x2cc4>
    2c50:	05 14 06 73 05       	add    $0x5730614,%eax
    2c55:	08 76 05             	or     %dh,0x5(%rsi)
    if (!real_pos) {
    2c58:	07                   	(bad)
    2c59:	06                   	(bad)
    2c5a:	82                   	(bad)
    2c5b:	05 05 06 2f 05       	add    $0x52f0605,%eax
    2c60:	0f bc 05 04 06 08 20 	bsf    0x20080604(%rip),%eax        # 2008326b <bpf_xdp_adjust_head+0x2007b2cb>
      return false;
    2c67:	05 0d 74 05 09       	add    $0x905740d,%eax
    2c6c:	06                   	(bad)
    2c6d:	40 05 08 06 74 05    	rex add $0x5740608,%eax
    key = *real_pos;
    2c73:	14 3c                	adc    $0x3c,%al
    2c75:	05 12 74 05 29       	add    $0x29057412,%eax
    2c7a:	4a 05 07 66 05 05    	rex.WX add $0x5056607,%rax
    if (key == 0) {
    2c80:	06                   	(bad)
    2c81:	30 05 19 06 74 05    	xor    %al,0x5740619(%rip)        # 57432a0 <bpf_xdp_adjust_head+0x573b300>
    2c87:	1c 06                	sbb    $0x6,%al
    2c89:	75 05                	jne    2c90 <balancer_ingress+0x2c90>
  __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
    2c8b:	1b 06                	sbb    (%rsi),%eax
    2c8d:	74 05                	je     2c94 <balancer_ingress+0x2c94>
    2c8f:	05 3c 05 19 74       	add    $0x7419053c,%eax
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    2c94:	05 03 06 4b 05       	add    $0x54b0603,%eax
    2c99:	05 2f 05 19 06       	add    $0x619052f,%eax
    2c9e:	74 05                	je     2ca5 <balancer_ingress+0x2ca5>
    2ca0:	09 06                	or     %eax,(%rsi)
    2ca2:	9f                   	lahf
    2ca3:	05 1d 06 74 05       	add    $0x574061d,%eax
    2ca8:	09 74 05 07          	or     %esi,0x7(%rbp,%rax,1)
    2cac:	06                   	(bad)
    2cad:	31 06                	xor    %eax,(%rsi)
    2caf:	03 45 90             	add    -0x70(%rbp),%eax
    2cb2:	05 03 06 03 3e       	add    $0x3e030603,%eax
    2cb7:	2e 05 01 75 05 0f    	cs add $0xf057501,%eax
    2cbd:	03 27                	add    (%rdi),%esp
    2cbf:	66 05 07 03          	add    $0x307,%ax
    2cc3:	1f                   	(bad)
    2cc4:	82                   	(bad)
    2cc5:	05 19 c9 05 0a       	add    $0xa05c919,%eax
    2cca:	06                   	(bad)
    2ccb:	66 05 09 06          	add    $0x609,%ax
    2ccf:	84 05 13 06 74 05    	test   %al,0x5740613(%rip)        # 57432e8 <bpf_xdp_adjust_head+0x573b348>
    2cd5:	19 2e                	sbb    %ebp,(%rsi)
    2cd7:	05 09 66 05 1e       	add    $0x1e056609,%eax
    2cdc:	06                   	(bad)
    2cdd:	32 05 07 06 ac 05    	xor    0x5ac0607(%rip),%al        # 5ac32ea <bpf_xdp_adjust_head+0x5abb34a>
    2ce3:	1c 74                	sbb    $0x74,%al
    2ce5:	05 0e 06 4b 05       	add    $0x54b060e,%eax
    2cea:	07                   	(bad)
    2ceb:	06                   	(bad)
    2cec:	74 05                	je     2cf3 <balancer_ingress+0x2cf3>
    2cee:	1c 06                	sbb    $0x6,%al
    2cf0:	08 14 05 22 06 74 05 	or     %dl,0x5740622(,%rax,1)
    2cf7:	07                   	(bad)
    2cf8:	06                   	(bad)
    2cf9:	03 8d 7f 08 4a 05    	add    0x54a087f(%rbp),%ecx
    2cff:	0f 92 05 09 06 08 12 	setb   0x12080609(%rip)        # 1208330f <bpf_xdp_adjust_head+0x1207b36f>
    2d06:	06                   	(bad)
    2d07:	75 05                	jne    2d0e <balancer_ingress+0x2d0e>
  struct lb_stats* ch_drop_stats =
    2d09:	14 06                	adc    $0x6,%al
    2d0b:	74 05                	je     2d12 <balancer_ingress+0x2d12>
    2d0d:	0c 06                	or     $0x6,%al
  if (!ch_drop_stats) {
    2d0f:	80 05 05 06 58 05 19 	addb   $0x19,0x5580605(%rip)        # 558331b <bpf_xdp_adjust_head+0x557b37b>
    2d16:	06                   	(bad)
    2d17:	87 05 24 06 74 05    	xchg   %eax,0x5740624(%rip)        # 5743341 <bpf_xdp_adjust_head+0x573b3a1>
  ch_drop_stats->v2 += 1;
    2d1d:	29 2e                	sub    %ebp,(%rsi)
    2d1f:	05 34 74 05 0c       	add    $0xc057434,%eax
    2d24:	82                   	(bad)
    2d25:	05 05 58 05 01       	add    $0x1055805,%eax
    2d2a:	06                   	(bad)
    2d2b:	68 05 30 03 eb       	push   $0xffffffffeb033005
      return false;
    2d30:	00 66 05             	add    %ah,0x5(%rsi)
    2d33:	0a 06                	or     (%rsi),%al
    2d35:	90                   	nop
    2d36:	05 18 06 67 05       	add    $0x5670618,%eax
  }
    2d3b:	15 06 74 05 2b       	adc    $0x2b057406,%eax
  pckt->real_index = key;
    2d40:	74 05                	je     2d47 <balancer_ingress+0x2d47>
    2d42:	09 66 05             	or     %esp,0x5(%rsi)
    2d45:	10 06                	adc    %al,(%rsi)
    2d47:	68 06 ac 9e 08       	push   $0x89eac06
  *real = bpf_map_lookup_elem(&reals, &key);
    2d4c:	e4 74                	in     $0x74,%al
    2d4e:	2e 08 f2             	cs or  %dh,%dl
    2d51:	74 74                	je     2dc7 <balancer_ingress+0x2dc7>
    2d53:	05 0e 74 05 0a       	add    $0xa05740e,%eax
    2d58:	06                   	(bad)
    2d59:	75 05                	jne    2d60 <balancer_ingress+0x2d60>
    2d5b:	09 06                	or     %eax,(%rsi)
    2d5d:	82                   	(bad)
    2d5e:	05 07 06 2f 05       	add    $0x52f0607,%eax
    2d63:	0c bc                	or     $0xbc,%al
    2d65:	05 0b 06 74 05       	add    $0x574060b,%eax
    2d6a:	09 2e                	or     %ebp,(%rsi)
    2d6c:	05 0d 06 67 05       	add    $0x567060d,%eax
    2d71:	09 06                	or     %eax,(%rsi)
    2d73:	74 06                	je     2d7b <balancer_ingress+0x2d7b>
    2d75:	03 b7 7f 66 05 07    	add    0x705667f(%rdi),%esi
    2d7b:	a0 06 ac 9e 08 e4 74 	movabs 0x82e74e4089eac06,%al
    2d82:	2e 08 
    2d84:	f2 74 74             	bnd je 2dfb <balancer_ingress+0x2dfb>
    2d87:	05 14 06 73 05       	add    $0x5730614,%eax
    2d8c:	08 76 05             	or     %dh,0x5(%rsi)
    2d8f:	07                   	(bad)
    2d90:	06                   	(bad)
    2d91:	82                   	(bad)
    2d92:	05 05 06 2f 05       	add    $0x52f0605,%eax
    2d97:	03 30                	add    (%rax),%esi
    2d99:	05 15 06 74 05       	add    $0x5740615,%eax
    2d9e:	07                   	(bad)
    2d9f:	06                   	(bad)
    2da0:	03 c7                	add    %edi,%eax
    2da2:	00 ba 05 03 bc 05    	add    %bh,0x5bc0305(%rdx)
    2da8:	16                   	(bad)
    2da9:	2f                   	(bad)
    2daa:	05 03 06 66 05       	add    $0x5660603,%eax
    2daf:	14 74                	adc    $0x74,%al
    2db1:	05 0b 06 3d 06       	add    $0x63d060b,%eax
    2db6:	ac                   	lods   %ds:(%rsi),%al
    2db7:	9e                   	sahf
    2db8:	08 e4                	or     %ah,%ah
    2dba:	74 2e                	je     2dea <balancer_ingress+0x2dea>
    2dbc:	08 f2                	or     %dh,%dl
    2dbe:	74 74                	je     2e34 <balancer_ingress+0x2e34>
    2dc0:	05 04 74 05 09       	add    $0x9057404,%eax
    2dc5:	74 05                	je     2dcc <balancer_ingress+0x2dcc>
    2dc7:	0a 06                	or     (%rsi),%al
    2dc9:	3d 05 08 06 74       	cmp    $0x74060805,%eax
  if (!(*real)) {
    2dce:	05 07 4a 05 09       	add    $0x9054a07,%eax
    2dd3:	06                   	(bad)
    2dd4:	03 a3 7f 66 05 07    	add    0x705667f(%rbx),%esp
    2dda:	a0 06 ac 9e 08 e4 74 	movabs 0x82e74e4089eac06,%al
    2de1:	2e 08 
  __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
    2de3:	f2 74 74             	bnd je 2e5a <balancer_ingress+0x2e5a>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    2de6:	05 14 06 73 05       	add    $0x5730614,%eax
    2deb:	08 76 05             	or     %dh,0x5(%rsi)
    2dee:	07                   	(bad)
    2def:	06                   	(bad)
    2df0:	82                   	(bad)
    2df1:	05 05 06 2f 05       	add    $0x52f0605,%eax
    2df6:	03 30                	add    (%rax),%esi
    2df8:	05 15 06 74 05       	add    $0x5740615,%eax
    2dfd:	05 06 03 db 00       	add    $0xdb0306,%eax
    2e02:	9e                   	sahf
    2e03:	05 07 92 05 0f       	add    $0xf059207,%eax
    2e08:	06                   	(bad)
    2e09:	82                   	(bad)
    2e0a:	05 14 2e 05 1e       	add    $0x1e052e14,%eax
    2e0f:	74 05                	je     2e16 <balancer_ingress+0x2e16>
    2e11:	24 2e                	and    $0x2e,%al
    2e13:	05 34 66 05 07       	add    $0x7056634,%eax
    2e18:	2e 05 09 06 91 05    	cs add $0x5910609,%eax
    2e1e:	1a 06                	sbb    (%rsi),%al
    2e20:	ac                   	lods   %ds:(%rsi),%al
    2e21:	05 09 3c 05 1b       	add    $0x1b053c09,%eax
    2e26:	06                   	(bad)
    2e27:	2f                   	(bad)
    2e28:	05 19 06 74 05       	add    $0x5740619,%eax
    2e2d:	17                   	(bad)
    2e2e:	06                   	(bad)
    2e2f:	76 05                	jbe    2e36 <balancer_ingress+0x2e36>
    2e31:	15 06 66 05 05       	adc    $0x5056606,%eax
    2e36:	06                   	(bad)
    2e37:	67 05 19 06 c8 05    	addr32 add $0x5c80619,%eax
    2e3d:	23 74 05 2f          	and    0x2f(%rbp,%rax,1),%esi
    2e41:	74 05                	je     2e48 <balancer_ingress+0x2e48>
    2e43:	05 74 05 03 06       	add    $0x6030574,%eax
    2e48:	4c 05 0b 03 cd 06    	rex.WR add $0x6cd030b,%rax
    2e4e:	74 05                	je     2e55 <balancer_ingress+0x2e55>
    2e50:	09 91 05 32 e8 05    	or     %edx,0x5e83205(%rcx)
    2e56:	3c 06                	cmp    $0x6,%al
    2e58:	74 05                	je     2e5f <balancer_ingress+0x2e5f>
  struct lb_stats* ch_drop_stats =
    2e5a:	09 06                	or     %eax,(%rsi)
    2e5c:	03 ca                	add    %edx,%ecx
    2e5e:	7c 02                	jl     2e62 <balancer_ingress+0x2e62>
  if (!ch_drop_stats) {
    2e60:	31 01                	xor    %eax,(%rcx)
    2e62:	05 07 a0 06 ac       	add    $0xac06a007,%eax
    2e67:	9e                   	sahf
    2e68:	08 e4                	or     %ah,%ah
    return;
    2e6a:	74 2e                	je     2e9a <balancer_ingress+0x2e9a>
  ch_drop_stats->v1 += 1;
    2e6c:	08 f2                	or     %dh,%dl
    2e6e:	74 74                	je     2ee4 <balancer_ingress+0x2ee4>
    2e70:	05 1a 06 73 05       	add    $0x573061a,%eax
    2e75:	08 76 05             	or     %dh,0x5(%rsi)
    2e78:	07                   	(bad)
    2e79:	06                   	(bad)
    2e7a:	82                   	(bad)
    2e7b:	05 05 06 2f 05       	add    $0x52f0605,%eax
    return false;
    2e80:	21 e6                	and    %esp,%esi
    2e82:	05 1a 91 05 39       	add    $0x3905911a,%eax
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    2e87:	06                   	(bad)
    2e88:	90                   	nop
    2e89:	05 36 74 05 47       	add    $0x47057436,%eax
    2e8e:	2e 05 1a 06 2f 05    	cs add $0x52f061a,%eax
    2e94:	39 06                	cmp    %eax,(%rsi)
    2e96:	9e                   	sahf
    2e97:	05 36 74 05 47       	add    $0x47057436,%eax
    2e9c:	3c 05                	cmp    $0x5,%al
    2e9e:	1a 06                	sbb    (%rsi),%al
    2ea0:	2f                   	(bad)
    2ea1:	05 39 06 9e 05       	add    $0x59e0639,%eax
    2ea6:	36 74 05             	ss je  2eae <balancer_ingress+0x2eae>
    2ea9:	47 3c 05             	rex.RXB cmp $0x5,%al
    if (pckt->flow.proto == IPPROTO_UDP) {
    2eac:	1a 06                	sbb    (%rsi),%al
    2eae:	2f                   	(bad)
    2eaf:	05 39 06 9e 05       	add    $0x59e0639,%eax
    2eb4:	36 74 05             	ss je  2ebc <balancer_ingress+0x2ebc>
    2eb7:	49 ac                	rex.WB lods %ds:(%rsi),%al
    2eb9:	05 11 06 2f 05       	add    $0x52f0611,%eax
      new_dst_lru.atime = cur_time;
    2ebe:	14 06                	adc    $0x6,%al
    2ec0:	08 12                	or     %dl,(%rdx)
    2ec2:	05 27 74 05 2e       	add    $0x2e057427,%eax
    2ec7:	2e 05 2b 74 03 ac    	cs add $0xac03742b,%eax
    new_dst_lru.pos = key;
    2ecd:	7b ac                	jnp    2e7b <balancer_ingress+0x2e7b>
    2ecf:	05 08 06 03 cf       	add    $0xcf030608,%eax
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    2ed4:	04 08                	add    $0x8,%al
    2ed6:	20 05 15 88 05 30    	and    %al,0x30058815(%rip)        # 3005b6f1 <bpf_xdp_adjust_head+0x30053751>
    2edc:	06                   	(bad)
    2edd:	ac                   	lods   %ds:(%rsi),%al
    2ede:	05 2d ac 05 08       	add    $0x805ac2d,%eax
    2ee3:	58                   	pop    %rax
    2ee4:	05 31 06 83 05       	add    $0x5830631,%eax
    2ee9:	36 06                	ss (bad)
    2eeb:	74 05                	je     2ef2 <balancer_ingress+0x2ef2>
    2eed:	16                   	(bad)
    2eee:	3c 05                	cmp    $0x5,%al
    2ef0:	2f                   	(bad)
    2ef1:	74 05                	je     2ef8 <balancer_ingress+0x2ef8>
    2ef3:	16                   	(bad)
    2ef4:	3c 05                	cmp    $0x5,%al
    2ef6:	08 58 05             	or     %bl,0x5(%rax)
    2ef9:	22 06                	and    (%rsi),%al
  return true;
    2efb:	83 05 30 06 08 12 05 	addl   $0x5,0x12080630(%rip)        # 12083532 <bpf_xdp_adjust_head+0x1207b592>
      if (!get_packet_dst(&dst, &pckt, vip_info, is_ipv6, lru_map)) {
    2f02:	33 08                	xor    (%rax),%ecx
    2f04:	12 03                	adc    (%rbx),%al
    2f06:	a9 7b ba 05 08       	test   $0x805ba7b,%eax
        return XDP_DROP;
    2f0b:	03 d7                	add    %edi,%edx
    2f0d:	04 66                	add    $0x66,%al
    2f0f:	05 07 06 83 05       	add    $0x5830607,%eax
    2f14:	1b c9                	sbb    %ecx,%ecx
    2f16:	05 21 06 74 05       	add    $0x5740621,%eax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    2f1b:	0b 3c 05 1c 06 67 06 	or     0x667061c(,%rax,1),%edi
    2f22:	ac                   	lods   %ds:(%rsi),%al
    2f23:	9e                   	sahf
    2f24:	08 e4                	or     %ah,%ah
    2f26:	74 2e                	je     2f56 <balancer_ingress+0x2f56>
    2f28:	08 f2                	or     %dh,%dl
    2f2a:	74 74                	je     2fa0 <balancer_ingress+0x2fa0>
    2f2c:	05 0c 74 05 0a       	add    $0xa05740c,%eax
    2f31:	06                   	(bad)
    2f32:	75 05                	jne    2f39 <balancer_ingress+0x2f39>
    2f34:	09 06                	or     %eax,(%rsi)
    2f36:	82                   	(bad)
    2f37:	05 07 06 2f 05       	add    $0x52f0607,%eax
    2f3c:	06                   	(bad)
    2f3d:	bc 05 14 06 74       	mov    $0x74061405,%esp
    2f42:	05 03 06 76 05       	add    $0x5760603,%eax
    2f47:	45 03 9f 03 9e 05 0b 	add    0xb059e03(%r15),%r11d
    2f4e:	06                   	(bad)
    2f4f:	74 05                	je     2f56 <balancer_ingress+0x2f56>
  __u32 vip_miss_stats_key = 0;
    2f51:	09 06                	or     %eax,(%rsi)
    2f53:	2f                   	(bad)
    2f54:	05 07 e8 05 16       	add    $0x1605e807,%eax
    2f59:	06                   	(bad)
    2f5a:	74 05                	je     2f61 <balancer_ingress+0x2f61>
      bpf_map_lookup_elem(&vip_miss_stats, &vip_miss_stats_key);
    2f5c:	03 06                	add    (%rsi),%eax
    2f5e:	bc 05 0a 30 06       	mov    $0x6300a05,%esp
    2f63:	ac                   	lods   %ds:(%rsi),%al
    2f64:	9e                   	sahf
    2f65:	08 e4                	or     %ah,%ah
    2f67:	74 2e                	je     2f97 <balancer_ingress+0x2f97>
    2f69:	08 f2                	or     %dh,%dl
    2f6b:	74 74                	je     2fe1 <balancer_ingress+0x2fe1>
    2f6d:	05 08 74 06 76       	add    $0x76067408,%eax
    2f72:	05 07 06 82 05       	add    $0x5820607,%eax
    2f77:	05 06 2f 05 10       	add    $0x10052f06,%eax
    2f7c:	e7 06                	out    %eax,$0x6
    2f7e:	ac                   	lods   %ds:(%rsi),%al
    2f7f:	9e                   	sahf
    2f80:	08 e4                	or     %ah,%ah
    2f82:	74 2e                	je     2fb2 <balancer_ingress+0x2fb2>
    2f84:	08 f2                	or     %dh,%dl
    2f86:	74 74                	je     2ffc <balancer_ingress+0x2ffc>
    2f88:	05 0e 74 05 08       	add    $0x805740e,%eax
    2f8d:	06                   	(bad)
    2f8e:	75 05                	jne    2f95 <balancer_ingress+0x2f95>
    2f90:	07                   	(bad)
    2f91:	06                   	(bad)
    2f92:	82                   	(bad)
    2f93:	05 05 06 2f 05       	add    $0x52f0605,%eax
    2f98:	03 e6                	add    %esi,%esp
    2f9a:	05 12 06 74 05       	add    $0x5740612,%eax
    2f9f:	15 06 9f 05 03       	adc    $0x3059f06,%eax
    2fa4:	06                   	(bad)
    2fa5:	90                   	nop
    2fa6:	05 12 74 05 10       	add    $0x10057412,%eax
    2fab:	06                   	(bad)
    2fac:	85 06                	test   %eax,(%rsi)
    2fae:	ac                   	lods   %ds:(%rsi),%al
    2faf:	9e                   	sahf
    2fb0:	08 e4                	or     %ah,%ah
    2fb2:	74 2e                	je     2fe2 <balancer_ingress+0x2fe2>
    2fb4:	08 f2                	or     %dh,%dl
    2fb6:	74 74                	je     302c <balancer_ingress+0x302c>
    2fb8:	05 0e 74 05 08       	add    $0x805740e,%eax
    2fbd:	06                   	(bad)
    2fbe:	75 05                	jne    2fc5 <balancer_ingress+0x2fc5>
    2fc0:	07                   	(bad)
    2fc1:	06                   	(bad)
    2fc2:	82                   	(bad)
    2fc3:	05 05 06 2f 05       	add    $0x52f0605,%eax
    2fc8:	03 e6                	add    %esi,%esp
    2fca:	05 12 06 74 05       	add    $0x5740612,%eax
  struct vip_definition* lru_miss_stat_vip =
    2fcf:	15 06 9f 05 03       	adc    $0x3059f06,%eax
    2fd4:	06                   	(bad)
    2fd5:	90                   	nop
  if (!lru_miss_stat_vip) {
    2fd6:	05 12 74 05 19       	add    $0x19057412,%eax
    2fdb:	06                   	(bad)
    2fdc:	89 05 17 06 74 05    	mov    %eax,0x5740617(%rip)        # 57435f9 <bpf_xdp_adjust_head+0x573b659>
    return XDP_DROP;
    2fe2:	07                   	(bad)
    2fe3:	06                   	(bad)
    2fe4:	75 05                	jne    2feb <balancer_ingress+0x2feb>
    2fe6:	12 06                	adc    (%rsi),%al
    2fe8:	ac                   	lods   %ds:(%rsi),%al
    2fe9:	05 07 66 05 18       	add    $0x18056607,%eax
    2fee:	06                   	(bad)
  bool address_match = (is_ipv6 &&
    2fef:	67 05 1d 06 74 05    	addr32 add $0x574061d,%eax
    2ff5:	23 74 05 33          	and    0x33(%rbp,%rax,1),%esi
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    2ff9:	66 05 38 74          	add    $0x7438,%ax
    2ffd:	04 0d                	add    $0xd,%al
    2fff:	05 07 06 03 96       	add    $0x96030607,%eax
    3004:	78 02                	js     3008 <balancer_ingress+0x3008>
    3006:	39 01                	cmp    %eax,(%rcx)
    3008:	05 1c 06 c8 05       	add    $0x5c8061c,%eax
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    300d:	07                   	(bad)
    300e:	74 9e                	je     2fae <balancer_ingress+0x2fae>
    3010:	05 05 06 2f 05       	add    $0x52f0605,%eax
    3015:	17                   	(bad)
    3016:	bc 05 1c 06 74       	mov    $0x74061c05,%esp
    301b:	05 08 3c 05 1b       	add    $0x1b053c08,%eax
    3020:	06                   	(bad)
    3021:	75 05                	jne    3028 <balancer_ingress+0x3028>
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    3023:	20 06                	and    %al,(%rsi)
    3025:	74 05                	je     302c <balancer_ingress+0x302c>
    3027:	0c 4a                	or     $0x4a,%al
    3029:	05 0d 06 75 05       	add    $0x575060d,%eax
    302e:	0b 06                	or     (%rsi),%eax
    3030:	74 05                	je     3037 <balancer_ingress+0x3037>
    3032:	0a 06                	or     (%rsi),%al
    3034:	75 05                	jne    303b <balancer_ingress+0x303b>
    3036:	0f 06                	clts
                         lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
    3038:	74 05                	je     303f <balancer_ingress+0x303f>
    303a:	08 4a 05             	or     %cl,0x5(%rdx)
    303d:	0d 06 75 05 12       	or     $0x12057506,%eax
    3042:	06                   	(bad)
    3043:	74 05                	je     304a <balancer_ingress+0x304a>
    3045:	0b 4a 05             	or     0x5(%rdx),%ecx
    3048:	07                   	(bad)
    3049:	06                   	(bad)
    304a:	75 05                	jne    3051 <balancer_ingress+0x3051>
    304c:	0f 06                	clts
    304e:	74 05                	je     3055 <balancer_ingress+0x3055>
    3050:	15 4a 05 13 74       	adc    $0x7413054a,%eax
    3055:	05 1e 3c 05 21       	add    $0x21053c1e,%eax
      (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
    305a:	2e 05 29 74 05 2f    	cs add $0x2f057429,%eax
    3060:	4a 05 2d 74 05 38    	rex.WX add $0x3805742d,%rax
    3066:	3c 05                	cmp    $0x5,%al
    3068:	3b 2e                	cmp    (%rsi),%ebp
    306a:	05 40 74 05 46       	add    $0x46057440,%eax
    306f:	4a 05 44 74 05 07    	rex.WX add $0x7057444,%rax
    3075:	3c 05                	cmp    $0x5,%al
    3077:	05 06 2f 05 0a       	add    $0xa052f06,%eax
    307c:	bc 05 1b 06 74       	mov    $0x74061b05,%esp
    3081:	05 03 74 05 0a       	add    $0xa057403,%eax
    3086:	06                   	(bad)
    3087:	bb 05 1d 06 74       	mov    $0x74061d05,%ebx
    308c:	05 03 74 06 c9       	add    $0xc9067403,%eax
    3091:	05 14 06 74 05       	add    $0x5740614,%eax
  bool address_match = (is_ipv6 &&
    3096:	07                   	(bad)
    3097:	06                   	(bad)
    3098:	68 05 0b c9 05       	push   $0x5c90b05
  bool port_match = lru_miss_stat_vip->port == vip->port;
    309d:	1b 75 05             	sbb    0x5(%rbp),%esi
    30a0:	31 06                	xor    %eax,(%rsi)
    30a2:	ac                   	lods   %ds:(%rsi),%al
    30a3:	05 46 9e 04 0e       	add    $0xe049e46,%eax
    30a8:	05 03 06 03 57       	add    $0x57030603,%eax
    30ad:	08 9e 05 0c 06 74    	or     %bl,0x74060c05(%rsi)
    30b3:	05 03 06 67 05       	add    $0x5670603,%eax
    30b8:	0c 06                	or     $0x6,%al
    30ba:	74 05                	je     30c1 <balancer_ingress+0x30c1>
    30bc:	03 06                	add    (%rsi),%eax
    30be:	75 05                	jne    30c5 <balancer_ingress+0x30c5>
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    30c0:	0c 06                	or     $0x6,%al
    30c2:	74 05                	je     30c9 <balancer_ingress+0x30c9>
    30c4:	0e                   	(bad)
    30c5:	06                   	(bad)
    30c6:	75 05                	jne    30cd <balancer_ingress+0x30cd>
    30c8:	14 06                	adc    $0x6,%al
    30ca:	66 05 12 74          	add    $0x7412,%ax
    30ce:	05 03 2e 05 0c       	add    $0xc052e03,%eax
    30d3:	74 04                	je     30d9 <balancer_ingress+0x30d9>
    30d5:	0d 05 13 06 03       	or     $0x3061305,%eax
    30da:	27                   	(bad)
    30db:	3c 05                	cmp    $0x5,%al
    30dd:	1d 06 66 05 11       	sbb    $0x11056606,%eax
  bool vip_match = address_match && port_match && proto_match;
    30e2:	4a 05 03 06 75 05    	rex.WX add $0x5750603,%rax
    30e8:	0b 59 05             	or     0x5(%rcx),%ebx
    30eb:	1b 75 05             	sbb    0x5(%rbp),%esi
    30ee:	31 06                	xor    %eax,(%rsi)
    30f0:	ac                   	lods   %ds:(%rsi),%al
    30f1:	05 3c 74 05 41       	add    $0x4105743c,%eax
    30f6:	2e 04 0e             	cs add $0xe,%al
    30f9:	05 03 06 03 53       	add    $0x53030603,%eax
    30fe:	08 9e 05 0c 06 74    	or     %bl,0x74060c05(%rsi)
    3104:	05 03 06 67 05       	add    $0x5670603,%eax
    3109:	0c 06                	or     $0x6,%al
    310b:	74 05                	je     3112 <balancer_ingress+0x3112>
    310d:	03 06                	add    (%rsi),%eax
    310f:	75 05                	jne    3116 <balancer_ingress+0x3116>
    3111:	0c 06                	or     $0x6,%al
    3113:	74 05                	je     311a <balancer_ingress+0x311a>
    3115:	0e                   	(bad)
    3116:	06                   	(bad)
    3117:	75 05                	jne    311e <balancer_ingress+0x311e>
    3119:	14 06                	adc    $0x6,%al
    311b:	66 05 12 74          	add    $0x7412,%ax
  if (vip_match) {
    311f:	05 03 2e 05 0c       	add    $0xc052e03,%eax
    3124:	74 04                	je     312a <balancer_ingress+0x312a>
    3126:	0d 05 13 06 03       	or     $0x3061305,%eax
    __u32 lru_stats_key = pckt->real_index;
    312b:	2b 3c 05 11 06 66 06 	sub    0x6660611(,%rax,1),%edi
    3132:	77 05                	ja     3139 <balancer_ingress+0x3139>
    3134:	17                   	(bad)
    3135:	06                   	(bad)
    3136:	74 05                	je     313d <balancer_ingress+0x313d>
    3138:	1d 74 05 22 4a       	sbb    $0x4a220574,%eax
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    313d:	05 29 74 05 35       	add    $0x35057429,%eax
    3142:	74 05                	je     3149 <balancer_ingress+0x3149>
    3144:	42 74 04             	rex.X je 314b <balancer_ingress+0x314b>
    3147:	0e                   	(bad)
    3148:	05 03 02 2f 12       	add    $0x122f0203,%eax
    314d:	05 11 74 05 0a       	add    $0xa057411,%eax
    3152:	06                   	(bad)
    3153:	9f                   	lahf
    3154:	05 10 06 74 05       	add    $0x5740610,%eax
    3159:	03 4a 05             	add    0x5(%rdx),%ecx
    315c:	15 06 ae 05 18       	adc    $0x1805ae06,%eax
    3161:	06                   	(bad)
    3162:	74 05                	je     3169 <balancer_ingress+0x3169>
    3164:	20 58 05             	and    %bl,0x5(%rax)
    3167:	14 3c                	adc    $0x3c,%al
    3169:	05 03 2e 05 12       	add    $0x12052e03,%eax
    316e:	74 05                	je     3175 <balancer_ingress+0x3175>
    3170:	18 06                	sbb    %al,(%rsi)
    3172:	bb 05 1b 06 74       	mov    $0x74061b05,%ebx
    3177:	05 23 3c 05 17       	add    $0x17053c23,%eax
    317c:	3c 05                	cmp    $0x5,%al
    317e:	03 2e                	add    (%rsi),%ebp
    3180:	05 15 74 05 13       	add    $0x13057415,%eax
    3185:	06                   	(bad)
    3186:	40 05 03 06 66 05    	rex add $0x5660603,%eax
    318c:	11 74 05 17          	adc    %esi,0x17(%rbp,%rax,1)
    3190:	06                   	(bad)
    3191:	3d 06 03 a4 7f       	cmp    $0x7fa40306,%eax
    3196:	08 3c 03             	or     %bh,(%rbx,%rax,1)
    3199:	dc 00                	faddl  (%rax)
    319b:	66 05 03 3c          	add    $0x3c03,%ax
    319f:	05 15 74 05 03       	add    $0x3057415,%eax
    31a4:	06                   	(bad)
    31a5:	4b 05 13 06 74 05    	rex.WXB add $0x5740613,%rax
    31ab:	0a 06                	or     (%rsi),%al
    31ad:	4b 05 21 06 74 05    	rex.WXB add $0x5740621,%rax
    31b3:	03 74 05 0a          	add    0xa(%rbp,%rax,1),%esi
    if (!lru_miss_stat) {
    31b7:	06                   	(bad)
    31b8:	e5 05                	in     $0x5,%eax
    31ba:	21 06                	and    %eax,(%rsi)
    31bc:	74 05                	je     31c3 <balancer_ingress+0x31c3>
      return XDP_DROP;
    31be:	03 74 04 0d          	add    0xd(%rsp,%rax,1),%esi
    31c2:	06                   	(bad)
    31c3:	03 76 e4             	add    -0x1c(%rsi),%esi
    31c6:	04 00                	add    $0x0,%al
    31c8:	05 09 03 cf 07       	add    $0x7cf0309,%eax
    *lru_miss_stat += 1;
    31cd:	74 05                	je     31d4 <balancer_ingress+0x31d4>
    31cf:	07                   	(bad)
    31d0:	91                   	xchg   %eax,%ecx
    31d1:	05 03 e6 05 18       	add    $0x1805e603,%eax
    31d6:	59                   	pop    %rcx
    31d7:	05 1d 06 74 05       	add    $0x574061d,%eax
  return FURTHER_PROCESSING;
    31dc:	2a 74 05 2f          	sub    0x2f(%rbp,%rax,1),%dh
    31e0:	74 04                	je     31e6 <balancer_ingress+0x31e6>
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    31e2:	0d 05 28 06 03       	or     $0x3062805,%eax
    31e7:	bb 78 02 30 01       	mov    $0x1300278,%ebx
        return XDP_DROP;
    31ec:	05 3e 06 ac 05       	add    $0x5ac063e,%eax
    31f1:	49 74 04             	rex.WB je 31f8 <balancer_ingress+0x31f8>
    31f4:	0e                   	(bad)
    31f5:	05 15 06 03 48       	add    $0x48030615,%eax
      data_stats->v2 += 1;
    31fa:	e4 06                	in     $0x6,%al
    31fc:	03 55 08             	add    0x8(%rbp),%edx
    31ff:	3c 05                	cmp    $0x5,%al
    3201:	09 03                	or     %eax,(%rbx)
    3203:	2b 66 05             	sub    0x5(%rsi),%esp
    3206:	0d 06 67 05 10       	or     $0x10056706,%eax
    320b:	e5 05                	in     $0x5,%eax
  }
    320d:	0d 06 66 05 19       	or     $0x19056606,%eax
  cval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos);
    3212:	06                   	(bad)
    3213:	d7                   	xlat   %ds:(%rbx)
    3214:	05 24 06 9e 04       	add    $0x49e0624,%eax
    3219:	0d 05 09 06 03       	or     $0x3060905,%eax
    321e:	35 58 67 05 07       	xor    $0x7056758,%eax
    3223:	ae                   	scas   %es:(%rdi),%al
    3224:	05 1c 06 c8 05       	add    $0x5c8061c,%eax
    3229:	07                   	(bad)
    322a:	74 9e                	je     31ca <balancer_ingress+0x31ca>
    322c:	05 05 06 2f 05       	add    $0x52f0605,%eax
    3231:	17                   	(bad)
    3232:	bc 05 1c 06 74       	mov    $0x74061c05,%esp
    3237:	05 08 3c 05 1b       	add    $0x1b053c08,%eax
    323c:	06                   	(bad)
    323d:	75 05                	jne    3244 <balancer_ingress+0x3244>
    323f:	20 06                	and    %al,(%rsi)
    3241:	74 05                	je     3248 <balancer_ingress+0x3248>
    3243:	0c 4a                	or     $0x4a,%al
    3245:	05 0d 06 75 05       	add    $0x575060d,%eax
    324a:	0b 06                	or     (%rsi),%eax
    324c:	74 05                	je     3253 <balancer_ingress+0x3253>
    324e:	09 06                	or     %eax,(%rsi)
    3250:	75 05                	jne    3257 <balancer_ingress+0x3257>
    3252:	0e                   	(bad)
    3253:	06                   	(bad)
    3254:	74 05                	je     325b <balancer_ingress+0x325b>
    3256:	07                   	(bad)
    3257:	4a 05 0d 06 75 05    	rex.WX add $0x575060d,%rax
    325d:	12 06                	adc    (%rsi),%al
    325f:	74 05                	je     3266 <balancer_ingress+0x3266>
    3261:	0b 4a 05             	or     0x5(%rdx),%ecx
    3264:	07                   	(bad)
    3265:	06                   	(bad)
    3266:	75 05                	jne    326d <balancer_ingress+0x326d>
    3268:	0f 06                	clts
    326a:	74 05                	je     3271 <balancer_ingress+0x3271>
    326c:	15 4a 05 13 74       	adc    $0x7413054a,%eax
    3271:	05 1e 3c 05 21       	add    $0x21053c1e,%eax
    3276:	2e 05 29 74 05 2f    	cs add $0x2f057429,%eax
    327c:	4a 05 2d 74 05 38    	rex.WX add $0x3805742d,%rax
    3282:	3c 05                	cmp    $0x5,%al
    3284:	3b 2e                	cmp    (%rsi),%ebp
    3286:	05 3f 74 05 45       	add    $0x4505743f,%eax
  if (!cval) {
    328b:	4a 05 43 74 05 07    	rex.WX add $0x7057443,%rax
    3291:	3c 05                	cmp    $0x5,%al
    3293:	05 06 2f 05 0a       	add    $0xa052f06,%eax
    return XDP_DROP;
    3298:	bc 05 1b 06 74       	mov    $0x74061b05,%esp
    329d:	05 03 74 05 0a       	add    $0xa057403,%eax
    32a2:	06                   	(bad)
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    32a3:	bb 05 1d 06 74       	mov    $0x74061d05,%ebx
    32a8:	05 03 74 06 c9       	add    $0xc9067403,%eax
    32ad:	05 14 06 74 05       	add    $0x5740614,%eax
    32b2:	11 06                	adc    %eax,(%rsi)
    32b4:	68 05 16 06 74       	push   $0x74061605
    32b9:	05 1c 74 05 21       	add    $0x2105741c,%eax
    32be:	4a 05 29 66 05 2e    	rex.WX add $0x2e056629,%rax
    32c4:	74 05                	je     32cb <balancer_ingress+0x32cb>
    32c6:	33 2e                	xor    (%rsi),%ebp
    32c8:	04 0e                	add    $0xe,%al
    32ca:	05 09 06 03 43       	add    $0x43030609,%eax
    32cf:	02 2e                	add    (%rsi),%ch
    32d1:	01 05 03 ad 05 10    	add    %eax,0x1005ad03(%rip)        # 1005dfda <bpf_xdp_adjust_head+0x1005603a>
    32d7:	06                   	(bad)
    32d8:	74 05                	je     32df <balancer_ingress+0x32df>
    32da:	03 06                	add    (%rsi),%eax
    32dc:	9f                   	lahf
    32dd:	05 0c 06 74 05       	add    $0x574060c,%eax
    32e2:	03 06                	add    (%rsi),%eax
    32e4:	9f                   	lahf
    32e5:	05 11 06 74 05       	add    $0x5740611,%eax
    32ea:	13 06                	adc    (%rsi),%eax
    32ec:	67 05 03 06 66 05    	addr32 add $0x5660603,%eax
    32f2:	11 74 05 03          	adc    %esi,0x3(%rbp,%rax,1)
    32f6:	06                   	(bad)
    32f7:	3d 05 0e 06 74       	cmp    $0x74060e05,%eax
    32fc:	06                   	(bad)
    32fd:	68 05 03 06 66       	push   $0x66060305
    3302:	05 0c 74 05 12       	add    $0x1205740c,%eax
    3307:	06                   	(bad)
    3308:	40 06                	rex (bad)
    330a:	03 bd 7f 08 74 03    	add    0x374087f(%rbp),%edi
    3310:	c3                   	ret
    3311:	00 66 05             	add    %ah,0x5(%rsi)
    3314:	03 3c 05 10 74 05 03 	add    0x3057410(,%rax,1),%edi
    331b:	06                   	(bad)
    331c:	4b 05 0b 06 74 05    	rex.WXB add $0x574060b,%rax
  if (!data_stats) {
    3322:	10 06                	adc    %al,(%rsi)
    3324:	67 05 03 06 66 05    	addr32 add $0x5660603,%eax
    return XDP_DROP;
    332a:	0e                   	(bad)
    332b:	74 05                	je     3332 <balancer_ingress+0x3332>
    332d:	10 06                	adc    %al,(%rsi)
    332f:	3d 05 03 06 66       	cmp    $0x66060305,%eax
    3334:	05 0e 74 05 03       	add    $0x305740e,%eax
  data_stats->v1 += 1;
    3339:	06                   	(bad)
    333a:	3d 05 0c 06 74       	cmp    $0x74060c05,%eax
    333f:	05 14 06 4b 04       	add    $0x44b0614,%eax
    3344:	0c 05                	or     $0x5,%al
    3346:	21 03                	and    %eax,(%rbx)
  data_stats->v2 += pkt_bytes;
    3348:	6d                   	insl   (%dx),%es:(%rdi)
    3349:	08 58 05             	or     %bl,0x5(%rax)
    334c:	0a 06                	or     (%rsi),%al
    334e:	4a 05 0c 06 4c 05    	rex.WX add $0x54c060c,%rax
    3354:	13 06                	adc    (%rsi),%eax
    3356:	74 05                	je     335d <balancer_ingress+0x335d>
    3358:	15 4a 05 03 4a       	adc    $0x4a03054a,%eax
    335d:	05 1b 06 2f 05       	add    $0x52f061b,%eax
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    3362:	0e                   	(bad)
    3363:	06                   	(bad)
    3364:	e4 05                	in     $0x5,%al
    3366:	06                   	(bad)
    3367:	58                   	pop    %rax
    3368:	05 0b 4a 05 33       	add    $0x33054a0b,%eax
    336d:	06                   	(bad)
    336e:	65 05 03 06 90 05    	gs add $0x5900603,%eax
    3374:	1d 06 31 05 1c       	sbb    $0x1c053106,%eax
    3379:	06                   	(bad)
    337a:	4a 05 0a 06 03 67    	rex.WX add $0x6703060a,%rax
    3380:	74 05                	je     3387 <balancer_ingress+0x3387>
    3382:	11 06                	adc    %eax,(%rsi)
    3384:	74 05                	je     338b <balancer_ingress+0x338b>
    3386:	03 4a 05             	add    0x5(%rdx),%ecx
    3389:	09 06                	or     %eax,(%rsi)
    338b:	2f                   	(bad)
    338c:	05 0e 06 4a 05       	add    $0x54a060e,%eax
    3391:	09 82 05 0f 06 2f    	or     %eax,0x2f060f05(%rdx)
    3397:	05 14 06 4a 05       	add    $0x54a0614,%eax
    339c:	21 66 05             	and    %esp,0x5(%rsi)
    339f:	26 4a 05 1e 4a 05 0c 	es rex.WX add $0xc054a1e,%rax
    33a6:	3c 05                	cmp    $0x5,%al
    33a8:	17                   	(bad)
    33a9:	06                   	(bad)
    33aa:	48 05 03 06 90 05    	add    $0x5900603,%rax
    33b0:	0b 06                	or     (%rsi),%eax
    33b2:	32 05 0a 06 4a 05    	xor    0x54a060a(%rip),%al        # 54a39c2 <bpf_xdp_adjust_head+0x549ba22>
    33b8:	0b 06                	or     (%rsi),%eax
    33ba:	03 15 4a 05 04 06    	add    0x604054a(%rip),%edx        # 604390a <bpf_xdp_adjust_head+0x603b96a>
    33c0:	58                   	pop    %rax
    33c1:	05 09 4a 04 0e       	add    $0xe044a09,%eax
    33c6:	05 10 06 03 0f       	add    $0xf030610,%eax
    33cb:	3c 05                	cmp    $0x5,%al
    33cd:	03 06                	add    (%rsi),%eax
    33cf:	9e                   	sahf
    33d0:	05 0e 74 04 0d       	add    $0xd04740e,%eax
    33d5:	05 03 06 03 2e       	add    $0x2e030603,%eax
    33da:	4a 04 00             	rex.WX add $0x0,%al
  if (!data_stats) {
    33dd:	05 09 03 b1 07       	add    $0x7b10309,%eax
    33e2:	74 05                	je     33e9 <balancer_ingress+0x33e9>
    33e4:	07                   	(bad)
    return XDP_DROP;
    33e5:	91                   	xchg   %eax,%ecx
    33e6:	06                   	(bad)
    33e7:	03 d7                	add    %edi,%edx
    33e9:	77 ba                	ja     33a5 <balancer_ingress+0x33a5>
    33eb:	05 03 06 03 ad       	add    $0xad030603,%eax
    33f0:	08 2e                	or     %ch,(%rsi)
    33f2:	05 01 9f 05 05       	add    $0x5059f01,%eax
  data_stats->v1 += 1;
    33f7:	03 15 66 85 05 01    	add    0x1058566(%rip),%edx        # 105b963 <bpf_xdp_adjust_head+0x10539c3>
    33fd:	a0 02 0f 00 01 01 04 	movabs 0xa040101000f02,%al
    3404:	0a 00 
  data_stats->v2 += pkt_bytes;
    3406:	09 02                	or     %eax,(%rdx)
    3408:	80 77 00 00          	xorb   $0x0,0x0(%rdi)
    340c:	00 00                	add    %al,(%rax)
    340e:	00 00                	add    %al,(%rax)
    3410:	03 36                	add    (%rsi),%esi
    3412:	01 05 1c 0a 08 22    	add    %eax,0x22080a1c(%rip)        # 22083e34 <bpf_xdp_adjust_head+0x2207be94>
    3418:	05 18 06 4a 05       	add    $0x54a0618,%eax
  pckt.flow.port16[0] = original_sport;
    341d:	1f                   	(bad)
    341e:	06                   	(bad)
    341f:	4c 05 1d 06 3c 05    	rex.WR add $0x53c061d,%rax
    3425:	26 58                	es pop %rax
    3427:	05 0d 3c 05 09       	add    $0x9053c0d,%eax
  if (dst->flags & F_IPV6) {
    342c:	3c 05                	cmp    $0x5,%al
    342e:	05 3c 05 11 06       	add    $0x611053c,%eax
    3433:	3e 05 03 06 4a 05    	ds add $0x54a0603,%eax
    3439:	12 06                	adc    (%rsi),%al
    343b:	67 05 0a 06 4a 05    	addr32 add $0x54a060a,%eax
    3441:	07                   	(bad)
    if (!PCKT_ENCAP_V6(xdp, cval, is_ipv6, &pckt, dst, pkt_bytes)) {
    3442:	2e 05 12 06 67 05    	cs add $0x5670612,%eax
    3448:	0a 06                	or     (%rsi),%al
    344a:	4a 05 07 3c 05 12    	rex.WX add $0x12053c07,%rax
    3450:	06                   	(bad)
    3451:	67 05 0a 06 4a 05    	addr32 add $0x54a060a,%eax
    3457:	07                   	(bad)
    3458:	3c 05                	cmp    $0x5,%al
    345a:	05 06 67 05 0c       	add    $0xc056706,%eax
    345f:	02 ea                	add    %dl,%ch
    3461:	01 13                	add    %edx,(%rbx)
    3463:	05 07 91 05 03       	add    $0x3059107,%eax
    3468:	03 7a ba             	add    -0x46(%rdx),%edi
    346b:	05 0b 60 05 03       	add    $0x305600b,%eax
    3470:	06                   	(bad)
    3471:	66 03 bb 7f 9e 03 c5 	add    -0x3afc6181(%rbx),%di
    3478:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    347b:	bb 7f ac 03 c5       	mov    $0xc503ac7f,%ebx
    3480:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    3483:	bb 7f ac 03 c5       	mov    $0xc503ac7f,%ebx
    3488:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    348b:	bb 7f ac 03 c5       	mov    $0xc503ac7f,%ebx
    3490:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    3493:	bb 7f ac 03 c5       	mov    $0xc503ac7f,%ebx
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    3498:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    349b:	bb 7f ac 03 c5       	mov    $0xc503ac7f,%ebx
    34a0:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    34a3:	bb 7f ac 03 c5       	mov    $0xc503ac7f,%ebx
    34a8:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    34ab:	bb 7f ac 03 c5       	mov    $0xc503ac7f,%ebx
    34b0:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    34b3:	bb 7f 74 03 c5       	mov    $0xc503747f,%ebx
    return false;
    34b8:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    34bb:	bb 7f 74 03 c5       	mov    $0xc503747f,%ebx
    34c0:	00 3c 03             	add    %bh,(%rbx,%rax,1)
  data = (void*)(long)xdp->data;
    34c3:	bb 7f 74 03 c5       	mov    $0xc503747f,%ebx
    34c8:	00 3c 03             	add    %bh,(%rbx,%rax,1)
    34cb:	bb 7f 74 03 c5       	mov    $0xc503747f,%ebx
    34d0:	00 3c 05 11 06 ae 05 	add    %bh,0x5ae0611(,%rax,1)
  data_end = (void*)(long)xdp->data_end;
    34d7:	0c 06                	or     $0x6,%al
    34d9:	4a 05 17 4a 05 09    	rex.WX add $0x9054a17,%rax
    34df:	3c 05                	cmp    $0x5,%al
    34e1:	11 06                	adc    %eax,(%rsi)
    34e3:	68 05 0c 06 4a       	push   $0x4a060c05
  new_eth = data;
    34e8:	05 17 4a 05 09       	add    $0x9054a17,%eax
    34ed:	3c 05                	cmp    $0x5,%al
    34ef:	11 06                	adc    %eax,(%rsi)
    34f1:	68 05 0c 06 4a       	push   $0x4a060c05
  ip6h = data + sizeof(struct ethhdr);
    34f6:	05 16 4a 05 09       	add    $0x9054a16,%eax
    34fb:	3c 05                	cmp    $0x5,%al
    34fd:	0c 06                	or     $0x6,%al
    34ff:	68 05 09 06 82       	push   $0xffffffff82060905
    3504:	05 11 06 68 05       	add    $0x5680611,%eax
  old_eth = data + sizeof(struct ipv6hdr);
    3509:	0c 06                	or     $0x6,%al
    350b:	4a 05 16 4a 05 09    	rex.WX add $0x9054a16,%rax
    3511:	3c 05                	cmp    $0x5,%al
    3513:	11 06                	adc    %eax,(%rsi)
    3515:	68 05 0c 06 4a       	push   $0x4a060c05
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    351a:	05 16 4a 05 09       	add    $0x9054a16,%eax
    351f:	3c 05                	cmp    $0x5,%al
    3521:	11 06                	adc    %eax,(%rsi)
    3523:	68 05 0c 06 4a       	push   $0x4a060c05
    3528:	05 16 4a 05 09       	add    $0x9054a16,%eax
    352d:	3c 05                	cmp    $0x5,%al
    352f:	0c 06                	or     $0x6,%al
    3531:	68 05 09 06 82       	push   $0xffffffff82060905
    3536:	05 11 06 68 05       	add    $0x5680611,%eax
    353b:	0c 06                	or     $0x6,%al
    353d:	4a 05 16 4a 05 09    	rex.WX add $0x9054a16,%rax
    3543:	3c 05                	cmp    $0x5,%al
    3545:	11 06                	adc    %eax,(%rsi)
    3547:	68 05 0c 06 4a       	push   $0x4a060c05
    354c:	05 16 4a 05 09       	add    $0x9054a16,%eax
    3551:	3c 05                	cmp    $0x5,%al
    3553:	11 06                	adc    %eax,(%rsi)
    3555:	68 05 0c 06 4a       	push   $0x4a060c05
    355a:	05 16 4a 05 09       	add    $0x9054a16,%eax
    return false;
    355f:	3c 05                	cmp    $0x5,%al
    3561:	0c 06                	or     $0x6,%al
    3563:	68 05 09 06 74       	push   $0x74060905
  memcpy(new_eth->h_dest, cval->mac, 6);
    3568:	05 07 06 67 02       	add    $0x2670607,%eax
    356d:	e0 01                	loopne 3570 <balancer_ingress+0x3570>
    356f:	14 05                	adc    $0x5,%al
    3571:	0a 31                	or     (%rcx),%dh
    3573:	05 03 06 3c 02       	add    $0x23c0603,%eax
    3578:	06                   	(bad)
    3579:	00 01                	add    %al,(%rcx)
    357b:	01 04 0a             	add    %eax,(%rdx,%rcx,1)
    357e:	00 09                	add    %cl,(%rcx)
    3580:	02 40 7b             	add    0x7b(%rax),%al
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    3583:	00 00                	add    %al,(%rax)
    3585:	00 00                	add    %al,(%rax)
    3587:	00 00                	add    %al,(%rax)
    3589:	03 ed                	add    %ebp,%ebp
    358b:	00 01                	add    %al,(%rcx)
    358d:	05 19 0a 08 13       	add    $0x13080a19,%eax
    3592:	05 1c 06 3c 05       	add    $0x53c061c,%eax
    3597:	22 3c 05 2a 3c 05 3a 	and    0x3a053c2a(,%rax,1),%bh
  new_eth->h_proto = BE_ETH_P_IPV6;
    359e:	66 05 0a 3c          	add    $0x3c0a,%ax
    35a2:	05 03 90 02 06       	add    $0x6029003,%eax
    35a7:	00 01                	add    %al,(%rcx)
    35a9:	01 04 0a             	add    %eax,(%rdx,%rcx,1)
  if (is_ipv6) {
    35ac:	00 09                	add    %cl,(%rcx)
    35ae:	02 80 7b 00 00 00    	add    0x7b(%rax),%al
    35b4:	00 00                	add    %al,(%rax)
    35b6:	00 03                	add    %al,(%rbx)
    proto = IPPROTO_IPV6;
    35b8:	e5 00                	in     $0x0,%eax
    35ba:	01 05 08 0a 08 3d    	add    %eax,0x3d080a08(%rip)        # 3d083fc8 <bpf_xdp_adjust_head+0x3d07c028>
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
    35c0:	05 05 06 3c 05       	add    $0x53c0605,%eax
    35c5:	08 06                	or     %al,(%rsi)
    35c7:	67 05 05 06 3c 05    	addr32 add $0x53c0605,%eax
    35cd:	08 06                	or     %al,(%rsi)
    35cf:	67 05 05 06 3c 05    	addr32 add $0x53c0605,%eax
    35d5:	03 06                	add    (%rsi),%eax
    35d7:	67 05 0a 02 e0 01    	addr32 add $0x1e0020a,%eax
    35dd:	13 05 03 06 3c 02    	adc    0x23c0603(%rip),%eax        # 23c3be6 <bpf_xdp_adjust_head+0x23bbc46>
    35e3:	06                   	(bad)
    35e4:	00 01                	add    %al,(%rcx)
    35e6:	01 04 0a             	add    %eax,(%rdx,%rcx,1)
    35e9:	00 09                	add    %cl,(%rcx)
    35eb:	02 a0 7c 00 00 00    	add    0x7c(%rax),%ah
  saddr[0] = IPIP_V6_PREFIX1;
    35f1:	00 00                	add    %al,(%rax)
    35f3:	00 18                	add    %bl,(%rax)
    35f5:	05 0b 0a ad 05       	add    $0x5ad0a0b,%eax
    35fa:	13 06                	adc    (%rsi),%eax
  saddr[1] = IPIP_V6_PREFIX2;
    35fc:	3c 05                	cmp    $0x5,%al
    35fe:	10 3c 05 1d 2e 05 27 	adc    %bh,0x27052e1d(,%rax,1)
    3605:	3c 05                	cmp    $0x5,%al
    3607:	2f                   	(bad)
    3608:	58                   	pop    %rax
  saddr[2] = IPIP_V6_PREFIX3;
    3609:	05 22 3c 05 1a       	add    $0x1a053c22,%eax
    360e:	4a 05 03 2e 02 06    	rex.WX add $0x6022e03,%rax
    3614:	00 01                	add    %al,(%rcx)
    3616:	01                   	.byte 0x1

Disassembly of section .debug_line_str:

0000000000000000 <.debug_line_str>:
int balancer_ingress(struct xdp_md* ctx) {
   0:	2f                   	(bad)
   1:	72 6f                	jb     72 <balancer_ingress+0x72>
   3:	6f                   	outsl  %ds:(%rsi),(%dx)
   4:	74 2f                	je     35 <balancer_ingress+0x35>
   6:	57                   	push   %rdi
   7:	6f                   	outsl  %ds:(%rsi),(%dx)
   8:	72 6b                	jb     75 <balancer_ingress+0x75>
   a:	73 70                	jae    7c <balancer_ingress+0x7c>
   c:	61                   	(bad)
   d:	63 65 2f             	movsxd 0x2f(%rbp),%esp
  10:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  14:	61                   	(bad)
  15:	6e                   	outsb  %ds:(%rsi),(%dx)
  void* data = (void*)(long)ctx->data;
  16:	2f                   	(bad)
  17:	5f                   	pop    %rdi
  18:	62 75                	(bad)
  1a:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
  21:	73 
  22:	2f                   	(bad)
  23:	62                   	(bad)
  24:	70 66                	jo     8c <balancer_ingress+0x8c>
  26:	70 72                	jo     9a <balancer_ingress+0x9a>
  void* data_end = (void*)(long)ctx->data_end;
  28:	6f                   	outsl  %ds:(%rsi),(%dx)
  29:	67 00 2e             	add    %ch,(%esi)
  2c:	2f                   	(bad)
  2d:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  31:	61                   	(bad)
  32:	6e                   	outsb  %ds:(%rsi),(%dx)
  33:	2f                   	(bad)
  34:	6c                   	insb   (%dx),%es:(%rdi)
  35:	69 62 2f 62 70 66 00 	imul   $0x667062,0x2f(%rdx),%esp
  struct ethhdr* eth = data;
  3c:	2f                   	(bad)
  3d:	75 73                	jne    b2 <balancer_ingress+0xb2>
  3f:	72 2f                	jb     70 <balancer_ingress+0x70>
  41:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  nh_off = sizeof(struct ethhdr);
  48:	2f                   	(bad)
  49:	61                   	(bad)
  4a:	73 6d                	jae    b9 <balancer_ingress+0xb9>
  4c:	2d 67 65 6e 65       	sub    $0x656e6567,%eax
  if (data + nh_off > data_end) {
  51:	72 69                	jb     bc <balancer_ingress+0xbc>
  53:	63 00                	movsxd (%rax),%eax
  55:	2f                   	(bad)
  56:	75 73                	jne    cb <balancer_ingress+0xcb>
  58:	72 2f                	jb     89 <balancer_ingress+0x89>
  5a:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  61:	2f                   	(bad)
  62:	6c                   	insb   (%dx),%es:(%rdi)
  63:	69 6e 75 78 00 2e 2f 	imul   $0x2f2e0078,0x75(%rsi),%ebp
    return XDP_DROP;
  6a:	2e 68 65 61 64 65    	cs push $0x65646165
  70:	72 5f                	jb     d1 <balancer_ingress+0xd1>
  72:	6f                   	outsl  %ds:(%rsi),(%dx)
  73:	76 65                	jbe    da <balancer_ingress+0xda>
  75:	72 72                	jb     e9 <balancer_ingress+0xe9>
  77:	69 64 65 2f 36 2f 6b 	imul   $0x616b2f36,0x2f(%rbp,%riz,2),%esp
  7e:	61 
  eth_proto = eth->h_proto;
  7f:	74 72                	je     f3 <balancer_ingress+0xf3>
  81:	61                   	(bad)
  82:	6e                   	outsb  %ds:(%rsi),(%dx)
  83:	2f                   	(bad)
  84:	6c                   	insb   (%dx),%es:(%rdi)
  85:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
  if (eth_proto == BE_ETH_P_IP) {
  8c:	78 5f                	js     ed <balancer_ingress+0xed>
  8e:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  95:	73 00                	jae    97 <balancer_ingress+0x97>
    return process_packet(ctx, nh_off, false);
  97:	2e 2f                	cs (bad)
  99:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  9d:	61                   	(bad)
  9e:	6e                   	outsb  %ds:(%rsi),(%dx)
  9f:	2f                   	(bad)
  a0:	6c                   	insb   (%dx),%es:(%rdi)
  a1:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
  a8:	78 5f                	js     109 <balancer_ingress+0x109>
  aa:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  b1:	73 00                	jae    b3 <balancer_ingress+0xb3>
  b3:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  b7:	61                   	(bad)
  b8:	6e                   	outsb  %ds:(%rsi),(%dx)
  void* data = (void*)(long)xdp->data;
  b9:	2f                   	(bad)
  ba:	6c                   	insb   (%dx),%es:(%rdi)
  bb:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
  c2:	62 61 6c 61 6e       	(bad)
  c7:	63 65 72             	movsxd 0x72(%rbp),%esp
  void* data_end = (void*)(long)xdp->data_end;
  ca:	2e 62                	cs (bad)
  cc:	70 66                	jo     134 <balancer_ingress+0x134>
  ce:	2e 63 00             	cs movsxd (%rax),%eax
  d1:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
  d4:	74 72                	je     148 <balancer_ingress+0x148>
  d6:	6f                   	outsl  %ds:(%rsi),(%dx)
  d7:	6c                   	insb   (%dx),%es:(%rdi)
  d8:	5f                   	pop    %rdi
  d9:	64 61                	fs (bad)
  db:	74 61                	je     13e <balancer_ingress+0x13e>
  struct real_definition* dst = NULL;
  dd:	5f                   	pop    %rdi
  de:	6d                   	insl   (%dx),%es:(%rdi)
  df:	61                   	(bad)
  e0:	70 73                	jo     155 <balancer_ingress+0x155>
  e2:	2e 68 00 69 6e 74    	cs push $0x746e6900
  struct packet_description pckt = {};
  e8:	2d 6c 6c 36 34       	sub    $0x34366c6c,%eax
  ed:	2e 68 00 62 61 6c    	cs push $0x6c616200
  f3:	61                   	(bad)
  f4:	6e                   	outsb  %ds:(%rsi),(%dx)
  f5:	63 65 72             	movsxd 0x72(%rbp),%esp
  f8:	5f                   	pop    %rdi
  f9:	73 74                	jae    16f <balancer_ingress+0x16f>
  fb:	72 75                	jb     172 <balancer_ingress+0x172>
  fd:	63 74 73 2e          	movsxd 0x2e(%rbx,%rsi,2),%esi
 101:	68 00 62 61 6c       	push   $0x6c616200
 106:	61                   	(bad)
 107:	6e                   	outsb  %ds:(%rsi),(%dx)
 108:	63 65 72             	movsxd 0x72(%rbp),%esp
 10b:	5f                   	pop    %rdi
 10c:	6d                   	insl   (%dx),%es:(%rdi)
 10d:	61                   	(bad)
 10e:	70 73                	jo     183 <balancer_ingress+0x183>
 110:	2e 68 00 74 79 70    	cs push $0x70797400
 116:	65 73 2e             	gs jae 147 <balancer_ingress+0x147>
 119:	68 00 62 70 66       	push   $0x66706200
 11e:	5f                   	pop    %rdi
  struct vip_definition vip = {};
 11f:	68 65 6c 70 65       	push   $0x65706c65
 124:	72 73                	jb     199 <balancer_ingress+0x199>
 126:	2e 68 00 62 70 66    	cs push $0x66706200
 12c:	2e 68 00 69 6e 2e    	cs push $0x2e6e6900
 132:	68 00 70 63 6b       	push   $0x6b637000
 137:	74 5f                	je     198 <balancer_ingress+0x198>
 139:	70 61                	jo     19c <balancer_ingress+0x19c>
 13b:	72 73                	jb     1b0 <balancer_ingress+0x1b0>
 13d:	69 6e 67 2e 68 00 6a 	imul   $0x6a00682e,0x67(%rsi),%ebp
  __u32 mac_addr_pos = 0;
 144:	68 61 73 68 2e       	push   $0x2e687361
  __u64 th_off = 0;
 149:	68 00 68 61 6e       	push   $0x6e616800
 14e:	64 6c                	fs insb (%dx),%es:(%rdi)
 150:	65 5f                	gs pop %rdi
 152:	69 63 6d 70 2e 68 00 	imul   $0x682e70,0x6d(%rbx),%esp
      &pckt, &protocol, nh_off, &th_off, &pkt_bytes, data, data_end, is_ipv6);
 159:	63 73 75             	movsxd 0x75(%rbx),%esi
 15c:	6d                   	insl   (%dx),%es:(%rdi)
 15d:	5f                   	pop    %rdi
 15e:	68 65 6c 70 65       	push   $0x65706c65
 163:	72 73                	jb     1d8 <balancer_ingress+0x1d8>
 165:	2e 68 00 70 63 6b    	cs push $0x6b637000
 16b:	74 5f                	je     1cc <balancer_ingress+0x1cc>
 16d:	65 6e                	outsb  %gs:(%rsi),(%dx)
 16f:	63 61 70             	movsxd 0x70(%rcx),%esp
 172:	2e 68 00 65 6e 63    	cs push $0x636e6500
 178:	61                   	(bad)
 179:	70 5f                	jo     1da <balancer_ingress+0x1da>
 17b:	68 65 6c 70 65       	push   $0x65706c65
 180:	72 73                	jb     1f5 <balancer_ingress+0x1f5>
 182:	2e 68 00 69 70 2e    	cs push $0x2e706900
 188:	68 00 69 70 76       	push   $0x76706900
 18d:	36 2e 68 00 69 6e 36 	ss cs push $0x366e6900
 194:	2e 68 00 69 63 6d    	cs push $0x6d636900
 19a:	70 76                	jo     212 <balancer_ingress+0x212>
 19c:	36 2e 68 00 69 66 5f 	ss cs push $0x5f666900
 1a3:	65 74 68             	gs je  20e <balancer_ingress+0x20e>
 1a6:	65 72 2e             	gs jb  1d7 <balancer_ingress+0x1d7>
 1a9:	68 00 74 63 70       	push   $0x70637400
 1ae:	2e 68 00 75 64 70    	cs push $0x70647500
 1b4:	2e                   	cs
 1b5:	68                   	.byte 0x68
	...
