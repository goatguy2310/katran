
bpf/native/balancer.bpf:     file format elf64-x86-64


Disassembly of section xdp:

0000000000000000 <balancer_ingress>:
  return XDP_TX;
}

SEC(PROG_SEC_NAME)
int balancer_ingress(struct xdp_md* ctx) {
  void* data = (void*)(long)ctx->data;
       0:	f3 0f 1e fa          	endbr64
       4:	55                   	push   %rbp
       5:	41 57                	push   %r15
       7:	41 56                	push   %r14
       9:	41 55                	push   %r13
       b:	41 54                	push   %r12
       d:	53                   	push   %rbx
       e:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
      15:	48 8b 1f             	mov    (%rdi),%rbx
  void* data_end = (void*)(long)ctx->data_end;
      18:	4c 8b 7f 08          	mov    0x8(%rdi),%r15
  struct ethhdr* eth = data;
  __u32 eth_proto;
  __u32 nh_off;
  nh_off = sizeof(struct ethhdr);

  if (data + nh_off > data_end) {
      1c:	48 8d 43 0e          	lea    0xe(%rbx),%rax
      20:	bd 01 00 00 00       	mov    $0x1,%ebp
      25:	4c 39 f8             	cmp    %r15,%rax
      28:	0f 87 a3 1e 00 00    	ja     1ed1 <balancer_ingress+0x1ed1>
      2e:	49 89 fd             	mov    %rdi,%r13
    // bogus packet, len less than minimum ethernet frame size
    return XDP_DROP;
  }

  eth_proto = eth->h_proto;
      31:	0f b7 4b 0c          	movzwl 0xc(%rbx),%ecx

  if (eth_proto == BE_ETH_P_IP) {
      35:	81 f9 86 dd 00 00    	cmp    $0xdd86,%ecx
      3b:	0f 84 1e 01 00 00    	je     15f <balancer_ingress+0x15f>
      41:	bd 02 00 00 00       	mov    $0x2,%ebp
      46:	66 83 f9 08          	cmp    $0x8,%cx
      4a:	0f 85 81 1e 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
  struct packet_description pckt = {};
      50:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
      57:	00 00 
      59:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
      60:	00 00 
      62:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
      69:	00 00 
      6b:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
      72:	00 00 
      74:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
      7b:	00 00 
      7d:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
      84:	00 00 
  struct vip_definition vip = {};
      86:	c7 44 24 68 00 00 00 	movl   $0x0,0x68(%rsp)
      8d:	00 
      8e:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
      95:	00 00 
      97:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
      9e:	00 00 
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
    }
  } else {
    iph = data + nh_off;
    if (iph + 1 > data_end) {
      a0:	4c 8d 73 22          	lea    0x22(%rbx),%r14
      a4:	4d 39 fe             	cmp    %r15,%r14
      a7:	0f 87 1f 1e 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
      return XDP_DROP;
    }
    // ihl contains len of ipv4 header in 32bit words
    if (iph->ihl != 5) {
      ad:	8a 00                	mov    (%rax),%al
      af:	24 0f                	and    $0xf,%al
      b1:	3c 05                	cmp    $0x5,%al
      b3:	0f 85 13 1e 00 00    	jne    1ecc <balancer_ingress+0x1ecc>
      // if len of ipv4 hdr is not equal to 20bytes that means that header
      // contains ip options, and we dont support em
      return XDP_DROP;
    }
    pckt->tos = iph->tos;
      b9:	8a 43 0f             	mov    0xf(%rbx),%al
      bc:	88 44 24 3d          	mov    %al,0x3d(%rsp)
    *protocol = iph->protocol;
      c0:	8a 43 17             	mov    0x17(%rbx),%al
    pckt->flow.proto = *protocol;
      c3:	88 44 24 34          	mov    %al,0x34(%rsp)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;

    if (iph->frag_off & PCKT_FRAGMENTED) {
      c7:	0f b7 4b 14          	movzwl 0x14(%rbx),%ecx
      cb:	f7 c1 3f ff 00 00    	test   $0xff3f,%ecx
      d1:	0f 85 f5 1d 00 00    	jne    1ecc <balancer_ingress+0x1ecc>
      d7:	0f b7 7b 10          	movzwl 0x10(%rbx),%edi
      // we drop fragmented packets.
      return XDP_DROP;
    }
    if (*protocol == IPPROTO_ICMP) {
      db:	3c 01                	cmp    $0x1,%al
      dd:	0f 85 43 03 00 00    	jne    426 <balancer_ingress+0x426>
    __u64 off,
    struct packet_description* pckt) {
  struct icmphdr* icmp_hdr;
  struct iphdr* iph;
  icmp_hdr = data + off;
  if (icmp_hdr + 1 > data_end) {
      e3:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
      e7:	4c 39 f8             	cmp    %r15,%rax
      ea:	0f 87 dc 1d 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    return XDP_DROP;
  }
  if (icmp_hdr->type == ICMP_ECHO) {
      f0:	41 8a 16             	mov    (%r14),%dl
      f3:	80 fa 03             	cmp    $0x3,%dl
      f6:	0f 84 59 08 00 00    	je     955 <balancer_ingress+0x955>
      fc:	bd 02 00 00 00       	mov    $0x2,%ebp
     101:	80 fa 08             	cmp    $0x8,%dl
     104:	0f 85 c7 1d 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
     10a:	44 0f b7 c7          	movzwl %di,%r8d
  icmp_hdr->type = ICMP_ECHOREPLY;
     10e:	c6 43 22 00          	movb   $0x0,0x22(%rbx)
  icmp_hdr->checksum += 0x0008;
     112:	66 83 43 24 08       	addw   $0x8,0x24(%rbx)
  iph->ttl = DEFAULT_TTL;
     117:	c6 43 16 40          	movb   $0x40,0x16(%rbx)
  iph->daddr = iph->saddr;
     11b:	8b 43 1a             	mov    0x1a(%rbx),%eax
  tmp_addr = iph->daddr;
     11e:	8b 73 1e             	mov    0x1e(%rbx),%esi
  iph->daddr = iph->saddr;
     121:	89 43 1e             	mov    %eax,0x1e(%rbx)
  iph->saddr = tmp_addr;
     124:	89 73 1a             	mov    %esi,0x1a(%rbx)
    void* iph,
    __u64* csum) {
  __u16* next_iph_u16 = (__u16*)iph;
#pragma clang loop unroll(full)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    *csum += *next_iph_u16++;
     127:	0f b7 7b 0e          	movzwl 0xe(%rbx),%edi
     12b:	0f b7 6b 12          	movzwl 0x12(%rbx),%ebp
     12f:	44 0f b7 4b 16       	movzwl 0x16(%rbx),%r9d
     134:	0f b7 d6             	movzwl %si,%edx
     137:	48 c1 ee 10          	shr    $0x10,%rsi
     13b:	48 01 d6             	add    %rdx,%rsi
     13e:	0f b7 d0             	movzwl %ax,%edx
     141:	48 01 f2             	add    %rsi,%rdx
     144:	48 c1 e8 10          	shr    $0x10,%rax
     148:	48 01 d0             	add    %rdx,%rax
     14b:	48 01 f8             	add    %rdi,%rax
     14e:	4c 01 c0             	add    %r8,%rax
     151:	48 01 e8             	add    %rbp,%rax
     154:	48 01 c8             	add    %rcx,%rax
     157:	4c 01 c8             	add    %r9,%rax
     15a:	e9 e3 01 00 00       	jmp    342 <balancer_ingress+0x342>
  struct packet_description pckt = {};
     15f:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
     166:	00 00 
     168:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
     16f:	00 00 
     171:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
     178:	00 00 
     17a:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
     181:	00 00 
     183:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
     18a:	00 00 
     18c:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
     193:	00 00 
  struct vip_definition vip = {};
     195:	c7 44 24 68 00 00 00 	movl   $0x0,0x68(%rsp)
     19c:	00 
     19d:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
     1a4:	00 00 
     1a6:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
     1ad:	00 00 
    if (ip6h + 1 > data_end) {
     1af:	4c 8d 73 36          	lea    0x36(%rbx),%r14
     1b3:	4d 39 fe             	cmp    %r15,%r14
     1b6:	0f 87 10 1d 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    *protocol = ip6h->nexthdr;
     1bc:	8a 43 14             	mov    0x14(%rbx),%al
    pckt->flow.proto = *protocol;
     1bf:	88 44 24 34          	mov    %al,0x34(%rsp)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1c3:	8a 4b 0e             	mov    0xe(%rbx),%cl
     1c6:	c0 e1 04             	shl    $0x4,%cl
     1c9:	88 4c 24 3d          	mov    %cl,0x3d(%rsp)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1cd:	8a 53 0f             	mov    0xf(%rbx),%dl
     1d0:	c0 ea 04             	shr    $0x4,%dl
     1d3:	08 ca                	or     %cl,%dl
     1d5:	88 54 24 3d          	mov    %dl,0x3d(%rsp)
    if (*protocol == IPPROTO_FRAGMENT) {
     1d9:	3c 2c                	cmp    $0x2c,%al
     1db:	0f 84 eb 1c 00 00    	je     1ecc <balancer_ingress+0x1ecc>
     1e1:	0f b7 7b 12          	movzwl 0x12(%rbx),%edi
     1e5:	3c 3a                	cmp    $0x3a,%al
     1e7:	0f 85 9b 00 00 00    	jne    288 <balancer_ingress+0x288>
  if (icmp_hdr + 1 > data_end) {
     1ed:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     1f1:	4c 39 f8             	cmp    %r15,%rax
     1f4:	0f 87 d2 1c 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1fa:	41 8a 06             	mov    (%r14),%al
     1fd:	3c 02                	cmp    $0x2,%al
     1ff:	0f 84 c2 02 00 00    	je     4c7 <balancer_ingress+0x4c7>
     205:	3c 01                	cmp    $0x1,%al
     207:	0f 84 f3 02 00 00    	je     500 <balancer_ingress+0x500>
     20d:	bd 02 00 00 00       	mov    $0x2,%ebp
     212:	3c 80                	cmp    $0x80,%al
     214:	0f 85 b7 1c 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
     21a:	c6 43 36 81          	movb   $0x81,0x36(%rbx)
     21e:	66 83 43 38 ff       	addw   $0xffff,0x38(%rbx)
     223:	c6 43 15 40          	movb   $0x40,0x15(%rbx)
     227:	48 8b 43 16          	mov    0x16(%rbx),%rax
     22b:	48 8b 4b 1e          	mov    0x1e(%rbx),%rcx
     22f:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     234:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
     239:	48 8b 43 26          	mov    0x26(%rbx),%rax
     23d:	48 8b 4b 2e          	mov    0x2e(%rbx),%rcx
     241:	48 89 43 16          	mov    %rax,0x16(%rbx)
     245:	48 89 4b 1e          	mov    %rcx,0x1e(%rbx)
     249:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
     24e:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
     253:	48 89 43 26          	mov    %rax,0x26(%rbx)
     257:	48 89 4b 2e          	mov    %rcx,0x2e(%rbx)
     25b:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     25f:	66 89 44 24 7c       	mov    %ax,0x7c(%rsp)
     264:	8b 43 06             	mov    0x6(%rbx),%eax
     267:	89 44 24 78          	mov    %eax,0x78(%rsp)
     26b:	8b 03                	mov    (%rbx),%eax
     26d:	89 43 06             	mov    %eax,0x6(%rbx)
     270:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     274:	66 89 43 0a          	mov    %ax,0xa(%rbx)
     278:	8b 44 24 78          	mov    0x78(%rsp),%eax
     27c:	89 03                	mov    %eax,(%rbx)
     27e:	0f b7 44 24 7c       	movzwl 0x7c(%rsp),%eax
     283:	e9 45 01 00 00       	jmp    3cd <balancer_ingress+0x3cd>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     288:	48 8b 4b 16          	mov    0x16(%rbx),%rcx
     28c:	48 8b 53 1e          	mov    0x1e(%rbx),%rdx
     290:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
     295:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     29a:	48 8b 4b 26          	mov    0x26(%rbx),%rcx
     29e:	48 8b 53 2e          	mov    0x2e(%rbx),%rdx
     2a2:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
     2a7:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
    void* data,
    void* data_end,
    __u64 off,
    struct packet_description* pckt,
    __u8 protocol) {
  if (protocol == IPPROTO_ICMPV6) {
     2ac:	3c 01                	cmp    $0x1,%al
     2ae:	0f 85 27 01 00 00    	jne    3db <balancer_ingress+0x3db>
  if (icmp_hdr + 1 > data_end) {
     2b4:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     2b8:	4c 39 f8             	cmp    %r15,%rax
     2bb:	0f 87 0b 1c 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
  if (icmp_hdr->type == ICMP_ECHO) {
     2c1:	41 8a 0e             	mov    (%r14),%cl
     2c4:	80 f9 03             	cmp    $0x3,%cl
     2c7:	0f 84 1f 05 00 00    	je     7ec <balancer_ingress+0x7ec>
     2cd:	bd 02 00 00 00       	mov    $0x2,%ebp
     2d2:	80 f9 08             	cmp    $0x8,%cl
     2d5:	0f 85 f6 1b 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2db:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
     2df:	bd 01 00 00 00       	mov    $0x1,%ebp
       sizeof(struct icmphdr)) > data_end) {
     2e4:	4c 39 f8             	cmp    %r15,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     2e7:	0f 87 e4 1b 00 00    	ja     1ed1 <balancer_ingress+0x1ed1>
  icmp_hdr->type = ICMP_ECHOREPLY;
     2ed:	c6 43 22 00          	movb   $0x0,0x22(%rbx)
  icmp_hdr->checksum += 0x0008;
     2f1:	66 83 43 24 08       	addw   $0x8,0x24(%rbx)
  iph->ttl = DEFAULT_TTL;
     2f6:	c6 43 16 40          	movb   $0x40,0x16(%rbx)
  iph->daddr = iph->saddr;
     2fa:	8b 43 1a             	mov    0x1a(%rbx),%eax
  tmp_addr = iph->daddr;
     2fd:	8b 4b 1e             	mov    0x1e(%rbx),%ecx
  iph->daddr = iph->saddr;
     300:	89 43 1e             	mov    %eax,0x1e(%rbx)
  iph->saddr = tmp_addr;
     303:	89 4b 1a             	mov    %ecx,0x1a(%rbx)
     306:	44 0f b7 4b 0e       	movzwl 0xe(%rbx),%r9d
     30b:	0f b7 73 10          	movzwl 0x10(%rbx),%esi
     30f:	0f b7 7b 12          	movzwl 0x12(%rbx),%edi
     313:	0f b7 6b 14          	movzwl 0x14(%rbx),%ebp
     317:	44 0f b7 43 16       	movzwl 0x16(%rbx),%r8d
     31c:	0f b7 d1             	movzwl %cx,%edx
     31f:	48 c1 e9 10          	shr    $0x10,%rcx
     323:	48 01 d1             	add    %rdx,%rcx
     326:	0f b7 d0             	movzwl %ax,%edx
     329:	48 01 ca             	add    %rcx,%rdx
     32c:	48 c1 e8 10          	shr    $0x10,%rax
     330:	48 01 d0             	add    %rdx,%rax
     333:	4c 01 c8             	add    %r9,%rax
     336:	48 01 f0             	add    %rsi,%rax
     339:	48 01 f8             	add    %rdi,%rax
     33c:	48 01 e8             	add    %rbp,%rax
     33f:	4c 01 c0             	add    %r8,%rax
     342:	48 89 c1             	mov    %rax,%rcx
     345:	48 c1 e9 10          	shr    $0x10,%rcx
     349:	0f b7 d0             	movzwl %ax,%edx
     34c:	48 01 ca             	add    %rcx,%rdx
     34f:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
     355:	48 0f 42 d0          	cmovb  %rax,%rdx
     359:	48 89 d0             	mov    %rdx,%rax
     35c:	48 c1 e8 10          	shr    $0x10,%rax
     360:	0f b7 ca             	movzwl %dx,%ecx
     363:	48 01 c1             	add    %rax,%rcx
     366:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     36d:	48 0f 42 ca          	cmovb  %rdx,%rcx
     371:	48 89 c8             	mov    %rcx,%rax
     374:	48 c1 e8 10          	shr    $0x10,%rax
     378:	0f b7 d1             	movzwl %cx,%edx
     37b:	48 01 c2             	add    %rax,%rdx
     37e:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
     385:	48 0f 42 d1          	cmovb  %rcx,%rdx
     389:	89 d0                	mov    %edx,%eax
     38b:	c1 e8 10             	shr    $0x10,%eax
     38e:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     395:	b9 00 00 01 00       	mov    $0x10000,%ecx
     39a:	0f 43 c8             	cmovae %eax,%ecx
     39d:	01 d1                	add    %edx,%ecx
     39f:	f7 d1                	not    %ecx
     3a1:	66 89 4b 18          	mov    %cx,0x18(%rbx)
     3a5:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     3a9:	66 89 44 24 44       	mov    %ax,0x44(%rsp)
     3ae:	8b 43 06             	mov    0x6(%rbx),%eax
     3b1:	89 44 24 40          	mov    %eax,0x40(%rsp)
     3b5:	8b 03                	mov    (%rbx),%eax
     3b7:	89 43 06             	mov    %eax,0x6(%rbx)
     3ba:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     3be:	66 89 43 0a          	mov    %ax,0xa(%rbx)
     3c2:	8b 44 24 40          	mov    0x40(%rsp),%eax
     3c6:	89 03                	mov    %eax,(%rbx)
     3c8:	0f b7 44 24 44       	movzwl 0x44(%rsp),%eax
     3cd:	66 89 43 04          	mov    %ax,0x4(%rbx)
     3d1:	bd 03 00 00 00       	mov    $0x3,%ebp
     3d6:	e9 f6 1a 00 00       	jmp    1ed1 <balancer_ingress+0x1ed1>
     3db:	b2 02                	mov    $0x2,%dl
     3dd:	b1 01                	mov    $0x1,%cl
     3df:	bd 02 00 00 00       	mov    $0x2,%ebp
  if (protocol == IPPROTO_IPIP) {
     3e4:	3c 10                	cmp    $0x10,%al
     3e6:	0f 8f 62 01 00 00    	jg     54e <balancer_ingress+0x54e>
     3ec:	3c 04                	cmp    $0x4,%al
     3ee:	0f 84 8f 02 00 00    	je     683 <balancer_ingress+0x683>
     3f4:	3c 06                	cmp    $0x6,%al
     3f6:	0f 85 d5 1a 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
  tcp = data + off;
     3fc:	48 8d 43 66          	lea    0x66(%rbx),%rax
  if (is_ipv6) {
     400:	84 c9                	test   %cl,%cl
  tcp = data + off;
     402:	49 0f 45 c6          	cmovne %r14,%rax
  if (tcp + 1 > data_end) {
     406:	48 8d 70 14          	lea    0x14(%rax),%rsi
     40a:	4c 39 fe             	cmp    %r15,%rsi
     40d:	0f 87 b9 1a 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
  if (tcp->syn) {
     413:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     417:	0f 84 b0 03 00 00    	je     7cd <balancer_ingress+0x7cd>
    pckt->flags |= F_SYN_SET;
     41d:	88 54 24 3c          	mov    %dl,0x3c(%rsp)
     421:	e9 a7 03 00 00       	jmp    7cd <balancer_ingress+0x7cd>
      return FURTHER_PROCESSING;
    } else {
      pckt->flow.src = iph->saddr;
     426:	8b 4b 1a             	mov    0x1a(%rbx),%ecx
     429:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
      pckt->flow.dst = iph->daddr;
     42d:	8b 4b 1e             	mov    0x1e(%rbx),%ecx
     430:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
  if (protocol == IPPROTO_ICMPV6) {
     434:	3c 3a                	cmp    $0x3a,%al
     436:	75 44                	jne    47c <balancer_ingress+0x47c>
  if (icmp_hdr + 1 > data_end) {
     438:	48 8d 43 2a          	lea    0x2a(%rbx),%rax
     43c:	4c 39 f8             	cmp    %r15,%rax
     43f:	0f 87 87 1a 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     445:	41 8a 06             	mov    (%r14),%al
     448:	3c 02                	cmp    $0x2,%al
     44a:	0f 84 0c 07 00 00    	je     b5c <balancer_ingress+0xb5c>
     450:	3c 01                	cmp    $0x1,%al
     452:	0f 84 3d 07 00 00    	je     b95 <balancer_ingress+0xb95>
     458:	bd 02 00 00 00       	mov    $0x2,%ebp
     45d:	3c 80                	cmp    $0x80,%al
     45f:	0f 85 6c 1a 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     465:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
     469:	bd 01 00 00 00       	mov    $0x1,%ebp
       sizeof(struct icmp6hdr)) > data_end) {
     46e:	4c 39 f8             	cmp    %r15,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     471:	0f 87 5a 1a 00 00    	ja     1ed1 <balancer_ingress+0x1ed1>
     477:	e9 9e fd ff ff       	jmp    21a <balancer_ingress+0x21a>
     47c:	b2 02                	mov    $0x2,%dl
     47e:	b1 01                	mov    $0x1,%cl
     480:	bd 02 00 00 00       	mov    $0x2,%ebp
     485:	3c 10                	cmp    $0x10,%al
     487:	0f 8f 58 07 00 00    	jg     be5 <balancer_ingress+0xbe5>
     48d:	3c 04                	cmp    $0x4,%al
     48f:	0f 84 6a 05 00 00    	je     9ff <balancer_ingress+0x9ff>
     495:	3c 06                	cmp    $0x6,%al
     497:	0f 85 34 1a 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
  tcp = data + off;
     49d:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
  if (is_ipv6) {
     4a1:	84 c9                	test   %cl,%cl
  tcp = data + off;
     4a3:	49 0f 45 c6          	cmovne %r14,%rax
  if (tcp + 1 > data_end) {
     4a7:	48 8d 70 14          	lea    0x14(%rax),%rsi
     4ab:	4c 39 fe             	cmp    %r15,%rsi
     4ae:	0f 87 18 1a 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
  if (tcp->syn) {
     4b4:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     4b8:	0f 84 85 08 00 00    	je     d43 <balancer_ingress+0xd43>
    pckt->flags |= F_SYN_SET;
     4be:	88 54 24 3c          	mov    %dl,0x3c(%rsp)
     4c2:	e9 7c 08 00 00       	jmp    d43 <balancer_ingress+0xd43>
     4c7:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     4ce:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     4d1:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     4d8:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     4df:	79 92 
    if (!icmp_ptb_v6_stats) {
     4e1:	48 85 c0             	test   %rax,%rax
     4e4:	0f 84 e2 19 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    icmp_ptb_v6_stats->v1 += 1;
     4ea:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4ee:	8b 4b 3a             	mov    0x3a(%rbx),%ecx
     4f1:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     4f3:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     4f9:	77 05                	ja     500 <balancer_ingress+0x500>
      icmp_ptb_v6_stats->v2 += 1;
     4fb:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     500:	48 8d 43 66          	lea    0x66(%rbx),%rax
     504:	4c 39 f8             	cmp    %r15,%rax
     507:	0f 87 bf 19 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
  pckt->flow.proto = ip6h->nexthdr;
     50d:	8a 43 44             	mov    0x44(%rbx),%al
     510:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     514:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     519:	48 8b 4b 56          	mov    0x56(%rbx),%rcx
     51d:	48 8b 53 5e          	mov    0x5e(%rbx),%rdx
     521:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
     526:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     52b:	48 8b 4b 46          	mov    0x46(%rbx),%rcx
     52f:	48 8b 53 4e          	mov    0x4e(%rbx),%rdx
     533:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
     538:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
     53d:	b2 03                	mov    $0x3,%dl
     53f:	31 c9                	xor    %ecx,%ecx
     541:	bd 02 00 00 00       	mov    $0x2,%ebp
     546:	3c 10                	cmp    $0x10,%al
     548:	0f 8e 9e fe ff ff    	jle    3ec <balancer_ingress+0x3ec>
     54e:	3c 11                	cmp    $0x11,%al
     550:	0f 84 60 02 00 00    	je     7b6 <balancer_ingress+0x7b6>
     556:	3c 29                	cmp    $0x29,%al
     558:	0f 85 73 19 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     55e:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     563:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     568:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     56d:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
  __u32* decap_dst_flags = bpf_map_lookup_elem(&decap_dst, &dst_addr);
     572:	48 bf 00 58 f3 48 81 	movabs $0xffff888148f35800,%rdi
     579:	88 ff ff 
     57c:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     581:	48 c7 c0 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rax
     588:	ff d0                	call   *%rax
     58a:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     58d:	48 85 c0             	test   %rax,%rax
     590:	74 27                	je     5b9 <balancer_ingress+0x5b9>
     592:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     599:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     59c:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     5a3:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     5aa:	79 92 
    if (!data_stats) {
     5ac:	48 85 c0             	test   %rax,%rax
     5af:	0f 84 17 19 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    data_stats->v1 += 1;
     5b5:	48 83 00 01          	addq   $0x1,(%rax)
decrement_ttl(void* data, void* data_end, int offset, bool is_ipv6) {
  struct iphdr* iph;
  struct ipv6hdr* ip6h;

  if (is_ipv6) {
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5b9:	48 8d 43 5e          	lea    0x5e(%rbx),%rax
     5bd:	bd 01 00 00 00       	mov    $0x1,%ebp
     5c2:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     5c8:	4c 39 f8             	cmp    %r15,%rax
     5cb:	77 13                	ja     5e0 <balancer_ingress+0x5e0>
      return XDP_DROP;
    }
    ip6h = (struct ipv6hdr*)(data + offset);
    if (!--ip6h->hop_limit) {
     5cd:	80 43 3d ff          	addb   $0xff,0x3d(%rbx)
     5d1:	b8 01 00 00 00       	mov    $0x1,%eax
     5d6:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
     5dc:	44 0f 44 e0          	cmove  %eax,%r12d
decap_v6(struct xdp_md* xdp, void** data, void** data_end, bool inner_v4) {
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  old_eth = *data;
  new_eth = *data + sizeof(struct ipv6hdr);
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5e0:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     5e4:	66 89 43 32          	mov    %ax,0x32(%rbx)
     5e8:	8b 43 06             	mov    0x6(%rbx),%eax
     5eb:	89 43 2e             	mov    %eax,0x2e(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     5ee:	8b 03                	mov    (%rbx),%eax
     5f0:	89 43 28             	mov    %eax,0x28(%rbx)
     5f3:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     5f7:	66 89 43 2c          	mov    %ax,0x2c(%rbx)
     5fb:	66 c7 43 34 86 dd    	movw   $0xdd86,0x34(%rbx)
     601:	48 c7 c0 20 5c c3 8e 	mov    $0xffffffff8ec35c20,%rax
  if (inner_v4) {
    new_eth->h_proto = BE_ETH_P_IP;
  } else {
    new_eth->h_proto = BE_ETH_P_IPV6;
  }
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     608:	4c 89 ef             	mov    %r13,%rdi
     60b:	be 28 00 00 00       	mov    $0x28,%esi
     610:	ff d0                	call   *%rax
     612:	85 c0                	test   %eax,%eax
     614:	0f 85 b7 18 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
     61a:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     621:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     624:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     62b:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
     632:	79 92 
  if (!data_stats) {
     634:	48 85 c9             	test   %rcx,%rcx
     637:	0f 84 94 18 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     63d:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     642:	45 85 e4             	test   %r12d,%r12d
     645:	bd 02 00 00 00       	mov    $0x2,%ebp
     64a:	41 0f 49 ec          	cmovns %r12d,%ebp
  if (decap_dst_flags) {
     64e:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     651:	0f 84 7a 18 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     657:	45 85 e4             	test   %r12d,%r12d
     65a:	0f 89 71 18 00 00    	jns    1ed1 <balancer_ingress+0x1ed1>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     660:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     667:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     66e:	79 92 
    if (xpop_stats_data) {
     670:	48 85 c0             	test   %rax,%rax
     673:	0f 84 bc 04 00 00    	je     b35 <balancer_ingress+0xb35>
     679:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
     67e:	e9 b2 04 00 00       	jmp    b35 <balancer_ingress+0xb35>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     683:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     688:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     68d:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     692:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
  __u32* decap_dst_flags = bpf_map_lookup_elem(&decap_dst, &dst_addr);
     697:	48 bf 00 58 f3 48 81 	movabs $0xffff888148f35800,%rdi
     69e:	88 ff ff 
     6a1:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     6a6:	48 c7 c0 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rax
     6ad:	ff d0                	call   *%rax
     6af:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     6b2:	48 85 c0             	test   %rax,%rax
     6b5:	74 27                	je     6de <balancer_ingress+0x6de>
     6b7:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     6be:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     6c1:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     6c8:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     6cf:	79 92 
    if (!data_stats) {
     6d1:	48 85 c0             	test   %rax,%rax
     6d4:	0f 84 f2 17 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    data_stats->v1 += 1;
     6da:	48 83 00 01          	addq   $0x1,(%rax)
      // ttl 0
      return XDP_DROP;
    }
  } else {
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     6de:	48 8d 43 4a          	lea    0x4a(%rbx),%rax
     6e2:	bd 01 00 00 00       	mov    $0x1,%ebp
     6e7:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     6ed:	4c 39 f8             	cmp    %r15,%rax
     6f0:	77 26                	ja     718 <balancer_ingress+0x718>
      return XDP_DROP;
    }
    iph = (struct iphdr*)(data + offset);
    __u32 csum;
    csum = iph->check + 0x0001;
     6f2:	0f b7 43 40          	movzwl 0x40(%rbx),%eax
     6f6:	8d 48 01             	lea    0x1(%rax),%ecx
    iph->check = (csum & 0xffff) + (csum >> 16);
     6f9:	c1 e9 10             	shr    $0x10,%ecx
     6fc:	01 c8                	add    %ecx,%eax
     6fe:	83 c0 01             	add    $0x1,%eax
     701:	66 89 43 40          	mov    %ax,0x40(%rbx)
    if (!--iph->ttl) {
     705:	80 43 3e ff          	addb   $0xff,0x3e(%rbx)
     709:	b8 01 00 00 00       	mov    $0x1,%eax
     70e:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
     714:	44 0f 44 e0          	cmove  %eax,%r12d
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     718:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     71c:	66 89 43 32          	mov    %ax,0x32(%rbx)
     720:	8b 43 06             	mov    0x6(%rbx),%eax
     723:	89 43 2e             	mov    %eax,0x2e(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     726:	8b 03                	mov    (%rbx),%eax
     728:	89 43 28             	mov    %eax,0x28(%rbx)
     72b:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     72f:	66 89 43 2c          	mov    %ax,0x2c(%rbx)
     733:	66 c7 43 34 08 00    	movw   $0x8,0x34(%rbx)
     739:	48 c7 c0 20 5c c3 8e 	mov    $0xffffffff8ec35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     740:	4c 89 ef             	mov    %r13,%rdi
     743:	be 28 00 00 00       	mov    $0x28,%esi
     748:	ff d0                	call   *%rax
     74a:	85 c0                	test   %eax,%eax
     74c:	0f 85 7f 17 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
     752:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     759:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     75c:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     763:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
     76a:	79 92 
  if (!data_stats) {
     76c:	48 85 c9             	test   %rcx,%rcx
     76f:	0f 84 5c 17 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     775:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     77a:	45 85 e4             	test   %r12d,%r12d
     77d:	bd 02 00 00 00       	mov    $0x2,%ebp
     782:	41 0f 49 ec          	cmovns %r12d,%ebp
  if (decap_dst_flags) {
     786:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     789:	0f 84 42 17 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     78f:	45 85 e4             	test   %r12d,%r12d
     792:	0f 89 39 17 00 00    	jns    1ed1 <balancer_ingress+0x1ed1>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     798:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     79f:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     7a6:	79 92 
    if (xpop_stats_data) {
     7a8:	48 85 c0             	test   %rax,%rax
     7ab:	0f 85 80 03 00 00    	jne    b31 <balancer_ingress+0xb31>
     7b1:	e9 7f 03 00 00       	jmp    b35 <balancer_ingress+0xb35>
  udp = data + off;
     7b6:	48 8d 43 66          	lea    0x66(%rbx),%rax
  if (is_ipv6) {
     7ba:	84 c9                	test   %cl,%cl
  udp = data + off;
     7bc:	49 0f 45 c6          	cmovne %r14,%rax
  if (udp + 1 > data_end) {
     7c0:	48 8d 50 08          	lea    0x8(%rax),%rdx
     7c4:	4c 39 fa             	cmp    %r15,%rdx
     7c7:	0f 87 ff 16 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
     7cd:	84 c9                	test   %cl,%cl
     7cf:	89 7c 24 54          	mov    %edi,0x54(%rsp)
     7d3:	0f 84 83 00 00 00    	je     85c <balancer_ingress+0x85c>
     7d9:	0f b7 10             	movzwl (%rax),%edx
     7dc:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     7e1:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     7e6:	48 83 c0 02          	add    $0x2,%rax
     7ea:	eb 7e                	jmp    86a <balancer_ingress+0x86a>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     7ec:	80 7b 37 04          	cmpb   $0x4,0x37(%rbx)
     7f0:	75 32                	jne    824 <balancer_ingress+0x824>
     7f2:	48 b9 00 00 98 03 83 	movabs $0xffff888303980000,%rcx
     7f9:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     7fc:	48 8b 89 68 11 00 00 	mov    0x1168(%rcx),%rcx
     803:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
     80a:	79 92 
    if (!icmp_ptb_v4_stats) {
     80c:	48 85 c9             	test   %rcx,%rcx
     80f:	0f 84 b7 16 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    icmp_ptb_v4_stats->v1 += 1;
     815:	48 83 01 01          	addq   $0x1,(%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     819:	80 7b 3c 04          	cmpb   $0x4,0x3c(%rbx)
     81d:	77 05                	ja     824 <balancer_ingress+0x824>
      icmp_ptb_v4_stats->v2 += 1;
     81f:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (iph + 1 > data_end) {
     824:	48 8d 4b 52          	lea    0x52(%rbx),%rcx
     828:	4c 39 f9             	cmp    %r15,%rcx
     82b:	0f 87 9b 16 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
  if (iph->ihl != 5) {
     831:	8a 00                	mov    (%rax),%al
     833:	24 0f                	and    $0xf,%al
     835:	3c 05                	cmp    $0x5,%al
     837:	0f 85 8f 16 00 00    	jne    1ecc <balancer_ingress+0x1ecc>
  pckt->flow.proto = iph->protocol;
     83d:	8a 43 47             	mov    0x47(%rbx),%al
     840:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     844:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  pckt->flow.src = iph->daddr;
     849:	8b 4b 4e             	mov    0x4e(%rbx),%ecx
     84c:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
  pckt->flow.dst = iph->saddr;
     850:	8b 4b 4a             	mov    0x4a(%rbx),%ecx
     853:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
     857:	e9 e1 fc ff ff       	jmp    53d <balancer_ingress+0x53d>
     85c:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     860:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     865:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     86a:	0f b7 00             	movzwl (%rax),%eax
     86d:	66 89 41 02          	mov    %ax,0x2(%rcx)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     871:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     876:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     87b:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
     880:	48 89 44 24 58       	mov    %rax,0x58(%rsp)
  vip.port = pckt.flow.port16[1];
     885:	0f b7 44 24 32       	movzwl 0x32(%rsp),%eax
     88a:	66 89 44 24 68       	mov    %ax,0x68(%rsp)
  vip.proto = pckt.flow.proto;
     88f:	8a 44 24 34          	mov    0x34(%rsp),%al
     893:	88 44 24 6a          	mov    %al,0x6a(%rsp)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     897:	48 bf 00 48 f3 48 81 	movabs $0xffff888148f34800,%rdi
     89e:	88 ff ff 
     8a1:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
     8a6:	49 c7 c4 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%r12
     8ad:	41 ff d4             	call   *%r12
     8b0:	48 89 c7             	mov    %rax,%rdi
  if (!vip_info) {
     8b3:	48 85 c0             	test   %rax,%rax
     8b6:	0f 84 09 01 00 00    	je     9c5 <balancer_ingress+0x9c5>
  if (data_end - data > MAX_PCKT_SIZE) {
     8bc:	4c 89 f8             	mov    %r15,%rax
     8bf:	48 29 d8             	sub    %rbx,%rax
     8c2:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     8c8:	0f 8f fe 15 00 00    	jg     1ecc <balancer_ingress+0x1ecc>
     8ce:	49 bc 00 00 98 03 83 	movabs $0xffff888303980000,%r12
     8d5:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     8d8:	49 8b b4 24 00 11 00 	mov    0x1100(%r12),%rsi
     8df:	00 
     8e0:	65 48 03 34 25 28 50 	add    %gs:0xffffffff92795028,%rsi
     8e7:	79 92 
  if (!data_stats) {
     8e9:	48 85 f6             	test   %rsi,%rsi
     8ec:	0f 84 da 15 00 00    	je     1ecc <balancer_ingress+0x1ecc>
  data_stats->v1 += 1;
     8f2:	48 83 06 01          	addq   $0x1,(%rsi)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     8f6:	f6 07 01             	testb  $0x1,(%rdi)
     8f9:	74 07                	je     902 <balancer_ingress+0x902>
    pckt.flow.port16[0] = 0;
     8fb:	66 c7 44 24 30 00 00 	movw   $0x0,0x30(%rsp)
  vip_num = vip_info->vip_num;
     902:	8b 57 04             	mov    0x4(%rdi),%edx
     905:	48 c7 c0 34 50 79 92 	mov    $0xffffffff92795034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     90c:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     913:	79 92 
     915:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     918:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     91d:	0f 84 32 05 00 00    	je     e55 <balancer_ingress+0xe55>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     923:	49 8b 84 24 18 11 00 	mov    0x1118(%r12),%rax
     92a:	00 
     92b:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     932:	79 92 
    if (!lru_stats) {
     934:	48 85 c0             	test   %rax,%rax
     937:	0f 84 8f 15 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    lru_stats->v1 += 1;
     93d:	48 83 00 01          	addq   $0x1,(%rax)
     941:	48 b8 00 40 f3 48 81 	movabs $0xffff888148f34000,%rax
     948:	88 ff ff 
     94b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
     950:	e9 22 05 00 00       	jmp    e77 <balancer_ingress+0xe77>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     955:	80 7b 23 04          	cmpb   $0x4,0x23(%rbx)
     959:	75 32                	jne    98d <balancer_ingress+0x98d>
     95b:	48 b9 00 00 98 03 83 	movabs $0xffff888303980000,%rcx
     962:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     965:	48 8b 89 68 11 00 00 	mov    0x1168(%rcx),%rcx
     96c:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
     973:	79 92 
    if (!icmp_ptb_v4_stats) {
     975:	48 85 c9             	test   %rcx,%rcx
     978:	0f 84 4e 15 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    icmp_ptb_v4_stats->v1 += 1;
     97e:	48 83 01 01          	addq   $0x1,(%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     982:	80 7b 28 04          	cmpb   $0x4,0x28(%rbx)
     986:	77 05                	ja     98d <balancer_ingress+0x98d>
      icmp_ptb_v4_stats->v2 += 1;
     988:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (iph + 1 > data_end) {
     98d:	48 8d 4b 3e          	lea    0x3e(%rbx),%rcx
     991:	4c 39 f9             	cmp    %r15,%rcx
     994:	0f 87 32 15 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
  if (iph->ihl != 5) {
     99a:	8a 00                	mov    (%rax),%al
     99c:	24 0f                	and    $0xf,%al
     99e:	3c 05                	cmp    $0x5,%al
     9a0:	0f 85 26 15 00 00    	jne    1ecc <balancer_ingress+0x1ecc>
  pckt->flow.proto = iph->protocol;
     9a6:	8a 43 33             	mov    0x33(%rbx),%al
     9a9:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     9ad:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  pckt->flow.src = iph->daddr;
     9b2:	8b 4b 3a             	mov    0x3a(%rbx),%ecx
     9b5:	89 4c 24 10          	mov    %ecx,0x10(%rsp)
  pckt->flow.dst = iph->saddr;
     9b9:	8b 4b 36             	mov    0x36(%rbx),%ecx
     9bc:	89 4c 24 20          	mov    %ecx,0x20(%rsp)
     9c0:	e9 0f 02 00 00       	jmp    bd4 <balancer_ingress+0xbd4>
    vip.port = 0;
     9c5:	66 c7 44 24 68 00 00 	movw   $0x0,0x68(%rsp)
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     9cc:	48 bf 00 48 f3 48 81 	movabs $0xffff888148f34800,%rdi
     9d3:	88 ff ff 
     9d6:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
     9db:	41 ff d4             	call   *%r12
    if (!vip_info) {
     9de:	48 85 c0             	test   %rax,%rax
     9e1:	0f 84 ea 14 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     9e7:	48 89 c7             	mov    %rax,%rdi
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     9ea:	f6 00 88             	testb  $0x88,(%rax)
     9ed:	0f 85 c9 fe ff ff    	jne    8bc <balancer_ingress+0x8bc>
      pckt.flow.port16[1] = 0;
     9f3:	66 c7 44 24 32 00 00 	movw   $0x0,0x32(%rsp)
     9fa:	e9 bd fe ff ff       	jmp    8bc <balancer_ingress+0x8bc>
  struct address dst_addr = {};
     9ff:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%rsp)
     a06:	00 
     a07:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
     a0e:	00 00 
    dst_addr.addr = pckt->flow.dst;
     a10:	8b 44 24 20          	mov    0x20(%rsp),%eax
     a14:	89 44 24 40          	mov    %eax,0x40(%rsp)
  __u32* decap_dst_flags = bpf_map_lookup_elem(&decap_dst, &dst_addr);
     a18:	48 bf 00 58 f3 48 81 	movabs $0xffff888148f35800,%rdi
     a1f:	88 ff ff 
     a22:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     a27:	48 c7 c0 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rax
     a2e:	ff d0                	call   *%rax
     a30:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     a33:	48 85 c0             	test   %rax,%rax
     a36:	74 27                	je     a5f <balancer_ingress+0xa5f>
     a38:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     a3f:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a42:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     a49:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     a50:	79 92 
    if (!data_stats) {
     a52:	48 85 c0             	test   %rax,%rax
     a55:	0f 84 71 14 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    data_stats->v1 += 1;
     a5b:	48 83 00 01          	addq   $0x1,(%rax)
     a5f:	48 8d 43 14          	lea    0x14(%rbx),%rax
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     a63:	48 8d 4b 36          	lea    0x36(%rbx),%rcx
     a67:	bd 01 00 00 00       	mov    $0x1,%ebp
     a6c:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     a72:	4c 39 f9             	cmp    %r15,%rcx
     a75:	77 26                	ja     a9d <balancer_ingress+0xa9d>
    csum = iph->check + 0x0001;
     a77:	0f b7 4b 2c          	movzwl 0x2c(%rbx),%ecx
     a7b:	8d 51 01             	lea    0x1(%rcx),%edx
    iph->check = (csum & 0xffff) + (csum >> 16);
     a7e:	c1 ea 10             	shr    $0x10,%edx
     a81:	01 d1                	add    %edx,%ecx
     a83:	83 c1 01             	add    $0x1,%ecx
     a86:	66 89 4b 2c          	mov    %cx,0x2c(%rbx)
    if (!--iph->ttl) {
     a8a:	80 43 2a ff          	addb   $0xff,0x2a(%rbx)
     a8e:	b9 01 00 00 00       	mov    $0x1,%ecx
     a93:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
     a99:	44 0f 44 e1          	cmove  %ecx,%r12d
decap_v4(struct xdp_md* xdp, void** data, void** data_end) {
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  old_eth = *data;
  new_eth = *data + sizeof(struct iphdr);
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     a9d:	0f b7 4b 0a          	movzwl 0xa(%rbx),%ecx
     aa1:	66 89 4b 1e          	mov    %cx,0x1e(%rbx)
     aa5:	8b 4b 06             	mov    0x6(%rbx),%ecx
     aa8:	89 4b 1a             	mov    %ecx,0x1a(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     aab:	0f b7 4b 04          	movzwl 0x4(%rbx),%ecx
     aaf:	66 89 48 04          	mov    %cx,0x4(%rax)
     ab3:	8b 0b                	mov    (%rbx),%ecx
     ab5:	89 08                	mov    %ecx,(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
     ab7:	66 c7 43 20 08 00    	movw   $0x8,0x20(%rbx)
     abd:	48 c7 c0 20 5c c3 8e 	mov    $0xffffffff8ec35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     ac4:	4c 89 ef             	mov    %r13,%rdi
     ac7:	be 14 00 00 00       	mov    $0x14,%esi
     acc:	ff d0                	call   *%rax
     ace:	85 c0                	test   %eax,%eax
     ad0:	0f 85 fb 13 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
     ad6:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     add:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     ae0:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     ae7:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
     aee:	79 92 
  if (!data_stats) {
     af0:	48 85 c9             	test   %rcx,%rcx
     af3:	0f 84 d8 13 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     af9:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     afe:	45 85 e4             	test   %r12d,%r12d
     b01:	bd 02 00 00 00       	mov    $0x2,%ebp
     b06:	41 0f 49 ec          	cmovns %r12d,%ebp
  if (decap_dst_flags) {
     b0a:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     b0d:	0f 84 be 13 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     b13:	45 85 e4             	test   %r12d,%r12d
     b16:	0f 89 b5 13 00 00    	jns    1ed1 <balancer_ingress+0x1ed1>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b1c:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     b23:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     b2a:	79 92 
    if (xpop_stats_data) {
     b2c:	48 85 c0             	test   %rax,%rax
     b2f:	74 04                	je     b35 <balancer_ingress+0xb35>
     b31:	48 83 00 01          	addq   $0x1,(%rax)
     b35:	48 b8 00 88 fd 57 81 	movabs $0xffff888157fd8800,%rax
     b3c:	88 ff ff 
     b3f:	48 8b 88 00 01 00 00 	mov    0x100(%rax),%rcx
     b46:	48 85 c9             	test   %rcx,%rcx
     b49:	0f 84 e1 03 00 00    	je     f30 <balancer_ingress+0xf30>
     b4f:	4c 89 ef             	mov    %r13,%rdi
     b52:	ff 51 30             	call   *0x30(%rcx)
     b55:	89 c5                	mov    %eax,%ebp
     b57:	e9 75 13 00 00       	jmp    1ed1 <balancer_ingress+0x1ed1>
     b5c:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     b63:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     b66:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     b6d:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     b74:	79 92 
    if (!icmp_ptb_v6_stats) {
     b76:	48 85 c0             	test   %rax,%rax
     b79:	0f 84 4d 13 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    icmp_ptb_v6_stats->v1 += 1;
     b7f:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     b83:	8b 4b 26             	mov    0x26(%rbx),%ecx
     b86:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     b88:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     b8e:	77 05                	ja     b95 <balancer_ingress+0xb95>
      icmp_ptb_v6_stats->v2 += 1;
     b90:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     b95:	48 8d 43 52          	lea    0x52(%rbx),%rax
     b99:	4c 39 f8             	cmp    %r15,%rax
     b9c:	0f 87 2a 13 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
     ba2:	48 8d 4c 24 20       	lea    0x20(%rsp),%rcx
  pckt->flow.proto = ip6h->nexthdr;
     ba7:	8a 43 30             	mov    0x30(%rbx),%al
     baa:	88 44 24 34          	mov    %al,0x34(%rsp)
  pckt->flags |= F_ICMP;
     bae:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     bb3:	48 8b 53 42          	mov    0x42(%rbx),%rdx
     bb7:	48 8b 73 4a          	mov    0x4a(%rbx),%rsi
     bbb:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
     bc0:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     bc5:	48 8b 53 32          	mov    0x32(%rbx),%rdx
     bc9:	48 8b 73 3a          	mov    0x3a(%rbx),%rsi
     bcd:	48 89 11             	mov    %rdx,(%rcx)
     bd0:	48 89 71 08          	mov    %rsi,0x8(%rcx)
     bd4:	b2 03                	mov    $0x3,%dl
     bd6:	31 c9                	xor    %ecx,%ecx
     bd8:	bd 02 00 00 00       	mov    $0x2,%ebp
  if (protocol == IPPROTO_IPIP) {
     bdd:	3c 10                	cmp    $0x10,%al
     bdf:	0f 8e a8 f8 ff ff    	jle    48d <balancer_ingress+0x48d>
     be5:	3c 11                	cmp    $0x11,%al
     be7:	0f 84 3f 01 00 00    	je     d2c <balancer_ingress+0xd2c>
     bed:	3c 29                	cmp    $0x29,%al
     bef:	0f 85 dc 12 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
  struct address dst_addr = {};
     bf5:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%rsp)
     bfc:	00 
     bfd:	48 c7 44 24 44 00 00 	movq   $0x0,0x44(%rsp)
     c04:	00 00 
    dst_addr.addr = pckt->flow.dst;
     c06:	8b 44 24 20          	mov    0x20(%rsp),%eax
     c0a:	89 44 24 40          	mov    %eax,0x40(%rsp)
  __u32* decap_dst_flags = bpf_map_lookup_elem(&decap_dst, &dst_addr);
     c0e:	48 bf 00 58 f3 48 81 	movabs $0xffff888148f35800,%rdi
     c15:	88 ff ff 
     c18:	48 8d 74 24 40       	lea    0x40(%rsp),%rsi
     c1d:	48 c7 c0 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rax
     c24:	ff d0                	call   *%rax
     c26:	49 89 c6             	mov    %rax,%r14
  if (decap_dst_flags) {
     c29:	48 85 c0             	test   %rax,%rax
     c2c:	74 27                	je     c55 <balancer_ingress+0xc55>
     c2e:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     c35:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c38:	48 8b 80 30 11 00 00 	mov    0x1130(%rax),%rax
     c3f:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     c46:	79 92 
    if (!data_stats) {
     c48:	48 85 c0             	test   %rax,%rax
     c4b:	0f 84 7b 12 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    data_stats->v1 += 1;
     c51:	48 83 00 01          	addq   $0x1,(%rax)
    if ((*data + offset) > *data_end) {
     c55:	48 8d 43 36          	lea    0x36(%rbx),%rax
     c59:	bd 01 00 00 00       	mov    $0x1,%ebp
     c5e:	4c 39 f8             	cmp    %r15,%rax
     c61:	0f 87 6a 12 00 00    	ja     1ed1 <balancer_ingress+0x1ed1>
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     c67:	48 8d 43 5e          	lea    0x5e(%rbx),%rax
     c6b:	bd 01 00 00 00       	mov    $0x1,%ebp
     c70:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     c76:	4c 39 f8             	cmp    %r15,%rax
     c79:	77 13                	ja     c8e <balancer_ingress+0xc8e>
    if (!--ip6h->hop_limit) {
     c7b:	80 43 3d ff          	addb   $0xff,0x3d(%rbx)
     c7f:	b8 01 00 00 00       	mov    $0x1,%eax
     c84:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
     c8a:	44 0f 44 e0          	cmove  %eax,%r12d
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     c8e:	0f b7 43 0a          	movzwl 0xa(%rbx),%eax
     c92:	66 89 43 32          	mov    %ax,0x32(%rbx)
     c96:	8b 43 06             	mov    0x6(%rbx),%eax
     c99:	89 43 2e             	mov    %eax,0x2e(%rbx)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     c9c:	8b 03                	mov    (%rbx),%eax
     c9e:	89 43 28             	mov    %eax,0x28(%rbx)
     ca1:	0f b7 43 04          	movzwl 0x4(%rbx),%eax
     ca5:	66 89 43 2c          	mov    %ax,0x2c(%rbx)
     ca9:	66 c7 43 34 86 dd    	movw   $0xdd86,0x34(%rbx)
     caf:	48 c7 c0 20 5c c3 8e 	mov    $0xffffffff8ec35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     cb6:	4c 89 ef             	mov    %r13,%rdi
     cb9:	be 28 00 00 00       	mov    $0x28,%esi
     cbe:	ff d0                	call   *%rax
     cc0:	85 c0                	test   %eax,%eax
     cc2:	0f 85 09 12 00 00    	jne    1ed1 <balancer_ingress+0x1ed1>
     cc8:	48 b8 00 00 98 03 83 	movabs $0xffff888303980000,%rax
     ccf:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     cd2:	48 8b 88 50 11 00 00 	mov    0x1150(%rax),%rcx
     cd9:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
     ce0:	79 92 
  if (!data_stats) {
     ce2:	48 85 c9             	test   %rcx,%rcx
     ce5:	0f 84 e6 11 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     ceb:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (action >= 0) {
     cf0:	45 85 e4             	test   %r12d,%r12d
     cf3:	bd 02 00 00 00       	mov    $0x2,%ebp
     cf8:	41 0f 49 ec          	cmovns %r12d,%ebp
  if (decap_dst_flags) {
     cfc:	4d 85 f6             	test   %r14,%r14
  if (action >= 0) {
     cff:	0f 84 cc 11 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     d05:	45 85 e4             	test   %r12d,%r12d
     d08:	0f 89 c3 11 00 00    	jns    1ed1 <balancer_ingress+0x1ed1>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     d0e:	48 8b 80 70 11 00 00 	mov    0x1170(%rax),%rax
     d15:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     d1c:	79 92 
    if (xpop_stats_data) {
     d1e:	48 85 c0             	test   %rax,%rax
     d21:	0f 85 52 f9 ff ff    	jne    679 <balancer_ingress+0x679>
     d27:	e9 09 fe ff ff       	jmp    b35 <balancer_ingress+0xb35>
  udp = data + off;
     d2c:	48 8d 43 3e          	lea    0x3e(%rbx),%rax
  if (is_ipv6) {
     d30:	84 c9                	test   %cl,%cl
  udp = data + off;
     d32:	49 0f 45 c6          	cmovne %r14,%rax
  if (udp + 1 > data_end) {
     d36:	48 8d 50 08          	lea    0x8(%rax),%rdx
     d3a:	4c 39 fa             	cmp    %r15,%rdx
     d3d:	0f 87 89 11 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
     d43:	84 c9                	test   %cl,%cl
     d45:	66 89 7c 24 54       	mov    %di,0x54(%rsp)
     d4a:	74 13                	je     d5f <balancer_ingress+0xd5f>
     d4c:	0f b7 10             	movzwl (%rax),%edx
     d4f:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     d54:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     d59:	48 83 c0 02          	add    $0x2,%rax
     d5d:	eb 0e                	jmp    d6d <balancer_ingress+0xd6d>
     d5f:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     d63:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
     d68:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     d6d:	0f b7 00             	movzwl (%rax),%eax
     d70:	66 89 41 02          	mov    %ax,0x2(%rcx)
    vip.vip = pckt.flow.dst;
     d74:	8b 44 24 20          	mov    0x20(%rsp),%eax
     d78:	89 44 24 58          	mov    %eax,0x58(%rsp)
  vip.port = pckt.flow.port16[1];
     d7c:	0f b7 44 24 32       	movzwl 0x32(%rsp),%eax
     d81:	66 89 44 24 68       	mov    %ax,0x68(%rsp)
  vip.proto = pckt.flow.proto;
     d86:	8a 44 24 34          	mov    0x34(%rsp),%al
     d8a:	88 44 24 6a          	mov    %al,0x6a(%rsp)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     d8e:	48 bf 00 48 f3 48 81 	movabs $0xffff888148f34800,%rdi
     d95:	88 ff ff 
     d98:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
     d9d:	49 c7 c4 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%r12
     da4:	41 ff d4             	call   *%r12
     da7:	48 89 c2             	mov    %rax,%rdx
  if (!vip_info) {
     daa:	48 85 c0             	test   %rax,%rax
     dad:	0f 84 43 01 00 00    	je     ef6 <balancer_ingress+0xef6>
  if (data_end - data > MAX_PCKT_SIZE) {
     db3:	4c 89 f8             	mov    %r15,%rax
     db6:	48 29 d8             	sub    %rbx,%rax
     db9:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     dbf:	0f 8f 07 11 00 00    	jg     1ecc <balancer_ingress+0x1ecc>
     dc5:	49 bc 00 00 98 03 83 	movabs $0xffff888303980000,%r12
     dcc:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     dcf:	49 8b ac 24 00 11 00 	mov    0x1100(%r12),%rbp
     dd6:	00 
     dd7:	65 48 03 2c 25 28 50 	add    %gs:0xffffffff92795028,%rbp
     dde:	79 92 
  if (!data_stats) {
     de0:	48 85 ed             	test   %rbp,%rbp
     de3:	0f 84 e3 10 00 00    	je     1ecc <balancer_ingress+0x1ecc>
  data_stats->v1 += 1;
     de9:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     dee:	f6 02 01             	testb  $0x1,(%rdx)
     df1:	74 07                	je     dfa <balancer_ingress+0xdfa>
    pckt.flow.port16[0] = 0;
     df3:	66 c7 44 24 30 00 00 	movw   $0x0,0x30(%rsp)
  vip_num = vip_info->vip_num;
     dfa:	8b 42 04             	mov    0x4(%rdx),%eax
     dfd:	48 89 84 24 80 00 00 	mov    %rax,0x80(%rsp)
     e04:	00 
     e05:	48 c7 c0 34 50 79 92 	mov    $0xffffffff92795034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     e0c:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     e13:	79 92 
     e15:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e18:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     e1d:	0f 84 4c 01 00 00    	je     f6f <balancer_ingress+0xf6f>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e23:	49 8b 84 24 18 11 00 	mov    0x1118(%r12),%rax
     e2a:	00 
     e2b:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     e32:	79 92 
    if (!lru_stats) {
     e34:	48 85 c0             	test   %rax,%rax
     e37:	0f 84 8f 10 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    lru_stats->v1 += 1;
     e3d:	48 83 00 01          	addq   $0x1,(%rax)
     e41:	48 b8 00 40 f3 48 81 	movabs $0xffff888148f34000,%rax
     e48:	88 ff ff 
     e4b:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
     e50:	e9 3c 01 00 00       	jmp    f91 <balancer_ingress+0xf91>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e55:	89 c0                	mov    %eax,%eax
     e57:	48 b9 00 f0 b4 e1 81 	movabs $0xffff8881e1b4f000,%rcx
     e5e:	88 ff ff 
     e61:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     e68:	00 
     e69:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  if (!lru_map) {
     e6e:	48 85 c0             	test   %rax,%rax
     e71:	0f 84 ac fa ff ff    	je     923 <balancer_ingress+0x923>
     e77:	48 89 b4 24 80 00 00 	mov    %rsi,0x80(%rsp)
     e7e:	00 
  if ((vip_info->flags & F_QUIC_VIP)) {
     e7f:	f6 07 04             	testb  $0x4,(%rdi)
     e82:	0f 84 6d 0a 00 00    	je     18f5 <balancer_ingress+0x18f5>
    bool is_icmp = (pckt.flags & F_ICMP);
     e88:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
    if (is_icmp) {
     e8d:	0f 85 a7 00 00 00    	jne    f3a <balancer_ingress+0xf3a>
     e93:	48 b8 00 80 fd 57 81 	movabs $0xffff888157fd8000,%rax
     e9a:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     e9d:	48 8b a8 00 01 00 00 	mov    0x100(%rax),%rbp
     ea4:	65 48 03 2c 25 28 50 	add    %gs:0xffffffff92795028,%rbp
     eab:	79 92 
      if (!quic_packets_stats) {
     ead:	48 85 ed             	test   %rbp,%rbp
     eb0:	0f 84 16 10 00 00    	je     1ecc <balancer_ingress+0x1ecc>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     eb6:	48 83 c3 66          	add    $0x66,%rbx
  bool is_icmp = (pckt->flags & F_ICMP);
     eba:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     ebf:	49 0f 44 de          	cmove  %r14,%rbx
     ec3:	48 8d 43 09          	lea    0x9(%rbx),%rax
     ec7:	4c 39 f8             	cmp    %r15,%rax
     eca:	0f 87 20 0a 00 00    	ja     18f0 <balancer_ingress+0x18f0>
     ed0:	48 89 14 24          	mov    %rdx,(%rsp)
     ed4:	48 83 c3 08          	add    $0x8,%rbx
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     ed8:	0f b6 0b             	movzbl (%rbx),%ecx
     edb:	f6 c1 80             	test   $0x80,%cl
     ede:	0f 85 b6 01 00 00    	jne    109a <balancer_ingress+0x109a>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     ee4:	48 83 c3 09          	add    $0x9,%rbx
     ee8:	4c 39 fb             	cmp    %r15,%rbx
     eeb:	0f 87 fb 09 00 00    	ja     18ec <balancer_ingress+0x18ec>
     ef1:	e9 d4 02 00 00       	jmp    11ca <balancer_ingress+0x11ca>
    vip.port = 0;
     ef6:	66 c7 44 24 68 00 00 	movw   $0x0,0x68(%rsp)
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     efd:	48 bf 00 48 f3 48 81 	movabs $0xffff888148f34800,%rdi
     f04:	88 ff ff 
     f07:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
     f0c:	41 ff d4             	call   *%r12
    if (!vip_info) {
     f0f:	48 85 c0             	test   %rax,%rax
     f12:	0f 84 b9 0f 00 00    	je     1ed1 <balancer_ingress+0x1ed1>
     f18:	48 89 c2             	mov    %rax,%rdx
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     f1b:	f6 00 88             	testb  $0x88,(%rax)
     f1e:	0f 85 8f fe ff ff    	jne    db3 <balancer_ingress+0xdb3>
      pckt.flow.port16[1] = 0;
     f24:	66 c7 44 24 32 00 00 	movw   $0x0,0x32(%rsp)
     f2b:	e9 83 fe ff ff       	jmp    db3 <balancer_ingress+0xdb3>
     f30:	bd 02 00 00 00       	mov    $0x2,%ebp
     f35:	e9 97 0f 00 00       	jmp    1ed1 <balancer_ingress+0x1ed1>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     f3a:	49 8b ac 24 58 11 00 	mov    0x1158(%r12),%rbp
     f41:	00 
     f42:	65 48 03 2c 25 28 50 	add    %gs:0xffffffff92795028,%rbp
     f49:	79 92 
      if (!data_stats) {
     f4b:	48 85 ed             	test   %rbp,%rbp
     f4e:	0f 84 78 0f 00 00    	je     1ecc <balancer_ingress+0x1ecc>
      data_stats->v1 += 1;
     f54:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     f59:	8a 43 37             	mov    0x37(%rbx),%al
     f5c:	04 fd                	add    $0xfd,%al
     f5e:	3c 01                	cmp    $0x1,%al
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     f60:	0f 87 8f 09 00 00    	ja     18f5 <balancer_ingress+0x18f5>
        data_stats->v2 += 1;
     f66:	48 83 c5 08          	add    $0x8,%rbp
     f6a:	e9 81 09 00 00       	jmp    18f0 <balancer_ingress+0x18f0>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     f6f:	89 c0                	mov    %eax,%eax
     f71:	48 b9 00 f0 b4 e1 81 	movabs $0xffff8881e1b4f000,%rcx
     f78:	88 ff ff 
     f7b:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     f82:	00 
     f83:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  if (!lru_map) {
     f88:	48 85 c0             	test   %rax,%rax
     f8b:	0f 84 92 fe ff ff    	je     e23 <balancer_ingress+0xe23>
  if ((vip_info->flags & F_QUIC_VIP)) {
     f91:	f6 02 04             	testb  $0x4,(%rdx)
     f94:	48 89 54 24 08       	mov    %rdx,0x8(%rsp)
     f99:	0f 84 90 00 00 00    	je     102f <balancer_ingress+0x102f>
    bool is_icmp = (pckt.flags & F_ICMP);
     f9f:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
    if (is_icmp) {
     fa4:	75 48                	jne    fee <balancer_ingress+0xfee>
     fa6:	48 b8 00 80 fd 57 81 	movabs $0xffff888157fd8000,%rax
     fad:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     fb0:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
     fb7:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     fbe:	79 92 
     fc0:	48 89 04 24          	mov    %rax,(%rsp)
      if (!quic_packets_stats) {
     fc4:	48 85 c0             	test   %rax,%rax
     fc7:	0f 84 ff 0e 00 00    	je     1ecc <balancer_ingress+0x1ecc>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fcd:	48 83 c3 3e          	add    $0x3e,%rbx
  bool is_icmp = (pckt->flags & F_ICMP);
     fd1:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     fd6:	49 0f 44 de          	cmove  %r14,%rbx
     fda:	48 8d 43 09          	lea    0x9(%rbx),%rax
     fde:	4c 39 f8             	cmp    %r15,%rax
     fe1:	0f 86 07 01 00 00    	jbe    10ee <balancer_ingress+0x10ee>
     fe7:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
     fec:	eb 39                	jmp    1027 <balancer_ingress+0x1027>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fee:	49 8b 84 24 58 11 00 	mov    0x1158(%r12),%rax
     ff5:	00 
     ff6:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
     ffd:	79 92 
     fff:	48 89 04 24          	mov    %rax,(%rsp)
      if (!data_stats) {
    1003:	48 85 c0             	test   %rax,%rax
    1006:	0f 84 c0 0e 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    100c:	48 8b 04 24          	mov    (%rsp),%rax
      data_stats->v1 += 1;
    1010:	48 83 00 01          	addq   $0x1,(%rax)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    1014:	8a 43 23             	mov    0x23(%rbx),%al
    1017:	24 fd                	and    $0xfd,%al
    1019:	3c 01                	cmp    $0x1,%al
    101b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    1020:	75 0d                	jne    102f <balancer_ingress+0x102f>
        data_stats->v2 += 1;
    1022:	48 83 04 24 08       	addq   $0x8,(%rsp)
    1027:	48 8b 04 24          	mov    (%rsp),%rax
    102b:	48 83 00 01          	addq   $0x1,(%rax)
  original_sport = pckt.flow.port16[0];
    102f:	44 0f b7 7c 24 30    	movzwl 0x30(%rsp),%r15d
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1035:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    103a:	75 56                	jne    1092 <balancer_ingress+0x1092>
        !(vip_info->flags & F_LRU_BYPASS)) {
    103c:	f6 02 02             	testb  $0x2,(%rdx)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    103f:	75 49                	jne    108a <balancer_ingress+0x108a>
    1041:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    1046:	48 c7 c0 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rax
    104d:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1052:	ff d0                	call   *%rax
  if (!dst_lru) {
    1054:	48 85 c0             	test   %rax,%rax
    1057:	74 31                	je     108a <balancer_ingress+0x108a>
    1059:	48 89 c3             	mov    %rax,%rbx
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    105c:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1061:	0f 85 af 01 00 00    	jne    1216 <balancer_ingress+0x1216>
    1067:	48 c7 c0 30 d6 a9 8c 	mov    $0xffffffff8ca9d630,%rax
    cur_time = bpf_ktime_get_ns();
    106e:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1070:	48 89 c1             	mov    %rax,%rcx
    1073:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1077:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    107e:	00 00 00 
    1081:	48 39 d1             	cmp    %rdx,%rcx
    1084:	0f 86 88 01 00 00    	jbe    1212 <balancer_ingress+0x1212>
    108a:	45 31 f6             	xor    %r14d,%r14d
    108d:	e9 ad 01 00 00       	jmp    123f <balancer_ingress+0x123f>
    1092:	45 31 f6             	xor    %r14d,%r14d
    1095:	e9 aa 01 00 00       	jmp    1244 <balancer_ingress+0x1244>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    109a:	48 8d 43 0e          	lea    0xe(%rbx),%rax
    109e:	4c 39 f8             	cmp    %r15,%rax
    10a1:	0f 87 45 08 00 00    	ja     18ec <balancer_ingress+0x18ec>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    10a7:	f6 c1 20             	test   $0x20,%cl
    10aa:	0f 85 09 01 00 00    	jne    11b9 <balancer_ingress+0x11b9>
        quic_packets_stats->cid_initial += 1;
    10b0:	48 83 45 08 01       	addq   $0x1,0x8(%rbp)
    10b5:	48 8b 14 24          	mov    (%rsp),%rdx
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    10b9:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
    10bf:	0f 87 30 08 00 00    	ja     18f5 <balancer_ingress+0x18f5>
    10c5:	48 b8 00 00 00 71 81 	movabs $0xffff888171000000,%rax
    10cc:	88 ff ff 
    10cf:	48 8b ac d0 00 01 00 	mov    0x100(%rax,%rdx,8),%rbp
    10d6:	00 
    10d7:	65 48 03 2c 25 28 50 	add    %gs:0xffffffff92795028,%rbp
    10de:	79 92 
  if (!per_vip_stats) {
    10e0:	48 85 ed             	test   %rbp,%rbp
    10e3:	0f 85 07 08 00 00    	jne    18f0 <balancer_ingress+0x18f0>
    10e9:	e9 07 08 00 00       	jmp    18f5 <balancer_ingress+0x18f5>
    10ee:	48 83 c3 08          	add    $0x8,%rbx
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    10f2:	0f b6 0b             	movzbl (%rbx),%ecx
    10f5:	f6 c1 80             	test   $0x80,%cl
    10f8:	75 55                	jne    114f <balancer_ingress+0x114f>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    10fa:	48 83 c3 09          	add    $0x9,%rbx
    10fe:	4c 39 fb             	cmp    %r15,%rbx
    1101:	0f 87 e0 fe ff ff    	ja     fe7 <balancer_ingress+0xfe7>
  if (!connId) {
    1107:	48 85 c0             	test   %rax,%rax
    110a:	0f 84 d7 fe ff ff    	je     fe7 <balancer_ingress+0xfe7>
  __u8 connIdVersion = (connId[0] >> 6);
    1110:	0f b6 08             	movzbl (%rax),%ecx
    1113:	89 ca                	mov    %ecx,%edx
    1115:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    1118:	80 fa 03             	cmp    $0x3,%dl
    111b:	0f 84 ab 0f 00 00    	je     20cc <balancer_ingress+0x20cc>
    1121:	80 fa 02             	cmp    $0x2,%dl
    1124:	0f 84 c7 0f 00 00    	je     20f1 <balancer_ingress+0x20f1>
    112a:	80 fa 01             	cmp    $0x1,%dl
    112d:	0f 85 b4 fe ff ff    	jne    fe7 <balancer_ingress+0xfe7>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    1133:	83 e1 3f             	and    $0x3f,%ecx
    1136:	48 c1 e1 0a          	shl    $0xa,%rcx
    113a:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    113e:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
    1142:	8a 40 02             	mov    0x2(%rax),%al
    1145:	c0 e8 06             	shr    $0x6,%al
    1148:	b2 01                	mov    $0x1,%dl
    114a:	e9 ba 0f 00 00       	jmp    2109 <balancer_ingress+0x2109>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    114f:	48 8d 43 0e          	lea    0xe(%rbx),%rax
    1153:	4c 39 f8             	cmp    %r15,%rax
    1156:	0f 87 8b fe ff ff    	ja     fe7 <balancer_ingress+0xfe7>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    115c:	f6 c1 20             	test   $0x20,%cl
    115f:	0f 85 c3 06 00 00    	jne    1828 <balancer_ingress+0x1828>
    1165:	48 8b 04 24          	mov    (%rsp),%rax
        quic_packets_stats->cid_initial += 1;
    1169:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    116e:	81 bc 24 80 00 00 00 	cmpl   $0x1ff,0x80(%rsp)
    1175:	ff 01 00 00 
    1179:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    117e:	0f 87 ab fe ff ff    	ja     102f <balancer_ingress+0x102f>
    1184:	48 b8 00 00 00 71 81 	movabs $0xffff888171000000,%rax
    118b:	88 ff ff 
    118e:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
    1195:	00 
    1196:	48 8b 84 c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rax
    119d:	00 
    119e:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    11a5:	79 92 
    11a7:	48 89 04 24          	mov    %rax,(%rsp)
  if (!per_vip_stats) {
    11ab:	48 85 c0             	test   %rax,%rax
    11ae:	0f 85 73 fe ff ff    	jne    1027 <balancer_ingress+0x1027>
    11b4:	e9 76 fe ff ff       	jmp    102f <balancer_ingress+0x102f>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    11b9:	80 7b 05 08          	cmpb   $0x8,0x5(%rbx)
    11bd:	0f 82 29 07 00 00    	jb     18ec <balancer_ingress+0x18ec>
    11c3:	48 83 c3 06          	add    $0x6,%rbx
    11c7:	48 89 d8             	mov    %rbx,%rax
  if (!connId) {
    11ca:	48 85 c0             	test   %rax,%rax
    11cd:	0f 84 19 07 00 00    	je     18ec <balancer_ingress+0x18ec>
  __u8 connIdVersion = (connId[0] >> 6);
    11d3:	0f b6 08             	movzbl (%rax),%ecx
    11d6:	89 ca                	mov    %ecx,%edx
    11d8:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    11db:	80 fa 03             	cmp    $0x3,%dl
    11de:	0f 84 16 05 00 00    	je     16fa <balancer_ingress+0x16fa>
    11e4:	80 fa 02             	cmp    $0x2,%dl
    11e7:	0f 84 32 05 00 00    	je     171f <balancer_ingress+0x171f>
    11ed:	80 fa 01             	cmp    $0x1,%dl
    11f0:	0f 85 f6 06 00 00    	jne    18ec <balancer_ingress+0x18ec>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    11f6:	83 e1 3f             	and    $0x3f,%ecx
    11f9:	48 c1 e1 0a          	shl    $0xa,%rcx
    11fd:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    1201:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
    1205:	8a 40 02             	mov    0x2(%rax),%al
    1208:	c0 e8 06             	shr    $0x6,%al
    120b:	b2 01                	mov    $0x1,%dl
    120d:	e9 25 05 00 00       	jmp    1737 <balancer_ingress+0x1737>
    dst_lru->atime = cur_time;
    1212:	48 89 43 08          	mov    %rax,0x8(%rbx)
  key = dst_lru->pos;
    1216:	8b 03                	mov    (%rbx),%eax
    1218:	45 31 f6             	xor    %r14d,%r14d
    121b:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    1221:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1225:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    1229:	48 b9 00 90 b1 11 00 	movabs $0xffffc90011b19000,%rcx
    1230:	c9 ff ff 
    1233:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    123a:	00 
    123b:	4c 0f 42 f0          	cmovb  %rax,%r14
    123f:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1244:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1249:	0f 85 ab 00 00 00    	jne    12fa <balancer_ingress+0x12fa>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    124f:	f6 42 01 02          	testb  $0x2,0x1(%rdx)
    1253:	0f 84 a1 00 00 00    	je     12fa <balancer_ingress+0x12fa>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1259:	49 8b 9c 24 10 11 00 	mov    0x1110(%r12),%rbx
    1260:	00 
    1261:	65 48 03 1c 25 28 50 	add    %gs:0xffffffff92795028,%rbx
    1268:	79 92 
  if (!conn_rate_stats) {
    126a:	48 85 db             	test   %rbx,%rbx
    126d:	0f 84 87 00 00 00    	je     12fa <balancer_ingress+0x12fa>
    1273:	48 c7 c0 30 d6 a9 8c 	mov    $0xffffffff8ca9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    127a:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    127c:	48 89 c1             	mov    %rax,%rcx
    127f:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1283:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    128a:	72 0d                	jb     1299 <balancer_ingress+0x1299>
    conn_rate_stats->v1 = 1;
    128c:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1293:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1297:	eb 12                	jmp    12ab <balancer_ingress+0x12ab>
    conn_rate_stats->v1 += 1;
    1299:	48 8b 03             	mov    (%rbx),%rax
    129c:	48 83 c0 01          	add    $0x1,%rax
    12a0:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    12a3:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    12a9:	77 4f                	ja     12fa <balancer_ingress+0x12fa>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    12ab:	48 bf 00 30 f3 48 81 	movabs $0xffff888148f33000,%rdi
    12b2:	88 ff ff 
    12b5:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
    12ba:	48 c7 c3 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rbx
    12c1:	ff d3                	call   *%rbx
    if (down_reals_map) {
    12c3:	48 85 c0             	test   %rax,%rax
    12c6:	74 32                	je     12fa <balancer_ingress+0x12fa>
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    12c8:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
    12cd:	48 89 c7             	mov    %rax,%rdi
    12d0:	ff d3                	call   *%rbx
      if (down_real) {
    12d2:	48 85 c0             	test   %rax,%rax
    12d5:	74 23                	je     12fa <balancer_ingress+0x12fa>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    12d7:	49 8b 84 24 78 11 00 	mov    0x1178(%r12),%rax
    12de:	00 
    12df:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    12e6:	79 92 
        if (stats_data) {
    12e8:	48 85 c0             	test   %rax,%rax
    12eb:	0f 84 77 01 00 00    	je     1468 <balancer_ingress+0x1468>
          stats_data->v1 += 1;
    12f1:	48 83 00 01          	addq   $0x1,(%rax)
    12f5:	e9 6e 01 00 00       	jmp    1468 <balancer_ingress+0x1468>
    if (!dst) {
    12fa:	4d 85 f6             	test   %r14,%r14
    12fd:	0f 84 65 01 00 00    	je     1468 <balancer_ingress+0x1468>
    1303:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    130a:	00 
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    130b:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    1310:	0f 87 b6 0b 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    1316:	49 8b 8c c4 00 01 00 	mov    0x100(%r12,%rax,8),%rcx
    131d:	00 
    131e:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
    1325:	79 92 
  if (!data_stats) {
    1327:	48 85 c9             	test   %rcx,%rcx
    132a:	0f 84 9c 0b 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    1330:	0f b7 44 24 54       	movzwl 0x54(%rsp),%eax
    1335:	89 c3                	mov    %eax,%ebx
    1337:	66 c1 c3 08          	rol    $0x8,%bx
  data_stats->v1 += 1;
    133b:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    133f:	0f b7 c3             	movzwl %bx,%eax
    1342:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1346:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    134a:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    1351:	0f 87 75 0b 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    1357:	48 ba 00 80 23 11 00 	movabs $0xffffc90011238000,%rdx
    135e:	c9 ff ff 
    1361:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
    1368:	00 
    1369:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
    1370:	79 92 
  if (!data_stats) {
    1372:	48 85 c9             	test   %rcx,%rcx
    1375:	0f 84 51 0b 00 00    	je     1ecc <balancer_ingress+0x1ecc>
  data_stats->v1 += 1;
    137b:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    137f:	48 01 41 08          	add    %rax,0x8(%rcx)
  pckt.flow.port16[0] = original_sport;
    1383:	66 44 89 7c 24 30    	mov    %r15w,0x30(%rsp)
  if (dst->flags & F_IPV6) {
    1389:	41 f6 46 10 01       	testb  $0x1,0x10(%r14)
    138e:	0f 85 ab 02 00 00    	jne    163f <balancer_ingress+0x163f>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1394:	44 0f b7 64 24 12    	movzwl 0x12(%rsp),%r12d
    139a:	48 c7 c0 20 5c c3 8e 	mov    $0xffffffff8ec35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    13a1:	4c 89 ef             	mov    %r13,%rdi
    13a4:	be ec ff ff ff       	mov    $0xffffffec,%esi
    13a9:	ff d0                	call   *%rax
    13ab:	85 c0                	test   %eax,%eax
    13ad:	0f 85 19 0b 00 00    	jne    1ecc <balancer_ingress+0x1ecc>
  data = (void*)(long)xdp->data;
    13b3:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    13b7:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  iph = data + sizeof(struct ethhdr);
    13bb:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    13bf:	48 39 ca             	cmp    %rcx,%rdx
    13c2:	0f 87 04 0b 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    13c8:	48 8d 50 22          	lea    0x22(%rax),%rdx
    13cc:	bd 01 00 00 00       	mov    $0x1,%ebp
    13d1:	48 39 ca             	cmp    %rcx,%rdx
    13d4:	0f 87 f7 0a 00 00    	ja     1ed1 <balancer_ingress+0x1ed1>
    13da:	66 41 c1 c7 08       	rol    $0x8,%r15w
    13df:	45 31 fc             	xor    %r15d,%r12d
    13e2:	41 c1 e4 10          	shl    $0x10,%r12d
    13e6:	41 8d bc 24 ac 10 00 	lea    0x10ac(%r12),%edi
    13ed:	00 
    13ee:	48 b9 00 8c fd 57 81 	movabs $0xffff888157fd8c00,%rcx
    13f5:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    13f8:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    13ff:	66 89 70 04          	mov    %si,0x4(%rax)
    1403:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1409:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    140b:	8b 48 14             	mov    0x14(%rax),%ecx
    140e:	89 48 06             	mov    %ecx,0x6(%rax)
    1411:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    1415:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    1419:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    141f:	8a 54 24 3d          	mov    0x3d(%rsp),%dl
    1423:	41 8b 0e             	mov    (%r14),%ecx
    __u32 daddr,
    __u16 pkt_bytes,
    __u8 proto) {
  __u64 csum = 0;
  iph->version = 4;
  iph->ihl = 5;
    1426:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->frag_off = 0;
  iph->protocol = proto;
  iph->check = 0;
#ifdef COPY_INNER_PACKET_TOS
  iph->tos = tos;
    142a:	88 50 0f             	mov    %dl,0xf(%rax)
#else
  iph->tos = DEFAULT_TOS;
#endif
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    142d:	83 c3 14             	add    $0x14,%ebx
    1430:	66 c1 c3 08          	rol    $0x8,%bx
    1434:	66 89 58 10          	mov    %bx,0x10(%rax)
  iph->id = 0;
    1438:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    143f:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    1442:	89 78 1a             	mov    %edi,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    1445:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    144b:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    144f:	0f b7 f3             	movzwl %bx,%esi
    1452:	0f b7 78 16          	movzwl 0x16(%rax),%edi
    1456:	41 c1 ec 10          	shr    $0x10,%r12d
    145a:	49 01 f4             	add    %rsi,%r12
    145d:	0f b7 f1             	movzwl %cx,%esi
    1460:	4c 01 e6             	add    %r12,%rsi
    1463:	e9 5e 07 00 00       	jmp    1bc6 <balancer_ingress+0x1bc6>
      if (pckt.flow.proto == IPPROTO_TCP) {
    1468:	80 7c 24 34 06       	cmpb   $0x6,0x34(%rsp)
    146d:	75 2b                	jne    149a <balancer_ingress+0x149a>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    146f:	49 8b 84 24 08 11 00 	mov    0x1108(%r12),%rax
    1476:	00 
    1477:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    147e:	79 92 
        if (!lru_stats) {
    1480:	48 85 c0             	test   %rax,%rax
    1483:	0f 84 43 0a 00 00    	je     1ecc <balancer_ingress+0x1ecc>
        if (pckt.flags & F_SYN_SET) {
    1489:	8b 4c 24 3c          	mov    0x3c(%rsp),%ecx
    148d:	c1 e1 02             	shl    $0x2,%ecx
    1490:	f7 d1                	not    %ecx
    1492:	83 e1 08             	and    $0x8,%ecx
    1495:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
  struct real_pos_lru new_dst_lru = {};
    149a:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    14a1:	00 00 
    14a3:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    14aa:	00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    14ac:	49 8b 9c 24 10 11 00 	mov    0x1110(%r12),%rbx
    14b3:	00 
    14b4:	65 48 03 1c 25 28 50 	add    %gs:0xffffffff92795028,%rbx
    14bb:	79 92 
    14bd:	41 b6 01             	mov    $0x1,%r14b
  if (!conn_rate_stats) {
    14c0:	48 85 db             	test   %rbx,%rbx
    14c3:	74 26                	je     14eb <balancer_ingress+0x14eb>
    14c5:	48 c7 c0 30 d6 a9 8c 	mov    $0xffffffff8ca9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    14cc:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    14ce:	48 89 c1             	mov    %rax,%rcx
    14d1:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    14d5:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    14dc:	72 11                	jb     14ef <balancer_ingress+0x14ef>
    conn_rate_stats->v1 = 1;
    14de:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    14e5:	48 89 43 08          	mov    %rax,0x8(%rbx)
    14e9:	eb 17                	jmp    1502 <balancer_ingress+0x1502>
    14eb:	31 c0                	xor    %eax,%eax
    14ed:	eb 16                	jmp    1505 <balancer_ingress+0x1505>
    conn_rate_stats->v1 += 1;
    14ef:	48 8b 0b             	mov    (%rbx),%rcx
    14f2:	48 83 c1 01          	add    $0x1,%rcx
    14f6:	48 89 0b             	mov    %rcx,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    14f9:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    1500:	77 03                	ja     1505 <balancer_ingress+0x1505>
    1502:	45 31 f6             	xor    %r14d,%r14d
    1505:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    150a:	f6 01 08             	testb  $0x8,(%rcx)
    150d:	75 0b                	jne    151a <balancer_ingress+0x151a>
    150f:	ba f7 c0 ad e0       	mov    $0xe0adc0f7,%edx
    1514:	03 54 24 10          	add    0x10(%rsp),%edx
    1518:	eb 21                	jmp    153b <balancer_ingress+0x153b>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    151a:	0f b7 4c 24 32       	movzwl 0x32(%rsp),%ecx
    151f:	66 89 4c 24 30       	mov    %cx,0x30(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    1524:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    152b:	00 00 
    152d:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
    1534:	00 00 
    1536:	ba f7 c0 ad e0       	mov    $0xe0adc0f7,%edx
    153b:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  return c;
}

static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval) {
  a += initval;
  b += initval;
    1540:	03 74 24 30          	add    0x30(%rsp),%esi
  c += initval;
  __jhash_final(a, b, c);
    1544:	89 f1                	mov    %esi,%ecx
    1546:	81 f1 f7 c0 ad e0    	xor    $0xe0adc0f7,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    154c:	89 f7                	mov    %esi,%edi
    154e:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    1551:	29 f9                	sub    %edi,%ecx
    1553:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1555:	89 cf                	mov    %ecx,%edi
    1557:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    155a:	29 fa                	sub    %edi,%edx
    155c:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    155e:	89 d7                	mov    %edx,%edi
    1560:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    1563:	29 fe                	sub    %edi,%esi
    1565:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1567:	89 f7                	mov    %esi,%edi
    1569:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    156c:	29 f9                	sub    %edi,%ecx
    156e:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1570:	89 cf                	mov    %ecx,%edi
    1572:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1575:	29 fa                	sub    %edi,%edx
    1577:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1579:	c1 c2 0e             	rol    $0xe,%edx
  __jhash_final(a, b, c);
    157c:	29 d6                	sub    %edx,%esi
    157e:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1580:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    1583:	29 f1                	sub    %esi,%ecx
    1585:	ba 01 00 ff ff       	mov    $0xffff0001,%edx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    158a:	48 0f af d1          	imul   %rcx,%rdx
    158e:	48 c1 ea 30          	shr    $0x30,%rdx
    1592:	89 d6                	mov    %edx,%esi
    1594:	c1 e6 10             	shl    $0x10,%esi
    1597:	09 d6                	or     %edx,%esi
    1599:	29 f1                	sub    %esi,%ecx
    159b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    15a0:	8b 72 04             	mov    0x4(%rdx),%esi
    15a3:	89 f2                	mov    %esi,%edx
    15a5:	c1 e2 10             	shl    $0x10,%edx
    15a8:	01 f2                	add    %esi,%edx
    15aa:	01 ca                	add    %ecx,%edx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15ac:	81 fa ff 01 00 02    	cmp    $0x20001ff,%edx
    if (!real_pos) {
    15b2:	0f 87 14 09 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    15b8:	89 d1                	mov    %edx,%ecx
    15ba:	48 ba 00 20 89 62 00 	movabs $0xffffc90062892000,%rdx
    15c1:	c9 ff ff 
    key = *real_pos;
    15c4:	8b 9c ca 00 01 00 00 	mov    0x100(%rdx,%rcx,8),%ebx
    15cb:	48 85 db             	test   %rbx,%rbx
    if (key == 0) {
    15ce:	74 2b                	je     15fb <balancer_ingress+0x15fb>
  pckt->real_index = key;
    15d0:	89 5c 24 38          	mov    %ebx,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    15d4:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  if (!(*real)) {
    15da:	72 3e                	jb     161a <balancer_ingress+0x161a>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    15dc:	49 8b 84 24 48 11 00 	mov    0x1148(%r12),%rax
    15e3:	00 
    15e4:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    15eb:	79 92 
  if (!ch_drop_stats) {
    15ed:	48 85 c0             	test   %rax,%rax
    15f0:	0f 85 d2 08 00 00    	jne    1ec8 <balancer_ingress+0x1ec8>
    15f6:	e9 d1 08 00 00       	jmp    1ecc <balancer_ingress+0x1ecc>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    15fb:	49 8b 84 24 48 11 00 	mov    0x1148(%r12),%rax
    1602:	00 
    1603:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    160a:	79 92 
  if (!ch_drop_stats) {
    160c:	48 85 c0             	test   %rax,%rax
    160f:	0f 85 af 08 00 00    	jne    1ec4 <balancer_ingress+0x1ec4>
    1615:	e9 b2 08 00 00       	jmp    1ecc <balancer_ingress+0x1ecc>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    161a:	48 83 7c 24 70 00    	cmpq   $0x0,0x70(%rsp)
    1620:	74 15                	je     1637 <balancer_ingress+0x1637>
    1622:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
    1627:	8a 09                	mov    (%rcx),%cl
    1629:	80 e1 02             	and    $0x2,%cl
    162c:	d0 e9                	shr    %cl
    162e:	41 08 ce             	or     %cl,%r14b
    1631:	0f 84 33 01 00 00    	je     176a <balancer_ingress+0x176a>
    1637:	41 89 d8             	mov    %ebx,%r8d
    163a:	e9 5a 01 00 00       	jmp    1799 <balancer_ingress+0x1799>
    163f:	48 c7 c0 20 5c c3 8e 	mov    $0xffffffff8ec35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1646:	4c 89 ef             	mov    %r13,%rdi
    1649:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    164e:	ff d0                	call   *%rax
    1650:	85 c0                	test   %eax,%eax
    1652:	0f 85 74 08 00 00    	jne    1ecc <balancer_ingress+0x1ecc>
  data = (void*)(long)xdp->data;
    1658:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    165c:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1660:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1664:	48 39 ca             	cmp    %rcx,%rdx
    1667:	0f 87 5f 08 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    166d:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1671:	bd 01 00 00 00       	mov    $0x1,%ebp
    1676:	48 39 ca             	cmp    %rcx,%rdx
    1679:	0f b7 74 24 54       	movzwl 0x54(%rsp),%esi
    167e:	0f 87 4d 08 00 00    	ja     1ed1 <balancer_ingress+0x1ed1>
    1684:	48 b9 00 8c fd 57 81 	movabs $0xffff888157fd8c00,%rcx
    168b:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    168e:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1695:	66 89 50 04          	mov    %dx,0x4(%rax)
    1699:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    169f:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    16a1:	8b 48 28             	mov    0x28(%rax),%ecx
    16a4:	89 48 06             	mov    %ecx,0x6(%rax)
    16a7:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    16ab:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    16af:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    16b5:	0f b7 4c 24 30       	movzwl 0x30(%rsp),%ecx
  saddr[3] = src ^ port;
    16ba:	33 4c 24 10          	xor    0x10(%rsp),%ecx
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    16be:	8a 5c 24 3d          	mov    0x3d(%rsp),%bl
    __u32* saddr,
    __u32* daddr,
    __u16 payload_len,
    __u8 proto) {
  ip6h->version = 6;
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    16c2:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#ifdef COPY_INNER_PACKET_TOS
  ip6h->priority = (tc & 0xF0) >> 4;
    16c8:	89 da                	mov    %ebx,%edx
    16ca:	c0 ea 04             	shr    $0x4,%dl
    16cd:	80 ca 60             	or     $0x60,%dl
    16d0:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    16d3:	c0 e3 04             	shl    $0x4,%bl
    16d6:	88 58 0f             	mov    %bl,0xf(%rax)
#else
  ip6h->priority = DEFAULT_TOS;
#endif
  ip6h->nexthdr = proto;
    16d9:	66 c7 40 14 04 40    	movw   $0x4004,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    16df:	66 89 70 12          	mov    %si,0x12(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    16e3:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    16ea:	00 
    16eb:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    16f2:	89 48 22             	mov    %ecx,0x22(%rax)
    16f5:	e9 ba 08 00 00       	jmp    1fb4 <balancer_ingress+0x1fb4>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    16fa:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    16fe:	48 c1 e1 18          	shl    $0x18,%rcx
    1702:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    1706:	48 c1 e2 10          	shl    $0x10,%rdx
    170a:	48 09 ca             	or     %rcx,%rdx
    170d:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    1711:	48 c1 e1 08          	shl    $0x8,%rcx
    1715:	48 09 d1             	or     %rdx,%rcx
    1718:	8a 40 04             	mov    0x4(%rax),%al
    171b:	b2 03                	mov    $0x3,%dl
    171d:	eb 18                	jmp    1737 <balancer_ingress+0x1737>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    171f:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    1723:	48 c1 e2 10          	shl    $0x10,%rdx
    1727:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    172b:	48 c1 e1 08          	shl    $0x8,%rcx
    172f:	48 09 d1             	or     %rdx,%rcx
    1732:	8a 40 03             	mov    0x3(%rax),%al
    1735:	b2 02                	mov    $0x2,%dl
    1737:	0f b6 c0             	movzbl %al,%eax
    173a:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    173d:	85 c0                	test   %eax,%eax
    173f:	0f 8e a7 01 00 00    	jle    18ec <balancer_ingress+0x18ec>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1745:	80 fa 01             	cmp    $0x1,%dl
    1748:	0f 84 f9 00 00 00    	je     1847 <balancer_ingress+0x1847>
    174e:	80 fa 03             	cmp    $0x3,%dl
    1751:	0f 84 f7 00 00 00    	je     184e <balancer_ingress+0x184e>
    1757:	80 fa 02             	cmp    $0x2,%dl
    175a:	0f 85 f5 00 00 00    	jne    1855 <balancer_ingress+0x1855>
    1760:	b9 40 00 00 00       	mov    $0x40,%ecx
    1765:	e9 f0 00 00 00       	jmp    185a <balancer_ingress+0x185a>
    if (pckt->flow.proto == IPPROTO_UDP) {
    176a:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    176f:	75 05                	jne    1776 <balancer_ingress+0x1776>
      new_dst_lru.atime = cur_time;
    1771:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    new_dst_lru.pos = key;
    1776:	89 5c 24 40          	mov    %ebx,0x40(%rsp)
    177a:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    177f:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    1784:	48 c7 c0 c0 c9 a9 8c 	mov    $0xffffffff8ca9c9c0,%rax
    178b:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1790:	31 c9                	xor    %ecx,%ecx
    1792:	ff d0                	call   *%rax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    1794:	44 8b 44 24 38       	mov    0x38(%rsp),%r8d
    1799:	48 bf 00 84 fd 57 81 	movabs $0xffff888157fd8400,%rdi
    17a0:	88 ff ff 
    17a3:	8b 87 00 01 00 00    	mov    0x100(%rdi),%eax
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17a9:	0f b7 97 10 01 00 00 	movzwl 0x110(%rdi),%edx
    17b0:	0f b7 74 24 68       	movzwl 0x68(%rsp),%esi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17b5:	8a 4c 24 6a          	mov    0x6a(%rsp),%cl
    17b9:	88 8f 12 01 00 00    	mov    %cl,0x112(%rdi)
    17bf:	3b 44 24 58          	cmp    0x58(%rsp),%eax
  bool vip_match = address_match && port_match && proto_match;
    17c3:	75 40                	jne    1805 <balancer_ingress+0x1805>
    17c5:	66 39 f2             	cmp    %si,%dx
    17c8:	75 3b                	jne    1805 <balancer_ingress+0x1805>
    17ca:	84 c9                	test   %cl,%cl
    17cc:	74 37                	je     1805 <balancer_ingress+0x1805>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17ce:	41 81 f8 ff 0f 00 00 	cmp    $0xfff,%r8d
    17d5:	0f 87 f1 06 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    17db:	44 89 c0             	mov    %r8d,%eax
    17de:	48 b9 00 a0 3f 11 00 	movabs $0xffffc900113fa000,%rcx
    17e5:	c9 ff ff 
    17e8:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    17ef:	00 
    17f0:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    17f7:	79 92 
    if (!lru_miss_stat) {
    17f9:	48 85 c0             	test   %rax,%rax
    17fc:	0f 84 ca 06 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    *lru_miss_stat += 1;
    1802:	83 00 01             	addl   $0x1,(%rax)
    1805:	48 8d 04 5b          	lea    (%rbx,%rbx,2),%rax
    1809:	48 b9 00 90 b1 11 00 	movabs $0xffffc90011b19000,%rcx
    1810:	c9 ff ff 
    1813:	4c 8d 34 c1          	lea    (%rcx,%rax,8),%r14
    1817:	49 81 c6 00 01 00 00 	add    $0x100,%r14
      data_stats->v2 += 1;
    181e:	48 83 45 08 01       	addq   $0x1,0x8(%rbp)
    1823:	e9 db fa ff ff       	jmp    1303 <balancer_ingress+0x1303>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1828:	80 7b 05 08          	cmpb   $0x8,0x5(%rbx)
    182c:	0f 82 b5 f7 ff ff    	jb     fe7 <balancer_ingress+0xfe7>
    1832:	48 83 c3 06          	add    $0x6,%rbx
    1836:	48 89 d8             	mov    %rbx,%rax
  if (!connId) {
    1839:	48 85 c0             	test   %rax,%rax
    183c:	0f 85 ce f8 ff ff    	jne    1110 <balancer_ingress+0x1110>
    1842:	e9 a0 f7 ff ff       	jmp    fe7 <balancer_ingress+0xfe7>
    1847:	b9 38 00 00 00       	mov    $0x38,%ecx
    184c:	eb 0c                	jmp    185a <balancer_ingress+0x185a>
    184e:	b9 48 00 00 00       	mov    $0x48,%ecx
    1853:	eb 05                	jmp    185a <balancer_ingress+0x185a>
    1855:	b9 30 00 00 00       	mov    $0x30,%ecx
    185a:	48 83 44 0d 00 01    	addq   $0x1,0x0(%rbp,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1860:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    1865:	77 7a                	ja     18e1 <balancer_ingress+0x18e1>
    1867:	48 b9 00 50 89 72 00 	movabs $0xffffc90072895000,%rcx
    186e:	c9 ff ff 
          key = *real_pos;
    1871:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    1878:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    187b:	74 64                	je     18e1 <balancer_ingress+0x18e1>
            pckt.real_index = key;
    187d:	89 4c 24 38          	mov    %ecx,0x38(%rsp)
    1881:	45 31 f6             	xor    %r14d,%r14d
            dst = bpf_map_lookup_elem(&reals, &key);
    1884:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    188a:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    188e:	48 b9 00 90 b1 11 00 	movabs $0xffffc90011b19000,%rcx
    1895:	c9 ff ff 
    1898:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    189f:	00 
    18a0:	4c 0f 42 f0          	cmovb  %rax,%r14
            if (!dst) {
    18a4:	4d 85 f6             	test   %r14,%r14
    18a7:	0f 84 80 08 00 00    	je     212d <balancer_ingress+0x212d>
    18ad:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    18b2:	48 c7 c0 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rax
    18b9:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    18be:	ff d0                	call   *%rax
  if (dst_lru) {
    18c0:	48 85 c0             	test   %rax,%rax
    18c3:	0f 84 6e 08 00 00    	je     2137 <balancer_ingress+0x2137>
    if (dst_lru->pos == pckt->real_index) {
    18c9:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    18cd:	39 08                	cmp    %ecx,(%rax)
    18cf:	0f 85 60 09 00 00    	jne    2235 <balancer_ingress+0x2235>
              quic_packets_stats->dst_match_in_lru += 1;
    18d5:	48 89 e8             	mov    %rbp,%rax
    18d8:	48 83 c0 50          	add    $0x50,%rax
    18dc:	e9 ed 09 00 00       	jmp    22ce <balancer_ingress+0x22ce>
    18e1:	48 83 45 10 01       	addq   $0x1,0x10(%rbp)
    18e6:	48 98                	cltq
    18e8:	48 89 45 18          	mov    %rax,0x18(%rbp)
    18ec:	48 8b 14 24          	mov    (%rsp),%rdx
    18f0:	48 83 45 00 01       	addq   $0x1,0x0(%rbp)
  original_sport = pckt.flow.port16[0];
    18f5:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
    18fa:	89 44 24 70          	mov    %eax,0x70(%rsp)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    18fe:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    1903:	75 51                	jne    1956 <balancer_ingress+0x1956>
        !(vip_info->flags & F_LRU_BYPASS)) {
    1905:	f6 07 02             	testb  $0x2,(%rdi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1908:	75 4c                	jne    1956 <balancer_ingress+0x1956>
    190a:	49 89 ff             	mov    %rdi,%r15
    190d:	48 89 d3             	mov    %rdx,%rbx
    1910:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    1915:	48 c7 c0 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rax
    191c:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1921:	ff d0                	call   *%rax
  if (!dst_lru) {
    1923:	48 85 c0             	test   %rax,%rax
    1926:	74 29                	je     1951 <balancer_ingress+0x1951>
    1928:	48 89 c5             	mov    %rax,%rbp
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    192b:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1930:	75 2d                	jne    195f <balancer_ingress+0x195f>
    1932:	48 c7 c0 30 d6 a9 8c 	mov    $0xffffffff8ca9d630,%rax
    cur_time = bpf_ktime_get_ns();
    1939:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    193b:	48 89 c1             	mov    %rax,%rcx
    193e:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    1942:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    1949:	00 00 00 
    194c:	48 39 d1             	cmp    %rdx,%rcx
    194f:	76 0a                	jbe    195b <balancer_ingress+0x195b>
    1951:	45 31 f6             	xor    %r14d,%r14d
    1954:	eb 33                	jmp    1989 <balancer_ingress+0x1989>
    1956:	45 31 f6             	xor    %r14d,%r14d
    1959:	eb 34                	jmp    198f <balancer_ingress+0x198f>
    dst_lru->atime = cur_time;
    195b:	48 89 45 08          	mov    %rax,0x8(%rbp)
  key = dst_lru->pos;
    195f:	8b 45 00             	mov    0x0(%rbp),%eax
    1962:	45 31 f6             	xor    %r14d,%r14d
    1965:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    196b:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    196f:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    1973:	48 b9 00 90 b1 11 00 	movabs $0xffffc90011b19000,%rcx
    197a:	c9 ff ff 
    197d:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    1984:	00 
    1985:	4c 0f 42 f0          	cmovb  %rax,%r14
    1989:	48 89 da             	mov    %rbx,%rdx
    198c:	4c 89 ff             	mov    %r15,%rdi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    198f:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1994:	0f 85 c6 00 00 00    	jne    1a60 <balancer_ingress+0x1a60>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    199a:	f6 47 01 02          	testb  $0x2,0x1(%rdi)
    199e:	0f 84 bc 00 00 00    	je     1a60 <balancer_ingress+0x1a60>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    19a4:	49 8b ac 24 10 11 00 	mov    0x1110(%r12),%rbp
    19ab:	00 
    19ac:	65 48 03 2c 25 28 50 	add    %gs:0xffffffff92795028,%rbp
    19b3:	79 92 
  if (!conn_rate_stats) {
    19b5:	48 85 ed             	test   %rbp,%rbp
    19b8:	0f 84 a2 00 00 00    	je     1a60 <balancer_ingress+0x1a60>
    19be:	49 89 ff             	mov    %rdi,%r15
    19c1:	48 89 d3             	mov    %rdx,%rbx
    19c4:	48 c7 c0 30 d6 a9 8c 	mov    $0xffffffff8ca9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    19cb:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    19cd:	48 89 c1             	mov    %rax,%rcx
    19d0:	48 2b 4d 08          	sub    0x8(%rbp),%rcx
    19d4:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    19db:	72 0e                	jb     19eb <balancer_ingress+0x19eb>
    conn_rate_stats->v1 = 1;
    19dd:	48 c7 45 00 01 00 00 	movq   $0x1,0x0(%rbp)
    19e4:	00 
    conn_rate_stats->v2 = *cur_time;
    19e5:	48 89 45 08          	mov    %rax,0x8(%rbp)
    19e9:	eb 1a                	jmp    1a05 <balancer_ingress+0x1a05>
    conn_rate_stats->v1 += 1;
    19eb:	48 8b 45 00          	mov    0x0(%rbp),%rax
    19ef:	48 83 c0 01          	add    $0x1,%rax
    19f3:	48 89 45 00          	mov    %rax,0x0(%rbp)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    19f7:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    19fd:	48 89 da             	mov    %rbx,%rdx
    1a00:	4c 89 ff             	mov    %r15,%rdi
    1a03:	77 5b                	ja     1a60 <balancer_ingress+0x1a60>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    1a05:	48 bf 00 30 f3 48 81 	movabs $0xffff888148f33000,%rdi
    1a0c:	88 ff ff 
    1a0f:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
    1a14:	48 c7 c5 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rbp
    1a1b:	ff d5                	call   *%rbp
    1a1d:	4c 89 ff             	mov    %r15,%rdi
    1a20:	48 89 da             	mov    %rbx,%rdx
    if (down_reals_map) {
    1a23:	48 85 c0             	test   %rax,%rax
    1a26:	74 38                	je     1a60 <balancer_ingress+0x1a60>
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1a28:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
    1a2d:	48 89 c7             	mov    %rax,%rdi
    1a30:	ff d5                	call   *%rbp
    1a32:	4c 89 ff             	mov    %r15,%rdi
    1a35:	48 89 da             	mov    %rbx,%rdx
      if (down_real) {
    1a38:	48 85 c0             	test   %rax,%rax
    1a3b:	74 23                	je     1a60 <balancer_ingress+0x1a60>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1a3d:	49 8b 84 24 78 11 00 	mov    0x1178(%r12),%rax
    1a44:	00 
    1a45:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    1a4c:	79 92 
        if (stats_data) {
    1a4e:	48 85 c0             	test   %rax,%rax
    1a51:	0f 84 ec 01 00 00    	je     1c43 <balancer_ingress+0x1c43>
          stats_data->v1 += 1;
    1a57:	48 83 00 01          	addq   $0x1,(%rax)
    1a5b:	e9 e3 01 00 00       	jmp    1c43 <balancer_ingress+0x1c43>
    if (!dst) {
    1a60:	4d 85 f6             	test   %r14,%r14
    1a63:	0f 84 da 01 00 00    	je     1c43 <balancer_ingress+0x1c43>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1a69:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
    1a6f:	0f 87 57 04 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    1a75:	49 8b 8c d4 00 01 00 	mov    0x100(%r12,%rdx,8),%rcx
    1a7c:	00 
    1a7d:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
    1a84:	79 92 
  if (!data_stats) {
    1a86:	48 85 c9             	test   %rcx,%rcx
    1a89:	0f 84 3d 04 00 00    	je     1ecc <balancer_ingress+0x1ecc>
    1a8f:	8b 44 24 54          	mov    0x54(%rsp),%eax
    1a93:	66 c1 c0 08          	rol    $0x8,%ax
  data_stats->v1 += 1;
    1a97:	48 83 01 01          	addq   $0x1,(%rcx)
    1a9b:	41 89 c4             	mov    %eax,%r12d
  data_stats->v2 += pkt_bytes;
    1a9e:	0f b7 c0             	movzwl %ax,%eax
    1aa1:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1aa5:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    1aa9:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    1ab0:	0f 87 16 04 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    1ab6:	48 ba 00 80 23 11 00 	movabs $0xffffc90011238000,%rdx
    1abd:	c9 ff ff 
    1ac0:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
    1ac7:	00 
    1ac8:	65 48 03 0c 25 28 50 	add    %gs:0xffffffff92795028,%rcx
    1acf:	79 92 
  if (!data_stats) {
    1ad1:	48 85 c9             	test   %rcx,%rcx
    1ad4:	0f 84 f2 03 00 00    	je     1ecc <balancer_ingress+0x1ecc>
  data_stats->v1 += 1;
    1ada:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    1ade:	48 01 41 08          	add    %rax,0x8(%rcx)
    1ae2:	8b 44 24 70          	mov    0x70(%rsp),%eax
  pckt.flow.port16[0] = original_sport;
    1ae6:	66 89 44 24 30       	mov    %ax,0x30(%rsp)
  if (dst->flags & F_IPV6) {
    1aeb:	41 f6 46 10 01       	testb  $0x1,0x10(%r14)
    1af0:	0f 85 0f 04 00 00    	jne    1f05 <balancer_ingress+0x1f05>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1af6:	0f b7 5c 24 12       	movzwl 0x12(%rsp),%ebx
    1afb:	48 c7 c0 20 5c c3 8e 	mov    $0xffffffff8ec35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1b02:	4c 89 ef             	mov    %r13,%rdi
    1b05:	be ec ff ff ff       	mov    $0xffffffec,%esi
    1b0a:	ff d0                	call   *%rax
    1b0c:	85 c0                	test   %eax,%eax
    1b0e:	0f 85 b8 03 00 00    	jne    1ecc <balancer_ingress+0x1ecc>
  data = (void*)(long)xdp->data;
    1b14:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1b18:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  iph = data + sizeof(struct ethhdr);
    1b1c:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1b20:	48 39 ca             	cmp    %rcx,%rdx
    1b23:	0f 87 a3 03 00 00    	ja     1ecc <balancer_ingress+0x1ecc>
    1b29:	48 8d 50 22          	lea    0x22(%rax),%rdx
    1b2d:	bd 01 00 00 00       	mov    $0x1,%ebp
    1b32:	48 39 ca             	cmp    %rcx,%rdx
    1b35:	0f 87 96 03 00 00    	ja     1ed1 <balancer_ingress+0x1ed1>
    1b3b:	8b 4c 24 70          	mov    0x70(%rsp),%ecx
    1b3f:	66 c1 c1 08          	rol    $0x8,%cx
    1b43:	31 cb                	xor    %ecx,%ebx
    1b45:	c1 e3 10             	shl    $0x10,%ebx
    1b48:	8d bb ac 10 00 00    	lea    0x10ac(%rbx),%edi
    1b4e:	48 b9 00 8c fd 57 81 	movabs $0xffff888157fd8c00,%rcx
    1b55:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1b58:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    1b5f:	66 89 70 04          	mov    %si,0x4(%rax)
    1b63:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1b69:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1b6b:	8b 48 14             	mov    0x14(%rax),%ecx
    1b6e:	89 48 06             	mov    %ecx,0x6(%rax)
    1b71:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    1b75:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    1b79:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1b7f:	8a 54 24 3d          	mov    0x3d(%rsp),%dl
    1b83:	41 8b 0e             	mov    (%r14),%ecx
  iph->ihl = 5;
    1b86:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->tos = tos;
    1b8a:	88 50 0f             	mov    %dl,0xf(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1b8d:	41 83 c4 14          	add    $0x14,%r12d
    1b91:	66 41 c1 c4 08       	rol    $0x8,%r12w
    1b96:	66 44 89 60 10       	mov    %r12w,0x10(%rax)
  iph->id = 0;
    1b9b:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    1ba2:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    1ba5:	89 78 1a             	mov    %edi,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    1ba8:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    1bae:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    1bb2:	41 0f b7 f4          	movzwl %r12w,%esi
    1bb6:	0f b7 78 16          	movzwl 0x16(%rax),%edi
    1bba:	c1 eb 10             	shr    $0x10,%ebx
    1bbd:	48 01 f3             	add    %rsi,%rbx
    1bc0:	0f b7 f1             	movzwl %cx,%esi
    1bc3:	48 01 de             	add    %rbx,%rsi
    1bc6:	48 c1 e9 10          	shr    $0x10,%rcx
    1bca:	48 01 f1             	add    %rsi,%rcx
    1bcd:	48 01 d1             	add    %rdx,%rcx
    1bd0:	48 01 f9             	add    %rdi,%rcx
    1bd3:	48 81 c1 ac 10 00 00 	add    $0x10ac,%rcx
    1bda:	48 89 ca             	mov    %rcx,%rdx
    1bdd:	48 c1 ea 10          	shr    $0x10,%rdx
    1be1:	0f b7 f1             	movzwl %cx,%esi
    1be4:	48 01 d6             	add    %rdx,%rsi
    1be7:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
    1bee:	48 0f 42 f1          	cmovb  %rcx,%rsi
    1bf2:	48 89 f1             	mov    %rsi,%rcx
    1bf5:	48 c1 e9 10          	shr    $0x10,%rcx
    1bf9:	0f b7 d6             	movzwl %si,%edx
    1bfc:	48 01 ca             	add    %rcx,%rdx
    1bff:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    1c06:	48 0f 42 d6          	cmovb  %rsi,%rdx
    1c0a:	48 89 d1             	mov    %rdx,%rcx
    1c0d:	48 c1 e9 10          	shr    $0x10,%rcx
    1c11:	0f b7 f2             	movzwl %dx,%esi
    1c14:	48 01 ce             	add    %rcx,%rsi
    1c17:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
    1c1e:	48 0f 42 f2          	cmovb  %rdx,%rsi
    1c22:	89 f1                	mov    %esi,%ecx
    1c24:	c1 e9 10             	shr    $0x10,%ecx
    1c27:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    1c2e:	ba 00 00 01 00       	mov    $0x10000,%edx
    1c33:	0f 43 d1             	cmovae %ecx,%edx
    1c36:	01 f2                	add    %esi,%edx
    1c38:	f7 d2                	not    %edx
    1c3a:	66 89 50 18          	mov    %dx,0x18(%rax)
    1c3e:	e9 8e e7 ff ff       	jmp    3d1 <balancer_ingress+0x3d1>
      if (pckt.flow.proto == IPPROTO_TCP) {
    1c43:	80 7c 24 34 06       	cmpb   $0x6,0x34(%rsp)
    1c48:	75 2b                	jne    1c75 <balancer_ingress+0x1c75>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1c4a:	49 8b 84 24 08 11 00 	mov    0x1108(%r12),%rax
    1c51:	00 
    1c52:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    1c59:	79 92 
        if (!lru_stats) {
    1c5b:	48 85 c0             	test   %rax,%rax
    1c5e:	0f 84 68 02 00 00    	je     1ecc <balancer_ingress+0x1ecc>
        if (pckt.flags & F_SYN_SET) {
    1c64:	8b 4c 24 3c          	mov    0x3c(%rsp),%ecx
    1c68:	c1 e1 02             	shl    $0x2,%ecx
    1c6b:	f7 d1                	not    %ecx
    1c6d:	83 e1 08             	and    $0x8,%ecx
    1c70:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
    1c75:	48 89 14 24          	mov    %rdx,(%rsp)
  struct real_pos_lru new_dst_lru = {};
    1c79:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    1c80:	00 00 
    1c82:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    1c89:	00 00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1c8b:	49 8b 9c 24 10 11 00 	mov    0x1110(%r12),%rbx
    1c92:	00 
    1c93:	65 48 03 1c 25 28 50 	add    %gs:0xffffffff92795028,%rbx
    1c9a:	79 92 
    1c9c:	41 b6 01             	mov    $0x1,%r14b
  if (!conn_rate_stats) {
    1c9f:	48 85 db             	test   %rbx,%rbx
    1ca2:	74 29                	je     1ccd <balancer_ingress+0x1ccd>
    1ca4:	48 89 fd             	mov    %rdi,%rbp
    1ca7:	48 c7 c0 30 d6 a9 8c 	mov    $0xffffffff8ca9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1cae:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1cb0:	48 89 c1             	mov    %rax,%rcx
    1cb3:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1cb7:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1cbe:	72 11                	jb     1cd1 <balancer_ingress+0x1cd1>
    conn_rate_stats->v1 = 1;
    1cc0:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1cc7:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1ccb:	eb 17                	jmp    1ce4 <balancer_ingress+0x1ce4>
    1ccd:	31 c0                	xor    %eax,%eax
    1ccf:	eb 19                	jmp    1cea <balancer_ingress+0x1cea>
    conn_rate_stats->v1 += 1;
    1cd1:	48 8b 0b             	mov    (%rbx),%rcx
    1cd4:	48 83 c1 01          	add    $0x1,%rcx
    1cd8:	48 89 0b             	mov    %rcx,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1cdb:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    1ce2:	77 03                	ja     1ce7 <balancer_ingress+0x1ce7>
    1ce4:	45 31 f6             	xor    %r14d,%r14d
    1ce7:	48 89 ef             	mov    %rbp,%rdi
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1cea:	f6 07 08             	testb  $0x8,(%rdi)
    1ced:	75 25                	jne    1d14 <balancer_ingress+0x1d14>
    1cef:	49 89 ff             	mov    %rdi,%r15
    1cf2:	8b 54 24 10          	mov    0x10(%rsp),%edx
    b += *(u32*)(k + 4);
    1cf6:	8b 4c 24 14          	mov    0x14(%rsp),%ecx
    c += *(u32*)(k + 8);
    1cfa:	8b 74 24 18          	mov    0x18(%rsp),%esi
      a += (u32)k[3] << 24;
    1cfe:	40 8a 6c 24 1f       	mov    0x1f(%rsp),%bpl
      a += (u32)k[2] << 16;
    1d03:	44 8a 54 24 1e       	mov    0x1e(%rsp),%r10b
      a += (u32)k[1] << 8;
    1d08:	44 8a 4c 24 1d       	mov    0x1d(%rsp),%r9b
      a += k[0];
    1d0d:	44 8a 44 24 1c       	mov    0x1c(%rsp),%r8b
    1d12:	eb 30                	jmp    1d44 <balancer_ingress+0x1d44>
    1d14:	49 89 ff             	mov    %rdi,%r15
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1d17:	0f b7 4c 24 32       	movzwl 0x32(%rsp),%ecx
    1d1c:	66 89 4c 24 30       	mov    %cx,0x30(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    1d21:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    1d28:	00 00 
    1d2a:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
    1d31:	00 00 
    1d33:	45 31 c0             	xor    %r8d,%r8d
    1d36:	45 31 c9             	xor    %r9d,%r9d
    1d39:	45 31 d2             	xor    %r10d,%r10d
    1d3c:	31 ed                	xor    %ebp,%ebp
    1d3e:	31 f6                	xor    %esi,%esi
    1d40:	31 c9                	xor    %ecx,%ecx
    1d42:	31 d2                	xor    %edx,%edx
    c += *(u32*)(k + 8);
    1d44:	8d 9e ff c0 ad de    	lea    -0x21523f01(%rsi),%ebx
    __jhash_mix(a, b, c);
    1d4a:	29 f2                	sub    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1d4c:	c1 c3 04             	rol    $0x4,%ebx
    __jhash_mix(a, b, c);
    1d4f:	31 d3                	xor    %edx,%ebx
    b += *(u32*)(k + 4);
    1d51:	89 ca                	mov    %ecx,%edx
    1d53:	81 c2 ff c0 ad de    	add    $0xdeadc0ff,%edx
    __jhash_mix(a, b, c);
    1d59:	01 ce                	add    %ecx,%esi
    1d5b:	81 c6 fe 81 5b bd    	add    $0xbd5b81fe,%esi
    1d61:	29 da                	sub    %ebx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1d63:	89 df                	mov    %ebx,%edi
    1d65:	c1 c7 06             	rol    $0x6,%edi
    __jhash_mix(a, b, c);
    1d68:	31 d7                	xor    %edx,%edi
    1d6a:	01 f3                	add    %esi,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1d6c:	89 f9                	mov    %edi,%ecx
    1d6e:	c1 c1 08             	rol    $0x8,%ecx
    __jhash_mix(a, b, c);
    1d71:	29 fe                	sub    %edi,%esi
    1d73:	31 f1                	xor    %esi,%ecx
    1d75:	01 df                	add    %ebx,%edi
    1d77:	29 cb                	sub    %ecx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1d79:	89 ce                	mov    %ecx,%esi
    1d7b:	c1 c6 10             	rol    $0x10,%esi
    __jhash_mix(a, b, c);
    1d7e:	31 de                	xor    %ebx,%esi
    1d80:	01 f9                	add    %edi,%ecx
    1d82:	29 f7                	sub    %esi,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    1d84:	89 f3                	mov    %esi,%ebx
    1d86:	c1 c3 13             	rol    $0x13,%ebx
    __jhash_mix(a, b, c);
    1d89:	31 fb                	xor    %edi,%ebx
    1d8b:	01 ce                	add    %ecx,%esi
    1d8d:	29 d9                	sub    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1d8f:	41 89 db             	mov    %ebx,%r11d
    1d92:	41 c1 c3 04          	rol    $0x4,%r11d
    __jhash_mix(a, b, c);
    1d96:	01 f3                	add    %esi,%ebx
      a += (u32)k[3] << 24;
    1d98:	40 0f b6 d5          	movzbl %bpl,%edx
    1d9c:	c1 e2 18             	shl    $0x18,%edx
      a += (u32)k[2] << 16;
    1d9f:	41 0f b6 ea          	movzbl %r10b,%ebp
    1da3:	c1 e5 10             	shl    $0x10,%ebp
      a += (u32)k[3] << 24;
    1da6:	09 d5                	or     %edx,%ebp
      a += (u32)k[1] << 8;
    1da8:	41 0f b6 f9          	movzbl %r9b,%edi
    1dac:	c1 e7 08             	shl    $0x8,%edi
      a += (u32)k[2] << 16;
    1daf:	09 ef                	or     %ebp,%edi
      a += k[0];
    1db1:	41 0f b6 d0          	movzbl %r8b,%edx
      a += (u32)k[1] << 8;
    1db5:	09 fa                	or     %edi,%edx
      a += k[0];
    1db7:	01 f2                	add    %esi,%edx
    __jhash_mix(a, b, c);
    1db9:	31 d9                	xor    %ebx,%ecx
      __jhash_final(a, b, c);
    1dbb:	44 31 d9             	xor    %r11d,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1dbe:	89 de                	mov    %ebx,%esi
    1dc0:	c1 c6 0e             	rol    $0xe,%esi
      __jhash_final(a, b, c);
    1dc3:	29 f1                	sub    %esi,%ecx
    1dc5:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1dc7:	89 ce                	mov    %ecx,%esi
    1dc9:	c1 c6 0b             	rol    $0xb,%esi
      __jhash_final(a, b, c);
    1dcc:	29 f2                	sub    %esi,%edx
    1dce:	31 d3                	xor    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1dd0:	89 d6                	mov    %edx,%esi
    1dd2:	c1 c6 19             	rol    $0x19,%esi
      __jhash_final(a, b, c);
    1dd5:	29 f3                	sub    %esi,%ebx
    1dd7:	31 d9                	xor    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1dd9:	89 de                	mov    %ebx,%esi
    1ddb:	c1 c6 10             	rol    $0x10,%esi
      __jhash_final(a, b, c);
    1dde:	29 f1                	sub    %esi,%ecx
    1de0:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1de2:	89 ce                	mov    %ecx,%esi
    1de4:	c1 c6 04             	rol    $0x4,%esi
      __jhash_final(a, b, c);
    1de7:	29 f2                	sub    %esi,%edx
    1de9:	31 d3                	xor    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1deb:	c1 c2 0e             	rol    $0xe,%edx
      __jhash_final(a, b, c);
    1dee:	29 d3                	sub    %edx,%ebx
    1df0:	31 d9                	xor    %ebx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1df2:	c1 c3 18             	rol    $0x18,%ebx
  a += initval;
    1df5:	29 d9                	sub    %ebx,%ecx
    1df7:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  b += initval;
    1dfc:	03 74 24 30          	add    0x30(%rsp),%esi
  a += initval;
    1e00:	81 c1 f7 c0 ad e0    	add    $0xe0adc0f7,%ecx
  __jhash_final(a, b, c);
    1e06:	89 f2                	mov    %esi,%edx
    1e08:	81 f2 f7 c0 ad e0    	xor    $0xe0adc0f7,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e0e:	89 f7                	mov    %esi,%edi
    1e10:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    1e13:	29 fa                	sub    %edi,%edx
    1e15:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e17:	89 d7                	mov    %edx,%edi
    1e19:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    1e1c:	29 f9                	sub    %edi,%ecx
    1e1e:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1e20:	89 cf                	mov    %ecx,%edi
    1e22:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    1e25:	29 fe                	sub    %edi,%esi
    1e27:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e29:	89 f7                	mov    %esi,%edi
    1e2b:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    1e2e:	29 fa                	sub    %edi,%edx
    1e30:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1e32:	89 d7                	mov    %edx,%edi
    1e34:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1e37:	29 f9                	sub    %edi,%ecx
    1e39:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1e3b:	c1 c1 0e             	rol    $0xe,%ecx
  __jhash_final(a, b, c);
    1e3e:	29 ce                	sub    %ecx,%esi
    1e40:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1e42:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    1e45:	29 f2                	sub    %esi,%edx
    1e47:	b9 01 00 ff ff       	mov    $0xffff0001,%ecx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1e4c:	48 0f af ca          	imul   %rdx,%rcx
    1e50:	48 c1 e9 30          	shr    $0x30,%rcx
    1e54:	89 ce                	mov    %ecx,%esi
    1e56:	c1 e6 10             	shl    $0x10,%esi
    1e59:	09 ce                	or     %ecx,%esi
    1e5b:	29 f2                	sub    %esi,%edx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1e5d:	41 8b 77 04          	mov    0x4(%r15),%esi
    1e61:	89 f1                	mov    %esi,%ecx
    1e63:	c1 e1 10             	shl    $0x10,%ecx
    1e66:	01 f1                	add    %esi,%ecx
    1e68:	01 d1                	add    %edx,%ecx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1e6a:	81 f9 ff 01 00 02    	cmp    $0x20001ff,%ecx
    if (!real_pos) {
    1e70:	77 5a                	ja     1ecc <balancer_ingress+0x1ecc>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1e72:	89 c9                	mov    %ecx,%ecx
    1e74:	48 ba 00 20 89 62 00 	movabs $0xffffc90062892000,%rdx
    1e7b:	c9 ff ff 
    key = *real_pos;
    1e7e:	8b ac ca 00 01 00 00 	mov    0x100(%rdx,%rcx,8),%ebp
    1e85:	48 85 ed             	test   %rbp,%rbp
    if (key == 0) {
    1e88:	74 24                	je     1eae <balancer_ingress+0x1eae>
  pckt->real_index = key;
    1e8a:	89 6c 24 38          	mov    %ebp,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1e8e:	81 fd 00 10 00 00    	cmp    $0x1000,%ebp
  if (!(*real)) {
    1e94:	72 4f                	jb     1ee5 <balancer_ingress+0x1ee5>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1e96:	49 8b 84 24 48 11 00 	mov    0x1148(%r12),%rax
    1e9d:	00 
    1e9e:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    1ea5:	79 92 
  if (!ch_drop_stats) {
    1ea7:	48 85 c0             	test   %rax,%rax
    1eaa:	75 1c                	jne    1ec8 <balancer_ingress+0x1ec8>
    1eac:	eb 1e                	jmp    1ecc <balancer_ingress+0x1ecc>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1eae:	49 8b 84 24 48 11 00 	mov    0x1148(%r12),%rax
    1eb5:	00 
    1eb6:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    1ebd:	79 92 
  if (!ch_drop_stats) {
    1ebf:	48 85 c0             	test   %rax,%rax
    1ec2:	74 08                	je     1ecc <balancer_ingress+0x1ecc>
    1ec4:	48 83 c0 08          	add    $0x8,%rax
    1ec8:	48 83 00 01          	addq   $0x1,(%rax)
    1ecc:	bd 01 00 00 00       	mov    $0x1,%ebp
    return process_packet(ctx, nh_off, true);
  } else {
    // pass to tcp/ip stack
    return XDP_PASS;
  }
}
    1ed1:	89 e8                	mov    %ebp,%eax
    1ed3:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    1eda:	5b                   	pop    %rbx
    1edb:	41 5c                	pop    %r12
    1edd:	41 5d                	pop    %r13
    1edf:	41 5e                	pop    %r14
    1ee1:	41 5f                	pop    %r15
    1ee3:	5d                   	pop    %rbp
    1ee4:	c3                   	ret
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1ee5:	48 83 7c 24 08 00    	cmpq   $0x0,0x8(%rsp)
    1eeb:	74 11                	je     1efe <balancer_ingress+0x1efe>
    1eed:	41 8a 0f             	mov    (%r15),%cl
    1ef0:	80 e1 02             	and    $0x2,%cl
    1ef3:	d0 e9                	shr    %cl
    1ef5:	41 08 ce             	or     %cl,%r14b
    1ef8:	0f 84 ca 00 00 00    	je     1fc8 <balancer_ingress+0x1fc8>
    1efe:	89 e8                	mov    %ebp,%eax
    1f00:	e9 f1 00 00 00       	jmp    1ff6 <balancer_ingress+0x1ff6>
    1f05:	48 c7 c0 20 5c c3 8e 	mov    $0xffffffff8ec35c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1f0c:	4c 89 ef             	mov    %r13,%rdi
    1f0f:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1f14:	ff d0                	call   *%rax
    1f16:	85 c0                	test   %eax,%eax
    1f18:	75 b2                	jne    1ecc <balancer_ingress+0x1ecc>
  data = (void*)(long)xdp->data;
    1f1a:	49 8b 45 00          	mov    0x0(%r13),%rax
  data_end = (void*)(long)xdp->data_end;
    1f1e:	49 8b 4d 08          	mov    0x8(%r13),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1f22:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1f26:	48 39 ca             	cmp    %rcx,%rdx
    1f29:	77 a1                	ja     1ecc <balancer_ingress+0x1ecc>
    1f2b:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1f2f:	bd 01 00 00 00       	mov    $0x1,%ebp
    1f34:	48 39 ca             	cmp    %rcx,%rdx
    1f37:	77 98                	ja     1ed1 <balancer_ingress+0x1ed1>
    1f39:	48 b9 00 8c fd 57 81 	movabs $0xffff888157fd8c00,%rcx
    1f40:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1f43:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1f4a:	66 89 50 04          	mov    %dx,0x4(%rax)
    1f4e:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1f54:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1f56:	8b 48 28             	mov    0x28(%rax),%ecx
    1f59:	89 48 06             	mov    %ecx,0x6(%rax)
    1f5c:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    1f60:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    1f64:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    1f6a:	0f b7 74 24 30       	movzwl 0x30(%rsp),%esi
  saddr[3] = src ^ port;
    1f6f:	33 74 24 1c          	xor    0x1c(%rsp),%esi
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    1f73:	41 83 c4 28          	add    $0x28,%r12d
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1f77:	8a 4c 24 3d          	mov    0x3d(%rsp),%cl
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1f7b:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    1f81:	89 ca                	mov    %ecx,%edx
    1f83:	c0 ea 04             	shr    $0x4,%dl
    1f86:	80 ca 60             	or     $0x60,%dl
    1f89:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1f8c:	c0 e1 04             	shl    $0x4,%cl
    1f8f:	88 48 0f             	mov    %cl,0xf(%rax)
  ip6h->nexthdr = proto;
    1f92:	66 c7 40 14 29 40    	movw   $0x4029,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    1f98:	66 41 c1 c4 08       	rol    $0x8,%r12w
    1f9d:	66 44 89 60 12       	mov    %r12w,0x12(%rax)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    1fa2:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    1fa9:	00 
    1faa:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    1fb1:	89 70 22             	mov    %esi,0x22(%rax)
    1fb4:	49 8b 0e             	mov    (%r14),%rcx
    1fb7:	49 8b 56 08          	mov    0x8(%r14),%rdx
    1fbb:	48 89 48 26          	mov    %rcx,0x26(%rax)
    1fbf:	48 89 50 2e          	mov    %rdx,0x2e(%rax)
    1fc3:	e9 09 e4 ff ff       	jmp    3d1 <balancer_ingress+0x3d1>
    if (pckt->flow.proto == IPPROTO_UDP) {
    1fc8:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1fcd:	75 05                	jne    1fd4 <balancer_ingress+0x1fd4>
      new_dst_lru.atime = cur_time;
    1fcf:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
    new_dst_lru.pos = key;
    1fd4:	89 6c 24 40          	mov    %ebp,0x40(%rsp)
    1fd8:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    1fdd:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    1fe2:	48 c7 c0 c0 c9 a9 8c 	mov    $0xffffffff8ca9c9c0,%rax
    1fe9:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1fee:	31 c9                	xor    %ecx,%ecx
    1ff0:	ff d0                	call   *%rax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    1ff2:	8b 44 24 38          	mov    0x38(%rsp),%eax
    1ff6:	48 b9 00 84 fd 57 81 	movabs $0xffff888157fd8400,%rcx
    1ffd:	88 ff ff 
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    2000:	8b b1 00 01 00 00    	mov    0x100(%rcx),%esi
    2006:	b2 01                	mov    $0x1,%dl
    2008:	3b 74 24 58          	cmp    0x58(%rsp),%esi
    200c:	75 25                	jne    2033 <balancer_ingress+0x2033>
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    200e:	8b b1 04 01 00 00    	mov    0x104(%rcx),%esi
    2014:	3b 74 24 5c          	cmp    0x5c(%rsp),%esi
    2018:	75 19                	jne    2033 <balancer_ingress+0x2033>
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    201a:	8b b1 08 01 00 00    	mov    0x108(%rcx),%esi
    2020:	3b 74 24 60          	cmp    0x60(%rsp),%esi
    2024:	75 0d                	jne    2033 <balancer_ingress+0x2033>
    2026:	8b 91 0c 01 00 00    	mov    0x10c(%rcx),%edx
    202c:	3b 54 24 64          	cmp    0x64(%rsp),%edx
    2030:	0f 95 c2             	setne  %dl
  bool port_match = lru_miss_stat_vip->port == vip->port;
    2033:	0f b7 b1 10 01 00 00 	movzwl 0x110(%rcx),%esi
    203a:	0f b7 7c 24 68       	movzwl 0x68(%rsp),%edi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    203f:	8a 5c 24 6a          	mov    0x6a(%rsp),%bl
    2043:	88 99 12 01 00 00    	mov    %bl,0x112(%rcx)
  bool vip_match = address_match && port_match && proto_match;
    2049:	84 d2                	test   %dl,%dl
    204b:	75 3d                	jne    208a <balancer_ingress+0x208a>
    204d:	66 39 fe             	cmp    %di,%si
    2050:	75 38                	jne    208a <balancer_ingress+0x208a>
    2052:	84 db                	test   %bl,%bl
    2054:	74 34                	je     208a <balancer_ingress+0x208a>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    2056:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    205b:	0f 87 6b fe ff ff    	ja     1ecc <balancer_ingress+0x1ecc>
    2061:	89 c0                	mov    %eax,%eax
    2063:	48 b9 00 a0 3f 11 00 	movabs $0xffffc900113fa000,%rcx
    206a:	c9 ff ff 
    206d:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    2074:	00 
    2075:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    207c:	79 92 
    if (!lru_miss_stat) {
    207e:	48 85 c0             	test   %rax,%rax
    2081:	0f 84 45 fe ff ff    	je     1ecc <balancer_ingress+0x1ecc>
    *lru_miss_stat += 1;
    2087:	83 00 01             	addl   $0x1,(%rax)
    208a:	48 8d 04 6d 00 00 00 	lea    0x0(,%rbp,2),%rax
    2091:	00 
    2092:	48 01 e8             	add    %rbp,%rax
    2095:	48 b9 00 90 b1 11 00 	movabs $0xffffc90011b19000,%rcx
    209c:	c9 ff ff 
    209f:	4c 8d 34 c1          	lea    (%rcx,%rax,8),%r14
    20a3:	49 81 c6 00 01 00 00 	add    $0x100,%r14
    20aa:	48 8b 84 24 80 00 00 	mov    0x80(%rsp),%rax
    20b1:	00 
      data_stats->v2 += 1;
    20b2:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    20b7:	48 8b 14 24          	mov    (%rsp),%rdx
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    20bb:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
    20c1:	0f 86 ae f9 ff ff    	jbe    1a75 <balancer_ingress+0x1a75>
    20c7:	e9 00 fe ff ff       	jmp    1ecc <balancer_ingress+0x1ecc>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    20cc:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    20d0:	48 c1 e1 18          	shl    $0x18,%rcx
    20d4:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    20d8:	48 c1 e2 10          	shl    $0x10,%rdx
    20dc:	48 09 ca             	or     %rcx,%rdx
    20df:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    20e3:	48 c1 e1 08          	shl    $0x8,%rcx
    20e7:	48 09 d1             	or     %rdx,%rcx
    20ea:	8a 40 04             	mov    0x4(%rax),%al
    20ed:	b2 03                	mov    $0x3,%dl
    20ef:	eb 18                	jmp    2109 <balancer_ingress+0x2109>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    20f1:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    20f5:	48 c1 e2 10          	shl    $0x10,%rdx
    20f9:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    20fd:	48 c1 e1 08          	shl    $0x8,%rcx
    2101:	48 09 d1             	or     %rdx,%rcx
    2104:	8a 40 03             	mov    0x3(%rax),%al
    2107:	b2 02                	mov    $0x2,%dl
    2109:	0f b6 c0             	movzbl %al,%eax
    210c:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    210f:	85 c0                	test   %eax,%eax
    2111:	0f 8e d0 ee ff ff    	jle    fe7 <balancer_ingress+0xfe7>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    2117:	80 fa 01             	cmp    $0x1,%dl
    211a:	74 62                	je     217e <balancer_ingress+0x217e>
    211c:	80 fa 03             	cmp    $0x3,%dl
    211f:	74 64                	je     2185 <balancer_ingress+0x2185>
    2121:	80 fa 02             	cmp    $0x2,%dl
    2124:	75 66                	jne    218c <balancer_ingress+0x218c>
    2126:	b9 40 00 00 00       	mov    $0x40,%ecx
    212b:	eb 64                	jmp    2191 <balancer_ingress+0x2191>
              quic_packets_stats->cid_unknown_real_dropped += 1;
    212d:	48 83 45 28 01       	addq   $0x1,0x28(%rbp)
    2132:	e9 95 fd ff ff       	jmp    1ecc <balancer_ingress+0x1ecc>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2137:	49 8b 9c 24 10 11 00 	mov    0x1110(%r12),%rbx
    213e:	00 
    213f:	65 48 03 1c 25 28 50 	add    %gs:0xffffffff92795028,%rbx
    2146:	79 92 
  if (!conn_rate_stats) {
    2148:	48 85 db             	test   %rbx,%rbx
    214b:	0f 84 76 01 00 00    	je     22c7 <balancer_ingress+0x22c7>
    2151:	48 c7 c0 30 d6 a9 8c 	mov    $0xffffffff8ca9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    2158:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    215a:	48 89 c1             	mov    %rax,%rcx
    215d:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    2161:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    2168:	0f 82 13 01 00 00    	jb     2281 <balancer_ingress+0x2281>
    conn_rate_stats->v1 = 1;
    216e:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    2175:	48 89 43 08          	mov    %rax,0x8(%rbx)
    2179:	e9 15 01 00 00       	jmp    2293 <balancer_ingress+0x2293>
    217e:	b9 38 00 00 00       	mov    $0x38,%ecx
    2183:	eb 0c                	jmp    2191 <balancer_ingress+0x2191>
    2185:	b9 48 00 00 00       	mov    $0x48,%ecx
    218a:	eb 05                	jmp    2191 <balancer_ingress+0x2191>
    218c:	b9 30 00 00 00       	mov    $0x30,%ecx
    2191:	48 8b 14 24          	mov    (%rsp),%rdx
    2195:	48 83 04 0a 01       	addq   $0x1,(%rdx,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    219a:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    219f:	77 7b                	ja     221c <balancer_ingress+0x221c>
    21a1:	48 b9 00 50 89 72 00 	movabs $0xffffc90072895000,%rcx
    21a8:	c9 ff ff 
          key = *real_pos;
    21ab:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    21b2:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    21b5:	74 65                	je     221c <balancer_ingress+0x221c>
            pckt.real_index = key;
    21b7:	89 4c 24 38          	mov    %ecx,0x38(%rsp)
    21bb:	45 31 f6             	xor    %r14d,%r14d
            dst = bpf_map_lookup_elem(&reals, &key);
    21be:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    21c4:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    21c8:	48 b9 00 90 b1 11 00 	movabs $0xffffc90011b19000,%rcx
    21cf:	c9 ff ff 
    21d2:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    21d9:	00 
    21da:	4c 0f 42 f0          	cmovb  %rax,%r14
            if (!dst) {
    21de:	4d 85 f6             	test   %r14,%r14
    21e1:	0f 84 8c 00 00 00    	je     2273 <balancer_ingress+0x2273>
    21e7:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    21ec:	48 c7 c0 30 c9 a9 8c 	mov    $0xffffffff8ca9c930,%rax
    21f3:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    21f8:	ff d0                	call   *%rax
  if (dst_lru) {
    21fa:	48 85 c0             	test   %rax,%rax
    21fd:	0f 84 f2 00 00 00    	je     22f5 <balancer_ingress+0x22f5>
    if (dst_lru->pos == pckt->real_index) {
    2203:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    2207:	39 08                	cmp    %ecx,(%rax)
    2209:	0f 85 26 01 00 00    	jne    2335 <balancer_ingress+0x2335>
    220f:	48 8b 04 24          	mov    (%rsp),%rax
              quic_packets_stats->dst_match_in_lru += 1;
    2213:	48 83 c0 50          	add    $0x50,%rax
    2217:	e9 b1 01 00 00       	jmp    23cd <balancer_ingress+0x23cd>
    221c:	48 8b 0c 24          	mov    (%rsp),%rcx
    2220:	48 83 41 10 01       	addq   $0x1,0x10(%rcx)
    2225:	48 98                	cltq
    2227:	48 89 41 18          	mov    %rax,0x18(%rcx)
    222b:	48 8b 54 24 08       	mov    0x8(%rsp),%rdx
    2230:	e9 f2 ed ff ff       	jmp    1027 <balancer_ingress+0x1027>
      dst_lru->pos = pckt->real_index;
    2235:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    2237:	48 83 45 58 01       	addq   $0x1,0x58(%rbp)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    223c:	81 3c 24 ff 01 00 00 	cmpl   $0x1ff,(%rsp)
    2243:	0f 87 89 00 00 00    	ja     22d2 <balancer_ingress+0x22d2>
    2249:	48 b8 00 00 00 71 81 	movabs $0xffff888171000000,%rax
    2250:	88 ff ff 
    2253:	48 8b 0c 24          	mov    (%rsp),%rcx
    2257:	48 8b 84 c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rax
    225e:	00 
    225f:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    2266:	79 92 
  if (!per_vip_stats) {
    2268:	48 85 c0             	test   %rax,%rax
    226b:	74 65                	je     22d2 <balancer_ingress+0x22d2>
    per_vip_stats->v2 += 1;
    226d:	48 83 c0 08          	add    $0x8,%rax
    2271:	eb 5b                	jmp    22ce <balancer_ingress+0x22ce>
    2273:	48 8b 04 24          	mov    (%rsp),%rax
              quic_packets_stats->cid_unknown_real_dropped += 1;
    2277:	48 83 40 28 01       	addq   $0x1,0x28(%rax)
    227c:	e9 4b fc ff ff       	jmp    1ecc <balancer_ingress+0x1ecc>
    conn_rate_stats->v1 += 1;
    2281:	48 8b 03             	mov    (%rbx),%rax
    2284:	48 83 c0 01          	add    $0x1,%rax
    2288:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    228b:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    2291:	77 34                	ja     22c7 <balancer_ingress+0x22c7>
  struct real_pos_lru new_dst_lru = {};
    2293:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    229a:	00 00 
    229c:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    22a3:	00 00 
  new_dst_lru.pos = pckt->real_index;
    22a5:	8b 44 24 38          	mov    0x38(%rsp),%eax
    22a9:	89 44 24 40          	mov    %eax,0x40(%rsp)
    22ad:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    22b2:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    22b7:	48 c7 c0 c0 c9 a9 8c 	mov    $0xffffffff8ca9c9c0,%rax
    22be:	48 8b 7c 24 08       	mov    0x8(%rsp),%rdi
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    22c3:	31 c9                	xor    %ecx,%ecx
    22c5:	ff d0                	call   *%rax
              quic_packets_stats->dst_not_found_in_lru += 1;
    22c7:	48 89 e8             	mov    %rbp,%rax
    22ca:	48 83 c0 60          	add    $0x60,%rax
    22ce:	48 83 00 01          	addq   $0x1,(%rax)
            quic_packets_stats->cid_routed += 1;
    22d2:	48 83 45 20 01       	addq   $0x1,0x20(%rbp)
  original_sport = pckt.flow.port16[0];
    22d7:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
    22dc:	89 44 24 70          	mov    %eax,0x70(%rsp)
    22e0:	48 8b 14 24          	mov    (%rsp),%rdx
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    22e4:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
    22ea:	0f 86 85 f7 ff ff    	jbe    1a75 <balancer_ingress+0x1a75>
    22f0:	e9 d7 fb ff ff       	jmp    1ecc <balancer_ingress+0x1ecc>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    22f5:	49 8b 9c 24 10 11 00 	mov    0x1110(%r12),%rbx
    22fc:	00 
    22fd:	65 48 03 1c 25 28 50 	add    %gs:0xffffffff92795028,%rbx
    2304:	79 92 
  if (!conn_rate_stats) {
    2306:	48 85 db             	test   %rbx,%rbx
    2309:	0f 84 b6 00 00 00    	je     23c5 <balancer_ingress+0x23c5>
    230f:	48 c7 c0 30 d6 a9 8c 	mov    $0xffffffff8ca9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    2316:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    2318:	48 89 c1             	mov    %rax,%rcx
    231b:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    231f:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    2326:	72 57                	jb     237f <balancer_ingress+0x237f>
    conn_rate_stats->v1 = 1;
    2328:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    232f:	48 89 43 08          	mov    %rax,0x8(%rbx)
    2333:	eb 5c                	jmp    2391 <balancer_ingress+0x2391>
      dst_lru->pos = pckt->real_index;
    2335:	89 08                	mov    %ecx,(%rax)
    2337:	48 8b 04 24          	mov    (%rsp),%rax
              quic_packets_stats->dst_mismatch_in_lru += 1;
    233b:	48 83 40 58 01       	addq   $0x1,0x58(%rax)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    2340:	81 bc 24 80 00 00 00 	cmpl   $0x1ff,0x80(%rsp)
    2347:	ff 01 00 00 
    234b:	0f 87 80 00 00 00    	ja     23d1 <balancer_ingress+0x23d1>
    2351:	48 b8 00 00 00 71 81 	movabs $0xffff888171000000,%rax
    2358:	88 ff ff 
    235b:	48 8b 8c 24 80 00 00 	mov    0x80(%rsp),%rcx
    2362:	00 
    2363:	48 8b 84 c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rax
    236a:	00 
    236b:	65 48 03 04 25 28 50 	add    %gs:0xffffffff92795028,%rax
    2372:	79 92 
  if (!per_vip_stats) {
    2374:	48 85 c0             	test   %rax,%rax
    2377:	74 58                	je     23d1 <balancer_ingress+0x23d1>
    per_vip_stats->v2 += 1;
    2379:	48 83 c0 08          	add    $0x8,%rax
    237d:	eb 4e                	jmp    23cd <balancer_ingress+0x23cd>
    conn_rate_stats->v1 += 1;
    237f:	48 8b 03             	mov    (%rbx),%rax
    2382:	48 83 c0 01          	add    $0x1,%rax
    2386:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2389:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    238f:	77 34                	ja     23c5 <balancer_ingress+0x23c5>
  struct real_pos_lru new_dst_lru = {};
    2391:	48 c7 44 24 40 00 00 	movq   $0x0,0x40(%rsp)
    2398:	00 00 
    239a:	48 c7 44 24 48 00 00 	movq   $0x0,0x48(%rsp)
    23a1:	00 00 
  new_dst_lru.pos = pckt->real_index;
    23a3:	8b 44 24 38          	mov    0x38(%rsp),%eax
    23a7:	89 44 24 40          	mov    %eax,0x40(%rsp)
    23ab:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    23b0:	48 8d 54 24 40       	lea    0x40(%rsp),%rdx
    23b5:	48 c7 c0 c0 c9 a9 8c 	mov    $0xffffffff8ca9c9c0,%rax
    23bc:	48 8b 7c 24 70       	mov    0x70(%rsp),%rdi
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    23c1:	31 c9                	xor    %ecx,%ecx
    23c3:	ff d0                	call   *%rax
    23c5:	48 8b 04 24          	mov    (%rsp),%rax
              quic_packets_stats->dst_not_found_in_lru += 1;
    23c9:	48 83 c0 60          	add    $0x60,%rax
    23cd:	48 83 00 01          	addq   $0x1,(%rax)
    23d1:	48 8b 04 24          	mov    (%rsp),%rax
            quic_packets_stats->cid_routed += 1;
    23d5:	48 83 40 20 01       	addq   $0x1,0x20(%rax)
  original_sport = pckt.flow.port16[0];
    23da:	44 0f b7 7c 24 30    	movzwl 0x30(%rsp),%r15d
    23e0:	e9 1e ef ff ff       	jmp    1303 <balancer_ingress+0x1303>
