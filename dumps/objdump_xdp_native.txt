
bpf/native/balancer.bpf:     file format elf64-x86-64


Disassembly of section xdp:

0000000000000000 <balancer_ingress>:
  return XDP_TX;
}

SEC(PROG_SEC_NAME)
int balancer_ingress(struct xdp_md* ctx) {
  void* data = (void*)(long)ctx->data;
       0:	f3 0f 1e fa          	endbr64
       4:	55                   	push   %rbp
       5:	41 57                	push   %r15
       7:	41 56                	push   %r14
       9:	41 55                	push   %r13
       b:	41 54                	push   %r12
       d:	53                   	push   %rbx
       e:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
      15:	4c 8b 3f             	mov    (%rdi),%r15
  void* data_end = (void*)(long)ctx->data_end;
      18:	4c 8b 6f 08          	mov    0x8(%rdi),%r13
  struct ethhdr* eth = data;
  __u32 eth_proto;
  __u32 nh_off;
  nh_off = sizeof(struct ethhdr);

  if (data + nh_off > data_end) {
      1c:	49 8d 4f 0e          	lea    0xe(%r15),%rcx
      20:	b8 01 00 00 00       	mov    $0x1,%eax
      25:	4c 39 e9             	cmp    %r13,%rcx
      28:	0f 87 72 1f 00 00    	ja     1fa0 <balancer_ingress+0x1fa0>
    // bogus packet, len less than minimum ethernet frame size
    return XDP_DROP;
  }

  eth_proto = eth->h_proto; 
      2e:	41 0f b7 57 0c       	movzwl 0xc(%r15),%edx
      33:	81 fa 86 dd 00 00    	cmp    $0xdd86,%edx

  if (eth_proto == BE_ETH_P_IP) {
      39:	0f 84 19 01 00 00    	je     158 <balancer_ingress+0x158>
      3f:	b8 02 00 00 00       	mov    $0x2,%eax
      44:	83 fa 08             	cmp    $0x8,%edx
      47:	0f 85 53 1f 00 00    	jne    1fa0 <balancer_ingress+0x1fa0>
  struct packet_description pckt = {};
      4d:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
      54:	00 00 
      56:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
      5d:	00 00 
      5f:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
      66:	00 00 
      68:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
      6f:	00 00 
      71:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
      78:	00 00 
      7a:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
      81:	00 00 
  struct vip_definition vip = {};
      83:	c7 44 24 68 00 00 00 	movl   $0x0,0x68(%rsp)
      8a:	00 
      8b:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
      92:	00 00 
      94:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
      9b:	00 00 
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
    }
  } else {
    iph = data + nh_off;
    if (iph + 1 > data_end) {
      9d:	49 8d 5f 22          	lea    0x22(%r15),%rbx
      a1:	4c 39 eb             	cmp    %r13,%rbx
      a4:	0f 87 f1 1e 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
      return XDP_DROP;
    }
    // ihl contains len of ipv4 header in 32bit words
    if (iph->ihl != 5) {
      aa:	0f b6 01             	movzbl (%rcx),%eax
      ad:	24 0f                	and    $0xf,%al
      af:	3c 05                	cmp    $0x5,%al
      b1:	0f 85 e4 1e 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
      // if len of ipv4 hdr is not equal to 20bytes that means that header
      // contains ip options, and we dont support em
      return XDP_DROP;
    }
    pckt->tos = iph->tos;
      b7:	41 0f b6 47 0f       	movzbl 0xf(%r15),%eax
      bc:	88 44 24 3d          	mov    %al,0x3d(%rsp)
    *protocol = iph->protocol;
      c0:	41 0f b6 4f 17       	movzbl 0x17(%r15),%ecx
    pckt->flow.proto = *protocol;
      c5:	88 4c 24 34          	mov    %cl,0x34(%rsp)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;

    if (iph->frag_off & PCKT_FRAGMENTED) {
      c9:	41 0f b7 57 14       	movzwl 0x14(%r15),%edx
      ce:	f7 c2 3f ff 00 00    	test   $0xff3f,%edx
      d4:	0f 85 c1 1e 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
      da:	41 0f b7 6f 10       	movzwl 0x10(%r15),%ebp
      // we drop fragmented packets.
      return XDP_DROP;
    }
    if (*protocol == IPPROTO_ICMP) {
      df:	80 f9 01             	cmp    $0x1,%cl
      e2:	0f 85 3d 03 00 00    	jne    425 <balancer_ingress+0x425>
    __u64 off,
    struct packet_description* pckt) {
  struct icmphdr* icmp_hdr;
  struct iphdr* iph;
  icmp_hdr = data + off;
  if (icmp_hdr + 1 > data_end) {
      e8:	49 8d 47 2a          	lea    0x2a(%r15),%rax
      ec:	4c 39 e8             	cmp    %r13,%rax
      ef:	0f 87 a6 1e 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    return XDP_DROP;
  }
  if (icmp_hdr->type == ICMP_ECHO) {
      f5:	0f b6 0b             	movzbl (%rbx),%ecx
      f8:	83 f9 03             	cmp    $0x3,%ecx
      fb:	0f 84 a5 08 00 00    	je     9a6 <balancer_ingress+0x9a6>
     101:	b8 02 00 00 00       	mov    $0x2,%eax
     106:	83 f9 08             	cmp    $0x8,%ecx
     109:	0f 85 91 1e 00 00    	jne    1fa0 <balancer_ingress+0x1fa0>
  icmp_hdr->type = ICMP_ECHOREPLY;
     10f:	41 c6 47 22 00       	movb   $0x0,0x22(%r15)
  icmp_hdr->checksum += 0x0008;
     114:	66 41 83 47 24 08    	addw   $0x8,0x24(%r15)
     11a:	0f b7 f5             	movzwl %bp,%esi
  iph->ttl = DEFAULT_TTL;
     11d:	41 c6 47 16 40       	movb   $0x40,0x16(%r15)
     122:	41 8b 47 1a          	mov    0x1a(%r15),%eax
     126:	41 8b 4f 1e          	mov    0x1e(%r15),%ecx
  iph->daddr = iph->saddr;
     12a:	41 89 47 1e          	mov    %eax,0x1e(%r15)
  iph->saddr = tmp_addr;
     12e:	41 89 4f 1a          	mov    %ecx,0x1a(%r15)
    void* iph,
    __u64* csum) {
  __u16* next_iph_u16 = (__u16*)iph;
#pragma clang loop unroll(full)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    *csum += *next_iph_u16++;
     132:	41 0f b7 7f 0e       	movzwl 0xe(%r15),%edi
     137:	45 0f b7 47 12       	movzwl 0x12(%r15),%r8d
     13c:	49 01 f8             	add    %rdi,%r8
     13f:	49 01 f0             	add    %rsi,%r8
     142:	41 0f b7 77 16       	movzwl 0x16(%r15),%esi
     147:	48 01 f2             	add    %rsi,%rdx
     14a:	0f b7 f1             	movzwl %cx,%esi
     14d:	48 01 d6             	add    %rdx,%rsi
     150:	4c 01 c6             	add    %r8,%rsi
     153:	e9 d5 01 00 00       	jmp    32d <balancer_ingress+0x32d>
  struct packet_description pckt = {};
     158:	48 c7 44 24 38 00 00 	movq   $0x0,0x38(%rsp)
     15f:	00 00 
     161:	48 c7 44 24 30 00 00 	movq   $0x0,0x30(%rsp)
     168:	00 00 
     16a:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
     171:	00 00 
     173:	48 c7 44 24 20 00 00 	movq   $0x0,0x20(%rsp)
     17a:	00 00 
     17c:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
     183:	00 00 
     185:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
     18c:	00 00 
  struct vip_definition vip = {};
     18e:	c7 44 24 68 00 00 00 	movl   $0x0,0x68(%rsp)
     195:	00 
     196:	48 c7 44 24 60 00 00 	movq   $0x0,0x60(%rsp)
     19d:	00 00 
     19f:	48 c7 44 24 58 00 00 	movq   $0x0,0x58(%rsp)
     1a6:	00 00 
    if (ip6h + 1 > data_end) {
     1a8:	49 8d 5f 36          	lea    0x36(%r15),%rbx
     1ac:	4c 39 eb             	cmp    %r13,%rbx
     1af:	0f 87 eb 1d 00 00    	ja     1fa0 <balancer_ingress+0x1fa0>
    *protocol = ip6h->nexthdr;
     1b5:	41 0f b6 4f 14       	movzbl 0x14(%r15),%ecx
    pckt->flow.proto = *protocol;
     1ba:	88 4c 24 34          	mov    %cl,0x34(%rsp)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1be:	41 0f b6 47 0e       	movzbl 0xe(%r15),%eax
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1c3:	41 0f b6 57 0f       	movzbl 0xf(%r15),%edx
     1c8:	c0 ea 04             	shr    $0x4,%dl
     1cb:	c0 e0 04             	shl    $0x4,%al
     1ce:	08 d0                	or     %dl,%al
     1d0:	88 44 24 3d          	mov    %al,0x3d(%rsp)
    *protocol = ip6h->nexthdr;
     1d4:	83 f9 2c             	cmp    $0x2c,%ecx
    if (*protocol == IPPROTO_FRAGMENT) {
     1d7:	0f 84 be 1d 00 00    	je     1f9b <balancer_ingress+0x1f9b>
     1dd:	45 0f b7 67 12       	movzwl 0x12(%r15),%r12d
     1e2:	83 f9 3a             	cmp    $0x3a,%ecx
     1e5:	0f 85 a8 00 00 00    	jne    293 <balancer_ingress+0x293>
  if (icmp_hdr + 1 > data_end) {
     1eb:	49 8d 47 3e          	lea    0x3e(%r15),%rax
     1ef:	4c 39 e8             	cmp    %r13,%rax
     1f2:	0f 87 a3 1d 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1f8:	0f b6 0b             	movzbl (%rbx),%ecx
     1fb:	83 f9 01             	cmp    $0x1,%ecx
     1fe:	0f 84 0b 03 00 00    	je     50f <balancer_ingress+0x50f>
     204:	83 f9 02             	cmp    $0x2,%ecx
     207:	0f 84 ce 02 00 00    	je     4db <balancer_ingress+0x4db>
     20d:	b8 02 00 00 00       	mov    $0x2,%eax
     212:	81 f9 80 00 00 00    	cmp    $0x80,%ecx
     218:	0f 85 82 1d 00 00    	jne    1fa0 <balancer_ingress+0x1fa0>
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
     21e:	41 c6 47 36 81       	movb   $0x81,0x36(%r15)
  icmp_hdr->icmp6_cksum -= 0x0001;
     223:	66 41 ff 4f 38       	decw   0x38(%r15)
  ip6h->hop_limit = DEFAULT_TTL;
     228:	41 c6 47 15 40       	movb   $0x40,0x15(%r15)
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
     22d:	49 8b 47 16          	mov    0x16(%r15),%rax
     231:	49 8b 4f 1e          	mov    0x1e(%r15),%rcx
     235:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
     23a:	48 89 04 24          	mov    %rax,(%rsp)
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
     23e:	49 8b 47 26          	mov    0x26(%r15),%rax
     242:	49 8b 4f 2e          	mov    0x2e(%r15),%rcx
     246:	49 89 47 16          	mov    %rax,0x16(%r15)
     24a:	49 89 4f 1e          	mov    %rcx,0x1e(%r15)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
     24e:	48 8b 04 24          	mov    (%rsp),%rax
     252:	48 8b 4c 24 08       	mov    0x8(%rsp),%rcx
     257:	49 89 47 26          	mov    %rax,0x26(%r15)
     25b:	49 89 4f 2e          	mov    %rcx,0x2e(%r15)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     25f:	41 0f b7 47 0a       	movzwl 0xa(%r15),%eax
     264:	66 89 44 24 74       	mov    %ax,0x74(%rsp)
     269:	41 8b 47 06          	mov    0x6(%r15),%eax
     26d:	89 44 24 70          	mov    %eax,0x70(%rsp)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     271:	41 8b 07             	mov    (%r15),%eax
     274:	41 89 47 06          	mov    %eax,0x6(%r15)
     278:	41 0f b7 47 04       	movzwl 0x4(%r15),%eax
     27d:	66 41 89 47 0a       	mov    %ax,0xa(%r15)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     282:	8b 44 24 70          	mov    0x70(%rsp),%eax
     286:	41 89 07             	mov    %eax,(%r15)
     289:	0f b7 44 24 74       	movzwl 0x74(%rsp),%eax
     28e:	e9 2c 01 00 00       	jmp    3bf <balancer_ingress+0x3bf>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     293:	49 8b 47 16          	mov    0x16(%r15),%rax
     297:	49 8b 57 1e          	mov    0x1e(%r15),%rdx
     29b:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
     2a0:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2a5:	49 8b 47 26          	mov    0x26(%r15),%rax
     2a9:	49 8b 57 2e          	mov    0x2e(%r15),%rdx
     2ad:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
     2b2:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
    void* data,
    void* data_end,
    __u64 off,
    struct packet_description* pckt,
    __u8 protocol) {
  if (protocol == IPPROTO_ICMPV6) {
     2b7:	80 f9 01             	cmp    $0x1,%cl
     2ba:	0f 85 0e 01 00 00    	jne    3ce <balancer_ingress+0x3ce>
  if (icmp_hdr + 1 > data_end) {
     2c0:	49 8d 47 3e          	lea    0x3e(%r15),%rax
     2c4:	4c 39 e8             	cmp    %r13,%rax
     2c7:	0f 87 ce 1c 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
  if (icmp_hdr->type == ICMP_ECHO) {
     2cd:	0f b6 0b             	movzbl (%rbx),%ecx
     2d0:	83 f9 03             	cmp    $0x3,%ecx
     2d3:	0f 84 78 05 00 00    	je     851 <balancer_ingress+0x851>
     2d9:	b8 02 00 00 00       	mov    $0x2,%eax
     2de:	83 f9 08             	cmp    $0x8,%ecx
     2e1:	0f 85 b9 1c 00 00    	jne    1fa0 <balancer_ingress+0x1fa0>
  icmp_hdr->type = ICMP_ECHOREPLY;
     2e7:	41 c6 47 22 00       	movb   $0x0,0x22(%r15)
  icmp_hdr->checksum += 0x0008;
     2ec:	66 41 83 47 24 08    	addw   $0x8,0x24(%r15)
  iph->ttl = DEFAULT_TTL;
     2f2:	41 c6 47 16 40       	movb   $0x40,0x16(%r15)
     2f7:	41 8b 47 1a          	mov    0x1a(%r15),%eax
     2fb:	41 8b 4f 1e          	mov    0x1e(%r15),%ecx
  iph->daddr = iph->saddr;
     2ff:	41 89 47 1e          	mov    %eax,0x1e(%r15)
  iph->saddr = tmp_addr;
     303:	41 89 4f 1a          	mov    %ecx,0x1a(%r15)
     307:	41 0f b7 57 0e       	movzwl 0xe(%r15),%edx
     30c:	41 0f b7 77 10       	movzwl 0x10(%r15),%esi
     311:	48 01 d6             	add    %rdx,%rsi
     314:	41 0f b7 57 14       	movzwl 0x14(%r15),%edx
     319:	49 01 d4             	add    %rdx,%r12
     31c:	49 01 f4             	add    %rsi,%r12
     31f:	41 0f b7 57 16       	movzwl 0x16(%r15),%edx
     324:	0f b7 f1             	movzwl %cx,%esi
     327:	48 01 d6             	add    %rdx,%rsi
     32a:	4c 01 e6             	add    %r12,%rsi
     32d:	c1 e9 10             	shr    $0x10,%ecx
     330:	0f b7 d0             	movzwl %ax,%edx
     333:	48 01 ca             	add    %rcx,%rdx
     336:	c1 e8 10             	shr    $0x10,%eax
     339:	48 01 d0             	add    %rdx,%rax
     33c:	48 01 f0             	add    %rsi,%rax
    if (csum >> 16)
     33f:	48 89 c1             	mov    %rax,%rcx
     342:	48 c1 e9 10          	shr    $0x10,%rcx
     346:	0f b7 d0             	movzwl %ax,%edx
     349:	48 01 ca             	add    %rcx,%rdx
     34c:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
     352:	48 0f 42 d0          	cmovb  %rax,%rdx
     356:	48 89 d0             	mov    %rdx,%rax
     359:	48 c1 e8 10          	shr    $0x10,%rax
     35d:	0f b7 ca             	movzwl %dx,%ecx
     360:	48 01 c1             	add    %rax,%rcx
     363:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     36a:	48 0f 42 ca          	cmovb  %rdx,%rcx
     36e:	48 89 c8             	mov    %rcx,%rax
     371:	48 c1 e8 10          	shr    $0x10,%rax
     375:	0f b7 d1             	movzwl %cx,%edx
     378:	01 d0                	add    %edx,%eax
     37a:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
     381:	0f 42 c1             	cmovb  %ecx,%eax
     384:	89 c1                	mov    %eax,%ecx
     386:	c1 e9 10             	shr    $0x10,%ecx
     389:	01 c1                	add    %eax,%ecx
  return ~csum;
     38b:	f7 d1                	not    %ecx
  iph->check = csum;
     38d:	66 41 89 4f 18       	mov    %cx,0x18(%r15)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     392:	41 0f b7 47 0a       	movzwl 0xa(%r15),%eax
     397:	66 89 44 24 04       	mov    %ax,0x4(%rsp)
     39c:	41 8b 47 06          	mov    0x6(%r15),%eax
     3a0:	89 04 24             	mov    %eax,(%rsp)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     3a3:	41 8b 07             	mov    (%r15),%eax
     3a6:	41 89 47 06          	mov    %eax,0x6(%r15)
     3aa:	41 0f b7 47 04       	movzwl 0x4(%r15),%eax
     3af:	66 41 89 47 0a       	mov    %ax,0xa(%r15)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     3b4:	8b 04 24             	mov    (%rsp),%eax
     3b7:	41 89 07             	mov    %eax,(%r15)
     3ba:	0f b7 44 24 04       	movzwl 0x4(%rsp),%eax
     3bf:	66 41 89 47 04       	mov    %ax,0x4(%r15)
     3c4:	b8 03 00 00 00       	mov    $0x3,%eax
     3c9:	e9 d2 1b 00 00       	jmp    1fa0 <balancer_ingress+0x1fa0>
     3ce:	40 b6 02             	mov    $0x2,%sil
     3d1:	b2 01                	mov    $0x1,%dl
  if (protocol == IPPROTO_IPIP) {
     3d3:	44 0f b6 c1          	movzbl %cl,%r8d
     3d7:	b8 02 00 00 00       	mov    $0x2,%eax
     3dc:	41 83 f8 10          	cmp    $0x10,%r8d
     3e0:	0f 8f 80 01 00 00    	jg     566 <balancer_ingress+0x566>
     3e6:	41 83 f8 04          	cmp    $0x4,%r8d
     3ea:	0f 84 d5 02 00 00    	je     6c5 <balancer_ingress+0x6c5>
     3f0:	41 83 f8 06          	cmp    $0x6,%r8d
     3f4:	0f 85 a6 1b 00 00    	jne    1fa0 <balancer_ingress+0x1fa0>
  tcp = data + off;
     3fa:	49 8d 47 66          	lea    0x66(%r15),%rax
  if (is_ipv6) {
     3fe:	84 d2                	test   %dl,%dl
  tcp = data + off;
     400:	48 0f 45 c3          	cmovne %rbx,%rax
  if (tcp + 1 > data_end) {
     404:	4c 8d 40 14          	lea    0x14(%rax),%r8
     408:	4d 39 e8             	cmp    %r13,%r8
     40b:	0f 87 8a 1b 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
  if (tcp->syn) {
     411:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     415:	0f 84 1f 04 00 00    	je     83a <balancer_ingress+0x83a>
    pckt->flags |= F_SYN_SET;
     41b:	40 88 74 24 3c       	mov    %sil,0x3c(%rsp)
     420:	e9 15 04 00 00       	jmp    83a <balancer_ingress+0x83a>
      return FURTHER_PROCESSING;
    } else {
      pckt->flow.src = iph->saddr;
     425:	41 8b 47 1a          	mov    0x1a(%r15),%eax
     429:	89 44 24 10          	mov    %eax,0x10(%rsp)
      pckt->flow.dst = iph->daddr;
     42d:	41 8b 47 1e          	mov    0x1e(%r15),%eax
     431:	89 44 24 20          	mov    %eax,0x20(%rsp)
  if (protocol == IPPROTO_ICMPV6) {
     435:	80 f9 3a             	cmp    $0x3a,%cl
     438:	75 4a                	jne    484 <balancer_ingress+0x484>
  if (icmp_hdr + 1 > data_end) {
     43a:	49 8d 47 2a          	lea    0x2a(%r15),%rax
     43e:	4c 39 e8             	cmp    %r13,%rax
     441:	0f 87 54 1b 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     447:	0f b6 0b             	movzbl (%rbx),%ecx
     44a:	83 f9 01             	cmp    $0x1,%ecx
     44d:	0f 84 9a 07 00 00    	je     bed <balancer_ingress+0xbed>
     453:	83 f9 02             	cmp    $0x2,%ecx
     456:	0f 84 5d 07 00 00    	je     bb9 <balancer_ingress+0xbb9>
     45c:	b8 02 00 00 00       	mov    $0x2,%eax
     461:	81 f9 80 00 00 00    	cmp    $0x80,%ecx
     467:	0f 85 33 1b 00 00    	jne    1fa0 <balancer_ingress+0x1fa0>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     46d:	49 8d 4f 3e          	lea    0x3e(%r15),%rcx
     471:	b8 01 00 00 00       	mov    $0x1,%eax
       sizeof(struct icmp6hdr)) > data_end) {
     476:	4c 39 e9             	cmp    %r13,%rcx
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     479:	0f 87 21 1b 00 00    	ja     1fa0 <balancer_ingress+0x1fa0>
     47f:	e9 9a fd ff ff       	jmp    21e <balancer_ingress+0x21e>
     484:	40 b6 02             	mov    $0x2,%sil
     487:	b2 01                	mov    $0x1,%dl
     489:	44 0f b6 c1          	movzbl %cl,%r8d
     48d:	b8 02 00 00 00       	mov    $0x2,%eax
     492:	41 83 f8 10          	cmp    $0x10,%r8d
     496:	0f 8f aa 07 00 00    	jg     c46 <balancer_ingress+0xc46>
     49c:	41 83 f8 04          	cmp    $0x4,%r8d
     4a0:	0f 84 af 05 00 00    	je     a55 <balancer_ingress+0xa55>
     4a6:	41 83 f8 06          	cmp    $0x6,%r8d
     4aa:	0f 85 f0 1a 00 00    	jne    1fa0 <balancer_ingress+0x1fa0>
  tcp = data + off;
     4b0:	49 8d 47 3e          	lea    0x3e(%r15),%rax
  if (is_ipv6) {
     4b4:	84 d2                	test   %dl,%dl
  tcp = data + off;
     4b6:	48 0f 45 c3          	cmovne %rbx,%rax
  if (tcp + 1 > data_end) {
     4ba:	4c 8d 40 14          	lea    0x14(%rax),%r8
     4be:	4d 39 e8             	cmp    %r13,%r8
     4c1:	0f 87 d4 1a 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
  if (tcp->syn) {
     4c7:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     4cb:	0f 84 ff 08 00 00    	je     dd0 <balancer_ingress+0xdd0>
    pckt->flags |= F_SYN_SET;
     4d1:	40 88 74 24 3c       	mov    %sil,0x3c(%rsp)
     4d6:	e9 f5 08 00 00       	jmp    dd0 <balancer_ingress+0xdd0>
     4db:	48 b8 60 11 54 4c 81 	movabs $0xffff88814c541160,%rax
     4e2:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     4e5:	48 8b 00             	mov    (%rax),%rax
     4e8:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     4ef:	39 a6 
    if (!icmp_ptb_v6_stats) {
     4f1:	48 85 c0             	test   %rax,%rax
     4f4:	0f 84 a1 1a 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    icmp_ptb_v6_stats->v1 += 1;
     4fa:	48 ff 00             	incq   (%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4fd:	41 8b 4f 3a          	mov    0x3a(%r15),%ecx
     501:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     503:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     509:	77 04                	ja     50f <balancer_ingress+0x50f>
      icmp_ptb_v6_stats->v2 += 1;
     50b:	48 ff 40 08          	incq   0x8(%rax)
  if (ip6h + 1 > data_end) {
     50f:	49 8d 47 66          	lea    0x66(%r15),%rax
     513:	4c 39 e8             	cmp    %r13,%rax
     516:	0f 87 7f 1a 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
  pckt->flow.proto = ip6h->nexthdr;
     51c:	41 0f b6 4f 44       	movzbl 0x44(%r15),%ecx
     521:	88 4c 24 34          	mov    %cl,0x34(%rsp)
  pckt->flags |= F_ICMP;
     525:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     52a:	49 8b 47 56          	mov    0x56(%r15),%rax
     52e:	49 8b 57 5e          	mov    0x5e(%r15),%rdx
     532:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
     537:	48 89 54 24 18       	mov    %rdx,0x18(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     53c:	49 8b 47 46          	mov    0x46(%r15),%rax
     540:	49 8b 57 4e          	mov    0x4e(%r15),%rdx
     544:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
     549:	48 89 54 24 28       	mov    %rdx,0x28(%rsp)
     54e:	40 b6 03             	mov    $0x3,%sil
     551:	31 d2                	xor    %edx,%edx
     553:	44 0f b6 c1          	movzbl %cl,%r8d
     557:	b8 02 00 00 00       	mov    $0x2,%eax
     55c:	41 83 f8 10          	cmp    $0x10,%r8d
     560:	0f 8e 80 fe ff ff    	jle    3e6 <balancer_ingress+0x3e6>
     566:	41 83 f8 11          	cmp    $0x11,%r8d
     56a:	0f 84 b3 02 00 00    	je     823 <balancer_ingress+0x823>
     570:	41 83 f8 29          	cmp    $0x29,%r8d
     574:	0f 85 26 1a 00 00    	jne    1fa0 <balancer_ingress+0x1fa0>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     57a:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     57f:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     584:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
     589:	48 89 04 24          	mov    %rax,(%rsp)
#define BPF_MAP_OPS_INLINE(name, pref, ret_type, decl_args, type_args, func_params)	\
	__attribute__((__always_inline__)) static inline ret_type pref##bpf_##name decl_args {	\
		return ((ret_type (*) type_args) (access_ptr_at_u64(access_ptr_at_u64(map, BPF_MAP_OPS_OFF), name##_off))) func_params;	\
	}

BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
     58d:	48 b8 00 c0 d5 5b 81 	movabs $0xffff88815bd5c000,%rax
     594:	88 ff ff 
     597:	48 8b 08             	mov    (%rax),%rcx
     59a:	48 89 e6             	mov    %rsp,%rsi
     59d:	48 89 fb             	mov    %rdi,%rbx
     5a0:	48 89 c7             	mov    %rax,%rdi
     5a3:	ff 51 60             	call   *0x60(%rcx)
     5a6:	48 89 df             	mov    %rbx,%rdi
     5a9:	48 89 c3             	mov    %rax,%rbx
  if (decap_dst_flags) {
     5ac:	48 85 c0             	test   %rax,%rax
     5af:	74 22                	je     5d3 <balancer_ingress+0x5d3>
     5b1:	48 b8 30 11 54 4c 81 	movabs $0xffff88814c541130,%rax
     5b8:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     5bb:	48 8b 00             	mov    (%rax),%rax
     5be:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     5c5:	39 a6 
    if (!data_stats) {
     5c7:	48 85 c0             	test   %rax,%rax
     5ca:	0f 84 cb 19 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    data_stats->v1 += 1;
     5d0:	48 ff 00             	incq   (%rax)
decrement_ttl(void* data, void* data_end, int offset, bool is_ipv6) {
  struct iphdr* iph;
  struct ipv6hdr* ip6h;

  if (is_ipv6) {
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5d3:	49 8d 47 5e          	lea    0x5e(%r15),%rax
     5d7:	bd 01 00 00 00       	mov    $0x1,%ebp
     5dc:	4c 39 e8             	cmp    %r13,%rax
     5df:	77 10                	ja     5f1 <balancer_ingress+0x5f1>
      return XDP_DROP;
    }
    ip6h = (struct ipv6hdr*)(data + offset);
    if (!--ip6h->hop_limit) {
     5e1:	31 c0                	xor    %eax,%eax
     5e3:	41 fe 4f 3d          	decb   0x3d(%r15)
     5e7:	0f 94 c0             	sete   %al
     5ea:	8d 2c 45 ff ff ff ff 	lea    -0x1(,%rax,2),%ebp
decap_v6(struct xdp_md* xdp, void** data, void** data_end, bool inner_v4) {
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  old_eth = *data;
  new_eth = *data + sizeof(struct ipv6hdr);
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5f1:	41 0f b7 47 0a       	movzwl 0xa(%r15),%eax
     5f6:	66 41 89 47 32       	mov    %ax,0x32(%r15)
     5fb:	41 8b 47 06          	mov    0x6(%r15),%eax
     5ff:	41 89 47 2e          	mov    %eax,0x2e(%r15)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     603:	41 8b 07             	mov    (%r15),%eax
     606:	41 89 47 28          	mov    %eax,0x28(%r15)
     60a:	41 0f b7 47 04       	movzwl 0x4(%r15),%eax
     60f:	66 41 89 47 2c       	mov    %ax,0x2c(%r15)
  if (inner_v4) {
    new_eth->h_proto = BE_ETH_P_IP;
  } else {
    new_eth->h_proto = BE_ETH_P_IPV6;
     614:	66 41 c7 47 34 86 dd 	movw   $0xdd86,0x34(%r15)
     61b:	48 c7 c0 20 5c 83 a2 	mov    $0xffffffffa2835c20,%rax
  }
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     622:	be 28 00 00 00       	mov    $0x28,%esi
     627:	ff d0                	call   *%rax
     629:	85 c0                	test   %eax,%eax
     62b:	0f 85 6a 19 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
     631:	48 b8 50 11 54 4c 81 	movabs $0xffff88814c541150,%rax
     638:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     63b:	48 8b 08             	mov    (%rax),%rcx
     63e:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     645:	39 a6 
  if (!data_stats) {
     647:	48 85 c9             	test   %rcx,%rcx
     64a:	b8 01 00 00 00       	mov    $0x1,%eax
     64f:	0f 84 4b 19 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
    data_stats->v2 += 1;
     655:	48 ff 41 08          	incq   0x8(%rcx)
  if (action >= 0) {
     659:	85 ed                	test   %ebp,%ebp
     65b:	b8 02 00 00 00       	mov    $0x2,%eax
     660:	0f 49 c5             	cmovns %ebp,%eax
  if (decap_dst_flags) {
     663:	48 85 db             	test   %rbx,%rbx
  if (action >= 0) {
     666:	0f 84 34 19 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     66c:	85 ed                	test   %ebp,%ebp
     66e:	0f 89 2c 19 00 00    	jns    1fa0 <balancer_ingress+0x1fa0>
     674:	48 b8 70 11 54 4c 81 	movabs $0xffff88814c541170,%rax
     67b:	88 ff ff 
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     67e:	48 8b 00             	mov    (%rax),%rax
     681:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     688:	39 a6 
    if (xpop_stats_data) {
     68a:	48 85 c0             	test   %rax,%rax
     68d:	74 04                	je     693 <balancer_ingress+0x693>
        xpop_stats_data->v2 += 1; // IPv6 inner packets
     68f:	48 ff 40 08          	incq   0x8(%rax)
     693:	48 b8 00 25 98 07 81 	movabs $0xffff888107982500,%rax
     69a:	88 ff ff 
  bpf_tail_call(ctx, &subprograms, i);
     69d:	48 8b 08             	mov    (%rax),%rcx
     6a0:	b8 02 00 00 00       	mov    $0x2,%eax
     6a5:	48 85 c9             	test   %rcx,%rcx
     6a8:	0f 84 f2 18 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     6ae:	48 8b 41 30          	mov    0x30(%rcx),%rax
     6b2:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
     6b9:	5b                   	pop    %rbx
     6ba:	41 5c                	pop    %r12
     6bc:	41 5d                	pop    %r13
     6be:	41 5e                	pop    %r14
     6c0:	41 5f                	pop    %r15
     6c2:	5d                   	pop    %rbp
     6c3:	ff e0                	jmp    *%rax
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     6c5:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
     6ca:	48 8b 4c 24 28       	mov    0x28(%rsp),%rcx
     6cf:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
     6d4:	48 89 04 24          	mov    %rax,(%rsp)
     6d8:	48 b8 00 c0 d5 5b 81 	movabs $0xffff88815bd5c000,%rax
     6df:	88 ff ff 
     6e2:	48 8b 08             	mov    (%rax),%rcx
     6e5:	48 89 e6             	mov    %rsp,%rsi
     6e8:	48 89 fb             	mov    %rdi,%rbx
     6eb:	48 89 c7             	mov    %rax,%rdi
     6ee:	ff 51 60             	call   *0x60(%rcx)
     6f1:	48 89 df             	mov    %rbx,%rdi
     6f4:	48 89 c3             	mov    %rax,%rbx
  if (decap_dst_flags) {
     6f7:	48 85 c0             	test   %rax,%rax
     6fa:	74 22                	je     71e <balancer_ingress+0x71e>
     6fc:	48 b8 30 11 54 4c 81 	movabs $0xffff88814c541130,%rax
     703:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     706:	48 8b 00             	mov    (%rax),%rax
     709:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     710:	39 a6 
    if (!data_stats) {
     712:	48 85 c0             	test   %rax,%rax
     715:	0f 84 80 18 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    data_stats->v1 += 1;
     71b:	48 ff 00             	incq   (%rax)
      // ttl 0
      return XDP_DROP;
    }
  } else {
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     71e:	49 8d 47 4a          	lea    0x4a(%r15),%rax
     722:	bd 01 00 00 00       	mov    $0x1,%ebp
     727:	4c 39 e8             	cmp    %r13,%rax
     72a:	77 24                	ja     750 <balancer_ingress+0x750>
      return XDP_DROP;
    }
    iph = (struct iphdr*)(data + offset);
    __u32 csum;
    csum = iph->check + 0x0001;
     72c:	41 0f b7 47 40       	movzwl 0x40(%r15),%eax
     731:	8d 48 01             	lea    0x1(%rax),%ecx
    iph->check = (csum & 0xffff) + (csum >> 16);
     734:	c1 e9 10             	shr    $0x10,%ecx
     737:	01 c8                	add    %ecx,%eax
     739:	ff c0                	inc    %eax
     73b:	66 41 89 47 40       	mov    %ax,0x40(%r15)
    if (!--iph->ttl) {
     740:	31 c0                	xor    %eax,%eax
     742:	41 fe 4f 3e          	decb   0x3e(%r15)
     746:	0f 94 c0             	sete   %al
     749:	8d 2c 45 ff ff ff ff 	lea    -0x1(,%rax,2),%ebp
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     750:	41 0f b7 47 0a       	movzwl 0xa(%r15),%eax
     755:	66 41 89 47 32       	mov    %ax,0x32(%r15)
     75a:	41 8b 47 06          	mov    0x6(%r15),%eax
     75e:	41 89 47 2e          	mov    %eax,0x2e(%r15)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     762:	41 8b 07             	mov    (%r15),%eax
     765:	41 89 47 28          	mov    %eax,0x28(%r15)
     769:	41 0f b7 47 04       	movzwl 0x4(%r15),%eax
     76e:	66 41 89 47 2c       	mov    %ax,0x2c(%r15)
    new_eth->h_proto = BE_ETH_P_IP;
     773:	66 41 c7 47 34 08 00 	movw   $0x8,0x34(%r15)
     77a:	48 c7 c0 20 5c 83 a2 	mov    $0xffffffffa2835c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     781:	be 28 00 00 00       	mov    $0x28,%esi
     786:	ff d0                	call   *%rax
     788:	85 c0                	test   %eax,%eax
      if (!decap_v6(xdp, data, data_end, true)) {
     78a:	0f 85 0b 18 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
     790:	48 b8 50 11 54 4c 81 	movabs $0xffff88814c541150,%rax
     797:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     79a:	48 8b 08             	mov    (%rax),%rcx
     79d:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     7a4:	39 a6 
  if (!data_stats) {
     7a6:	48 85 c9             	test   %rcx,%rcx
     7a9:	b8 01 00 00 00       	mov    $0x1,%eax
     7ae:	0f 84 ec 17 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
    data_stats->v2 += 1;
     7b4:	48 ff 41 08          	incq   0x8(%rcx)
  if (action >= 0) {
     7b8:	85 ed                	test   %ebp,%ebp
     7ba:	b8 02 00 00 00       	mov    $0x2,%eax
     7bf:	0f 49 c5             	cmovns %ebp,%eax
  if (decap_dst_flags) {
     7c2:	48 85 db             	test   %rbx,%rbx
  if (action >= 0) {
     7c5:	0f 84 d5 17 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     7cb:	85 ed                	test   %ebp,%ebp
     7cd:	0f 89 cd 17 00 00    	jns    1fa0 <balancer_ingress+0x1fa0>
     7d3:	48 b8 70 11 54 4c 81 	movabs $0xffff88814c541170,%rax
     7da:	88 ff ff 
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     7dd:	48 8b 00             	mov    (%rax),%rax
     7e0:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     7e7:	39 a6 
    if (xpop_stats_data) {
     7e9:	48 85 c0             	test   %rax,%rax
     7ec:	74 03                	je     7f1 <balancer_ingress+0x7f1>
        xpop_stats_data->v1 += 1; // IPv4 inner packets
     7ee:	48 ff 00             	incq   (%rax)
     7f1:	48 b8 00 25 98 07 81 	movabs $0xffff888107982500,%rax
     7f8:	88 ff ff 
  bpf_tail_call(ctx, &subprograms, i);
     7fb:	48 8b 08             	mov    (%rax),%rcx
     7fe:	b8 02 00 00 00       	mov    $0x2,%eax
     803:	48 85 c9             	test   %rcx,%rcx
     806:	0f 84 94 17 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     80c:	48 8b 41 30          	mov    0x30(%rcx),%rax
     810:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
     817:	5b                   	pop    %rbx
     818:	41 5c                	pop    %r12
     81a:	41 5d                	pop    %r13
     81c:	41 5e                	pop    %r14
     81e:	41 5f                	pop    %r15
     820:	5d                   	pop    %rbp
     821:	ff e0                	jmp    *%rax
  udp = data + off;
     823:	49 8d 47 66          	lea    0x66(%r15),%rax
  if (is_ipv6) {
     827:	84 d2                	test   %dl,%dl
  udp = data + off;
     829:	48 0f 45 c3          	cmovne %rbx,%rax
  if (udp + 1 > data_end) {
     82d:	48 8d 70 08          	lea    0x8(%rax),%rsi
     831:	4c 39 ee             	cmp    %r13,%rsi
     834:	0f 87 61 17 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
     83a:	48 89 7c 24 50       	mov    %rdi,0x50(%rsp)
     83f:	84 d2                	test   %dl,%dl
     841:	74 7f                	je     8c2 <balancer_ingress+0x8c2>
     843:	0f b7 10             	movzwl (%rax),%edx
     846:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     84b:	0f b7 40 02          	movzwl 0x2(%rax),%eax
     84f:	eb 7d                	jmp    8ce <balancer_ingress+0x8ce>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     851:	41 80 7f 37 04       	cmpb   $0x4,0x37(%r15)
     856:	75 2d                	jne    885 <balancer_ingress+0x885>
     858:	48 b9 68 11 54 4c 81 	movabs $0xffff88814c541168,%rcx
     85f:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     862:	48 8b 09             	mov    (%rcx),%rcx
     865:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     86c:	39 a6 
    if (!icmp_ptb_v4_stats) {
     86e:	48 85 c9             	test   %rcx,%rcx
     871:	0f 84 24 17 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    icmp_ptb_v4_stats->v1 += 1;
     877:	48 ff 01             	incq   (%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     87a:	41 80 7f 3c 04       	cmpb   $0x4,0x3c(%r15)
     87f:	77 04                	ja     885 <balancer_ingress+0x885>
      icmp_ptb_v4_stats->v2 += 1;
     881:	48 ff 41 08          	incq   0x8(%rcx)
  if (iph + 1 > data_end) {
     885:	49 8d 4f 52          	lea    0x52(%r15),%rcx
     889:	4c 39 e9             	cmp    %r13,%rcx
     88c:	0f 87 09 17 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
  if (iph->ihl != 5) {
     892:	0f b6 00             	movzbl (%rax),%eax
     895:	24 0f                	and    $0xf,%al
     897:	3c 05                	cmp    $0x5,%al
     899:	0f 85 fc 16 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
  pckt->flow.proto = iph->protocol;
     89f:	41 0f b6 4f 47       	movzbl 0x47(%r15),%ecx
     8a4:	88 4c 24 34          	mov    %cl,0x34(%rsp)
  pckt->flags |= F_ICMP;
     8a8:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  pckt->flow.src = iph->daddr;
     8ad:	41 8b 47 4e          	mov    0x4e(%r15),%eax
     8b1:	89 44 24 10          	mov    %eax,0x10(%rsp)
  pckt->flow.dst = iph->saddr;
     8b5:	41 8b 47 4a          	mov    0x4a(%r15),%eax
     8b9:	89 44 24 20          	mov    %eax,0x20(%rsp)
     8bd:	e9 8c fc ff ff       	jmp    54e <balancer_ingress+0x54e>
     8c2:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     8c6:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     8cb:	0f b7 00             	movzwl (%rax),%eax
     8ce:	66 89 44 24 32       	mov    %ax,0x32(%rsp)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     8d3:	48 8b 54 24 20       	mov    0x20(%rsp),%rdx
     8d8:	48 8b 74 24 28       	mov    0x28(%rsp),%rsi
     8dd:	48 89 74 24 60       	mov    %rsi,0x60(%rsp)
     8e2:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  vip.port = pckt.flow.port16[1];
     8e7:	66 89 44 24 68       	mov    %ax,0x68(%rsp)
  vip.proto = pckt.flow.proto;
     8ec:	88 4c 24 6a          	mov    %cl,0x6a(%rsp)
     8f0:	49 be 00 c8 d5 5b 81 	movabs $0xffff88815bd5c800,%r14
     8f7:	88 ff ff 
     8fa:	49 8b 06             	mov    (%r14),%rax
     8fd:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
     902:	4c 89 f7             	mov    %r14,%rdi
     905:	ff 50 60             	call   *0x60(%rax)
  if (!vip_info) {
     908:	48 85 c0             	test   %rax,%rax
     90b:	0f 84 06 01 00 00    	je     a17 <balancer_ingress+0xa17>
  if (data_end - data > MAX_PCKT_SIZE) {
     911:	4c 89 e9             	mov    %r13,%rcx
     914:	4c 29 f9             	sub    %r15,%rcx
     917:	48 81 f9 ea 05 00 00 	cmp    $0x5ea,%rcx
     91e:	0f 8f 77 16 00 00    	jg     1f9b <balancer_ingress+0x1f9b>
     924:	48 b9 00 11 54 4c 81 	movabs $0xffff88814c541100,%rcx
     92b:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     92e:	48 8b 29             	mov    (%rcx),%rbp
     931:	65 48 03 2c 25 28 50 	add    %gs:0xffffffffa6395028,%rbp
     938:	39 a6 
  if (!data_stats) {
     93a:	48 85 ed             	test   %rbp,%rbp
     93d:	0f 84 58 16 00 00    	je     1f9b <balancer_ingress+0x1f9b>
  data_stats->v1 += 1;
     943:	48 ff 45 00          	incq   0x0(%rbp)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     947:	f6 00 01             	testb  $0x1,(%rax)
     94a:	74 07                	je     953 <balancer_ingress+0x953>
    pckt.flow.port16[0] = 0;
     94c:	66 c7 44 24 30 00 00 	movw   $0x0,0x30(%rsp)
  vip_num = vip_info->vip_num;
     953:	8b 70 04             	mov    0x4(%rax),%esi
     956:	48 c7 c1 34 50 39 a6 	mov    $0xffffffffa6395034,%rcx
  __u32 cpu_num = bpf_get_smp_processor_id();
     95d:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     964:	39 a6 
     966:	48 8b 09             	mov    (%rcx),%rcx
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     969:	f7 c1 80 ff ff ff    	test   $0xffffff80,%ecx
     96f:	0f 84 4f 05 00 00    	je     ec4 <balancer_ingress+0xec4>
     975:	48 b9 18 11 54 4c 81 	movabs $0xffff88814c541118,%rcx
     97c:	88 ff ff 
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     97f:	48 8b 09             	mov    (%rcx),%rcx
     982:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     989:	39 a6 
    if (!lru_stats) {
     98b:	48 85 c9             	test   %rcx,%rcx
     98e:	0f 84 07 16 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    lru_stats->v1 += 1;
     994:	48 ff 01             	incq   (%rcx)
     997:	48 bf 00 d0 d5 5b 81 	movabs $0xffff88815bd5d000,%rdi
     99e:	88 ff ff 
     9a1:	e9 38 05 00 00       	jmp    ede <balancer_ingress+0xede>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     9a6:	41 80 7f 23 04       	cmpb   $0x4,0x23(%r15)
     9ab:	75 2d                	jne    9da <balancer_ingress+0x9da>
     9ad:	48 b9 68 11 54 4c 81 	movabs $0xffff88814c541168,%rcx
     9b4:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     9b7:	48 8b 09             	mov    (%rcx),%rcx
     9ba:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     9c1:	39 a6 
    if (!icmp_ptb_v4_stats) {
     9c3:	48 85 c9             	test   %rcx,%rcx
     9c6:	0f 84 cf 15 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    icmp_ptb_v4_stats->v1 += 1;
     9cc:	48 ff 01             	incq   (%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     9cf:	41 80 7f 28 04       	cmpb   $0x4,0x28(%r15)
     9d4:	77 04                	ja     9da <balancer_ingress+0x9da>
      icmp_ptb_v4_stats->v2 += 1;
     9d6:	48 ff 41 08          	incq   0x8(%rcx)
  if (iph + 1 > data_end) {
     9da:	49 8d 4f 3e          	lea    0x3e(%r15),%rcx
     9de:	4c 39 e9             	cmp    %r13,%rcx
     9e1:	0f 87 b4 15 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
  if (iph->ihl != 5) {
     9e7:	0f b6 00             	movzbl (%rax),%eax
     9ea:	24 0f                	and    $0xf,%al
     9ec:	3c 05                	cmp    $0x5,%al
     9ee:	0f 85 a7 15 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
  pckt->flow.proto = iph->protocol;
     9f4:	41 0f b6 4f 33       	movzbl 0x33(%r15),%ecx
     9f9:	88 4c 24 34          	mov    %cl,0x34(%rsp)
  pckt->flags |= F_ICMP;
     9fd:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  pckt->flow.src = iph->daddr;
     a02:	41 8b 47 3a          	mov    0x3a(%r15),%eax
     a06:	89 44 24 10          	mov    %eax,0x10(%rsp)
  pckt->flow.dst = iph->saddr;
     a0a:	41 8b 47 36          	mov    0x36(%r15),%eax
     a0e:	89 44 24 20          	mov    %eax,0x20(%rsp)
     a12:	e9 17 02 00 00       	jmp    c2e <balancer_ingress+0xc2e>
    vip.port = 0;
     a17:	66 c7 44 24 68 00 00 	movw   $0x0,0x68(%rsp)
     a1e:	49 8b 06             	mov    (%r14),%rax
     a21:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
     a26:	4c 89 f7             	mov    %r14,%rdi
     a29:	ff 50 60             	call   *0x60(%rax)
     a2c:	48 89 c1             	mov    %rax,%rcx
    if (!vip_info) {
     a2f:	48 85 c0             	test   %rax,%rax
     a32:	b8 02 00 00 00       	mov    $0x2,%eax
     a37:	0f 84 63 15 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     a3d:	48 89 c8             	mov    %rcx,%rax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     a40:	f6 01 88             	testb  $0x88,(%rcx)
     a43:	0f 85 c8 fe ff ff    	jne    911 <balancer_ingress+0x911>
      pckt.flow.port16[1] = 0;
     a49:	66 c7 44 24 32 00 00 	movw   $0x0,0x32(%rsp)
     a50:	e9 bc fe ff ff       	jmp    911 <balancer_ingress+0x911>
  struct address dst_addr = {};
     a55:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
     a5c:	00 
     a5d:	48 c7 44 24 04 00 00 	movq   $0x0,0x4(%rsp)
     a64:	00 00 
    dst_addr.addr = pckt->flow.dst;
     a66:	8b 44 24 20          	mov    0x20(%rsp),%eax
     a6a:	89 04 24             	mov    %eax,(%rsp)
     a6d:	48 b8 00 c0 d5 5b 81 	movabs $0xffff88815bd5c000,%rax
     a74:	88 ff ff 
     a77:	48 8b 08             	mov    (%rax),%rcx
     a7a:	48 89 e6             	mov    %rsp,%rsi
     a7d:	48 89 fb             	mov    %rdi,%rbx
     a80:	48 89 c7             	mov    %rax,%rdi
     a83:	ff 51 60             	call   *0x60(%rcx)
     a86:	48 89 df             	mov    %rbx,%rdi
     a89:	48 89 c3             	mov    %rax,%rbx
  if (decap_dst_flags) {
     a8c:	48 85 c0             	test   %rax,%rax
     a8f:	74 22                	je     ab3 <balancer_ingress+0xab3>
     a91:	48 b8 30 11 54 4c 81 	movabs $0xffff88814c541130,%rax
     a98:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a9b:	48 8b 00             	mov    (%rax),%rax
     a9e:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     aa5:	39 a6 
    if (!data_stats) {
     aa7:	48 85 c0             	test   %rax,%rax
     aaa:	0f 84 eb 14 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    data_stats->v1 += 1;
     ab0:	48 ff 00             	incq   (%rax)
     ab3:	49 8d 47 14          	lea    0x14(%r15),%rax
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     ab7:	49 8d 4f 36          	lea    0x36(%r15),%rcx
     abb:	bd 01 00 00 00       	mov    $0x1,%ebp
     ac0:	4c 39 e9             	cmp    %r13,%rcx
     ac3:	77 24                	ja     ae9 <balancer_ingress+0xae9>
    csum = iph->check + 0x0001;
     ac5:	41 0f b7 4f 2c       	movzwl 0x2c(%r15),%ecx
     aca:	8d 51 01             	lea    0x1(%rcx),%edx
    iph->check = (csum & 0xffff) + (csum >> 16);
     acd:	c1 ea 10             	shr    $0x10,%edx
     ad0:	01 d1                	add    %edx,%ecx
     ad2:	ff c1                	inc    %ecx
     ad4:	66 41 89 4f 2c       	mov    %cx,0x2c(%r15)
    if (!--iph->ttl) {
     ad9:	31 c9                	xor    %ecx,%ecx
     adb:	41 fe 4f 2a          	decb   0x2a(%r15)
     adf:	0f 94 c1             	sete   %cl
     ae2:	8d 2c 4d ff ff ff ff 	lea    -0x1(,%rcx,2),%ebp
decap_v4(struct xdp_md* xdp, void** data, void** data_end) {
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  old_eth = *data;
  new_eth = *data + sizeof(struct iphdr);
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     ae9:	41 0f b7 4f 0a       	movzwl 0xa(%r15),%ecx
     aee:	66 41 89 4f 1e       	mov    %cx,0x1e(%r15)
     af3:	41 8b 4f 06          	mov    0x6(%r15),%ecx
     af7:	41 89 4f 1a          	mov    %ecx,0x1a(%r15)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     afb:	41 0f b7 4f 04       	movzwl 0x4(%r15),%ecx
     b00:	66 89 48 04          	mov    %cx,0x4(%rax)
     b04:	41 8b 0f             	mov    (%r15),%ecx
     b07:	89 08                	mov    %ecx,(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
     b09:	66 41 c7 47 20 08 00 	movw   $0x8,0x20(%r15)
     b10:	48 c7 c0 20 5c 83 a2 	mov    $0xffffffffa2835c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     b17:	be 14 00 00 00       	mov    $0x14,%esi
     b1c:	ff d0                	call   *%rax
     b1e:	85 c0                	test   %eax,%eax
     b20:	0f 85 75 14 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
     b26:	48 b8 50 11 54 4c 81 	movabs $0xffff88814c541150,%rax
     b2d:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b30:	48 8b 08             	mov    (%rax),%rcx
     b33:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     b3a:	39 a6 
  if (!data_stats) {
     b3c:	48 85 c9             	test   %rcx,%rcx
     b3f:	b8 01 00 00 00       	mov    $0x1,%eax
     b44:	0f 84 56 14 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
    data_stats->v2 += 1;
     b4a:	48 ff 41 08          	incq   0x8(%rcx)
  if (action >= 0) {
     b4e:	85 ed                	test   %ebp,%ebp
     b50:	b8 02 00 00 00       	mov    $0x2,%eax
     b55:	0f 49 c5             	cmovns %ebp,%eax
  if (decap_dst_flags) {
     b58:	48 85 db             	test   %rbx,%rbx
  if (action >= 0) {
     b5b:	0f 84 3f 14 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     b61:	85 ed                	test   %ebp,%ebp
     b63:	0f 89 37 14 00 00    	jns    1fa0 <balancer_ingress+0x1fa0>
     b69:	48 b8 70 11 54 4c 81 	movabs $0xffff88814c541170,%rax
     b70:	88 ff ff 
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b73:	48 8b 00             	mov    (%rax),%rax
     b76:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     b7d:	39 a6 
    if (xpop_stats_data) {
     b7f:	48 85 c0             	test   %rax,%rax
     b82:	74 03                	je     b87 <balancer_ingress+0xb87>
        xpop_stats_data->v1 += 1; // IPv4 inner packets
     b84:	48 ff 00             	incq   (%rax)
     b87:	48 b8 00 25 98 07 81 	movabs $0xffff888107982500,%rax
     b8e:	88 ff ff 
  bpf_tail_call(ctx, &subprograms, i);
     b91:	48 8b 08             	mov    (%rax),%rcx
     b94:	b8 02 00 00 00       	mov    $0x2,%eax
     b99:	48 85 c9             	test   %rcx,%rcx
     b9c:	0f 84 fe 13 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     ba2:	48 8b 41 30          	mov    0x30(%rcx),%rax
     ba6:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
     bad:	5b                   	pop    %rbx
     bae:	41 5c                	pop    %r12
     bb0:	41 5d                	pop    %r13
     bb2:	41 5e                	pop    %r14
     bb4:	41 5f                	pop    %r15
     bb6:	5d                   	pop    %rbp
     bb7:	ff e0                	jmp    *%rax
     bb9:	48 b8 60 11 54 4c 81 	movabs $0xffff88814c541160,%rax
     bc0:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     bc3:	48 8b 00             	mov    (%rax),%rax
     bc6:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     bcd:	39 a6 
    if (!icmp_ptb_v6_stats) {
     bcf:	48 85 c0             	test   %rax,%rax
     bd2:	0f 84 c3 13 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    icmp_ptb_v6_stats->v1 += 1;
     bd8:	48 ff 00             	incq   (%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     bdb:	41 8b 4f 26          	mov    0x26(%r15),%ecx
     bdf:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     be1:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     be7:	77 04                	ja     bed <balancer_ingress+0xbed>
      icmp_ptb_v6_stats->v2 += 1;
     be9:	48 ff 40 08          	incq   0x8(%rax)
  if (ip6h + 1 > data_end) {
     bed:	49 8d 47 52          	lea    0x52(%r15),%rax
     bf1:	4c 39 e8             	cmp    %r13,%rax
     bf4:	0f 87 a1 13 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
     bfa:	48 8d 44 24 20       	lea    0x20(%rsp),%rax
  pckt->flow.proto = ip6h->nexthdr;
     bff:	41 0f b6 4f 30       	movzbl 0x30(%r15),%ecx
     c04:	88 4c 24 34          	mov    %cl,0x34(%rsp)
  pckt->flags |= F_ICMP;
     c08:	c6 44 24 3c 01       	movb   $0x1,0x3c(%rsp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     c0d:	49 8b 57 42          	mov    0x42(%r15),%rdx
     c11:	49 8b 77 4a          	mov    0x4a(%r15),%rsi
     c15:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
     c1a:	48 89 54 24 10       	mov    %rdx,0x10(%rsp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     c1f:	49 8b 57 32          	mov    0x32(%r15),%rdx
     c23:	49 8b 77 3a          	mov    0x3a(%r15),%rsi
     c27:	48 89 10             	mov    %rdx,(%rax)
     c2a:	48 89 70 08          	mov    %rsi,0x8(%rax)
     c2e:	40 b6 03             	mov    $0x3,%sil
     c31:	31 d2                	xor    %edx,%edx
  if (protocol == IPPROTO_IPIP) {
     c33:	44 0f b6 c1          	movzbl %cl,%r8d
     c37:	b8 02 00 00 00       	mov    $0x2,%eax
     c3c:	41 83 f8 10          	cmp    $0x10,%r8d
     c40:	0f 8e 56 f8 ff ff    	jle    49c <balancer_ingress+0x49c>
     c46:	41 83 f8 11          	cmp    $0x11,%r8d
     c4a:	0f 84 69 01 00 00    	je     db9 <balancer_ingress+0xdb9>
     c50:	41 83 f8 29          	cmp    $0x29,%r8d
     c54:	0f 85 46 13 00 00    	jne    1fa0 <balancer_ingress+0x1fa0>
     c5a:	49 89 fe             	mov    %rdi,%r14
  struct address dst_addr = {};
     c5d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%rsp)
     c64:	00 
     c65:	48 c7 44 24 04 00 00 	movq   $0x0,0x4(%rsp)
     c6c:	00 00 
    dst_addr.addr = pckt->flow.dst;
     c6e:	8b 44 24 20          	mov    0x20(%rsp),%eax
     c72:	89 04 24             	mov    %eax,(%rsp)
     c75:	48 bf 00 c0 d5 5b 81 	movabs $0xffff88815bd5c000,%rdi
     c7c:	88 ff ff 
     c7f:	48 8b 07             	mov    (%rdi),%rax
     c82:	48 89 e6             	mov    %rsp,%rsi
     c85:	ff 50 60             	call   *0x60(%rax)
     c88:	48 89 c3             	mov    %rax,%rbx
  if (decap_dst_flags) {
     c8b:	48 85 c0             	test   %rax,%rax
     c8e:	74 22                	je     cb2 <balancer_ingress+0xcb2>
     c90:	48 b8 30 11 54 4c 81 	movabs $0xffff88814c541130,%rax
     c97:	88 ff ff 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c9a:	48 8b 00             	mov    (%rax),%rax
     c9d:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     ca4:	39 a6 
    if (!data_stats) {
     ca6:	48 85 c0             	test   %rax,%rax
     ca9:	0f 84 ec 12 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    data_stats->v1 += 1;
     caf:	48 ff 00             	incq   (%rax)
    if ((*data + offset) > *data_end) {
     cb2:	49 8d 4f 36          	lea    0x36(%r15),%rcx
     cb6:	b8 01 00 00 00       	mov    $0x1,%eax
     cbb:	4c 39 e9             	cmp    %r13,%rcx
     cbe:	0f 87 dc 12 00 00    	ja     1fa0 <balancer_ingress+0x1fa0>
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     cc4:	49 8d 47 5e          	lea    0x5e(%r15),%rax
     cc8:	bd 01 00 00 00       	mov    $0x1,%ebp
     ccd:	4c 39 e8             	cmp    %r13,%rax
     cd0:	77 10                	ja     ce2 <balancer_ingress+0xce2>
    if (!--ip6h->hop_limit) {
     cd2:	31 c0                	xor    %eax,%eax
     cd4:	41 fe 4f 3d          	decb   0x3d(%r15)
     cd8:	0f 94 c0             	sete   %al
     cdb:	8d 2c 45 ff ff ff ff 	lea    -0x1(,%rax,2),%ebp
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     ce2:	41 0f b7 47 0a       	movzwl 0xa(%r15),%eax
     ce7:	66 41 89 47 32       	mov    %ax,0x32(%r15)
     cec:	41 8b 47 06          	mov    0x6(%r15),%eax
     cf0:	41 89 47 2e          	mov    %eax,0x2e(%r15)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     cf4:	41 8b 07             	mov    (%r15),%eax
     cf7:	41 89 47 28          	mov    %eax,0x28(%r15)
     cfb:	41 0f b7 47 04       	movzwl 0x4(%r15),%eax
     d00:	66 41 89 47 2c       	mov    %ax,0x2c(%r15)
    new_eth->h_proto = BE_ETH_P_IPV6;
     d05:	66 41 c7 47 34 86 dd 	movw   $0xdd86,0x34(%r15)
     d0c:	48 c7 c0 20 5c 83 a2 	mov    $0xffffffffa2835c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     d13:	4c 89 f7             	mov    %r14,%rdi
     d16:	be 28 00 00 00       	mov    $0x28,%esi
     d1b:	ff d0                	call   *%rax
     d1d:	85 c0                	test   %eax,%eax
     d1f:	0f 85 76 12 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
     d25:	48 b8 50 11 54 4c 81 	movabs $0xffff88814c541150,%rax
     d2c:	88 ff ff 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     d2f:	48 8b 08             	mov    (%rax),%rcx
     d32:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     d39:	39 a6 
  if (!data_stats) {
     d3b:	48 85 c9             	test   %rcx,%rcx
     d3e:	b8 01 00 00 00       	mov    $0x1,%eax
     d43:	0f 84 57 12 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
    data_stats->v2 += 1;
     d49:	48 ff 41 08          	incq   0x8(%rcx)
  if (action >= 0) {
     d4d:	85 ed                	test   %ebp,%ebp
     d4f:	b8 02 00 00 00       	mov    $0x2,%eax
     d54:	0f 49 c5             	cmovns %ebp,%eax
  if (decap_dst_flags) {
     d57:	48 85 db             	test   %rbx,%rbx
  if (action >= 0) {
     d5a:	0f 84 40 12 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     d60:	85 ed                	test   %ebp,%ebp
     d62:	0f 89 38 12 00 00    	jns    1fa0 <balancer_ingress+0x1fa0>
     d68:	48 b8 70 11 54 4c 81 	movabs $0xffff88814c541170,%rax
     d6f:	88 ff ff 
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     d72:	48 8b 00             	mov    (%rax),%rax
     d75:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
     d7c:	39 a6 
    if (xpop_stats_data) {
     d7e:	48 85 c0             	test   %rax,%rax
     d81:	74 04                	je     d87 <balancer_ingress+0xd87>
        xpop_stats_data->v2 += 1; // IPv6 inner packets
     d83:	48 ff 40 08          	incq   0x8(%rax)
     d87:	48 b8 00 25 98 07 81 	movabs $0xffff888107982500,%rax
     d8e:	88 ff ff 
  bpf_tail_call(ctx, &subprograms, i);
     d91:	48 8b 08             	mov    (%rax),%rcx
     d94:	b8 02 00 00 00       	mov    $0x2,%eax
     d99:	48 85 c9             	test   %rcx,%rcx
     d9c:	0f 84 fe 11 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     da2:	48 8b 41 30          	mov    0x30(%rcx),%rax
     da6:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
     dad:	5b                   	pop    %rbx
     dae:	41 5c                	pop    %r12
     db0:	41 5d                	pop    %r13
     db2:	41 5e                	pop    %r14
     db4:	41 5f                	pop    %r15
     db6:	5d                   	pop    %rbp
     db7:	ff e0                	jmp    *%rax
  udp = data + off;
     db9:	49 8d 47 3e          	lea    0x3e(%r15),%rax
  if (is_ipv6) {
     dbd:	84 d2                	test   %dl,%dl
  udp = data + off;
     dbf:	48 0f 45 c3          	cmovne %rbx,%rax
  if (udp + 1 > data_end) {
     dc3:	48 8d 70 08          	lea    0x8(%rax),%rsi
     dc7:	4c 39 ee             	cmp    %r13,%rsi
     dca:	0f 87 cb 11 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
     dd0:	48 89 7c 24 50       	mov    %rdi,0x50(%rsp)
     dd5:	84 d2                	test   %dl,%dl
     dd7:	74 0e                	je     de7 <balancer_ingress+0xde7>
     dd9:	0f b7 10             	movzwl (%rax),%edx
     ddc:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     de1:	0f b7 40 02          	movzwl 0x2(%rax),%eax
     de5:	eb 0c                	jmp    df3 <balancer_ingress+0xdf3>
     de7:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     deb:	66 89 54 24 30       	mov    %dx,0x30(%rsp)
     df0:	0f b7 00             	movzwl (%rax),%eax
     df3:	66 89 44 24 32       	mov    %ax,0x32(%rsp)
    vip.vip = pckt.flow.dst;
     df8:	8b 54 24 20          	mov    0x20(%rsp),%edx
     dfc:	89 54 24 58          	mov    %edx,0x58(%rsp)
  vip.port = pckt.flow.port16[1];
     e00:	66 89 44 24 68       	mov    %ax,0x68(%rsp)
  vip.proto = pckt.flow.proto;
     e05:	88 4c 24 6a          	mov    %cl,0x6a(%rsp)
     e09:	49 be 00 c8 d5 5b 81 	movabs $0xffff88815bd5c800,%r14
     e10:	88 ff ff 
     e13:	49 8b 06             	mov    (%r14),%rax
     e16:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
     e1b:	4c 89 f7             	mov    %r14,%rdi
     e1e:	ff 50 60             	call   *0x60(%rax)
  if (!vip_info) {
     e21:	48 85 c0             	test   %rax,%rax
     e24:	0f 84 68 01 00 00    	je     f92 <balancer_ingress+0xf92>
  if (data_end - data > MAX_PCKT_SIZE) {
     e2a:	4c 89 e9             	mov    %r13,%rcx
     e2d:	4c 29 f9             	sub    %r15,%rcx
     e30:	48 81 f9 ea 05 00 00 	cmp    $0x5ea,%rcx
     e37:	0f 8f 5e 11 00 00    	jg     1f9b <balancer_ingress+0x1f9b>
     e3d:	48 b9 00 11 54 4c 81 	movabs $0xffff88814c541100,%rcx
     e44:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     e47:	4c 8b 21             	mov    (%rcx),%r12
     e4a:	65 4c 03 24 25 28 50 	add    %gs:0xffffffffa6395028,%r12
     e51:	39 a6 
  if (!data_stats) {
     e53:	4d 85 e4             	test   %r12,%r12
     e56:	0f 84 3f 11 00 00    	je     1f9b <balancer_ingress+0x1f9b>
  data_stats->v1 += 1;
     e5c:	49 ff 04 24          	incq   (%r12)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     e60:	f6 00 01             	testb  $0x1,(%rax)
     e63:	74 07                	je     e6c <balancer_ingress+0xe6c>
    pckt.flow.port16[0] = 0;
     e65:	66 c7 44 24 30 00 00 	movw   $0x0,0x30(%rsp)
  vip_num = vip_info->vip_num;
     e6c:	8b 70 04             	mov    0x4(%rax),%esi
     e6f:	48 c7 c1 34 50 39 a6 	mov    $0xffffffffa6395034,%rcx
  __u32 cpu_num = bpf_get_smp_processor_id();
     e76:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     e7d:	39 a6 
     e7f:	48 8b 09             	mov    (%rcx),%rcx
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e82:	f7 c1 80 ff ff ff    	test   $0xffffff80,%ecx
     e88:	0f 84 7e 01 00 00    	je     100c <balancer_ingress+0x100c>
     e8e:	48 b9 18 11 54 4c 81 	movabs $0xffff88814c541118,%rcx
     e95:	88 ff ff 
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e98:	48 8b 09             	mov    (%rcx),%rcx
     e9b:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
     ea2:	39 a6 
    if (!lru_stats) {
     ea4:	48 85 c9             	test   %rcx,%rcx
     ea7:	0f 84 ee 10 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    lru_stats->v1 += 1;
     ead:	48 ff 01             	incq   (%rcx)
     eb0:	48 b9 00 d0 d5 5b 81 	movabs $0xffff88815bd5d000,%rcx
     eb7:	88 ff ff 
     eba:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
     ebf:	e9 67 01 00 00       	jmp    102b <balancer_ingress+0x102b>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     ec4:	83 e1 7f             	and    $0x7f,%ecx
     ec7:	48 ba 00 31 5e 4c 81 	movabs $0xffff88814c5e3100,%rdx
     ece:	88 ff ff 
     ed1:	48 8b 3c ca          	mov    (%rdx,%rcx,8),%rdi
  if (!lru_map) {
     ed5:	48 85 ff             	test   %rdi,%rdi
     ed8:	0f 84 97 fa ff ff    	je     975 <balancer_ingress+0x975>
  if ((vip_info->flags & F_QUIC_VIP)) {
     ede:	f6 00 04             	testb  $0x4,(%rax)
     ee1:	0f 84 fd 03 00 00    	je     12e4 <balancer_ingress+0x12e4>
    bool is_icmp = (pckt.flags & F_ICMP);
     ee7:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
    if (is_icmp) {
     eec:	0f 85 de 00 00 00    	jne    fd0 <balancer_ingress+0xfd0>
     ef2:	48 b9 00 2d 98 07 81 	movabs $0xffff888107982d00,%rcx
     ef9:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     efc:	4c 8b 31             	mov    (%rcx),%r14
     eff:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffa6395028,%r14
     f06:	39 a6 
      if (!quic_packets_stats) {
     f08:	4d 85 f6             	test   %r14,%r14
     f0b:	0f 84 8a 10 00 00    	je     1f9b <balancer_ingress+0x1f9b>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     f11:	49 83 c7 66          	add    $0x66,%r15
  bool is_icmp = (pckt->flags & F_ICMP);
     f15:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     f1a:	4c 0f 44 fb          	cmove  %rbx,%r15
     f1e:	49 8d 57 09          	lea    0x9(%r15),%rdx
     f22:	4c 39 ea             	cmp    %r13,%rdx
     f25:	0f 87 b6 03 00 00    	ja     12e1 <balancer_ingress+0x12e1>
     f2b:	48 89 fb             	mov    %rdi,%rbx
     f2e:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     f33:	41 0f b6 4f 08       	movzbl 0x8(%r15),%ecx
     f38:	84 c9                	test   %cl,%cl
     f3a:	0f 88 e2 01 00 00    	js     1122 <balancer_ingress+0x1122>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     f40:	49 83 c7 11          	add    $0x11,%r15
     f44:	4d 39 ef             	cmp    %r13,%r15
     f47:	0f 87 8c 03 00 00    	ja     12d9 <balancer_ingress+0x12d9>
  if (!connId) {
     f4d:	48 85 d2             	test   %rdx,%rdx
     f50:	0f 84 83 03 00 00    	je     12d9 <balancer_ingress+0x12d9>
  __u8 connIdVersion = (connId[0] >> 6);
     f56:	0f b6 32             	movzbl (%rdx),%esi
     f59:	89 f1                	mov    %esi,%ecx
     f5b:	c1 e9 06             	shr    $0x6,%ecx
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     f5e:	83 f9 03             	cmp    $0x3,%ecx
     f61:	0f 84 9a 02 00 00    	je     1201 <balancer_ingress+0x1201>
     f67:	83 f9 02             	cmp    $0x2,%ecx
     f6a:	0f 84 7b 02 00 00    	je     11eb <balancer_ingress+0x11eb>
     f70:	83 f9 01             	cmp    $0x1,%ecx
     f73:	0f 85 60 03 00 00    	jne    12d9 <balancer_ingress+0x12d9>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     f79:	83 e6 3f             	and    $0x3f,%esi
     f7c:	c1 e6 0a             	shl    $0xa,%esi
     f7f:	0f b6 7a 01          	movzbl 0x1(%rdx),%edi
     f83:	8d 34 be             	lea    (%rsi,%rdi,4),%esi
     f86:	0f b6 52 02          	movzbl 0x2(%rdx),%edx
     f8a:	c0 ea 06             	shr    $0x6,%dl
     f8d:	e9 8c 02 00 00       	jmp    121e <balancer_ingress+0x121e>
    vip.port = 0;
     f92:	66 c7 44 24 68 00 00 	movw   $0x0,0x68(%rsp)
     f99:	49 8b 06             	mov    (%r14),%rax
     f9c:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
     fa1:	4c 89 f7             	mov    %r14,%rdi
     fa4:	ff 50 60             	call   *0x60(%rax)
     fa7:	48 89 c1             	mov    %rax,%rcx
    if (!vip_info) {
     faa:	48 85 c0             	test   %rax,%rax
     fad:	b8 02 00 00 00       	mov    $0x2,%eax
     fb2:	0f 84 e8 0f 00 00    	je     1fa0 <balancer_ingress+0x1fa0>
     fb8:	48 89 c8             	mov    %rcx,%rax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     fbb:	f6 01 88             	testb  $0x88,(%rcx)
     fbe:	0f 85 66 fe ff ff    	jne    e2a <balancer_ingress+0xe2a>
      pckt.flow.port16[1] = 0;
     fc4:	66 c7 44 24 32 00 00 	movw   $0x0,0x32(%rsp)
     fcb:	e9 5a fe ff ff       	jmp    e2a <balancer_ingress+0xe2a>
     fd0:	48 b9 58 11 54 4c 81 	movabs $0xffff88814c541158,%rcx
     fd7:	88 ff ff 
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fda:	4c 8b 31             	mov    (%rcx),%r14
     fdd:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffa6395028,%r14
     fe4:	39 a6 
      if (!data_stats) {
     fe6:	4d 85 f6             	test   %r14,%r14
     fe9:	0f 84 ac 0f 00 00    	je     1f9b <balancer_ingress+0x1f9b>
      data_stats->v1 += 1;
     fef:	49 ff 06             	incq   (%r14)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     ff2:	41 0f b6 4f 37       	movzbl 0x37(%r15),%ecx
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     ff7:	80 c1 fd             	add    $0xfd,%cl
     ffa:	80 f9 01             	cmp    $0x1,%cl
     ffd:	0f 87 e1 02 00 00    	ja     12e4 <balancer_ingress+0x12e4>
        data_stats->v2 += 1;
    1003:	49 83 c6 08          	add    $0x8,%r14
    1007:	e9 d5 02 00 00       	jmp    12e1 <balancer_ingress+0x12e1>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
    100c:	83 e1 7f             	and    $0x7f,%ecx
    100f:	48 ba 00 31 5e 4c 81 	movabs $0xffff88814c5e3100,%rdx
    1016:	88 ff ff 
    1019:	48 8b 0c ca          	mov    (%rdx,%rcx,8),%rcx
    101d:	48 89 4c 24 48       	mov    %rcx,0x48(%rsp)
  if (!lru_map) {
    1022:	48 85 c9             	test   %rcx,%rcx
    1025:	0f 84 63 fe ff ff    	je     e8e <balancer_ingress+0xe8e>
    102b:	48 89 74 24 78       	mov    %rsi,0x78(%rsp)
  if ((vip_info->flags & F_QUIC_VIP)) {
    1030:	f6 00 04             	testb  $0x4,(%rax)
    1033:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
    1038:	0f 84 0a 0a 00 00    	je     1a48 <balancer_ingress+0x1a48>
    bool is_icmp = (pckt.flags & F_ICMP);
    103e:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
    if (is_icmp) {
    1043:	0f 85 98 00 00 00    	jne    10e1 <balancer_ingress+0x10e1>
    1049:	48 b8 00 2d 98 07 81 	movabs $0xffff888107982d00,%rax
    1050:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
    1053:	4c 8b 30             	mov    (%rax),%r14
    1056:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffa6395028,%r14
    105d:	39 a6 
      if (!quic_packets_stats) {
    105f:	4d 85 f6             	test   %r14,%r14
    1062:	0f 84 33 0f 00 00    	je     1f9b <balancer_ingress+0x1f9b>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1068:	49 83 c7 3e          	add    $0x3e,%r15
  bool is_icmp = (pckt->flags & F_ICMP);
    106c:	f6 44 24 3c 01       	testb  $0x1,0x3c(%rsp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1071:	4c 0f 44 fb          	cmove  %rbx,%r15
    1075:	49 8d 4f 09          	lea    0x9(%r15),%rcx
    1079:	4c 39 e9             	cmp    %r13,%rcx
    107c:	0f 87 be 09 00 00    	ja     1a40 <balancer_ingress+0x1a40>
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    1082:	41 0f b6 47 08       	movzbl 0x8(%r15),%eax
    1087:	84 c0                	test   %al,%al
    1089:	0f 88 e6 00 00 00    	js     1175 <balancer_ingress+0x1175>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    108f:	49 83 c7 11          	add    $0x11,%r15
    1093:	4d 39 ef             	cmp    %r13,%r15
    1096:	0f 87 a4 09 00 00    	ja     1a40 <balancer_ingress+0x1a40>
  if (!connId) {
    109c:	48 85 c9             	test   %rcx,%rcx
    109f:	0f 84 9b 09 00 00    	je     1a40 <balancer_ingress+0x1a40>
  __u8 connIdVersion = (connId[0] >> 6);
    10a5:	0f b6 11             	movzbl (%rcx),%edx
    10a8:	89 d0                	mov    %edx,%eax
    10aa:	c1 e8 06             	shr    $0x6,%eax
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10ad:	83 f8 03             	cmp    $0x3,%eax
    10b0:	0f 84 b0 08 00 00    	je     1966 <balancer_ingress+0x1966>
    10b6:	83 f8 02             	cmp    $0x2,%eax
    10b9:	0f 84 91 08 00 00    	je     1950 <balancer_ingress+0x1950>
    10bf:	83 f8 01             	cmp    $0x1,%eax
    10c2:	0f 85 78 09 00 00    	jne    1a40 <balancer_ingress+0x1a40>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    10c8:	83 e2 3f             	and    $0x3f,%edx
    10cb:	c1 e2 0a             	shl    $0xa,%edx
    10ce:	0f b6 71 01          	movzbl 0x1(%rcx),%esi
    10d2:	8d 14 b2             	lea    (%rdx,%rsi,4),%edx
    10d5:	0f b6 49 02          	movzbl 0x2(%rcx),%ecx
    10d9:	c0 e9 06             	shr    $0x6,%cl
    10dc:	e9 a2 08 00 00       	jmp    1983 <balancer_ingress+0x1983>
    10e1:	48 b8 58 11 54 4c 81 	movabs $0xffff88814c541158,%rax
    10e8:	88 ff ff 
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    10eb:	4c 8b 30             	mov    (%rax),%r14
    10ee:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffa6395028,%r14
    10f5:	39 a6 
      if (!data_stats) {
    10f7:	4d 85 f6             	test   %r14,%r14
    10fa:	0f 84 9b 0e 00 00    	je     1f9b <balancer_ingress+0x1f9b>
      data_stats->v1 += 1;
    1100:	49 ff 06             	incq   (%r14)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    1103:	41 0f b6 47 23       	movzbl 0x23(%r15),%eax
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    1108:	83 c8 02             	or     $0x2,%eax
    110b:	83 f8 03             	cmp    $0x3,%eax
    110e:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    1113:	0f 85 2f 09 00 00    	jne    1a48 <balancer_ingress+0x1a48>
        data_stats->v2 += 1;
    1119:	49 83 c6 08          	add    $0x8,%r14
    111d:	e9 23 09 00 00       	jmp    1a45 <balancer_ingress+0x1a45>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1122:	49 8d 57 16          	lea    0x16(%r15),%rdx
    1126:	4c 39 ea             	cmp    %r13,%rdx
    1129:	0f 87 aa 01 00 00    	ja     12d9 <balancer_ingress+0x12d9>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    112f:	f6 c1 20             	test   $0x20,%cl
    1132:	0f 85 93 00 00 00    	jne    11cb <balancer_ingress+0x11cb>
        quic_packets_stats->cid_initial += 1;
    1138:	49 ff 46 08          	incq   0x8(%r14)
    113c:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1141:	81 fe ff 01 00 00    	cmp    $0x1ff,%esi
    1147:	48 89 df             	mov    %rbx,%rdi
    114a:	0f 87 94 01 00 00    	ja     12e4 <balancer_ingress+0x12e4>
    1150:	48 b9 00 41 54 6d 81 	movabs $0xffff88816d544100,%rcx
    1157:	88 ff ff 
    115a:	4c 8b 34 f1          	mov    (%rcx,%rsi,8),%r14
    115e:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffa6395028,%r14
    1165:	39 a6 
  if (!per_vip_stats) {
    1167:	4d 85 f6             	test   %r14,%r14
    116a:	0f 85 71 01 00 00    	jne    12e1 <balancer_ingress+0x12e1>
    1170:	e9 6f 01 00 00       	jmp    12e4 <balancer_ingress+0x12e4>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1175:	49 8d 4f 16          	lea    0x16(%r15),%rcx
    1179:	4c 39 e9             	cmp    %r13,%rcx
    117c:	0f 87 be 08 00 00    	ja     1a40 <balancer_ingress+0x1a40>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1182:	a8 20                	test   $0x20,%al
    1184:	0f 85 a6 07 00 00    	jne    1930 <balancer_ingress+0x1930>
        quic_packets_stats->cid_initial += 1;
    118a:	49 ff 46 08          	incq   0x8(%r14)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    118e:	81 7c 24 78 ff 01 00 	cmpl   $0x1ff,0x78(%rsp)
    1195:	00 
    1196:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    119b:	0f 87 a7 08 00 00    	ja     1a48 <balancer_ingress+0x1a48>
    11a1:	48 b9 00 41 54 6d 81 	movabs $0xffff88816d544100,%rcx
    11a8:	88 ff ff 
    11ab:	48 8b 54 24 78       	mov    0x78(%rsp),%rdx
    11b0:	4c 8b 34 d1          	mov    (%rcx,%rdx,8),%r14
    11b4:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffa6395028,%r14
    11bb:	39 a6 
  if (!per_vip_stats) {
    11bd:	4d 85 f6             	test   %r14,%r14
    11c0:	0f 85 7f 08 00 00    	jne    1a45 <balancer_ingress+0x1a45>
    11c6:	e9 7d 08 00 00       	jmp    1a48 <balancer_ingress+0x1a48>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    11cb:	41 80 7f 0d 07       	cmpb   $0x7,0xd(%r15)
    11d0:	0f 86 03 01 00 00    	jbe    12d9 <balancer_ingress+0x12d9>
    11d6:	49 83 c7 0e          	add    $0xe,%r15
    11da:	4c 89 fa             	mov    %r15,%rdx
  if (!connId) {
    11dd:	48 85 d2             	test   %rdx,%rdx
    11e0:	0f 85 70 fd ff ff    	jne    f56 <balancer_ingress+0xf56>
    11e6:	e9 ee 00 00 00       	jmp    12d9 <balancer_ingress+0x12d9>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    11eb:	0f b6 7a 01          	movzbl 0x1(%rdx),%edi
    11ef:	c1 e7 10             	shl    $0x10,%edi
    11f2:	0f b6 72 02          	movzbl 0x2(%rdx),%esi
    11f6:	c1 e6 08             	shl    $0x8,%esi
    11f9:	09 fe                	or     %edi,%esi
    11fb:	0f b6 52 03          	movzbl 0x3(%rdx),%edx
    11ff:	eb 1d                	jmp    121e <balancer_ingress+0x121e>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1201:	0f b6 72 01          	movzbl 0x1(%rdx),%esi
    1205:	c1 e6 18             	shl    $0x18,%esi
    1208:	0f b6 7a 02          	movzbl 0x2(%rdx),%edi
    120c:	c1 e7 10             	shl    $0x10,%edi
    120f:	09 f7                	or     %esi,%edi
    1211:	0f b6 72 03          	movzbl 0x3(%rdx),%esi
    1215:	c1 e6 08             	shl    $0x8,%esi
    1218:	09 fe                	or     %edi,%esi
    121a:	0f b6 52 04          	movzbl 0x4(%rdx),%edx
    121e:	0f b6 d2             	movzbl %dl,%edx
    1221:	48 09 f2             	or     %rsi,%rdx
      if (qpr.server_id > 0) {
    1224:	85 d2                	test   %edx,%edx
    1226:	0f 8e ad 00 00 00    	jle    12d9 <balancer_ingress+0x12d9>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    122c:	48 83 f9 03          	cmp    $0x3,%rcx
    1230:	74 16                	je     1248 <balancer_ingress+0x1248>
    1232:	83 f9 02             	cmp    $0x2,%ecx
    1235:	74 0b                	je     1242 <balancer_ingress+0x1242>
    1237:	83 f9 01             	cmp    $0x1,%ecx
    123a:	75 12                	jne    124e <balancer_ingress+0x124e>
    quic_packets_stats->cid_v1 += 1;
    123c:	49 8d 4e 38          	lea    0x38(%r14),%rcx
    1240:	eb 10                	jmp    1252 <balancer_ingress+0x1252>
    quic_packets_stats->cid_v2 += 1;
    1242:	49 8d 4e 40          	lea    0x40(%r14),%rcx
    1246:	eb 0a                	jmp    1252 <balancer_ingress+0x1252>
    quic_packets_stats->cid_v3 += 1;
    1248:	49 8d 4e 48          	lea    0x48(%r14),%rcx
    124c:	eb 04                	jmp    1252 <balancer_ingress+0x1252>
    quic_packets_stats->cid_v0 += 1;
    124e:	49 8d 4e 30          	lea    0x30(%r14),%rcx
    1252:	48 ff 01             	incq   (%rcx)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1255:	81 fa fd ff ff 00    	cmp    $0xfffffd,%edx
        if (real_pos) {
    125b:	77 74                	ja     12d1 <balancer_ingress+0x12d1>
    125d:	48 b9 00 91 6e 18 00 	movabs $0xffffc900186e9100,%rcx
    1264:	c9 ff ff 
    1267:	48 8d 0c d1          	lea    (%rcx,%rdx,8),%rcx
    126b:	48 85 c9             	test   %rcx,%rcx
    126e:	74 61                	je     12d1 <balancer_ingress+0x12d1>
          key = *real_pos;
    1270:	8b 09                	mov    (%rcx),%ecx
    1272:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    1275:	74 5a                	je     12d1 <balancer_ingress+0x12d1>
            pckt.real_index = key;
    1277:	89 4c 24 38          	mov    %ecx,0x38(%rsp)
            dst = bpf_map_lookup_elem(&reals, &key);
    127b:	81 f9 ff 0f 00 00    	cmp    $0xfff,%ecx
            if (!dst) {
    1281:	0f 87 a8 07 00 00    	ja     1a2f <balancer_ingress+0x1a2f>
    1287:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    128b:	48 b9 00 b1 6b 18 00 	movabs $0xffffc900186bb100,%rcx
    1292:	c9 ff ff 
    1295:	4c 8d 2c c1          	lea    (%rcx,%rax,8),%r13
    1299:	4d 85 ed             	test   %r13,%r13
    129c:	0f 84 8d 07 00 00    	je     1a2f <balancer_ingress+0x1a2f>
    12a2:	48 89 df             	mov    %rbx,%rdi
    12a5:	48 8b 03             	mov    (%rbx),%rax
    12a8:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    12ad:	ff 50 60             	call   *0x60(%rax)
  if (dst_lru) {
    12b0:	48 85 c0             	test   %rax,%rax
    12b3:	0f 84 dc 0d 00 00    	je     2095 <balancer_ingress+0x2095>
    if (dst_lru->pos == pckt->real_index) {
    12b9:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    12bd:	39 08                	cmp    %ecx,(%rax)
    12bf:	0f 85 15 0e 00 00    	jne    20da <balancer_ingress+0x20da>
              quic_packets_stats->dst_match_in_lru += 1;
    12c5:	4c 89 f0             	mov    %r14,%rax
    12c8:	48 83 c0 50          	add    $0x50,%rax
    12cc:	e9 83 0e 00 00       	jmp    2154 <balancer_ingress+0x2154>
    12d1:	49 ff 46 10          	incq   0x10(%r14)
    12d5:	49 89 56 18          	mov    %rdx,0x18(%r14)
    12d9:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
    12de:	48 89 df             	mov    %rbx,%rdi
    12e1:	49 ff 06             	incq   (%r14)
  original_sport = pckt.flow.port16[0];
    12e4:	0f b7 4c 24 30       	movzwl 0x30(%rsp),%ecx
    12e9:	89 4c 24 40          	mov    %ecx,0x40(%rsp)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    12ed:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    12f2:	48 89 7c 24 78       	mov    %rdi,0x78(%rsp)
    12f7:	75 49                	jne    1342 <balancer_ingress+0x1342>
        !(vip_info->flags & F_LRU_BYPASS)) {
    12f9:	f6 00 02             	testb  $0x2,(%rax)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    12fc:	75 44                	jne    1342 <balancer_ingress+0x1342>
    12fe:	49 89 f6             	mov    %rsi,%r14
    1301:	48 89 c3             	mov    %rax,%rbx
    1304:	48 8b 07             	mov    (%rdi),%rax
    1307:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    130c:	ff 50 60             	call   *0x60(%rax)
  if (!dst_lru) {
    130f:	48 85 c0             	test   %rax,%rax
    1312:	74 29                	je     133d <balancer_ingress+0x133d>
    1314:	49 89 c7             	mov    %rax,%r15
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1317:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    131c:	75 2d                	jne    134b <balancer_ingress+0x134b>
    131e:	48 c7 c0 30 d6 69 a0 	mov    $0xffffffffa069d630,%rax
    cur_time = bpf_ktime_get_ns();
    1325:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1327:	48 89 c1             	mov    %rax,%rcx
    132a:	49 2b 4f 08          	sub    0x8(%r15),%rcx
    132e:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    1335:	00 00 00 
    1338:	48 39 d1             	cmp    %rdx,%rcx
    133b:	76 0a                	jbe    1347 <balancer_ingress+0x1347>
    133d:	45 31 ed             	xor    %r13d,%r13d
    1340:	eb 2f                	jmp    1371 <balancer_ingress+0x1371>
    1342:	45 31 ed             	xor    %r13d,%r13d
    1345:	eb 30                	jmp    1377 <balancer_ingress+0x1377>
    dst_lru->atime = cur_time;
    1347:	49 89 47 08          	mov    %rax,0x8(%r15)
  key = dst_lru->pos;
    134b:	41 8b 07             	mov    (%r15),%eax
    134e:	45 31 ed             	xor    %r13d,%r13d
    1351:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    1357:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    135b:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    135f:	48 b9 00 b1 6b 18 00 	movabs $0xffffc900186bb100,%rcx
    1366:	c9 ff ff 
    1369:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
    136d:	4c 0f 42 e8          	cmovb  %rax,%r13
    1371:	48 89 d8             	mov    %rbx,%rax
    1374:	4c 89 f6             	mov    %r14,%rsi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1377:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    137c:	0f 85 cf 00 00 00    	jne    1451 <balancer_ingress+0x1451>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1382:	f6 40 01 02          	testb  $0x2,0x1(%rax)
    1386:	0f 84 c5 00 00 00    	je     1451 <balancer_ingress+0x1451>
    138c:	48 b9 10 11 54 4c 81 	movabs $0xffff88814c541110,%rcx
    1393:	88 ff ff 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1396:	4c 8b 31             	mov    (%rcx),%r14
    1399:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffa6395028,%r14
    13a0:	39 a6 
  if (!conn_rate_stats) {
    13a2:	4d 85 f6             	test   %r14,%r14
    13a5:	0f 84 a6 00 00 00    	je     1451 <balancer_ingress+0x1451>
    13ab:	49 89 f7             	mov    %rsi,%r15
    13ae:	48 89 c3             	mov    %rax,%rbx
    13b1:	48 c7 c0 30 d6 69 a0 	mov    $0xffffffffa069d630,%rax
  *cur_time = bpf_ktime_get_ns();
    13b8:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    13ba:	48 89 c1             	mov    %rax,%rcx
    13bd:	49 2b 4e 08          	sub    0x8(%r14),%rcx
    13c1:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    13c8:	72 0d                	jb     13d7 <balancer_ingress+0x13d7>
    conn_rate_stats->v1 = 1;
    13ca:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    conn_rate_stats->v2 = *cur_time;
    13d1:	49 89 46 08          	mov    %rax,0x8(%r14)
    13d5:	eb 17                	jmp    13ee <balancer_ingress+0x13ee>
    conn_rate_stats->v1 += 1;
    13d7:	49 8b 06             	mov    (%r14),%rax
    13da:	48 ff c0             	inc    %rax
    13dd:	49 89 06             	mov    %rax,(%r14)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    13e0:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    13e6:	48 89 d8             	mov    %rbx,%rax
    13e9:	4c 89 fe             	mov    %r15,%rsi
    13ec:	77 63                	ja     1451 <balancer_ingress+0x1451>
    13ee:	48 bf 00 e8 d5 5b 81 	movabs $0xffff88815bd5e800,%rdi
    13f5:	88 ff ff 
    13f8:	48 8b 07             	mov    (%rdi),%rax
    13fb:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
    1400:	ff 50 60             	call   *0x60(%rax)
    1403:	4c 89 fe             	mov    %r15,%rsi
    1406:	48 89 c7             	mov    %rax,%rdi
    1409:	48 89 d8             	mov    %rbx,%rax
    if (down_reals_map) {
    140c:	48 85 ff             	test   %rdi,%rdi
    140f:	74 40                	je     1451 <balancer_ingress+0x1451>
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1411:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
    1416:	48 8b 07             	mov    (%rdi),%rax
    1419:	ff 50 60             	call   *0x60(%rax)
    141c:	4c 89 fe             	mov    %r15,%rsi
    141f:	48 89 c1             	mov    %rax,%rcx
    1422:	48 89 d8             	mov    %rbx,%rax
      if (down_real) {
    1425:	48 85 c9             	test   %rcx,%rcx
    1428:	74 27                	je     1451 <balancer_ingress+0x1451>
    142a:	48 b9 78 11 54 4c 81 	movabs $0xffff88814c541178,%rcx
    1431:	88 ff ff 
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1434:	48 8b 09             	mov    (%rcx),%rcx
    1437:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
    143e:	39 a6 
        if (stats_data) {
    1440:	48 85 c9             	test   %rcx,%rcx
    1443:	0f 84 7c 01 00 00    	je     15c5 <balancer_ingress+0x15c5>
          stats_data->v1 += 1;
    1449:	48 ff 01             	incq   (%rcx)
    144c:	e9 74 01 00 00       	jmp    15c5 <balancer_ingress+0x15c5>
    if (!dst) {
    1451:	4d 85 ed             	test   %r13,%r13
    1454:	0f 84 6b 01 00 00    	je     15c5 <balancer_ingress+0x15c5>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    145a:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
    1460:	0f 87 35 0b 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    1466:	48 b8 00 01 54 4c 81 	movabs $0xffff88814c540100,%rax
    146d:	88 ff ff 
    1470:	48 8b 0c f0          	mov    (%rax,%rsi,8),%rcx
    1474:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
    147b:	39 a6 
  if (!data_stats) {
    147d:	48 85 c9             	test   %rcx,%rcx
    1480:	0f 84 15 0b 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    1486:	66 41 c1 c4 08       	rol    $0x8,%r12w
  data_stats->v1 += 1;
    148b:	48 ff 01             	incq   (%rcx)
  data_stats->v2 += pkt_bytes;
    148e:	41 0f b7 c4          	movzwl %r12w,%eax
    1492:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1496:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    149a:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    14a1:	0f 87 f4 0a 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    14a7:	48 ba 00 51 6d 18 00 	movabs $0xffffc900186d5100,%rdx
    14ae:	c9 ff ff 
    14b1:	48 8b 0c ca          	mov    (%rdx,%rcx,8),%rcx
    14b5:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
    14bc:	39 a6 
  if (!data_stats) {
    14be:	48 85 c9             	test   %rcx,%rcx
    14c1:	0f 84 d4 0a 00 00    	je     1f9b <balancer_ingress+0x1f9b>
  data_stats->v1 += 1;
    14c7:	48 ff 01             	incq   (%rcx)
  data_stats->v2 += pkt_bytes;
    14ca:	48 01 41 08          	add    %rax,0x8(%rcx)
    14ce:	8b 44 24 40          	mov    0x40(%rsp),%eax
  pckt.flow.port16[0] = original_sport;
    14d2:	66 89 44 24 30       	mov    %ax,0x30(%rsp)
  if (dst->flags & F_IPV6) {
    14d7:	41 f6 45 10 01       	testb  $0x1,0x10(%r13)
    14dc:	0f 85 94 03 00 00    	jne    1876 <balancer_ingress+0x1876>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    14e2:	0f b7 5c 24 12       	movzwl 0x12(%rsp),%ebx
    14e7:	48 c7 c0 20 5c 83 a2 	mov    $0xffffffffa2835c20,%rax
    14ee:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    14f3:	be ec ff ff ff       	mov    $0xffffffec,%esi
    14f8:	ff d0                	call   *%rax
    14fa:	85 c0                	test   %eax,%eax
    14fc:	0f 85 99 0a 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
    1502:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  data = (void*)(long)xdp->data;
    1507:	48 8b 08             	mov    (%rax),%rcx
  data_end = (void*)(long)xdp->data_end;
    150a:	48 8b 50 08          	mov    0x8(%rax),%rdx
  iph = data + sizeof(struct ethhdr);
    150e:	48 8d 41 0e          	lea    0xe(%rcx),%rax
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1512:	48 39 d0             	cmp    %rdx,%rax
    1515:	0f 87 80 0a 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    151b:	48 8d 71 22          	lea    0x22(%rcx),%rsi
    151f:	b8 01 00 00 00       	mov    $0x1,%eax
    1524:	48 39 d6             	cmp    %rdx,%rsi
    1527:	0f 87 73 0a 00 00    	ja     1fa0 <balancer_ingress+0x1fa0>
    152d:	8b 44 24 40          	mov    0x40(%rsp),%eax
    1531:	66 c1 c0 08          	rol    $0x8,%ax
    1535:	31 c3                	xor    %eax,%ebx
    1537:	c1 e3 10             	shl    $0x10,%ebx
    153a:	8d 93 ac 10 00 00    	lea    0x10ac(%rbx),%edx
    1540:	48 b8 04 21 98 07 81 	movabs $0xffff888107982104,%rax
    1547:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    154a:	0f b7 00             	movzwl (%rax),%eax
    154d:	66 89 41 04          	mov    %ax,0x4(%rcx)
    1551:	48 b8 00 21 98 07 81 	movabs $0xffff888107982100,%rax
    1558:	88 ff ff 
    155b:	8b 00                	mov    (%rax),%eax
    155d:	89 01                	mov    %eax,(%rcx)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    155f:	8b 41 14             	mov    0x14(%rcx),%eax
    1562:	89 41 06             	mov    %eax,0x6(%rcx)
    1565:	0f b7 41 18          	movzwl 0x18(%rcx),%eax
    1569:	66 89 41 0a          	mov    %ax,0xa(%rcx)
  new_eth->h_proto = BE_ETH_P_IP;
    156d:	66 c7 41 0c 08 00    	movw   $0x8,0xc(%rcx)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1573:	0f b6 74 24 3d       	movzbl 0x3d(%rsp),%esi
    1578:	41 8b 45 00          	mov    0x0(%r13),%eax
    __u32 daddr,
    __u16 pkt_bytes,
    __u8 proto) {
  __u64 csum = 0;
  iph->version = 4;
  iph->ihl = 5;
    157c:	c6 41 0e 45          	movb   $0x45,0xe(%rcx)
#ifdef COPY_INNER_PACKET_TOS
  iph->tos = tos;
#else
  iph->tos = DEFAULT_TOS;
#endif
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1580:	41 83 c4 14          	add    $0x14,%r12d
    1584:	66 41 c1 c4 08       	rol    $0x8,%r12w
  iph->tos = tos;
    1589:	40 88 71 0f          	mov    %sil,0xf(%rcx)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    158d:	66 44 89 61 10       	mov    %r12w,0x10(%rcx)
  iph->id = 0;
    1592:	c7 41 12 00 00 00 00 	movl   $0x0,0x12(%rcx)
  iph->daddr = daddr;
    1599:	89 41 1e             	mov    %eax,0x1e(%rcx)
  iph->saddr = saddr;
    159c:	89 51 1a             	mov    %edx,0x1a(%rcx)
  iph->ttl = DEFAULT_TTL;
    159f:	66 c7 41 16 40 04    	movw   $0x440,0x16(%rcx)
    *csum += *next_iph_u16++;
    15a5:	0f b7 51 0e          	movzwl 0xe(%rcx),%edx
    15a9:	41 0f b7 f4          	movzwl %r12w,%esi
    15ad:	0f b7 79 16          	movzwl 0x16(%rcx),%edi
    15b1:	48 01 d7             	add    %rdx,%rdi
    15b4:	c1 eb 10             	shr    $0x10,%ebx
    15b7:	48 01 fb             	add    %rdi,%rbx
    15ba:	0f b7 d0             	movzwl %ax,%edx
    15bd:	48 01 da             	add    %rbx,%rdx
    15c0:	e9 4c 07 00 00       	jmp    1d11 <balancer_ingress+0x1d11>
      if (pckt.flow.proto == IPPROTO_TCP) {
    15c5:	80 7c 24 34 06       	cmpb   $0x6,0x34(%rsp)
    15ca:	75 2d                	jne    15f9 <balancer_ingress+0x15f9>
    15cc:	48 b9 08 11 54 4c 81 	movabs $0xffff88814c541108,%rcx
    15d3:	88 ff ff 
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    15d6:	48 8b 09             	mov    (%rcx),%rcx
    15d9:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
    15e0:	39 a6 
        if (!lru_stats) {
    15e2:	48 85 c9             	test   %rcx,%rcx
    15e5:	0f 84 b0 09 00 00    	je     1f9b <balancer_ingress+0x1f9b>
        if (pckt.flags & F_SYN_SET) {
    15eb:	31 d2                	xor    %edx,%edx
    15ed:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    15f2:	0f 94 c2             	sete   %dl
    15f5:	48 ff 04 d1          	incq   (%rcx,%rdx,8)
    15f9:	48 89 74 24 48       	mov    %rsi,0x48(%rsp)
  struct real_pos_lru new_dst_lru = {};
    15fe:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    1605:	00 00 
    1607:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    160e:	00 
    160f:	48 b9 10 11 54 4c 81 	movabs $0xffff88814c541110,%rcx
    1616:	88 ff ff 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1619:	4c 8b 29             	mov    (%rcx),%r13
    161c:	65 4c 03 2c 25 28 50 	add    %gs:0xffffffffa6395028,%r13
    1623:	39 a6 
    1625:	b3 01                	mov    $0x1,%bl
  if (!conn_rate_stats) {
    1627:	4d 85 ed             	test   %r13,%r13
    162a:	74 29                	je     1655 <balancer_ingress+0x1655>
    162c:	49 89 c6             	mov    %rax,%r14
    162f:	48 c7 c0 30 d6 69 a0 	mov    $0xffffffffa069d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1636:	ff d0                	call   *%rax
    1638:	49 89 c7             	mov    %rax,%r15
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    163b:	49 2b 45 08          	sub    0x8(%r13),%rax
    163f:	48 3d 01 ca 9a 3b    	cmp    $0x3b9aca01,%rax
    1645:	72 13                	jb     165a <balancer_ingress+0x165a>
    conn_rate_stats->v1 = 1;
    1647:	49 c7 45 00 01 00 00 	movq   $0x1,0x0(%r13)
    164e:	00 
    conn_rate_stats->v2 = *cur_time;
    164f:	4d 89 7d 08          	mov    %r15,0x8(%r13)
    1653:	eb 18                	jmp    166d <balancer_ingress+0x166d>
    1655:	45 31 ff             	xor    %r15d,%r15d
    1658:	eb 18                	jmp    1672 <balancer_ingress+0x1672>
    conn_rate_stats->v1 += 1;
    165a:	49 8b 45 00          	mov    0x0(%r13),%rax
    165e:	48 ff c0             	inc    %rax
    1661:	49 89 45 00          	mov    %rax,0x0(%r13)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1665:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    166b:	77 02                	ja     166f <balancer_ingress+0x166f>
    166d:	31 db                	xor    %ebx,%ebx
    166f:	4c 89 f0             	mov    %r14,%rax
    1672:	49 89 c6             	mov    %rax,%r14
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1675:	f6 00 08             	testb  $0x8,(%rax)
    1678:	74 1c                	je     1696 <balancer_ingress+0x1696>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    167a:	0f b7 44 24 32       	movzwl 0x32(%rsp),%eax
    167f:	66 89 44 24 30       	mov    %ax,0x30(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    1684:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    168b:	00 00 
    168d:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
    1694:	00 00 
        jhash(pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6),
    1696:	48 b8 c0 22 00 00 00 	movabs $0x22c0,%rax
    169d:	00 00 00 
    16a0:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
    16a5:	ff d0                	call   *%rax
        pckt->flow.ports,
    16a7:	8b 74 24 30          	mov    0x30(%rsp),%esi
    return jhash_2words(
    16ab:	48 b9 60 22 00 00 00 	movabs $0x2260,%rcx
    16b2:	00 00 00 
    16b5:	89 c7                	mov    %eax,%edi
    16b7:	ff d1                	call   *%rcx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    16b9:	89 c1                	mov    %eax,%ecx
    16bb:	ba 01 00 ff ff       	mov    $0xffff0001,%edx
    16c0:	48 0f af d1          	imul   %rcx,%rdx
    16c4:	48 c1 ea 30          	shr    $0x30,%rdx
    16c8:	89 d1                	mov    %edx,%ecx
    16ca:	c1 e1 10             	shl    $0x10,%ecx
    16cd:	09 d1                	or     %edx,%ecx
    16cf:	29 c8                	sub    %ecx,%eax
    16d1:	4c 89 f1             	mov    %r14,%rcx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    16d4:	41 8b 4e 04          	mov    0x4(%r14),%ecx
    16d8:	01 c8                	add    %ecx,%eax
    16da:	c1 e1 10             	shl    $0x10,%ecx
    16dd:	01 c8                	add    %ecx,%eax
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    16df:	3d ff 01 00 02       	cmp    $0x20001ff,%eax
    if (!real_pos) {
    16e4:	0f 87 b1 08 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    16ea:	48 b9 00 61 63 08 00 	movabs $0xffffc90008636100,%rcx
    16f1:	c9 ff ff 
    16f4:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
    16f8:	48 85 c0             	test   %rax,%rax
    16fb:	0f 84 9a 08 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    key = *real_pos;
    1701:	8b 00                	mov    (%rax),%eax
    1703:	48 85 c0             	test   %rax,%rax
    if (key == 0) {
    1706:	0f 84 22 01 00 00    	je     182e <balancer_ingress+0x182e>
  pckt->real_index = key;
    170c:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1710:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  if (!(*real)) {
    1715:	0f 87 37 01 00 00    	ja     1852 <balancer_ingress+0x1852>
    171b:	48 8d 0c 40          	lea    (%rax,%rax,2),%rcx
    171f:	48 ba 00 b1 6b 18 00 	movabs $0xffffc900186bb100,%rdx
    1726:	c9 ff ff 
    1729:	4c 8d 2c ca          	lea    (%rdx,%rcx,8),%r13
    172d:	4d 85 ed             	test   %r13,%r13
    1730:	0f 84 1c 01 00 00    	je     1852 <balancer_ingress+0x1852>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1736:	41 0f b6 0e          	movzbl (%r14),%ecx
    173a:	80 e1 02             	and    $0x2,%cl
    173d:	d0 e9                	shr    %cl
    173f:	08 cb                	or     %cl,%bl
    1741:	75 24                	jne    1767 <balancer_ingress+0x1767>
    if (pckt->flow.proto == IPPROTO_UDP) {
    1743:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1748:	75 05                	jne    174f <balancer_ingress+0x174f>
      new_dst_lru.atime = cur_time;
    174a:	4c 89 7c 24 08       	mov    %r15,0x8(%rsp)
    new_dst_lru.pos = key;
    174f:	89 04 24             	mov    %eax,(%rsp)
    1752:	48 8b 7c 24 78       	mov    0x78(%rsp),%rdi
		void*,
		(void* map, void* key),
		(void*, void*),
		(map, key))
BPF_MAP_OPS_INLINE(map_update_elem,,
    1757:	48 8b 07             	mov    (%rdi),%rax
    175a:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    175f:	48 89 e2             	mov    %rsp,%rdx
    1762:	31 c9                	xor    %ecx,%ecx
    1764:	ff 50 68             	call   *0x68(%rax)
    1767:	48 b8 00 29 98 07 81 	movabs $0xffff888107982900,%rax
    176e:	88 ff ff 
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    1771:	8b 08                	mov    (%rax),%ecx
    1773:	b0 01                	mov    $0x1,%al
    1775:	3b 4c 24 58          	cmp    0x58(%rsp),%ecx
    1779:	75 37                	jne    17b2 <balancer_ingress+0x17b2>
    177b:	48 b9 04 29 98 07 81 	movabs $0xffff888107982904,%rcx
    1782:	88 ff ff 
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    1785:	8b 09                	mov    (%rcx),%ecx
    1787:	3b 4c 24 5c          	cmp    0x5c(%rsp),%ecx
    178b:	75 25                	jne    17b2 <balancer_ingress+0x17b2>
    178d:	48 b9 08 29 98 07 81 	movabs $0xffff888107982908,%rcx
    1794:	88 ff ff 
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    1797:	8b 09                	mov    (%rcx),%ecx
    1799:	3b 4c 24 60          	cmp    0x60(%rsp),%ecx
    179d:	75 13                	jne    17b2 <balancer_ingress+0x17b2>
    179f:	48 b8 0c 29 98 07 81 	movabs $0xffff88810798290c,%rax
    17a6:	88 ff ff 
                         lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
    17a9:	8b 00                	mov    (%rax),%eax
    17ab:	3b 44 24 64          	cmp    0x64(%rsp),%eax
    17af:	0f 95 c0             	setne  %al
    17b2:	48 b9 10 29 98 07 81 	movabs $0xffff888107982910,%rcx
    17b9:	88 ff ff 
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17bc:	0f b7 11             	movzwl (%rcx),%edx
    17bf:	0f b7 74 24 68       	movzwl 0x68(%rsp),%esi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17c4:	0f b6 4c 24 6a       	movzbl 0x6a(%rsp),%ecx
    17c9:	48 bf 12 29 98 07 81 	movabs $0xffff888107982912,%rdi
    17d0:	88 ff ff 
    17d3:	88 0f                	mov    %cl,(%rdi)
  bool vip_match = address_match && port_match && proto_match;
    17d5:	84 c0                	test   %al,%al
    17d7:	75 3b                	jne    1814 <balancer_ingress+0x1814>
    17d9:	66 39 f2             	cmp    %si,%dx
    17dc:	75 36                	jne    1814 <balancer_ingress+0x1814>
    17de:	84 c9                	test   %cl,%cl
    17e0:	74 32                	je     1814 <balancer_ingress+0x1814>
    __u32 lru_stats_key = pckt->real_index;
    17e2:	8b 44 24 38          	mov    0x38(%rsp),%eax
    17e6:	48 3d ff 0f 00 00    	cmp    $0xfff,%rax
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17ec:	0f 87 a9 07 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    17f2:	48 b9 00 f1 6d 18 00 	movabs $0xffffc900186df100,%rcx
    17f9:	c9 ff ff 
    17fc:	48 8b 04 c1          	mov    (%rcx,%rax,8),%rax
    1800:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    1807:	39 a6 
    if (!lru_miss_stat) {
    1809:	48 85 c0             	test   %rax,%rax
    180c:	0f 84 89 07 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    *lru_miss_stat += 1;
    1812:	ff 00                	incl   (%rax)
      data_stats->v2 += 1;
    1814:	48 ff 45 08          	incq   0x8(%rbp)
    1818:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    181d:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
    1823:	0f 86 3d fc ff ff    	jbe    1466 <balancer_ingress+0x1466>
    1829:	e9 6d 07 00 00       	jmp    1f9b <balancer_ingress+0x1f9b>
    182e:	48 b8 48 11 54 4c 81 	movabs $0xffff88814c541148,%rax
    1835:	88 ff ff 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1838:	48 8b 00             	mov    (%rax),%rax
    183b:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    1842:	39 a6 
  if (!ch_drop_stats) {
    1844:	48 85 c0             	test   %rax,%rax
    1847:	0f 85 47 07 00 00    	jne    1f94 <balancer_ingress+0x1f94>
    184d:	e9 49 07 00 00       	jmp    1f9b <balancer_ingress+0x1f9b>
    1852:	48 b8 48 11 54 4c 81 	movabs $0xffff88814c541148,%rax
    1859:	88 ff ff 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    185c:	48 8b 00             	mov    (%rax),%rax
    185f:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    1866:	39 a6 
  if (!ch_drop_stats) {
    1868:	48 85 c0             	test   %rax,%rax
    186b:	0f 85 27 07 00 00    	jne    1f98 <balancer_ingress+0x1f98>
    1871:	e9 25 07 00 00       	jmp    1f9b <balancer_ingress+0x1f9b>
    1876:	48 c7 c0 20 5c 83 a2 	mov    $0xffffffffa2835c20,%rax
    187d:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1882:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1887:	ff d0                	call   *%rax
    1889:	85 c0                	test   %eax,%eax
    188b:	0f 85 0a 07 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
    1891:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  data = (void*)(long)xdp->data;
    1896:	48 8b 08             	mov    (%rax),%rcx
  data_end = (void*)(long)xdp->data_end;
    1899:	48 8b 50 08          	mov    0x8(%rax),%rdx
  ip6h = data + sizeof(struct ethhdr);
    189d:	48 8d 41 0e          	lea    0xe(%rcx),%rax
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    18a1:	48 39 d0             	cmp    %rdx,%rax
    18a4:	0f 87 f1 06 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    18aa:	48 8d 71 36          	lea    0x36(%rcx),%rsi
    18ae:	b8 01 00 00 00       	mov    $0x1,%eax
    18b3:	48 39 d6             	cmp    %rdx,%rsi
    18b6:	0f 87 e4 06 00 00    	ja     1fa0 <balancer_ingress+0x1fa0>
    18bc:	48 b8 04 21 98 07 81 	movabs $0xffff888107982104,%rax
    18c3:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    18c6:	0f b7 00             	movzwl (%rax),%eax
    18c9:	66 89 41 04          	mov    %ax,0x4(%rcx)
    18cd:	48 b8 00 21 98 07 81 	movabs $0xffff888107982100,%rax
    18d4:	88 ff ff 
    18d7:	8b 00                	mov    (%rax),%eax
    18d9:	89 01                	mov    %eax,(%rcx)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    18db:	8b 41 28             	mov    0x28(%rcx),%eax
    18de:	89 41 06             	mov    %eax,0x6(%rcx)
    18e1:	0f b7 41 2c          	movzwl 0x2c(%rcx),%eax
    18e5:	66 89 41 0a          	mov    %ax,0xa(%rcx)
  new_eth->h_proto = BE_ETH_P_IPV6;
    18e9:	66 c7 41 0c 86 dd    	movw   $0xdd86,0xc(%rcx)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
    18ef:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
  saddr[3] = src ^ port;
    18f4:	33 44 24 1c          	xor    0x1c(%rsp),%eax
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    18f8:	41 83 c4 28          	add    $0x28,%r12d
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    18fc:	0f b6 54 24 3d       	movzbl 0x3d(%rsp),%edx
    __u32* saddr,
    __u32* daddr,
    __u16 payload_len,
    __u8 proto) {
  ip6h->version = 6;
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1901:	66 c7 41 10 00 00    	movw   $0x0,0x10(%rcx)
    1907:	89 d6                	mov    %edx,%esi
    1909:	40 c0 ee 04          	shr    $0x4,%sil
#ifdef COPY_INNER_PACKET_TOS
  ip6h->priority = (tc & 0xF0) >> 4;
    190d:	40 80 ce 60          	or     $0x60,%sil
    1911:	40 88 71 0e          	mov    %sil,0xe(%rcx)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1915:	c0 e2 04             	shl    $0x4,%dl
    1918:	88 51 0f             	mov    %dl,0xf(%rcx)
#else
  ip6h->priority = DEFAULT_TOS;
#endif
  ip6h->nexthdr = proto;
    191b:	66 c7 41 14 29 40    	movw   $0x4029,0x14(%rcx)
  ip6h->payload_len = bpf_htons(payload_len);
    1921:	66 41 c1 c4 08       	rol    $0x8,%r12w
    1926:	66 44 89 61 12       	mov    %r12w,0x12(%rcx)
    192b:	e9 3e 07 00 00       	jmp    206e <balancer_ingress+0x206e>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1930:	41 80 7f 0d 07       	cmpb   $0x7,0xd(%r15)
    1935:	0f 86 05 01 00 00    	jbe    1a40 <balancer_ingress+0x1a40>
    193b:	49 83 c7 0e          	add    $0xe,%r15
    193f:	4c 89 f9             	mov    %r15,%rcx
  if (!connId) {
    1942:	48 85 c9             	test   %rcx,%rcx
    1945:	0f 85 5a f7 ff ff    	jne    10a5 <balancer_ingress+0x10a5>
    194b:	e9 f0 00 00 00       	jmp    1a40 <balancer_ingress+0x1a40>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1950:	0f b6 71 01          	movzbl 0x1(%rcx),%esi
    1954:	c1 e6 10             	shl    $0x10,%esi
    1957:	0f b6 51 02          	movzbl 0x2(%rcx),%edx
    195b:	c1 e2 08             	shl    $0x8,%edx
    195e:	09 f2                	or     %esi,%edx
    1960:	0f b6 49 03          	movzbl 0x3(%rcx),%ecx
    1964:	eb 1d                	jmp    1983 <balancer_ingress+0x1983>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1966:	0f b6 51 01          	movzbl 0x1(%rcx),%edx
    196a:	c1 e2 18             	shl    $0x18,%edx
    196d:	0f b6 71 02          	movzbl 0x2(%rcx),%esi
    1971:	c1 e6 10             	shl    $0x10,%esi
    1974:	09 d6                	or     %edx,%esi
    1976:	0f b6 51 03          	movzbl 0x3(%rcx),%edx
    197a:	c1 e2 08             	shl    $0x8,%edx
    197d:	09 f2                	or     %esi,%edx
    197f:	0f b6 49 04          	movzbl 0x4(%rcx),%ecx
    1983:	0f b6 c9             	movzbl %cl,%ecx
    1986:	48 09 d1             	or     %rdx,%rcx
      if (qpr.server_id > 0) {
    1989:	85 c9                	test   %ecx,%ecx
    198b:	0f 8e af 00 00 00    	jle    1a40 <balancer_ingress+0x1a40>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1991:	48 83 f8 03          	cmp    $0x3,%rax
    1995:	74 16                	je     19ad <balancer_ingress+0x19ad>
    1997:	83 f8 02             	cmp    $0x2,%eax
    199a:	74 0b                	je     19a7 <balancer_ingress+0x19a7>
    199c:	83 f8 01             	cmp    $0x1,%eax
    199f:	75 12                	jne    19b3 <balancer_ingress+0x19b3>
    quic_packets_stats->cid_v1 += 1;
    19a1:	49 8d 46 38          	lea    0x38(%r14),%rax
    19a5:	eb 10                	jmp    19b7 <balancer_ingress+0x19b7>
    quic_packets_stats->cid_v2 += 1;
    19a7:	49 8d 46 40          	lea    0x40(%r14),%rax
    19ab:	eb 0a                	jmp    19b7 <balancer_ingress+0x19b7>
    quic_packets_stats->cid_v3 += 1;
    19ad:	49 8d 46 48          	lea    0x48(%r14),%rax
    19b1:	eb 04                	jmp    19b7 <balancer_ingress+0x19b7>
    quic_packets_stats->cid_v0 += 1;
    19b3:	49 8d 46 30          	lea    0x30(%r14),%rax
    19b7:	48 ff 00             	incq   (%rax)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    19ba:	81 f9 fd ff ff 00    	cmp    $0xfffffd,%ecx
        if (real_pos) {
    19c0:	77 76                	ja     1a38 <balancer_ingress+0x1a38>
    19c2:	48 b8 00 91 6e 18 00 	movabs $0xffffc900186e9100,%rax
    19c9:	c9 ff ff 
    19cc:	48 8d 04 c8          	lea    (%rax,%rcx,8),%rax
    19d0:	48 85 c0             	test   %rax,%rax
    19d3:	74 63                	je     1a38 <balancer_ingress+0x1a38>
          key = *real_pos;
    19d5:	8b 00                	mov    (%rax),%eax
    19d7:	48 85 c0             	test   %rax,%rax
          if (key == 0) {
    19da:	74 5c                	je     1a38 <balancer_ingress+0x1a38>
            pckt.real_index = key;
    19dc:	89 44 24 38          	mov    %eax,0x38(%rsp)
            dst = bpf_map_lookup_elem(&reals, &key);
    19e0:	3d ff 0f 00 00       	cmp    $0xfff,%eax
            if (!dst) {
    19e5:	77 48                	ja     1a2f <balancer_ingress+0x1a2f>
    19e7:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    19eb:	48 b9 00 b1 6b 18 00 	movabs $0xffffc900186bb100,%rcx
    19f2:	c9 ff ff 
    19f5:	4c 8d 2c c1          	lea    (%rcx,%rax,8),%r13
    19f9:	4d 85 ed             	test   %r13,%r13
    19fc:	74 31                	je     1a2f <balancer_ingress+0x1a2f>
    19fe:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    1a03:	48 8b 07             	mov    (%rdi),%rax
    1a06:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    1a0b:	ff 50 60             	call   *0x60(%rax)
  if (dst_lru) {
    1a0e:	48 85 c0             	test   %rax,%rax
    1a11:	0f 84 63 07 00 00    	je     217a <balancer_ingress+0x217a>
    if (dst_lru->pos == pckt->real_index) {
    1a17:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    1a1b:	39 08                	cmp    %ecx,(%rax)
    1a1d:	0f 85 9c 07 00 00    	jne    21bf <balancer_ingress+0x21bf>
              quic_packets_stats->dst_match_in_lru += 1;
    1a23:	4c 89 f0             	mov    %r14,%rax
    1a26:	48 83 c0 50          	add    $0x50,%rax
    1a2a:	e9 0c 08 00 00       	jmp    223b <balancer_ingress+0x223b>
              quic_packets_stats->cid_unknown_real_dropped += 1;
    1a2f:	49 ff 46 28          	incq   0x28(%r14)
    1a33:	e9 63 05 00 00       	jmp    1f9b <balancer_ingress+0x1f9b>
    1a38:	49 ff 46 10          	incq   0x10(%r14)
    1a3c:	49 89 4e 18          	mov    %rcx,0x18(%r14)
    1a40:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    1a45:	49 ff 06             	incq   (%r14)
  original_sport = pckt.flow.port16[0];
    1a48:	0f b7 4c 24 30       	movzwl 0x30(%rsp),%ecx
    1a4d:	89 8c 24 84 00 00 00 	mov    %ecx,0x84(%rsp)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1a54:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    1a59:	75 48                	jne    1aa3 <balancer_ingress+0x1aa3>
        !(vip_info->flags & F_LRU_BYPASS)) {
    1a5b:	f6 00 02             	testb  $0x2,(%rax)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1a5e:	75 3e                	jne    1a9e <balancer_ingress+0x1a9e>
    1a60:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    1a65:	48 8b 07             	mov    (%rdi),%rax
    1a68:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    1a6d:	ff 50 60             	call   *0x60(%rax)
  if (!dst_lru) {
    1a70:	48 85 c0             	test   %rax,%rax
    1a73:	74 29                	je     1a9e <balancer_ingress+0x1a9e>
    1a75:	49 89 c7             	mov    %rax,%r15
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1a78:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1a7d:	75 2d                	jne    1aac <balancer_ingress+0x1aac>
    1a7f:	48 c7 c0 30 d6 69 a0 	mov    $0xffffffffa069d630,%rax
    cur_time = bpf_ktime_get_ns();
    1a86:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1a88:	48 89 c1             	mov    %rax,%rcx
    1a8b:	49 2b 4f 08          	sub    0x8(%r15),%rcx
    1a8f:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    1a96:	00 00 00 
    1a99:	48 39 d1             	cmp    %rdx,%rcx
    1a9c:	76 0a                	jbe    1aa8 <balancer_ingress+0x1aa8>
    1a9e:	45 31 ed             	xor    %r13d,%r13d
    1aa1:	eb 2f                	jmp    1ad2 <balancer_ingress+0x1ad2>
    1aa3:	45 31 ed             	xor    %r13d,%r13d
    1aa6:	eb 2f                	jmp    1ad7 <balancer_ingress+0x1ad7>
    dst_lru->atime = cur_time;
    1aa8:	49 89 47 08          	mov    %rax,0x8(%r15)
  key = dst_lru->pos;
    1aac:	41 8b 07             	mov    (%r15),%eax
    1aaf:	45 31 ed             	xor    %r13d,%r13d
    1ab2:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    1ab8:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1abc:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    1ac0:	48 b9 00 b1 6b 18 00 	movabs $0xffffc900186bb100,%rcx
    1ac7:	c9 ff ff 
    1aca:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
    1ace:	4c 0f 42 e8          	cmovb  %rax,%r13
    1ad2:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1ad7:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1adc:	0f 85 b4 00 00 00    	jne    1b96 <balancer_ingress+0x1b96>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1ae2:	f6 40 01 02          	testb  $0x2,0x1(%rax)
    1ae6:	0f 84 aa 00 00 00    	je     1b96 <balancer_ingress+0x1b96>
    1aec:	48 b8 10 11 54 4c 81 	movabs $0xffff88814c541110,%rax
    1af3:	88 ff ff 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1af6:	48 8b 18             	mov    (%rax),%rbx
    1af9:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffa6395028,%rbx
    1b00:	39 a6 
  if (!conn_rate_stats) {
    1b02:	48 85 db             	test   %rbx,%rbx
    1b05:	0f 84 8b 00 00 00    	je     1b96 <balancer_ingress+0x1b96>
    1b0b:	48 c7 c0 30 d6 69 a0 	mov    $0xffffffffa069d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1b12:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1b14:	48 89 c1             	mov    %rax,%rcx
    1b17:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1b1b:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1b22:	72 0d                	jb     1b31 <balancer_ingress+0x1b31>
    conn_rate_stats->v1 = 1;
    1b24:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1b2b:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1b2f:	eb 11                	jmp    1b42 <balancer_ingress+0x1b42>
    conn_rate_stats->v1 += 1;
    1b31:	48 8b 03             	mov    (%rbx),%rax
    1b34:	48 ff c0             	inc    %rax
    1b37:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1b3a:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    1b40:	77 54                	ja     1b96 <balancer_ingress+0x1b96>
    1b42:	48 bf 00 e8 d5 5b 81 	movabs $0xffff88815bd5e800,%rdi
    1b49:	88 ff ff 
    1b4c:	48 8b 07             	mov    (%rdi),%rax
    1b4f:	48 8d 74 24 58       	lea    0x58(%rsp),%rsi
    1b54:	ff 50 60             	call   *0x60(%rax)
    if (down_reals_map) {
    1b57:	48 85 c0             	test   %rax,%rax
    1b5a:	74 3a                	je     1b96 <balancer_ingress+0x1b96>
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1b5c:	48 8d 74 24 38       	lea    0x38(%rsp),%rsi
    1b61:	48 8b 08             	mov    (%rax),%rcx
    1b64:	48 89 c7             	mov    %rax,%rdi
    1b67:	ff 51 60             	call   *0x60(%rcx)
      if (down_real) {
    1b6a:	48 85 c0             	test   %rax,%rax
    1b6d:	74 27                	je     1b96 <balancer_ingress+0x1b96>
    1b6f:	48 b8 78 11 54 4c 81 	movabs $0xffff88814c541178,%rax
    1b76:	88 ff ff 
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1b79:	48 8b 00             	mov    (%rax),%rax
    1b7c:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    1b83:	39 a6 
        if (stats_data) {
    1b85:	48 85 c0             	test   %rax,%rax
    1b88:	0f 84 e9 01 00 00    	je     1d77 <balancer_ingress+0x1d77>
          stats_data->v1 += 1;
    1b8e:	48 ff 00             	incq   (%rax)
    1b91:	e9 e1 01 00 00       	jmp    1d77 <balancer_ingress+0x1d77>
    if (!dst) {
    1b96:	4d 85 ed             	test   %r13,%r13
    1b99:	0f 84 d8 01 00 00    	je     1d77 <balancer_ingress+0x1d77>
    1b9f:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1ba4:	81 f9 ff 03 00 00    	cmp    $0x3ff,%ecx
    1baa:	0f 87 eb 03 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    1bb0:	48 b8 00 01 54 4c 81 	movabs $0xffff88814c540100,%rax
    1bb7:	88 ff ff 
    1bba:	48 8b 0c c8          	mov    (%rax,%rcx,8),%rcx
    1bbe:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
    1bc5:	39 a6 
  if (!data_stats) {
    1bc7:	48 85 c9             	test   %rcx,%rcx
    1bca:	0f 84 cb 03 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    1bd0:	89 eb                	mov    %ebp,%ebx
    1bd2:	66 c1 c3 08          	rol    $0x8,%bx
  data_stats->v1 += 1;
    1bd6:	48 ff 01             	incq   (%rcx)
  data_stats->v2 += pkt_bytes;
    1bd9:	0f b7 c3             	movzwl %bx,%eax
    1bdc:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1be0:	8b 4c 24 38          	mov    0x38(%rsp),%ecx
    1be4:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    1beb:	0f 87 aa 03 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    1bf1:	48 ba 00 51 6d 18 00 	movabs $0xffffc900186d5100,%rdx
    1bf8:	c9 ff ff 
    1bfb:	48 8b 0c ca          	mov    (%rdx,%rcx,8),%rcx
    1bff:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffa6395028,%rcx
    1c06:	39 a6 
  if (!data_stats) {
    1c08:	48 85 c9             	test   %rcx,%rcx
    1c0b:	0f 84 8a 03 00 00    	je     1f9b <balancer_ingress+0x1f9b>
  data_stats->v1 += 1;
    1c11:	48 ff 01             	incq   (%rcx)
  data_stats->v2 += pkt_bytes;
    1c14:	48 01 41 08          	add    %rax,0x8(%rcx)
    1c18:	8b 84 24 84 00 00 00 	mov    0x84(%rsp),%eax
  pckt.flow.port16[0] = original_sport;
    1c1f:	66 89 44 24 30       	mov    %ax,0x30(%rsp)
  if (dst->flags & F_IPV6) {
    1c24:	41 f6 45 10 01       	testb  $0x1,0x10(%r13)
    1c29:	0f 85 a0 03 00 00    	jne    1fcf <balancer_ingress+0x1fcf>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1c2f:	44 0f b7 74 24 12    	movzwl 0x12(%rsp),%r14d
    1c35:	48 c7 c0 20 5c 83 a2 	mov    $0xffffffffa2835c20,%rax
    1c3c:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1c41:	be ec ff ff ff       	mov    $0xffffffec,%esi
    1c46:	ff d0                	call   *%rax
    1c48:	85 c0                	test   %eax,%eax
    1c4a:	0f 85 4b 03 00 00    	jne    1f9b <balancer_ingress+0x1f9b>
    1c50:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  data = (void*)(long)xdp->data;
    1c55:	48 8b 08             	mov    (%rax),%rcx
  data_end = (void*)(long)xdp->data_end;
    1c58:	48 8b 50 08          	mov    0x8(%rax),%rdx
  iph = data + sizeof(struct ethhdr);
    1c5c:	48 8d 41 0e          	lea    0xe(%rcx),%rax
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1c60:	48 39 d0             	cmp    %rdx,%rax
    1c63:	0f 87 32 03 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    1c69:	48 8d 71 22          	lea    0x22(%rcx),%rsi
    1c6d:	b8 01 00 00 00       	mov    $0x1,%eax
    1c72:	48 39 d6             	cmp    %rdx,%rsi
    1c75:	0f 87 25 03 00 00    	ja     1fa0 <balancer_ingress+0x1fa0>
    1c7b:	8b 84 24 84 00 00 00 	mov    0x84(%rsp),%eax
    1c82:	66 c1 c0 08          	rol    $0x8,%ax
    1c86:	41 31 c6             	xor    %eax,%r14d
    1c89:	41 c1 e6 10          	shl    $0x10,%r14d
    1c8d:	41 8d 96 ac 10 00 00 	lea    0x10ac(%r14),%edx
    1c94:	48 b8 04 21 98 07 81 	movabs $0xffff888107982104,%rax
    1c9b:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1c9e:	0f b7 00             	movzwl (%rax),%eax
    1ca1:	66 89 41 04          	mov    %ax,0x4(%rcx)
    1ca5:	48 b8 00 21 98 07 81 	movabs $0xffff888107982100,%rax
    1cac:	88 ff ff 
    1caf:	8b 00                	mov    (%rax),%eax
    1cb1:	89 01                	mov    %eax,(%rcx)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1cb3:	8b 41 14             	mov    0x14(%rcx),%eax
    1cb6:	89 41 06             	mov    %eax,0x6(%rcx)
    1cb9:	0f b7 41 18          	movzwl 0x18(%rcx),%eax
    1cbd:	66 89 41 0a          	mov    %ax,0xa(%rcx)
  new_eth->h_proto = BE_ETH_P_IP;
    1cc1:	66 c7 41 0c 08 00    	movw   $0x8,0xc(%rcx)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1cc7:	0f b6 74 24 3d       	movzbl 0x3d(%rsp),%esi
    1ccc:	41 8b 45 00          	mov    0x0(%r13),%eax
  iph->ihl = 5;
    1cd0:	c6 41 0e 45          	movb   $0x45,0xe(%rcx)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1cd4:	83 c3 14             	add    $0x14,%ebx
    1cd7:	66 c1 c3 08          	rol    $0x8,%bx
  iph->tos = tos;
    1cdb:	40 88 71 0f          	mov    %sil,0xf(%rcx)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1cdf:	66 89 59 10          	mov    %bx,0x10(%rcx)
  iph->id = 0;
    1ce3:	c7 41 12 00 00 00 00 	movl   $0x0,0x12(%rcx)
  iph->daddr = daddr;
    1cea:	89 41 1e             	mov    %eax,0x1e(%rcx)
  iph->saddr = saddr;
    1ced:	89 51 1a             	mov    %edx,0x1a(%rcx)
  iph->ttl = DEFAULT_TTL;
    1cf0:	66 c7 41 16 40 04    	movw   $0x440,0x16(%rcx)
    1cf6:	0f b7 51 0e          	movzwl 0xe(%rcx),%edx
    1cfa:	0f b7 f3             	movzwl %bx,%esi
    1cfd:	0f b7 79 16          	movzwl 0x16(%rcx),%edi
    1d01:	48 01 d7             	add    %rdx,%rdi
    1d04:	41 c1 ee 10          	shr    $0x10,%r14d
    1d08:	49 01 fe             	add    %rdi,%r14
    1d0b:	0f b7 d0             	movzwl %ax,%edx
    1d0e:	4c 01 f2             	add    %r14,%rdx
    1d11:	48 01 f2             	add    %rsi,%rdx
    1d14:	c1 e8 10             	shr    $0x10,%eax
    1d17:	48 01 d0             	add    %rdx,%rax
    1d1a:	48 05 ac 10 00 00    	add    $0x10ac,%rax
    if (csum >> 16)
    1d20:	48 89 c2             	mov    %rax,%rdx
    1d23:	48 c1 ea 10          	shr    $0x10,%rdx
    1d27:	0f b7 f0             	movzwl %ax,%esi
    1d2a:	48 01 d6             	add    %rdx,%rsi
    1d2d:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
    1d33:	48 0f 42 f0          	cmovb  %rax,%rsi
    1d37:	48 89 f0             	mov    %rsi,%rax
    1d3a:	48 c1 e8 10          	shr    $0x10,%rax
    1d3e:	0f b7 d6             	movzwl %si,%edx
    1d41:	48 01 c2             	add    %rax,%rdx
    1d44:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    1d4b:	48 0f 42 d6          	cmovb  %rsi,%rdx
    1d4f:	48 89 d0             	mov    %rdx,%rax
    1d52:	48 c1 e8 10          	shr    $0x10,%rax
    1d56:	0f b7 f2             	movzwl %dx,%esi
    1d59:	01 f0                	add    %esi,%eax
    1d5b:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
    1d62:	0f 42 c2             	cmovb  %edx,%eax
    1d65:	89 c2                	mov    %eax,%edx
    1d67:	c1 ea 10             	shr    $0x10,%edx
    1d6a:	01 c2                	add    %eax,%edx
  return ~csum;
    1d6c:	f7 d2                	not    %edx
  iph->check = csum;
    1d6e:	66 89 51 18          	mov    %dx,0x18(%rcx)
    1d72:	e9 4d e6 ff ff       	jmp    3c4 <balancer_ingress+0x3c4>
      if (pckt.flow.proto == IPPROTO_TCP) {
    1d77:	80 7c 24 34 06       	cmpb   $0x6,0x34(%rsp)
    1d7c:	75 2d                	jne    1dab <balancer_ingress+0x1dab>
    1d7e:	48 b8 08 11 54 4c 81 	movabs $0xffff88814c541108,%rax
    1d85:	88 ff ff 
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1d88:	48 8b 00             	mov    (%rax),%rax
    1d8b:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    1d92:	39 a6 
        if (!lru_stats) {
    1d94:	48 85 c0             	test   %rax,%rax
    1d97:	0f 84 fe 01 00 00    	je     1f9b <balancer_ingress+0x1f9b>
        if (pckt.flags & F_SYN_SET) {
    1d9d:	31 c9                	xor    %ecx,%ecx
    1d9f:	f6 44 24 3c 02       	testb  $0x2,0x3c(%rsp)
    1da4:	0f 94 c1             	sete   %cl
    1da7:	48 ff 04 c8          	incq   (%rax,%rcx,8)
  struct real_pos_lru new_dst_lru = {};
    1dab:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    1db2:	00 00 
    1db4:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    1dbb:	00 
    1dbc:	48 b8 10 11 54 4c 81 	movabs $0xffff88814c541110,%rax
    1dc3:	88 ff ff 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1dc6:	4c 8b 30             	mov    (%rax),%r14
    1dc9:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffa6395028,%r14
    1dd0:	39 a6 
    1dd2:	b3 01                	mov    $0x1,%bl
  if (!conn_rate_stats) {
    1dd4:	4d 85 f6             	test   %r14,%r14
    1dd7:	74 25                	je     1dfe <balancer_ingress+0x1dfe>
    1dd9:	48 c7 c0 30 d6 69 a0 	mov    $0xffffffffa069d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1de0:	ff d0                	call   *%rax
    1de2:	49 89 c7             	mov    %rax,%r15
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1de5:	49 2b 46 08          	sub    0x8(%r14),%rax
    1de9:	48 3d 01 ca 9a 3b    	cmp    $0x3b9aca01,%rax
    1def:	72 12                	jb     1e03 <balancer_ingress+0x1e03>
    conn_rate_stats->v1 = 1;
    1df1:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    conn_rate_stats->v2 = *cur_time;
    1df8:	4d 89 7e 08          	mov    %r15,0x8(%r14)
    1dfc:	eb 16                	jmp    1e14 <balancer_ingress+0x1e14>
    1dfe:	45 31 ff             	xor    %r15d,%r15d
    1e01:	eb 13                	jmp    1e16 <balancer_ingress+0x1e16>
    conn_rate_stats->v1 += 1;
    1e03:	49 8b 06             	mov    (%r14),%rax
    1e06:	48 ff c0             	inc    %rax
    1e09:	49 89 06             	mov    %rax,(%r14)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1e0c:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    1e12:	77 02                	ja     1e16 <balancer_ingress+0x1e16>
    1e14:	31 db                	xor    %ebx,%ebx
    1e16:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1e1b:	f6 00 08             	testb  $0x8,(%rax)
    1e1e:	75 06                	jne    1e26 <balancer_ingress+0x1e26>
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    1e20:	8b 7c 24 10          	mov    0x10(%rsp),%edi
    1e24:	eb 1e                	jmp    1e44 <balancer_ingress+0x1e44>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1e26:	0f b7 44 24 32       	movzwl 0x32(%rsp),%eax
    1e2b:	66 89 44 24 30       	mov    %ax,0x30(%rsp)
      memset(pckt->flow.srcv6, 0, 16);
    1e30:	48 c7 44 24 10 00 00 	movq   $0x0,0x10(%rsp)
    1e37:	00 00 
    1e39:	48 c7 44 24 18 00 00 	movq   $0x0,0x18(%rsp)
    1e40:	00 00 
    1e42:	31 ff                	xor    %edi,%edi
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    1e44:	8b 74 24 30          	mov    0x30(%rsp),%esi
    1e48:	48 b8 60 22 00 00 00 	movabs $0x2260,%rax
    1e4f:	00 00 00 
    1e52:	ff d0                	call   *%rax
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1e54:	89 c1                	mov    %eax,%ecx
    1e56:	ba 01 00 ff ff       	mov    $0xffff0001,%edx
    1e5b:	48 0f af d1          	imul   %rcx,%rdx
    1e5f:	48 c1 ea 30          	shr    $0x30,%rdx
    1e63:	89 d1                	mov    %edx,%ecx
    1e65:	c1 e1 10             	shl    $0x10,%ecx
    1e68:	09 d1                	or     %edx,%ecx
    1e6a:	29 c8                	sub    %ecx,%eax
    1e6c:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1e71:	8b 49 04             	mov    0x4(%rcx),%ecx
    1e74:	01 c8                	add    %ecx,%eax
    1e76:	c1 e1 10             	shl    $0x10,%ecx
    1e79:	01 c8                	add    %ecx,%eax
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1e7b:	3d ff 01 00 02       	cmp    $0x20001ff,%eax
    if (!real_pos) {
    1e80:	0f 87 15 01 00 00    	ja     1f9b <balancer_ingress+0x1f9b>
    1e86:	48 b9 00 61 63 08 00 	movabs $0xffffc90008636100,%rcx
    1e8d:	c9 ff ff 
    1e90:	48 8d 04 c1          	lea    (%rcx,%rax,8),%rax
    1e94:	48 85 c0             	test   %rax,%rax
    1e97:	0f 84 fe 00 00 00    	je     1f9b <balancer_ingress+0x1f9b>
    key = *real_pos;
    1e9d:	8b 00                	mov    (%rax),%eax
    1e9f:	48 85 c0             	test   %rax,%rax
    if (key == 0) {
    1ea2:	0f 84 d1 00 00 00    	je     1f79 <balancer_ingress+0x1f79>
  pckt->real_index = key;
    1ea8:	89 44 24 38          	mov    %eax,0x38(%rsp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1eac:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  if (!(*real)) {
    1eb1:	0f 87 fb 00 00 00    	ja     1fb2 <balancer_ingress+0x1fb2>
    1eb7:	48 8d 0c 40          	lea    (%rax,%rax,2),%rcx
    1ebb:	48 ba 00 b1 6b 18 00 	movabs $0xffffc900186bb100,%rdx
    1ec2:	c9 ff ff 
    1ec5:	4c 8d 2c ca          	lea    (%rdx,%rcx,8),%r13
    1ec9:	4d 85 ed             	test   %r13,%r13
    1ecc:	0f 84 e0 00 00 00    	je     1fb2 <balancer_ingress+0x1fb2>
    1ed2:	48 8b 4c 24 40       	mov    0x40(%rsp),%rcx
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1ed7:	0f b6 09             	movzbl (%rcx),%ecx
    1eda:	80 e1 02             	and    $0x2,%cl
    1edd:	d0 e9                	shr    %cl
    1edf:	08 cb                	or     %cl,%bl
    1ee1:	75 24                	jne    1f07 <balancer_ingress+0x1f07>
    if (pckt->flow.proto == IPPROTO_UDP) {
    1ee3:	80 7c 24 34 11       	cmpb   $0x11,0x34(%rsp)
    1ee8:	75 05                	jne    1eef <balancer_ingress+0x1eef>
      new_dst_lru.atime = cur_time;
    1eea:	4c 89 7c 24 08       	mov    %r15,0x8(%rsp)
    new_dst_lru.pos = key;
    1eef:	89 04 24             	mov    %eax,(%rsp)
    1ef2:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
BPF_MAP_OPS_INLINE(map_update_elem,,
    1ef7:	48 8b 07             	mov    (%rdi),%rax
    1efa:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    1eff:	48 89 e2             	mov    %rsp,%rdx
    1f02:	31 c9                	xor    %ecx,%ecx
    1f04:	ff 50 68             	call   *0x68(%rax)
    1f07:	48 b8 00 29 98 07 81 	movabs $0xffff888107982900,%rax
    1f0e:	88 ff ff 
      (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
    1f11:	8b 30                	mov    (%rax),%esi
    1f13:	48 b8 10 29 98 07 81 	movabs $0xffff888107982910,%rax
    1f1a:	88 ff ff 
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1f1d:	0f b7 08             	movzwl (%rax),%ecx
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1f20:	0f b6 44 24 6a       	movzbl 0x6a(%rsp),%eax
    1f25:	48 ba 12 29 98 07 81 	movabs $0xffff888107982912,%rdx
    1f2c:	88 ff ff 
    1f2f:	88 02                	mov    %al,(%rdx)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1f31:	0f b7 54 24 68       	movzwl 0x68(%rsp),%edx
      (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
    1f36:	3b 74 24 58          	cmp    0x58(%rsp),%esi
  bool vip_match = address_match && port_match && proto_match;
    1f3a:	75 33                	jne    1f6f <balancer_ingress+0x1f6f>
    1f3c:	66 39 d1             	cmp    %dx,%cx
    1f3f:	75 2e                	jne    1f6f <balancer_ingress+0x1f6f>
    1f41:	84 c0                	test   %al,%al
    1f43:	74 2a                	je     1f6f <balancer_ingress+0x1f6f>
    __u32 lru_stats_key = pckt->real_index;
    1f45:	8b 44 24 38          	mov    0x38(%rsp),%eax
    1f49:	48 3d ff 0f 00 00    	cmp    $0xfff,%rax
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1f4f:	77 4a                	ja     1f9b <balancer_ingress+0x1f9b>
    1f51:	48 b9 00 f1 6d 18 00 	movabs $0xffffc900186df100,%rcx
    1f58:	c9 ff ff 
    1f5b:	48 8b 04 c1          	mov    (%rcx,%rax,8),%rax
    1f5f:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    1f66:	39 a6 
    if (!lru_miss_stat) {
    1f68:	48 85 c0             	test   %rax,%rax
    1f6b:	74 2e                	je     1f9b <balancer_ingress+0x1f9b>
    *lru_miss_stat += 1;
    1f6d:	ff 00                	incl   (%rax)
      data_stats->v2 += 1;
    1f6f:	49 ff 44 24 08       	incq   0x8(%r12)
    1f74:	e9 26 fc ff ff       	jmp    1b9f <balancer_ingress+0x1b9f>
    1f79:	48 b8 48 11 54 4c 81 	movabs $0xffff88814c541148,%rax
    1f80:	88 ff ff 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1f83:	48 8b 00             	mov    (%rax),%rax
    1f86:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    1f8d:	39 a6 
  if (!ch_drop_stats) {
    1f8f:	48 85 c0             	test   %rax,%rax
    1f92:	74 07                	je     1f9b <balancer_ingress+0x1f9b>
  ch_drop_stats->v2 += 1;
    1f94:	48 83 c0 08          	add    $0x8,%rax
    1f98:	48 ff 00             	incq   (%rax)
    1f9b:	b8 01 00 00 00       	mov    $0x1,%eax
    return process_packet(ctx, nh_off, true);
  } else {
    // pass to tcp/ip stack
    return XDP_PASS;
  }
}
    1fa0:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    1fa7:	5b                   	pop    %rbx
    1fa8:	41 5c                	pop    %r12
    1faa:	41 5d                	pop    %r13
    1fac:	41 5e                	pop    %r14
    1fae:	41 5f                	pop    %r15
    1fb0:	5d                   	pop    %rbp
    1fb1:	c3                   	ret
    1fb2:	48 b8 48 11 54 4c 81 	movabs $0xffff88814c541148,%rax
    1fb9:	88 ff ff 
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1fbc:	48 8b 00             	mov    (%rax),%rax
    1fbf:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    1fc6:	39 a6 
  if (!ch_drop_stats) {
    1fc8:	48 85 c0             	test   %rax,%rax
    1fcb:	75 cb                	jne    1f98 <balancer_ingress+0x1f98>
    1fcd:	eb cc                	jmp    1f9b <balancer_ingress+0x1f9b>
    1fcf:	48 c7 c0 20 5c 83 a2 	mov    $0xffffffffa2835c20,%rax
    1fd6:	48 8b 7c 24 50       	mov    0x50(%rsp),%rdi
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1fdb:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1fe0:	ff d0                	call   *%rax
    1fe2:	85 c0                	test   %eax,%eax
    1fe4:	75 b5                	jne    1f9b <balancer_ingress+0x1f9b>
    1fe6:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  data = (void*)(long)xdp->data;
    1feb:	48 8b 08             	mov    (%rax),%rcx
  data_end = (void*)(long)xdp->data_end;
    1fee:	48 8b 50 08          	mov    0x8(%rax),%rdx
  ip6h = data + sizeof(struct ethhdr);
    1ff2:	48 8d 41 0e          	lea    0xe(%rcx),%rax
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1ff6:	48 39 d0             	cmp    %rdx,%rax
    1ff9:	77 a0                	ja     1f9b <balancer_ingress+0x1f9b>
    1ffb:	48 8d 71 36          	lea    0x36(%rcx),%rsi
    1fff:	b8 01 00 00 00       	mov    $0x1,%eax
    2004:	48 39 d6             	cmp    %rdx,%rsi
    2007:	77 97                	ja     1fa0 <balancer_ingress+0x1fa0>
    2009:	48 b8 04 21 98 07 81 	movabs $0xffff888107982104,%rax
    2010:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    2013:	0f b7 00             	movzwl (%rax),%eax
    2016:	66 89 41 04          	mov    %ax,0x4(%rcx)
    201a:	48 b8 00 21 98 07 81 	movabs $0xffff888107982100,%rax
    2021:	88 ff ff 
    2024:	8b 00                	mov    (%rax),%eax
    2026:	89 01                	mov    %eax,(%rcx)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    2028:	8b 41 28             	mov    0x28(%rcx),%eax
    202b:	89 41 06             	mov    %eax,0x6(%rcx)
    202e:	0f b7 41 2c          	movzwl 0x2c(%rcx),%eax
    2032:	66 89 41 0a          	mov    %ax,0xa(%rcx)
  new_eth->h_proto = BE_ETH_P_IPV6;
    2036:	66 c7 41 0c 86 dd    	movw   $0xdd86,0xc(%rcx)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
    203c:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
  saddr[3] = src ^ port;
    2041:	33 44 24 10          	xor    0x10(%rsp),%eax
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    2045:	0f b6 54 24 3d       	movzbl 0x3d(%rsp),%edx
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    204a:	66 c7 41 10 00 00    	movw   $0x0,0x10(%rcx)
    2050:	89 d6                	mov    %edx,%esi
    2052:	40 c0 ee 04          	shr    $0x4,%sil
  ip6h->priority = (tc & 0xF0) >> 4;
    2056:	40 80 ce 60          	or     $0x60,%sil
    205a:	40 88 71 0e          	mov    %sil,0xe(%rcx)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    205e:	c0 e2 04             	shl    $0x4,%dl
    2061:	88 51 0f             	mov    %dl,0xf(%rcx)
  ip6h->nexthdr = proto;
    2064:	66 c7 41 14 04 40    	movw   $0x4004,0x14(%rcx)
  ip6h->payload_len = bpf_htons(payload_len);
    206a:	66 89 69 12          	mov    %bp,0x12(%rcx)
  ip6h->hop_limit = DEFAULT_TTL;
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    206e:	48 c7 41 16 01 00 00 	movq   $0x1,0x16(%rcx)
    2075:	00 
    2076:	c7 41 1e 00 00 00 00 	movl   $0x0,0x1e(%rcx)
    207d:	89 41 22             	mov    %eax,0x22(%rcx)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    2080:	49 8b 45 00          	mov    0x0(%r13),%rax
    2084:	49 8b 55 08          	mov    0x8(%r13),%rdx
    2088:	48 89 41 26          	mov    %rax,0x26(%rcx)
    208c:	48 89 51 2e          	mov    %rdx,0x2e(%rcx)
    2090:	e9 2f e3 ff ff       	jmp    3c4 <balancer_ingress+0x3c4>
    2095:	48 b8 10 11 54 4c 81 	movabs $0xffff88814c541110,%rax
    209c:	88 ff ff 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    209f:	4c 8b 38             	mov    (%rax),%r15
    20a2:	65 4c 03 3c 25 28 50 	add    %gs:0xffffffffa6395028,%r15
    20a9:	39 a6 
  if (!conn_rate_stats) {
    20ab:	4d 85 ff             	test   %r15,%r15
    20ae:	0f 84 99 00 00 00    	je     214d <balancer_ingress+0x214d>
    20b4:	48 c7 c0 30 d6 69 a0 	mov    $0xffffffffa069d630,%rax
  *cur_time = bpf_ktime_get_ns();
    20bb:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    20bd:	48 89 c1             	mov    %rax,%rcx
    20c0:	49 2b 4f 08          	sub    0x8(%r15),%rcx
    20c4:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    20cb:	72 44                	jb     2111 <balancer_ingress+0x2111>
    conn_rate_stats->v1 = 1;
    20cd:	49 c7 07 01 00 00 00 	movq   $0x1,(%r15)
    conn_rate_stats->v2 = *cur_time;
    20d4:	49 89 47 08          	mov    %rax,0x8(%r15)
    20d8:	eb 48                	jmp    2122 <balancer_ingress+0x2122>
      dst_lru->pos = pckt->real_index;
    20da:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    20dc:	49 ff 46 58          	incq   0x58(%r14)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    20e0:	81 7c 24 48 ff 01 00 	cmpl   $0x1ff,0x48(%rsp)
    20e7:	00 
    20e8:	77 6d                	ja     2157 <balancer_ingress+0x2157>
    20ea:	48 b8 00 41 54 6d 81 	movabs $0xffff88816d544100,%rax
    20f1:	88 ff ff 
    20f4:	48 8b 4c 24 48       	mov    0x48(%rsp),%rcx
    20f9:	48 8b 04 c8          	mov    (%rax,%rcx,8),%rax
    20fd:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    2104:	39 a6 
  if (!per_vip_stats) {
    2106:	48 85 c0             	test   %rax,%rax
    2109:	74 4c                	je     2157 <balancer_ingress+0x2157>
    per_vip_stats->v2 += 1;
    210b:	48 83 c0 08          	add    $0x8,%rax
    210f:	eb 43                	jmp    2154 <balancer_ingress+0x2154>
    conn_rate_stats->v1 += 1;
    2111:	49 8b 07             	mov    (%r15),%rax
    2114:	48 ff c0             	inc    %rax
    2117:	49 89 07             	mov    %rax,(%r15)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    211a:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    2120:	77 2b                	ja     214d <balancer_ingress+0x214d>
  struct real_pos_lru new_dst_lru = {};
    2122:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    2129:	00 
    212a:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    2131:	00 00 
  new_dst_lru.pos = pckt->real_index;
    2133:	8b 44 24 38          	mov    0x38(%rsp),%eax
    2137:	89 04 24             	mov    %eax,(%rsp)
    213a:	48 8b 03             	mov    (%rbx),%rax
    213d:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    2142:	48 89 e2             	mov    %rsp,%rdx
    2145:	48 89 df             	mov    %rbx,%rdi
    2148:	31 c9                	xor    %ecx,%ecx
    214a:	ff 50 68             	call   *0x68(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    214d:	4c 89 f0             	mov    %r14,%rax
    2150:	48 83 c0 60          	add    $0x60,%rax
    2154:	48 ff 00             	incq   (%rax)
            quic_packets_stats->cid_routed += 1;
    2157:	49 ff 46 20          	incq   0x20(%r14)
  original_sport = pckt.flow.port16[0];
    215b:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
    2160:	89 44 24 40          	mov    %eax,0x40(%rsp)
    2164:	48 8b 74 24 48       	mov    0x48(%rsp),%rsi
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    2169:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
    216f:	0f 86 f1 f2 ff ff    	jbe    1466 <balancer_ingress+0x1466>
    2175:	e9 21 fe ff ff       	jmp    1f9b <balancer_ingress+0x1f9b>
    217a:	48 b8 10 11 54 4c 81 	movabs $0xffff88814c541110,%rax
    2181:	88 ff ff 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2184:	48 8b 18             	mov    (%rax),%rbx
    2187:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffa6395028,%rbx
    218e:	39 a6 
  if (!conn_rate_stats) {
    2190:	48 85 db             	test   %rbx,%rbx
    2193:	0f 84 9b 00 00 00    	je     2234 <balancer_ingress+0x2234>
    2199:	48 c7 c0 30 d6 69 a0 	mov    $0xffffffffa069d630,%rax
  *cur_time = bpf_ktime_get_ns();
    21a0:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    21a2:	48 89 c1             	mov    %rax,%rcx
    21a5:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    21a9:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    21b0:	72 44                	jb     21f6 <balancer_ingress+0x21f6>
    conn_rate_stats->v1 = 1;
    21b2:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    21b9:	48 89 43 08          	mov    %rax,0x8(%rbx)
    21bd:	eb 48                	jmp    2207 <balancer_ingress+0x2207>
      dst_lru->pos = pckt->real_index;
    21bf:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    21c1:	49 ff 46 58          	incq   0x58(%r14)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    21c5:	81 7c 24 78 ff 01 00 	cmpl   $0x1ff,0x78(%rsp)
    21cc:	00 
    21cd:	77 6f                	ja     223e <balancer_ingress+0x223e>
    21cf:	48 b8 00 41 54 6d 81 	movabs $0xffff88816d544100,%rax
    21d6:	88 ff ff 
    21d9:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
    21de:	48 8b 04 c8          	mov    (%rax,%rcx,8),%rax
    21e2:	65 48 03 04 25 28 50 	add    %gs:0xffffffffa6395028,%rax
    21e9:	39 a6 
  if (!per_vip_stats) {
    21eb:	48 85 c0             	test   %rax,%rax
    21ee:	74 4e                	je     223e <balancer_ingress+0x223e>
    per_vip_stats->v2 += 1;
    21f0:	48 83 c0 08          	add    $0x8,%rax
    21f4:	eb 45                	jmp    223b <balancer_ingress+0x223b>
    conn_rate_stats->v1 += 1;
    21f6:	48 8b 03             	mov    (%rbx),%rax
    21f9:	48 ff c0             	inc    %rax
    21fc:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    21ff:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    2205:	77 2d                	ja     2234 <balancer_ingress+0x2234>
  struct real_pos_lru new_dst_lru = {};
    2207:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
    220e:	00 
    220f:	48 c7 44 24 08 00 00 	movq   $0x0,0x8(%rsp)
    2216:	00 00 
  new_dst_lru.pos = pckt->real_index;
    2218:	8b 44 24 38          	mov    0x38(%rsp),%eax
    221c:	89 04 24             	mov    %eax,(%rsp)
    221f:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
    2224:	48 8b 07             	mov    (%rdi),%rax
    2227:	48 8d 74 24 10       	lea    0x10(%rsp),%rsi
    222c:	48 89 e2             	mov    %rsp,%rdx
    222f:	31 c9                	xor    %ecx,%ecx
    2231:	ff 50 68             	call   *0x68(%rax)
              quic_packets_stats->dst_not_found_in_lru += 1;
    2234:	4c 89 f0             	mov    %r14,%rax
    2237:	48 83 c0 60          	add    $0x60,%rax
    223b:	48 ff 00             	incq   (%rax)
            quic_packets_stats->cid_routed += 1;
    223e:	49 ff 46 20          	incq   0x20(%r14)
  original_sport = pckt.flow.port16[0];
    2242:	0f b7 44 24 30       	movzwl 0x30(%rsp),%eax
    2247:	89 84 24 84 00 00 00 	mov    %eax,0x84(%rsp)
    224e:	e9 4c f9 ff ff       	jmp    1b9f <balancer_ingress+0x1b9f>

Disassembly of section .ltext.jhash_2words:

0000000000002260 <jhash_2words>:

  return c;
}

static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval) {
  a += initval;
    2260:	f3 0f 1e fa          	endbr64
    2264:	81 c7 f7 c0 ad e0    	add    $0xe0adc0f7,%edi
  b += initval;
    226a:	81 c6 f7 c0 ad e0    	add    $0xe0adc0f7,%esi
  c += initval;
  __jhash_final(a, b, c);
    2270:	89 f0                	mov    %esi,%eax
    2272:	35 f7 c0 ad e0       	xor    $0xe0adc0f7,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    2277:	89 f1                	mov    %esi,%ecx
    2279:	c1 c1 0e             	rol    $0xe,%ecx
  __jhash_final(a, b, c);
    227c:	29 c8                	sub    %ecx,%eax
    227e:	31 c7                	xor    %eax,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    2280:	89 c1                	mov    %eax,%ecx
    2282:	c1 c1 0b             	rol    $0xb,%ecx
  __jhash_final(a, b, c);
    2285:	29 cf                	sub    %ecx,%edi
    2287:	31 fe                	xor    %edi,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    2289:	89 f9                	mov    %edi,%ecx
    228b:	c1 c1 19             	rol    $0x19,%ecx
  __jhash_final(a, b, c);
    228e:	29 ce                	sub    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    2290:	89 f1                	mov    %esi,%ecx
    2292:	c1 c1 10             	rol    $0x10,%ecx
  __jhash_final(a, b, c);
    2295:	31 f0                	xor    %esi,%eax
    2297:	29 c8                	sub    %ecx,%eax
    2299:	31 c7                	xor    %eax,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    229b:	89 c1                	mov    %eax,%ecx
    229d:	c1 c1 04             	rol    $0x4,%ecx
  __jhash_final(a, b, c);
    22a0:	29 cf                	sub    %ecx,%edi
    22a2:	31 fe                	xor    %edi,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    22a4:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    22a7:	29 fe                	sub    %edi,%esi
    22a9:	31 f0                	xor    %esi,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    22ab:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    22ae:	29 f0                	sub    %esi,%eax
  return c;
}

static inline u32 jhash_2words(u32 a, u32 b, u32 initval) {
  return __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 << 2));
    22b0:	c3                   	ret

Disassembly of section .ltext.jhash:

00000000000022c0 <jhash>:
    a += *(u32*)(k);
    22c0:	f3 0f 1e fa          	endbr64
    22c4:	8b 07                	mov    (%rdi),%eax
    b += *(u32*)(k + 4);
    22c6:	8b 57 04             	mov    0x4(%rdi),%edx
    22c9:	8d b2 ff c0 ad de    	lea    -0x21523f01(%rdx),%esi
    c += *(u32*)(k + 8);
    22cf:	44 8b 47 08          	mov    0x8(%rdi),%r8d
    __jhash_mix(a, b, c);
    22d3:	44 29 c0             	sub    %r8d,%eax
    c += *(u32*)(k + 8);
    22d6:	45 8d 88 ff c0 ad de 	lea    -0x21523f01(%r8),%r9d
  return (word << shift) | (word >> ((-shift) & 31));
    22dd:	41 c1 c1 04          	rol    $0x4,%r9d
    __jhash_mix(a, b, c);
    22e1:	41 31 c1             	xor    %eax,%r9d
    22e4:	44 29 ce             	sub    %r9d,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    22e7:	44 89 c9             	mov    %r9d,%ecx
    22ea:	c1 c1 06             	rol    $0x6,%ecx
    __jhash_mix(a, b, c);
    22ed:	31 f1                	xor    %esi,%ecx
    22ef:	41 8d 04 10          	lea    (%r8,%rdx,1),%eax
    22f3:	05 fe 81 5b bd       	add    $0xbd5b81fe,%eax
    22f8:	41 01 c1             	add    %eax,%r9d
    22fb:	42 8d 14 09          	lea    (%rcx,%r9,1),%edx
    22ff:	29 c8                	sub    %ecx,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    2301:	c1 c1 08             	rol    $0x8,%ecx
    __jhash_mix(a, b, c);
    2304:	31 c1                	xor    %eax,%ecx
    2306:	41 29 c9             	sub    %ecx,%r9d
  return (word << shift) | (word >> ((-shift) & 31));
    2309:	89 ce                	mov    %ecx,%esi
    230b:	c1 c6 10             	rol    $0x10,%esi
    __jhash_mix(a, b, c);
    230e:	44 31 ce             	xor    %r9d,%esi
    2311:	01 d1                	add    %edx,%ecx
    2313:	29 f2                	sub    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    2315:	41 89 f0             	mov    %esi,%r8d
    2318:	41 c1 c0 13          	rol    $0x13,%r8d
    __jhash_mix(a, b, c);
    231c:	41 31 d0             	xor    %edx,%r8d
    231f:	01 ce                	add    %ecx,%esi
    2321:	41 8d 04 30          	lea    (%r8,%rsi,1),%eax
    2325:	44 29 c1             	sub    %r8d,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    2328:	41 c1 c0 04          	rol    $0x4,%r8d
      a += (u32)k[3] << 24;
    232c:	0f b6 57 0f          	movzbl 0xf(%rdi),%edx
    2330:	c1 e2 18             	shl    $0x18,%edx
      a += (u32)k[2] << 16;
    2333:	44 0f b6 4f 0e       	movzbl 0xe(%rdi),%r9d
    2338:	41 c1 e1 10          	shl    $0x10,%r9d
      a += (u32)k[3] << 24;
    233c:	41 01 d1             	add    %edx,%r9d
      a += (u32)k[1] << 8;
    233f:	44 0f b6 57 0d       	movzbl 0xd(%rdi),%r10d
    2344:	41 c1 e2 08          	shl    $0x8,%r10d
      a += (u32)k[2] << 16;
    2348:	45 01 ca             	add    %r9d,%r10d
      a += k[0];
    234b:	0f b6 57 0c          	movzbl 0xc(%rdi),%edx
      a += (u32)k[1] << 8;
    234f:	44 01 d2             	add    %r10d,%edx
      a += k[0];
    2352:	01 f2                	add    %esi,%edx
    __jhash_mix(a, b, c);
    2354:	31 c1                	xor    %eax,%ecx
      __jhash_final(a, b, c);
    2356:	44 31 c1             	xor    %r8d,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    2359:	89 c6                	mov    %eax,%esi
    235b:	c1 c6 0e             	rol    $0xe,%esi
      __jhash_final(a, b, c);
    235e:	29 f1                	sub    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    2360:	89 ce                	mov    %ecx,%esi
    2362:	c1 c6 0b             	rol    $0xb,%esi
      __jhash_final(a, b, c);
    2365:	31 ca                	xor    %ecx,%edx
    2367:	29 f2                	sub    %esi,%edx
    2369:	31 d0                	xor    %edx,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    236b:	89 d6                	mov    %edx,%esi
    236d:	c1 c6 19             	rol    $0x19,%esi
      __jhash_final(a, b, c);
    2370:	29 f0                	sub    %esi,%eax
    2372:	31 c1                	xor    %eax,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    2374:	89 c6                	mov    %eax,%esi
    2376:	c1 c6 10             	rol    $0x10,%esi
      __jhash_final(a, b, c);
    2379:	29 f1                	sub    %esi,%ecx
    237b:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    237d:	89 ce                	mov    %ecx,%esi
    237f:	c1 c6 04             	rol    $0x4,%esi
      __jhash_final(a, b, c);
    2382:	29 f2                	sub    %esi,%edx
    2384:	31 d0                	xor    %edx,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    2386:	c1 c2 0e             	rol    $0xe,%edx
      __jhash_final(a, b, c);
    2389:	29 d0                	sub    %edx,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    238b:	89 c2                	mov    %eax,%edx
    238d:	c1 c2 18             	rol    $0x18,%edx
      __jhash_final(a, b, c);
    2390:	31 c8                	xor    %ecx,%eax
    2392:	29 d0                	sub    %edx,%eax
  return c;
    2394:	c3                   	ret

Disassembly of section license:

0000000000002395 <_license>:
    2395:	47 50                	rex.RXB push %r8
    2397:	4c                   	rex.WR
	...

Disassembly of section .maps:

00000000000023a0 <.maps>:
	...

Disassembly of section .debug_loclists:

0000000000000000 <.debug_loclists>:
  void* data = (void*)(long)ctx->data;
       0:	48 34 00             	rex.W xor $0x0,%al
       3:	00 05 00 08 00 9b    	add    %al,-0x64fff800(%rip)        # ffffffff9b000809 <server_id_map+0x36ff82917809>
       9:	01 00                	add    %eax,(%rax)
       b:	00 6c 06 00          	add    %ch,0x0(%rsi,%rax,1)
       f:	00 4e 07             	add    %cl,0x7(%rsi)
      12:	00 00                	add    %al,(%rax)
      14:	6c                   	insb   (%dx),%es:(%rdi)
      15:	07                   	(bad)
      16:	00 00                	add    %al,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
      18:	ad                   	lods   %ds:(%rsi),%eax
      19:	07                   	(bad)
      1a:	00 00                	add    %al,(%rax)
  if (data + nh_off > data_end) {
      1c:	cb                   	lret
      1d:	07                   	(bad)
      1e:	00 00                	add    %al,(%rax)
      20:	d5                   	(bad)
      21:	07                   	(bad)
      22:	00 00                	add    %al,(%rax)
      24:	67 08 00             	or     %al,(%eax)
      27:	00 c9                	add    %cl,%cl
      29:	08 00                	or     %al,(%rax)
      2b:	00 2b                	add    %ch,(%rbx)
      2d:	09 00                	or     %eax,(%rax)
  eth_proto = eth->h_proto; 
      2f:	00 5e 09             	add    %bl,0x9(%rsi)
      32:	00 00                	add    %al,(%rax)
      34:	ad                   	lods   %ds:(%rsi),%eax
      35:	09 00                	or     %eax,(%rax)
      37:	00 0c 0a             	add    %cl,(%rdx,%rcx,1)
  if (eth_proto == BE_ETH_P_IP) {
      3a:	00 00                	add    %al,(%rax)
      3c:	6f                   	outsl  %ds:(%rsi),(%dx)
      3d:	0a 00                	or     (%rax),%al
      3f:	00 9c 0a 00 00 b1 0a 	add    %bl,0xab10000(%rdx,%rcx,1)
      46:	00 00                	add    %al,(%rax)
      48:	c4                   	(bad)
      49:	0a 00                	or     (%rax),%al
      4b:	00 d5                	add    %dl,%ch
  struct packet_description pckt = {};
      4d:	0a 00                	or     (%rax),%al
      4f:	00 e6                	add    %ah,%dh
      51:	0a 00                	or     (%rax),%al
      53:	00 f9                	add    %bh,%cl
      55:	0a 00                	or     (%rax),%al
      57:	00 0c 0b             	add    %cl,(%rbx,%rcx,1)
      5a:	00 00                	add    %al,(%rax)
      5c:	1d 0b 00 00 2e       	sbb    $0x2e00000b,%eax
      61:	0b 00                	or     (%rax),%eax
      63:	00 43 0b             	add    %al,0xb(%rbx)
      66:	00 00                	add    %al,(%rax)
      68:	58                   	pop    %rax
      69:	0b 00                	or     (%rax),%eax
      6b:	00 72 0b             	add    %dh,0xb(%rdx)
      6e:	00 00                	add    %al,(%rax)
      70:	84 0b                	test   %cl,(%rbx)
      72:	00 00                	add    %al,(%rax)
      74:	b4 0b                	mov    $0xb,%ah
      76:	00 00                	add    %al,(%rax)
      78:	e4 0b                	in     $0xb,%al
      7a:	00 00                	add    %al,(%rax)
      7c:	7c 0c                	jl     8a <balancer_ingress+0x8a>
      7e:	00 00                	add    %al,(%rax)
      80:	cf                   	iret
      81:	0c 00                	or     $0x0,%al
  struct vip_definition vip = {};
      83:	00 22                	add    %ah,(%rdx)
      85:	0d 00 00 56 0d       	or     $0xd560000,%eax
      8a:	00 00                	add    %al,(%rax)
      8c:	ad                   	lods   %ds:(%rsi),%eax
      8d:	0d 00 00 15 0e       	or     $0xe150000,%eax
      92:	00 00                	add    %al,(%rax)
      94:	68 0e 00 00 9e       	push   $0xffffffff9e00000e
      99:	0e                   	(bad)
      9a:	00 00                	add    %al,(%rax)
      9c:	b3 0e                	mov    $0xe,%bl
    if (iph + 1 > data_end) {
      9e:	00 00                	add    %al,(%rax)
      a0:	c6                   	(bad)
      a1:	0e                   	(bad)
      a2:	00 00                	add    %al,(%rax)
      a4:	d7                   	xlat   %ds:(%rbx)
      a5:	0e                   	(bad)
      a6:	00 00                	add    %al,(%rax)
      a8:	e8 0e 00 00 fb       	call   fffffffffb0000bb <server_id_map+0x36ffe29170bb>
    if (iph->ihl != 5) {
      ad:	0e                   	(bad)
      ae:	00 00                	add    %al,(%rax)
      b0:	0e                   	(bad)
      b1:	0f 00 00             	sldt   (%rax)
      b4:	23 0f                	and    (%rdi),%ecx
      b6:	00 00                	add    %al,(%rax)
    pckt->tos = iph->tos;
      b8:	34 0f                	xor    $0xf,%al
      ba:	00 00                	add    %al,(%rax)
      bc:	45 0f 00 00          	rex.RB sldt (%r8)
    *protocol = iph->protocol;
      c0:	5a                   	pop    %rdx
      c1:	0f 00 00             	sldt   (%rax)
      c4:	6f                   	outsl  %ds:(%rsi),(%dx)
    pckt->flow.proto = *protocol;
      c5:	0f 00 00             	sldt   (%rax)
      c8:	89 0f                	mov    %ecx,(%rdi)
    if (iph->frag_off & PCKT_FRAGMENTED) {
      ca:	00 00                	add    %al,(%rax)
      cc:	dd 0f                	fisttpll (%rdi)
      ce:	00 00                	add    %al,(%rax)
      d0:	0a 10                	or     (%rax),%dl
      d2:	00 00                	add    %al,(%rax)
      d4:	1b 10                	sbb    (%rax),%edx
      d6:	00 00                	add    %al,(%rax)
      d8:	2c 10                	sub    $0x10,%al
      da:	00 00                	add    %al,(%rax)
      dc:	41 10 00             	adc    %al,(%r8)
    if (*protocol == IPPROTO_ICMP) {
      df:	00 56 10             	add    %dl,0x10(%rsi)
      e2:	00 00                	add    %al,(%rax)
      e4:	60                   	(bad)
      e5:	10 00                	adc    %al,(%rax)
      e7:	00 71 10             	add    %dh,0x10(%rcx)
  if (icmp_hdr + 1 > data_end) {
      ea:	00 00                	add    %al,(%rax)
      ec:	82                   	(bad)
      ed:	10 00                	adc    %al,(%rax)
      ef:	00 97 10 00 00 ac    	add    %dl,-0x53fffff0(%rdi)
  if (icmp_hdr->type == ICMP_ECHO) {
      f5:	10 00                	adc    %al,(%rax)
      f7:	00 c6                	add    %al,%dh
      f9:	10 00                	adc    %al,(%rax)
      fb:	00 d8                	add    %bl,%al
      fd:	10 00                	adc    %al,(%rax)
      ff:	00 08                	add    %cl,(%rax)
     101:	11 00                	adc    %eax,(%rax)
     103:	00 2f                	add    %ch,(%rdi)
     105:	11 00                	adc    %eax,(%rax)
     107:	00 39                	add    %bh,(%rcx)
     109:	11 00                	adc    %eax,(%rax)
     10b:	00 9f 11 00 00 c5    	add    %bl,-0x3affffef(%rdi)
  icmp_hdr->type = ICMP_ECHOREPLY;
     111:	11 00                	adc    %eax,(%rax)
     113:	00 d6                	add    %dl,%dh
  icmp_hdr->checksum += 0x0008;
     115:	11 00                	adc    %eax,(%rax)
     117:	00 e7                	add    %ah,%bh
     119:	11 00                	adc    %eax,(%rax)
     11b:	00 fc                	add    %bh,%ah
  iph->ttl = DEFAULT_TTL;
     11d:	11 00                	adc    %eax,(%rax)
     11f:	00 11                	add    %dl,(%rcx)
     121:	12 00                	adc    (%rax),%al
     123:	00 1b                	add    %bl,(%rbx)
     125:	12 00                	adc    (%rax),%al
     127:	00 2c 12             	add    %ch,(%rdx,%rdx,1)
  iph->daddr = iph->saddr;
     12a:	00 00                	add    %al,(%rax)
     12c:	3d 12 00 00 52       	cmp    $0x52000012,%eax
  iph->saddr = tmp_addr;
     131:	12 00                	adc    (%rax),%al
    *csum += *next_iph_u16++;
     133:	00 67 12             	add    %ah,0x12(%rdi)
     136:	00 00                	add    %al,(%rax)
     138:	81 12 00 00 8b 12    	adcl   $0x128b0000,(%rdx)
     13e:	00 00                	add    %al,(%rax)
     140:	9d                   	popf
     141:	12 00                	adc    (%rax),%al
     143:	00 a7 12 00 00 b1    	add    %ah,-0x4effffee(%rdi)
     149:	12 00                	adc    (%rax),%al
     14b:	00 bf 12 00 00 ca    	add    %bh,-0x35ffffee(%rdi)
     151:	12 00                	adc    (%rax),%al
     153:	00 df                	add    %bl,%bh
     155:	12 00                	adc    (%rax),%al
     157:	00 f2                	add    %dh,%dl
  struct packet_description pckt = {};
     159:	12 00                	adc    (%rax),%al
     15b:	00 04 13             	add    %al,(%rbx,%rdx,1)
     15e:	00 00                	add    %al,(%rax)
     160:	0e                   	(bad)
     161:	13 00                	adc    (%rax),%eax
     163:	00 1f                	add    %bl,(%rdi)
     165:	13 00                	adc    (%rax),%eax
     167:	00 31                	add    %dh,(%rcx)
     169:	13 00                	adc    (%rax),%eax
     16b:	00 3b                	add    %bh,(%rbx)
     16d:	13 00                	adc    (%rax),%eax
     16f:	00 47 13             	add    %al,0x13(%rdi)
     172:	00 00                	add    %al,(%rax)
     174:	51                   	push   %rcx
     175:	13 00                	adc    (%rax),%eax
     177:	00 5e 13             	add    %bl,0x13(%rsi)
     17a:	00 00                	add    %al,(%rax)
     17c:	70 13                	jo     191 <balancer_ingress+0x191>
     17e:	00 00                	add    %al,(%rax)
     180:	7a 13                	jp     195 <balancer_ingress+0x195>
     182:	00 00                	add    %al,(%rax)
     184:	8c 13                	mov    %ss,(%rbx)
     186:	00 00                	add    %al,(%rax)
     188:	96                   	xchg   %eax,%esi
     189:	13 00                	adc    (%rax),%eax
     18b:	00 a0 13 00 00 aa    	add    %ah,-0x55ffffed(%rax)
  struct vip_definition vip = {};
     191:	13 00                	adc    (%rax),%eax
     193:	00 b5 13 00 00 ca    	add    %dh,-0x35ffffed(%rbp)
     199:	13 00                	adc    (%rax),%eax
     19b:	00 dd                	add    %bl,%ch
     19d:	13 00                	adc    (%rax),%eax
     19f:	00 ef                	add    %ch,%bh
     1a1:	13 00                	adc    (%rax),%eax
     1a3:	00 f9                	add    %bh,%cl
     1a5:	13 00                	adc    (%rax),%eax
     1a7:	00 0a                	add    %cl,(%rdx)
    if (ip6h + 1 > data_end) {
     1a9:	14 00                	adc    $0x0,%al
     1ab:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
     1ae:	00 00                	add    %al,(%rax)
     1b0:	26 14 00             	es adc $0x0,%al
     1b3:	00 32                	add    %dh,(%rdx)
    *protocol = ip6h->nexthdr;
     1b5:	14 00                	adc    $0x0,%al
     1b7:	00 3c 14             	add    %bh,(%rsp,%rdx,1)
    pckt->flow.proto = *protocol;
     1ba:	00 00                	add    %al,(%rax)
     1bc:	46 14 00             	rex.RX adc $0x0,%al
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1bf:	00 53 14             	add    %dl,0x14(%rbx)
     1c2:	00 00                	add    %al,(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1c4:	65 14 00             	gs adc $0x0,%al
     1c7:	00 6f 14             	add    %ch,0x14(%rdi)
     1ca:	00 00                	add    %al,(%rax)
     1cc:	81 14 00 00 8b 14 00 	adcl   $0x148b00,(%rax,%rax,1)
     1d3:	00 95 14 00 00 9f    	add    %dl,-0x60ffffec(%rbp)
    if (*protocol == IPPROTO_FRAGMENT) {
     1d9:	14 00                	adc    $0x0,%al
     1db:	00 a9 14 00 00 bb    	add    %ch,-0x44ffffec(%rcx)
     1e1:	14 00                	adc    $0x0,%al
     1e3:	00 c5                	add    %al,%ch
     1e5:	14 00                	adc    $0x0,%al
     1e7:	00 da                	add    %bl,%dl
     1e9:	14 00                	adc    $0x0,%al
  if (icmp_hdr + 1 > data_end) {
     1eb:	00 ec                	add    %ch,%ah
     1ed:	14 00                	adc    $0x0,%al
     1ef:	00 f6                	add    %dh,%dh
     1f1:	14 00                	adc    $0x0,%al
     1f3:	00 5b 15             	add    %bl,0x15(%rbx)
     1f6:	00 00                	add    %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1f8:	9a                   	(bad)
     1f9:	15 00 00 ac 15       	adc    $0x15ac0000,%eax
     1fe:	00 00                	add    %al,(%rax)
     200:	f5                   	cmc
     201:	15 00 00 11 16       	adc    $0x16110000,%eax
     206:	00 00                	add    %al,(%rax)
     208:	3a 16                	cmp    (%rsi),%dl
     20a:	00 00                	add    %al,(%rax)
     20c:	63 16                	movsxd (%rsi),%edx
     20e:	00 00                	add    %al,(%rax)
     210:	7d 16                	jge    228 <balancer_ingress+0x228>
     212:	00 00                	add    %al,(%rax)
     214:	90                   	nop
     215:	16                   	(bad)
     216:	00 00                	add    %al,(%rax)
     218:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     219:	16                   	(bad)
     21a:	00 00                	add    %al,(%rax)
     21c:	ba 16 00 00 cc       	mov    $0xcc000016,%edx
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
     221:	16                   	(bad)
     222:	00 00                	add    %al,(%rax)
  icmp_hdr->icmp6_cksum -= 0x0001;
     224:	d6                   	(bad)
     225:	16                   	(bad)
     226:	00 00                	add    %al,(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
     228:	1c 17                	sbb    $0x17,%al
     22a:	00 00                	add    %al,(%rax)
     22c:	2e 17                	cs (bad)
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
     22e:	00 00                	add    %al,(%rax)
     230:	38 17                	cmp    %dl,(%rdi)
     232:	00 00                	add    %al,(%rax)
     234:	4d 17                	rex.WRB (bad)
     236:	00 00                	add    %al,(%rax)
     238:	5f                   	pop    %rdi
     239:	17                   	(bad)
     23a:	00 00                	add    %al,(%rax)
     23c:	6a 17                	push   $0x17
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
     23e:	00 00                	add    %al,(%rax)
     240:	7f 17                	jg     259 <balancer_ingress+0x259>
     242:	00 00                	add    %al,(%rax)
     244:	92                   	xchg   %eax,%edx
     245:	17                   	(bad)
     246:	00 00                	add    %al,(%rax)
     248:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     249:	17                   	(bad)
     24a:	00 00                	add    %al,(%rax)
     24c:	ae                   	scas   %es:(%rdi),%al
     24d:	17                   	(bad)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
     24e:	00 00                	add    %al,(%rax)
     250:	bf 17 00 00 d1       	mov    $0xd1000017,%edi
     255:	17                   	(bad)
     256:	00 00                	add    %al,(%rax)
     258:	db 17                	fistl  (%rdi)
     25a:	00 00                	add    %al,(%rax)
     25c:	e7 17                	out    %eax,$0x17
     25e:	00 00                	add    %al,(%rax)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     260:	f1                   	int1
     261:	17                   	(bad)
     262:	00 00                	add    %al,(%rax)
     264:	fb                   	sti
     265:	17                   	(bad)
     266:	00 00                	add    %al,(%rax)
     268:	05 18 00 00 12       	add    $0x12000018,%eax
     26d:	18 00                	sbb    %al,(%rax)
     26f:	00 24 18             	add    %ah,(%rax,%rbx,1)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     272:	00 00                	add    %al,(%rax)
     274:	2e 18 00             	cs sbb %al,(%rax)
     277:	00 40 18             	add    %al,0x18(%rax)
     27a:	00 00                	add    %al,(%rax)
     27c:	4a 18 00             	rex.WX sbb %al,(%rax)
     27f:	00 54 18 00          	add    %dl,0x0(%rax,%rbx,1)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     283:	00 5e 18             	add    %bl,0x18(%rsi)
     286:	00 00                	add    %al,(%rax)
     288:	70 18                	jo     2a2 <balancer_ingress+0x2a2>
     28a:	00 00                	add    %al,(%rax)
     28c:	7a 18                	jp     2a6 <balancer_ingress+0x2a6>
     28e:	00 00                	add    %al,(%rax)
     290:	84 18                	test   %bl,(%rax)
     292:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     294:	92                   	xchg   %eax,%edx
     295:	18 00                	sbb    %al,(%rax)
     297:	00 9d 18 00 00 b2    	add    %bl,-0x4dffffe8(%rbp)
     29d:	18 00                	sbb    %al,(%rax)
     29f:	00 c5                	add    %al,%ch
     2a1:	18 00                	sbb    %al,(%rax)
     2a3:	00 d7                	add    %dl,%bh
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2a5:	18 00                	sbb    %al,(%rax)
     2a7:	00 e1                	add    %ah,%cl
     2a9:	18 00                	sbb    %al,(%rax)
     2ab:	00 f2                	add    %dh,%dl
     2ad:	18 00                	sbb    %al,(%rax)
     2af:	00 04 19             	add    %al,(%rcx,%rbx,1)
     2b2:	00 00                	add    %al,(%rax)
     2b4:	0e                   	(bad)
     2b5:	19 00                	sbb    %eax,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
     2b7:	00 18                	add    %bl,(%rax)
     2b9:	19 00                	sbb    %eax,(%rax)
     2bb:	00 25 19 00 00 37    	add    %ah,0x37000019(%rip)        # 370002da <_license+0x36ffdf45>
  if (icmp_hdr + 1 > data_end) {
     2c1:	19 00                	sbb    %eax,(%rax)
     2c3:	00 41 19             	add    %al,0x19(%rcx)
     2c6:	00 00                	add    %al,(%rax)
     2c8:	53                   	push   %rbx
     2c9:	19 00                	sbb    %eax,(%rax)
     2cb:	00 5d 19             	add    %bl,0x19(%rbp)
  if (icmp_hdr->type == ICMP_ECHO) {
     2ce:	00 00                	add    %al,(%rax)
     2d0:	67 19 00             	sbb    %eax,(%eax)
     2d3:	00 71 19             	add    %dh,0x19(%rcx)
     2d6:	00 00                	add    %al,(%rax)
     2d8:	7b 19                	jnp    2f3 <balancer_ingress+0x2f3>
     2da:	00 00                	add    %al,(%rax)
     2dc:	8d 19                	lea    (%rcx),%ebx
     2de:	00 00                	add    %al,(%rax)
     2e0:	97                   	xchg   %eax,%edi
     2e1:	19 00                	sbb    %eax,(%rax)
     2e3:	00 fc                	add    %bh,%ah
     2e5:	19 00                	sbb    %eax,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
     2e7:	00 4f 1a             	add    %cl,0x1a(%rdi)
     2ea:	00 00                	add    %al,(%rax)
  icmp_hdr->checksum += 0x0008;
     2ec:	61                   	(bad)
     2ed:	1a 00                	sbb    (%rax),%al
     2ef:	00 b1 1a 00 00 cd    	add    %dh,-0x32ffffe6(%rcx)
  iph->ttl = DEFAULT_TTL;
     2f5:	1a 00                	sbb    (%rax),%al
     2f7:	00 f6                	add    %dh,%dh
     2f9:	1a 00                	sbb    (%rax),%al
     2fb:	00 1f                	add    %bl,(%rdi)
     2fd:	1b 00                	sbb    (%rax),%eax
  iph->daddr = iph->saddr;
     2ff:	00 42 1b             	add    %al,0x1b(%rdx)
     302:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
     304:	55                   	push   %rbp
     305:	1b 00                	sbb    (%rax),%eax
     307:	00 6c 1b 00          	add    %ch,0x0(%rbx,%rbx,1)
     30b:	00 7f 1b             	add    %bh,0x1b(%rdi)
     30e:	00 00                	add    %al,(%rax)
     310:	91                   	xchg   %eax,%ecx
     311:	1b 00                	sbb    (%rax),%eax
     313:	00 9b 1b 00 00 e4    	add    %bl,-0x1bffffe5(%rbx)
     319:	1b 00                	sbb    (%rax),%eax
     31b:	00 07                	add    %al,(%rdi)
     31d:	1c 00                	sbb    $0x0,%al
     31f:	00 19                	add    %bl,(%rcx)
     321:	1c 00                	sbb    $0x0,%al
     323:	00 38                	add    %bh,(%rax)
     325:	1c 00                	sbb    $0x0,%al
     327:	00 42 1c             	add    %al,0x1c(%rdx)
     32a:	00 00                	add    %al,(%rax)
     32c:	5a                   	pop    %rdx
     32d:	1c 00                	sbb    $0x0,%al
     32f:	00 75 1c             	add    %dh,0x1c(%rbp)
     332:	00 00                	add    %al,(%rax)
     334:	93                   	xchg   %eax,%ebx
     335:	1c 00                	sbb    $0x0,%al
     337:	00 03                	add    %al,(%rbx)
     339:	1e                   	(bad)
     33a:	00 00                	add    %al,(%rax)
     33c:	21 1e                	and    %ebx,(%rsi)
     33e:	00 00                	add    %al,(%rax)
    if (csum >> 16)
     340:	3f                   	(bad)
     341:	1e                   	(bad)
     342:	00 00                	add    %al,(%rax)
     344:	76 1e                	jbe    364 <balancer_ingress+0x364>
     346:	00 00                	add    %al,(%rax)
     348:	ab                   	stos   %eax,%es:(%rdi)
     349:	1e                   	(bad)
     34a:	00 00                	add    %al,(%rax)
     34c:	bd 1e 00 00 cf       	mov    $0xcf00001e,%ebp
     351:	1e                   	(bad)
     352:	00 00                	add    %al,(%rax)
     354:	d9 1e                	fstps  (%rsi)
     356:	00 00                	add    %al,(%rax)
     358:	04 1f                	add    $0x1f,%al
     35a:	00 00                	add    %al,(%rax)
     35c:	16                   	(bad)
     35d:	1f                   	(bad)
     35e:	00 00                	add    %al,(%rax)
     360:	3c 1f                	cmp    $0x1f,%al
     362:	00 00                	add    %al,(%rax)
     364:	46 1f                	rex.RX (bad)
     366:	00 00                	add    %al,(%rax)
     368:	5e                   	pop    %rsi
     369:	1f                   	(bad)
     36a:	00 00                	add    %al,(%rax)
     36c:	79 1f                	jns    38d <balancer_ingress+0x38d>
     36e:	00 00                	add    %al,(%rax)
     370:	97                   	xchg   %eax,%edi
     371:	1f                   	(bad)
     372:	00 00                	add    %al,(%rax)
     374:	07                   	(bad)
     375:	21 00                	and    %eax,(%rax)
     377:	00 25 21 00 00 43    	add    %ah,0x43000021(%rip)        # 4300039e <_license+0x42ffe009>
     37d:	21 00                	and    %eax,(%rax)
     37f:	00 7a 21             	add    %bh,0x21(%rdx)
     382:	00 00                	add    %al,(%rax)
     384:	af                   	scas   %es:(%rdi),%eax
     385:	21 00                	and    %eax,(%rax)
     387:	00 c1                	add    %al,%cl
     389:	21 00                	and    %eax,(%rax)
  return ~csum;
     38b:	00 cb                	add    %cl,%bl
  iph->check = csum;
     38d:	21 00                	and    %eax,(%rax)
     38f:	00 e1                	add    %ah,%cl
     391:	22 00                	and    (%rax),%al
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     393:	00 f3                	add    %dh,%bl
     395:	22 00                	and    (%rax),%al
     397:	00 fd                	add    %bh,%ch
     399:	22 00                	and    (%rax),%al
     39b:	00 13                	add    %dl,(%rbx)
     39d:	24 00                	and    $0x0,%al
     39f:	00 25 24 00 00 2f    	add    %ah,0x2f000024(%rip)        # 2f0003c9 <_license+0x2effe034>
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     3a5:	24 00                	and    $0x0,%al
     3a7:	00 3b                	add    %bh,(%rbx)
     3a9:	24 00                	and    $0x0,%al
     3ab:	00 a2 24 00 00 b3    	add    %ah,-0x4cffffdc(%rdx)
     3b1:	24 00                	and    $0x0,%al
     3b3:	00 be 24 00 00 c9    	add    %bh,-0x36ffffdc(%rsi)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     3b9:	24 00                	and    $0x0,%al
     3bb:	00 e7                	add    %ah,%bh
     3bd:	24 00                	and    $0x0,%al
     3bf:	00 ff                	add    %bh,%bh
     3c1:	24 00                	and    $0x0,%al
     3c3:	00 10                	add    %dl,(%rax)
     3c5:	25 00 00 1c 25       	and    $0x251c0000,%eax
     3ca:	00 00                	add    %al,(%rax)
     3cc:	31 25 00 00 46 25    	xor    %esp,0x25460000(%rip)        # 254603d2 <_license+0x2545e03d>
     3d2:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_IPIP) {
     3d4:	59                   	pop    %rcx
     3d5:	25 00 00 71 25       	and    $0x25710000,%eax
     3da:	00 00                	add    %al,(%rax)
     3dc:	82                   	(bad)
     3dd:	25 00 00 8c 25       	and    $0x258c0000,%eax
     3e2:	00 00                	add    %al,(%rax)
     3e4:	96                   	xchg   %eax,%esi
     3e5:	25 00 00 a7 25       	and    $0x25a70000,%eax
     3ea:	00 00                	add    %al,(%rax)
     3ec:	b9 25 00 00 c3       	mov    $0xc3000025,%ecx
     3f1:	25 00 00 d5 25       	and    $0x25d50000,%eax
     3f6:	00 00                	add    %al,(%rax)
     3f8:	df 25 00 00 e9 25    	fbld   0x25e90000(%rip)        # 25e903fe <_license+0x25e8e069>
  if (is_ipv6) {
     3fe:	00 00                	add    %al,(%rax)
  tcp = data + off;
     400:	f3 25 00 00 fd 25    	repz and $0x25fd0000,%eax
  if (tcp + 1 > data_end) {
     406:	00 00                	add    %al,(%rax)
     408:	07                   	(bad)
     409:	26 00 00             	es add %al,(%rax)
     40c:	19 26                	sbb    %esp,(%rsi)
     40e:	00 00                	add    %al,(%rax)
     410:	23 26                	and    (%rsi),%esp
  if (tcp->syn) {
     412:	00 00                	add    %al,(%rax)
     414:	45                   	rex.RB
     415:	26 00 00             	es add %al,(%rax)
     418:	60                   	(bad)
     419:	26 00 00             	es add %al,(%rax)
    pckt->flags |= F_SYN_SET;
     41c:	81 26 00 00 9c 26    	andl   $0x269c0000,(%rsi)
     422:	00 00                	add    %al,(%rax)
     424:	ad                   	lods   %ds:(%rsi),%eax
      pckt->flow.src = iph->saddr;
     425:	26 00 00             	es add %al,(%rax)
     428:	bf 26 00 00 cc       	mov    $0xcc000026,%edi
      pckt->flow.dst = iph->daddr;
     42d:	26 00 00             	es add %al,(%rax)
     430:	d7                   	xlat   %ds:(%rbx)
     431:	26 00 00             	es add %al,(%rax)
     434:	ee                   	out    %al,(%dx)
  if (protocol == IPPROTO_ICMPV6) {
     435:	26 00 00             	es add %al,(%rax)
     438:	f9                   	stc
     439:	26 00 00             	es add %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
     43c:	03 27                	add    (%rdi),%esp
     43e:	00 00                	add    %al,(%rax)
     440:	0d 27 00 00 17       	or     $0x17000027,%eax
     445:	27                   	(bad)
     446:	00 00                	add    %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     448:	21 27                	and    %esp,(%rdi)
     44a:	00 00                	add    %al,(%rax)
     44c:	2d 27 00 00 44       	sub    $0x44000027,%eax
     451:	27                   	(bad)
     452:	00 00                	add    %al,(%rax)
     454:	4e 27                	rex.WRX (bad)
     456:	00 00                	add    %al,(%rax)
     458:	87 27                	xchg   %esp,(%rdi)
     45a:	00 00                	add    %al,(%rax)
     45c:	c0 27 00             	shlb   $0x0,(%rdi)
     45f:	00 d2                	add    %dl,%dl
     461:	27                   	(bad)
     462:	00 00                	add    %al,(%rax)
     464:	dc 27                	fsubl  (%rdi)
     466:	00 00                	add    %al,(%rax)
     468:	f1                   	int1
     469:	27                   	(bad)
     46a:	00 00                	add    %al,(%rax)
     46c:	04 28                	add    $0x28,%al
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     46e:	00 00                	add    %al,(%rax)
     470:	19 28                	sbb    %ebp,(%rax)
     472:	00 00                	add    %al,(%rax)
     474:	52                   	push   %rdx
     475:	28 00                	sub    %al,(%rax)
       sizeof(struct icmp6hdr)) > data_end) {
     477:	00 65 28             	add    %ah,0x28(%rbp)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     47a:	00 00                	add    %al,(%rax)
     47c:	7f 28                	jg     4a6 <balancer_ingress+0x4a6>
     47e:	00 00                	add    %al,(%rax)
     480:	91                   	xchg   %eax,%ecx
     481:	28 00                	sub    %al,(%rax)
     483:	00 9b 28 00 00 ae    	add    %bl,-0x51ffffd8(%rbx)
     489:	28 00                	sub    %al,(%rax)
     48b:	00 b8 28 00 00 d0    	add    %bh,-0x2fffffd8(%rax)
     491:	28 00                	sub    %al,(%rax)
     493:	00 db                	add    %bl,%bl
     495:	28 00                	sub    %al,(%rax)
     497:	00 e6                	add    %ah,%dh
     499:	28 00                	sub    %al,(%rax)
     49b:	00 f0                	add    %dh,%al
     49d:	28 00                	sub    %al,(%rax)
     49f:	00 0a                	add    %cl,(%rdx)
     4a1:	29 00                	sub    %eax,(%rax)
     4a3:	00 41 29             	add    %al,0x29(%rcx)
     4a6:	00 00                	add    %al,(%rax)
     4a8:	53                   	push   %rbx
     4a9:	29 00                	sub    %eax,(%rax)
     4ab:	00 5d 29             	add    %bl,0x29(%rbp)
     4ae:	00 00                	add    %al,(%rax)
  tcp = data + off;
     4b0:	6f                   	outsl  %ds:(%rsi),(%dx)
     4b1:	29 00                	sub    %eax,(%rax)
     4b3:	00 79 29             	add    %bh,0x29(%rcx)
     4b6:	00 00                	add    %al,(%rax)
     4b8:	8b 29                	mov    (%rcx),%ebp
  if (tcp + 1 > data_end) {
     4ba:	00 00                	add    %al,(%rax)
     4bc:	95                   	xchg   %eax,%ebp
     4bd:	29 00                	sub    %eax,(%rax)
     4bf:	00 b0 29 00 00 ba    	add    %dh,-0x45ffffd7(%rax)
     4c5:	29 00                	sub    %eax,(%rax)
  if (tcp->syn) {
     4c7:	00 c4                	add    %al,%ah
     4c9:	29 00                	sub    %eax,(%rax)
     4cb:	00 ce                	add    %cl,%dh
     4cd:	29 00                	sub    %eax,(%rax)
     4cf:	00 d8                	add    %bl,%al
    pckt->flags |= F_SYN_SET;
     4d1:	29 00                	sub    %eax,(%rax)
     4d3:	00 e4                	add    %ah,%ah
     4d5:	29 00                	sub    %eax,(%rax)
     4d7:	00 f0                	add    %dh,%al
     4d9:	29 00                	sub    %eax,(%rax)
     4db:	00 1a                	add    %bl,(%rdx)
     4dd:	2a 00                	sub    (%rax),%al
     4df:	00 24 2a             	add    %ah,(%rdx,%rbp,1)
     4e2:	00 00                	add    %al,(%rax)
     4e4:	2e 2a 00             	cs sub (%rax),%al
        bpf_map_lookup_elem(&stats, &stats_key);
     4e7:	00 38                	add    %bh,(%rax)
     4e9:	2a 00                	sub    (%rax),%al
     4eb:	00 44 2a 00          	add    %al,0x0(%rdx,%rbp,1)
     4ef:	00 ab 2a 00 00 bc    	add    %ch,-0x43ffffd6(%rbx)
    if (!icmp_ptb_v6_stats) {
     4f5:	2a 00                	sub    (%rax),%al
     4f7:	00 c7                	add    %al,%bh
     4f9:	2a 00                	sub    (%rax),%al
    icmp_ptb_v6_stats->v1 += 1;
     4fb:	00 d2                	add    %dl,%dl
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4fd:	2a 00                	sub    (%rax),%al
     4ff:	00 f0                	add    %dh,%al
     501:	2a 00                	sub    (%rax),%al
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     503:	00 0e                	add    %cl,(%rsi)
     505:	2b 00                	sub    (%rax),%eax
     507:	00 1f                	add    %bl,(%rdi)
     509:	2b 00                	sub    (%rax),%eax
      icmp_ptb_v6_stats->v2 += 1;
     50b:	00 2b                	add    %ch,(%rbx)
     50d:	2b 00                	sub    (%rax),%eax
  if (ip6h + 1 > data_end) {
     50f:	00 40 2b             	add    %al,0x2b(%rax)
     512:	00 00                	add    %al,(%rax)
     514:	55                   	push   %rbp
     515:	2b 00                	sub    (%rax),%eax
     517:	00 68 2b             	add    %ch,0x2b(%rax)
     51a:	00 00                	add    %al,(%rax)
  pckt->flow.proto = ip6h->nexthdr;
     51c:	80 2b 00             	subb   $0x0,(%rbx)
     51f:	00 91 2b 00 00 9b    	add    %dl,-0x64ffffd5(%rcx)
  pckt->flags |= F_ICMP;
     525:	2b 00                	sub    (%rax),%eax
     527:	00 a5 2b 00 00 b7    	add    %ah,-0x48ffffd5(%rbp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     52d:	2b 00                	sub    (%rax),%eax
     52f:	00 c1                	add    %al,%cl
     531:	2b 00                	sub    (%rax),%eax
     533:	00 d3                	add    %dl,%bl
     535:	2b 00                	sub    (%rax),%eax
     537:	00 dd                	add    %bl,%ch
     539:	2b 00                	sub    (%rax),%eax
     53b:	00 e7                	add    %ah,%bh
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     53d:	2b 00                	sub    (%rax),%eax
     53f:	00 f1                	add    %dh,%cl
     541:	2b 00                	sub    (%rax),%eax
     543:	00 03                	add    %al,(%rbx)
     545:	2c 00                	sub    $0x0,%al
     547:	00 0d 2c 00 00 1f    	add    %cl,0x1f00002c(%rip)        # 1f000579 <_license+0x1effe1e4>
     54d:	2c 00                	sub    $0x0,%al
     54f:	00 30                	add    %dh,(%rax)
     551:	2c 00                	sub    $0x0,%al
     553:	00 42 2c             	add    %al,0x2c(%rdx)
     556:	00 00                	add    %al,(%rax)
     558:	4f 2c 00             	rex.WRXB sub $0x0,%al
     55b:	00 5a 2c             	add    %bl,0x2c(%rdx)
     55e:	00 00                	add    %al,(%rax)
     560:	71 2c                	jno    58e <balancer_ingress+0x58e>
     562:	00 00                	add    %al,(%rax)
     564:	7c 2c                	jl     592 <balancer_ingress+0x592>
     566:	00 00                	add    %al,(%rax)
     568:	86 2c 00             	xchg   %ch,(%rax,%rax,1)
     56b:	00 90 2c 00 00 9a    	add    %dl,-0x65ffffd4(%rax)
     571:	2c 00                	sub    $0x0,%al
     573:	00 a4 2c 00 00 b0 2c 	add    %ah,0x2cb00000(%rsp,%rbp,1)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     57a:	00 00                	add    %al,(%rax)
     57c:	c7                   	(bad)
     57d:	2c 00                	sub    $0x0,%al
     57f:	00 d1                	add    %dl,%cl
     581:	2c 00                	sub    $0x0,%al
     583:	00 0a                	add    %cl,(%rdx)
     585:	2d 00 00 43 2d       	sub    $0x2d430000,%eax
     58a:	00 00                	add    %al,(%rax)
     58c:	55                   	push   %rbp
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
     58d:	2d 00 00 5f 2d       	sub    $0x2d5f0000,%eax
     592:	00 00                	add    %al,(%rax)
     594:	7d 2d                	jge    5c3 <balancer_ingress+0x5c3>
     596:	00 00                	add    %al,(%rax)
     598:	9b                   	fwait
     599:	2d 00 00 b6 2d       	sub    $0x2db60000,%eax
     59e:	00 00                	add    %al,(%rax)
     5a0:	d4                   	(bad)
     5a1:	2d 00 00 24 2e       	sub    $0x2e240000,%eax
     5a6:	00 00                	add    %al,(%rax)
     5a8:	3f                   	(bad)
     5a9:	2e 00 00             	cs add %al,(%rax)
  if (decap_dst_flags) {
     5ac:	61                   	(bad)
     5ad:	2e 00 00             	cs add %al,(%rax)
     5b0:	73 2e                	jae    5e0 <balancer_ingress+0x5e0>
     5b2:	00 00                	add    %al,(%rax)
     5b4:	7d 2e                	jge    5e4 <balancer_ingress+0x5e4>
     5b6:	00 00                	add    %al,(%rax)
     5b8:	90                   	nop
     5b9:	2e 00 00             	cs add %al,(%rax)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     5bc:	9c                   	pushf
     5bd:	2e 00 00             	cs add %al,(%rax)
     5c0:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
     5c1:	2e 00 00             	cs add %al,(%rax)
     5c4:	b1 2e                	mov    $0x2e,%cl
     5c6:	00 00                	add    %al,(%rax)
    if (!data_stats) {
     5c8:	c2 2e 00             	ret    $0x2e
     5cb:	00 cd                	add    %cl,%ch
     5cd:	2e 00 00             	cs add %al,(%rax)
    data_stats->v1 += 1;
     5d0:	d8 2e                	fsubrs (%rsi)
     5d2:	00 00                	add    %al,(%rax)
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5d4:	e2 2e                	loop   604 <balancer_ingress+0x604>
     5d6:	00 00                	add    %al,(%rax)
     5d8:	f4                   	hlt
     5d9:	2e 00 00             	cs add %al,(%rax)
     5dc:	fe                   	(bad)
     5dd:	2e 00 00             	cs add %al,(%rax)
     5e0:	10 2f                	adc    %ch,(%rdi)
    if (!--ip6h->hop_limit) {
     5e2:	00 00                	add    %al,(%rax)
     5e4:	1a 2f                	sbb    (%rdi),%ch
     5e6:	00 00                	add    %al,(%rax)
     5e8:	2c 2f                	sub    $0x2f,%al
     5ea:	00 00                	add    %al,(%rax)
     5ec:	36 2f                	ss (bad)
     5ee:	00 00                	add    %al,(%rax)
     5f0:	40 2f                	rex (bad)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5f2:	00 00                	add    %al,(%rax)
     5f4:	4a 2f                	rex.WX (bad)
     5f6:	00 00                	add    %al,(%rax)
     5f8:	54                   	push   %rsp
     5f9:	2f                   	(bad)
     5fa:	00 00                	add    %al,(%rax)
     5fc:	5e                   	pop    %rsi
     5fd:	2f                   	(bad)
     5fe:	00 00                	add    %al,(%rax)
     600:	6a 2f                	push   $0x2f
     602:	00 00                	add    %al,(%rax)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     604:	75 2f                	jne    635 <balancer_ingress+0x635>
     606:	00 00                	add    %al,(%rax)
     608:	9f                   	lahf
     609:	2f                   	(bad)
     60a:	00 00                	add    %al,(%rax)
     60c:	a9 2f 00 00 b3       	test   $0xb300002f,%eax
     611:	2f                   	(bad)
     612:	00 00                	add    %al,(%rax)
    new_eth->h_proto = BE_ETH_P_IPV6;
     614:	ca 2f 00             	lret   $0x2f
     617:	00 dc                	add    %bl,%ah
     619:	2f                   	(bad)
     61a:	00 00                	add    %al,(%rax)
     61c:	ed                   	in     (%dx),%eax
     61d:	2f                   	(bad)
     61e:	00 00                	add    %al,(%rax)
     620:	ff 2f                	ljmp   *(%rdi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     622:	00 00                	add    %al,(%rax)
     624:	09 30                	or     %esi,(%rax)
     626:	00 00                	add    %al,(%rax)
     628:	1c 30                	sbb    $0x30,%al
     62a:	00 00                	add    %al,(%rax)
     62c:	33 30                	xor    (%rax),%esi
     62e:	00 00                	add    %al,(%rax)
     630:	45 30 00             	xor    %r8b,(%r8)
     633:	00 56 30             	add    %dl,0x30(%rsi)
     636:	00 00                	add    %al,(%rax)
     638:	68 30 00 00 72       	push   $0x72000030
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     63d:	30 00                	xor    %al,(%rax)
     63f:	00 85 30 00 00 96    	add    %al,-0x69ffffd0(%rbp)
     645:	30 00                	xor    %al,(%rax)
  if (!data_stats) {
     647:	00 a7 30 00 00 b0    	add    %ah,-0x4fffffd0(%rdi)
     64d:	30 00                	xor    %al,(%rax)
     64f:	00 b9 30 00 00 c5    	add    %bh,-0x3affffd0(%rcx)
    data_stats->v2 += 1;
     655:	30 00                	xor    %al,(%rax)
     657:	00 e9                	add    %ch,%cl
  if (action >= 0) {
     659:	30 00                	xor    %al,(%rax)
     65b:	00 fd                	add    %bh,%ch
     65d:	30 00                	xor    %al,(%rax)
     65f:	00 07                	add    %al,(%rdi)
     661:	31 00                	xor    %eax,(%rax)
  if (decap_dst_flags) {
     663:	00 12                	add    %dl,(%rdx)
     665:	31 00                	xor    %eax,(%rax)
  if (action >= 0) {
     667:	00 1b                	add    %bl,(%rbx)
     669:	31 00                	xor    %eax,(%rax)
     66b:	00 27                	add    %ah,(%rdi)
     66d:	31 00                	xor    %eax,(%rax)
     66f:	00 10                	add    %dl,(%rax)
     671:	32 00                	xor    (%rax),%al
     673:	00 25 33 00 00 01    	add    %ah,0x1000033(%rip)        # 10006ac <_license+0xffe317>
     679:	14 04                	adc    $0x4,%al
     67b:	04 b7                	add    $0xb7,%al
     67d:	02 01                	add    (%rcx),%al
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     67f:	55                   	push   %rbp
     680:	04 b7                	add    $0xb7,%al
     682:	02 d8                	add    %al,%bl
     684:	02 04 a3             	add    (%rbx,%riz,4),%al
     687:	01 55 9f             	add    %edx,-0x61(%rbp)
    if (xpop_stats_data) {
     68a:	04 d8                	add    $0xd8,%al
     68c:	02 ad 06 01 55 04    	add    0x4550106(%rbp),%ch
        xpop_stats_data->v2 += 1; // IPv6 inner packets
     692:	ad                   	lods   %ds:(%rsi),%eax
     693:	06                   	(bad)
     694:	ce                   	(bad)
     695:	07                   	(bad)
     696:	04 a3                	add    $0xa3,%al
     698:	01 55 9f             	add    %edx,-0x61(%rbp)
     69b:	04 ce                	add    $0xce,%al
  bpf_tail_call(ctx, &subprograms, i);
     69d:	07                   	(bad)
     69e:	a0 0b 01 55 04 a0 0b 	movabs 0xbac0ba00455010b,%al
     6a5:	ac 0b 
     6a7:	01 53 04             	add    %edx,0x4(%rbx)
     6aa:	ac                   	lods   %ds:(%rsi),%al
     6ab:	0b b1 0b 01 55 04    	or     0x455010b(%rcx),%esi
     6b1:	b1 0b                	mov    $0xb,%cl
     6b3:	c5 0d 04             	(bad)
     6b6:	a3 01 55 9f 04 c5 0d 	movabs %eax,0xdeb0dc5049f5501
     6bd:	eb 0d 
     6bf:	01 55 04             	add    %edx,0x4(%rbp)
     6c2:	eb 0d                	jmp    6d1 <balancer_ingress+0x6d1>
     6c4:	f7 0d 01 53 04 f7 0d 	testl  $0x10dfc0d,-0x8fbacff(%rip)        # fffffffff70459cf <server_id_map+0x36ffde95c9cf>
     6cb:	fc 0d 01 
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     6ce:	55                   	push   %rbp
     6cf:	04 fc                	add    $0xfc,%al
     6d1:	0d a3 10 04 a3       	or     $0xa30410a3,%eax
     6d6:	01 55 9f             	add    %edx,-0x61(%rbp)
     6d9:	04 a3                	add    $0xa3,%al
     6db:	10 bf 10 01 55 04    	adc    %bh,0x4550110(%rdi)
     6e1:	bf 10 d1 10 03       	mov    $0x310d110,%edi
     6e6:	77 d0                	ja     6b8 <balancer_ingress+0x6b8>
     6e8:	00 04 d1             	add    %al,(%rcx,%rdx,8)
     6eb:	10 c2                	adc    %al,%dl
     6ed:	11 01                	adc    %eax,(%rcx)
     6ef:	55                   	push   %rbp
     6f0:	04 c2                	add    $0xc2,%al
     6f2:	11 a6 13 03 77 d0    	adc    %esp,-0x2f88fced(%rsi)
  if (decap_dst_flags) {
     6f8:	00 04 a6             	add    %al,(%rsi,%riz,4)
     6fb:	13 97 14 01 55 04    	adc    0x4550114(%rdi),%edx
     701:	97                   	xchg   %eax,%edi
     702:	14 d5                	adc    $0xd5,%al
     704:	14 03                	adc    $0x3,%al
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     706:	77 d0                	ja     6d8 <balancer_ingress+0x6d8>
     708:	00 04 d5 14 80 15 01 	add    %al,0x1158014(,%rdx,8)
     70f:	55                   	push   %rbp
     710:	04 80                	add    $0x80,%al
    if (!data_stats) {
     712:	15 8c 15 01 53       	adc    $0x5301158c,%eax
     717:	04 8c                	add    $0x8c,%al
     719:	15 91 15 01 55       	adc    $0x55011591,%eax
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     71e:	04 91                	add    $0x91,%al
     720:	15 b9 17 04 a3       	adc    $0xa30417b9,%eax
     725:	01 55 9f             	add    %edx,-0x61(%rbp)
     728:	04 b9                	add    $0xb9,%al
     72a:	17                   	(bad)
     72b:	dd 18                	fstpl  (%rax)
    csum = iph->check + 0x0001;
     72d:	01 55 04             	add    %edx,0x4(%rbp)
     730:	dd 18                	fstpl  (%rax)
     732:	b9 1b 01 5e 04       	mov    $0x45e011b,%ecx
    iph->check = (csum & 0xffff) + (csum >> 16);
     737:	b9 1b d5 1b 01       	mov    $0x11bd51b,%ecx
     73c:	55                   	push   %rbp
     73d:	04 d5                	add    $0xd5,%al
     73f:	1b 9b 3f 03 77 d0    	sbb    -0x2f88fcc1(%rbx),%ebx
    if (!--iph->ttl) {
     745:	00 04 9b             	add    %al,(%rbx,%rbx,4)
     748:	3f                   	(bad)
     749:	b2 3f                	mov    $0x3f,%dl
     74b:	04 a3                	add    $0xa3,%al
     74d:	01 55 9f             	add    %edx,-0x61(%rbp)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     750:	04 b2                	add    $0xb2,%al
     752:	3f                   	(bad)
     753:	d3 44 03 77          	roll   %cl,0x77(%rbx,%rax,1)
     757:	d0 00                	rolb   (%rax)
     759:	00 01                	add    %al,(%rcx)
     75b:	14 04                	adc    $0x4,%al
     75d:	18 c4                	sbb    %al,%ah
     75f:	07                   	(bad)
     760:	01 5f 04             	add    %ebx,0x4(%rdi)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     763:	ce                   	(bad)
     764:	07                   	(bad)
     765:	95                   	xchg   %eax,%ebp
     766:	1e                   	(bad)
     767:	01 5f 04             	add    %ebx,0x4(%rdi)
     76a:	92                   	xchg   %eax,%edx
     76b:	1f                   	(bad)
     76c:	ec                   	in     (%dx),%al
     76d:	20 01                	and    %al,(%rcx)
     76f:	5f                   	pop    %rdi
     770:	04 e1                	add    $0xe1,%al
     772:	21 a2 22 01 5f 00    	and    %esp,0x5f0122(%rdx)
    new_eth->h_proto = BE_ETH_P_IP;
     778:	01 14 04             	add    %edx,(%rsp,%rax,1)
     77b:	1c c4                	sbb    $0xc4,%al
     77d:	07                   	(bad)
     77e:	01 5d 04             	add    %ebx,0x4(%rbp)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     781:	ce                   	(bad)
     782:	07                   	(bad)
     783:	99                   	cltd
     784:	25 01 5d 04 d1       	and    $0xd1045d01,%eax
     789:	25 c0 26 01 5d       	and    $0x5d0126c0,%eax
      if (!decap_v6(xdp, data, data_end, true)) {
     78e:	04 c2                	add    $0xc2,%al
     790:	26 c5 26 01          	(bad)
     794:	5d                   	pop    %rbp
     795:	04 c7                	add    $0xc7,%al
     797:	26 d1 26             	es shll (%rsi)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     79a:	01 5d 04             	add    %ebx,0x4(%rbp)
     79d:	b0 32                	mov    $0x32,%al
     79f:	f9                   	stc
     7a0:	33 01                	xor    (%rcx),%eax
     7a2:	5d                   	pop    %rbp
     7a3:	04 b8                	add    $0xb8,%al
     7a5:	34 a1                	xor    $0xa1,%al
  if (!data_stats) {
     7a7:	35 01 5d 04 a3       	xor    $0xa3045d01,%eax
     7ac:	35 a6 35 01 5d       	xor    $0x5d0135a6,%eax
     7b1:	04 a8                	add    $0xa8,%al
     7b3:	35 b2 35 01 5d       	xor    $0x5d0135b2,%eax
  if (action >= 0) {
     7b8:	00 01                	add    %al,(%rcx)
     7ba:	14 04                	adc    $0x4,%al
     7bc:	1c c4                	sbb    $0xc4,%al
     7be:	07                   	(bad)
     7bf:	01 5f 04             	add    %ebx,0x4(%rdi)
  if (decap_dst_flags) {
     7c2:	ce                   	(bad)
     7c3:	07                   	(bad)
     7c4:	95                   	xchg   %eax,%ebp
  if (action >= 0) {
     7c5:	1e                   	(bad)
     7c6:	01 5f 04             	add    %ebx,0x4(%rdi)
     7c9:	92                   	xchg   %eax,%edx
     7ca:	1f                   	(bad)
     7cb:	ec                   	in     (%dx),%al
     7cc:	20 01                	and    %al,(%rcx)
     7ce:	5f                   	pop    %rdi
     7cf:	04 e1                	add    $0xe1,%al
     7d1:	21 a2 22 01 5f 00    	and    %esp,0x5f0122(%rdx)
     7d7:	01 14 04             	add    %edx,(%rsp,%rax,1)
     7da:	1c d3                	sbb    $0xd3,%al
     7dc:	44 02 3e             	add    (%rsi),%r15b
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     7df:	9f                   	lahf
     7e0:	00 01                	add    %al,(%rcx)
     7e2:	14 04                	adc    $0x4,%al
     7e4:	4d b7 02             	rex.WRB mov $0x2,%r15b
     7e7:	01 55 04             	add    %edx,0x4(%rbp)
    if (xpop_stats_data) {
     7ea:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     7eb:	08 db                	or     %bl,%bl
     7ed:	09 01                	or     %eax,(%rcx)
        xpop_stats_data->v1 += 1; // IPv4 inner packets
     7ef:	55                   	push   %rbp
     7f0:	04 a6                	add    $0xa6,%al
     7f2:	13 97 14 01 55 04    	adc    0x4550114(%rdi),%edx
     7f8:	d5                   	(bad)
     7f9:	14 80                	adc    $0x80,%al
  bpf_tail_call(ctx, &subprograms, i);
     7fb:	15 01 55 04 80       	adc    $0x80045501,%eax
     800:	15 8c 15 01 53       	adc    $0x5301158c,%eax
     805:	04 8c                	add    $0x8c,%al
     807:	15 91 15 01 55       	adc    $0x55011591,%eax
     80c:	04 b9                	add    $0xb9,%al
     80e:	17                   	(bad)
     80f:	dd 18                	fstpl  (%rax)
     811:	01 55 04             	add    %edx,0x4(%rbp)
     814:	dd 18                	fstpl  (%rax)
     816:	b9 1b 01 5e 04       	mov    $0x45e011b,%ecx
     81b:	b9 1b d5 1b 01       	mov    $0x11bd51b,%ecx
     820:	55                   	push   %rbp
     821:	04 d5                	add    $0xd5,%al
  udp = data + off;
     823:	1b c4                	sbb    %esp,%eax
     825:	1d 03 77 d0 00       	sbb    $0xd07703,%eax
     82a:	04 92                	add    $0x92,%al
     82c:	1f                   	(bad)
  if (udp + 1 > data_end) {
     82d:	d0 1f                	rcrb   (%rdi)
     82f:	03 77 d0             	add    -0x30(%rdi),%esi
     832:	00 04 8c             	add    %al,(%rsp,%rcx,4)
     835:	20 a2 22 03 77 d0    	and    %ah,-0x2f88fcde(%rdx)
     83b:	00 04 f5 22 cb 23 03 	add    %al,0x323cb22(,%rsi,8)
     842:	77 d0                	ja     814 <balancer_ingress+0x814>
     844:	00 04 b0             	add    %al,(%rax,%rsi,4)
     847:	32 af 34 03 77 d0    	xor    -0x2f88fccc(%rdi),%ch
     84d:	00 04 b8             	add    %al,(%rax,%rdi,4)
     850:	34 91                	xor    $0x91,%al
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     852:	3a 03                	cmp    (%rbx),%al
     854:	77 d0                	ja     826 <balancer_ingress+0x826>
     856:	00 04 f7             	add    %al,(%rdi,%rsi,8)
     859:	3a 94 3f 03 77 d0 00 	cmp    0xd07703(%rdi,%rdi,1),%dl
     860:	04 b2                	add    $0xb2,%al
        bpf_map_lookup_elem(&stats, &stats_key);
     862:	3f                   	(bad)
     863:	ee                   	out    %al,(%dx)
     864:	40 03 77 d0          	rex add -0x30(%rdi),%esi
     868:	00 04 fa             	add    %al,(%rdx,%rdi,8)
     86b:	42 d3 44 03 77       	roll   %cl,0x77(%rbx,%r8,1)
    if (!icmp_ptb_v4_stats) {
     870:	d0 00                	rolb   (%rax)
     872:	00 01                	add    %al,(%rcx)
     874:	14 04                	adc    $0x4,%al
     876:	4d d8 02             	rex.WRB fadds (%r10)
    icmp_ptb_v4_stats->v1 += 1;
     879:	02 3e                	add    (%rsi),%bh
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     87b:	9f                   	lahf
     87c:	04 a5                	add    $0xa5,%al
     87e:	08 db                	or     %bl,%bl
     880:	09 02                	or     %eax,(%rdx)
      icmp_ptb_v4_stats->v2 += 1;
     882:	3e 9f                	ds lahf
     884:	04 a6                	add    $0xa6,%al
  if (iph + 1 > data_end) {
     886:	13 97 14 02 3e 9f    	adc    -0x60c1fdec(%rdi),%edx
     88c:	04 d5                	add    $0xd5,%al
     88e:	14 c4                	adc    $0xc4,%al
     890:	1d 02 3e 9f 04       	sbb    $0x49f3e02,%eax
  if (iph->ihl != 5) {
     895:	92                   	xchg   %eax,%edx
     896:	1f                   	(bad)
     897:	d0 1f                	rcrb   (%rdi)
     899:	02 3e                	add    (%rsi),%bh
     89b:	9f                   	lahf
     89c:	04 8c                	add    $0x8c,%al
     89e:	20 a2 22 02 3e 9f    	and    %ah,-0x60c1fdde(%rdx)
  pckt->flow.proto = iph->protocol;
     8a4:	04 f5                	add    $0xf5,%al
     8a6:	22 cb                	and    %bl,%cl
  pckt->flags |= F_ICMP;
     8a8:	23 02                	and    (%rdx),%eax
     8aa:	3e 9f                	ds lahf
     8ac:	04 b0                	add    $0xb0,%al
  pckt->flow.src = iph->daddr;
     8ae:	32 af 34 02 3e 9f    	xor    -0x60c1fdcc(%rdi),%ch
     8b4:	04 b8                	add    $0xb8,%al
  pckt->flow.dst = iph->saddr;
     8b6:	34 91                	xor    $0x91,%al
     8b8:	3a 02                	cmp    (%rdx),%al
     8ba:	3e 9f                	ds lahf
     8bc:	04 f7                	add    $0xf7,%al
     8be:	3a 94 3f 02 3e 9f 04 	cmp    0x49f3e02(%rdi,%rdi,1),%dl
     8c5:	b2 3f                	mov    $0x3f,%dl
     8c7:	ee                   	out    %al,(%dx)
     8c8:	40 02 3e             	add    (%rsi),%dil
     8cb:	9f                   	lahf
     8cc:	04 fa                	add    $0xfa,%al
     8ce:	42 d3 44 02 3e       	roll   %cl,0x3e(%rdx,%r8,1)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     8d3:	9f                   	lahf
     8d4:	00 01                	add    %al,(%rcx)
     8d6:	14 04                	adc    $0x4,%al
     8d8:	4d d8 02             	rex.WRB fadds (%r10)
     8db:	02 30                	add    (%rax),%dh
     8dd:	9f                   	lahf
     8de:	04 a5                	add    $0xa5,%al
     8e0:	08 db                	or     %bl,%bl
     8e2:	09 02                	or     %eax,(%rdx)
     8e4:	30 9f 04 a6 13 97    	xor    %bl,-0x68ec59fc(%rdi)
  vip.port = pckt.flow.port16[1];
     8ea:	14 02                	adc    $0x2,%al
  vip.proto = pckt.flow.proto;
     8ec:	30 9f 04 d5 14 c4    	xor    %bl,-0x3beb2afc(%rdi)
     8f2:	1d 02 30 9f 04       	sbb    $0x49f3002,%eax
     8f7:	92                   	xchg   %eax,%edx
     8f8:	1f                   	(bad)
     8f9:	d0 1f                	rcrb   (%rdi)
     8fb:	02 30                	add    (%rax),%dh
     8fd:	9f                   	lahf
     8fe:	04 8c                	add    $0x8c,%al
     900:	20 a2 22 02 30 9f    	and    %ah,-0x60cffdde(%rdx)
     906:	04 f5                	add    $0xf5,%al
  if (!vip_info) {
     908:	22 cb                	and    %bl,%cl
     90a:	23 02                	and    (%rdx),%eax
     90c:	30 9f 04 b0 32 af    	xor    %bl,-0x50cd4ffc(%rdi)
  if (data_end - data > MAX_PCKT_SIZE) {
     912:	34 02                	xor    $0x2,%al
     914:	30 9f 04 b8 34 91    	xor    %bl,-0x6ecb47fc(%rdi)
     91a:	3a 02                	cmp    (%rdx),%al
     91c:	30 9f 04 f7 3a 94    	xor    %bl,-0x6bc508fc(%rdi)
     922:	3f                   	(bad)
     923:	02 30                	add    (%rax),%dh
     925:	9f                   	lahf
     926:	04 b2                	add    $0xb2,%al
     928:	3f                   	(bad)
     929:	ee                   	out    %al,(%dx)
     92a:	40 02 30             	add    (%rax),%sil
     92d:	9f                   	lahf
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     92e:	04 fa                	add    $0xfa,%al
     930:	42 d3 44 02 30       	roll   %cl,0x30(%rdx,%r8,1)
     935:	9f                   	lahf
     936:	00 01                	add    %al,(%rcx)
     938:	14 04                	adc    $0x4,%al
  if (!data_stats) {
     93a:	4d d8 02             	rex.WRB fadds (%r10)
     93d:	01 5f 04             	add    %ebx,0x4(%rdi)
     940:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     941:	08 db                	or     %bl,%bl
  data_stats->v1 += 1;
     943:	09 01                	or     %eax,(%rcx)
     945:	5f                   	pop    %rdi
     946:	04 a6                	add    $0xa6,%al
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     948:	13 97 14 01 5f 04    	adc    0x45f0114(%rdi),%edx
    pckt.flow.port16[0] = 0;
     94e:	d5                   	(bad)
     94f:	14 c4                	adc    $0xc4,%al
     951:	1d 01 5f 04 92       	sbb    $0x92045f01,%eax
  vip_num = vip_info->vip_num;
     956:	1f                   	(bad)
     957:	d0 1f                	rcrb   (%rdi)
     959:	01 5f 04             	add    %ebx,0x4(%rdi)
     95c:	8c 20                	mov    %fs,(%rax)
  __u32 cpu_num = bpf_get_smp_processor_id();
     95e:	ec                   	in     (%dx),%al
     95f:	20 01                	and    %al,(%rcx)
     961:	5f                   	pop    %rdi
     962:	04 e1                	add    $0xe1,%al
     964:	21 a2 22 01 5f 00    	and    %esp,0x5f0122(%rdx)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     96a:	01 14 04             	add    %edx,(%rsp,%rax,1)
     96d:	4d d8 02             	rex.WRB fadds (%r10)
     970:	01 5d 04             	add    %ebx,0x4(%rbp)
     973:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     974:	08 db                	or     %bl,%bl
     976:	09 01                	or     %eax,(%rcx)
     978:	5d                   	pop    %rbp
     979:	04 a6                	add    $0xa6,%al
     97b:	13 97 14 01 5d 04    	adc    0x45d0114(%rdi),%edx
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     981:	d5                   	(bad)
     982:	14 c4                	adc    $0xc4,%al
     984:	1d 01 5d 04 92       	sbb    $0x92045d01,%eax
     989:	1f                   	(bad)
     98a:	d0 1f                	rcrb   (%rdi)
    if (!lru_stats) {
     98c:	01 5d 04             	add    %ebx,0x4(%rbp)
     98f:	8c 20                	mov    %fs,(%rax)
     991:	a2 22 01 5d 04 f5 22 	movabs %al,0x23cb22f5045d0122
     998:	cb 23 
    lru_stats->v1 += 1;
     99a:	01 5d 04             	add    %ebx,0x4(%rbp)
     99d:	b0 32                	mov    $0x32,%al
     99f:	f9                   	stc
     9a0:	33 01                	xor    (%rcx),%eax
     9a2:	5d                   	pop    %rbp
     9a3:	04 b8                	add    $0xb8,%al
     9a5:	34 a1                	xor    $0xa1,%al
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     9a7:	35 01 5d 04 a3       	xor    $0xa3045d01,%eax
     9ac:	35 a6 35 01 5d       	xor    $0x5d0135a6,%eax
     9b1:	04 a8                	add    $0xa8,%al
     9b3:	35 b2 35 01 5d       	xor    $0x5d0135b2,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     9b8:	00 01                	add    %al,(%rcx)
     9ba:	14 04                	adc    $0x4,%al
     9bc:	4d d8 02             	rex.WRB fadds (%r10)
     9bf:	02 30                	add    (%rax),%dh
     9c1:	9f                   	lahf
     9c2:	04 a5                	add    $0xa5,%al
    if (!icmp_ptb_v4_stats) {
     9c4:	08 db                	or     %bl,%bl
     9c6:	09 02                	or     %eax,(%rdx)
     9c8:	30 9f 04 a6 13 97    	xor    %bl,-0x68ec59fc(%rdi)
    icmp_ptb_v4_stats->v1 += 1;
     9ce:	14 02                	adc    $0x2,%al
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     9d0:	30 9f 04 d5 14 c4    	xor    %bl,-0x3beb2afc(%rdi)
      icmp_ptb_v4_stats->v2 += 1;
     9d6:	1d 02 30 9f 04       	sbb    $0x49f3002,%eax
  if (iph + 1 > data_end) {
     9db:	92                   	xchg   %eax,%edx
     9dc:	1f                   	(bad)
     9dd:	d0 1f                	rcrb   (%rdi)
     9df:	02 30                	add    (%rax),%dh
     9e1:	9f                   	lahf
     9e2:	04 8c                	add    $0x8c,%al
     9e4:	20 a2 22 02 30 9f    	and    %ah,-0x60cffdde(%rdx)
  if (iph->ihl != 5) {
     9ea:	04 f5                	add    $0xf5,%al
     9ec:	22 cb                	and    %bl,%cl
     9ee:	23 02                	and    (%rdx),%eax
     9f0:	30 9f 04 b0 32 e5    	xor    %bl,-0x1acd4ffc(%rdi)
  pckt->flow.proto = iph->protocol;
     9f6:	33 02                	xor    (%rdx),%eax
     9f8:	30 9f 04 b8 34 96    	xor    %bl,-0x69cb47fc(%rdi)
  pckt->flags |= F_ICMP;
     9fe:	37                   	(bad)
     9ff:	02 30                	add    (%rax),%dh
     a01:	9f                   	lahf
  pckt->flow.src = iph->daddr;
     a02:	04 96                	add    $0x96,%al
     a04:	37                   	(bad)
     a05:	9f                   	lahf
     a06:	37                   	(bad)
     a07:	01 5d 04             	add    %ebx,0x4(%rbp)
  pckt->flow.dst = iph->saddr;
     a0a:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     a0b:	38 91 3a 01 5d 04    	cmp    %dl,0x45d013a(%rcx)
     a11:	cf                   	iret
     a12:	3f                   	(bad)
     a13:	ee                   	out    %al,(%dx)
     a14:	40 01 5d 00          	rex add %ebx,0x0(%rbp)
    vip.port = 0;
     a18:	01 14 04             	add    %edx,(%rsp,%rax,1)
     a1b:	9d                   	popf
     a1c:	01 d8                	add    %ebx,%eax
     a1e:	02 02                	add    (%rdx),%al
     a20:	30 9f 04 a5 08 db    	xor    %bl,-0x24f75afc(%rdi)
     a26:	09 02                	or     %eax,(%rdx)
     a28:	30 9f 04 a6 13 97    	xor    %bl,-0x68ec59fc(%rdi)
     a2e:	14 02                	adc    $0x2,%al
    if (!vip_info) {
     a30:	30 9f 04 d5 14 c4    	xor    %bl,-0x3beb2afc(%rdi)
     a36:	1d 02 30 9f 04       	sbb    $0x49f3002,%eax
     a3b:	92                   	xchg   %eax,%edx
     a3c:	1f                   	(bad)
     a3d:	d0 1f                	rcrb   (%rdi)
     a3f:	02 30                	add    (%rax),%dh
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     a41:	9f                   	lahf
     a42:	04 8c                	add    $0x8c,%al
     a44:	20 a2 22 02 30 9f    	and    %ah,-0x60cffdde(%rdx)
      pckt.flow.port16[1] = 0;
     a4a:	04 f5                	add    $0xf5,%al
     a4c:	22 cb                	and    %bl,%cl
     a4e:	23 02                	and    (%rdx),%eax
     a50:	30 9f 04 b0 32 af    	xor    %bl,-0x50cd4ffc(%rdi)
  struct address dst_addr = {};
     a56:	34 02                	xor    $0x2,%al
     a58:	30 9f 04 b8 34 91    	xor    %bl,-0x6ecb47fc(%rdi)
     a5e:	3a 02                	cmp    (%rdx),%al
     a60:	30 9f 04 f7 3a 94    	xor    %bl,-0x6bc508fc(%rdi)
    dst_addr.addr = pckt->flow.dst;
     a66:	3f                   	(bad)
     a67:	02 30                	add    (%rax),%dh
     a69:	9f                   	lahf
     a6a:	04 b2                	add    $0xb2,%al
     a6c:	3f                   	(bad)
     a6d:	ee                   	out    %al,(%dx)
     a6e:	40 02 30             	add    (%rax),%sil
     a71:	9f                   	lahf
     a72:	04 fa                	add    $0xfa,%al
     a74:	42 d3 44 02 30       	roll   %cl,0x30(%rdx,%r8,1)
     a79:	9f                   	lahf
     a7a:	00 01                	add    %al,(%rcx)
     a7c:	14 04                	adc    $0x4,%al
     a7e:	9d                   	popf
     a7f:	01 d8                	add    %ebx,%eax
     a81:	02 02                	add    (%rdx),%al
     a83:	30 9f 04 a5 08 b5    	xor    %bl,-0x4af75afc(%rdi)
     a89:	08 02                	or     %al,(%rdx)
     a8b:	30 9f 04 b5 08 9c    	xor    %bl,-0x63f74afc(%rdi)
     a91:	09 03                	or     %eax,(%rbx)
     a93:	10 22                	adc    %ah,(%rdx)
     a95:	9f                   	lahf
     a96:	04 a6                	add    $0xa6,%al
     a98:	13 97 14 02 30 9f    	adc    -0x60cffdec(%rdi),%edx
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a9e:	04 b9                	add    $0xb9,%al
     aa0:	17                   	(bad)
     aa1:	ae                   	scas   %es:(%rdi),%al
     aa2:	18 03                	sbb    %al,(%rbx)
     aa4:	10 22                	adc    %ah,(%rdx)
     aa6:	9f                   	lahf
    if (!data_stats) {
     aa7:	00 01                	add    %al,(%rcx)
     aa9:	14 04                	adc    $0x4,%al
     aab:	9d                   	popf
     aac:	01 e8                	add    %ebp,%eax
     aae:	01 03                	add    %eax,(%rbx)
    data_stats->v1 += 1;
     ab0:	77 10                	ja     ac2 <balancer_ingress+0xac2>
     ab2:	9f                   	lahf
     ab3:	04 a5                	add    $0xa5,%al
     ab5:	08 ba 08 03 77 10    	or     %bh,0x10770308(%rdx)
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     abb:	9f                   	lahf
     abc:	00 01                	add    %al,(%rcx)
     abe:	14 04                	adc    $0x4,%al
     ac0:	9d                   	popf
     ac1:	01 e8                	add    %ebp,%eax
     ac3:	01 02                	add    %eax,(%rdx)
    csum = iph->check + 0x0001;
     ac5:	3e 9f                	ds lahf
     ac7:	04 a5                	add    $0xa5,%al
     ac9:	08 ba 08 02 3e 9f    	or     %bh,-0x60c1fdf8(%rdx)
    iph->check = (csum & 0xffff) + (csum >> 16);
     acf:	00 01                	add    %al,(%rcx)
     ad1:	14 04                	adc    $0x4,%al
     ad3:	9d                   	popf
     ad4:	01 e8                	add    %ebp,%eax
     ad6:	01 01                	add    %eax,(%rcx)
     ad8:	5f                   	pop    %rdi
    if (!--iph->ttl) {
     ad9:	04 a5                	add    $0xa5,%al
     adb:	08 ba 08 01 5f 00    	or     %bh,0x5f0108(%rdx)
     ae1:	01 14 04             	add    %edx,(%rsp,%rax,1)
     ae4:	9d                   	popf
     ae5:	01 e8                	add    %ebp,%eax
     ae7:	01 01                	add    %eax,(%rcx)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     ae9:	5d                   	pop    %rbp
     aea:	04 a5                	add    $0xa5,%al
     aec:	08 ba 08 01 5d 00    	or     %bh,0x5d0108(%rdx)
     af2:	01 14 04             	add    %edx,(%rsp,%rax,1)
     af5:	9d                   	popf
     af6:	01 e8                	add    %ebp,%eax
     af8:	01 02                	add    %eax,(%rdx)
     afa:	30 9f 04 a5 08 ba    	xor    %bl,-0x45f75afc(%rdi)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     b00:	08 02                	or     %al,(%rdx)
     b02:	30 9f 00 01 14 04    	xor    %bl,0x4140100(%rdi)
     b08:	9d                   	popf
  new_eth->h_proto = BE_ETH_P_IP;
     b09:	01 aa 01 03 7f 0e    	add    %ebp,0xe7f0301(%rdx)
     b0f:	9f                   	lahf
     b10:	04 aa                	add    $0xaa,%al
     b12:	01 c5                	add    %eax,%ebp
     b14:	01 01                	add    %eax,(%rcx)
     b16:	52                   	push   %rdx
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     b17:	00 01                	add    %al,(%rcx)
     b19:	14 04                	adc    $0x4,%al
     b1b:	e8 01 d8 02 01       	call   102e321 <_license+0x102bf8c>
     b20:	5f                   	pop    %rdi
     b21:	04 a6                	add    $0xa6,%al
     b23:	13 97 14 01 5f 00    	adc    0x5f0114(%rdi),%edx
     b29:	01 14 04             	add    %edx,(%rsp,%rax,1)
     b2c:	e8 01 d8 02 01       	call   102e332 <_license+0x102bf9d>
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b31:	5d                   	pop    %rbp
     b32:	04 a6                	add    $0xa6,%al
     b34:	13 97 14 01 5d 00    	adc    0x5d0114(%rdi),%edx
     b3a:	01 14 04             	add    %edx,(%rsp,%rax,1)
  if (!data_stats) {
     b3d:	e8 01 d8 02 03       	call   302e343 <_license+0x302bfae>
     b42:	10 22                	adc    %ah,(%rdx)
     b44:	9f                   	lahf
     b45:	04 a6                	add    $0xa6,%al
     b47:	13 da                	adc    %edx,%ebx
     b49:	13 03                	adc    (%rbx),%eax
    data_stats->v2 += 1;
     b4b:	10 22                	adc    %ah,(%rdx)
     b4d:	9f                   	lahf
  if (action >= 0) {
     b4e:	00 01                	add    %al,(%rcx)
     b50:	14 04                	adc    $0x4,%al
     b52:	e8 01 d8 02 03       	call   302e358 <_license+0x302bfc3>
     b57:	77 10                	ja     b69 <balancer_ingress+0xb69>
  if (decap_dst_flags) {
     b59:	9f                   	lahf
     b5a:	04 a6                	add    $0xa6,%al
  if (action >= 0) {
     b5c:	13 97 14 03 77 10    	adc    0x10770314(%rdi),%edx
     b62:	9f                   	lahf
     b63:	00 01                	add    %al,(%rcx)
     b65:	14 04                	adc    $0x4,%al
     b67:	e8 01 f5 01 03       	call   302006d <_license+0x301dcd8>
     b6c:	7f 22                	jg     b90 <balancer_ingress+0xb90>
     b6e:	9f                   	lahf
     b6f:	04 f5                	add    $0xf5,%al
     b71:	01 d8                	add    %ebx,%eax
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b73:	02 01                	add    (%rcx),%al
     b75:	53                   	push   %rbx
     b76:	04 a6                	add    $0xa6,%al
     b78:	13 97 14 01 53 00    	adc    0x530114(%rdi),%edx
     b7e:	01 14 04             	add    %edx,(%rsp,%rax,1)
    if (xpop_stats_data) {
     b81:	8f 02                	pop    (%rdx)
     b83:	aa                   	stos   %al,%es:(%rdi)
        xpop_stats_data->v1 += 1; // IPv4 inner packets
     b84:	02 02                	add    (%rdx),%al
     b86:	30 9f 04 aa 02 d8    	xor    %bl,-0x27fd55fc(%rdi)
     b8c:	02 01                	add    (%rcx),%al
     b8e:	52                   	push   %rdx
     b8f:	00 01                	add    %al,(%rcx)
  bpf_tail_call(ctx, &subprograms, i);
     b91:	14 04                	adc    $0x4,%al
     b93:	b2 02                	mov    $0x2,%dl
     b95:	b7 02                	mov    $0x2,%bh
     b97:	03 7f 10             	add    0x10(%rdi),%edi
     b9a:	9f                   	lahf
     b9b:	04 b7                	add    $0xb7,%al
     b9d:	02 c2                	add    %dl,%al
     b9f:	02 03                	add    (%rbx),%al
     ba1:	7f 12                	jg     bb5 <balancer_ingress+0xbb5>
     ba3:	9f                   	lahf
     ba4:	04 c2                	add    $0xc2,%al
     ba6:	02 ca                	add    %dl,%cl
     ba8:	02 03                	add    (%rbx),%al
     baa:	7f 16                	jg     bc2 <balancer_ingress+0xbc2>
     bac:	9f                   	lahf
     bad:	04 ca                	add    $0xca,%al
     baf:	02 d3                	add    %bl,%dl
     bb1:	02 03                	add    (%rbx),%al
     bb3:	7f 1a                	jg     bcf <balancer_ingress+0xbcf>
     bb5:	9f                   	lahf
     bb6:	04 d3                	add    $0xd3,%al
     bb8:	02 d8                	add    %al,%bl
     bba:	02 03                	add    (%rbx),%al
     bbc:	7f 1e                	jg     bdc <balancer_ingress+0xbdc>
     bbe:	9f                   	lahf
     bbf:	00 01                	add    %al,(%rcx)
     bc1:	14 04                	adc    $0x4,%al
        bpf_map_lookup_elem(&stats, &stats_key);
     bc3:	b2 02                	mov    $0x2,%dl
     bc5:	b7 02                	mov    $0x2,%bh
     bc7:	03 11                	add    (%rcx),%edx
     bc9:	00 9f 04 b7 02 c2    	add    %bl,-0x3dfd48fc(%rdi)
    if (!icmp_ptb_v6_stats) {
     bcf:	02 03                	add    (%rbx),%al
     bd1:	11 02                	adc    %eax,(%rdx)
     bd3:	9f                   	lahf
     bd4:	04 c2                	add    $0xc2,%al
     bd6:	02 ca                	add    %dl,%cl
    icmp_ptb_v6_stats->v1 += 1;
     bd8:	02 03                	add    (%rbx),%al
     bda:	11 04 9f             	adc    %eax,(%rdi,%rbx,4)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     bdd:	04 ca                	add    $0xca,%al
     bdf:	02 d3                	add    %bl,%dl
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     be1:	02 03                	add    (%rbx),%al
     be3:	11 06                	adc    %eax,(%rsi)
     be5:	9f                   	lahf
     be6:	04 d3                	add    $0xd3,%al
     be8:	02 d8                	add    %al,%bl
      icmp_ptb_v6_stats->v2 += 1;
     bea:	02 03                	add    (%rbx),%al
     bec:	11 07                	adc    %eax,(%rdi)
  if (ip6h + 1 > data_end) {
     bee:	9f                   	lahf
     bef:	00 01                	add    %al,(%rcx)
     bf1:	14 04                	adc    $0x4,%al
     bf3:	d8 02                	fadds  (%rdx)
     bf5:	9e                   	sahf
     bf6:	04 01                	add    $0x1,%al
     bf8:	55                   	push   %rbp
     bf9:	04 93                	add    $0x93,%al
     bfb:	05 ad 06 01 55       	add    $0x550106ad,%eax
  pckt->flow.proto = ip6h->nexthdr;
     c00:	04 ce                	add    $0xce,%al
     c02:	07                   	(bad)
     c03:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     c04:	08 01                	or     %al,(%rcx)
     c06:	55                   	push   %rbp
     c07:	04 db                	add    $0xdb,%al
  pckt->flags |= F_ICMP;
     c09:	09 a0 0b 01 55 04    	or     %esp,0x455010b(%rax)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     c0f:	a0 0b ac 0b 01 53 04 	movabs 0xbac0453010bac0b,%al
     c16:	ac 0b 
     c18:	b1 0b                	mov    $0xb,%cl
     c1a:	01 55 04             	add    %edx,0x4(%rbp)
     c1d:	c5 0d eb 0d 01 55 04 	vpor   -0x14fbaaff(%rip),%ymm14,%ymm9        # ffffffffeb046126 <server_id_map+0x36ffd295d126>
     c24:	eb 
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     c25:	0d f7 0d 01 53       	or     $0x53010df7,%eax
     c2a:	04 f7                	add    $0xf7,%al
     c2c:	0d fc 0d 01 55       	or     $0x55010dfc,%eax
     c31:	04 a3                	add    $0xa3,%al
  if (protocol == IPPROTO_IPIP) {
     c33:	10 bf 10 01 55 04    	adc    %bh,0x4550110(%rdi)
     c39:	bf 10 d1 10 03       	mov    $0x310d110,%edi
     c3e:	77 d0                	ja     c10 <balancer_ingress+0xc10>
     c40:	00 04 d1             	add    %al,(%rcx,%rdx,8)
     c43:	10 c2                	adc    %al,%dl
     c45:	11 01                	adc    %eax,(%rcx)
     c47:	55                   	push   %rbp
     c48:	04 c2                	add    $0xc2,%al
     c4a:	11 a6 13 03 77 d0    	adc    %esp,-0x2f88fced(%rsi)
     c50:	00 04 97             	add    %al,(%rdi,%rdx,4)
     c53:	14 d5                	adc    $0xd5,%al
     c55:	14 03                	adc    $0x3,%al
     c57:	77 d0                	ja     c29 <balancer_ingress+0xc29>
     c59:	00 04 c4             	add    %al,(%rsp,%rax,8)
     c5c:	1d 92 1f 03 77       	sbb    $0x77031f92,%eax
  struct address dst_addr = {};
     c61:	d0 00                	rolb   (%rax)
     c63:	04 d0                	add    $0xd0,%al
     c65:	1f                   	(bad)
     c66:	8c 20                	mov    %fs,(%rax)
     c68:	03 77 d0             	add    -0x30(%rdi),%esi
     c6b:	00 04 a2             	add    %al,(%rdx,%riz,4)
    dst_addr.addr = pckt->flow.dst;
     c6e:	22 f5                	and    %ch,%dh
     c70:	22 03                	and    (%rbx),%al
     c72:	77 d0                	ja     c44 <balancer_ingress+0xc44>
     c74:	00 04 cb             	add    %al,(%rbx,%rcx,8)
     c77:	23 b0 32 03 77 d0    	and    -0x2f88fcce(%rax),%esi
     c7d:	00 04 95 41 fa 42 03 	add    %al,0x342fa41(,%rdx,4)
     c84:	77 d0                	ja     c56 <balancer_ingress+0xc56>
     c86:	00 00                	add    %al,(%rax)
     c88:	01 14 04             	add    %edx,(%rsp,%rax,1)
  if (decap_dst_flags) {
     c8b:	d8 02                	fadds  (%rdx)
     c8d:	9e                   	sahf
     c8e:	04 02                	add    $0x2,%al
     c90:	3e 9f                	ds lahf
     c92:	04 93                	add    $0x93,%al
     c94:	05 ad 06 02 3e       	add    $0x3e0206ad,%eax
     c99:	9f                   	lahf
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c9a:	04 ce                	add    $0xce,%al
     c9c:	07                   	(bad)
     c9d:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     c9e:	08 02                	or     %al,(%rdx)
     ca0:	3e 9f                	ds lahf
     ca2:	04 db                	add    $0xdb,%al
     ca4:	09 a6 13 02 3e 9f    	or     %esp,-0x60c1fded(%rsi)
    if (!data_stats) {
     caa:	04 97                	add    $0x97,%al
     cac:	14 d5                	adc    $0xd5,%al
     cae:	14 02                	adc    $0x2,%al
    data_stats->v1 += 1;
     cb0:	3e 9f                	ds lahf
    if ((*data + offset) > *data_end) {
     cb2:	04 c4                	add    $0xc4,%al
     cb4:	1d 92 1f 02 3e       	sbb    $0x3e021f92,%eax
     cb9:	9f                   	lahf
     cba:	04 d0                	add    $0xd0,%al
     cbc:	1f                   	(bad)
     cbd:	8c 20                	mov    %fs,(%rax)
     cbf:	02 3e                	add    (%rsi),%bh
     cc1:	9f                   	lahf
     cc2:	04 a2                	add    $0xa2,%al
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     cc4:	22 f5                	and    %ch,%dh
     cc6:	22 02                	and    (%rdx),%al
     cc8:	3e 9f                	ds lahf
     cca:	04 cb                	add    $0xcb,%al
     ccc:	23 b0 32 02 3e 9f    	and    -0x60c1fdce(%rax),%esi
    if (!--ip6h->hop_limit) {
     cd2:	04 95                	add    $0x95,%al
     cd4:	41 fa                	rex.B cli
     cd6:	42 02 3e             	rex.X add (%rsi),%dil
     cd9:	9f                   	lahf
     cda:	00 01                	add    %al,(%rcx)
     cdc:	14 04                	adc    $0x4,%al
     cde:	d8 02                	fadds  (%rdx)
     ce0:	9e                   	sahf
     ce1:	04 02                	add    $0x2,%al
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     ce3:	31 9f 04 93 05 ad    	xor    %ebx,-0x52fa6cfc(%rdi)
     ce9:	06                   	(bad)
     cea:	02 31                	add    (%rcx),%dh
     cec:	9f                   	lahf
     ced:	04 ce                	add    $0xce,%al
     cef:	07                   	(bad)
     cf0:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     cf1:	08 02                	or     %al,(%rdx)
     cf3:	31 9f 04 db 09 a6    	xor    %ebx,-0x59f624fc(%rdi)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     cf9:	13 02                	adc    (%rdx),%eax
     cfb:	31 9f 04 97 14 d5    	xor    %ebx,-0x2aeb68fc(%rdi)
     d01:	14 02                	adc    $0x2,%al
     d03:	31 9f 04 c4 1d 92    	xor    %ebx,-0x6de23bfc(%rdi)
    new_eth->h_proto = BE_ETH_P_IPV6;
     d09:	1f                   	(bad)
     d0a:	02 31                	add    (%rcx),%dh
     d0c:	9f                   	lahf
     d0d:	04 d0                	add    $0xd0,%al
     d0f:	1f                   	(bad)
     d10:	8c 20                	mov    %fs,(%rax)
     d12:	02 31                	add    (%rcx),%dh
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     d14:	9f                   	lahf
     d15:	04 a2                	add    $0xa2,%al
     d17:	22 f5                	and    %ch,%dh
     d19:	22 02                	and    (%rdx),%al
     d1b:	31 9f 04 cb 23 b0    	xor    %ebx,-0x4fdc34fc(%rdi)
     d21:	32 02                	xor    (%rdx),%al
     d23:	31 9f 04 95 41 fa    	xor    %ebx,-0x5be6afc(%rdi)
     d29:	42 02 31             	rex.X add (%rcx),%sil
     d2c:	9f                   	lahf
     d2d:	00 01                	add    %al,(%rcx)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     d2f:	14 04                	adc    $0x4,%al
     d31:	d8 02                	fadds  (%rdx)
     d33:	9e                   	sahf
     d34:	04 01                	add    $0x1,%al
     d36:	5f                   	pop    %rdi
     d37:	04 93                	add    $0x93,%al
     d39:	05 ad 06 01 5f       	add    $0x5f0106ad,%eax
  if (!data_stats) {
     d3e:	04 ce                	add    $0xce,%al
     d40:	07                   	(bad)
     d41:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     d42:	08 01                	or     %al,(%rcx)
     d44:	5f                   	pop    %rdi
     d45:	04 db                	add    $0xdb,%al
     d47:	09 a6 13 01 5f 04    	or     %esp,0x45f0113(%rsi)
  if (action >= 0) {
     d4d:	97                   	xchg   %eax,%edi
     d4e:	14 d5                	adc    $0xd5,%al
     d50:	14 01                	adc    $0x1,%al
     d52:	5f                   	pop    %rdi
     d53:	04 c4                	add    $0xc4,%al
     d55:	1d 95 1e 01 5f       	sbb    $0x5f011e95,%eax
     d5a:	04 d0                	add    $0xd0,%al
     d5c:	1f                   	(bad)
     d5d:	8c 20                	mov    %fs,(%rax)
     d5f:	01 5f 00             	add    %ebx,0x0(%rdi)
     d62:	01 14 04             	add    %edx,(%rsp,%rax,1)
     d65:	d8 02                	fadds  (%rdx)
     d67:	9e                   	sahf
     d68:	04 01                	add    $0x1,%al
     d6a:	5d                   	pop    %rbp
     d6b:	04 93                	add    $0x93,%al
     d6d:	05 ad 06 01 5d       	add    $0x5d0106ad,%eax
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     d72:	04 ce                	add    $0xce,%al
     d74:	07                   	(bad)
     d75:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     d76:	08 01                	or     %al,(%rcx)
     d78:	5d                   	pop    %rbp
     d79:	04 db                	add    $0xdb,%al
     d7b:	09 a6 13 01 5d 04    	or     %esp,0x45d0113(%rsi)
    if (xpop_stats_data) {
     d81:	97                   	xchg   %eax,%edi
     d82:	14 d5                	adc    $0xd5,%al
        xpop_stats_data->v2 += 1; // IPv6 inner packets
     d84:	14 01                	adc    $0x1,%al
     d86:	5d                   	pop    %rbp
     d87:	04 c4                	add    $0xc4,%al
     d89:	1d 92 1f 01 5d       	sbb    $0x5d011f92,%eax
     d8e:	04 d0                	add    $0xd0,%al
     d90:	1f                   	(bad)
  bpf_tail_call(ctx, &subprograms, i);
     d91:	8c 20                	mov    %fs,(%rax)
     d93:	01 5d 04             	add    %ebx,0x4(%rbp)
     d96:	a2 22 f5 22 01 5d 04 	movabs %al,0x23cb045d0122f522
     d9d:	cb 23 
     d9f:	99                   	cltd
     da0:	25 01 5d 04 d1       	and    $0xd1045d01,%eax
     da5:	25 c0 26 01 5d       	and    $0x5d0126c0,%eax
     daa:	04 c2                	add    $0xc2,%al
     dac:	26 c5 26 01          	(bad)
     db0:	5d                   	pop    %rbp
     db1:	04 c7                	add    $0xc7,%al
     db3:	26 d1 26             	es shll (%rsi)
     db6:	01 5d 00             	add    %ebx,0x0(%rbp)
  udp = data + off;
     db9:	01 14 04             	add    %edx,(%rsp,%rax,1)
     dbc:	d8 02                	fadds  (%rdx)
  if (is_ipv6) {
     dbe:	9e                   	sahf
  udp = data + off;
     dbf:	04 02                	add    $0x2,%al
     dc1:	30 9f 04 93 05 ad    	xor    %bl,-0x52fa6cfc(%rdi)
  if (udp + 1 > data_end) {
     dc7:	06                   	(bad)
     dc8:	02 30                	add    (%rax),%dh
     dca:	9f                   	lahf
     dcb:	04 ce                	add    $0xce,%al
     dcd:	07                   	(bad)
     dce:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     dcf:	08 02                	or     %al,(%rdx)
     dd1:	30 9f 04 db 09 a6    	xor    %bl,-0x59f624fc(%rdi)
     dd7:	13 02                	adc    (%rdx),%eax
     dd9:	30 9f 04 97 14 d5    	xor    %bl,-0x2aeb68fc(%rdi)
     ddf:	14 02                	adc    $0x2,%al
     de1:	30 9f 04 c4 1d 92    	xor    %bl,-0x6de23bfc(%rdi)
     de7:	1f                   	(bad)
     de8:	02 30                	add    (%rax),%dh
     dea:	9f                   	lahf
     deb:	04 d0                	add    $0xd0,%al
     ded:	1f                   	(bad)
     dee:	8c 20                	mov    %fs,(%rax)
     df0:	02 30                	add    (%rax),%dh
     df2:	9f                   	lahf
     df3:	04 a2                	add    $0xa2,%al
     df5:	22 f5                	and    %ch,%dh
     df7:	22 02                	and    (%rdx),%al
    vip.vip = pckt.flow.dst;
     df9:	30 9f 04 cb 23 81    	xor    %bl,-0x7edc34fc(%rdi)
     dff:	25 02 30 9f 04       	and    $0x49f3002,%eax
  vip.port = pckt.flow.port16[1];
     e04:	d1 25 d1 28 02 30    	shll   0x300228d1(%rip)        # 300236db <_license+0x30021346>
     e0a:	9f                   	lahf
     e0b:	04 d1                	add    $0xd1,%al
     e0d:	28 e6                	sub    %ah,%dh
     e0f:	28 01                	sub    %al,(%rcx)
     e11:	5d                   	pop    %rbp
     e12:	04 d7                	add    $0xd7,%al
     e14:	29 c5                	sub    %eax,%ebp
     e16:	2b 01                	sub    (%rcx),%eax
     e18:	5d                   	pop    %rbp
     e19:	04 f6                	add    $0xf6,%al
     e1b:	30 b0 32 01 5d 00    	xor    %dh,0x5d0132(%rax)
  if (!vip_info) {
     e21:	01 14 04             	add    %edx,(%rsp,%rax,1)
     e24:	a8 03                	test   $0x3,%al
     e26:	9e                   	sahf
     e27:	04 02                	add    $0x2,%al
     e29:	30 9f 04 93 05 ad    	xor    %bl,-0x52fa6cfc(%rdi)
  if (data_end - data > MAX_PCKT_SIZE) {
     e2f:	06                   	(bad)
     e30:	02 30                	add    (%rax),%dh
     e32:	9f                   	lahf
     e33:	04 ce                	add    $0xce,%al
     e35:	07                   	(bad)
     e36:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     e37:	08 02                	or     %al,(%rdx)
     e39:	30 9f 04 db 09 a6    	xor    %bl,-0x59f624fc(%rdi)
     e3f:	13 02                	adc    (%rdx),%eax
     e41:	30 9f 04 97 14 d5    	xor    %bl,-0x2aeb68fc(%rdi)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     e47:	14 02                	adc    $0x2,%al
     e49:	30 9f 04 c4 1d 92    	xor    %bl,-0x6de23bfc(%rdi)
     e4f:	1f                   	(bad)
     e50:	02 30                	add    (%rax),%dh
     e52:	9f                   	lahf
  if (!data_stats) {
     e53:	04 d0                	add    $0xd0,%al
     e55:	1f                   	(bad)
     e56:	8c 20                	mov    %fs,(%rax)
     e58:	02 30                	add    (%rax),%dh
     e5a:	9f                   	lahf
     e5b:	04 a2                	add    $0xa2,%al
  data_stats->v1 += 1;
     e5d:	22 f5                	and    %ch,%dh
     e5f:	22 02                	and    (%rdx),%al
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     e61:	30 9f 04 cb 23 b0    	xor    %bl,-0x4fdc34fc(%rdi)
    pckt.flow.port16[0] = 0;
     e67:	32 02                	xor    (%rdx),%al
     e69:	30 9f 04 95 41 fa    	xor    %bl,-0x5be6afc(%rdi)
  vip_num = vip_info->vip_num;
     e6f:	42 02 30             	rex.X add (%rax),%sil
     e72:	9f                   	lahf
     e73:	00 01                	add    %al,(%rcx)
     e75:	14 04                	adc    $0x4,%al
  __u32 cpu_num = bpf_get_smp_processor_id();
     e77:	a8 03                	test   $0x3,%al
     e79:	9e                   	sahf
     e7a:	04 02                	add    $0x2,%al
     e7c:	30 9f 04 93 05 b7    	xor    %bl,-0x48fa6cfc(%rdi)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e82:	05 02 30 9f 04       	add    $0x49f3002,%eax
     e87:	b7 05                	mov    $0x5,%bh
     e89:	ad                   	lods   %ds:(%rsi),%eax
     e8a:	06                   	(bad)
     e8b:	03 10                	add    (%rax),%edx
     e8d:	36 9f                	ss lahf
     e8f:	04 ce                	add    $0xce,%al
     e91:	07                   	(bad)
     e92:	e6 07                	out    %al,$0x7
     e94:	03 10                	add    (%rax),%edx
     e96:	36 9f                	ss lahf
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e98:	04 db                	add    $0xdb,%al
     e9a:	09 ce                	or     %ecx,%esi
     e9c:	0a 02                	or     (%rdx),%al
     e9e:	30 9f 04 d1 10 c2    	xor    %bl,-0x3def2efc(%rdi)
    if (!lru_stats) {
     ea4:	11 03                	adc    %eax,(%rbx)
     ea6:	10 36                	adc    %dh,(%rsi)
     ea8:	9f                   	lahf
     ea9:	00 01                	add    %al,(%rcx)
     eab:	14 04                	adc    $0x4,%al
    lru_stats->v1 += 1;
     ead:	a8 03                	test   $0x3,%al
     eaf:	eb 03                	jmp    eb4 <balancer_ingress+0xeb4>
     eb1:	03 77 10             	add    0x10(%rdi),%esi
     eb4:	9f                   	lahf
     eb5:	04 93                	add    $0x93,%al
     eb7:	05 c0 05 03 77       	add    $0x770305c0,%eax
     ebc:	10 9f 00 01 14 04    	adc    %bl,0x4140100(%rdi)
     ec2:	a8 03                	test   $0x3,%al
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     ec4:	eb 03                	jmp    ec9 <balancer_ingress+0xec9>
     ec6:	02 3e                	add    (%rsi),%bh
     ec8:	9f                   	lahf
     ec9:	04 93                	add    $0x93,%al
     ecb:	05 c0 05 02 3e       	add    $0x3e0205c0,%eax
     ed0:	9f                   	lahf
     ed1:	00 01                	add    %al,(%rcx)
     ed3:	14 04                	adc    $0x4,%al
  if (!lru_map) {
     ed5:	a8 03                	test   $0x3,%al
     ed7:	eb 03                	jmp    edc <balancer_ingress+0xedc>
     ed9:	01 5f 04             	add    %ebx,0x4(%rdi)
     edc:	93                   	xchg   %eax,%ebx
     edd:	05 c0 05 01 5f       	add    $0x5f0105c0,%eax
  if ((vip_info->flags & F_QUIC_VIP)) {
     ee2:	00 01                	add    %al,(%rcx)
     ee4:	14 04                	adc    $0x4,%al
     ee6:	a8 03                	test   $0x3,%al
    bool is_icmp = (pckt.flags & F_ICMP);
     ee8:	eb 03                	jmp    eed <balancer_ingress+0xeed>
     eea:	01 5d 04             	add    %ebx,0x4(%rbp)
    if (is_icmp) {
     eed:	93                   	xchg   %eax,%ebx
     eee:	05 c0 05 01 5d       	add    $0x5d0105c0,%eax
     ef3:	00 01                	add    %al,(%rcx)
     ef5:	14 04                	adc    $0x4,%al
     ef7:	a8 03                	test   $0x3,%al
     ef9:	eb 03                	jmp    efe <balancer_ingress+0xefe>
     efb:	02 31                	add    (%rcx),%dh
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     efd:	9f                   	lahf
     efe:	04 93                	add    $0x93,%al
     f00:	05 c0 05 02 31       	add    $0x310205c0,%eax
     f05:	9f                   	lahf
     f06:	00 01                	add    %al,(%rcx)
      if (!quic_packets_stats) {
     f08:	14 04                	adc    $0x4,%al
     f0a:	a8 03                	test   $0x3,%al
     f0c:	b5 03                	mov    $0x3,%ch
     f0e:	03 7f 0e             	add    0xe(%rdi),%edi
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     f11:	9f                   	lahf
     f12:	04 b5                	add    $0xb5,%al
     f14:	03 ba 03 01 52 00    	add    0x520103(%rdx),%edi
     f1a:	01 14 04             	add    %edx,(%rsp,%rax,1)
     f1d:	b5 03                	mov    $0x3,%ch
     f1f:	eb 03                	jmp    f24 <balancer_ingress+0xf24>
     f21:	03 10                	add    (%rax),%edx
     f23:	28 9f 04 93 05 c0    	sub    %bl,-0x3ffa6cfc(%rdi)
     f29:	05 03 10 28 9f       	add    $0x9f281003,%eax
     f2e:	00 01                	add    %al,(%rcx)
     f30:	14 04                	adc    $0x4,%al
     f32:	eb 03                	jmp    f37 <balancer_ingress+0xf37>
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     f34:	9e                   	sahf
     f35:	04 01                	add    $0x1,%al
     f37:	5f                   	pop    %rdi
     f38:	04 db                	add    $0xdb,%al
     f3a:	09 ce                	or     %ecx,%esi
     f3c:	0a 01                	or     (%rcx),%al
     f3e:	5f                   	pop    %rdi
     f3f:	00 01                	add    %al,(%rcx)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     f41:	14 04                	adc    $0x4,%al
     f43:	eb 03                	jmp    f48 <balancer_ingress+0xf48>
     f45:	9e                   	sahf
     f46:	04 01                	add    $0x1,%al
     f48:	5d                   	pop    %rbp
     f49:	04 db                	add    $0xdb,%al
     f4b:	09 ce                	or     %ecx,%esi
  if (!connId) {
     f4d:	0a 01                	or     (%rcx),%al
     f4f:	5d                   	pop    %rbp
     f50:	00 01                	add    %al,(%rcx)
     f52:	14 04                	adc    $0x4,%al
     f54:	eb 03                	jmp    f59 <balancer_ingress+0xf59>
  __u8 connIdVersion = (connId[0] >> 6);
     f56:	9e                   	sahf
     f57:	04 03                	add    $0x3,%al
     f59:	10 36                	adc    %dh,(%rsi)
     f5b:	9f                   	lahf
     f5c:	04 db                	add    $0xdb,%al
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     f5e:	09 8f 0a 03 10 36    	or     %ecx,0x3610030a(%rdi)
     f64:	9f                   	lahf
     f65:	00 01                	add    %al,(%rcx)
     f67:	14 04                	adc    $0x4,%al
     f69:	eb 03                	jmp    f6e <balancer_ingress+0xf6e>
     f6b:	9e                   	sahf
     f6c:	04 03                	add    $0x3,%al
     f6e:	77 10                	ja     f80 <balancer_ingress+0xf80>
     f70:	9f                   	lahf
     f71:	04 db                	add    $0xdb,%al
     f73:	09 ce                	or     %ecx,%esi
     f75:	0a 03                	or     (%rbx),%al
     f77:	77 10                	ja     f89 <balancer_ingress+0xf89>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     f79:	9f                   	lahf
     f7a:	00 01                	add    %al,(%rcx)
     f7c:	14 04                	adc    $0x4,%al
     f7e:	eb 03                	jmp    f83 <balancer_ingress+0xf83>
     f80:	f8                   	clc
     f81:	03 03                	add    (%rbx),%eax
     f83:	7f 36                	jg     fbb <balancer_ingress+0xfbb>
     f85:	9f                   	lahf
     f86:	04 f8                	add    $0xf8,%al
     f88:	03 9e 04 01 53 04    	add    0x4530104(%rsi),%ebx
     f8e:	db 09                	fisttpl (%rcx)
     f90:	ce                   	(bad)
     f91:	0a 01                	or     (%rcx),%al
    vip.port = 0;
     f93:	53                   	push   %rbx
     f94:	00 01                	add    %al,(%rcx)
     f96:	14 04                	adc    $0x4,%al
     f98:	b7 05                	mov    $0x5,%bh
     f9a:	ad                   	lods   %ds:(%rsi),%eax
     f9b:	06                   	(bad)
     f9c:	03 11                	add    (%rcx),%edx
     f9e:	7f 9f                	jg     f3f <balancer_ingress+0xf3f>
     fa0:	04 ce                	add    $0xce,%al
     fa2:	07                   	(bad)
     fa3:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     fa4:	08 03                	or     %al,(%rbx)
     fa6:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     fa9:	04 d3                	add    $0xd3,%al
    if (!vip_info) {
     fab:	0a a6 13 03 11 7f    	or     0x7f110313(%rsi),%ah
     fb1:	9f                   	lahf
     fb2:	04 97                	add    $0x97,%al
     fb4:	14 d5                	adc    $0xd5,%al
     fb6:	14 03                	adc    $0x3,%al
     fb8:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     fbb:	04 c4                	add    $0xc4,%al
     fbd:	1d 92 1f 03 11       	sbb    $0x11031f92,%eax
     fc2:	7f 9f                	jg     f63 <balancer_ingress+0xf63>
      pckt.flow.port16[1] = 0;
     fc4:	04 d0                	add    $0xd0,%al
     fc6:	1f                   	(bad)
     fc7:	8c 20                	mov    %fs,(%rax)
     fc9:	03 11                	add    (%rcx),%edx
     fcb:	7f 9f                	jg     f6c <balancer_ingress+0xf6c>
     fcd:	04 a2                	add    $0xa2,%al
     fcf:	22 f5                	and    %ch,%dh
     fd1:	22 03                	and    (%rbx),%al
     fd3:	11 7f 9f             	adc    %edi,-0x61(%rdi)
     fd6:	04 cb                	add    $0xcb,%al
     fd8:	23 b0 32 03 11 7f    	and    0x7f110332(%rax),%esi
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fde:	9f                   	lahf
     fdf:	04 95                	add    $0x95,%al
     fe1:	41 fa                	rex.B cli
     fe3:	42 03 11             	rex.X add (%rcx),%edx
      if (!data_stats) {
     fe6:	7f 9f                	jg     f87 <balancer_ingress+0xf87>
     fe8:	00 01                	add    %al,(%rcx)
     fea:	14 04                	adc    $0x4,%al
     fec:	b7 05                	mov    $0x5,%bh
     fee:	d0 05 01 52 04 ce    	rolb   -0x31fbadff(%rip)        # ffffffffce0461f5 <server_id_map+0x36ffb595d1f5>
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     ff4:	07                   	(bad)
     ff5:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
     ff6:	08 01                	or     %al,(%rcx)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     ff8:	52                   	push   %rdx
     ff9:	04 d3                	add    $0xd3,%al
     ffb:	0a 84 0b 01 52 04 c5 	or     -0x3afbadff(%rbx,%rcx,1),%al
    1002:	0d cf 0d 01 52       	or     $0x52010dcf,%eax
    1007:	04 a3                	add    $0xa3,%al
    1009:	10 d1                	adc    %dl,%cl
    100b:	10 01                	adc    %al,(%rcx)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
    100d:	52                   	push   %rdx
    100e:	04 c2                	add    $0xc2,%al
    1010:	11 88 12 01 52 00    	adc    %ecx,0x520112(%rax)
    1016:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1019:	b7 05                	mov    $0x5,%bh
    101b:	ad                   	lods   %ds:(%rsi),%eax
    101c:	06                   	(bad)
    101d:	01 5f 04             	add    %ebx,0x4(%rdi)
    1020:	d1 10                	rcll   (%rax)
  if (!lru_map) {
    1022:	c2 11 01             	ret    $0x111
    1025:	5f                   	pop    %rdi
    1026:	00 01                	add    %al,(%rcx)
    1028:	14 04                	adc    $0x4,%al
    102a:	b7 05                	mov    $0x5,%bh
    102c:	ad                   	lods   %ds:(%rsi),%eax
    102d:	06                   	(bad)
    102e:	01 5d 04             	add    %ebx,0x4(%rbp)
  if ((vip_info->flags & F_QUIC_VIP)) {
    1031:	d1 10                	rcll   (%rax)
    1033:	c2 11 01             	ret    $0x111
    1036:	5d                   	pop    %rbp
    1037:	00 01                	add    %al,(%rcx)
    1039:	14 04                	adc    $0x4,%al
    103b:	b7 05                	mov    $0x5,%bh
    103d:	ad                   	lods   %ds:(%rsi),%eax
    bool is_icmp = (pckt.flags & F_ICMP);
    103e:	06                   	(bad)
    103f:	03 10                	add    (%rax),%edx
    1041:	36 9f                	ss lahf
    if (is_icmp) {
    1043:	04 d1                	add    $0xd1,%al
    1045:	10 c2                	adc    %al,%dl
    1047:	11 03                	adc    %eax,(%rbx)
    1049:	10 36                	adc    %dh,(%rsi)
    104b:	9f                   	lahf
    104c:	00 01                	add    %al,(%rcx)
    104e:	14 04                	adc    $0x4,%al
    1050:	b7 05                	mov    $0x5,%bh
    1052:	ad                   	lods   %ds:(%rsi),%eax
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
    1053:	06                   	(bad)
    1054:	03 77 10             	add    0x10(%rdi),%esi
    1057:	9f                   	lahf
    1058:	04 d1                	add    $0xd1,%al
    105a:	10 c2                	adc    %al,%dl
    105c:	11 03                	adc    %eax,(%rbx)
    105e:	77 10                	ja     1070 <balancer_ingress+0x1070>
      if (!quic_packets_stats) {
    1060:	9f                   	lahf
    1061:	00 01                	add    %al,(%rcx)
    1063:	14 04                	adc    $0x4,%al
    1065:	b7 05                	mov    $0x5,%bh
    1067:	d0 05 01 52 00 01    	rolb   0x1005201(%rip)        # 100626e <_license+0x1003ed9>
  bool is_icmp = (pckt->flags & F_ICMP);
    106d:	14 04                	adc    $0x4,%al
    106f:	c0 05 ad 06 01 5f 04 	rolb   $0x4,0x5f0106ad(%rip)        # 5f011723 <_license+0x5f00f38e>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1076:	d1 10                	rcll   (%rax)
    1078:	c2 11 01             	ret    $0x111
    107b:	5f                   	pop    %rdi
    107c:	00 01                	add    %al,(%rcx)
    107e:	14 04                	adc    $0x4,%al
    1080:	c0 05 ad 06 01 5d 04 	rolb   $0x4,0x5d0106ad(%rip)        # 5d011734 <_license+0x5d00f39f>
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    1087:	d1 10                	rcll   (%rax)
    1089:	c2 11 01             	ret    $0x111
    108c:	5d                   	pop    %rbp
    108d:	00 01                	add    %al,(%rcx)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    108f:	14 04                	adc    $0x4,%al
    1091:	c0 05 ad 06 03 10 36 	rolb   $0x36,0x100306ad(%rip)        # 10031745 <_license+0x1002f3b0>
    1098:	9f                   	lahf
    1099:	04 d1                	add    $0xd1,%al
    109b:	10 85 11 03 10 36    	adc    %al,0x36100311(%rbp)
  if (!connId) {
    10a1:	9f                   	lahf
    10a2:	00 01                	add    %al,(%rcx)
    10a4:	14 04                	adc    $0x4,%al
  __u8 connIdVersion = (connId[0] >> 6);
    10a6:	c0 05 ad 06 03 77 10 	rolb   $0x10,0x770306ad(%rip)        # 7703175a <_license+0x7702f3c5>
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10ad:	9f                   	lahf
    10ae:	04 d1                	add    $0xd1,%al
    10b0:	10 c2                	adc    %al,%dl
    10b2:	11 03                	adc    %eax,(%rbx)
    10b4:	77 10                	ja     10c6 <balancer_ingress+0x10c6>
    10b6:	9f                   	lahf
    10b7:	00 01                	add    %al,(%rcx)
    10b9:	14 04                	adc    $0x4,%al
    10bb:	c0 05 cd 05 03 7f 36 	rolb   $0x36,0x7f0305cd(%rip)        # 7f03168f <_license+0x7f02f2fa>
    10c2:	9f                   	lahf
    10c3:	04 cd                	add    $0xcd,%al
    10c5:	05 ad 06 01 53       	add    $0x530106ad,%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    10ca:	04 d1                	add    $0xd1,%al
    10cc:	10 c2                	adc    %al,%dl
    10ce:	11 01                	adc    %eax,(%rcx)
    10d0:	53                   	push   %rbx
    10d1:	00 01                	add    %al,(%rcx)
    10d3:	14 04                	adc    $0x4,%al
    10d5:	e7 05                	out    %eax,$0x5
    10d7:	ff 05 02 30 9f 04    	incl   0x49f3002(%rip)        # 49f40df <_license+0x49f1d4a>
    10dd:	ff 05 ad 06 01 52    	incl   0x520106ad(%rip)        # 52011790 <_license+0x5200f3fb>
    10e3:	00 01                	add    %al,(%rcx)
    10e5:	14 04                	adc    $0x4,%al
    10e7:	87 06                	xchg   %eax,(%rsi)
    10e9:	8c 06                	mov    %es,(%rsi)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    10eb:	03 11                	add    (%rcx),%edx
    10ed:	00 9f 04 8c 06 94    	add    %bl,-0x6bf973fc(%rdi)
    10f3:	06                   	(bad)
    10f4:	03 11                	add    (%rcx),%edx
    10f6:	01 9f 04 94 06 9f    	add    %ebx,-0x60f96bfc(%rdi)
      if (!data_stats) {
    10fc:	06                   	(bad)
    10fd:	03 11                	add    (%rcx),%edx
    10ff:	03 9f 04 9f 06 a4    	add    -0x5bf960fc(%rdi),%ebx
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    1105:	06                   	(bad)
    1106:	03 11                	add    (%rcx),%edx
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    1108:	04 9f                	add    $0x9f,%al
    110a:	04 a4                	add    $0xa4,%al
    110c:	06                   	(bad)
    110d:	ad                   	lods   %ds:(%rsi),%eax
    110e:	06                   	(bad)
    110f:	03 11                	add    (%rcx),%edx
    1111:	06                   	(bad)
    1112:	9f                   	lahf
    1113:	00 01                	add    %al,(%rcx)
    1115:	14 04                	adc    $0x4,%al
    1117:	87 06                	xchg   %eax,(%rsi)
        data_stats->v2 += 1;
    1119:	94                   	xchg   %eax,%esp
    111a:	06                   	(bad)
    111b:	03 7f 10             	add    0x10(%rdi),%edi
    111e:	9f                   	lahf
    111f:	04 94                	add    $0x94,%al
    1121:	06                   	(bad)
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1122:	9f                   	lahf
    1123:	06                   	(bad)
    1124:	03 7f 16             	add    0x16(%rdi),%edi
    1127:	9f                   	lahf
    1128:	04 9f                	add    $0x9f,%al
    112a:	06                   	(bad)
    112b:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    112c:	06                   	(bad)
    112d:	03 7f 18             	add    0x18(%rdi),%edi
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1130:	9f                   	lahf
    1131:	04 a4                	add    $0xa4,%al
    1133:	06                   	(bad)
    1134:	ad                   	lods   %ds:(%rsi),%eax
    1135:	06                   	(bad)
    1136:	03 7f 1a             	add    0x1a(%rdi),%edi
        quic_packets_stats->cid_initial += 1;
    1139:	9f                   	lahf
    113a:	00 01                	add    %al,(%rcx)
    113c:	14 04                	adc    $0x4,%al
    113e:	84 08                	test   %cl,(%rax)
    1140:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1141:	08 01                	or     %al,(%rcx)
    1143:	50                   	push   %rax
    1144:	00 01                	add    %al,(%rcx)
    1146:	14 04                	adc    $0x4,%al
    1148:	b5 08                	mov    $0x8,%ch
    114a:	db 09                	fisttpl (%rcx)
    114c:	03 11                	add    (%rcx),%edx
    114e:	7f 9f                	jg     10ef <balancer_ingress+0x10ef>
    1150:	04 d5                	add    $0xd5,%al
    1152:	14 ae                	adc    $0xae,%al
    1154:	18 03                	sbb    %al,(%rbx)
    1156:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    1159:	04 b3                	add    $0xb3,%al
    115b:	18 c4                	sbb    %al,%ah
    115d:	1d 03 11 7f 9f       	sbb    $0x9f7f1103,%eax
    1162:	04 92                	add    $0x92,%al
    1164:	1f                   	(bad)
    1165:	d0 1f                	rcrb   (%rdi)
  if (!per_vip_stats) {
    1167:	03 11                	add    (%rcx),%edx
    1169:	7f 9f                	jg     110a <balancer_ingress+0x110a>
    116b:	04 8c                	add    $0x8c,%al
    116d:	20 a2 22 03 11 7f    	and    %ah,0x7f110322(%rdx)
    1173:	9f                   	lahf
    1174:	04 f5                	add    $0xf5,%al
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1176:	22 cb                	and    %bl,%cl
    1178:	23 03                	and    (%rbx),%eax
    117a:	11 7f 9f             	adc    %edi,-0x61(%rdi)
    117d:	04 b0                	add    $0xb0,%al
    117f:	32 af 34 03 11 7f    	xor    0x7f110334(%rdi),%ch
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1185:	9f                   	lahf
    1186:	04 b8                	add    $0xb8,%al
    1188:	34 91                	xor    $0x91,%al
        quic_packets_stats->cid_initial += 1;
    118a:	3a 03                	cmp    (%rbx),%al
    118c:	11 7f 9f             	adc    %edi,-0x61(%rdi)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    118f:	04 f7                	add    $0xf7,%al
    1191:	3a 94 3f 03 11 7f 9f 	cmp    -0x6080eefd(%rdi,%rdi,1),%dl
    1198:	04 b2                	add    $0xb2,%al
    119a:	3f                   	(bad)
    119b:	ee                   	out    %al,(%dx)
    119c:	40 03 11             	rex add (%rcx),%edx
    119f:	7f 9f                	jg     1140 <balancer_ingress+0x1140>
    11a1:	04 fa                	add    $0xfa,%al
    11a3:	42 d3 44 03 11       	roll   %cl,0x11(%rbx,%r8,1)
    11a8:	7f 9f                	jg     1149 <balancer_ingress+0x1149>
    11aa:	00 01                	add    %al,(%rcx)
    11ac:	14 04                	adc    $0x4,%al
    11ae:	b5 08                	mov    $0x8,%ch
    11b0:	ca 08 01             	lret   $0x108
    11b3:	52                   	push   %rdx
    11b4:	04 84                	add    $0x84,%al
    11b6:	09 db                	or     %ebx,%ebx
    11b8:	09 01                	or     %eax,(%rcx)
    11ba:	52                   	push   %rdx
    11bb:	04 d5                	add    $0xd5,%al
  if (!per_vip_stats) {
    11bd:	14 fa                	adc    $0xfa,%al
    11bf:	14 01                	adc    $0x1,%al
    11c1:	52                   	push   %rdx
    11c2:	04 b3                	add    $0xb3,%al
    11c4:	18 88 19 01 52 04    	sbb    %cl,0x4520119(%rax)
    11ca:	b9 1b a1 1c 01       	mov    $0x11ca11b,%ecx
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    11cf:	52                   	push   %rdx
    11d0:	00 01                	add    %al,(%rcx)
    11d2:	14 04                	adc    $0x4,%al
    11d4:	b5 08                	mov    $0x8,%ch
    11d6:	84 09                	test   %cl,(%rcx)
    11d8:	01 5f 04             	add    %ebx,0x4(%rdi)
    11db:	b9 17 ae 18 01       	mov    $0x118ae17,%ecx
  if (!connId) {
    11e0:	5f                   	pop    %rdi
    11e1:	00 01                	add    %al,(%rcx)
    11e3:	14 04                	adc    $0x4,%al
    11e5:	b5 08                	mov    $0x8,%ch
    11e7:	84 09                	test   %cl,(%rcx)
    11e9:	01 5d 04             	add    %ebx,0x4(%rbp)
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    11ec:	b9 17 ae 18 01       	mov    $0x118ae17,%ecx
    11f1:	5d                   	pop    %rbp
    11f2:	00 01                	add    %al,(%rcx)
    11f4:	14 04                	adc    $0x4,%al
    11f6:	b5 08                	mov    $0x8,%ch
    11f8:	84 09                	test   %cl,(%rcx)
    11fa:	03 10                	add    (%rax),%edx
    11fc:	22 9f 04 b9 17 ae    	and    -0x51e846fc(%rdi),%bl
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1202:	18 03                	sbb    %al,(%rbx)
    1204:	10 22                	adc    %ah,(%rdx)
    1206:	9f                   	lahf
    1207:	00 01                	add    %al,(%rcx)
    1209:	14 04                	adc    $0x4,%al
    120b:	b5 08                	mov    $0x8,%ch
    120d:	84 09                	test   %cl,(%rcx)
    120f:	03 77 10             	add    0x10(%rdi),%esi
    1212:	9f                   	lahf
    1213:	04 b9                	add    $0xb9,%al
    1215:	17                   	(bad)
    1216:	ae                   	scas   %es:(%rdi),%al
    1217:	18 03                	sbb    %al,(%rbx)
    1219:	77 10                	ja     122b <balancer_ingress+0x122b>
    121b:	9f                   	lahf
    121c:	00 01                	add    %al,(%rcx)
    121e:	14 04                	adc    $0x4,%al
    1220:	b5 08                	mov    $0x8,%ch
    1222:	ca 08 01             	lret   $0x108
      if (qpr.server_id > 0) {
    1225:	52                   	push   %rdx
    1226:	00 01                	add    %al,(%rcx)
    1228:	14 04                	adc    $0x4,%al
    122a:	ba 08 84 09 01       	mov    $0x1098408,%edx
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    122f:	5f                   	pop    %rdi
    1230:	04 b9                	add    $0xb9,%al
    1232:	17                   	(bad)
    1233:	ae                   	scas   %es:(%rdi),%al
    1234:	18 01                	sbb    %al,(%rcx)
    1236:	5f                   	pop    %rdi
    1237:	00 01                	add    %al,(%rcx)
    1239:	14 04                	adc    $0x4,%al
    123b:	ba 08 84 09 01       	mov    $0x1098408,%edx
    1240:	5d                   	pop    %rbp
    1241:	04 b9                	add    $0xb9,%al
    quic_packets_stats->cid_v2 += 1;
    1243:	17                   	(bad)
    1244:	ae                   	scas   %es:(%rdi),%al
    1245:	18 01                	sbb    %al,(%rcx)
    1247:	5d                   	pop    %rbp
    quic_packets_stats->cid_v3 += 1;
    1248:	00 01                	add    %al,(%rcx)
    124a:	14 04                	adc    $0x4,%al
    124c:	ba 08 84 09 03       	mov    $0x3098408,%edx
    quic_packets_stats->cid_v0 += 1;
    1251:	10 22                	adc    %ah,(%rdx)
    1253:	9f                   	lahf
    1254:	04 b9                	add    $0xb9,%al
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1256:	17                   	(bad)
    1257:	ed                   	in     (%dx),%eax
    1258:	17                   	(bad)
    1259:	03 10                	add    (%rax),%edx
        if (real_pos) {
    125b:	22 9f 00 01 14 04    	and    0x4140100(%rdi),%bl
    1261:	ba 08 84 09 03       	mov    $0x3098408,%edx
    1266:	77 10                	ja     1278 <balancer_ingress+0x1278>
    1268:	9f                   	lahf
    1269:	04 b9                	add    $0xb9,%al
    126b:	17                   	(bad)
    126c:	ae                   	scas   %es:(%rdi),%al
    126d:	18 03                	sbb    %al,(%rbx)
    126f:	77 10                	ja     1281 <balancer_ingress+0x1281>
          key = *real_pos;
    1271:	9f                   	lahf
    1272:	00 01                	add    %al,(%rcx)
    1274:	14 04                	adc    $0x4,%al
          if (key == 0) {
    1276:	ba 08 c7 08 03       	mov    $0x308c708,%edx
            dst = bpf_map_lookup_elem(&reals, &key);
    127b:	7f 22                	jg     129f <balancer_ingress+0x129f>
    127d:	9f                   	lahf
    127e:	04 c7                	add    $0xc7,%al
    1280:	08 84 09 01 53 04 b9 	or     %al,-0x46fbacff(%rcx,%rcx,1)
    1287:	17                   	(bad)
    1288:	ae                   	scas   %es:(%rdi),%al
    1289:	18 01                	sbb    %al,(%rcx)
    128b:	53                   	push   %rbx
    128c:	00 01                	add    %al,(%rcx)
    128e:	14 04                	adc    $0x4,%al
    1290:	ba 09 db 09 01       	mov    $0x109db09,%edx
    1295:	50                   	push   %rax
    1296:	00 01                	add    %al,(%rcx)
    1298:	14 04                	adc    $0x4,%al
            if (!dst) {
    129a:	db 09                	fisttpl (%rcx)
    129c:	e8 09 02 30 9f       	call   ffffffff9f3014aa <server_id_map+0x36ff86c184aa>
    12a1:	04 e8                	add    $0xe8,%al
    12a3:	09 f1                	or     %esi,%ecx
    12a5:	09 01                	or     %eax,(%rcx)
    12a7:	50                   	push   %rax
    12a8:	00 01                	add    %al,(%rcx)
    12aa:	14 04                	adc    $0x4,%al
    12ac:	f1                   	int1
    12ad:	09 8f 0a 01 50 00    	or     %ecx,0x50010a(%rdi)
  if (dst_lru) {
    12b3:	01 14 04             	add    %edx,(%rsp,%rax,1)
    12b6:	83 0a 8f             	orl    $0xffffff8f,(%rdx)
    if (dst_lru->pos == pckt->real_index) {
    12b9:	0a 01                	or     (%rcx),%al
    12bb:	52                   	push   %rdx
    12bc:	00 01                	add    %al,(%rcx)
    12be:	14 04                	adc    $0x4,%al
    12c0:	8f 0a ce 0a          	(bad)
    12c4:	05 7f 36 23 08       	add    $0x823367f,%eax
              quic_packets_stats->dst_match_in_lru += 1;
    12c9:	9f                   	lahf
    12ca:	00 01                	add    %al,(%rcx)
    12cc:	14 04                	adc    $0x4,%al
    12ce:	fa                   	cli
    12cf:	0a d3                	or     %bl,%dl
    12d1:	0b 02                	or     (%rdx),%eax
    12d3:	31 9f 00 01 14 04    	xor    %ebx,0x4140100(%rdi)
    12d9:	fa                   	cli
    12da:	0a d3                	or     %bl,%dl
    12dc:	0b 03                	or     (%rbx),%eax
    12de:	77 10                	ja     12f0 <balancer_ingress+0x12f0>
    12e0:	9f                   	lahf
    12e1:	04 d5                	add    $0xd5,%al
    12e3:	0c ec                	or     $0xec,%al
  original_sport = pckt.flow.port16[0];
    12e5:	0c 03                	or     $0x3,%al
    12e7:	77 10                	ja     12f9 <balancer_ingress+0x12f9>
    12e9:	9f                   	lahf
    12ea:	00 01                	add    %al,(%rcx)
    12ec:	14 04                	adc    $0x4,%al
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    12ee:	fa                   	cli
    12ef:	0a d3                	or     %bl,%dl
    12f1:	0b 02                	or     (%rdx),%eax
    12f3:	31 9f 04 d5 0c ec    	xor    %ebx,-0x13f32afc(%rdi)
        !(vip_info->flags & F_LRU_BYPASS)) {
    12f9:	0c 02                	or     $0x2,%al
    12fb:	31 9f 00 01 14 04    	xor    %ebx,0x4140100(%rdi)
    1301:	8d 0b                	lea    (%rbx),%ecx
    1303:	ac                   	lods   %ds:(%rsi),%al
    1304:	0b 02                	or     (%rdx),%eax
    1306:	30 9f 04 ac 0b b1    	xor    %bl,-0x4ef453fc(%rdi)
    130c:	0b 01                	or     (%rcx),%eax
    130e:	53                   	push   %rbx
  if (!dst_lru) {
    130f:	00 01                	add    %al,(%rcx)
    1311:	14 04                	adc    $0x4,%al
    1313:	97                   	xchg   %eax,%edi
    1314:	0b a6 0b 01 50 00    	or     0x50010b(%rsi),%esp
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    131a:	01 14 04             	add    %edx,(%rsp,%rax,1)
    131d:	ac                   	lods   %ds:(%rsi),%al
    131e:	0b d3                	or     %ebx,%edx
    1320:	0b 01                	or     (%rcx),%eax
    1322:	53                   	push   %rbx
    1323:	04 d5                	add    $0xd5,%al
    cur_time = bpf_ktime_get_ns();
    1325:	0c ec                	or     $0xec,%al
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1327:	0c 01                	or     $0x1,%al
    1329:	53                   	push   %rbx
    132a:	00 01                	add    %al,(%rcx)
    132c:	14 04                	adc    $0x4,%al
    132e:	b1 0b                	mov    $0xb,%cl
    1330:	be 0b 02 30 9f       	mov    $0x9f30020b,%esi
    1335:	04 be                	add    $0xbe,%al
    1337:	0b c7                	or     %edi,%eax
    1339:	0b 01                	or     (%rcx),%eax
    133b:	50                   	push   %rax
    133c:	00 01                	add    %al,(%rcx)
    133e:	14 04                	adc    $0x4,%al
    1340:	c7                   	(bad)
    1341:	0b d3                	or     %ebx,%edx
    1343:	0b 01                	or     (%rcx),%eax
    1345:	50                   	push   %rax
    1346:	00 01                	add    %al,(%rcx)
    dst_lru->atime = cur_time;
    1348:	14 04                	adc    $0x4,%al
    134a:	e1 0b                	loope  1357 <balancer_ingress+0x1357>
  key = dst_lru->pos;
    134c:	f1                   	int1
    134d:	0b 03                	or     (%rbx),%eax
    134f:	7f 36                	jg     1387 <balancer_ingress+0x1387>
    1351:	9f                   	lahf
    1352:	00 01                	add    %al,(%rcx)
    1354:	14 04                	adc    $0x4,%al
    1356:	f1                   	int1
  pckt->real_index = key;
    1357:	0b c5                	or     %ebp,%eax
    1359:	0d 01 56 00 01       	or     $0x1005601,%eax
  *real = bpf_map_lookup_elem(&reals, &key);
    135e:	14 04                	adc    $0x4,%al
    1360:	b1 0c                	mov    $0xc,%cl
    1362:	c5 0d 04             	(bad)
    1365:	10 8a 04 9f 00 01    	adc    %cl,0x1009f04(%rdx)
    136b:	14 04                	adc    $0x4,%al
    136d:	b1 0c                	mov    $0xc,%cl
    136f:	be 0c 02 30 9f       	mov    $0x9f30020c,%esi
    1374:	04 be                	add    $0xbe,%al
    1376:	0c c7                	or     $0xc7,%al
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1378:	0c 01                	or     $0x1,%al
    137a:	52                   	push   %rdx
    137b:	00 01                	add    %al,(%rcx)
    137d:	14 04                	adc    $0x4,%al
    137f:	c7                   	(bad)
    1380:	0c a0                	or     $0xa0,%al
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1382:	0d 01 52 00 01       	or     $0x1005201,%eax
    1387:	14 04                	adc    $0x4,%al
    1389:	f4                   	hlt
    138a:	0c 81                	or     $0x81,%al
    138c:	0d 02 30 9f 04       	or     $0x49f3002,%eax
    1391:	81 0d 8a 0d 01 50 00 	orl    $0x4140100,0x50010d8a(%rip)        # 50012125 <_license+0x5000fd90>
    1398:	01 14 04 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    139b:	8a 0d 93 0d 01 50    	mov    0x50010d93(%rip),%cl        # 50012134 <_license+0x5000fd9f>
    13a1:	00 01                	add    %al,(%rcx)
  if (!conn_rate_stats) {
    13a3:	14 04                	adc    $0x4,%al
    13a5:	a0 0d c5 0d 01 52 00 	movabs 0x14010052010dc50d,%al
    13ac:	01 14 
    13ae:	04 b2                	add    $0xb2,%al
    13b0:	0d c5 0d 01 50       	or     $0x50010dc5,%eax
    13b5:	00 01                	add    %al,(%rcx)
    13b7:	14 04                	adc    $0x4,%al
  *cur_time = bpf_ktime_get_ns();
    13b9:	c5 0d 9e             	(bad)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    13bc:	0e                   	(bad)
    13bd:	02 31                	add    (%rcx),%dh
    13bf:	9f                   	lahf
    13c0:	00 01                	add    %al,(%rcx)
    13c2:	14 04                	adc    $0x4,%al
    13c4:	c5 0d 9e             	(bad)
    13c7:	0e                   	(bad)
    13c8:	03 77 10             	add    0x10(%rdi),%esi
    conn_rate_stats->v1 = 1;
    13cb:	9f                   	lahf
    13cc:	04 b4                	add    $0xb4,%al
    13ce:	0f cb                	bswap  %ebx
    13d0:	0f 03 77 10          	lsl    0x10(%rdi),%esi
    conn_rate_stats->v2 = *cur_time;
    13d4:	9f                   	lahf
    13d5:	00 01                	add    %al,(%rcx)
    conn_rate_stats->v1 += 1;
    13d7:	14 04                	adc    $0x4,%al
    13d9:	c5 0d 9e             	(bad)
    13dc:	0e                   	(bad)
    13dd:	02 31                	add    (%rcx),%dh
    13df:	9f                   	lahf
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    13e0:	04 b4                	add    $0xb4,%al
    13e2:	0f cb                	bswap  %ebx
    13e4:	0f 02 31             	lar    (%rcx),%esi
    13e7:	9f                   	lahf
    13e8:	00 01                	add    %al,(%rcx)
    13ea:	14 04                	adc    $0x4,%al
    13ec:	d8 0d f7 0d 02 30    	fmuls  0x30020df7(%rip)        # 300221e9 <_license+0x3001fe54>
    13f2:	9f                   	lahf
    13f3:	04 f7                	add    $0xf7,%al
    13f5:	0d fc 0d 01 53       	or     $0x53010dfc,%eax
    13fa:	00 01                	add    %al,(%rcx)
    13fc:	14 04                	adc    $0x4,%al
    13fe:	e2 0d                	loop   140d <balancer_ingress+0x140d>
    1400:	f1                   	int1
    1401:	0d 01 50 00 01       	or     $0x1005001,%eax
    1406:	14 04                	adc    $0x4,%al
    1408:	f7 0d 9e 0e 01 53 04 	testl  $0xcb0fb404,0x53010e9e(%rip)        # 530122b0 <_license+0x5300ff1b>
    140f:	b4 0f cb 
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1412:	0f 01 53 00          	lgdt   0x0(%rbx)
    1416:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1419:	fc                   	cld
    141a:	0d 89 0e 02 30       	or     $0x30020e89,%eax
    141f:	9f                   	lahf
    1420:	04 89                	add    $0x89,%al
    1422:	0e                   	(bad)
    1423:	92                   	xchg   %eax,%edx
    1424:	0e                   	(bad)
      if (down_real) {
    1425:	01 50 00             	add    %edx,0x0(%rax)
    1428:	01 14 04             	add    %edx,(%rsp,%rax,1)
    142b:	92                   	xchg   %eax,%edx
    142c:	0e                   	(bad)
    142d:	9e                   	sahf
    142e:	0e                   	(bad)
    142f:	01 50 00             	add    %edx,0x0(%rax)
    1432:	01 14 04             	add    %edx,(%rsp,%rax,1)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1435:	ac                   	lods   %ds:(%rsi),%al
    1436:	0e                   	(bad)
    1437:	d0 0e                	rorb   (%rsi)
    1439:	03 7f 36             	add    0x36(%rdi),%edi
    143c:	9f                   	lahf
    143d:	00 01                	add    %al,(%rcx)
    143f:	14 04                	adc    $0x4,%al
        if (stats_data) {
    1441:	b4 0e                	mov    $0xe,%ah
    1443:	b7 0e                	mov    $0xe,%bh
    1445:	01 52 00             	add    %edx,0x0(%rdx)
    1448:	01 14 04             	add    %edx,(%rsp,%rax,1)
          stats_data->v1 += 1;
    144b:	d0 0e                	rorb   (%rsi)
    144d:	a3 10 01 56 00 01 14 	movabs %eax,0x9004140100560110
    1454:	04 90 
    if (!dst) {
    1456:	0f a3 10             	bt     %edx,(%rax)
    1459:	04 10                	add    $0x10,%al
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    145b:	8a 04 9f             	mov    (%rdi,%rbx,4),%al
    145e:	00 01                	add    %al,(%rcx)
    1460:	14 04                	adc    $0x4,%al
    1462:	90                   	nop
    1463:	0f 9d 0f             	setge  (%rdi)
    1466:	02 30                	add    (%rax),%dh
    1468:	9f                   	lahf
    1469:	04 9d                	add    $0x9d,%al
    146b:	0f                   	xsha1  (bad)
    146c:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    146d:	0f 01 52 00          	lgdt   0x0(%rdx)
    1471:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1474:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1475:	0f fe 0f             	paddd  (%rdi),%mm1
    1478:	01 52 00             	add    %edx,0x0(%rdx)
    147b:	01 14 04             	add    %edx,(%rsp,%rax,1)
  if (!data_stats) {
    147e:	d3 0f                	rorl   %cl,(%rdi)
    1480:	e0 0f                	loopne 1491 <balancer_ingress+0x1491>
    1482:	02 30                	add    (%rax),%dh
    1484:	9f                   	lahf
    1485:	04 e0                	add    $0xe0,%al
    1487:	0f e9 0f             	psubsw (%rdi),%mm1
    148a:	01 50 00             	add    %edx,0x0(%rax)
  data_stats->v1 += 1;
    148d:	01 14 04             	add    %edx,(%rsp,%rax,1)
  data_stats->v2 += pkt_bytes;
    1490:	e9 0f f1 0f 01       	jmp    11005a4 <_license+0x10fe20f>
    1495:	50                   	push   %rax
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1496:	00 01                	add    %al,(%rcx)
    1498:	14 04                	adc    $0x4,%al
    149a:	fe 0f                	decb   (%rdi)
    149c:	a3 10 01 52 00 01 14 	movabs %eax,0x9004140100520110
    14a3:	04 90 
    14a5:	10 a3 10 01 50 00    	adc    %ah,0x500110(%rbx)
    14ab:	01 14 04             	add    %edx,(%rsp,%rax,1)
    14ae:	ad                   	lods   %ds:(%rsi),%eax
    14af:	10 ba 10 01 50 00    	adc    %bh,0x500110(%rdx)
    14b5:	01 14 04             	add    %edx,(%rsp,%rax,1)
    14b8:	d8 10                	fcoms  (%rax)
    14ba:	e5 10                	in     $0x10,%eax
    14bc:	02 30                	add    (%rax),%dh
  if (!data_stats) {
    14be:	9f                   	lahf
    14bf:	04 e5                	add    $0xe5,%al
    14c1:	10 ee                	adc    %ch,%dh
    14c3:	10 01                	adc    %al,(%rcx)
    14c5:	52                   	push   %rdx
    14c6:	00 01                	add    %al,(%rcx)
  data_stats->v1 += 1;
    14c8:	14 04                	adc    $0x4,%al
  data_stats->v2 += pkt_bytes;
    14ca:	ee                   	out    %al,(%dx)
    14cb:	10 85 11 01 52 00    	adc    %al,0x520111(%rbp)
    14d1:	01 14 04             	add    %edx,(%rsp,%rax,1)
  pckt.flow.port16[0] = original_sport;
    14d4:	85 11                	test   %edx,(%rcx)
    14d6:	92                   	xchg   %eax,%edx
  if (dst->flags & F_IPV6) {
    14d7:	11 05 7f 36 23 08    	adc    %eax,0x823367f(%rip)        # 8234b5c <_license+0x82327c7>
    14dd:	9f                   	lahf
    14de:	04 92                	add    $0x92,%al
    14e0:	11 95 11 01 50 00    	adc    %edx,0x500111(%rbp)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    14e6:	01 14 04             	add    %edx,(%rsp,%rax,1)
    14e9:	f0 11 88 12 02 30 9f 	lock adc %ecx,-0x60cffdee(%rax)
    14f0:	04 88                	add    $0x88,%al
    14f2:	12 91 12 01 50 00    	adc    0x500112(%rcx),%dl
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    14f8:	01 14 04             	add    %edx,(%rsp,%rax,1)
    14fb:	fa                   	cli
    14fc:	11 91 12 01 5e 00    	adc    %edx,0x5e0112(%rcx)
    1502:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1505:	88 12                	mov    %dl,(%rdx)
  data = (void*)(long)xdp->data;
    1507:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1508:	13 01                	adc    (%rcx),%eax
  data_end = (void*)(long)xdp->data_end;
    150a:	50                   	push   %rax
    150b:	04 97                	add    $0x97,%al
    150d:	14 a1                	adc    $0xa1,%al
  iph = data + sizeof(struct ethhdr);
    150f:	14 01                	adc    $0x1,%al
    1511:	50                   	push   %rax
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1512:	04 ac                	add    $0xac,%al
    1514:	14 b7                	adc    $0xb7,%al
    1516:	14 01                	adc    $0x1,%al
    1518:	50                   	push   %rax
    1519:	04 b7                	add    $0xb7,%al
    151b:	14 d5                	adc    $0xd5,%al
    151d:	14 01                	adc    $0x1,%al
    151f:	52                   	push   %rdx
    1520:	04 c4                	add    $0xc4,%al
    1522:	1d 92 1f 01 50       	sbb    $0x50011f92,%eax
    1527:	04 d0                	add    $0xd0,%al
    1529:	1f                   	(bad)
    152a:	8c 20                	mov    %fs,(%rax)
    152c:	01 50 04             	add    %edx,0x4(%rax)
    152f:	a2 22 f5 22 01 50 04 	movabs %al,0x23cb04500122f522
    1536:	cb 23 
    1538:	8b 25 01 50 04 d1    	mov    -0x2efbafff(%rip),%esp        # ffffffffd104653f <server_id_map+0x36ffb895d53f>
    153e:	25 84 26 01 50       	and    $0x50012684,%eax
    1543:	04 84                	add    $0x84,%al
    1545:	26 c2 26 01          	es ret $0x126
    1549:	53                   	push   %rbx
  memcpy(new_eth->h_dest, cval->mac, 6);
    154a:	04 c2                	add    $0xc2,%al
    154c:	26 c7                	es (bad)
    154e:	26 01 50 04          	es add %edx,0x4(%rax)
    1552:	c7                   	(bad)
    1553:	26 f7 26             	es mull (%rsi)
    1556:	01 53 04             	add    %edx,0x4(%rbx)
    1559:	f7 26                	mull   (%rsi)
    155b:	b1 27                	mov    $0x27,%cl
    155d:	01 50 04             	add    %edx,0x4(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1560:	b1 27                	mov    $0x27,%cl
    1562:	d1 28                	shrl   (%rax)
    1564:	01 53 00             	add    %edx,0x0(%rbx)
    1567:	01 14 04             	add    %edx,(%rsp,%rax,1)
    156a:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    156b:	12 a6 13 04 10 80    	adc    -0x7feffbed(%rsi),%ah
  new_eth->h_proto = BE_ETH_P_IP;
    1571:	04 9f                	add    $0x9f,%al
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1573:	04 c4                	add    $0xc4,%al
    1575:	1d 92 1f 04 10       	sbb    $0x10041f92,%eax
    157a:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
  iph->ihl = 5;
    157e:	d0 1f                	rcrb   (%rdi)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1580:	8c 20                	mov    %fs,(%rax)
    1582:	04 10                	add    $0x10,%al
    1584:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1588:	a2 22 f5 22 04 10 80 	movabs %al,0x9f0480100422f522
    158f:	04 9f 
    1591:	04 cb                	add    $0xcb,%al
  iph->id = 0;
    1593:	23 b0 32 04 10 80    	and    -0x7feffbce(%rax),%esi
  iph->daddr = daddr;
    1599:	04 9f                	add    $0x9f,%al
    159b:	04 95                	add    $0x95,%al
  iph->saddr = saddr;
    159d:	41 fa                	rex.B cli
  iph->ttl = DEFAULT_TTL;
    159f:	42 04 10             	rex.X add $0x10,%al
    15a2:	80 04 9f 00          	addb   $0x0,(%rdi,%rbx,4)
    *csum += *next_iph_u16++;
    15a6:	01 14 04             	add    %edx,(%rsp,%rax,1)
    15a9:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    15aa:	12 b1 12 02 30 9f    	adc    -0x60cffdee(%rcx),%dh
    15b0:	04 b1                	add    $0xb1,%al
    15b2:	12 ba 12 01 56 00    	adc    0x560112(%rdx),%bh
    15b8:	01 14 04             	add    %edx,(%rsp,%rax,1)
    15bb:	ba 12 a6 13 01       	mov    $0x113a612,%edx
    15c0:	56                   	push   %rsi
    15c1:	04 c4                	add    $0xc4,%al
    15c3:	1d 92 1f 01 56       	sbb    $0x56011f92,%eax
      if (pckt.flow.proto == IPPROTO_TCP) {
    15c8:	04 d0                	add    $0xd0,%al
    15ca:	1f                   	(bad)
    15cb:	8c 20                	mov    %fs,(%rax)
    15cd:	01 56 04             	add    %edx,0x4(%rsi)
    15d0:	a2 22 f5 22 01 56 04 	movabs %al,0x23cb04560122f522
    15d7:	cb 23 
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    15d9:	fd                   	std
    15da:	28 01                	sub    %al,(%rcx)
    15dc:	56                   	push   %rsi
    15dd:	04 fd                	add    $0xfd,%al
    15df:	28 9a 29 01 52 04    	sub    %bl,0x4520129(%rdx)
        if (!lru_stats) {
    15e5:	be 29 fa 29 01       	mov    $0x129fa29,%esi
    15ea:	52                   	push   %rdx
        if (pckt.flags & F_SYN_SET) {
    15eb:	04 c5                	add    $0xc5,%al
    15ed:	2b f6                	sub    %esi,%esi
    15ef:	30 01                	xor    %al,(%rcx)
    15f1:	56                   	push   %rsi
    15f2:	04 f6                	add    $0xf6,%al
    15f4:	30 89 31 01 52 04    	xor    %cl,0x4520131(%rcx)
    15fa:	95                   	xchg   %eax,%ebp
    15fb:	41 fa                	rex.B cli
    15fd:	42 01 56 00          	rex.X add %edx,0x0(%rsi)
  struct real_pos_lru new_dst_lru = {};
    1601:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1604:	dd 12                	fstl   (%rdx)
    1606:	e6 12                	out    %al,$0x12
    1608:	0c 10                	or     $0x10,%al
    160a:	b4 a0                	mov    $0xa0,%ah
    160c:	e5 b1                	in     $0xb1,%eax
    160e:	fa                   	cli
    160f:	ff                   	(bad)
    1610:	ff                   	(bad)
    1611:	ff                   	(bad)
    1612:	ff 01                	incl   (%rcx)
    1614:	9f                   	lahf
    1615:	04 e6                	add    $0xe6,%al
    1617:	12 e9                	adc    %cl,%ch
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1619:	12 01                	adc    (%rcx),%al
    161b:	52                   	push   %rdx
    161c:	00 01                	add    %al,(%rcx)
    161e:	14 04                	adc    $0x4,%al
    1620:	e9 12 f5 12 0d       	jmp    d130b37 <_license+0xd12e7a2>
    1625:	72 00                	jb     1627 <balancer_ingress+0x1627>
  if (!conn_rate_stats) {
    1627:	a8 af                	test   $0xaf,%al
    1629:	80 80 00 a8 b4 80 80 	addb   $0x80,-0x7f4b5800(%rax)
    1630:	00 9f 04 c4 1d c7    	add    %bl,-0x38e23bfc(%rdi)
  *cur_time = bpf_ktime_get_ns();
    1636:	1d 0d 72 00 a8       	sbb    $0xa800720d,%eax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    163b:	af                   	scas   %es:(%rdi),%eax
    163c:	80 80 00 a8 b4 80 80 	addb   $0x80,-0x7f4b5800(%rax)
    1643:	00 9f 00 01 14 04    	add    %bl,0x4140100(%rdi)
    conn_rate_stats->v1 = 1;
    1649:	e9 12 f5 12 0d       	jmp    d130b60 <_license+0xd12e7cb>
    164e:	72 00                	jb     1650 <balancer_ingress+0x1650>
    conn_rate_stats->v2 = *cur_time;
    1650:	a8 af                	test   $0xaf,%al
    1652:	80 80 00 a8 b4 80 80 	addb   $0x80,-0x7f4b5800(%rax)
    1659:	00 9f 04 c4 1d c7    	add    %bl,-0x38e23bfc(%rdi)
    conn_rate_stats->v1 += 1;
    165f:	1d 0d 72 00 a8       	sbb    $0xa800720d,%eax
    1664:	af                   	scas   %es:(%rdi),%eax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1665:	80 80 00 a8 b4 80 80 	addb   $0x80,-0x7f4b5800(%rax)
    166c:	00 9f 00 01 14 04    	add    %bl,0x4140100(%rdi)
    1672:	e9 12 f5 12 02       	jmp    2130b89 <_license+0x212e7f4>
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1677:	30 9f 04 c4 1d d5    	xor    %bl,-0x2ae23bfc(%rdi)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    167d:	1d 02 30 9f 04       	sbb    $0x49f3002,%eax
    1682:	d5                   	(bad)
    1683:	1d de 1d 01 55       	sbb    $0x55011dde,%eax
      memset(pckt->flow.srcv6, 0, 16);
    1688:	00 01                	add    %al,(%rcx)
    168a:	14 04                	adc    $0x4,%al
    168c:	e9 12 f5 12 02       	jmp    2130ba3 <_license+0x212e80e>
    1691:	3c 9f                	cmp    $0x9f,%al
    1693:	04 c4                	add    $0xc4,%al
    1695:	1d de 1d 02 3c       	sbb    $0x3c021dde,%eax
        jhash(pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6),
    169a:	9f                   	lahf
    169b:	00 01                	add    %al,(%rcx)
    169d:	14 04                	adc    $0x4,%al
    169f:	e9 12 f5 12 04       	jmp    4130bb6 <_license+0x412e821>
    16a4:	10 80 01 9f 04 c4    	adc    %al,-0x3bfb60ff(%rax)
        pckt->flow.ports,
    16aa:	1d de 1d 04 10       	sbb    $0x10041dde,%eax
    return jhash_2words(
    16af:	80 01 9f             	addb   $0x9f,(%rcx)
    16b2:	00 01                	add    %al,(%rcx)
    16b4:	14 04                	adc    $0x4,%al
    16b6:	e9 12 f5 12 02       	jmp    2130bcd <_license+0x212e838>
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    16bb:	38 9f 04 c4 1d de    	cmp    %bl,-0x21e23bfc(%rdi)
    16c1:	1d 02 38 9f 00       	sbb    $0x9f3802,%eax
    16c6:	01 14 04             	add    %edx,(%rsp,%rax,1)
    16c9:	f5                   	cmc
    16ca:	12 82 13 02 30 9f    	adc    -0x60cffded(%rdx),%al
    16d0:	04 82                	add    $0x82,%al
    16d2:	13 8b 13 01 52 00    	adc    0x520113(%rbx),%ecx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    16d8:	01 14 04             	add    %edx,(%rsp,%rax,1)
    16db:	8b 13                	mov    (%rbx),%edx
    16dd:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    16de:	13 01                	adc    (%rcx),%eax
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    16e0:	52                   	push   %rdx
    16e1:	00 01                	add    %al,(%rcx)
    16e3:	14 04                	adc    $0x4,%al
    if (!real_pos) {
    16e5:	d5                   	(bad)
    16e6:	1d ae 1e 01 55       	sbb    $0x55011eae,%eax
    16eb:	04 ae                	add    $0xae,%al
    16ed:	1e                   	(bad)
    16ee:	92                   	xchg   %eax,%edx
    16ef:	1f                   	(bad)
    16f0:	01 53 04             	add    %edx,0x4(%rbx)
    16f3:	d0 1f                	rcrb   (%rdi)
    16f5:	8c 20                	mov    %fs,(%rax)
    16f7:	01 55 04             	add    %edx,0x4(%rbp)
    16fa:	a2 22 f5 22 01 53 04 	movabs %al,0x23cb04530122f522
    1701:	cb 23 
    key = *real_pos;
    1703:	e1 25                	loope  172a <balancer_ingress+0x172a>
    1705:	01 53 04             	add    %edx,0x4(%rbx)
    if (key == 0) {
    1708:	e1 25                	loope  172f <balancer_ingress+0x172f>
    170a:	f7 25 01 55 04 f7    	mull   -0x8fbaaff(%rip)        # fffffffff7046c11 <server_id_map+0x36ffde95dc11>
  *real = bpf_map_lookup_elem(&reals, &key);
    1710:	25 e6 28 03 77       	and    $0x770328e6,%eax
  if (!(*real)) {
    1715:	f8                   	clc
    1716:	00 04 c5 2b f6 30 03 	add    %al,0x330f62b(,%rax,8)
    171d:	77 f8                	ja     1717 <balancer_ingress+0x1717>
    171f:	00 04 95 41 fa 42 01 	add    %al,0x142fa41(,%rdx,4)
    1726:	53                   	push   %rbx
    1727:	00 01                	add    %al,(%rcx)
    1729:	14 04                	adc    $0x4,%al
    172b:	ad                   	lods   %ds:(%rsi),%eax
    172c:	13 ba 13 02 30 9f    	adc    -0x60cffded(%rdx),%edi
    1732:	04 ba                	add    $0xba,%al
    1734:	13 c3                	adc    %ebx,%eax
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1736:	13 01                	adc    (%rcx),%eax
    1738:	52                   	push   %rdx
    1739:	00 01                	add    %al,(%rcx)
    173b:	14 04                	adc    $0x4,%al
    173d:	c3                   	ret
    173e:	13 da                	adc    %edx,%ebx
    1740:	13 01                	adc    (%rcx),%eax
    1742:	52                   	push   %rdx
    if (pckt->flow.proto == IPPROTO_UDP) {
    1743:	00 01                	add    %al,(%rcx)
    1745:	14 04                	adc    $0x4,%al
    1747:	da 13                	ficoml (%rbx)
    1749:	e7 13                	out    %eax,$0x13
      new_dst_lru.atime = cur_time;
    174b:	05 7f 22 23 08       	add    $0x823227f,%eax
    new_dst_lru.pos = key;
    1750:	9f                   	lahf
    1751:	04 e7                	add    $0xe7,%al
    1753:	13 ea                	adc    %edx,%ebp
    1755:	13 01                	adc    (%rcx),%eax
BPF_MAP_OPS_INLINE(map_update_elem,,
    1757:	50                   	push   %rax
    1758:	00 01                	add    %al,(%rcx)
    175a:	14 04                	adc    $0x4,%al
    175c:	9e                   	sahf
    175d:	14 ac                	adc    $0xac,%al
    175f:	14 02                	adc    $0x2,%al
    1761:	30 9f 04 ac 14 b7    	xor    %bl,-0x48eb53fc(%rdi)
    1767:	14 01                	adc    $0x1,%al
    1769:	50                   	push   %rax
    176a:	00 01                	add    %al,(%rcx)
    176c:	14 04                	adc    $0x4,%al
    176e:	d5                   	(bad)
    176f:	14 b3                	adc    $0xb3,%al
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    1771:	15 02 31 9f 00       	adc    $0x9f3102,%eax
    1776:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1779:	d5                   	(bad)
    177a:	14 b3                	adc    $0xb3,%al
    177c:	15 03 77 10 9f       	adc    $0x9f107703,%eax
    1781:	04 ca                	add    $0xca,%al
    1783:	16                   	(bad)
    1784:	e1 16                	loope  179c <balancer_ingress+0x179c>
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    1786:	03 77 10             	add    0x10(%rdi),%esi
    1789:	9f                   	lahf
    178a:	00 01                	add    %al,(%rcx)
    178c:	14 04                	adc    $0x4,%al
    178e:	d5                   	(bad)
    178f:	14 b3                	adc    $0xb3,%al
    1791:	15 02 30 9f 04       	adc    $0x49f3002,%eax
    1796:	ca 16 e1             	lret   $0xe116
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    1799:	16                   	(bad)
    179a:	02 30                	add    (%rax),%dh
    179c:	9f                   	lahf
    179d:	00 01                	add    %al,(%rcx)
    179f:	14 04                	adc    $0x4,%al
    17a1:	ed                   	in     (%dx),%eax
    17a2:	14 8c                	adc    $0x8c,%al
    17a4:	15 02 30 9f 04       	adc    $0x49f3002,%eax
                         lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
    17a9:	8c 15 91 15 01 53    	mov    %ss,0x53011591(%rip)        # 53012d40 <_license+0x530109ab>
    17af:	00 01                	add    %al,(%rcx)
    17b1:	14 04                	adc    $0x4,%al
    17b3:	f7 14 86             	notl   (%rsi,%rax,4)
    17b6:	15 01 50 00 01       	adc    $0x1005001,%eax
    17bb:	14 04                	adc    $0x4,%al
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17bd:	8c 15 b3 15 01 53    	mov    %ss,0x530115b3(%rip)        # 53012d76 <_license+0x530109e1>
    17c3:	04 ca                	add    $0xca,%al
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17c5:	16                   	(bad)
    17c6:	e1 16                	loope  17de <balancer_ingress+0x17de>
    17c8:	01 53 00             	add    %edx,0x0(%rbx)
    17cb:	01 14 04             	add    %edx,(%rsp,%rax,1)
    17ce:	91                   	xchg   %eax,%ecx
    17cf:	15 9e 15 02 30       	adc    $0x3002159e,%eax
    17d4:	9f                   	lahf
  bool vip_match = address_match && port_match && proto_match;
    17d5:	04 9e                	add    $0x9e,%al
    17d7:	15 a7 15 01 50       	adc    $0x500115a7,%eax
    17dc:	00 01                	add    %al,(%rcx)
    17de:	14 04                	adc    $0x4,%al
    17e0:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    17e1:	15 b3 15 01 50       	adc    $0x500115b3,%eax
    __u32 lru_stats_key = pckt->real_index;
    17e6:	00 01                	add    %al,(%rcx)
    17e8:	14 04                	adc    $0x4,%al
    17ea:	c5 15 e9 15 03 7f 22 	vpsubsw -0x60dd80fd(%rip),%ymm13,%ymm10        # ffffffff9f2296f5 <server_id_map+0x36ff86b406f5>
    17f1:	9f 
    17f2:	00 01                	add    %al,(%rcx)
    17f4:	14 04                	adc    $0x4,%al
    17f6:	cd 15                	int    $0x15
    17f8:	d0 15 01 51 00 01    	rclb   0x1005101(%rip)        # 10068ff <_license+0x100456a>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17fe:	14 04                	adc    $0x4,%al
    1800:	e9 15 b9 17 01       	jmp    117d11a <_license+0x117ad85>
    1805:	56                   	push   %rsi
    1806:	00 01                	add    %al,(%rcx)
    1808:	14 04                	adc    $0x4,%al
    if (!lru_miss_stat) {
    180a:	e9 15 97 16 01       	jmp    116af24 <_license+0x1168b8f>
    180f:	50                   	push   %rax
    1810:	00 01                	add    %al,(%rcx)
    *lru_miss_stat += 1;
    1812:	14 04                	adc    $0x4,%al
      data_stats->v2 += 1;
    1814:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1815:	16                   	(bad)
    1816:	b9 17 04 10 8a       	mov    $0x8a100417,%ecx
    181b:	04 9f                	add    $0x9f,%al
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    181d:	00 01                	add    %al,(%rcx)
    181f:	14 04                	adc    $0x4,%al
    1821:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1822:	16                   	(bad)
    1823:	b3 16                	mov    $0x16,%bl
    1825:	02 30                	add    (%rax),%dh
    1827:	9f                   	lahf
    1828:	04 b3                	add    $0xb3,%al
    182a:	16                   	(bad)
    182b:	bc 16 01 52 00       	mov    $0x520116,%esp
    1830:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1833:	bc 16 94 17 01       	mov    $0x1179416,%esp
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1838:	52                   	push   %rdx
    1839:	00 01                	add    %al,(%rcx)
    183b:	14 04                	adc    $0x4,%al
    183d:	e9 16 f6 16 02       	jmp    2170e58 <_license+0x216eac3>
    1842:	30 9f 04 f6 16 ff    	xor    %bl,-0xe909fc(%rdi)
  if (!ch_drop_stats) {
    1848:	16                   	(bad)
    1849:	01 50 00             	add    %edx,0x0(%rax)
    184c:	01 14 04             	add    %edx,(%rsp,%rax,1)
    184f:	ff 16                	call   *(%rsi)
    1851:	87 17                	xchg   %edx,(%rdi)
    1853:	01 50 00             	add    %edx,0x0(%rax)
    1856:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1859:	94                   	xchg   %eax,%esp
    185a:	17                   	(bad)
    185b:	b9 17 01 52 00       	mov    $0x520117,%ecx
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1860:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1863:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1864:	17                   	(bad)
    1865:	b9 17 01 50 00       	mov    $0x500117,%ecx
  if (!ch_drop_stats) {
    186a:	01 14 04             	add    %edx,(%rsp,%rax,1)
    186d:	b9 17 c6 17 02       	mov    $0x217c617,%ecx
    1872:	30 9f 04 c6 17 cf    	xor    %bl,-0x30e839fc(%rdi)
    1878:	17                   	(bad)
    1879:	01 50 00             	add    %edx,0x0(%rax)
    187c:	01 14 04             	add    %edx,(%rsp,%rax,1)
    187f:	cf                   	iret
    1880:	17                   	(bad)
    1881:	ed                   	in     (%dx),%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1882:	17                   	(bad)
    1883:	01 50 00             	add    %edx,0x0(%rax)
    1886:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1889:	e1 17                	loope  18a2 <balancer_ingress+0x18a2>
    188b:	ed                   	in     (%dx),%eax
    188c:	17                   	(bad)
    188d:	01 52 00             	add    %edx,0x0(%rdx)
    1890:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1893:	ed                   	in     (%dx),%eax
    1894:	17                   	(bad)
    1895:	ae                   	scas   %es:(%rdi),%al
  data = (void*)(long)xdp->data;
    1896:	18 05 7f 22 23 08    	sbb    %al,0x823227f(%rip)        # 8233b1b <_license+0x8231786>
  data_end = (void*)(long)xdp->data_end;
    189c:	9f                   	lahf
  ip6h = data + sizeof(struct ethhdr);
    189d:	00 01                	add    %al,(%rcx)
    189f:	14 04                	adc    $0x4,%al
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    18a1:	dd 18                	fstpl  (%rax)
    18a3:	b2 19                	mov    $0x19,%dl
    18a5:	02 31                	add    (%rcx),%dh
    18a7:	9f                   	lahf
    18a8:	00 01                	add    %al,(%rcx)
    18aa:	14 04                	adc    $0x4,%al
    18ac:	dd 18                	fstpl  (%rax)
    18ae:	b2 19                	mov    $0x19,%dl
    18b0:	03 77 10             	add    0x10(%rdi),%esi
    18b3:	9f                   	lahf
    18b4:	04 c9                	add    $0xc9,%al
    18b6:	1a e0                	sbb    %al,%ah
    18b8:	1a 03                	sbb    (%rbx),%al
    18ba:	77 10                	ja     18cc <balancer_ingress+0x18cc>
    18bc:	9f                   	lahf
    18bd:	00 01                	add    %al,(%rcx)
    18bf:	14 04                	adc    $0x4,%al
    18c1:	dd 18                	fstpl  (%rax)
    18c3:	b2 19                	mov    $0x19,%dl
    18c5:	02 30                	add    (%rax),%dh
  memcpy(new_eth->h_dest, cval->mac, 6);
    18c7:	9f                   	lahf
    18c8:	04 c9                	add    $0xc9,%al
    18ca:	1a e0                	sbb    %al,%ah
    18cc:	1a 02                	sbb    (%rdx),%al
    18ce:	30 9f 00 01 14 04    	xor    %bl,0x4140100(%rdi)
    18d4:	f5                   	cmc
    18d5:	18 8b 19 02 30 9f    	sbb    %cl,-0x60cffde7(%rbx)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    18db:	04 8b                	add    $0x8b,%al
    18dd:	19 90 19 01 53 00    	sbb    %edx,0x530119(%rax)
    18e3:	01 14 04             	add    %edx,(%rsp,%rax,1)
    18e6:	ff 18                	lcall  *(%rax)
    18e8:	88 19                	mov    %bl,(%rcx)
  new_eth->h_proto = BE_ETH_P_IPV6;
    18ea:	01 55 00             	add    %edx,0x0(%rbp)
    18ed:	01 14 04             	add    %edx,(%rsp,%rax,1)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
    18f0:	8b 19                	mov    (%rcx),%ebx
    18f2:	b2 19                	mov    $0x19,%dl
  saddr[3] = src ^ port;
    18f4:	01 53 04             	add    %edx,0x4(%rbx)
    18f7:	c9                   	leave
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    18f8:	1a e0                	sbb    %al,%ah
    18fa:	1a 01                	sbb    (%rcx),%al
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    18fc:	53                   	push   %rbx
    18fd:	00 01                	add    %al,(%rcx)
    18ff:	14 04                	adc    $0x4,%al
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1901:	90                   	nop
    1902:	19 9d 19 02 30 9f    	sbb    %ebx,-0x60cffde7(%rbp)
    1908:	04 9d                	add    $0x9d,%al
    190a:	19 a6 19 01 50 00    	sbb    %esp,0x500119(%rsi)
  ip6h->priority = (tc & 0xF0) >> 4;
    1910:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1913:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1914:	19 b2 19 01 50 00    	sbb    %esi,0x500119(%rdx)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    191a:	01 14 04             	add    %edx,(%rsp,%rax,1)
  ip6h->nexthdr = proto;
    191d:	e2 19                	loop   1938 <balancer_ingress+0x1938>
    191f:	b9 1b 01 56 00       	mov    $0x56011b,%ecx
  ip6h->payload_len = bpf_htons(payload_len);
    1924:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1927:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    1928:	1a b9 1b 04 10 8a    	sbb    -0x75effbe5(%rcx),%bh
    192e:	04 9f                	add    $0x9f,%al
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1930:	00 01                	add    %al,(%rcx)
    1932:	14 04                	adc    $0x4,%al
    1934:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    1935:	1a b2 1a 02 30 9f    	sbb    -0x60cffde6(%rdx),%dh
    193b:	04 b2                	add    $0xb2,%al
    193d:	1a bb 1a 01 52 00    	sbb    0x52011a(%rbx),%bh
  if (!connId) {
    1943:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1946:	bb 1a 94 1b 01       	mov    $0x11b941a,%ebx
    194b:	52                   	push   %rdx
    194c:	00 01                	add    %al,(%rcx)
    194e:	14 04                	adc    $0x4,%al
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1950:	e8 1a f5 1a 02       	call   21b0e6f <_license+0x21aeada>
    1955:	30 9f 04 f5 1a fe    	xor    %bl,-0x1e50afc(%rdi)
    195b:	1a 01                	sbb    (%rcx),%al
    195d:	50                   	push   %rax
    195e:	00 01                	add    %al,(%rcx)
    1960:	14 04                	adc    $0x4,%al
    1962:	fe                   	(bad)
    1963:	1a 87 1b 01 50 00    	sbb    0x50011b(%rdi),%al
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1969:	01 14 04             	add    %edx,(%rsp,%rax,1)
    196c:	94                   	xchg   %eax,%esp
    196d:	1b b9 1b 01 52 00    	sbb    0x52011b(%rcx),%edi
    1973:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1976:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    1977:	1b b9 1b 01 50 00    	sbb    0x50011b(%rcx),%edi
    197d:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1980:	c3                   	ret
    1981:	1b d0                	sbb    %eax,%edx
    1983:	1b 01                	sbb    (%rcx),%eax
    1985:	50                   	push   %rax
    1986:	00 01                	add    %al,(%rcx)
    1988:	14 04                	adc    $0x4,%al
      if (qpr.server_id > 0) {
    198a:	89 1c a1             	mov    %ebx,(%rcx,%riz,4)
    198d:	1c 02                	sbb    $0x2,%al
    198f:	30 9f 04 a1 1c aa    	xor    %bl,-0x55e35efc(%rdi)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1995:	1c 01                	sbb    $0x1,%al
    1997:	50                   	push   %rax
    1998:	00 01                	add    %al,(%rcx)
    199a:	14 04                	adc    $0x4,%al
    199c:	93                   	xchg   %eax,%ebx
    199d:	1c aa                	sbb    $0xaa,%al
    199f:	1c 01                	sbb    $0x1,%al
    quic_packets_stats->cid_v1 += 1;
    19a1:	5e                   	pop    %rsi
    19a2:	00 01                	add    %al,(%rcx)
    19a4:	14 04                	adc    $0x4,%al
    19a6:	a1 1c c4 1d 01 50 04 	movabs 0x1f920450011dc41c,%eax
    19ad:	92 1f 
    quic_packets_stats->cid_v3 += 1;
    19af:	9c                   	pushf
    19b0:	1f                   	(bad)
    19b1:	01 50 04             	add    %edx,0x4(%rax)
    quic_packets_stats->cid_v0 += 1;
    19b4:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    19b5:	1f                   	(bad)
    19b6:	b2 1f                	mov    $0x1f,%dl
    19b8:	01 50 04             	add    %edx,0x4(%rax)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    19bb:	b2 1f                	mov    $0x1f,%dl
    19bd:	d0 1f                	rcrb   (%rdi)
    19bf:	01 52 04             	add    %edx,0x4(%rdx)
    19c2:	8c 20                	mov    %fs,(%rax)
    19c4:	b8 20 01 50 04       	mov    $0x4500120,%eax
    19c9:	b8 20 a2 22 03       	mov    $0x322a220,%eax
    19ce:	77 c0                	ja     1990 <balancer_ingress+0x1990>
        if (real_pos) {
    19d0:	00 04 f5 22 cb 23 03 	add    %al,0x323cb22(,%rsi,8)
          key = *real_pos;
    19d7:	77 c0                	ja     1999 <balancer_ingress+0x1999>
    19d9:	00 04 b0             	add    %al,(%rax,%rsi,4)
            pckt.real_index = key;
    19dc:	32 af 34 03 77 c0    	xor    -0x3f88fccc(%rdi),%ch
            dst = bpf_map_lookup_elem(&reals, &key);
    19e2:	00 04 b8             	add    %al,(%rax,%rdi,4)
            if (!dst) {
    19e5:	34 91                	xor    $0x91,%al
    19e7:	3a 03                	cmp    (%rbx),%al
    19e9:	77 c0                	ja     19ab <balancer_ingress+0x19ab>
    19eb:	00 04 f7             	add    %al,(%rdi,%rsi,8)
    19ee:	3a 94 3f 03 77 c0 00 	cmp    0xc07703(%rdi,%rdi,1),%dl
    19f5:	04 b2                	add    $0xb2,%al
    19f7:	3f                   	(bad)
    19f8:	ee                   	out    %al,(%dx)
    19f9:	40 03 77 c0          	rex add -0x40(%rdi),%esi
    19fd:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    1a00:	42 d3 44 03 77       	roll   %cl,0x77(%rbx,%r8,1)
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    1a05:	c0 00 00             	rolb   $0x0,(%rax)
    1a08:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1a0b:	bd 1c c4 1d 04       	mov    $0x41dc41c,%ebp
  if (dst_lru) {
    1a10:	10 80 04 9f 04 8c    	adc    %al,-0x73fb60fc(%rax)
    1a16:	20 a2 22 04 10 80    	and    %ah,-0x7feffbde(%rdx)
    if (dst_lru->pos == pckt->real_index) {
    1a1c:	04 9f                	add    $0x9f,%al
    1a1e:	04 f5                	add    $0xf5,%al
    1a20:	22 cb                	and    %bl,%cl
    1a22:	23 04 10             	and    (%rax,%rdx,1),%eax
              quic_packets_stats->dst_match_in_lru += 1;
    1a25:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1a29:	b0 32                	mov    $0x32,%al
    1a2b:	af                   	scas   %es:(%rdi),%eax
    1a2c:	34 04                	xor    $0x4,%al
    1a2e:	10 80 04 9f 04 b8    	adc    %al,-0x47fb60fc(%rax)
              quic_packets_stats->cid_unknown_real_dropped += 1;
    1a34:	34 91                	xor    $0x91,%al
    1a36:	3a 04 10             	cmp    (%rax,%rdx,1),%al
    1a39:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1a3d:	f7 3a                	idivl  (%rdx)
    1a3f:	94                   	xchg   %eax,%esp
    1a40:	3f                   	(bad)
    1a41:	04 10                	add    $0x10,%al
    1a43:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1a47:	b2 3f                	mov    $0x3f,%dl
  original_sport = pckt.flow.port16[0];
    1a49:	ee                   	out    %al,(%dx)
    1a4a:	40 04 10             	rex add $0x10,%al
    1a4d:	80 04 9f 04          	addb   $0x4,(%rdi,%rbx,4)
    1a51:	fa                   	cli
    1a52:	42 d3 44 04 10       	roll   %cl,0x10(%rsp,%r8,1)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1a57:	80 04 9f 00          	addb   $0x0,(%rdi,%rbx,4)
        !(vip_info->flags & F_LRU_BYPASS)) {
    1a5b:	01 14 04             	add    %edx,(%rsp,%rax,1)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1a5e:	bd 1c ca 1c 02       	mov    $0x21cca1c,%ebp
    1a63:	30 9f 04 ca 1c d3    	xor    %bl,-0x2ce335fc(%rdi)
    1a69:	1c 01                	sbb    $0x1,%al
    1a6b:	5c                   	pop    %rsp
    1a6c:	00 01                	add    %al,(%rcx)
    1a6e:	14 04                	adc    $0x4,%al
  if (!dst_lru) {
    1a70:	d3 1c c4             	rcrl   %cl,(%rsp,%rax,8)
    1a73:	1d 01 5c 04 8c       	sbb    $0x8c045c01,%eax
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1a78:	20 a2 22 01 5c 04    	and    %ah,0x45c0122(%rdx)
    1a7e:	f5                   	cmc
    1a7f:	22 cb                	and    %bl,%cl
    1a81:	23 01                	and    (%rcx),%eax
    1a83:	5c                   	pop    %rsp
    1a84:	04 b0                	add    $0xb0,%al
    cur_time = bpf_ktime_get_ns();
    1a86:	32 af 34 01 5c 04    	xor    0x45c0134(%rdi),%ch
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1a8c:	b8 34 c7 37 01       	mov    $0x137c734,%eax
    1a91:	5c                   	pop    %rsp
    1a92:	04 c7                	add    $0xc7,%al
    1a94:	37                   	(bad)
    1a95:	e4 37                	in     $0x37,%al
    1a97:	01 52 04             	add    %edx,0x4(%rdx)
    1a9a:	88 38                	mov    %bh,(%rax)
    1a9c:	c8 38 01 52          	enter  $0x138,$0x52
    1aa0:	04 f7                	add    $0xf7,%al
    1aa2:	3a 94 3f 01 5c 04 b2 	cmp    -0x4dfba3ff(%rdi,%rdi,1),%dl
    dst_lru->atime = cur_time;
    1aa9:	3f                   	(bad)
    1aaa:	cf                   	iret
    1aab:	3f                   	(bad)
  key = dst_lru->pos;
    1aac:	01 5c 04 cf          	add    %ebx,-0x31(%rsp,%rax,1)
    1ab0:	3f                   	(bad)
    1ab1:	e2 3f                	loop   1af2 <balancer_ingress+0x1af2>
    1ab3:	01 52 04             	add    %edx,0x4(%rdx)
    1ab6:	fa                   	cli
    1ab7:	42 d3 44 01 5c       	roll   %cl,0x5c(%rcx,%r8,1)
  *real = bpf_map_lookup_elem(&reals, &key);
    1abc:	00 01                	add    %al,(%rcx)
    1abe:	14 04                	adc    $0x4,%al
    1ac0:	f6 1c ff             	negb   (%rdi,%rdi,8)
    1ac3:	1c 0c                	sbb    $0xc,%al
    1ac5:	10 b4 a0 e5 b1 fa ff 	adc    %dh,-0x54e1b(%rax,%riz,4)
    1acc:	ff                   	(bad)
    1acd:	ff                   	(bad)
    1ace:	ff 01                	incl   (%rcx)
    1ad0:	9f                   	lahf
    1ad1:	04 ff                	add    $0xff,%al
    1ad3:	1c 82                	sbb    $0x82,%al
    1ad5:	1d 01 52 00 01       	sbb    $0x1005201,%eax
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1ada:	14 04                	adc    $0x4,%al
    1adc:	82                   	(bad)
    1add:	1d 8e 1d 0d 72       	sbb    $0x720d1d8e,%eax
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1ae2:	00 a8 af 80 80 00    	add    %ch,0x8080af(%rax)
    1ae8:	a8 b4                	test   $0xb4,%al
    1aea:	80 80 00 9f 04 8c 20 	addb   $0x20,-0x73fb6100(%rax)
    1af1:	8f                   	(bad)
    1af2:	20 0d 72 00 a8 af    	and    %cl,-0x5057ff8e(%rip)        # ffffffffafa81b6a <server_id_map+0x36ff97398b6a>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1af8:	80 80 00 a8 b4 80 80 	addb   $0x80,-0x7f4b5800(%rax)
    1aff:	00 9f 00 01 14 04    	add    %bl,0x4140100(%rdi)
  if (!conn_rate_stats) {
    1b05:	82                   	(bad)
    1b06:	1d 8e 1d 0d 72       	sbb    $0x720d1d8e,%eax
    1b0b:	00 a8 af 80 80 00    	add    %ch,0x8080af(%rax)
    1b11:	a8 b4                	test   $0xb4,%al
  *cur_time = bpf_ktime_get_ns();
    1b13:	80 80 00 9f 04 8c 20 	addb   $0x20,-0x73fb6100(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1b1a:	8f                   	(bad)
    1b1b:	20 0d 72 00 a8 af    	and    %cl,-0x5057ff8e(%rip)        # ffffffffafa81b93 <server_id_map+0x36ff97398b93>
    1b21:	80 80 00 a8 b4 80 80 	addb   $0x80,-0x7f4b5800(%rax)
    conn_rate_stats->v1 = 1;
    1b28:	00 9f 00 01 14 04    	add    %bl,0x4140100(%rdi)
    conn_rate_stats->v2 = *cur_time;
    1b2e:	82                   	(bad)
    1b2f:	1d 8e 1d 02 30       	sbb    $0x30021d8e,%eax
    conn_rate_stats->v1 += 1;
    1b34:	9f                   	lahf
    1b35:	04 8c                	add    $0x8c,%al
    1b37:	20 9d 20 02 30 9f    	and    %bl,-0x60cffde0(%rbp)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1b3d:	04 9d                	add    $0x9d,%al
    1b3f:	20 a2 20 01 52 04    	and    %ah,0x4520120(%rdx)
    1b45:	a2 20 ab 20 03 77 c8 	movabs %al,0xc8770320ab20
    1b4c:	00 00 
    1b4e:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1b51:	82                   	(bad)
    1b52:	1d 8e 1d 02 3c       	sbb    $0x3c021d8e,%eax
    if (down_reals_map) {
    1b57:	9f                   	lahf
    1b58:	04 8c                	add    $0x8c,%al
    1b5a:	20 ab 20 02 3c 9f    	and    %ch,-0x60c3fde0(%rbx)
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1b60:	00 01                	add    %al,(%rcx)
    1b62:	14 04                	adc    $0x4,%al
    1b64:	82                   	(bad)
    1b65:	1d 8e 1d 04 10       	sbb    $0x10041d8e,%eax
      if (down_real) {
    1b6a:	80 01 9f             	addb   $0x9f,(%rcx)
    1b6d:	04 8c                	add    $0x8c,%al
    1b6f:	20 ab 20 04 10 80    	and    %ch,-0x7feffbe0(%rbx)
    1b75:	01 9f 00 01 14 04    	add    %ebx,0x4140100(%rdi)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1b7b:	82                   	(bad)
    1b7c:	1d 8e 1d 02 38       	sbb    $0x38021d8e,%eax
    1b81:	9f                   	lahf
    1b82:	04 8c                	add    $0x8c,%al
    1b84:	20 ab 20 02 38 9f    	and    %ch,-0x60c7fde0(%rbx)
        if (stats_data) {
    1b8a:	00 01                	add    %al,(%rcx)
    1b8c:	14 04                	adc    $0x4,%al
          stats_data->v1 += 1;
    1b8e:	8e 1d 9b 1d 02 30    	mov    0x30021d9b(%rip),%ds        # 3002392f <_license+0x3002159a>
    1b94:	9f                   	lahf
    1b95:	04 9b                	add    $0x9b,%al
    if (!dst) {
    1b97:	1d a4 1d 01 52       	sbb    $0x52011da4,%eax
    1b9c:	00 01                	add    %al,(%rcx)
    1b9e:	14 04                	adc    $0x4,%al
    1ba0:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    1ba1:	1d ba 1d 01 52       	sbb    $0x52011dba,%eax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1ba6:	00 01                	add    %al,(%rcx)
    1ba8:	14 04                	adc    $0x4,%al
    1baa:	9d                   	popf
    1bab:	20 a2 20 01 52 04    	and    %ah,0x4520120(%rdx)
    1bb1:	a2 20 a2 22 03 77 c8 	movabs %al,0x400c8770322a220
    1bb8:	00 04 
    1bba:	f5                   	cmc
    1bbb:	22 cb                	and    %bl,%cl
    1bbd:	23 03                	and    (%rbx),%eax
    1bbf:	77 c8                	ja     1b89 <balancer_ingress+0x1b89>
    1bc1:	00 04 b0             	add    %al,(%rax,%rsi,4)
    1bc4:	32 af 34 03 77 c8    	xor    -0x3788fccc(%rdi),%ch
  if (!data_stats) {
    1bca:	00 04 b8             	add    %al,(%rax,%rdi,4)
    1bcd:	34 91                	xor    $0x91,%al
    1bcf:	3a 03                	cmp    (%rbx),%al
    1bd1:	77 c8                	ja     1b9b <balancer_ingress+0x1b9b>
    1bd3:	00 04 f7             	add    %al,(%rdi,%rsi,8)
  data_stats->v1 += 1;
    1bd6:	3a 94 3f 03 77 c8 00 	cmp    0xc87703(%rdi,%rdi,1),%dl
  data_stats->v2 += pkt_bytes;
    1bdd:	04 b2                	add    $0xb2,%al
    1bdf:	3f                   	(bad)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1be0:	ee                   	out    %al,(%dx)
    1be1:	40 03 77 c8          	rex add -0x38(%rdi),%esi
    1be5:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    1be8:	42 d3 44 03 77       	roll   %cl,0x77(%rbx,%r8,1)
    1bed:	c8 00 00 01          	enter  $0x0,$0x1
    1bf1:	14 04                	adc    $0x4,%al
    1bf3:	f2 1d 92 1f 02 30    	repnz sbb $0x30021f92,%eax
    1bf9:	9f                   	lahf
    1bfa:	04 a2                	add    $0xa2,%al
    1bfc:	22 f5                	and    %ch,%dh
    1bfe:	22 02                	and    (%rdx),%al
    1c00:	30 9f 04 cb 23 d9    	xor    %bl,-0x26dc34fc(%rdi)
    1c06:	25 02 30 9f 04       	and    $0x49f3002,%eax
  if (!data_stats) {
    1c0b:	95                   	xchg   %eax,%ebp
    1c0c:	41 fa                	rex.B cli
    1c0e:	42 02 30             	rex.X add (%rax),%sil
  data_stats->v1 += 1;
    1c11:	9f                   	lahf
    1c12:	00 01                	add    %al,(%rcx)
  data_stats->v2 += pkt_bytes;
    1c14:	14 04                	adc    $0x4,%al
    1c16:	f2 1d ff 1d 02 30    	repnz sbb $0x30021dff,%eax
    1c1c:	9f                   	lahf
    1c1d:	04 ff                	add    $0xff,%al
  pckt.flow.port16[0] = original_sport;
    1c1f:	1d 88 1e 01 5e       	sbb    $0x5e011e88,%eax
  if (dst->flags & F_IPV6) {
    1c24:	00 01                	add    %al,(%rcx)
    1c26:	14 04                	adc    $0x4,%al
    1c28:	88 1e                	mov    %bl,(%rsi)
    1c2a:	92                   	xchg   %eax,%edx
    1c2b:	1f                   	(bad)
    1c2c:	01 5e 04             	add    %ebx,0x4(%rsi)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1c2f:	a2 22 de 22 01 5e 04 	movabs %al,0x23cb045e0122de22
    1c36:	cb 23 
    1c38:	d9 25 01 5e 04 95    	fldenv -0x6afba1ff(%rip)        # ffffffff95047a3f <server_id_map+0x36ff7c95ea3f>
    1c3e:	41 fa                	rex.B cli
    1c40:	42 01 5e 00          	rex.X add %ebx,0x0(%rsi)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1c44:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1c47:	91                   	xchg   %eax,%ecx
    1c48:	1e                   	(bad)
    1c49:	95                   	xchg   %eax,%ebp
    1c4a:	1e                   	(bad)
    1c4b:	01 5f 00             	add    %ebx,0x0(%rdi)
    1c4e:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1c51:	91                   	xchg   %eax,%ecx
    1c52:	1e                   	(bad)
    1c53:	92                   	xchg   %eax,%edx
    1c54:	1f                   	(bad)
  data = (void*)(long)xdp->data;
    1c55:	01 5d 04             	add    %ebx,0x4(%rbp)
  data_end = (void*)(long)xdp->data_end;
    1c58:	a2 22 b8 22 01 5d 04 	movabs %al,0x23cb045d0122b822
    1c5f:	cb 23 
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1c61:	ac                   	lods   %ds:(%rsi),%al
    1c62:	24 01                	and    $0x1,%al
    1c64:	5d                   	pop    %rbp
    1c65:	00 01                	add    %al,(%rcx)
    1c67:	14 04                	adc    $0x4,%al
    1c69:	91                   	xchg   %eax,%ecx
    1c6a:	1e                   	(bad)
    1c6b:	92                   	xchg   %eax,%edx
    1c6c:	1f                   	(bad)
    1c6d:	02 31                	add    (%rcx),%dh
    1c6f:	9f                   	lahf
    1c70:	04 a2                	add    $0xa2,%al
    1c72:	22 b8 22 02 31 9f    	and    -0x60cefdde(%rax),%bh
    1c78:	04 cb                	add    $0xcb,%al
    1c7a:	23 ac 24 02 31 9f 00 	and    0x9f3102(%rsp),%ebp
    1c81:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1c84:	91                   	xchg   %eax,%ecx
    1c85:	1e                   	(bad)
    1c86:	92                   	xchg   %eax,%edx
    1c87:	1f                   	(bad)
    1c88:	03 77 10             	add    0x10(%rdi),%esi
    1c8b:	9f                   	lahf
    1c8c:	04 a2                	add    $0xa2,%al
    1c8e:	22 b8 22 03 77 10    	and    0x10770322(%rax),%bh
    1c94:	9f                   	lahf
    1c95:	04 cb                	add    $0xcb,%al
    1c97:	23 ac 24 03 77 10 9f 	and    -0x60ef88fd(%rsp),%ebp
  memcpy(new_eth->h_dest, cval->mac, 6);
    1c9e:	00 01                	add    %al,(%rcx)
    1ca0:	14 04                	adc    $0x4,%al
    1ca2:	91                   	xchg   %eax,%ecx
    1ca3:	1e                   	(bad)
    1ca4:	de 1e                	ficomps (%rsi)
    1ca6:	12 30                	adc    (%rax),%dh
    1ca8:	20 9f 93 04 30 20    	and    %bl,0x20300493(%rdi)
    1cae:	9f                   	lahf
    1caf:	93                   	xchg   %eax,%ebx
    1cb0:	01 30                	add    %esi,(%rax)
    1cb2:	9f                   	lahf
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1cb3:	93                   	xchg   %eax,%ebx
    1cb4:	01 30                	add    %esi,(%rax)
    1cb6:	9f                   	lahf
    1cb7:	93                   	xchg   %eax,%ebx
    1cb8:	02 04 de             	add    (%rsi,%rbx,8),%al
    1cbb:	1e                   	(bad)
    1cbc:	8d 1f                	lea    (%rdi),%ebx
    1cbe:	22 30                	and    (%rax),%dh
    1cc0:	20 9f 93 04 72 00    	and    %bl,0x720493(%rdi)
  new_eth->h_proto = BE_ETH_P_IP;
    1cc6:	10 ff                	adc    %bh,%bh
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1cc8:	ff                   	(bad)
    1cc9:	ff                   	(bad)
    1cca:	ff 0f                	decl   (%rdi)
    1ccc:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
  iph->ihl = 5;
    1cd2:	a8 b9                	test   $0xb9,%al
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1cd4:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
  iph->tos = tos;
    1cdb:	93                   	xchg   %eax,%ebx
    1cdc:	01 30                	add    %esi,(%rax)
    1cde:	9f                   	lahf
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1cdf:	93                   	xchg   %eax,%ebx
    1ce0:	02 04 8d 1f 92 1f 1f 	add    0x1f1f921f(,%rcx,4),%al
  iph->id = 0;
    1ce7:	93                   	xchg   %eax,%ebx
    1ce8:	04 72                	add    $0x72,%al
  iph->daddr = daddr;
    1cea:	00 10                	add    %dl,(%rax)
    1cec:	ff                   	(bad)
  iph->saddr = saddr;
    1ced:	ff                   	(bad)
    1cee:	ff                   	(bad)
    1cef:	ff 0f                	decl   (%rdi)
  iph->ttl = DEFAULT_TTL;
    1cf1:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    1cf7:	a8 b9                	test   $0xb9,%al
    1cf9:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
    1d00:	93                   	xchg   %eax,%ebx
    1d01:	01 30                	add    %esi,(%rax)
    1d03:	9f                   	lahf
    1d04:	93                   	xchg   %eax,%ebx
    1d05:	02 04 a2             	add    (%rdx,%riz,4),%al
    1d08:	22 b8 22 12 30 20    	and    0x20301222(%rax),%bh
    1d0e:	9f                   	lahf
    1d0f:	93                   	xchg   %eax,%ebx
    1d10:	04 30                	add    $0x30,%al
    1d12:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    1d18:	93                   	xchg   %eax,%ebx
    1d19:	01 30                	add    %esi,(%rax)
    1d1b:	9f                   	lahf
    1d1c:	93                   	xchg   %eax,%ebx
    1d1d:	02 04 cb             	add    (%rbx,%rcx,8),%al
    if (csum >> 16)
    1d20:	23 eb                	and    %ebx,%ebp
    1d22:	23 12                	and    (%rdx),%edx
    1d24:	30 20                	xor    %ah,(%rax)
    1d26:	9f                   	lahf
    1d27:	93                   	xchg   %eax,%ebx
    1d28:	04 30                	add    $0x30,%al
    1d2a:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    1d30:	93                   	xchg   %eax,%ebx
    1d31:	01 30                	add    %esi,(%rax)
    1d33:	9f                   	lahf
    1d34:	93                   	xchg   %eax,%ebx
    1d35:	02 04 eb             	add    (%rbx,%rbp,8),%al
    1d38:	23 ff                	and    %edi,%edi
    1d3a:	23 22                	and    (%rdx),%esp
    1d3c:	30 20                	xor    %ah,(%rax)
    1d3e:	9f                   	lahf
    1d3f:	93                   	xchg   %eax,%ebx
    1d40:	04 72                	add    $0x72,%al
    1d42:	00 10                	add    %dl,(%rax)
    1d44:	ff                   	(bad)
    1d45:	ff                   	(bad)
    1d46:	ff                   	(bad)
    1d47:	ff 0f                	decl   (%rdi)
    1d49:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    1d4f:	a8 b9                	test   $0xb9,%al
    1d51:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
    1d58:	93                   	xchg   %eax,%ebx
    1d59:	01 30                	add    %esi,(%rax)
    1d5b:	9f                   	lahf
    1d5c:	93                   	xchg   %eax,%ebx
    1d5d:	02 04 ff             	add    (%rdi,%rdi,8),%al
    1d60:	23 81 24 1f 93 04    	and    0x4931f24(%rcx),%eax
    1d66:	72 00                	jb     1d68 <balancer_ingress+0x1d68>
    1d68:	10 ff                	adc    %bh,%bh
    1d6a:	ff                   	(bad)
    1d6b:	ff                   	(bad)
  return ~csum;
    1d6c:	ff 0f                	decl   (%rdi)
  iph->check = csum;
    1d6e:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    1d74:	a8 b9                	test   $0xb9,%al
    1d76:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
      if (pckt.flow.proto == IPPROTO_TCP) {
    1d7d:	93                   	xchg   %eax,%ebx
    1d7e:	01 30                	add    %esi,(%rax)
    1d80:	9f                   	lahf
    1d81:	93                   	xchg   %eax,%ebx
    1d82:	02 04 81             	add    (%rcx,%rax,4),%al
    1d85:	24 9e                	and    $0x9e,%al
    1d87:	24 22                	and    $0x22,%al
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1d89:	30 20                	xor    %ah,(%rax)
    1d8b:	9f                   	lahf
    1d8c:	93                   	xchg   %eax,%ebx
    1d8d:	04 72                	add    $0x72,%al
    1d8f:	00 10                	add    %dl,(%rax)
    1d91:	ff                   	(bad)
    1d92:	ff                   	(bad)
    1d93:	ff                   	(bad)
        if (!lru_stats) {
    1d94:	ff 0f                	decl   (%rdi)
    1d96:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    1d9c:	a8 b9                	test   $0xb9,%al
        if (pckt.flags & F_SYN_SET) {
    1d9e:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
    1da5:	93                   	xchg   %eax,%ebx
    1da6:	01 30                	add    %esi,(%rax)
    1da8:	9f                   	lahf
    1da9:	93                   	xchg   %eax,%ebx
    1daa:	02 04 9e             	add    (%rsi,%rbx,4),%al
  struct real_pos_lru new_dst_lru = {};
    1dad:	24 a1                	and    $0xa1,%al
    1daf:	24 1f                	and    $0x1f,%al
    1db1:	93                   	xchg   %eax,%ebx
    1db2:	04 72                	add    $0x72,%al
    1db4:	00 10                	add    %dl,(%rax)
    1db6:	ff                   	(bad)
    1db7:	ff                   	(bad)
    1db8:	ff                   	(bad)
    1db9:	ff 0f                	decl   (%rdi)
    1dbb:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    1dc1:	a8 b9                	test   $0xb9,%al
    1dc3:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1dca:	93                   	xchg   %eax,%ebx
    1dcb:	01 30                	add    %esi,(%rax)
    1dcd:	9f                   	lahf
    1dce:	93                   	xchg   %eax,%ebx
    1dcf:	02 04 a1             	add    (%rcx,%riz,4),%al
    1dd2:	24 a4                	and    $0xa4,%al
  if (!conn_rate_stats) {
    1dd4:	24 2c                	and    $0x2c,%al
    1dd6:	74 00                	je     1dd8 <balancer_ingress+0x1dd8>
    1dd8:	71 00                	jno    1dda <balancer_ingress+0x1dda>
    1dda:	10 ff                	adc    %bh,%bh
    1ddc:	ff                   	(bad)
    1ddd:	ff                   	(bad)
    1dde:	ff 0f                	decl   (%rdi)
  *cur_time = bpf_ktime_get_ns();
    1de0:	1a 21                	sbb    (%rcx),%ah
    1de2:	9f                   	lahf
    1de3:	93                   	xchg   %eax,%ebx
    1de4:	04 72                	add    $0x72,%al
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1de6:	00 10                	add    %dl,(%rax)
    1de8:	ff                   	(bad)
    1de9:	ff                   	(bad)
    1dea:	ff                   	(bad)
    1deb:	ff 0f                	decl   (%rdi)
    1ded:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    conn_rate_stats->v1 = 1;
    1df3:	a8 b9                	test   $0xb9,%al
    1df5:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
    conn_rate_stats->v2 = *cur_time;
    1dfc:	93                   	xchg   %eax,%ebx
    1dfd:	01 30                	add    %esi,(%rax)
    1dff:	9f                   	lahf
    1e00:	93                   	xchg   %eax,%ebx
    1e01:	02 04 a4             	add    (%rsp,%riz,4),%al
    conn_rate_stats->v1 += 1;
    1e04:	24 ac                	and    $0xac,%al
    1e06:	24 06                	and    $0x6,%al
    1e08:	93                   	xchg   %eax,%ebx
    1e09:	06                   	(bad)
    1e0a:	30 9f 93 02 00 01    	xor    %bl,0x1000293(%rdi)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1e10:	14 04                	adc    $0x4,%al
    1e12:	ab                   	stos   %eax,%es:(%rdi)
    1e13:	1e                   	(bad)
    1e14:	c4                   	(bad)
    1e15:	1e                   	(bad)
    1e16:	03 7f 08             	add    0x8(%rdi),%edi
    1e19:	9f                   	lahf
    1e1a:	04 a2                	add    $0xa2,%al
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1e1c:	22 b8 22 03 7f 08    	and    0x87f0322(%rax),%bh
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    1e22:	9f                   	lahf
    1e23:	04 cb                	add    $0xcb,%al
    1e25:	23 da                	and    %edx,%ebx
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1e27:	23 03                	and    (%rbx),%eax
    1e29:	7f 08                	jg     1e33 <balancer_ingress+0x1e33>
    1e2b:	9f                   	lahf
    1e2c:	00 01                	add    %al,(%rcx)
    1e2e:	14 04                	adc    $0x4,%al
      memset(pckt->flow.srcv6, 0, 16);
    1e30:	ab                   	stos   %eax,%es:(%rdi)
    1e31:	1e                   	(bad)
    1e32:	c4                   	(bad)
    1e33:	1e                   	(bad)
    1e34:	03 7f 08             	add    0x8(%rdi),%edi
    1e37:	9f                   	lahf
    1e38:	04 a2                	add    $0xa2,%al
    1e3a:	22 b8 22 03 7f 08    	and    0x87f0322(%rax),%bh
    1e40:	9f                   	lahf
    1e41:	04 cb                	add    $0xcb,%al
    1e43:	23 da                	and    %edx,%ebx
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    1e45:	23 03                	and    (%rbx),%eax
    1e47:	7f 08                	jg     1e51 <balancer_ingress+0x1e51>
    1e49:	9f                   	lahf
    1e4a:	00 01                	add    %al,(%rcx)
    1e4c:	14 04                	adc    $0x4,%al
    1e4e:	ab                   	stos   %eax,%es:(%rdi)
    1e4f:	1e                   	(bad)
    1e50:	cd 1e                	int    $0x1e
    1e52:	02 30                	add    (%rax),%dh
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1e54:	9f                   	lahf
    1e55:	04 cd                	add    $0xcd,%al
    1e57:	1e                   	(bad)
    1e58:	8a 1f                	mov    (%rdi),%bl
    1e5a:	01 51 04             	add    %edx,0x4(%rcx)
    1e5d:	a2 22 b8 22 02 30 9f 	movabs %al,0xcb049f300222b822
    1e64:	04 cb 
    1e66:	23 d0                	and    %eax,%edx
    1e68:	23 02                	and    (%rdx),%eax
    1e6a:	30 9f 04 dd 23 eb    	xor    %bl,-0x14dc22fc(%rdi)
    1e70:	23 01                	and    (%rcx),%eax
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1e72:	5f                   	pop    %rdi
    1e73:	04 eb                	add    $0xeb,%al
    1e75:	23 ff                	and    %edi,%edi
    1e77:	23 01                	and    (%rcx),%eax
    1e79:	51                   	push   %rcx
    1e7a:	04 81                	add    $0x81,%al
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1e7c:	24 9e                	and    $0x9e,%al
    1e7e:	24 01                	and    $0x1,%al
    if (!real_pos) {
    1e80:	51                   	push   %rcx
    1e81:	00 01                	add    %al,(%rcx)
    1e83:	14 04                	adc    $0x4,%al
    1e85:	de 1e                	ficomps (%rsi)
    1e87:	92                   	xchg   %eax,%edx
    1e88:	1f                   	(bad)
    1e89:	13 72 00             	adc    0x0(%rdx),%esi
    1e8c:	10 ff                	adc    %bh,%bh
    1e8e:	ff                   	(bad)
    1e8f:	ff                   	(bad)
    1e90:	ff 0f                	decl   (%rdi)
    1e92:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    1e98:	a8 b9                	test   $0xb9,%al
    1e9a:	80 80 00 04 eb 23 ac 	addb   $0xac,0x23eb0400(%rax)
    key = *real_pos;
    1ea1:	24 13                	and    $0x13,%al
    if (key == 0) {
    1ea3:	72 00                	jb     1ea5 <balancer_ingress+0x1ea5>
    1ea5:	10 ff                	adc    %bh,%bh
    1ea7:	ff                   	(bad)
  pckt->real_index = key;
    1ea8:	ff                   	(bad)
    1ea9:	ff 0f                	decl   (%rdi)
    1eab:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
  if (!(*real)) {
    1eb1:	a8 b9                	test   $0xb9,%al
    1eb3:	80 80 00 00 01 14 04 	addb   $0x4,0x14010000(%rax)
    1eba:	99                   	cltd
    1ebb:	1f                   	(bad)
    1ebc:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    1ebd:	1f                   	(bad)
    1ebe:	02 30                	add    (%rax),%dh
    1ec0:	9f                   	lahf
    1ec1:	04 a7                	add    $0xa7,%al
    1ec3:	1f                   	(bad)
    1ec4:	b2 1f                	mov    $0x1f,%dl
    1ec6:	01 50 00             	add    %edx,0x0(%rax)
    1ec9:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1ecc:	d0 1f                	rcrb   (%rdi)
    1ece:	dd 1f                	fstpl  (%rdi)
    1ed0:	02 30                	add    (%rax),%dh
    1ed2:	9f                   	lahf
    1ed3:	04 dd                	add    $0xdd,%al
    1ed5:	1f                   	(bad)
    1ed6:	e6 1f                	out    %al,$0x1f
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1ed8:	01 5e 00             	add    %ebx,0x0(%rsi)
    1edb:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1ede:	e6 1f                	out    %al,$0x1f
    1ee0:	87 20                	xchg   %esp,(%rax)
    1ee2:	01 5e 00             	add    %ebx,0x0(%rsi)
    if (pckt->flow.proto == IPPROTO_UDP) {
    1ee5:	01 14 04             	add    %edx,(%rsp,%rax,1)
    1ee8:	c9                   	leave
    1ee9:	20 e1                	and    %ah,%cl
      new_dst_lru.atime = cur_time;
    1eeb:	21 02                	and    %eax,(%rdx)
    1eed:	30 9f 04 f5 22 cb    	xor    %bl,-0x34dd0afc(%rdi)
    1ef3:	23 02                	and    (%rdx),%eax
    1ef5:	30 9f 04 b0 32 af    	xor    %bl,-0x50cd4ffc(%rdi)
    1efb:	34 02                	xor    $0x2,%al
    1efd:	30 9f 04 b8 34 c0    	xor    %bl,-0x3fcb47fc(%rdi)
BPF_MAP_OPS_INLINE(map_update_elem,,
    1f03:	34 02                	xor    $0x2,%al
    1f05:	30 9f 04 fa 42 d3    	xor    %bl,-0x2cbd05fc(%rdi)
    1f0b:	44 02 30             	add    (%rax),%r14b
    1f0e:	9f                   	lahf
    1f0f:	00 01                	add    %al,(%rcx)
      (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
    1f11:	14 04                	adc    $0x4,%al
    1f13:	c9                   	leave
    1f14:	20 d6                	and    %dl,%dh
    1f16:	20 02                	and    %al,(%rdx)
    1f18:	30 9f 04 d6 20 df    	xor    %bl,-0x20df29fc(%rdi)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1f1e:	20 01                	and    %al,(%rcx)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1f20:	5e                   	pop    %rsi
    1f21:	00 01                	add    %al,(%rcx)
    1f23:	14 04                	adc    $0x4,%al
    1f25:	df 20                	fbld   (%rax)
    1f27:	e1 21                	loope  1f4a <balancer_ingress+0x1f4a>
    1f29:	01 5e 04             	add    %ebx,0x4(%rsi)
    1f2c:	f5                   	cmc
    1f2d:	22 b4 23 01 5e 04 b0 	and    -0x4ffba1ff(%rbx,%riz,1),%dh
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1f34:	32 af 34 01 5e 04    	xor    0x45e0134(%rdi),%ch
  bool vip_match = address_match && port_match && proto_match;
    1f3a:	b8 34 c0 34 01       	mov    $0x134c034,%eax
    1f3f:	5e                   	pop    %rsi
    1f40:	04 fa                	add    $0xfa,%al
    1f42:	42 d3 44 01 5e       	roll   %cl,0x5e(%rcx,%r8,1)
    __u32 lru_stats_key = pckt->real_index;
    1f47:	00 01                	add    %al,(%rcx)
    1f49:	14 04                	adc    $0x4,%al
    1f4b:	e8 20 ec 20 01       	call   1210b70 <_license+0x120e7db>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1f50:	5f                   	pop    %rdi
    1f51:	00 01                	add    %al,(%rcx)
    1f53:	14 04                	adc    $0x4,%al
    1f55:	e8 20 e1 21 01       	call   122007a <_license+0x121dce5>
    1f5a:	5d                   	pop    %rbp
    1f5b:	04 f5                	add    $0xf5,%al
    1f5d:	22 8a 23 01 5d 04    	and    0x45d0123(%rdx),%cl
    1f63:	b0 32                	mov    $0x32,%al
    1f65:	91                   	xchg   %eax,%ecx
    1f66:	33 01                	xor    (%rcx),%eax
    if (!lru_miss_stat) {
    1f68:	5d                   	pop    %rbp
    1f69:	00 01                	add    %al,(%rcx)
    1f6b:	14 04                	adc    $0x4,%al
    *lru_miss_stat += 1;
    1f6d:	e8 20 e1 21 02       	call   2220092 <_license+0x221dcfd>
      data_stats->v2 += 1;
    1f72:	30 9f 04 f5 22 8a    	xor    %bl,-0x75dd0afc(%rdi)
    1f78:	23 02                	and    (%rdx),%eax
    1f7a:	30 9f 04 b0 32 91    	xor    %bl,-0x6ecd4ffc(%rdi)
    1f80:	33 02                	xor    (%rdx),%eax
    1f82:	30 9f 00 01 14 04    	xor    %bl,0x4140100(%rdi)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1f88:	e8 20 e1 21 03       	call   32200ad <_license+0x321dd18>
    1f8d:	77 10                	ja     1f9f <balancer_ingress+0x1f9f>
  if (!ch_drop_stats) {
    1f8f:	9f                   	lahf
    1f90:	04 f5                	add    $0xf5,%al
    1f92:	22 8a 23 03 77 10    	and    0x10770323(%rdx),%cl
    1f98:	9f                   	lahf
    1f99:	04 b0                	add    $0xb0,%al
    1f9b:	32 91 33 03 77 10    	xor    0x10770333(%rcx),%dl
}
    1fa1:	9f                   	lahf
    1fa2:	00 01                	add    %al,(%rcx)
    1fa4:	14 04                	adc    $0x4,%al
    1fa6:	e8 20 ad 21 12       	call   1221cccb <_license+0x1221a936>
    1fab:	30 20                	xor    %ah,(%rax)
    1fad:	9f                   	lahf
    1fae:	93                   	xchg   %eax,%ebx
    1faf:	04 30                	add    $0x30,%al
    1fb1:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    1fb7:	93                   	xchg   %eax,%ebx
    1fb8:	01 30                	add    %esi,(%rax)
    1fba:	9f                   	lahf
    1fbb:	93                   	xchg   %eax,%ebx
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1fbc:	02 04 ad 21 dc 21 22 	add    0x2221dc21(,%rbp,4),%al
    1fc3:	30 20                	xor    %ah,(%rax)
    1fc5:	9f                   	lahf
    1fc6:	93                   	xchg   %eax,%ebx
    1fc7:	04 70                	add    $0x70,%al
  if (!ch_drop_stats) {
    1fc9:	00 10                	add    %dl,(%rax)
    1fcb:	ff                   	(bad)
    1fcc:	ff                   	(bad)
    1fcd:	ff                   	(bad)
    1fce:	ff 0f                	decl   (%rdi)
    1fd0:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    1fd6:	a8 b9                	test   $0xb9,%al
    1fd8:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1fdf:	93                   	xchg   %eax,%ebx
    1fe0:	01 30                	add    %esi,(%rax)
    1fe2:	9f                   	lahf
    1fe3:	93                   	xchg   %eax,%ebx
    1fe4:	02 04 dc             	add    (%rsp,%rbx,8),%al
    1fe7:	21 e1                	and    %esp,%ecx
    1fe9:	21 1f                	and    %ebx,(%rdi)
  data = (void*)(long)xdp->data;
    1feb:	93                   	xchg   %eax,%ebx
    1fec:	04 70                	add    $0x70,%al
  data_end = (void*)(long)xdp->data_end;
    1fee:	00 10                	add    %dl,(%rax)
    1ff0:	ff                   	(bad)
    1ff1:	ff                   	(bad)
  ip6h = data + sizeof(struct ethhdr);
    1ff2:	ff                   	(bad)
    1ff3:	ff 0f                	decl   (%rdi)
    1ff5:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    1ffb:	a8 b9                	test   $0xb9,%al
    1ffd:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    2004:	93                   	xchg   %eax,%ebx
    2005:	01 30                	add    %esi,(%rax)
    2007:	9f                   	lahf
    2008:	93                   	xchg   %eax,%ebx
    2009:	02 04 f5 22 8a 23 12 	add    0x12238a22(,%rsi,8),%al
    2010:	30 20                	xor    %ah,(%rax)
    2012:	9f                   	lahf
  memcpy(new_eth->h_dest, cval->mac, 6);
    2013:	93                   	xchg   %eax,%ebx
    2014:	04 30                	add    $0x30,%al
    2016:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    201c:	93                   	xchg   %eax,%ebx
    201d:	01 30                	add    %esi,(%rax)
    201f:	9f                   	lahf
    2020:	93                   	xchg   %eax,%ebx
    2021:	02 04 b0             	add    (%rax,%rsi,4),%al
    2024:	32 d0                	xor    %al,%dl
    2026:	32 12                	xor    (%rdx),%dl
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    2028:	30 20                	xor    %ah,(%rax)
    202a:	9f                   	lahf
    202b:	93                   	xchg   %eax,%ebx
    202c:	04 30                	add    $0x30,%al
    202e:	20 9f 93 01 30 9f    	and    %bl,-0x60cffe6d(%rdi)
    2034:	93                   	xchg   %eax,%ebx
    2035:	01 30                	add    %esi,(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    2037:	9f                   	lahf
    2038:	93                   	xchg   %eax,%ebx
    2039:	02 04 d0             	add    (%rax,%rdx,8),%al
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
    203c:	32 e4                	xor    %ah,%ah
    203e:	32 22                	xor    (%rdx),%ah
    2040:	30 20                	xor    %ah,(%rax)
  saddr[3] = src ^ port;
    2042:	9f                   	lahf
    2043:	93                   	xchg   %eax,%ebx
    2044:	04 70                	add    $0x70,%al
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    2046:	00 10                	add    %dl,(%rax)
    2048:	ff                   	(bad)
    2049:	ff                   	(bad)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    204a:	ff                   	(bad)
    204b:	ff 0f                	decl   (%rdi)
    204d:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2053:	a8 b9                	test   $0xb9,%al
    2055:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    205c:	93                   	xchg   %eax,%ebx
    205d:	01 30                	add    %esi,(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    205f:	9f                   	lahf
    2060:	93                   	xchg   %eax,%ebx
    2061:	02 04 e4             	add    (%rsp,%riz,8),%al
  ip6h->nexthdr = proto;
    2064:	32 e6                	xor    %dh,%ah
    2066:	32 1f                	xor    (%rdi),%bl
    2068:	93                   	xchg   %eax,%ebx
    2069:	04 70                	add    $0x70,%al
  ip6h->payload_len = bpf_htons(payload_len);
    206b:	00 10                	add    %dl,(%rax)
    206d:	ff                   	(bad)
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    206e:	ff                   	(bad)
    206f:	ff                   	(bad)
    2070:	ff 0f                	decl   (%rdi)
    2072:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2078:	a8 b9                	test   $0xb9,%al
    207a:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    2081:	93                   	xchg   %eax,%ebx
    2082:	01 30                	add    %esi,(%rax)
    2084:	9f                   	lahf
    2085:	93                   	xchg   %eax,%ebx
    2086:	02 04 e6             	add    (%rsi,%riz,8),%al
    2089:	32 83 33 22 30 20    	xor    0x20302233(%rbx),%al
    208f:	9f                   	lahf
    2090:	93                   	xchg   %eax,%ebx
    2091:	04 70                	add    $0x70,%al
    2093:	00 10                	add    %dl,(%rax)
    2095:	ff                   	(bad)
    2096:	ff                   	(bad)
    2097:	ff                   	(bad)
    2098:	ff 0f                	decl   (%rdi)
    209a:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    20a0:	a8 b9                	test   $0xb9,%al
    20a2:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
    20a9:	93                   	xchg   %eax,%ebx
    20aa:	01 30                	add    %esi,(%rax)
  if (!conn_rate_stats) {
    20ac:	9f                   	lahf
    20ad:	93                   	xchg   %eax,%ebx
    20ae:	02 04 83             	add    (%rbx,%rax,4),%al
    20b1:	33 86 33 1f 93 04    	xor    0x4931f33(%rsi),%eax
    20b7:	70 00                	jo     20b9 <balancer_ingress+0x20b9>
    20b9:	10 ff                	adc    %bh,%bh
  *cur_time = bpf_ktime_get_ns();
    20bb:	ff                   	(bad)
    20bc:	ff                   	(bad)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    20bd:	ff 0f                	decl   (%rdi)
    20bf:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    20c5:	a8 b9                	test   $0xb9,%al
    20c7:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
    conn_rate_stats->v1 = 1;
    20ce:	93                   	xchg   %eax,%ebx
    20cf:	01 30                	add    %esi,(%rax)
    20d1:	9f                   	lahf
    20d2:	93                   	xchg   %eax,%ebx
    20d3:	02 04 86             	add    (%rsi,%rax,4),%al
    conn_rate_stats->v2 = *cur_time;
    20d6:	33 89 33 2c 71 00    	xor    0x712c33(%rcx),%ecx
              quic_packets_stats->dst_mismatch_in_lru += 1;
    20dc:	72 00                	jb     20de <balancer_ingress+0x20de>
    20de:	10 ff                	adc    %bh,%bh
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    20e0:	ff                   	(bad)
    20e1:	ff                   	(bad)
    20e2:	ff 0f                	decl   (%rdi)
    20e4:	1a 21                	sbb    (%rcx),%ah
    20e6:	9f                   	lahf
    20e7:	93                   	xchg   %eax,%ebx
    20e8:	04 70                	add    $0x70,%al
    20ea:	00 10                	add    %dl,(%rax)
    20ec:	ff                   	(bad)
    20ed:	ff                   	(bad)
    20ee:	ff                   	(bad)
    20ef:	ff 0f                	decl   (%rdi)
    20f1:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    20f7:	a8 b9                	test   $0xb9,%al
    20f9:	80 80 00 93 01 30 9f 	addb   $0x9f,0x30019300(%rax)
    2100:	93                   	xchg   %eax,%ebx
    2101:	01 30                	add    %esi,(%rax)
    2103:	9f                   	lahf
    2104:	93                   	xchg   %eax,%ebx
    2105:	02 04 89             	add    (%rcx,%rcx,4),%al
  if (!per_vip_stats) {
    2108:	33 91 33 06 93 06    	xor    0x6930633(%rcx),%edx
    per_vip_stats->v2 += 1;
    210e:	30 9f 93 02 00 01    	xor    %bl,0x1000293(%rdi)
    conn_rate_stats->v1 += 1;
    2114:	14 04                	adc    $0x4,%al
    2116:	82                   	(bad)
    2117:	21 93 21 03 7f 08    	and    %edx,0x87f0321(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    211d:	9f                   	lahf
    211e:	04 f5                	add    $0xf5,%al
    2120:	22 8a 23 03 7f 08    	and    0x87f0323(%rdx),%cl
  struct real_pos_lru new_dst_lru = {};
    2126:	9f                   	lahf
    2127:	04 b0                	add    $0xb0,%al
    2129:	32 bf 32 03 7f 08    	xor    0x87f0332(%rdi),%bh
    212f:	9f                   	lahf
    2130:	00 01                	add    %al,(%rcx)
    2132:	14 04                	adc    $0x4,%al
  new_dst_lru.pos = pckt->real_index;
    2134:	82                   	(bad)
    2135:	21 93 21 03 7f 08    	and    %edx,0x87f0321(%rbx)
    213b:	9f                   	lahf
    213c:	04 f5                	add    $0xf5,%al
    213e:	22 8a 23 03 7f 08    	and    0x87f0323(%rdx),%cl
    2144:	9f                   	lahf
    2145:	04 b0                	add    $0xb0,%al
    2147:	32 bf 32 03 7f 08    	xor    0x87f0332(%rdi),%bh
              quic_packets_stats->dst_not_found_in_lru += 1;
    214d:	9f                   	lahf
    214e:	00 01                	add    %al,(%rcx)
    2150:	14 04                	adc    $0x4,%al
    2152:	82                   	(bad)
    2153:	21 9c 21 02 30 9f 04 	and    %ebx,0x49f3002(%rcx,%riz,1)
            quic_packets_stats->cid_routed += 1;
    215a:	9c                   	pushf
  original_sport = pckt.flow.port16[0];
    215b:	21 d9                	and    %ebx,%ecx
    215d:	21 01                	and    %eax,(%rcx)
    215f:	52                   	push   %rdx
    2160:	04 f5                	add    $0xf5,%al
    2162:	22 8a 23 02 30 9f    	and    -0x60cffddd(%rdx),%cl
    2168:	04 b0                	add    $0xb0,%al
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    216a:	32 b5 32 02 30 9f    	xor    -0x60cffdce(%rbp),%dh
    2170:	04 c2                	add    $0xc2,%al
    2172:	32 d0                	xor    %al,%dl
    2174:	32 01                	xor    (%rcx),%al
    2176:	5f                   	pop    %rdi
    2177:	04 d0                	add    $0xd0,%al
    2179:	32 e4                	xor    %ah,%ah
    217b:	32 01                	xor    (%rcx),%al
    217d:	52                   	push   %rdx
    217e:	04 e6                	add    $0xe6,%al
    2180:	32 83 33 01 52 00    	xor    0x520133(%rbx),%al
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2186:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2189:	ad                   	lods   %ds:(%rsi),%eax
    218a:	21 e1                	and    %esp,%ecx
    218c:	21 13                	and    %edx,(%rbx)
    218e:	70 00                	jo     2190 <balancer_ingress+0x2190>
  if (!conn_rate_stats) {
    2190:	10 ff                	adc    %bh,%bh
    2192:	ff                   	(bad)
    2193:	ff                   	(bad)
    2194:	ff 0f                	decl   (%rdi)
    2196:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    219c:	a8 b9                	test   $0xb9,%al
    219e:	80 80 00 04 d0 32 91 	addb   $0x91,0x32d00400(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    21a5:	33 13                	xor    (%rbx),%edx
    21a7:	70 00                	jo     21a9 <balancer_ingress+0x21a9>
    21a9:	10 ff                	adc    %bh,%bh
    21ab:	ff                   	(bad)
    21ac:	ff                   	(bad)
    21ad:	ff 0f                	decl   (%rdi)
    21af:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    conn_rate_stats->v1 = 1;
    21b5:	a8 b9                	test   $0xb9,%al
    21b7:	80 80 00 00 01 14 04 	addb   $0x4,0x14010000(%rax)
    conn_rate_stats->v2 = *cur_time;
    21be:	e1 21                	loope  21e1 <balancer_ingress+0x21e1>
      dst_lru->pos = pckt->real_index;
    21c0:	ee                   	out    %al,(%dx)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    21c1:	21 02                	and    %eax,(%rdx)
    21c3:	30 9f 04 ee 21 f7    	xor    %bl,-0x8de11fc(%rdi)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    21c9:	21 01                	and    %eax,(%rcx)
    21cb:	5e                   	pop    %rsi
    21cc:	00 01                	add    %al,(%rcx)
    21ce:	14 04                	adc    $0x4,%al
    21d0:	f7 21                	mull   (%rcx)
    21d2:	9d                   	popf
    21d3:	22 01                	and    (%rcx),%al
    21d5:	5e                   	pop    %rsi
    21d6:	00 01                	add    %al,(%rcx)
    21d8:	14 04                	adc    $0x4,%al
    21da:	b8 22 f5 22 0b       	mov    $0xb22f522,%eax
    21df:	30 20                	xor    %ah,(%rax)
    21e1:	9f                   	lahf
    21e2:	93                   	xchg   %eax,%ebx
    21e3:	04 93                	add    $0x93,%al
    21e5:	02 30                	add    (%rax),%dh
    21e7:	9f                   	lahf
    21e8:	93                   	xchg   %eax,%ebx
    21e9:	02 04 a4             	add    (%rsp,%riz,4),%al
  if (!per_vip_stats) {
    21ec:	24 ac                	and    $0xac,%al
    21ee:	24 09                	and    $0x9,%al
    per_vip_stats->v2 += 1;
    21f0:	51                   	push   %rcx
    21f1:	93                   	xchg   %eax,%ebx
    21f2:	04 93                	add    $0x93,%al
    21f4:	02 30                	add    (%rax),%dh
    conn_rate_stats->v1 += 1;
    21f6:	9f                   	lahf
    21f7:	93                   	xchg   %eax,%ebx
    21f8:	02 04 ac             	add    (%rsp,%rbp,4),%al
    21fb:	24 c0                	and    $0xc0,%al
    21fd:	24 1e                	and    $0x1e,%al
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    21ff:	51                   	push   %rcx
    2200:	93                   	xchg   %eax,%ebx
    2201:	04 72                	add    $0x72,%al
    2203:	00 10                	add    %dl,(%rax)
    2205:	ff                   	(bad)
    2206:	ff                   	(bad)
  struct real_pos_lru new_dst_lru = {};
    2207:	ff                   	(bad)
    2208:	ff 0f                	decl   (%rdi)
    220a:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2210:	a8 b9                	test   $0xb9,%al
    2212:	80 80 00 93 01 93 01 	addb   $0x1,-0x6cfe6d00(%rax)
  new_dst_lru.pos = pckt->real_index;
    2219:	30 9f 93 02 04 c0    	xor    %bl,-0x3ffbfd6d(%rdi)
    221f:	24 c2                	and    $0xc2,%al
    2221:	24 09                	and    $0x9,%al
    2223:	51                   	push   %rcx
    2224:	93                   	xchg   %eax,%ebx
    2225:	04 93                	add    $0x93,%al
    2227:	02 30                	add    (%rax),%dh
    2229:	9f                   	lahf
    222a:	93                   	xchg   %eax,%ebx
    222b:	02 04 c2             	add    (%rdx,%rax,8),%al
    222e:	24 c6                	and    $0xc6,%al
    2230:	24 1e                	and    $0x1e,%al
    2232:	51                   	push   %rcx
    2233:	93                   	xchg   %eax,%ebx
              quic_packets_stats->dst_not_found_in_lru += 1;
    2234:	04 72                	add    $0x72,%al
    2236:	00 10                	add    %dl,(%rax)
    2238:	ff                   	(bad)
    2239:	ff                   	(bad)
    223a:	ff                   	(bad)
    223b:	ff 0f                	decl   (%rdi)
    223d:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
  original_sport = pckt.flow.port16[0];
    2243:	a8 b9                	test   $0xb9,%al
    2245:	80 80 00 93 01 93 01 	addb   $0x1,-0x6cfe6d00(%rax)
    224c:	30 9f 93 02 04 c6    	xor    %bl,-0x39fbfd6d(%rdi)
    2252:	24 c8                	and    $0xc8,%al
    2254:	24 09                	and    $0x9,%al
    2256:	51                   	push   %rcx
    2257:	93                   	xchg   %eax,%ebx
    2258:	04 93                	add    $0x93,%al
    225a:	02 30                	add    (%rax),%dh
    225c:	9f                   	lahf
    225d:	93                   	xchg   %eax,%ebx
    225e:	02 04 c8             	add    (%rax,%rcx,8),%al
  a += initval;
    2261:	24 cc                	and    $0xcc,%al
    2263:	24 1e                	and    $0x1e,%al
    2265:	51                   	push   %rcx
    2266:	93                   	xchg   %eax,%ebx
    2267:	04 72                	add    $0x72,%al
    2269:	00 10                	add    %dl,(%rax)
  b += initval;
    226b:	ff                   	(bad)
    226c:	ff                   	(bad)
    226d:	ff                   	(bad)
    226e:	ff 0f                	decl   (%rdi)
  __jhash_final(a, b, c);
    2270:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2276:	a8 b9                	test   $0xb9,%al
  return (word << shift) | (word >> ((-shift) & 31));
    2278:	80 80 00 93 01 93 01 	addb   $0x1,-0x6cfe6d00(%rax)
  __jhash_final(a, b, c);
    227f:	30 9f 93 02 04 cc    	xor    %bl,-0x33fbfd6d(%rdi)
    2285:	24 ce                	and    $0xce,%al
    2287:	24 09                	and    $0x9,%al
  return (word << shift) | (word >> ((-shift) & 31));
    2289:	51                   	push   %rcx
    228a:	93                   	xchg   %eax,%ebx
    228b:	04 93                	add    $0x93,%al
    228d:	02 30                	add    (%rax),%dh
  __jhash_final(a, b, c);
    228f:	9f                   	lahf
  return (word << shift) | (word >> ((-shift) & 31));
    2290:	93                   	xchg   %eax,%ebx
    2291:	02 04 ce             	add    (%rsi,%rcx,8),%al
    2294:	24 d2                	and    $0xd2,%al
  __jhash_final(a, b, c);
    2296:	24 1e                	and    $0x1e,%al
    2298:	51                   	push   %rcx
    2299:	93                   	xchg   %eax,%ebx
    229a:	04 72                	add    $0x72,%al
  return (word << shift) | (word >> ((-shift) & 31));
    229c:	00 10                	add    %dl,(%rax)
    229e:	ff                   	(bad)
    229f:	ff                   	(bad)
  __jhash_final(a, b, c);
    22a0:	ff                   	(bad)
    22a1:	ff 0f                	decl   (%rdi)
    22a3:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    22a9:	a8 b9                	test   $0xb9,%al
  return (word << shift) | (word >> ((-shift) & 31));
    22ab:	80 80 00 93 01 93 01 	addb   $0x1,-0x6cfe6d00(%rax)
    22b2:	30 9f 93 02 04 d2    	xor    %bl,-0x2dfbfd6d(%rdi)
    22b8:	24 b0                	and    $0xb0,%al
    22ba:	25 09 51 93 04       	and    $0x4935109,%eax
    22bf:	93                   	xchg   %eax,%ebx
    a += *(u32*)(k);
    22c0:	02 30                	add    (%rax),%dh
    22c2:	9f                   	lahf
    22c3:	93                   	xchg   %eax,%ebx
    22c4:	02 04 b0             	add    (%rax,%rsi,4),%al
    b += *(u32*)(k + 4);
    22c7:	25 d1 25 06 93       	and    $0x930625d1,%eax
    22cc:	06                   	(bad)
    22cd:	30 9f 93 02 04 d1    	xor    %bl,-0x2efbfd6d(%rdi)
    __jhash_mix(a, b, c);
    22d3:	25 d9 25 09 51       	and    $0x510925d9,%eax
    c += *(u32*)(k + 8);
    22d8:	93                   	xchg   %eax,%ebx
    22d9:	04 93                	add    $0x93,%al
    22db:	02 30                	add    (%rax),%dh
  return (word << shift) | (word >> ((-shift) & 31));
    22dd:	9f                   	lahf
    22de:	93                   	xchg   %eax,%ebx
    22df:	02 04 95 41 fa 42 06 	add    0x642fa41(,%rdx,4),%al
    __jhash_mix(a, b, c);
    22e6:	93                   	xchg   %eax,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    22e7:	06                   	(bad)
    22e8:	30 9f 93 02 00 01    	xor    %bl,0x1000293(%rdi)
    __jhash_mix(a, b, c);
    22ee:	14 04                	adc    $0x4,%al
    22f0:	bc 22 de 22 02       	mov    $0x222de22,%esp
    22f5:	30 9f 04 de 22 e7    	xor    %bl,-0x18dd21fc(%rdi)
    22fb:	22 01                	and    (%rcx),%al
    22fd:	5e                   	pop    %rsi
    22fe:	00 01                	add    %al,(%rcx)
    2300:	14 04                	adc    $0x4,%al
  return (word << shift) | (word >> ((-shift) & 31));
    2302:	e7 22                	out    %eax,$0x22
    __jhash_mix(a, b, c);
    2304:	f5                   	cmc
    2305:	22 01                	and    (%rcx),%al
    2307:	5e                   	pop    %rsi
    2308:	00 01                	add    %al,(%rcx)
  return (word << shift) | (word >> ((-shift) & 31));
    230a:	14 04                	adc    $0x4,%al
    230c:	8a 23                	mov    (%rbx),%ah
    __jhash_mix(a, b, c);
    230e:	cb                   	lret
    230f:	23 0b                	and    (%rbx),%ecx
    2311:	30 20                	xor    %ah,(%rax)
    2313:	9f                   	lahf
    2314:	93                   	xchg   %eax,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    2315:	04 93                	add    $0x93,%al
    2317:	02 30                	add    (%rax),%dh
    2319:	9f                   	lahf
    231a:	93                   	xchg   %eax,%ebx
    231b:	02 04 89             	add    (%rcx,%rcx,4),%al
    __jhash_mix(a, b, c);
    231e:	33 91 33 09 52 93    	xor    -0x6cadf6cd(%rcx),%edx
    2324:	04 93                	add    $0x93,%al
    2326:	02 30                	add    (%rax),%dh
  return (word << shift) | (word >> ((-shift) & 31));
    2328:	9f                   	lahf
    2329:	93                   	xchg   %eax,%ebx
    232a:	02 04 91             	add    (%rcx,%rdx,4),%al
      a += (u32)k[3] << 24;
    232d:	33 a5 33 1e 52 93    	xor    -0x6cade1cd(%rbp),%esp
      a += (u32)k[2] << 16;
    2333:	04 70                	add    $0x70,%al
    2335:	00 10                	add    %dl,(%rax)
    2337:	ff                   	(bad)
    2338:	ff                   	(bad)
    2339:	ff                   	(bad)
    233a:	ff 0f                	decl   (%rdi)
      a += (u32)k[3] << 24;
    233c:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
      a += (u32)k[1] << 8;
    2342:	a8 b9                	test   $0xb9,%al
    2344:	80 80 00 93 01 93 01 	addb   $0x1,-0x6cfe6d00(%rax)
      a += k[0];
    234b:	30 9f 93 02 04 a5    	xor    %bl,-0x5afbfd6d(%rdi)
      a += (u32)k[1] << 8;
    2351:	33 a7 33 09 52 93    	xor    -0x6cadf6cd(%rdi),%esp
      __jhash_final(a, b, c);
    2357:	04 93                	add    $0x93,%al
  return (word << shift) | (word >> ((-shift) & 31));
    2359:	02 30                	add    (%rax),%dh
    235b:	9f                   	lahf
    235c:	93                   	xchg   %eax,%ebx
    235d:	02 04 a7             	add    (%rdi,%riz,4),%al
    2360:	33 ab 33 1e 52 93    	xor    -0x6cade1cd(%rbx),%ebp
      __jhash_final(a, b, c);
    2366:	04 70                	add    $0x70,%al
    2368:	00 10                	add    %dl,(%rax)
    236a:	ff                   	(bad)
  return (word << shift) | (word >> ((-shift) & 31));
    236b:	ff                   	(bad)
    236c:	ff                   	(bad)
    236d:	ff 0f                	decl   (%rdi)
    236f:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2375:	a8 b9                	test   $0xb9,%al
    2377:	80 80 00 93 01 93 01 	addb   $0x1,-0x6cfe6d00(%rax)
    237e:	30 9f 93 02 04 ab    	xor    %bl,-0x54fbfd6d(%rdi)
      __jhash_final(a, b, c);
    2384:	33 ad 33 09 52 93    	xor    -0x6cadf6cd(%rbp),%ebp
    238a:	04 93                	add    $0x93,%al
  return (word << shift) | (word >> ((-shift) & 31));
    238c:	02 30                	add    (%rax),%dh
    238e:	9f                   	lahf
    238f:	93                   	xchg   %eax,%ebx
      __jhash_final(a, b, c);
    2390:	02 04 ad 33 b1 33 1e 	add    0x1e33b133(,%rbp,4),%al
    2397:	52                   	push   %rdx
    2398:	93                   	xchg   %eax,%ebx
    2399:	04 70                	add    $0x70,%al
    239b:	00 10                	add    %dl,(%rax)
    239d:	ff                   	(bad)
    239e:	ff                   	(bad)
    239f:	ff                   	(bad)
    23a0:	ff 0f                	decl   (%rdi)
    23a2:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    23a8:	a8 b9                	test   $0xb9,%al
    23aa:	80 80 00 93 01 93 01 	addb   $0x1,-0x6cfe6d00(%rax)
    23b1:	30 9f 93 02 04 b1    	xor    %bl,-0x4efbfd6d(%rdi)
    23b7:	33 b3 33 09 52 93    	xor    -0x6cadf6cd(%rbx),%esi
    23bd:	04 93                	add    $0x93,%al
    23bf:	02 30                	add    (%rax),%dh
    23c1:	9f                   	lahf
    23c2:	93                   	xchg   %eax,%ebx
    23c3:	02 04 b3             	add    (%rbx,%rsi,4),%al
    23c6:	33 b7 33 1e 52 93    	xor    -0x6cade1cd(%rdi),%esi
    23cc:	04 70                	add    $0x70,%al
    23ce:	00 10                	add    %dl,(%rax)
    23d0:	ff                   	(bad)
    23d1:	ff                   	(bad)
    23d2:	ff                   	(bad)
    23d3:	ff 0f                	decl   (%rdi)
    23d5:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    23db:	a8 b9                	test   $0xb9,%al
    23dd:	80 80 00 93 01 93 01 	addb   $0x1,-0x6cfe6d00(%rax)
    23e4:	30 9f 93 02 04 b7    	xor    %bl,-0x48fbfd6d(%rdi)
    23ea:	33 f5                	xor    %ebp,%esi
    23ec:	33 09                	xor    (%rcx),%ecx
    23ee:	52                   	push   %rdx
    23ef:	93                   	xchg   %eax,%ebx
    23f0:	04 93                	add    $0x93,%al
    23f2:	02 30                	add    (%rax),%dh
    23f4:	9f                   	lahf
    23f5:	93                   	xchg   %eax,%ebx
    23f6:	02 04 f5 33 af 34 06 	add    0x634af33(,%rsi,8),%al
    23fd:	93                   	xchg   %eax,%ebx
    23fe:	06                   	(bad)
    23ff:	30 9f 93 02 04 b8    	xor    %bl,-0x47fbfd6d(%rdi)
    2405:	34 c0                	xor    $0xc0,%al
    2407:	34 09                	xor    $0x9,%al
    2409:	52                   	push   %rdx
    240a:	93                   	xchg   %eax,%ebx
    240b:	04 93                	add    $0x93,%al
    240d:	02 30                	add    (%rax),%dh
    240f:	9f                   	lahf
    2410:	93                   	xchg   %eax,%ebx
    2411:	02 04 fa             	add    (%rdx,%rdi,8),%al
    2414:	42 d3 44 06 93       	roll   %cl,-0x6d(%rsi,%r8,1)
    2419:	06                   	(bad)
    241a:	30 9f 93 02 00 01    	xor    %bl,0x1000293(%rdi)
    2420:	14 04                	adc    $0x4,%al
    2422:	8e 23                	mov    (%rbx),%fs
    2424:	b4 23                	mov    $0x23,%ah
    2426:	02 30                	add    (%rax),%dh
    2428:	9f                   	lahf
    2429:	04 b4                	add    $0xb4,%al
    242b:	23 bd 23 01 5e 00    	and    0x5e0123(%rbp),%edi
    2431:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2434:	bd 23 cb 23 01       	mov    $0x123cb23,%ebp
    2439:	5e                   	pop    %rsi
    243a:	00 01                	add    %al,(%rcx)
    243c:	14 04                	adc    $0x4,%al
    243e:	d0 23                	shlb   (%rbx)
    2440:	d6                   	(bad)
    2441:	23 03                	and    (%rbx),%eax
    2443:	7f 08                	jg     244d <_license+0xb8>
    2445:	9f                   	lahf
    2446:	00 01                	add    %al,(%rcx)
    2448:	14 04                	adc    $0x4,%al
    244a:	ac                   	lods   %ds:(%rsi),%al
    244b:	24 c0                	and    $0xc0,%al
    244d:	24 13                	and    $0x13,%al
    244f:	72 00                	jb     2451 <_license+0xbc>
    2451:	10 ff                	adc    %bh,%bh
    2453:	ff                   	(bad)
    2454:	ff                   	(bad)
    2455:	ff 0f                	decl   (%rdi)
    2457:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    245d:	a8 b9                	test   $0xb9,%al
    245f:	80 80 00 04 c2 24 c6 	addb   $0xc6,0x24c20400(%rax)
    2466:	24 13                	and    $0x13,%al
    2468:	72 00                	jb     246a <_license+0xd5>
    246a:	10 ff                	adc    %bh,%bh
    246c:	ff                   	(bad)
    246d:	ff                   	(bad)
    246e:	ff 0f                	decl   (%rdi)
    2470:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2476:	a8 b9                	test   $0xb9,%al
    2478:	80 80 00 04 c8 24 cc 	addb   $0xcc,0x24c80400(%rax)
    247f:	24 13                	and    $0x13,%al
    2481:	72 00                	jb     2483 <_license+0xee>
    2483:	10 ff                	adc    %bh,%bh
    2485:	ff                   	(bad)
    2486:	ff                   	(bad)
    2487:	ff 0f                	decl   (%rdi)
    2489:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    248f:	a8 b9                	test   $0xb9,%al
    2491:	80 80 00 04 ce 24 d2 	addb   $0xd2,0x24ce0400(%rax)
    2498:	24 13                	and    $0x13,%al
    249a:	72 00                	jb     249c <_license+0x107>
    249c:	10 ff                	adc    %bh,%bh
    249e:	ff                   	(bad)
    249f:	ff                   	(bad)
    24a0:	ff 0f                	decl   (%rdi)
    24a2:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    24a8:	a8 b9                	test   $0xb9,%al
    24aa:	80 80 00 00 01 14 04 	addb   $0x4,0x14010000(%rax)
    24b1:	d5                   	(bad)
    24b2:	24 f2                	and    $0xf2,%al
    24b4:	24 01                	and    $0x1,%al
    24b6:	51                   	push   %rcx
    24b7:	04 f2                	add    $0xf2,%al
    24b9:	24 95                	and    $0x95,%al
    24bb:	25 01 52 00 01       	and    $0x1005201,%eax
    24c0:	14 04                	adc    $0x4,%al
    24c2:	d5                   	(bad)
    24c3:	24 db                	and    $0xdb,%al
    24c5:	24 02                	and    $0x2,%al
    24c7:	30 9f 00 01 14 04    	xor    %bl,0x4140100(%rdi)
    24cd:	fb                   	sti
    24ce:	24 81                	and    $0x81,%al
    24d0:	25 02 30 9f 00       	and    $0x9f3002,%eax
    24d5:	01 14 04             	add    %edx,(%rsp,%rax,1)
    24d8:	a2 25 c5 25 03 77 10 	movabs %al,0x49f10770325c525
    24df:	9f 04 
    24e1:	95                   	xchg   %eax,%ebp
    24e2:	41 ea                	rex.B (bad)
    24e4:	41 03 77 10          	add    0x10(%r15),%esi
    24e8:	9f                   	lahf
    24e9:	04 91                	add    $0x91,%al
    24eb:	42 cd 42             	rex.X int $0x42
    24ee:	03 77 10             	add    0x10(%rdi),%esi
    24f1:	9f                   	lahf
    24f2:	00 01                	add    %al,(%rcx)
    24f4:	14 04                	adc    $0x4,%al
    24f6:	a2 25 c5 25 01 53 04 	movabs %al,0x419504530125c525
    24fd:	95 41 
    24ff:	ea                   	(bad)
    2500:	41 01 53 04          	add    %edx,0x4(%r11)
    2504:	91                   	xchg   %eax,%ecx
    2505:	42 cd 42             	rex.X int $0x42
    2508:	01 53 00             	add    %edx,0x0(%rbx)
    250b:	01 14 04             	add    %edx,(%rsp,%rax,1)
    250e:	b0 25                	mov    $0x25,%al
    2510:	c5 25 01             	(bad)
    2513:	50                   	push   %rax
    2514:	04 da                	add    $0xda,%al
    2516:	41 ea                	rex.B (bad)
    2518:	41 01 50 00          	add    %edx,0x0(%r8)
    251c:	01 14 04             	add    %edx,(%rsp,%rax,1)
    251f:	dc 41 91             	faddl  -0x6f(%rcx)
    2522:	42 03 11             	rex.X add (%rcx),%edx
    2525:	01 9f 00 01 14 04    	add    %ebx,0x4140100(%rdi)
    252b:	fe                   	(bad)
    252c:	25 c2 26 03 77       	and    $0x770326c2,%eax
    2531:	10 9f 04 c7 26 f1    	adc    %bl,-0xed938fc(%rdi)
    2537:	26 03 77 10          	es add 0x10(%rdi),%esi
    253b:	9f                   	lahf
    253c:	00 01                	add    %al,(%rcx)
    253e:	14 04                	adc    $0x4,%al
    2540:	fe                   	(bad)
    2541:	25 c2 26 03 77       	and    $0x770326c2,%eax
    2546:	f8                   	clc
    2547:	00 04 c7             	add    %al,(%rdi,%rax,8)
    254a:	26 f1                	es int1
    254c:	26 03 77 f8          	es add -0x8(%rdi),%esi
    2550:	00 00                	add    %al,(%rax)
    2552:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2555:	fe                   	(bad)
    2556:	25 c2 26 02 30       	and    $0x300226c2,%eax
    255b:	9f                   	lahf
    255c:	04 c7                	add    $0xc7,%al
    255e:	26 f1                	es int1
    2560:	26 02 30             	es add (%rax),%dh
    2563:	9f                   	lahf
    2564:	00 01                	add    %al,(%rcx)
    2566:	14 04                	adc    $0x4,%al
    2568:	8f                   	(bad)
    2569:	26 9e                	es sahf
    256b:	26 01 50 04          	es add %edx,0x4(%rax)
    256f:	9e                   	sahf
    2570:	26 bd 26 01 5f 04    	es mov $0x45f0126,%ebp
    2576:	c7                   	(bad)
    2577:	26 f1                	es int1
    2579:	26 01 5f 00          	es add %ebx,0x0(%rdi)
    257d:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2580:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    2581:	26 bd 26 01 50 04    	es mov $0x4500126,%ebp
    2587:	c7                   	(bad)
    2588:	26 cb                	es lret
    258a:	26 01 50 00          	es add %edx,0x0(%rax)
    258e:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2591:	ce                   	(bad)
    2592:	26 df 26             	es fbld (%rsi)
    2595:	01 50 00             	add    %edx,0x0(%rax)
    2598:	01 14 04             	add    %edx,(%rsp,%rax,1)
    259b:	ce                   	(bad)
    259c:	26 df 26             	es fbld (%rsi)
    259f:	01 50 00             	add    %edx,0x0(%rax)
    25a2:	01 14 04             	add    %edx,(%rsp,%rax,1)
    25a5:	f7 26                	mull   (%rsi)
    25a7:	b1 27                	mov    $0x27,%cl
    25a9:	01 50 04             	add    %edx,0x4(%rax)
    25ac:	b1 27                	mov    $0x27,%cl
    25ae:	d1 28                	shrl   (%rax)
    25b0:	01 53 00             	add    %edx,0x0(%rbx)
    25b3:	01 14 04             	add    %edx,(%rsp,%rax,1)
    25b6:	8c 27                	mov    %fs,(%rdi)
    25b8:	99                   	cltd
    25b9:	27                   	(bad)
    25ba:	02 30                	add    (%rax),%dh
    25bc:	9f                   	lahf
    25bd:	04 99                	add    $0x99,%al
    25bf:	27                   	(bad)
    25c0:	a2 27 01 5e 00 01 14 	movabs %al,0xa2041401005e0127
    25c7:	04 a2 
    25c9:	27                   	(bad)
    25ca:	ee                   	out    %al,(%dx)
    25cb:	27                   	(bad)
    25cc:	01 5e 00             	add    %ebx,0x0(%rsi)
    25cf:	01 14 04             	add    %edx,(%rsp,%rax,1)
    25d2:	ee                   	out    %al,(%dx)
    25d3:	27                   	(bad)
    25d4:	89 28                	mov    %ebp,(%rax)
    25d6:	02 30                	add    (%rax),%dh
    25d8:	9f                   	lahf
    25d9:	04 89                	add    $0x89,%al
    25db:	28 91 28 01 55 00    	sub    %dl,0x550128(%rcx)
    25e1:	01 14 04             	add    %edx,(%rsp,%rax,1)
    25e4:	f8                   	clc
    25e5:	27                   	(bad)
    25e6:	83 28 01             	subl   $0x1,(%rax)
    25e9:	55                   	push   %rbp
    25ea:	00 01                	add    %al,(%rcx)
    25ec:	14 04                	adc    $0x4,%al
    25ee:	89 28                	mov    %ebp,(%rax)
    25f0:	9c                   	pushf
    25f1:	28 01                	sub    %al,(%rcx)
    25f3:	55                   	push   %rbp
    25f4:	00 01                	add    %al,(%rcx)
    25f6:	14 04                	adc    $0x4,%al
    25f8:	96                   	xchg   %eax,%esi
    25f9:	28 9c 28 01 54 00 01 	sub    %bl,0x1005401(%rax,%rbp,1)
    2600:	14 04                	adc    $0x4,%al
    2602:	96                   	xchg   %eax,%esi
    2603:	28 9c 28 01 55 00 01 	sub    %bl,0x1005501(%rax,%rbp,1)
    260a:	14 04                	adc    $0x4,%al
    260c:	a2 28 b4 28 01 52 00 	movabs %al,0x140100520128b428
    2613:	01 14 
    2615:	04 aa                	add    $0xaa,%al
    2617:	28 b7 28 02 30 9f    	sub    %dh,-0x60cffdd8(%rdi)
    261d:	04 b7                	add    $0xb7,%al
    261f:	28 c0                	sub    %al,%al
    2621:	28 01                	sub    %al,(%rcx)
    2623:	52                   	push   %rdx
    2624:	00 01                	add    %al,(%rcx)
    2626:	14 04                	adc    $0x4,%al
    2628:	c0 28 d1             	shrb   $0xd1,(%rax)
    262b:	28 01                	sub    %al,(%rcx)
    262d:	52                   	push   %rdx
    262e:	00 01                	add    %al,(%rcx)
    2630:	14 04                	adc    $0x4,%al
    2632:	da 28                	fisubrl (%rax)
    2634:	f4                   	hlt
    2635:	28 02                	sub    %al,(%rdx)
    2637:	30 9f 04 f4 28 fd    	xor    %bl,-0x2d70bfc(%rdi)
    263d:	28 01                	sub    %al,(%rcx)
    263f:	52                   	push   %rdx
    2640:	04 9d                	add    $0x9d,%al
    2642:	30 ae 30 02 30 9f    	xor    %ch,-0x60cffdd0(%rsi)
    2648:	04 e9                	add    $0xe9,%al
    264a:	42 fa                	rex.X cli
    264c:	42 02 30             	rex.X add (%rax),%sil
    264f:	9f                   	lahf
    2650:	00 01                	add    %al,(%rcx)
    2652:	14 04                	adc    $0x4,%al
    2654:	da 28                	fisubrl (%rax)
    2656:	86 29                	xchg   %ch,(%rcx)
    2658:	02 36                	add    (%rsi),%dh
    265a:	9f                   	lahf
    265b:	04 9d                	add    $0x9d,%al
    265d:	30 ae 30 02 36 9f    	xor    %ch,-0x60c9fdd0(%rsi)
    2663:	04 e9                	add    $0xe9,%al
    2665:	42 fa                	rex.X cli
    2667:	42 02 36             	rex.X add (%rsi),%sil
    266a:	9f                   	lahf
    266b:	00 01                	add    %al,(%rcx)
    266d:	14 04                	adc    $0x4,%al
    266f:	da 28                	fisubrl (%rax)
    2671:	86 29                	xchg   %ch,(%rcx)
    2673:	04 10                	add    $0x10,%al
    2675:	80 08 9f             	orb    $0x9f,(%rax)
    2678:	04 9d                	add    $0x9d,%al
    267a:	30 ae 30 04 10 80    	xor    %ch,-0x7feffbd0(%rsi)
    2680:	08 9f 04 e9 42 fa    	or     %bl,-0x5bd16fc(%rdi)
    2686:	42 04 10             	rex.X add $0x10,%al
    2689:	80 08 9f             	orb    $0x9f,(%rax)
    268c:	00 01                	add    %al,(%rcx)
    268e:	14 04                	adc    $0x4,%al
    2690:	da 28                	fisubrl (%rax)
    2692:	86 29                	xchg   %ch,(%rcx)
    2694:	02 38                	add    (%rax),%bh
    2696:	9f                   	lahf
    2697:	04 9d                	add    $0x9d,%al
    2699:	30 ae 30 02 38 9f    	xor    %ch,-0x60c7fdd0(%rsi)
    269f:	04 e9                	add    $0xe9,%al
    26a1:	42 fa                	rex.X cli
    26a3:	42 02 38             	rex.X add (%rax),%dil
    26a6:	9f                   	lahf
    26a7:	00 01                	add    %al,(%rcx)
    26a9:	14 04                	adc    $0x4,%al
    26ab:	8e 29                	mov    (%rcx),%gs
    26ad:	e2 29                	loop   26d8 <_license+0x343>
    26af:	01 5c 04 f6          	add    %ebx,-0xa(%rsp,%rax,1)
    26b3:	30 fc                	xor    %bh,%ah
    26b5:	31 01                	xor    %eax,(%rcx)
    26b7:	5c                   	pop    %rsp
    26b8:	00 01                	add    %al,(%rcx)
    26ba:	14 04                	adc    $0x4,%al
    26bc:	96                   	xchg   %eax,%esi
    26bd:	29 b5 29 02 30 9f    	sub    %esi,-0x60cffdd7(%rbp)
    26c3:	04 b5                	add    $0xb5,%al
    26c5:	29 be 29 01 52 00    	sub    %edi,0x520129(%rsi)
    26cb:	01 14 04             	add    %edx,(%rsp,%rax,1)
    26ce:	a1 29 c7 29 04 10 80 	movabs 0x9f2080100429c729,%eax
    26d5:	20 9f 
    26d7:	00 01                	add    %al,(%rcx)
    26d9:	14 04                	adc    $0x4,%al
    26db:	a1 29 c7 29 02 38 9f 	movabs 0x1009f380229c729,%eax
    26e2:	00 01 
    26e4:	14 04                	adc    $0x4,%al
    26e6:	ba 2a b7 2b 0e       	mov    $0xe2bb72a,%edx
    26eb:	73 00                	jae    26ed <_license+0x358>
    26ed:	10 ff                	adc    %bh,%bh
    26ef:	ff                   	(bad)
    26f0:	ff                   	(bad)
    26f1:	ff 0f                	decl   (%rdi)
    26f3:	1a 10                	sbb    (%rax),%dl
    26f5:	ac                   	lods   %ds:(%rsi),%al
    26f6:	21 21                	and    %esp,(%rcx)
    26f8:	9f                   	lahf
    26f9:	00 01                	add    %al,(%rcx)
    26fb:	14 04                	adc    $0x4,%al
    26fd:	e7 29                	out    %eax,$0x29
    26ff:	c5 2b 02             	(bad)
    2702:	30 9f 00 01 14 04    	xor    %bl,0x4140100(%rdi)
    2708:	8a 2a                	mov    (%rdx),%ch
    270a:	c5 2b 01             	(bad)
    270d:	52                   	push   %rdx
    270e:	00 01                	add    %al,(%rcx)
    2710:	14 04                	adc    $0x4,%al
    2712:	8e 2a                	mov    (%rdx),%gs
    2714:	c0 2a 01             	shrb   $0x1,(%rdx)
    2717:	51                   	push   %rcx
    2718:	00 01                	add    %al,(%rcx)
    271a:	14 04                	adc    $0x4,%al
    271c:	8e 2a                	mov    (%rdx),%gs
    271e:	c5 2b 01             	(bad)
    2721:	52                   	push   %rdx
    2722:	00 01                	add    %al,(%rcx)
    2724:	14 04                	adc    $0x4,%al
    2726:	92                   	xchg   %eax,%edx
    2727:	2a a4 2a 01 50 00 01 	sub    0x1005001(%rdx,%rbp,1),%ah
    272e:	14 04                	adc    $0x4,%al
    2730:	92                   	xchg   %eax,%edx
    2731:	2a c5                	sub    %ch,%al
    2733:	2b 03                	sub    (%rbx),%eax
    2735:	72 14                	jb     274b <_license+0x3b6>
    2737:	9f                   	lahf
    2738:	00 01                	add    %al,(%rcx)
    273a:	14 04                	adc    $0x4,%al
    273c:	fc                   	cld
    273d:	2a b7 2b 0e 73 00    	sub    0x730e2b(%rdi),%dh
    2743:	10 ff                	adc    %bh,%bh
    2745:	ff                   	(bad)
    2746:	ff                   	(bad)
    2747:	ff 0f                	decl   (%rdi)
    2749:	1a 10                	sbb    (%rax),%dl
    274b:	ac                   	lods   %ds:(%rsi),%al
    274c:	21 21                	and    %esp,(%rcx)
    274e:	9f                   	lahf
    274f:	00 01                	add    %al,(%rcx)
    2751:	14 04                	adc    $0x4,%al
    2753:	fc                   	cld
    2754:	2a ad 2b 01 54 00    	sub    0x54012b(%rbp),%ch
    275a:	01 14 04             	add    %edx,(%rsp,%rax,1)
    275d:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    275e:	2b a9 2b 03 11 00    	sub    0x11032b(%rcx),%ebp
    2764:	9f                   	lahf
    2765:	04 a9                	add    $0xa9,%al
    2767:	2b ad 2b 03 11 01    	sub    0x111032b(%rbp),%ebp
    276d:	9f                   	lahf
    276e:	04 ad                	add    $0xad,%al
    2770:	2b b4 2b 03 11 04 9f 	sub    -0x60fbeefd(%rbx,%rbp,1),%esi
    2777:	04 b4                	add    $0xb4,%al
    2779:	2b b7 2b 03 11 07    	sub    0x711032b(%rdi),%esi
    277f:	9f                   	lahf
    2780:	04 b7                	add    $0xb7,%al
    2782:	2b ba 2b 03 11 06    	sub    0x611032b(%rdx),%edi
    2788:	9f                   	lahf
    2789:	04 ba                	add    $0xba,%al
    278b:	2b c5                	sub    %ebp,%eax
    278d:	2b 03                	sub    (%rbx),%eax
    278f:	11 08                	adc    %ecx,(%rax)
    2791:	9f                   	lahf
    2792:	00 01                	add    %al,(%rcx)
    2794:	14 04                	adc    $0x4,%al
    2796:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2797:	2b a9 2b 03 72 10    	sub    0x1072032b(%rcx),%ebp
    279d:	9f                   	lahf
    279e:	04 a9                	add    $0xa9,%al
    27a0:	2b ad 2b 03 72 12    	sub    0x1272032b(%rbp),%ebp
    27a6:	9f                   	lahf
    27a7:	04 ad                	add    $0xad,%al
    27a9:	2b b4 2b 03 72 18 9f 	sub    -0x60e78dfd(%rbx,%rbp,1),%esi
    27b0:	04 b4                	add    $0xb4,%al
    27b2:	2b b7 2b 03 72 1e    	sub    0x1e72032b(%rdi),%esi
    27b8:	9f                   	lahf
    27b9:	04 b7                	add    $0xb7,%al
    27bb:	2b ba 2b 03 72 1c    	sub    0x1c72032b(%rdx),%edi
    27c1:	9f                   	lahf
    27c2:	04 ba                	add    $0xba,%al
    27c4:	2b c5                	sub    %ebp,%eax
    27c6:	2b 03                	sub    (%rbx),%eax
    27c8:	72 20                	jb     27ea <_license+0x455>
    27ca:	9f                   	lahf
    27cb:	00 01                	add    %al,(%rcx)
    27cd:	14 04                	adc    $0x4,%al
    27cf:	cc                   	int3
    27d0:	2b d9                	sub    %ecx,%ebx
    27d2:	2b 02                	sub    (%rdx),%eax
    27d4:	30 9f 04 d9 2b e2    	xor    %bl,-0x1dd426fc(%rdi)
    27da:	2b 01                	sub    (%rcx),%eax
    27dc:	52                   	push   %rdx
    27dd:	00 01                	add    %al,(%rcx)
    27df:	14 04                	adc    $0x4,%al
    27e1:	e2 2b                	loop   280e <_license+0x479>
    27e3:	f9                   	stc
    27e4:	2b 01                	sub    (%rcx),%eax
    27e6:	52                   	push   %rdx
    27e7:	00 01                	add    %al,(%rcx)
    27e9:	14 04                	adc    $0x4,%al
    27eb:	f9                   	stc
    27ec:	2b e7                	sub    %edi,%esp
    27ee:	2e 03 77 10          	cs add 0x10(%rdi),%esi
    27f2:	9f                   	lahf
    27f3:	04 ae                	add    $0xae,%al
    27f5:	30 f6                	xor    %dh,%dh
    27f7:	30 03                	xor    %al,(%rbx)
    27f9:	77 10                	ja     280b <_license+0x476>
    27fb:	9f                   	lahf
    27fc:	00 01                	add    %al,(%rcx)
    27fe:	14 04                	adc    $0x4,%al
    2800:	f9                   	stc
    2801:	2b e7                	sub    %edi,%esp
    2803:	2e 02 31             	cs add (%rcx),%dh
    2806:	9f                   	lahf
    2807:	04 ae                	add    $0xae,%al
    2809:	30 f6                	xor    %dh,%dh
    280b:	30 02                	xor    %al,(%rdx)
    280d:	31 9f 00 01 14 04    	xor    %ebx,0x4140100(%rdi)
    2813:	f9                   	stc
    2814:	2b e7                	sub    %edi,%esp
    2816:	2e 03 77 f8          	cs add -0x8(%rdi),%esi
    281a:	00 04 ae             	add    %al,(%rsi,%rbp,4)
    281d:	30 f6                	xor    %dh,%dh
    281f:	30 03                	xor    %al,(%rbx)
    2821:	77 f8                	ja     281b <_license+0x486>
    2823:	00 00                	add    %al,(%rax)
    2825:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2828:	99                   	cltd
    2829:	2c f2                	sub    $0xf2,%al
    282b:	2c 02                	sub    $0x2,%al
    282d:	30 9f 04 f2 2c c1    	xor    %bl,-0x3ed30dfc(%rdi)
    2833:	2e 11 73 00          	cs adc %esi,0x0(%rbx)
    2837:	10 ff                	adc    %bh,%bh
    2839:	01 1a                	add    %ebx,(%rdx)
    283b:	a8 be                	test   $0xbe,%al
    283d:	80 80 00 a8 b9 80 80 	addb   $0x80,-0x7f465800(%rax)
    2844:	00 9f 04 ae 30 f6    	add    %bl,-0x9cf51fc(%rdi)
    284a:	30 11                	xor    %dl,(%rcx)
    284c:	73 00                	jae    284e <_license+0x4b9>
    284e:	10 ff                	adc    %bh,%bh
    2850:	01 1a                	add    %ebx,(%rdx)
    2852:	a8 be                	test   $0xbe,%al
    2854:	80 80 00 a8 b9 80 80 	addb   $0x80,-0x7f465800(%rax)
    285b:	00 9f 00 01 14 04    	add    %bl,0x4140100(%rdi)
    2861:	99                   	cltd
    2862:	2c e7                	sub    $0xe7,%al
    2864:	2e 02 30             	cs add (%rax),%dh
    2867:	9f                   	lahf
    2868:	04 ae                	add    $0xae,%al
    286a:	30 f6                	xor    %dh,%dh
    286c:	30 02                	xor    %al,(%rdx)
    286e:	30 9f 00 01 14 04    	xor    %bl,0x4140100(%rdi)
    2874:	99                   	cltd
    2875:	2c ca                	sub    $0xca,%al
    2877:	2e 02 30             	cs add (%rax),%dh
    287a:	9f                   	lahf
    287b:	04 ca                	add    $0xca,%al
    287d:	2e cf                	cs iret
    287f:	2e 01 5f 04          	cs add %ebx,0x4(%rdi)
    2883:	ae                   	scas   %es:(%rdi),%al
    2884:	30 f6                	xor    %dh,%dh
    2886:	30 02                	xor    %al,(%rdx)
    2888:	30 9f 00 01 14 04    	xor    %bl,0x4140100(%rdi)
    288e:	99                   	cltd
    288f:	2c 9c                	sub    $0x9c,%al
    2891:	2c 02                	sub    $0x2,%al
    2893:	30 9f 04 9c 2c ac    	xor    %bl,-0x53d363fc(%rdi)
    2899:	2c 01                	sub    $0x1,%al
    289b:	5d                   	pop    %rbp
    289c:	00 01                	add    %al,(%rcx)
    289e:	14 04                	adc    $0x4,%al
    28a0:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    28a1:	2c ed                	sub    $0xed,%al
    28a3:	2c 01                	sub    $0x1,%al
    28a5:	5d                   	pop    %rbp
    28a6:	00 01                	add    %al,(%rcx)
    28a8:	14 04                	adc    $0x4,%al
    28aa:	f2 2c 8c             	repnz sub $0x8c,%al
    28ad:	2e 02 31             	cs add (%rcx),%dh
    28b0:	9f                   	lahf
    28b1:	04 ae                	add    $0xae,%al
    28b3:	30 d2                	xor    %dl,%dl
    28b5:	30 02                	xor    %al,(%rdx)
    28b7:	31 9f 00 01 14 04    	xor    %ebx,0x4140100(%rdi)
    28bd:	d1 2d da 2d 01 50    	shrl   0x50012dda(%rip)        # 5001569d <_license+0x50013308>
    28c3:	00 01                	add    %al,(%rcx)
    28c5:	14 04                	adc    $0x4,%al
    28c7:	df 2d f8 2d 01 50    	fildll 0x50012df8(%rip)        # 500156c5 <_license+0x50013330>
    28cd:	04 83                	add    $0x83,%al
    28cf:	2e da 2e             	cs fisubrl (%rsi)
    28d2:	01 50 04             	add    %edx,0x4(%rax)
    28d5:	d2 30                	shlb   %cl,(%rax)
    28d7:	dc 30                	fdivl  (%rax)
    28d9:	01 50 00             	add    %edx,0x0(%rax)
    28dc:	01 14 04             	add    %edx,(%rsp,%rax,1)
    28df:	df 2d e4 2d 02 30    	fildll 0x30022de4(%rip)        # 300256c9 <_license+0x30023334>
    28e5:	9f                   	lahf
    28e6:	00 01                	add    %al,(%rcx)
    28e8:	14 04                	adc    $0x4,%al
    28ea:	90                   	nop
    28eb:	2e 95                	cs xchg %eax,%ebp
    28ed:	2e 02 30             	cs add (%rax),%dh
    28f0:	9f                   	lahf
    28f1:	00 01                	add    %al,(%rcx)
    28f3:	14 04                	adc    $0x4,%al
    28f5:	f1                   	int1
    28f6:	2e f5                	cs cmc
    28f8:	2e 01 50 00          	cs add %edx,0x0(%rax)
    28fc:	01 14 04             	add    %edx,(%rsp,%rax,1)
    28ff:	b2 2f                	mov    $0x2f,%dl
    2901:	e6 2f                	out    %al,$0x2f
    2903:	11 70 00             	adc    %esi,0x0(%rax)
    2906:	10 ff                	adc    %bh,%bh
    2908:	01 1a                	add    %ebx,(%rdx)
    290a:	a8 be                	test   $0xbe,%al
    290c:	80 80 00 a8 b9 80 80 	addb   $0x80,-0x7f465800(%rax)
    2913:	00 9f 00 01 14 04    	add    %bl,0x4140100(%rdi)
    2919:	c4                   	(bad)
    291a:	2f                   	(bad)
    291b:	d5                   	(bad)
    291c:	2f                   	(bad)
    291d:	2e 71 00             	jno,pn 2920 <_license+0x58b>
    2920:	10 ff                	adc    %bh,%bh
    2922:	ff 03                	incl   (%rbx)
    2924:	1a a8 c3 80 80 00    	sbb    0x8080c3(%rax),%ch
    292a:	a8 b4                	test   $0xb4,%al
    292c:	80 80 00 74 00 10 ff 	addb   $0xff,0x10007400(%rax)
    2933:	ff 03                	incl   (%rbx)
    2935:	1a a8 c3 80 80 00    	sbb    0x8080c3(%rax),%ch
    293b:	a8 b4                	test   $0xb4,%al
    293d:	80 80 00 29 a8 be 80 	addb   $0x80,-0x4157d700(%rax)
    2944:	80 00 a8             	addb   $0xa8,(%rax)
    2947:	b9 80 80 00 9f       	mov    $0x9f008080,%ecx
    294c:	00 01                	add    %al,(%rcx)
    294e:	14 04                	adc    $0x4,%al
    2950:	ec                   	in     (%dx),%al
    2951:	2f                   	(bad)
    2952:	80 30 02             	xorb   $0x2,(%rax)
    2955:	30 9f 04 80 30 89    	xor    %bl,-0x76cf7ffc(%rdi)
    295b:	30 01                	xor    %al,(%rcx)
    295d:	50                   	push   %rax
    295e:	00 01                	add    %al,(%rcx)
    2960:	14 04                	adc    $0x4,%al
    2962:	89 30                	mov    %esi,(%rax)
    2964:	94                   	xchg   %eax,%esp
    2965:	30 01                	xor    %al,(%rcx)
    2967:	50                   	push   %rax
    2968:	00 01                	add    %al,(%rcx)
    296a:	14 04                	adc    $0x4,%al
    296c:	ae                   	scas   %es:(%rdi),%al
    296d:	30 bb 30 02 30 9f    	xor    %bh,-0x60cffdd0(%rbx)
    2973:	04 bb                	add    $0xbb,%al
    2975:	30 c4                	xor    %al,%ah
    2977:	30 01                	xor    %al,(%rcx)
    2979:	50                   	push   %rax
    297a:	00 01                	add    %al,(%rcx)
    297c:	14 04                	adc    $0x4,%al
    297e:	c4                   	(bad)
    297f:	30 d2                	xor    %dl,%dl
    2981:	30 01                	xor    %al,(%rcx)
    2983:	50                   	push   %rax
    2984:	00 01                	add    %al,(%rcx)
    2986:	14 04                	adc    $0x4,%al
    2988:	d2 30                	shlb   %cl,(%rax)
    298a:	df 30                	fbstp  (%rax)
    298c:	02 30                	add    (%rax),%dh
    298e:	9f                   	lahf
    298f:	04 df                	add    $0xdf,%al
    2991:	30 e8                	xor    %ch,%al
    2993:	30 01                	xor    %al,(%rcx)
    2995:	50                   	push   %rax
    2996:	00 01                	add    %al,(%rcx)
    2998:	14 04                	adc    $0x4,%al
    299a:	e8 30 f6 30 01       	call   1311fcf <_license+0x130fc3a>
    299f:	50                   	push   %rax
    29a0:	00 01                	add    %al,(%rcx)
    29a2:	14 04                	adc    $0x4,%al
    29a4:	f6 30                	divb   (%rax)
    29a6:	fc                   	cld
    29a7:	31 12                	xor    %edx,(%rdx)
    29a9:	7c 00                	jl     29ab <_license+0x616>
    29ab:	10 ff                	adc    %bh,%bh
    29ad:	ff 03                	incl   (%rbx)
    29af:	1a a8 c3 80 80 00    	sbb    0x8080c3(%rax),%ch
    29b5:	a8 b4                	test   $0xb4,%al
    29b7:	80 80 00 9f 00 01 14 	addb   $0x14,0x1009f00(%rax)
    29be:	04 99                	add    $0x99,%al
    29c0:	31 b0 32 01 52 00    	xor    %esi,0x520132(%rax)
    29c6:	01 14 04             	add    %edx,(%rsp,%rax,1)
    29c9:	9d                   	popf
    29ca:	31 81 32 01 51 00    	xor    %eax,0x510132(%rcx)
    29d0:	01 14 04             	add    %edx,(%rsp,%rax,1)
    29d3:	9d                   	popf
    29d4:	31 b0 32 01 52 00    	xor    %esi,0x520132(%rax)
    29da:	01 14 04             	add    %edx,(%rsp,%rax,1)
    29dd:	a1 31 b3 31 01 50 00 	movabs 0x140100500131b331,%eax
    29e4:	01 14 
    29e6:	04 a1                	add    $0xa1,%al
    29e8:	31 b0 32 03 72 28    	xor    %esi,0x28720332(%rax)
    29ee:	9f                   	lahf
    29ef:	00 01                	add    %al,(%rcx)
    29f1:	14 04                	adc    $0x4,%al
    29f3:	ef                   	out    %eax,(%dx)
    29f4:	31 b0 32 03 10 29    	xor    %esi,0x29100332(%rax)
    29fa:	9f                   	lahf
    29fb:	00 01                	add    %al,(%rcx)
    29fd:	14 04                	adc    $0x4,%al
    29ff:	f4                   	hlt
    2a00:	31 f8                	xor    %edi,%eax
    2a02:	31 0c 31             	xor    %ecx,(%rcx,%rsi,1)
    2a05:	9f                   	lahf
    2a06:	93                   	xchg   %eax,%ebx
    2a07:	04 30                	add    $0x30,%al
    2a09:	9f                   	lahf
    2a0a:	93                   	xchg   %eax,%ebx
    2a0b:	04 30                	add    $0x30,%al
    2a0d:	9f                   	lahf
    2a0e:	93                   	xchg   %eax,%ebx
    2a0f:	04 04                	add    $0x4,%al
    2a11:	f8                   	clc
    2a12:	31 b0 32 0f 31 9f    	xor    %esi,-0x60cef0ce(%rax)
    2a18:	93                   	xchg   %eax,%ebx
    2a19:	04 30                	add    $0x30,%al
    2a1b:	9f                   	lahf
    2a1c:	93                   	xchg   %eax,%ebx
    2a1d:	04 30                	add    $0x30,%al
    2a1f:	9f                   	lahf
    2a20:	93                   	xchg   %eax,%ebx
    2a21:	04 50                	add    $0x50,%al
    2a23:	93                   	xchg   %eax,%ebx
    2a24:	04 00                	add    $0x0,%al
    2a26:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2a29:	fc                   	cld
    2a2a:	31 a6 32 01 5c 00    	xor    %esp,0x5c0132(%rsi)
    2a30:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2a33:	fc                   	cld
    2a34:	31 a6 32 01 5c 00    	xor    %esp,0x5c0132(%rsi)
    2a3a:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2a3d:	81 32 98 32 01 51    	xorl   $0x51013298,(%rdx)
    2a43:	00 01                	add    %al,(%rcx)
    2a45:	14 04                	adc    $0x4,%al
    2a47:	b5 32                	mov    $0x32,%ch
    2a49:	bb 32 03 7f 08       	mov    $0x87f0332,%ebx
    2a4e:	9f                   	lahf
    2a4f:	00 01                	add    %al,(%rcx)
    2a51:	14 04                	adc    $0x4,%al
    2a53:	91                   	xchg   %eax,%ecx
    2a54:	33 a5 33 13 70 00    	xor    0x701333(%rbp),%esp
    2a5a:	10 ff                	adc    %bh,%bh
    2a5c:	ff                   	(bad)
    2a5d:	ff                   	(bad)
    2a5e:	ff 0f                	decl   (%rdi)
    2a60:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2a66:	a8 b9                	test   $0xb9,%al
    2a68:	80 80 00 04 a7 33 ab 	addb   $0xab,0x33a70400(%rax)
    2a6f:	33 13                	xor    (%rbx),%edx
    2a71:	70 00                	jo     2a73 <_license+0x6de>
    2a73:	10 ff                	adc    %bh,%bh
    2a75:	ff                   	(bad)
    2a76:	ff                   	(bad)
    2a77:	ff 0f                	decl   (%rdi)
    2a79:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2a7f:	a8 b9                	test   $0xb9,%al
    2a81:	80 80 00 04 ad 33 b1 	addb   $0xb1,0x33ad0400(%rax)
    2a88:	33 13                	xor    (%rbx),%edx
    2a8a:	70 00                	jo     2a8c <_license+0x6f7>
    2a8c:	10 ff                	adc    %bh,%bh
    2a8e:	ff                   	(bad)
    2a8f:	ff                   	(bad)
    2a90:	ff 0f                	decl   (%rdi)
    2a92:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2a98:	a8 b9                	test   $0xb9,%al
    2a9a:	80 80 00 04 b3 33 b7 	addb   $0xb7,0x33b30400(%rax)
    2aa1:	33 13                	xor    (%rbx),%edx
    2aa3:	70 00                	jo     2aa5 <_license+0x710>
    2aa5:	10 ff                	adc    %bh,%bh
    2aa7:	ff                   	(bad)
    2aa8:	ff                   	(bad)
    2aa9:	ff 0f                	decl   (%rdi)
    2aab:	1a a8 af 80 80 00    	sbb    0x8080af(%rax),%ch
    2ab1:	a8 b9                	test   $0xb9,%al
    2ab3:	80 80 00 00 01 14 04 	addb   $0x4,0x14010000(%rax)
    2aba:	ba 33 d7 33 01       	mov    $0x133d733,%edx
    2abf:	52                   	push   %rdx
    2ac0:	04 d7                	add    $0xd7,%al
    2ac2:	33 eb                	xor    %ebx,%ebp
    2ac4:	33 01                	xor    (%rcx),%eax
    2ac6:	50                   	push   %rax
    2ac7:	00 01                	add    %al,(%rcx)
    2ac9:	14 04                	adc    $0x4,%al
    2acb:	ba 33 c0 33 02       	mov    $0x233c033,%edx
    2ad0:	30 9f 00 01 14 04    	xor    %bl,0x4140100(%rdi)
    2ad6:	e0 33                	loopne 2b0b <_license+0x776>
    2ad8:	e5 33                	in     $0x33,%eax
    2ada:	02 30                	add    (%rax),%dh
    2adc:	9f                   	lahf
    2add:	00 01                	add    %al,(%rcx)
    2adf:	14 04                	adc    $0x4,%al
    2ae1:	fe                   	(bad)
    2ae2:	33 a3 34 03 77 10    	xor    0x10770334(%rbx),%esp
    2ae8:	9f                   	lahf
    2ae9:	04 fa                	add    $0xfa,%al
    2aeb:	42 cf                	rex.X iret
    2aed:	43 03 77 10          	rex.XB add 0x10(%r15),%esi
    2af1:	9f                   	lahf
    2af2:	04 f6                	add    $0xf6,%al
    2af4:	43 b4 44             	rex.XB mov $0x44,%r12b
    2af7:	03 77 10             	add    0x10(%rdi),%esi
    2afa:	9f                   	lahf
    2afb:	00 01                	add    %al,(%rcx)
    2afd:	14 04                	adc    $0x4,%al
    2aff:	fe                   	(bad)
    2b00:	33 a3 34 03 77 c8    	xor    -0x3788fccc(%rbx),%esp
    2b06:	00 04 fa             	add    %al,(%rdx,%rdi,8)
    2b09:	42 cf                	rex.X iret
    2b0b:	43 03 77 c8          	rex.XB add -0x38(%r15),%esi
    2b0f:	00 04 f6             	add    %al,(%rsi,%rsi,8)
    2b12:	43 b4 44             	rex.XB mov $0x44,%r12b
    2b15:	03 77 c8             	add    -0x38(%rdi),%esi
    2b18:	00 00                	add    %al,(%rax)
    2b1a:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2b1d:	8e 34 a3             	mov    (%rbx,%riz,4),%?
    2b20:	34 01                	xor    $0x1,%al
    2b22:	50                   	push   %rax
    2b23:	04 bf                	add    $0xbf,%al
    2b25:	43 cf                	rex.XB iret
    2b27:	43 01 50 00          	rex.XB add %edx,0x0(%r8)
    2b2b:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2b2e:	c1 43 f6 43          	roll   $0x43,-0xa(%rbx)
    2b32:	03 11                	add    (%rcx),%edx
    2b34:	01 9f 00 01 14 04    	add    %ebx,0x4140100(%rdi)
    2b3a:	e0 34                	loopne 2b70 <_license+0x7db>
    2b3c:	9e                   	sahf
    2b3d:	35 03 77 10 9f       	xor    $0x9f107703,%eax
    2b42:	04 a8                	add    $0xa8,%al
    2b44:	35 d2 35 03 77       	xor    $0x770335d2,%eax
    2b49:	10 9f 00 01 14 04    	adc    %bl,0x4140100(%rdi)
    2b4f:	e0 34                	loopne 2b85 <_license+0x7f0>
    2b51:	9e                   	sahf
    2b52:	35 03 77 c8 00       	xor    $0xc87703,%eax
    2b57:	04 a8                	add    $0xa8,%al
    2b59:	35 d2 35 03 77       	xor    $0x770335d2,%eax
    2b5e:	c8 00 00 01          	enter  $0x0,$0x1
    2b62:	14 04                	adc    $0x4,%al
    2b64:	e0 34                	loopne 2b9a <_license+0x805>
    2b66:	9e                   	sahf
    2b67:	35 02 30 9f 04       	xor    $0x49f3002,%eax
    2b6c:	a8 35                	test   $0x35,%al
    2b6e:	d2 35 02 30 9f 00    	shlb   %cl,0x9f3002(%rip)        # 9f5b76 <_license+0x9f37e1>
    2b74:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2b77:	f0 34 ff             	lock xor $0xff,%al
    2b7a:	34 01                	xor    $0x1,%al
    2b7c:	50                   	push   %rax
    2b7d:	04 ff                	add    $0xff,%al
    2b7f:	34 9e                	xor    $0x9e,%al
    2b81:	35 01 5f 04 a8       	xor    $0xa8045f01,%eax
    2b86:	35 d2 35 01 5f       	xor    $0x5f0135d2,%eax
    2b8b:	00 01                	add    %al,(%rcx)
    2b8d:	14 04                	adc    $0x4,%al
    2b8f:	88 35 9e 35 01 50    	mov    %dh,0x5001359e(%rip)        # 50016133 <_license+0x50013d9e>
    2b95:	04 a8                	add    $0xa8,%al
    2b97:	35 ac 35 01 50       	xor    $0x500135ac,%eax
    2b9c:	00 01                	add    %al,(%rcx)
    2b9e:	14 04                	adc    $0x4,%al
    2ba0:	af                   	scas   %es:(%rdi),%eax
    2ba1:	35 c0 35 01 50       	xor    $0x500135c0,%eax
    2ba6:	00 01                	add    %al,(%rcx)
    2ba8:	14 04                	adc    $0x4,%al
    2baa:	af                   	scas   %es:(%rdi),%eax
    2bab:	35 c0 35 01 50       	xor    $0x500135c0,%eax
    2bb0:	00 01                	add    %al,(%rcx)
    2bb2:	14 04                	adc    $0x4,%al
    2bb4:	ec                   	in     (%dx),%al
    2bb5:	35 f9 35 02 30       	xor    $0x300235f9,%eax
    2bba:	9f                   	lahf
    2bbb:	04 f9                	add    $0xf9,%al
    2bbd:	35 82 36 01 53       	xor    $0x53013682,%eax
    2bc2:	00 01                	add    %al,(%rcx)
    2bc4:	14 04                	adc    $0x4,%al
    2bc6:	82                   	(bad)
    2bc7:	36 c2 36 01          	ss ret $0x136
    2bcb:	53                   	push   %rbx
    2bcc:	00 01                	add    %al,(%rcx)
    2bce:	14 04                	adc    $0x4,%al
    2bd0:	c2 36 d7             	ret    $0xd736
    2bd3:	36 02 30             	ss add (%rax),%dh
    2bd6:	9f                   	lahf
    2bd7:	04 d7                	add    $0xd7,%al
    2bd9:	36 dc 36             	ss fdivl (%rsi)
    2bdc:	01 50 00             	add    %edx,0x0(%rax)
    2bdf:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2be2:	cc                   	int3
    2be3:	36 d7                	xlat   %ds:(%rbx)
    2be5:	36 01 55 00          	ss add %edx,0x0(%rbp)
    2be9:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2bec:	d7                   	xlat   %ds:(%rbx)
    2bed:	36 ea                	ss (bad)
    2bef:	36 01 50 00          	ss add %edx,0x0(%rax)
    2bf3:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2bf6:	ea                   	(bad)
    2bf7:	36 f9                	ss stc
    2bf9:	36 01 50 00          	ss add %edx,0x0(%rax)
    2bfd:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2c00:	ef                   	out    %eax,(%dx)
    2c01:	36 fc                	ss cld
    2c03:	36 02 30             	ss add (%rax),%dh
    2c06:	9f                   	lahf
    2c07:	04 fc                	add    $0xfc,%al
    2c09:	36 85 37             	ss test %esi,(%rdi)
    2c0c:	01 50 00             	add    %edx,0x0(%rax)
    2c0f:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2c12:	85 37                	test   %esi,(%rdi)
    2c14:	96                   	xchg   %eax,%esi
    2c15:	37                   	(bad)
    2c16:	01 50 00             	add    %edx,0x0(%rax)
    2c19:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2c1c:	9f                   	lahf
    2c1d:	37                   	(bad)
    2c1e:	be 37 02 30 9f       	mov    $0x9f300237,%esi
    2c23:	04 be                	add    $0xbe,%al
    2c25:	37                   	(bad)
    2c26:	c7                   	(bad)
    2c27:	37                   	(bad)
    2c28:	01 52 00             	add    %edx,0x0(%rdx)
    2c2b:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2c2e:	d9 37                	fnstenv (%rdi)
    2c30:	af                   	scas   %es:(%rdi),%eax
    2c31:	38 01                	cmp    %al,(%rcx)
    2c33:	53                   	push   %rbx
    2c34:	04 cf                	add    $0xcf,%al
    2c36:	3f                   	(bad)
    2c37:	ee                   	out    %al,(%dx)
    2c38:	40 01 53 00          	rex add %edx,0x0(%rbx)
    2c3c:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2c3f:	e0 37                	loopne 2c78 <_license+0x8e3>
    2c41:	ff 37                	push   (%rdi)
    2c43:	02 30                	add    (%rax),%dh
    2c45:	9f                   	lahf
    2c46:	04 ff                	add    $0xff,%al
    2c48:	37                   	(bad)
    2c49:	88 38                	mov    %bh,(%rax)
    2c4b:	01 52 00             	add    %edx,0x0(%rdx)
    2c4e:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2c51:	eb 37                	jmp    2c8a <_license+0x8f5>
    2c53:	91                   	xchg   %eax,%ecx
    2c54:	38 04 10             	cmp    %al,(%rax,%rdx,1)
    2c57:	80 20 9f             	andb   $0x9f,(%rax)
    2c5a:	00 01                	add    %al,(%rcx)
    2c5c:	14 04                	adc    $0x4,%al
    2c5e:	eb 37                	jmp    2c97 <_license+0x902>
    2c60:	91                   	xchg   %eax,%ecx
    2c61:	38 02                	cmp    %al,(%rdx)
    2c63:	38 9f 00 01 14 04    	cmp    %bl,0x4140100(%rdi)
    2c69:	8d 39                	lea    (%rcx),%edi
    2c6b:	88 3a                	mov    %bh,(%rdx)
    2c6d:	0e                   	(bad)
    2c6e:	7e 00                	jle    2c70 <_license+0x8db>
    2c70:	10 ff                	adc    %bh,%bh
    2c72:	ff                   	(bad)
    2c73:	ff                   	(bad)
    2c74:	ff 0f                	decl   (%rdi)
    2c76:	1a 10                	sbb    (%rax),%dl
    2c78:	ac                   	lods   %ds:(%rsi),%al
    2c79:	21 21                	and    %esp,(%rcx)
    2c7b:	9f                   	lahf
    2c7c:	00 01                	add    %al,(%rcx)
    2c7e:	14 04                	adc    $0x4,%al
    2c80:	b5 38                	mov    $0x38,%ch
    2c82:	91                   	xchg   %eax,%ecx
    2c83:	3a 02                	cmp    (%rdx),%al
    2c85:	30 9f 00 01 14 04    	xor    %bl,0x4140100(%rdi)
    2c8b:	d8 38                	fdivrs (%rax)
    2c8d:	91                   	xchg   %eax,%ecx
    2c8e:	3a 01                	cmp    (%rcx),%al
    2c90:	52                   	push   %rdx
    2c91:	00 01                	add    %al,(%rcx)
    2c93:	14 04                	adc    $0x4,%al
    2c95:	dc 38                	fdivrl (%rax)
    2c97:	94                   	xchg   %eax,%esp
    2c98:	39 01                	cmp    %eax,(%rcx)
    2c9a:	51                   	push   %rcx
    2c9b:	00 01                	add    %al,(%rcx)
    2c9d:	14 04                	adc    $0x4,%al
    2c9f:	dc 38                	fdivrl (%rax)
    2ca1:	91                   	xchg   %eax,%ecx
    2ca2:	3a 01                	cmp    (%rcx),%al
    2ca4:	52                   	push   %rdx
    2ca5:	00 01                	add    %al,(%rcx)
    2ca7:	14 04                	adc    $0x4,%al
    2ca9:	e0 38                	loopne 2ce3 <_license+0x94e>
    2cab:	f2 38 01             	repnz cmp %al,(%rcx)
    2cae:	50                   	push   %rax
    2caf:	00 01                	add    %al,(%rcx)
    2cb1:	14 04                	adc    $0x4,%al
    2cb3:	e0 38                	loopne 2ced <_license+0x958>
    2cb5:	91                   	xchg   %eax,%ecx
    2cb6:	3a 03                	cmp    (%rbx),%al
    2cb8:	72 14                	jb     2cce <_license+0x939>
    2cba:	9f                   	lahf
    2cbb:	00 01                	add    %al,(%rcx)
    2cbd:	14 04                	adc    $0x4,%al
    2cbf:	d0 39                	sarb   (%rcx)
    2cc1:	88 3a                	mov    %bh,(%rdx)
    2cc3:	0e                   	(bad)
    2cc4:	7e 00                	jle    2cc6 <_license+0x931>
    2cc6:	10 ff                	adc    %bh,%bh
    2cc8:	ff                   	(bad)
    2cc9:	ff                   	(bad)
    2cca:	ff 0f                	decl   (%rdi)
    2ccc:	1a 10                	sbb    (%rax),%dl
    2cce:	ac                   	lods   %ds:(%rsi),%al
    2ccf:	21 21                	and    %esp,(%rcx)
    2cd1:	9f                   	lahf
    2cd2:	00 01                	add    %al,(%rcx)
    2cd4:	14 04                	adc    $0x4,%al
    2cd6:	d0 39                	sarb   (%rcx)
    2cd8:	fd                   	std
    2cd9:	39 01                	cmp    %eax,(%rcx)
    2cdb:	54                   	push   %rsp
    2cdc:	00 01                	add    %al,(%rcx)
    2cde:	14 04                	adc    $0x4,%al
    2ce0:	f6 39                	idivb  (%rcx)
    2ce2:	fa                   	cli
    2ce3:	39 03                	cmp    %eax,(%rbx)
    2ce5:	11 00                	adc    %eax,(%rax)
    2ce7:	9f                   	lahf
    2ce8:	04 fa                	add    $0xfa,%al
    2cea:	39 fd                	cmp    %edi,%ebp
    2cec:	39 03                	cmp    %eax,(%rbx)
    2cee:	11 01                	adc    %eax,(%rcx)
    2cf0:	9f                   	lahf
    2cf1:	04 fd                	add    $0xfd,%al
    2cf3:	39 84 3a 03 11 04 9f 	cmp    %eax,-0x60fbeefd(%rdx,%rdi,1)
    2cfa:	04 84                	add    $0x84,%al
    2cfc:	3a 88 3a 03 11 07    	cmp    0x711033a(%rax),%cl
    2d02:	9f                   	lahf
    2d03:	04 88                	add    $0x88,%al
    2d05:	3a 8b 3a 03 11 06    	cmp    0x611033a(%rbx),%cl
    2d0b:	9f                   	lahf
    2d0c:	04 8b                	add    $0x8b,%al
    2d0e:	3a 91 3a 03 11 08    	cmp    0x811033a(%rcx),%dl
    2d14:	9f                   	lahf
    2d15:	00 01                	add    %al,(%rcx)
    2d17:	14 04                	adc    $0x4,%al
    2d19:	f6 39                	idivb  (%rcx)
    2d1b:	fa                   	cli
    2d1c:	39 03                	cmp    %eax,(%rbx)
    2d1e:	72 10                	jb     2d30 <_license+0x99b>
    2d20:	9f                   	lahf
    2d21:	04 fa                	add    $0xfa,%al
    2d23:	39 fd                	cmp    %edi,%ebp
    2d25:	39 03                	cmp    %eax,(%rbx)
    2d27:	72 12                	jb     2d3b <_license+0x9a6>
    2d29:	9f                   	lahf
    2d2a:	04 fd                	add    $0xfd,%al
    2d2c:	39 84 3a 03 72 18 9f 	cmp    %eax,-0x60e78dfd(%rdx,%rdi,1)
    2d33:	04 84                	add    $0x84,%al
    2d35:	3a 88 3a 03 72 1e    	cmp    0x1e72033a(%rax),%cl
    2d3b:	9f                   	lahf
    2d3c:	04 88                	add    $0x88,%al
    2d3e:	3a 8b 3a 03 72 1c    	cmp    0x1c72033a(%rbx),%cl
    2d44:	9f                   	lahf
    2d45:	04 8b                	add    $0x8b,%al
    2d47:	3a 91 3a 03 72 20    	cmp    0x2072033a(%rcx),%dl
    2d4d:	9f                   	lahf
    2d4e:	00 01                	add    %al,(%rcx)
    2d50:	14 04                	adc    $0x4,%al
    2d52:	fe                   	(bad)
    2d53:	3a 8b 3b 02 30 9f    	cmp    -0x60cffdc5(%rbx),%cl
    2d59:	04 8b                	add    $0x8b,%al
    2d5b:	3b 94 3b 01 50 00 01 	cmp    0x1005001(%rbx,%rdi,1),%edx
    2d62:	14 04                	adc    $0x4,%al
    2d64:	94                   	xchg   %eax,%esp
    2d65:	3b ab 3b 01 50 00    	cmp    0x50013b(%rbx),%ebp
    2d6b:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2d6e:	ab                   	stos   %eax,%es:(%rdi)
    2d6f:	3b 87 3e 03 77 10    	cmp    0x1077033e(%rdi),%eax
    2d75:	9f                   	lahf
    2d76:	04 f9                	add    $0xf9,%al
    2d78:	3e 94                	ds xchg %eax,%esp
    2d7a:	3f                   	(bad)
    2d7b:	03 77 10             	add    0x10(%rdi),%esi
    2d7e:	9f                   	lahf
    2d7f:	04 b2                	add    $0xb2,%al
    2d81:	3f                   	(bad)
    2d82:	cf                   	iret
    2d83:	3f                   	(bad)
    2d84:	03 77 10             	add    0x10(%rdi),%esi
    2d87:	9f                   	lahf
    2d88:	00 01                	add    %al,(%rcx)
    2d8a:	14 04                	adc    $0x4,%al
    2d8c:	ab                   	stos   %eax,%es:(%rdi)
    2d8d:	3b 87 3e 03 77 c0    	cmp    -0x3f88fcc2(%rdi),%eax
    2d93:	00 04 f9             	add    %al,(%rcx,%rdi,8)
    2d96:	3e 94                	ds xchg %eax,%esp
    2d98:	3f                   	(bad)
    2d99:	03 77 c0             	add    -0x40(%rdi),%esi
    2d9c:	00 04 b2             	add    %al,(%rdx,%rsi,4)
    2d9f:	3f                   	(bad)
    2da0:	cf                   	iret
    2da1:	3f                   	(bad)
    2da2:	03 77 c0             	add    -0x40(%rdi),%esi
    2da5:	00 00                	add    %al,(%rax)
    2da7:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2daa:	ab                   	stos   %eax,%es:(%rdi)
    2dab:	3b 87 3e 02 30 9f    	cmp    -0x60cffdc2(%rdi),%eax
    2db1:	04 f9                	add    $0xf9,%al
    2db3:	3e 94                	ds xchg %eax,%esp
    2db5:	3f                   	(bad)
    2db6:	02 30                	add    (%rax),%dh
    2db8:	9f                   	lahf
    2db9:	04 b2                	add    $0xb2,%al
    2dbb:	3f                   	(bad)
    2dbc:	cf                   	iret
    2dbd:	3f                   	(bad)
    2dbe:	02 30                	add    (%rax),%dh
    2dc0:	9f                   	lahf
    2dc1:	00 01                	add    %al,(%rcx)
    2dc3:	14 04                	adc    $0x4,%al
    2dc5:	ab                   	stos   %eax,%es:(%rdi)
    2dc6:	3b 87 3e 03 77 c8    	cmp    -0x3788fcc2(%rdi),%eax
    2dcc:	00 04 f9             	add    %al,(%rcx,%rdi,8)
    2dcf:	3e 94                	ds xchg %eax,%esp
    2dd1:	3f                   	(bad)
    2dd2:	03 77 c8             	add    -0x38(%rdi),%esi
    2dd5:	00 04 b2             	add    %al,(%rdx,%rsi,4)
    2dd8:	3f                   	(bad)
    2dd9:	cf                   	iret
    2dda:	3f                   	(bad)
    2ddb:	03 77 c8             	add    -0x38(%rdi),%esi
    2dde:	00 00                	add    %al,(%rax)
    2de0:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2de3:	c6                   	(bad)
    2de4:	3b 96 3c 02 30 9f    	cmp    -0x60cffdc4(%rsi),%edx
    2dea:	04 96                	add    $0x96,%al
    2dec:	3c e1                	cmp    $0xe1,%al
    2dee:	3d 11 73 00 10       	cmp    $0x10007311,%eax
    2df3:	ff 01                	incl   (%rcx)
    2df5:	1a a8 be 80 80 00    	sbb    0x8080be(%rax),%ch
    2dfb:	a8 b9                	test   $0xb9,%al
    2dfd:	80 80 00 9f 04 f9 3e 	addb   $0x3e,-0x6fb6100(%rax)
    2e04:	94                   	xchg   %eax,%esp
    2e05:	3f                   	(bad)
    2e06:	11 73 00             	adc    %esi,0x0(%rbx)
    2e09:	10 ff                	adc    %bh,%bh
    2e0b:	01 1a                	add    %ebx,(%rdx)
    2e0d:	a8 be                	test   $0xbe,%al
    2e0f:	80 80 00 a8 b9 80 80 	addb   $0x80,-0x7f465800(%rax)
    2e16:	00 9f 04 b2 3f cf    	add    %bl,-0x30c04dfc(%rdi)
    2e1c:	3f                   	(bad)
    2e1d:	11 73 00             	adc    %esi,0x0(%rbx)
    2e20:	10 ff                	adc    %bh,%bh
    2e22:	01 1a                	add    %ebx,(%rdx)
    2e24:	a8 be                	test   $0xbe,%al
    2e26:	80 80 00 a8 b9 80 80 	addb   $0x80,-0x7f465800(%rax)
    2e2d:	00 9f 00 01 14 04    	add    %bl,0x4140100(%rdi)
    2e33:	c6                   	(bad)
    2e34:	3b 87 3e 02 30 9f    	cmp    -0x60cffdc2(%rdi),%eax
    2e3a:	04 f9                	add    $0xf9,%al
    2e3c:	3e 94                	ds xchg %eax,%esp
    2e3e:	3f                   	(bad)
    2e3f:	02 30                	add    (%rax),%dh
    2e41:	9f                   	lahf
    2e42:	04 b2                	add    $0xb2,%al
    2e44:	3f                   	(bad)
    2e45:	cf                   	iret
    2e46:	3f                   	(bad)
    2e47:	02 30                	add    (%rax),%dh
    2e49:	9f                   	lahf
    2e4a:	00 01                	add    %al,(%rcx)
    2e4c:	14 04                	adc    $0x4,%al
    2e4e:	c6                   	(bad)
    2e4f:	3b ea                	cmp    %edx,%ebp
    2e51:	3d 02 30 9f 04       	cmp    $0x49f3002,%eax
    2e56:	ea                   	(bad)
    2e57:	3d ef 3d 01 5f       	cmp    $0x5f013def,%eax
    2e5c:	04 f9                	add    $0xf9,%al
    2e5e:	3e 94                	ds xchg %eax,%esp
    2e60:	3f                   	(bad)
    2e61:	02 30                	add    (%rax),%dh
    2e63:	9f                   	lahf
    2e64:	04 b2                	add    $0xb2,%al
    2e66:	3f                   	(bad)
    2e67:	cf                   	iret
    2e68:	3f                   	(bad)
    2e69:	02 30                	add    (%rax),%dh
    2e6b:	9f                   	lahf
    2e6c:	00 01                	add    %al,(%rcx)
    2e6e:	14 04                	adc    $0x4,%al
    2e70:	c6                   	(bad)
    2e71:	3b c9                	cmp    %ecx,%ecx
    2e73:	3b 02                	cmp    (%rdx),%eax
    2e75:	30 9f 04 c9 3b d9    	xor    %bl,-0x26c436fc(%rdi)
    2e7b:	3b 01                	cmp    (%rcx),%eax
    2e7d:	5e                   	pop    %rsi
    2e7e:	00 01                	add    %al,(%rcx)
    2e80:	14 04                	adc    $0x4,%al
    2e82:	d2 3b                	sarb   %cl,(%rbx)
    2e84:	94                   	xchg   %eax,%esp
    2e85:	3c 01                	cmp    $0x1,%al
    2e87:	5e                   	pop    %rsi
    2e88:	00 01                	add    %al,(%rcx)
    2e8a:	14 04                	adc    $0x4,%al
    2e8c:	96                   	xchg   %eax,%esi
    2e8d:	3c a8                	cmp    $0xa8,%al
    2e8f:	3d 02 30 9f 04       	cmp    $0x49f3002,%eax
    2e94:	f9                   	stc
    2e95:	3e 94                	ds xchg %eax,%esp
    2e97:	3f                   	(bad)
    2e98:	02 30                	add    (%rax),%dh
    2e9a:	9f                   	lahf
    2e9b:	00 01                	add    %al,(%rcx)
    2e9d:	14 04                	adc    $0x4,%al
    2e9f:	c4                   	(bad)
    2ea0:	3c 86                	cmp    $0x86,%al
    2ea2:	3d 03 77 10 9f       	cmp    $0x9f107703,%eax
    2ea7:	00 01                	add    %al,(%rcx)
    2ea9:	14 04                	adc    $0x4,%al
    2eab:	c4                   	(bad)
    2eac:	3c 86                	cmp    $0x86,%al
    2eae:	3d 02 30 9f 00       	cmp    $0x9f3002,%eax
    2eb3:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2eb6:	ec                   	in     (%dx),%al
    2eb7:	3c f6                	cmp    $0xf6,%al
    2eb9:	3c 01                	cmp    $0x1,%al
    2ebb:	50                   	push   %rax
    2ebc:	00 01                	add    %al,(%rcx)
    2ebe:	14 04                	adc    $0x4,%al
    2ec0:	fb                   	sti
    2ec1:	3c 94                	cmp    $0x94,%al
    2ec3:	3d 01 50 04 9f       	cmp    $0x9f045001,%eax
    2ec8:	3d fa 3d 01 50       	cmp    $0x50013dfa,%eax
    2ecd:	00 01                	add    %al,(%rcx)
    2ecf:	14 04                	adc    $0x4,%al
    2ed1:	fb                   	sti
    2ed2:	3c 80                	cmp    $0x80,%al
    2ed4:	3d 02 30 9f 00       	cmp    $0x9f3002,%eax
    2ed9:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2edc:	ac                   	lods   %ds:(%rsi),%al
    2edd:	3d b1 3d 02 30       	cmp    $0x30023db1,%eax
    2ee2:	9f                   	lahf
    2ee3:	00 01                	add    %al,(%rcx)
    2ee5:	14 04                	adc    $0x4,%al
    2ee7:	91                   	xchg   %eax,%ecx
    2ee8:	3e 9d                	ds popf
    2eea:	3e 01 50 00          	ds add %edx,0x0(%rax)
    2eee:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2ef1:	cf                   	iret
    2ef2:	3e df 3e             	ds fistpll (%rsi)
    2ef5:	02 30                	add    (%rax),%dh
    2ef7:	9f                   	lahf
    2ef8:	04 df                	add    $0xdf,%al
    2efa:	3e e8 3e 01 50 00    	ds call 50303e <_license+0x500ca9>
    2f00:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2f03:	e8 3e ef 3e 01       	call   13f1e46 <_license+0x13efab1>
    2f08:	50                   	push   %rax
    2f09:	00 01                	add    %al,(%rcx)
    2f0b:	14 04                	adc    $0x4,%al
    2f0d:	f9                   	stc
    2f0e:	3e 86 3f             	ds xchg %bh,(%rdi)
    2f11:	02 30                	add    (%rax),%dh
    2f13:	9f                   	lahf
    2f14:	04 86                	add    $0x86,%al
    2f16:	3f                   	(bad)
    2f17:	8f                   	(bad)
    2f18:	3f                   	(bad)
    2f19:	01 50 00             	add    %edx,0x0(%rax)
    2f1c:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2f1f:	8f                   	(bad)
    2f20:	3f                   	(bad)
    2f21:	94                   	xchg   %eax,%esp
    2f22:	3f                   	(bad)
    2f23:	01 50 00             	add    %edx,0x0(%rax)
    2f26:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2f29:	b2 3f                	mov    $0x3f,%dl
    2f2b:	bf 3f 02 30 9f       	mov    $0x9f30023f,%edi
    2f30:	04 bf                	add    $0xbf,%al
    2f32:	3f                   	(bad)
    2f33:	c8 3f 01 50          	enter  $0x13f,$0x50
    2f37:	00 01                	add    %al,(%rcx)
    2f39:	14 04                	adc    $0x4,%al
    2f3b:	c8 3f cf 3f          	enter  $0xcf3f,$0x3f
    2f3f:	01 50 00             	add    %edx,0x0(%rax)
    2f42:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2f45:	ee                   	out    %al,(%dx)
    2f46:	3f                   	(bad)
    2f47:	ee                   	out    %al,(%dx)
    2f48:	40 01 52 00          	rex add %edx,0x0(%rdx)
    2f4c:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2f4f:	f2 3f                	repnz (bad)
    2f51:	ca 40 01             	lret   $0x140
    2f54:	51                   	push   %rcx
    2f55:	00 01                	add    %al,(%rcx)
    2f57:	14 04                	adc    $0x4,%al
    2f59:	f2 3f                	repnz (bad)
    2f5b:	ee                   	out    %al,(%dx)
    2f5c:	40 01 52 00          	rex add %edx,0x0(%rdx)
    2f60:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2f63:	f6 3f                	idivb  (%rdi)
    2f65:	84 40 01             	test   %al,0x1(%rax)
    2f68:	50                   	push   %rax
    2f69:	00 01                	add    %al,(%rcx)
    2f6b:	14 04                	adc    $0x4,%al
    2f6d:	f6 3f                	idivb  (%rdi)
    2f6f:	ee                   	out    %al,(%dx)
    2f70:	40 03 72 28          	rex add 0x28(%rdx),%esi
    2f74:	9f                   	lahf
    2f75:	00 01                	add    %al,(%rcx)
    2f77:	14 04                	adc    $0x4,%al
    2f79:	bc 40 ee 40 02       	mov    $0x240ee40,%esp
    2f7e:	34 9f                	xor    $0x9f,%al
    2f80:	00 01                	add    %al,(%rcx)
    2f82:	14 04                	adc    $0x4,%al
    2f84:	c1 40 c5 40          	roll   $0x40,-0x3b(%rax)
    2f88:	0c 31                	or     $0x31,%al
    2f8a:	9f                   	lahf
    2f8b:	93                   	xchg   %eax,%ebx
    2f8c:	04 30                	add    $0x30,%al
    2f8e:	9f                   	lahf
    2f8f:	93                   	xchg   %eax,%ebx
    2f90:	04 30                	add    $0x30,%al
    2f92:	9f                   	lahf
    2f93:	93                   	xchg   %eax,%ebx
    2f94:	04 04                	add    $0x4,%al
    2f96:	c5 40 ee             	(bad)
    2f99:	40 0f 31             	rex rdtsc
    2f9c:	9f                   	lahf
    2f9d:	93                   	xchg   %eax,%ebx
    2f9e:	04 30                	add    $0x30,%al
    2fa0:	9f                   	lahf
    2fa1:	93                   	xchg   %eax,%ebx
    2fa2:	04 30                	add    $0x30,%al
    2fa4:	9f                   	lahf
    2fa5:	93                   	xchg   %eax,%ebx
    2fa6:	04 50                	add    $0x50,%al
    2fa8:	93                   	xchg   %eax,%ebx
    2fa9:	04 00                	add    $0x0,%al
    2fab:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2fae:	c5 40 ee             	(bad)
    2fb1:	40 01 53 00          	rex add %edx,0x0(%rbx)
    2fb5:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2fb8:	ca 40 e1             	lret   $0xe140
    2fbb:	40 01 51 00          	rex add %edx,0x0(%rcx)
    2fbf:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2fc2:	95                   	xchg   %eax,%ebp
    2fc3:	41 da 41 04          	fiaddl 0x4(%r9)
    2fc7:	10 82 04 9f 04 91    	adc    %al,-0x6efb60fc(%rdx)
    2fcd:	42 a2 42 04 10 82 04 	rex.X movabs %al,0x1009f0482100442
    2fd4:	9f 00 01 
    2fd7:	14 04                	adc    $0x4,%al
    2fd9:	95                   	xchg   %eax,%ebp
    2fda:	41 a2 41 02 30 9f 04 	rex.B movabs %al,0xab41a2049f300241
    2fe1:	a2 41 ab 
    2fe4:	41 01 5f 00          	add    %ebx,0x0(%r15)
    2fe8:	01 14 04             	add    %edx,(%rsp,%rax,1)
    2feb:	ab                   	stos   %eax,%es:(%rdi)
    2fec:	41 da 41 01          	fiaddl 0x1(%r9)
    2ff0:	5f                   	pop    %rdi
    2ff1:	04 91                	add    $0x91,%al
    2ff3:	42 a2 42 01 5f 00 01 	rex.X movabs %al,0xe0041401005f0142
    2ffa:	14 04 e0 
    2ffd:	41 fd                	rex.B std
    2fff:	41 02 30             	add    (%r8),%sil
    3002:	9f                   	lahf
    3003:	04 fd                	add    $0xfd,%al
    3005:	41 86 42 01          	xchg   %al,0x1(%r10)
    3009:	50                   	push   %rax
    300a:	00 01                	add    %al,(%rcx)
    300c:	14 04                	adc    $0x4,%al
    300e:	86 42 8f             	xchg   %al,-0x71(%rdx)
    3011:	42 01 50 00          	rex.X add %edx,0x0(%rax)
    3015:	01 14 04             	add    %edx,(%rsp,%rax,1)
    3018:	e0 42                	loopne 305c <_license+0xcc7>
    301a:	e4 42                	in     $0x42,%al
    301c:	01 50 04             	add    %edx,0x4(%rax)
    301f:	e4 42                	in     $0x42,%al
    3021:	fa                   	cli
    3022:	42 03 77 c0          	rex.X add -0x40(%rdi),%esi
    3026:	00 00                	add    %al,(%rax)
    3028:	01 14 04             	add    %edx,(%rsp,%rax,1)
    302b:	fa                   	cli
    302c:	42 bf 43 04 10 82    	rex.X mov $0x82100443,%edi
    3032:	04 9f                	add    $0x9f,%al
    3034:	04 f6                	add    $0xf6,%al
    3036:	43 87 44 04 10       	xchg   %eax,0x10(%r12,%r8,1)
    303b:	82                   	(bad)
    303c:	04 9f                	add    $0x9f,%al
    303e:	00 01                	add    %al,(%rcx)
    3040:	14 04                	adc    $0x4,%al
    3042:	fa                   	cli
    3043:	42 87 43 02          	rex.X xchg %eax,0x2(%rbx)
    3047:	30 9f 04 87 43 90    	xor    %bl,-0x6fbc78fc(%rdi)
    304d:	43 01 53 00          	rex.XB add %edx,0x0(%r11)
    3051:	01 14 04             	add    %edx,(%rsp,%rax,1)
    3054:	90                   	nop
    3055:	43 bf 43 01 53 04    	rex.XB mov $0x4530143,%r15d
    305b:	f6 43 87 44          	testb  $0x44,-0x79(%rbx)
    305f:	01 53 00             	add    %edx,0x0(%rbx)
    3062:	01 14 04             	add    %edx,(%rsp,%rax,1)
    3065:	c5 43 e2             	(bad)
    3068:	43 02 30             	rex.XB add (%r8),%sil
    306b:	9f                   	lahf
    306c:	04 e2                	add    $0xe2,%al
    306e:	43 eb 43             	rex.XB jmp 30b4 <_license+0xd1f>
    3071:	01 50 00             	add    %edx,0x0(%rax)
    3074:	01 14 04             	add    %edx,(%rsp,%rax,1)
    3077:	eb 43                	jmp    30bc <_license+0xd27>
    3079:	f4                   	hlt
    307a:	43 01 50 00          	rex.XB add %edx,0x0(%r8)
    307e:	01 14 04             	add    %edx,(%rsp,%rax,1)
    3081:	c7 44 ce 44 01 50 04 	movl   $0xce045001,0x44(%rsi,%rcx,8)
    3088:	ce 
    3089:	44 d3 44 03 77       	rex.R roll %cl,0x77(%rbx,%rax,1)
    308e:	84 01                	test   %al,(%rcx)
    3090:	00 01                	add    %al,(%rcx)
    3092:	ca 01 04             	lret   $0x401
    3095:	04 0a                	add    $0xa,%al
    3097:	01 55 04             	add    %edx,0x4(%rbp)
    309a:	0a 51 04             	or     0x4(%rcx),%dl
    309d:	a3 01 55 9f 00 01 ca 	movabs %eax,0x401ca01009f5501
    30a4:	01 04 
    30a6:	04 10                	add    $0x10,%al
    30a8:	01 54 04 10          	add    %edx,0x10(%rsp,%rax,1)
    30ac:	51                   	push   %rcx
    30ad:	04 a3                	add    $0xa3,%al
    30af:	01 54 9f 00          	add    %edx,0x0(%rdi,%rbx,4)
    30b3:	01 ca                	add    %ecx,%edx
    30b5:	01 04 04             	add    %eax,(%rsp,%rax,1)
    30b8:	47 01 55 00          	rex.RXB add %r10d,0x0(%r13)
    30bc:	01 ca                	add    %ecx,%edx
    30be:	01 04 04             	add    %eax,(%rsp,%rax,1)
    30c1:	4e 01 54 00 03       	add    %r10,0x3(%rax,%r8,1)
    30c6:	ca 01 51             	lret   $0x5101
    30c9:	06                   	(bad)
    30ca:	10 80 84 80 10 9f    	adc    %al,-0x60ef7f7c(%rax)
    30d0:	00 01                	add    %al,(%rcx)
    30d2:	ca 01 04             	lret   $0x401
    30d5:	04 10                	add    $0x10,%al
    30d7:	02 30                	add    (%rax),%dh
    30d9:	9f                   	lahf
    30da:	04 10                	add    $0x10,%al
    30dc:	17                   	(bad)
    30dd:	0c 10                	or     $0x10,%al
    30df:	f7 81 b7 85 fe ff ff 	testl  $0x1ffffff,-0x17a49(%rcx)
    30e6:	ff ff 01 
    30e9:	9f                   	lahf
    30ea:	04 17                	add    $0x17,%al
    30ec:	30 01                	xor    %al,(%rcx)
    30ee:	50                   	push   %rax
    30ef:	04 37                	add    $0x37,%al
    30f1:	50                   	push   %rax
    30f2:	01 50 00             	add    %edx,0x0(%rax)
    30f5:	01 ca                	add    %ecx,%edx
    30f7:	01 04 04             	add    %eax,(%rsp,%rax,1)
    30fa:	51                   	push   %rcx
    30fb:	0c 10                	or     $0x10,%al
    30fd:	f7 81 b7 85 fe ff ff 	testl  $0x1ffffff,-0x17a49(%rcx)
    3104:	ff ff 01 
    3107:	9f                   	lahf
    3108:	00 01                	add    %al,(%rcx)
    310a:	d2 01                	rolb   %cl,(%rcx)
    310c:	04 04                	add    $0x4,%al
    310e:	d5                   	(bad)
    310f:	01 01                	add    %eax,(%rcx)
    3111:	55                   	push   %rbp
    3112:	00 03                	add    %al,(%rbx)
    3114:	d2 01                	rolb   %cl,(%rcx)
    3116:	d5                   	(bad)
    3117:	01 04 10             	add    %eax,(%rax,%rdx,1)
    311a:	80 04 9f 00          	addb   $0x0,(%rdi,%rbx,4)
    311e:	03 d2                	add    %edx,%edx
    3120:	01 d5                	add    %edx,%ebp
    3122:	01 02                	add    %eax,(%rdx)
    3124:	34 9f                	xor    $0x9f,%al
    3126:	00 01                	add    %al,(%rcx)
    3128:	d2 01                	rolb   %cl,(%rcx)
    312a:	04 04                	add    $0x4,%al
    312c:	d5                   	(bad)
    312d:	01 03                	add    %eax,(%rbx)
    312f:	75 0c                	jne    313d <_license+0xda8>
    3131:	9f                   	lahf
    3132:	00 01                	add    %al,(%rcx)
    3134:	d2 01                	rolb   %cl,(%rcx)
    3136:	04 06                	add    $0x6,%al
    3138:	13 11                	adc    (%rcx),%edx
    313a:	70 00                	jo     313c <_license+0xda7>
    313c:	10 ff                	adc    %bh,%bh
    313e:	ff                   	(bad)
    313f:	ff                   	(bad)
    3140:	ff 0f                	decl   (%rdi)
    3142:	1a 10                	sbb    (%rax),%dl
    3144:	81 fe c8 8a 02 1c    	cmp    $0x1c028ac8,%esi
    314a:	9f                   	lahf
    314b:	04 13                	add    $0x13,%al
    314d:	16                   	(bad)
    314e:	14 70                	adc    $0x70,%al
    3150:	00 10                	add    %dl,(%rax)
    3152:	ff                   	(bad)
    3153:	ff                   	(bad)
    3154:	ff                   	(bad)
    3155:	ff 0f                	decl   (%rdi)
    3157:	1a 78 00             	sbb    0x0(%rax),%bh
    315a:	10 ff                	adc    %bh,%bh
    315c:	ff                   	(bad)
    315d:	ff                   	(bad)
    315e:	ff 0f                	decl   (%rdi)
    3160:	1a 1c 9f             	sbb    (%rdi,%rbx,4),%bl
    3163:	04 16                	add    $0x16,%al
    3165:	21 01                	and    %eax,(%rcx)
    3167:	50                   	push   %rax
    3168:	04 38                	add    $0x38,%al
    316a:	3b 14 79             	cmp    (%rcx,%rdi,2),%edx
    316d:	00 10                	add    %dl,(%rax)
    316f:	ff                   	(bad)
    3170:	ff                   	(bad)
    3171:	ff                   	(bad)
    3172:	ff 0f                	decl   (%rdi)
    3174:	1a 70 00             	sbb    0x0(%rax),%dh
    3177:	10 ff                	adc    %bh,%bh
    3179:	ff                   	(bad)
    317a:	ff                   	(bad)
    317b:	ff 0f                	decl   (%rdi)
    317d:	1a 22                	sbb    (%rdx),%ah
    317f:	9f                   	lahf
    3180:	04 3b                	add    $0x3b,%al
    3182:	44 01 59 04          	add    %r11d,0x4(%rcx)
    3186:	44                   	rex.R
    3187:	46 1e                	rex.RX (bad)
    3189:	79 00                	jns    318b <_license+0xdf6>
    318b:	10 ff                	adc    %bh,%bh
    318d:	ff                   	(bad)
    318e:	ff                   	(bad)
    318f:	ff 0f                	decl   (%rdi)
    3191:	1a 70 00             	sbb    0x0(%rax),%dh
    3194:	10 ff                	adc    %bh,%bh
    3196:	ff                   	(bad)
    3197:	ff                   	(bad)
    3198:	ff 0f                	decl   (%rdi)
    319a:	1a 72 00             	sbb    0x0(%rdx),%dh
    319d:	10 ff                	adc    %bh,%bh
    319f:	ff                   	(bad)
    31a0:	ff                   	(bad)
    31a1:	ff 0f                	decl   (%rdi)
    31a3:	1a 27                	sbb    (%rdi),%ah
    31a5:	1c 9f                	sbb    $0x9f,%al
    31a7:	04 46                	add    $0x46,%al
    31a9:	49 14 79             	rex.WB adc $0x79,%al
    31ac:	00 10                	add    %dl,(%rax)
    31ae:	ff                   	(bad)
    31af:	ff                   	(bad)
    31b0:	ff                   	(bad)
    31b1:	ff 0f                	decl   (%rdi)
    31b3:	1a 72 00             	sbb    0x0(%rdx),%dh
    31b6:	10 ff                	adc    %bh,%bh
    31b8:	ff                   	(bad)
    31b9:	ff                   	(bad)
    31ba:	ff 0f                	decl   (%rdi)
    31bc:	1a 1c 9f             	sbb    (%rdi,%rbx,4),%bl
    31bf:	04 49                	add    $0x49,%al
    31c1:	4e 01 59 04          	rex.WRX add %r11,0x4(%rcx)
    31c5:	4e 51                	rex.WRX push %rcx
    31c7:	28 79 00             	sub    %bh,0x0(%rcx)
    31ca:	10 ff                	adc    %bh,%bh
    31cc:	ff                   	(bad)
    31cd:	ff                   	(bad)
    31ce:	ff 0f                	decl   (%rdi)
    31d0:	1a 74 00 10          	sbb    0x10(%rax,%rax,1),%dh
    31d4:	ff                   	(bad)
    31d5:	ff                   	(bad)
    31d6:	ff                   	(bad)
    31d7:	ff 0f                	decl   (%rdi)
    31d9:	1a 27                	sbb    (%rdi),%ah
    31db:	72 00                	jb     31dd <_license+0xe48>
    31dd:	10 ff                	adc    %bh,%bh
    31df:	ff                   	(bad)
    31e0:	ff                   	(bad)
    31e1:	ff 0f                	decl   (%rdi)
    31e3:	1a 71 00             	sbb    0x0(%rcx),%dh
    31e6:	10 ff                	adc    %bh,%bh
    31e8:	ff                   	(bad)
    31e9:	ff                   	(bad)
    31ea:	ff 0f                	decl   (%rdi)
    31ec:	1a 22                	sbb    (%rdx),%ah
    31ee:	22 9f 04 5f 61 14    	and    0x14615f04(%rdi),%bl
    31f4:	74 00                	je     31f6 <_license+0xe61>
    31f6:	10 ff                	adc    %bh,%bh
    31f8:	ff                   	(bad)
    31f9:	ff                   	(bad)
    31fa:	ff 0f                	decl   (%rdi)
    31fc:	1a 72 00             	sbb    0x0(%rdx),%dh
    31ff:	10 ff                	adc    %bh,%bh
    3201:	ff                   	(bad)
    3202:	ff                   	(bad)
    3203:	ff 0f                	decl   (%rdi)
    3205:	1a 22                	sbb    (%rdx),%ah
    3207:	9f                   	lahf
    3208:	04 61                	add    $0x61,%al
    320a:	73 01                	jae    320d <_license+0xe78>
    320c:	54                   	push   %rsp
    320d:	04 94                	add    $0x94,%al
    320f:	01 a0 01 01 51 04    	add    %esp,0x4510101(%rax)
    3215:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    3216:	01 c9                	add    %ecx,%ecx
    3218:	01 01                	add    %eax,(%rcx)
    321a:	51                   	push   %rcx
    321b:	00 01                	add    %al,(%rcx)
    321d:	d2 01                	rolb   %cl,(%rcx)
    321f:	04 13                	add    $0x13,%al
    3221:	1d 1b 78 00 10       	sbb    $0x1000781b,%eax
    3226:	ff                   	(bad)
    3227:	ff                   	(bad)
    3228:	ff                   	(bad)
    3229:	ff 0f                	decl   (%rdi)
    322b:	1a 10                	sbb    (%rax),%dl
    322d:	81 fe c8 8a 02 1c    	cmp    $0x1c028ac8,%esi
    3233:	74 00                	je     3235 <_license+0xea0>
    3235:	10 ff                	adc    %bh,%bh
    3237:	ff                   	(bad)
    3238:	ff                   	(bad)
    3239:	ff 0f                	decl   (%rdi)
    323b:	1a 22                	sbb    (%rdx),%ah
    323d:	9f                   	lahf
    323e:	04 1d                	add    $0x1d,%al
    3240:	21 14 79             	and    %edx,(%rcx,%rdi,2)
    3243:	00 10                	add    %dl,(%rax)
    3245:	ff                   	(bad)
    3246:	ff                   	(bad)
    3247:	ff                   	(bad)
    3248:	ff 0f                	decl   (%rdi)
    324a:	1a 74 00 10          	sbb    0x10(%rax,%rax,1),%dh
    324e:	ff                   	(bad)
    324f:	ff                   	(bad)
    3250:	ff                   	(bad)
    3251:	ff 0f                	decl   (%rdi)
    3253:	1a 22                	sbb    (%rdx),%ah
    3255:	9f                   	lahf
    3256:	04 38                	add    $0x38,%al
    3258:	41 14 70             	rex.B adc $0x70,%al
    325b:	00 10                	add    %dl,(%rax)
    325d:	ff                   	(bad)
    325e:	ff                   	(bad)
    325f:	ff                   	(bad)
    3260:	ff 0f                	decl   (%rdi)
    3262:	1a 72 00             	sbb    0x0(%rdx),%dh
    3265:	10 ff                	adc    %bh,%bh
    3267:	ff                   	(bad)
    3268:	ff                   	(bad)
    3269:	ff 0f                	decl   (%rdi)
    326b:	1a 1c 9f             	sbb    (%rdi,%rbx,4),%bl
    326e:	04 41                	add    $0x41,%al
    3270:	44 01 50 04          	add    %r10d,0x4(%rax)
    3274:	44                   	rex.R
    3275:	46 1e                	rex.RX (bad)
    3277:	70 00                	jo     3279 <_license+0xee4>
    3279:	10 ff                	adc    %bh,%bh
    327b:	ff                   	(bad)
    327c:	ff                   	(bad)
    327d:	ff 0f                	decl   (%rdi)
    327f:	1a 72 00             	sbb    0x0(%rdx),%dh
    3282:	10 ff                	adc    %bh,%bh
    3284:	ff                   	(bad)
    3285:	ff                   	(bad)
    3286:	ff 0f                	decl   (%rdi)
    3288:	1a 27                	sbb    (%rdi),%ah
    328a:	71 00                	jno    328c <_license+0xef7>
    328c:	10 ff                	adc    %bh,%bh
    328e:	ff                   	(bad)
    328f:	ff                   	(bad)
    3290:	ff 0f                	decl   (%rdi)
    3292:	1a 22                	sbb    (%rdx),%ah
    3294:	9f                   	lahf
    3295:	04 46                	add    $0x46,%al
    3297:	51                   	push   %rcx
    3298:	14 72                	adc    $0x72,%al
    329a:	00 10                	add    %dl,(%rax)
    329c:	ff                   	(bad)
    329d:	ff                   	(bad)
    329e:	ff                   	(bad)
    329f:	ff 0f                	decl   (%rdi)
    32a1:	1a 71 00             	sbb    0x0(%rcx),%dh
    32a4:	10 ff                	adc    %bh,%bh
    32a6:	ff                   	(bad)
    32a7:	ff                   	(bad)
    32a8:	ff 0f                	decl   (%rdi)
    32aa:	1a 22                	sbb    (%rdx),%ah
    32ac:	9f                   	lahf
    32ad:	04 5f                	add    $0x5f,%al
    32af:	68 14 72 00 10       	push   $0x10007214
    32b4:	ff                   	(bad)
    32b5:	ff                   	(bad)
    32b6:	ff                   	(bad)
    32b7:	ff 0f                	decl   (%rdi)
    32b9:	1a 78 00             	sbb    0x0(%rax),%bh
    32bc:	10 ff                	adc    %bh,%bh
    32be:	ff                   	(bad)
    32bf:	ff                   	(bad)
    32c0:	ff 0f                	decl   (%rdi)
    32c2:	1a 1c 9f             	sbb    (%rdi,%rbx,4),%bl
    32c5:	04 68                	add    $0x68,%al
    32c7:	6c                   	insb   (%dx),%es:(%rdi)
    32c8:	01 52 04             	add    %edx,0x4(%rdx)
    32cb:	99                   	cltd
    32cc:	01 cb                	add    %ecx,%ebx
    32ce:	01 01                	add    %eax,(%rcx)
    32d0:	52                   	push   %rdx
    32d1:	04 cb                	add    $0xcb,%al
    32d3:	01 d0                	add    %edx,%eax
    32d5:	01 14 72             	add    %edx,(%rdx,%rsi,2)
    32d8:	00 10                	add    %dl,(%rax)
    32da:	ff                   	(bad)
    32db:	ff                   	(bad)
    32dc:	ff                   	(bad)
    32dd:	ff 0f                	decl   (%rdi)
    32df:	1a 70 00             	sbb    0x0(%rax),%dh
    32e2:	10 ff                	adc    %bh,%bh
    32e4:	ff                   	(bad)
    32e5:	ff                   	(bad)
    32e6:	ff 0f                	decl   (%rdi)
    32e8:	1a 27                	sbb    (%rdi),%ah
    32ea:	9f                   	lahf
    32eb:	04 d0                	add    $0xd0,%al
    32ed:	01 d2                	add    %edx,%edx
    32ef:	01 1e                	add    %ebx,(%rsi)
    32f1:	72 00                	jb     32f3 <_license+0xf5e>
    32f3:	10 ff                	adc    %bh,%bh
    32f5:	ff                   	(bad)
    32f6:	ff                   	(bad)
    32f7:	ff 0f                	decl   (%rdi)
    32f9:	1a 70 00             	sbb    0x0(%rax),%dh
    32fc:	10 ff                	adc    %bh,%bh
    32fe:	ff                   	(bad)
    32ff:	ff                   	(bad)
    3300:	ff 0f                	decl   (%rdi)
    3302:	1a 27                	sbb    (%rdi),%ah
    3304:	71 00                	jno    3306 <_license+0xf71>
    3306:	10 ff                	adc    %bh,%bh
    3308:	ff                   	(bad)
    3309:	ff                   	(bad)
    330a:	ff 0f                	decl   (%rdi)
    330c:	1a 1c 9f             	sbb    (%rdi,%rbx,4),%bl
    330f:	04 d2                	add    $0xd2,%al
    3311:	01 d4                	add    %edx,%esp
    3313:	01 14 70             	add    %edx,(%rax,%rsi,2)
    3316:	00 10                	add    %dl,(%rax)
    3318:	ff                   	(bad)
    3319:	ff                   	(bad)
    331a:	ff                   	(bad)
    331b:	ff 0f                	decl   (%rdi)
    331d:	1a 71 00             	sbb    0x0(%rcx),%dh
    3320:	10 ff                	adc    %bh,%bh
    3322:	ff                   	(bad)
    3323:	ff                   	(bad)
    3324:	ff 0f                	decl   (%rdi)
    3326:	1a 1c 9f             	sbb    (%rdi,%rbx,4),%bl
    3329:	04 d4                	add    $0xd4,%al
    332b:	01 d5                	add    %edx,%ebp
    332d:	01 01                	add    %eax,(%rcx)
    332f:	50                   	push   %rax
    3330:	00 01                	add    %al,(%rcx)
    3332:	d2 01                	rolb   %cl,(%rcx)
    3334:	04 09                	add    $0x9,%al
    3336:	0f 11 71 00          	movups %xmm6,0x0(%rcx)
    333a:	10 ff                	adc    %bh,%bh
    333c:	ff                   	(bad)
    333d:	ff                   	(bad)
    333e:	ff 0f                	decl   (%rdi)
    3340:	1a 10                	sbb    (%rax),%dl
    3342:	81 fe c8 8a 02 1c    	cmp    $0x1c028ac8,%esi
    3348:	9f                   	lahf
    3349:	04 0f                	add    $0xf,%al
    334b:	21 01                	and    %eax,(%rcx)
    334d:	54                   	push   %rsp
    334e:	04 21                	add    $0x21,%al
    3350:	24 1e                	and    $0x1e,%al
    3352:	74 00                	je     3354 <_license+0xfbf>
    3354:	10 ff                	adc    %bh,%bh
    3356:	ff                   	(bad)
    3357:	ff                   	(bad)
    3358:	ff 0f                	decl   (%rdi)
    335a:	1a 70 00             	sbb    0x0(%rax),%dh
    335d:	10 ff                	adc    %bh,%bh
    335f:	ff                   	(bad)
    3360:	ff                   	(bad)
    3361:	ff 0f                	decl   (%rdi)
    3363:	1a 79 00             	sbb    0x0(%rcx),%bh
    3366:	10 ff                	adc    %bh,%bh
    3368:	ff                   	(bad)
    3369:	ff                   	(bad)
    336a:	ff 0f                	decl   (%rdi)
    336c:	1a 27                	sbb    (%rdi),%ah
    336e:	1c 9f                	sbb    $0x9f,%al
    3370:	04 24                	add    $0x24,%al
    3372:	27                   	(bad)
    3373:	14 74                	adc    $0x74,%al
    3375:	00 10                	add    %dl,(%rax)
    3377:	ff                   	(bad)
    3378:	ff                   	(bad)
    3379:	ff                   	(bad)
    337a:	ff 0f                	decl   (%rdi)
    337c:	1a 79 00             	sbb    0x0(%rcx),%bh
    337f:	10 ff                	adc    %bh,%bh
    3381:	ff                   	(bad)
    3382:	ff                   	(bad)
    3383:	ff 0f                	decl   (%rdi)
    3385:	1a 1c 9f             	sbb    (%rdi,%rbx,4),%bl
    3388:	04 27                	add    $0x27,%al
    338a:	2d 01 54 04 38       	sub    $0x38045401,%eax
    338f:	3b 1e                	cmp    (%rsi),%ebx
    3391:	72 00                	jb     3393 <_license+0xffe>
    3393:	10 ff                	adc    %bh,%bh
    3395:	ff                   	(bad)
    3396:	ff                   	(bad)
    3397:	ff 0f                	decl   (%rdi)
    3399:	1a 79 00             	sbb    0x0(%rcx),%bh
    339c:	10 ff                	adc    %bh,%bh
    339e:	ff                   	(bad)
    339f:	ff                   	(bad)
    33a0:	ff 0f                	decl   (%rdi)
    33a2:	1a 70 00             	sbb    0x0(%rax),%dh
    33a5:	10 ff                	adc    %bh,%bh
    33a7:	ff                   	(bad)
    33a8:	ff                   	(bad)
    33a9:	ff 0f                	decl   (%rdi)
    33ab:	1a 22                	sbb    (%rdx),%ah
    33ad:	22 9f 04 3b 3f 14    	and    0x143f3b04(%rdi),%bl
    33b3:	72 00                	jb     33b5 <_license+0x1020>
    33b5:	10 ff                	adc    %bh,%bh
    33b7:	ff                   	(bad)
    33b8:	ff                   	(bad)
    33b9:	ff 0f                	decl   (%rdi)
    33bb:	1a 79 00             	sbb    0x0(%rcx),%bh
    33be:	10 ff                	adc    %bh,%bh
    33c0:	ff                   	(bad)
    33c1:	ff                   	(bad)
    33c2:	ff 0f                	decl   (%rdi)
    33c4:	1a 22                	sbb    (%rdx),%ah
    33c6:	9f                   	lahf
    33c7:	04 3f                	add    $0x3f,%al
    33c9:	4e 01 51 04          	rex.WRX add %r10,0x4(%rcx)
    33cd:	4e 51                	rex.WRX push %rcx
    33cf:	1e                   	(bad)
    33d0:	71 00                	jno    33d2 <_license+0x103d>
    33d2:	10 ff                	adc    %bh,%bh
    33d4:	ff                   	(bad)
    33d5:	ff                   	(bad)
    33d6:	ff 0f                	decl   (%rdi)
    33d8:	1a 79 00             	sbb    0x0(%rcx),%bh
    33db:	10 ff                	adc    %bh,%bh
    33dd:	ff                   	(bad)
    33de:	ff                   	(bad)
    33df:	ff 0f                	decl   (%rdi)
    33e1:	1a 74 00 10          	sbb    0x10(%rax,%rax,1),%dh
    33e5:	ff                   	(bad)
    33e6:	ff                   	(bad)
    33e7:	ff                   	(bad)
    33e8:	ff 0f                	decl   (%rdi)
    33ea:	1a 27                	sbb    (%rdi),%ah
    33ec:	1c 9f                	sbb    $0x9f,%al
    33ee:	04 53                	add    $0x53,%al
    33f0:	55                   	push   %rbp
    33f1:	14 71                	adc    $0x71,%al
    33f3:	00 10                	add    %dl,(%rax)
    33f5:	ff                   	(bad)
    33f6:	ff                   	(bad)
    33f7:	ff                   	(bad)
    33f8:	ff 0f                	decl   (%rdi)
    33fa:	1a 74 00 10          	sbb    0x10(%rax,%rax,1),%dh
    33fe:	ff                   	(bad)
    33ff:	ff                   	(bad)
    3400:	ff                   	(bad)
    3401:	ff 0f                	decl   (%rdi)
    3403:	1a 1c 9f             	sbb    (%rdi,%rbx,4),%bl
    3406:	04 55                	add    $0x55,%al
    3408:	5c                   	pop    %rsp
    3409:	01 51 04             	add    %edx,0x4(%rcx)
    340c:	5f                   	pop    %rdi
    340d:	61                   	(bad)
    340e:	1e                   	(bad)
    340f:	78 00                	js     3411 <_license+0x107c>
    3411:	10 ff                	adc    %bh,%bh
    3413:	ff                   	(bad)
    3414:	ff                   	(bad)
    3415:	ff 0f                	decl   (%rdi)
    3417:	1a 74 00 10          	sbb    0x10(%rax,%rax,1),%dh
    341b:	ff                   	(bad)
    341c:	ff                   	(bad)
    341d:	ff                   	(bad)
    341e:	ff 0f                	decl   (%rdi)
    3420:	1a 72 00             	sbb    0x0(%rdx),%dh
    3423:	10 ff                	adc    %bh,%bh
    3425:	ff                   	(bad)
    3426:	ff                   	(bad)
    3427:	ff 0f                	decl   (%rdi)
    3429:	1a 22                	sbb    (%rdx),%ah
    342b:	22 9f 04 61 65 14    	and    0x14656104(%rdi),%bl
    3431:	78 00                	js     3433 <_license+0x109e>
    3433:	10 ff                	adc    %bh,%bh
    3435:	ff                   	(bad)
    3436:	ff                   	(bad)
    3437:	ff 0f                	decl   (%rdi)
    3439:	1a 74 00 10          	sbb    0x10(%rax,%rax,1),%dh
    343d:	ff                   	(bad)
    343e:	ff                   	(bad)
    343f:	ff                   	(bad)
    3440:	ff 0f                	decl   (%rdi)
    3442:	1a 22                	sbb    (%rdx),%ah
    3444:	9f                   	lahf
    3445:	04 65                	add    $0x65,%al
    3447:	d2 01                	rolb   %cl,(%rcx)
    3449:	01 50 00             	add    %edx,0x0(%rax)

Disassembly of section .debug_abbrev:

0000000000000000 <.debug_abbrev>:
  void* data = (void*)(long)ctx->data;
   0:	01 11                	add    %edx,(%rcx)
   2:	01 25 25 13 05 03    	add    %esp,0x3051325(%rip)        # 305132d <_license+0x304ef98>
   8:	25 72 17 10 17       	and    $0x17101772,%eax
   d:	1b 25 11 01 55 23    	sbb    0x23550111(%rip),%esp        # 23550124 <_license+0x2354dd8f>
  13:	73 17                	jae    2c <balancer_ingress+0x2c>
  15:	74 17                	je     2e <balancer_ingress+0x2e>
  17:	8c 01                	mov    %es,(%rcx)
  void* data_end = (void*)(long)ctx->data_end;
  19:	17                   	(bad)
  1a:	00 00                	add    %al,(%rax)
  if (data + nh_off > data_end) {
  1c:	02 24 00             	add    (%rax,%rax,1),%ah
  1f:	03 26                	add    (%rsi),%esp
  21:	3e 0b 0b             	ds or  (%rbx),%ecx
  24:	0b 00                	or     (%rax),%eax
  26:	00 03                	add    %al,(%rbx)
  28:	34 00                	xor    $0x0,%al
  2a:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f1379 <_license+0x193eefe4>
  eth_proto = eth->h_proto; 
  30:	3a 0b                	cmp    (%rbx),%cl
  32:	3b 05 02 18 00 00    	cmp    0x1802(%rip),%eax        # 183a <balancer_ingress+0x183a>
  38:	04 01                	add    $0x1,%al
  if (eth_proto == BE_ETH_P_IP) {
  3a:	01 49 13             	add    %ecx,0x13(%rcx)
  3d:	00 00                	add    %al,(%rax)
  3f:	05 21 00 49 13       	add    $0x13490021,%eax
  44:	37                   	(bad)
  45:	0b 00                	or     (%rax),%eax
  47:	00 06                	add    %al,(%rsi)
  49:	24 00                	and    $0x0,%al
  4b:	03 25 3e 0b 0b 0b    	add    0xb0b0b3e(%rip),%esp        # b0b0b8f <_license+0xb0ae7fa>
  struct packet_description pckt = {};
  51:	00 00                	add    %al,(%rax)
  53:	07                   	(bad)
  54:	24 00                	and    $0x0,%al
  56:	03 25 0b 0b 3e 0b    	add    0xb3e0b0b(%rip),%esp        # b3e0b67 <_license+0xb3de7d2>
  5c:	00 00                	add    %al,(%rax)
  5e:	08 34 00             	or     %dh,(%rax,%rax,1)
  61:	03 25 49 13 3f 19    	add    0x193f1349(%rip),%esp        # 193f13b0 <_license+0x193ef01b>
  67:	3a 0b                	cmp    (%rbx),%cl
  69:	3b 0b                	cmp    (%rbx),%ecx
  6b:	02 18                	add    (%rax),%bl
  6d:	00 00                	add    %al,(%rax)
  6f:	09 13                	or     %edx,(%rbx)
  71:	01 0b                	add    %ecx,(%rbx)
  73:	0b 3a                	or     (%rdx),%edi
  75:	0b 3b                	or     (%rbx),%edi
  77:	0b 00                	or     (%rax),%eax
  79:	00 0a                	add    %cl,(%rdx)
  7b:	0d 00 03 25 49       	or     $0x49250300,%eax
  80:	13 3a                	adc    (%rdx),%edi
  82:	0b 3b                	or     (%rbx),%edi
  struct vip_definition vip = {};
  84:	0b 38                	or     (%rax),%edi
  86:	0b 00                	or     (%rax),%eax
  88:	00 0b                	add    %cl,(%rbx)
  8a:	0f 00 49 13          	str    0x13(%rcx)
  8e:	00 00                	add    %al,(%rax)
  90:	0c 16                	or     $0x16,%al
  92:	00 49 13             	add    %cl,0x13(%rcx)
  95:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0bd5 <_license+0xb3ae840>
  9b:	00 00                	add    %al,(%rax)
    if (iph + 1 > data_end) {
  9d:	0d 13 01 03 25       	or     $0x25030113,%eax
  a2:	0b 0b                	or     (%rbx),%ecx
  a4:	3a 0b                	cmp    (%rbx),%cl
  a6:	3b 0b                	cmp    (%rbx),%ecx
  a8:	00 00                	add    %al,(%rax)
    if (iph->ihl != 5) {
  aa:	0e                   	(bad)
  ab:	0d 00 49 13 3a       	or     $0x3a134900,%eax
  b0:	0b 3b                	or     (%rbx),%edi
  b2:	0b 38                	or     (%rax),%edi
  b4:	0b 00                	or     (%rax),%eax
  b6:	00 0f                	add    %cl,(%rdi)
    pckt->tos = iph->tos;
  b8:	17                   	(bad)
  b9:	01 0b                	add    %ecx,(%rbx)
  bb:	0b 3a                	or     (%rdx),%edi
  bd:	0b 3b                	or     (%rbx),%edi
  bf:	0b 00                	or     (%rax),%eax
    *protocol = iph->protocol;
  c1:	00 10                	add    %dl,(%rax)
  c3:	21 00                	and    %eax,(%rax)
    pckt->flow.proto = *protocol;
  c5:	49 13 37             	adc    (%r15),%rsi
  c8:	05 00 00 11 21       	add    $0x21110000,%eax
    if (iph->frag_off & PCKT_FRAGMENTED) {
  cd:	00 49 13             	add    %cl,0x13(%rcx)
  d0:	00 00                	add    %al,(%rax)
  d2:	12 21                	adc    (%rcx),%ah
  d4:	00 49 13             	add    %cl,0x13(%rcx)
  d7:	37                   	(bad)
  d8:	06                   	(bad)
  d9:	00 00                	add    %al,(%rax)
  db:	13 34 00             	adc    (%rax,%rax,1),%esi
  de:	03 25 49 13 3a 0b    	add    0xb3a1349(%rip),%esp        # b3a142d <_license+0xb39f098>
    if (*protocol == IPPROTO_ICMP) {
  e4:	3b 0b                	cmp    (%rbx),%ecx
  e6:	1c 0f                	sbb    $0xf,%al
  if (icmp_hdr + 1 > data_end) {
  e8:	00 00                	add    %al,(%rax)
  ea:	14 15                	adc    $0x15,%al
  ec:	01 49 13             	add    %ecx,0x13(%rcx)
  ef:	27                   	(bad)
  f0:	19 00                	sbb    %eax,(%rax)
  f2:	00 15 05 00 49 13    	add    %dl,0x13490005(%rip)        # 134900fd <_license+0x1348dd68>
  if (icmp_hdr->type == ICMP_ECHO) {
  f8:	00 00                	add    %al,(%rax)
  fa:	16                   	(bad)
  fb:	0f 00 00             	sldt   (%rax)
  fe:	00 17                	add    %dl,(%rdi)
 100:	15 00 49 13 27       	adc    $0x27134900,%eax
 105:	19 00                	sbb    %eax,(%rax)
 107:	00 18                	add    %bl,(%rax)
 109:	04 01                	add    $0x1,%al
 10b:	49 13 03             	adc    (%r11),%rax
 10e:	25 0b 0b 3a 0b       	and    $0xb3a0b0b,%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
 113:	3b 05 00 00 19 28    	cmp    0x28190000(%rip),%eax        # 28190119 <_license+0x2818dd84>
  icmp_hdr->checksum += 0x0008;
 119:	00 03                	add    %al,(%rbx)
 11b:	25 1c 0f 00 00       	and    $0xf1c,%eax
  iph->ttl = DEFAULT_TTL;
 120:	1a 04 01             	sbb    (%rcx,%rax,1),%al
 123:	49 13 0b             	adc    (%r11),%rcx
 126:	0b 3a                	or     (%rdx),%edi
 128:	0b 3b                	or     (%rbx),%edi
  iph->daddr = iph->saddr;
 12a:	0b 00                	or     (%rax),%eax
 12c:	00 1b                	add    %bl,(%rbx)
  iph->saddr = tmp_addr;
 12e:	0d 00 03 25 49       	or     $0x49250300,%eax
    *csum += *next_iph_u16++;
 133:	13 3a                	adc    (%rdx),%edi
 135:	0b 3b                	or     (%rbx),%edi
 137:	0b 0d 0b 6b 0b 00    	or     0xb6b0b(%rip),%ecx        # b6c48 <_license+0xb48b3>
 13d:	00 1c 2e             	add    %bl,(%rsi,%rbp,1)
 140:	01 03                	add    %eax,(%rbx)
 142:	25 3a 0b 3b 05       	and    $0x53b0b3a,%eax
 147:	27                   	(bad)
 148:	19 49 13             	sbb    %ecx,0x13(%rcx)
 14b:	20 21                	and    %ah,(%rcx)
 14d:	01 00                	add    %eax,(%rax)
 14f:	00 1d 05 00 03 25    	add    %bl,0x25030005(%rip)        # 2503015a <_license+0x2502ddc5>
 155:	3a 0b                	cmp    (%rbx),%cl
 157:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 14a6 <balancer_ingress+0x14a6>
  struct packet_description pckt = {};
 15d:	1e                   	(bad)
 15e:	34 00                	xor    $0x0,%al
 160:	03 25 3a 0b 3b 05    	add    0x53b0b3a(%rip),%esp        # 53b0ca0 <_license+0x53ae90b>
 166:	49 13 00             	adc    (%r8),%rax
 169:	00 1f                	add    %bl,(%rdi)
 16b:	0b 01                	or     (%rcx),%eax
 16d:	00 00                	add    %al,(%rax)
 16f:	20 13                	and    %dl,(%rbx)
 171:	01 03                	add    %eax,(%rbx)
 173:	25 0b 0b 3a 0b       	and    $0xb3a0b0b,%eax
 178:	3b 05 00 00 21 0d    	cmp    0xd210000(%rip),%eax        # d21017e <_license+0xd20dde9>
 17e:	00 03                	add    %al,(%rbx)
 180:	25 49 13 3a 0b       	and    $0xb3a1349,%eax
 185:	3b 05 38 0b 00 00    	cmp    0xb38(%rip),%eax        # cc3 <balancer_ingress+0xcc3>
 18b:	22 13                	and    (%rbx),%dl
 18d:	00 03                	add    %al,(%rbx)
  struct vip_definition vip = {};
 18f:	25 3c 19 00 00       	and    $0x193c,%eax
 194:	23 26                	and    (%rsi),%esp
 196:	00 49 13             	add    %cl,0x13(%rcx)
 199:	00 00                	add    %al,(%rax)
 19b:	24 2e                	and    $0x2e,%al
 19d:	01 03                	add    %eax,(%rbx)
 19f:	25 3a 0b 3b 0b       	and    $0xb3b0b3a,%eax
 1a4:	27                   	(bad)
 1a5:	19 49 13             	sbb    %ecx,0x13(%rcx)
    if (ip6h + 1 > data_end) {
 1a8:	20 21                	and    %ah,(%rcx)
 1aa:	01 00                	add    %eax,(%rax)
 1ac:	00 25 05 00 03 25    	add    %ah,0x25030005(%rip)        # 250301b7 <_license+0x2502de22>
 1b2:	3a 0b                	cmp    (%rbx),%cl
 1b4:	3b 0b                	cmp    (%rbx),%ecx
    *protocol = ip6h->nexthdr;
 1b6:	49 13 00             	adc    (%r8),%rax
 1b9:	00 26                	add    %ah,(%rsi)
    pckt->flow.proto = *protocol;
 1bb:	34 00                	xor    $0x0,%al
 1bd:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0cfd <_license+0xb3ae968>
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1c3:	49 13 00             	adc    (%r8),%rax
 1c6:	00 27                	add    %ah,(%rdi)
 1c8:	2e 01 03             	cs add %eax,(%rbx)
 1cb:	25 3a 0b 3b 0b       	and    $0xb3b0b3a,%eax
 1d0:	27                   	(bad)
 1d1:	19 20                	sbb    %esp,(%rax)
 1d3:	21 01                	and    %eax,(%rcx)
    *protocol = ip6h->nexthdr;
 1d5:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_FRAGMENT) {
 1d7:	28 34 00             	sub    %dh,(%rax,%rax,1)
 1da:	03 26                	add    (%rsi),%esp
 1dc:	3a 0b                	cmp    (%rbx),%cl
 1de:	3b 0b                	cmp    (%rbx),%ecx
 1e0:	49 13 00             	adc    (%r8),%rax
 1e3:	00 29                	add    %ch,(%rcx)
 1e5:	13 01                	adc    (%rcx),%eax
 1e7:	03 26                	add    (%rsi),%esp
 1e9:	0b 0b                	or     (%rbx),%ecx
  if (icmp_hdr + 1 > data_end) {
 1eb:	3a 0b                	cmp    (%rbx),%cl
 1ed:	3b 0b                	cmp    (%rbx),%ecx
 1ef:	00 00                	add    %al,(%rax)
 1f1:	2a 2e                	sub    (%rsi),%ch
 1f3:	01 03                	add    %eax,(%rbx)
 1f5:	26 3a 0b             	es cmp (%rbx),%cl
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 1f8:	3b 0b                	cmp    (%rbx),%ecx
 1fa:	27                   	(bad)
 1fb:	19 49 13             	sbb    %ecx,0x13(%rcx)
 1fe:	20 21                	and    %ah,(%rcx)
 200:	01 00                	add    %eax,(%rax)
 202:	00 2b                	add    %ch,(%rbx)
 204:	0d 00 03 26 49       	or     $0x49260300,%eax
 209:	13 3a                	adc    (%rdx),%edi
 20b:	0b 3b                	or     (%rbx),%edi
 20d:	0b 38                	or     (%rax),%edi
 20f:	0b 00                	or     (%rax),%eax
 211:	00 2c 0d 00 03 26 49 	add    %ch,0x49260300(,%rcx,1)
 218:	13 3a                	adc    (%rdx),%edi
 21a:	0b 3b                	or     (%rbx),%edi
 21c:	0b 0d 0b 6b 0b 00    	or     0xb6b0b(%rip),%ecx        # b6d2d <_license+0xb4998>
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
 222:	00 2d 2e 01 03 26    	add    %ch,0x2603012e(%rip)        # 26030356 <_license+0x2602dfc1>
  ip6h->hop_limit = DEFAULT_TTL;
 228:	3a 0b                	cmp    (%rbx),%cl
 22a:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491b57 <_license+0x1348f7c2>
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
 230:	20 21                	and    %ah,(%rcx)
 232:	01 00                	add    %eax,(%rax)
 234:	00 2e                	add    %ch,(%rsi)
 236:	05 00 03 26 3a       	add    $0x3a260300,%eax
 23b:	0b 3b                	or     (%rbx),%edi
 23d:	05 49 13 00 00       	add    $0x1349,%eax
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
 242:	2f                   	(bad)
 243:	05 00 03 26 3a       	add    $0x3a260300,%eax
 248:	0b 3b                	or     (%rbx),%edi
 24a:	0b 49 13             	or     0x13(%rcx),%ecx
 24d:	00 00                	add    %al,(%rax)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
 24f:	30 34 00             	xor    %dh,(%rax,%rax,1)
 252:	03 26                	add    (%rsi),%esp
 254:	3a 0b                	cmp    (%rbx),%cl
 256:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 15a5 <balancer_ingress+0x15a5>
 25c:	31 2e                	xor    %ebp,(%rsi)
 25e:	01 03                	add    %eax,(%rbx)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 260:	26 3a 0b             	es cmp (%rbx),%cl
 263:	3b 05 27 19 20 21    	cmp    0x21201927(%rip),%eax        # 21201b90 <_license+0x211ff7fb>
 269:	01 00                	add    %eax,(%rax)
 26b:	00 32                	add    %dh,(%rdx)
 26d:	2e 01 03             	cs add %eax,(%rbx)
 270:	26 3a 0b             	es cmp (%rbx),%cl
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 273:	3b 0b                	cmp    (%rbx),%ecx
 275:	27                   	(bad)
 276:	19 20                	sbb    %esp,(%rax)
 278:	21 01                	and    %eax,(%rcx)
 27a:	00 00                	add    %al,(%rax)
 27c:	33 2e                	xor    (%rsi),%ebp
 27e:	01 03                	add    %eax,(%rbx)
 280:	26 3a 0b             	es cmp (%rbx),%cl
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 283:	3b 0b                	cmp    (%rbx),%ecx
 285:	20 21                	and    %ah,(%rcx)
 287:	01 00                	add    %eax,(%rax)
 289:	00 34 2e             	add    %dh,(%rsi,%rbp,1)
 28c:	01 11                	add    %edx,(%rcx)
 28e:	1b 12                	sbb    (%rdx),%edx
 290:	06                   	(bad)
 291:	40 18 7a 19          	sbb    %dil,0x19(%rdx)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 295:	03 26                	add    (%rsi),%esp
 297:	3a 0b                	cmp    (%rbx),%cl
 299:	3b 05 27 19 49 13    	cmp    0x13491927(%rip),%eax        # 13491bc6 <_license+0x1348f831>
 29f:	3f                   	(bad)
 2a0:	19 00                	sbb    %eax,(%rax)
 2a2:	00 35 05 00 02 22    	add    %dh,0x22020005(%rip)        # 220202ad <_license+0x2201df18>
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2a8:	03 26                	add    (%rsi),%esp
 2aa:	3a 0b                	cmp    (%rbx),%cl
 2ac:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 15fb <balancer_ingress+0x15fb>
 2b2:	36 34 00             	ss xor $0x0,%al
 2b5:	02 22                	add    (%rdx),%ah
  if (protocol == IPPROTO_ICMPV6) {
 2b7:	03 25 3a 0b 3b 05    	add    0x53b0b3a(%rip),%esp        # 53b0df7 <_license+0x53aea62>
 2bd:	49 13 00             	adc    (%r8),%rax
  if (icmp_hdr + 1 > data_end) {
 2c0:	00 37                	add    %dh,(%rdi)
 2c2:	34 00                	xor    $0x0,%al
 2c4:	02 22                	add    (%rdx),%ah
 2c6:	03 26                	add    (%rsi),%esp
 2c8:	3a 0b                	cmp    (%rbx),%cl
 2ca:	3b 05 49 13 00 00    	cmp    0x1349(%rip),%eax        # 1619 <balancer_ingress+0x1619>
  if (icmp_hdr->type == ICMP_ECHO) {
 2d0:	38 1d 01 31 13 55    	cmp    %bl,0x55133101(%rip)        # 551333d7 <_license+0x55131042>
 2d6:	23 58 0b             	and    0xb(%rax),%ebx
 2d9:	59                   	pop    %rcx
 2da:	05 57 0b 00 00       	add    $0xb57,%eax
 2df:	39 05 00 02 22 31    	cmp    %eax,0x31220200(%rip)        # 312204e5 <_license+0x3121e150>
 2e5:	13 00                	adc    (%rax),%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
 2e7:	00 3a                	add    %bh,(%rdx)
 2e9:	34 00                	xor    $0x0,%al
 2eb:	02 18                	add    (%rax),%bl
  icmp_hdr->checksum += 0x0008;
 2ed:	31 13                	xor    %edx,(%rbx)
 2ef:	00 00                	add    %al,(%rax)
 2f1:	3b 34 00             	cmp    (%rax,%rax,1),%esi
  iph->ttl = DEFAULT_TTL;
 2f4:	02 22                	add    (%rdx),%ah
 2f6:	31 13                	xor    %edx,(%rbx)
 2f8:	00 00                	add    %al,(%rax)
 2fa:	3c 1d                	cmp    $0x1d,%al
 2fc:	01 31                	add    %esi,(%rcx)
 2fe:	13 11                	adc    (%rcx),%edx
  iph->daddr = iph->saddr;
 300:	1b 12                	sbb    (%rdx),%edx
 302:	06                   	(bad)
  iph->saddr = tmp_addr;
 303:	58                   	pop    %rax
 304:	0b 59 05             	or     0x5(%rcx),%ebx
 307:	57                   	push   %rdi
 308:	0b 00                	or     (%rax),%eax
 30a:	00 3d 05 00 02 18    	add    %bh,0x18020005(%rip)        # 18020315 <_license+0x1801df80>
 310:	31 13                	xor    %edx,(%rbx)
 312:	00 00                	add    %al,(%rax)
 314:	3e 34 00             	ds xor $0x0,%al
 317:	1c 0f                	sbb    $0xf,%al
 319:	31 13                	xor    %edx,(%rbx)
 31b:	00 00                	add    %al,(%rax)
 31d:	3f                   	(bad)
 31e:	1d 01 31 13 11       	sbb    $0x11133101,%eax
 323:	1b 12                	sbb    (%rdx),%edx
 325:	06                   	(bad)
 326:	58                   	pop    %rax
 327:	0b 59 0b             	or     0xb(%rcx),%ebx
 32a:	57                   	push   %rdi
 32b:	0b 00                	or     (%rax),%eax
 32d:	00 40 0b             	add    %al,0xb(%rax)
 330:	01 11                	add    %edx,(%rcx)
 332:	1b 12                	sbb    (%rdx),%edx
 334:	06                   	(bad)
 335:	00 00                	add    %al,(%rax)
 337:	41 34 00             	rex.B xor $0x0,%al
 33a:	1c 0d                	sbb    $0xd,%al
 33c:	31 13                	xor    %edx,(%rbx)
 33e:	00 00                	add    %al,(%rax)
    if (csum >> 16)
 340:	42 0b 01             	rex.X or (%rcx),%eax
 343:	55                   	push   %rbp
 344:	23 00                	and    (%rax),%eax
 346:	00 43 05             	add    %al,0x5(%rbx)
 349:	00 1c 0d 31 13 00 00 	add    %bl,0x1331(,%rcx,1)
 350:	44 34 00             	rex.R xor $0x0,%al
 353:	31 13                	xor    %edx,(%rbx)
 355:	00 00                	add    %al,(%rax)
 357:	45 05 00 1c 0f 31    	rex.RB add $0x310f1c00,%eax
 35d:	13 00                	adc    (%rax),%eax
 35f:	00 46 1d             	add    %al,0x1d(%rsi)
 362:	01 31                	add    %esi,(%rcx)
 364:	13 55 23             	adc    0x23(%rbp),%edx
 367:	58                   	pop    %rax
 368:	0b 59 0b             	or     0xb(%rcx),%ebx
 36b:	57                   	push   %rdi
 36c:	0b 00                	or     (%rax),%eax
 36e:	00 47 1d             	add    %al,0x1d(%rdi)
 371:	00 31                	add    %dh,(%rcx)
 373:	13 11                	adc    (%rcx),%edx
 375:	1b 12                	sbb    (%rdx),%edx
 377:	06                   	(bad)
 378:	58                   	pop    %rax
 379:	0b 59 0b             	or     0xb(%rcx),%ebx
 37c:	57                   	push   %rdi
 37d:	0b 00                	or     (%rax),%eax
 37f:	00 48 1d             	add    %cl,0x1d(%rax)
 382:	01 31                	add    %esi,(%rcx)
 384:	13 55 23             	adc    0x23(%rbp),%edx
 387:	58                   	pop    %rax
 388:	0b 59 0b             	or     0xb(%rcx),%ebx
  return ~csum;
 38b:	00 00                	add    %al,(%rax)
  iph->check = csum;
 38d:	49                   	rex.WB
 38e:	48 00 83 01 18 7d 1b 	rex.W add %al,0x1b7d1801(%rbx)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 395:	00 00                	add    %al,(%rax)
 397:	4a                   	rex.WX
 398:	2e 01 11             	cs add %edx,(%rcx)
 39b:	1b 12                	sbb    (%rdx),%edx
 39d:	06                   	(bad)
 39e:	40 18 7a 19          	sbb    %dil,0x19(%rdx)
 3a2:	03 26                	add    (%rsi),%esp
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 3a4:	3a 0b                	cmp    (%rbx),%cl
 3a6:	3b 0b                	cmp    (%rbx),%ecx
 3a8:	27                   	(bad)
 3a9:	19 36                	sbb    %esi,(%rsi)
 3ab:	0b 49 13             	or     0x13(%rcx),%ecx
 3ae:	00 00                	add    %al,(%rax)
 3b0:	4b 05 00 02 22 03    	rex.WXB add $0x3220200,%rax
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 3b6:	26 3a 0b             	es cmp (%rbx),%cl
 3b9:	3b 0b                	cmp    (%rbx),%ecx
 3bb:	49 13 00             	adc    (%r8),%rax
 3be:	00 4c 05 00          	add    %cl,0x0(%rbp,%rax,1)
 3c2:	02 22                	add    (%rdx),%ah
 3c4:	03 25 3a 0b 3b 0b    	add    0xb3b0b3a(%rip),%esp        # b3b0f04 <_license+0xb3aeb6f>
 3ca:	49 13 00             	adc    (%r8),%rax
 3cd:	00 4d 34             	add    %cl,0x34(%rbp)
 3d0:	00 02                	add    %al,(%rdx)
 3d2:	22 03                	and    (%rbx),%al
  if (protocol == IPPROTO_IPIP) {
 3d4:	26 3a 0b             	es cmp (%rbx),%cl
 3d7:	3b 0b                	cmp    (%rbx),%ecx
 3d9:	49 13 00             	adc    (%r8),%rax
 3dc:	00 4e 26             	add    %cl,0x26(%rsi)
 3df:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_info:

0000000000000000 <.debug_info>:
  void* data = (void*)(long)ctx->data;
       0:	cd 47                	int    $0x47
       2:	00 00                	add    %al,(%rax)
       4:	05 00 01 08 00       	add    $0x80100,%eax
       9:	00 00                	add    %al,(%rax)
       b:	00 01                	add    %al,(%rcx)
       d:	00 1d 00 01 08 00    	add    %bl,0x80100(%rip)        # 80113 <_license+0x7dd7e>
      13:	00 00                	add    %al,(%rax)
      15:	00 00                	add    %al,(%rax)
      17:	00 00                	add    %al,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
      19:	02 00                	add    (%rax),%al
      1b:	00 00                	add    %al,(%rax)
  if (data + nh_off > data_end) {
      1d:	00 00                	add    %al,(%rax)
      1f:	00 00                	add    %al,(%rax)
      21:	00 2e                	add    %ch,(%rsi)
      23:	08 00                	or     %al,(%rax)
      25:	00 00                	add    %al,(%rax)
      27:	0c 00                	or     $0x0,%al
      29:	00 00                	add    %al,(%rax)
      2b:	0c 00                	or     $0x0,%al
      2d:	00 00                	add    %al,(%rax)
  eth_proto = eth->h_proto; 
      2f:	02 7a 01             	add    0x1(%rdx),%bh
      32:	07                   	(bad)
      33:	08 02                	or     %al,(%rdx)
      35:	79 01                	jns    38 <balancer_ingress+0x38>
      37:	07                   	(bad)
      38:	04 02                	add    $0x2,%al
  if (eth_proto == BE_ETH_P_IP) {
      3a:	78 01                	js     3d <balancer_ingress+0x3d>
      3c:	07                   	(bad)
      3d:	01 02                	add    %eax,(%rdx)
      3f:	77 01                	ja     42 <balancer_ingress+0x42>
      41:	07                   	(bad)
      42:	01 02                	add    %eax,(%rdx)
      44:	76 01                	jbe    47 <balancer_ingress+0x47>
      46:	07                   	(bad)
      47:	02 03                	add    (%rbx),%al
      49:	03 54 00 00          	add    0x0(%rax,%rax,1),%edx
  struct packet_description pckt = {};
      4d:	00 00                	add    %al,(%rax)
      4f:	4b 04 02             	rex.WXB add $0x2,%al
      52:	a1 00 04 60 00 00 00 	movabs 0x6405000000600400,%eax
      59:	05 64 
      5b:	00 00                	add    %al,(%rax)
      5d:	00 04 00             	add    %al,(%rax,%rax,1)
      60:	06                   	(bad)
      61:	04 06                	add    $0x6,%al
      63:	01 07                	add    %eax,(%rdi)
      65:	05 08 07 08 06       	add    $0x6080708,%eax
      6a:	73 00                	jae    6c <balancer_ingress+0x6c>
      6c:	00 00                	add    %al,(%rax)
      6e:	01 29                	add    %ebp,(%rcx)
      70:	02 a1 01 09 28 01    	add    0x1280901(%rcx),%ah
      76:	23 0a                	and    (%rdx),%ecx
      78:	07                   	(bad)
      79:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
      7a:	00 00                	add    %al,(%rax)
      7c:	00 01                	add    %al,(%rcx)
      7e:	24 00                	and    $0x0,%al
      80:	0a 09                	or     (%rcx),%cl
      82:	ba 00 00 00 01       	mov    $0x1000000,%edx
  struct vip_definition vip = {};
      87:	25 08 0a 0c cb       	and    $0xcb0c0a08,%eax
      8c:	00 00                	add    %al,(%rax)
      8e:	00 01                	add    %al,(%rcx)
      90:	26 10 0a             	es adc %cl,(%rdx)
      93:	14 22                	adc    $0x22,%al
      95:	01 00                	add    %eax,(%rax)
      97:	00 01                	add    %al,(%rcx)
      99:	27                   	(bad)
      9a:	18 0a                	sbb    %cl,(%rdx)
      9c:	15 33 01 00 00       	adc    $0x133,%eax
    if (iph + 1 > data_end) {
      a1:	01 28                	add    %ebp,(%rax)
      a3:	20 00                	and    %al,(%rax)
      a5:	0b aa 00 00 00 04    	or     0x4000000(%rdx),%ebp
    if (iph->ihl != 5) {
      ab:	b6 00                	mov    $0x0,%dh
      ad:	00 00                	add    %al,(%rax)
      af:	05 64 00 00 00       	add    $0x64,%eax
      b4:	02 00                	add    (%rax),%al
      b6:	06                   	(bad)
    pckt->tos = iph->tos;
      b7:	08 05 04 0b bf 00    	or     %al,0xbf0b04(%rip)        # bf0bc1 <_license+0xbee82c>
      bd:	00 00                	add    %al,(%rax)
      bf:	0c c7                	or     $0xc7,%al
    *protocol = iph->protocol;
      c1:	00 00                	add    %al,(%rax)
      c3:	00 0b                	add    %cl,(%rbx)
    pckt->flow.proto = *protocol;
      c5:	02 1b                	add    (%rbx),%bl
      c7:	06                   	(bad)
      c8:	0a 07                	or     (%rdi),%al
    if (iph->frag_off & PCKT_FRAGMENTED) {
      ca:	04 0b                	add    $0xb,%al
      cc:	d0 00                	rolb   (%rax)
      ce:	00 00                	add    %al,(%rax)
      d0:	0d 13 08 03 35       	or     $0x35030813,%eax
      d5:	0e                   	(bad)
      d6:	dd 00                	fldl   (%rax)
      d8:	00 00                	add    %al,(%rax)
      da:	03 36                	add    (%rsi),%esi
      dc:	00 0f                	add    %cl,(%rdi)
      de:	08 03                	or     %al,(%rbx)
    if (*protocol == IPPROTO_ICMP) {
      e0:	36 0a 0c fe          	ss or  (%rsi,%rdi,8),%cl
      e4:	00 00                	add    %al,(%rax)
      e6:	00 03                	add    %al,(%rbx)
  if (icmp_hdr + 1 > data_end) {
      e8:	37                   	(bad)
      e9:	00 0a                	add    %cl,(%rdx)
      eb:	0f bf 00             	movswl (%rax),%eax
      ee:	00 00                	add    %al,(%rax)
      f0:	03 38                	add    (%rax),%edi
      f2:	00 0a                	add    %cl,(%rdx)
      f4:	10 0a                	adc    %cl,(%rdx)
  if (icmp_hdr->type == ICMP_ECHO) {
      f6:	01 00                	add    %eax,(%rax)
      f8:	00 03                	add    %al,(%rbx)
      fa:	39 00                	cmp    %eax,(%rax)
      fc:	00 00                	add    %al,(%rax)
      fe:	0c 06                	or     $0x6,%al
     100:	01 00                	add    %eax,(%rax)
     102:	00 0e                	add    %cl,(%rsi)
     104:	02 1f                	add    (%rdi),%bl
     106:	06                   	(bad)
     107:	0d 07 08 04 16       	or     $0x16040807,%eax
     10c:	01 00                	add    %eax,(%rax)
     10e:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 178 <balancer_ingress+0x178>
  icmp_hdr->checksum += 0x0008;
     114:	06                   	(bad)
     115:	00 0c 1e             	add    %cl,(%rsi,%rbx,1)
     118:	01 00                	add    %eax,(%rax)
     11a:	00 12                	add    %dl,(%rdx)
     11c:	02 15 06 11 08 01    	add    0x1081106(%rip),%dl        # 1081228 <_license+0x107ee93>
  iph->ttl = DEFAULT_TTL;
     122:	0b 27                	or     (%rdi),%esp
     124:	01 00                	add    %eax,(%rax)
     126:	00 04 b6             	add    %al,(%rsi,%rsi,4)
     129:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
     12b:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 195 <balancer_ingress+0x195>
  iph->saddr = tmp_addr;
     131:	10 00                	adc    %al,(%rax)
    *csum += *next_iph_u16++;
     133:	0b 38                	or     (%rax),%edi
     135:	01 00                	add    %eax,(%rax)
     137:	00 04 b6             	add    %al,(%rsi,%rsi,4)
     13a:	00 00                	add    %al,(%rax)
     13c:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 1a6 <balancer_ingress+0x1a6>
     142:	00 00                	add    %al,(%rax)
     144:	08 16                	or     %dl,(%rsi)
     146:	4f 01 00             	rex.WRXB add %r8,(%r8)
     149:	00 01                	add    %al,(%rcx)
     14b:	3e 02 a1 02 09 28 01 	ds add 0x1280902(%rcx),%ah
     152:	38 0a                	cmp    %cl,(%rdx)
     154:	07                   	(bad)
     155:	81 01 00 00 01 39    	addl   $0x39010000,(%rcx)
  struct packet_description pckt = {};
     15b:	00 0a                	add    %cl,(%rdx)
     15d:	09 92 01 00 00 01    	or     %edx,0x1000001(%rdx)
     163:	3a 08                	cmp    (%rax),%cl
     165:	0a 0c ba             	or     (%rdx,%rdi,4),%cl
     168:	00 00                	add    %al,(%rax)
     16a:	00 01                	add    %al,(%rcx)
     16c:	3b 10                	cmp    (%rax),%edx
     16e:	0a 14 d0             	or     (%rax,%rdx,8),%dl
     171:	01 00                	add    %eax,(%rax)
     173:	00 01                	add    %al,(%rcx)
     175:	3c 18                	cmp    $0x18,%al
     177:	0a 15 33 01 00 00    	or     0x133(%rip),%dl        # 2b0 <balancer_ingress+0x2b0>
     17d:	01 3d 20 00 0b 86    	add    %edi,-0x79f4ffe0(%rip)        # ffffffff860b01a3 <server_id_map+0x36ff6d9c71a3>
     183:	01 00                	add    %eax,(%rax)
     185:	00 04 b6             	add    %al,(%rsi,%rsi,4)
     188:	00 00                	add    %al,(%rax)
     18a:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 1f4 <balancer_ingress+0x1f4>
  struct vip_definition vip = {};
     190:	01 00                	add    %eax,(%rax)
     192:	0b 97 01 00 00 0d    	or     0xd000001(%rdi),%edx
     198:	1a 10                	sbb    (%rax),%dl
     19a:	03 6e 0e             	add    0xe(%rsi),%ebp
     19d:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
     19e:	01 00                	add    %eax,(%rax)
     1a0:	00 03                	add    %al,(%rbx)
     1a2:	6f                   	outsl  %ds:(%rsi),(%dx)
     1a3:	00 0f                	add    %cl,(%rdi)
     1a5:	10 03                	adc    %al,(%rbx)
     1a7:	6f                   	outsl  %ds:(%rsi),(%dx)
    if (ip6h + 1 > data_end) {
     1a8:	0a 17                	or     (%rdi),%dl
     1aa:	bc 01 00 00 03       	mov    $0x3000001,%esp
     1af:	70 00                	jo     1b1 <balancer_ingress+0x1b1>
     1b1:	0a 19                	or     (%rcx),%bl
     1b3:	c4 01 00 00          	(bad)
    *protocol = ip6h->nexthdr;
     1b7:	03 71 00             	add    0x0(%rcx),%esi
    pckt->flow.proto = *protocol;
     1ba:	00 00                	add    %al,(%rax)
     1bc:	0c bf                	or     $0xbf,%al
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1be:	00 00                	add    %al,(%rax)
     1c0:	00 18                	add    %bl,(%rax)
     1c2:	04 22                	add    $0x22,%al
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1c4:	04 bc                	add    $0xbc,%al
     1c6:	01 00                	add    %eax,(%rax)
     1c8:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 232 <balancer_ingress+0x232>
     1ce:	04 00                	add    $0x0,%al
     1d0:	0b d5                	or     %ebp,%edx
     1d2:	01 00                	add    %eax,(%rax)
    *protocol = ip6h->nexthdr;
     1d4:	00 04 b6             	add    %al,(%rsi,%rsi,4)
    if (*protocol == IPPROTO_FRAGMENT) {
     1d7:	00 00                	add    %al,(%rax)
     1d9:	00 10                	add    %dl,(%rax)
     1db:	64 00 00             	add    %al,%fs:(%rax)
     1de:	00 00                	add    %al,(%rax)
     1e0:	02 00                	add    (%rax),%al
     1e2:	08 1b                	or     %bl,(%rbx)
     1e4:	ed                   	in     (%dx),%eax
     1e5:	01 00                	add    %eax,(%rax)
     1e7:	00 01                	add    %al,(%rcx)
     1e9:	45 02 a1 03 09 20 01 	add    0x1200903(%r9),%r12b
  if (icmp_hdr + 1 > data_end) {
     1f0:	40 0a 07             	rex or (%rdi),%al
     1f3:	16                   	(bad)
     1f4:	02 00                	add    (%rax),%al
     1f6:	00 01                	add    %al,(%rcx)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1f8:	41 00 0a             	add    %cl,(%r10)
     1fb:	09 ba 00 00 00 01    	or     %edi,0x1000000(%rdx)
     201:	42 08 0a             	rex.X or %cl,(%rdx)
     204:	0c ba                	or     $0xba,%al
     206:	00 00                	add    %al,(%rax)
     208:	00 01                	add    %al,(%rcx)
     20a:	43 10 0a             	rex.XB adc %cl,(%r10)
     20d:	14 81                	adc    $0x81,%al
     20f:	01 00                	add    %eax,(%rax)
     211:	00 01                	add    %al,(%rcx)
     213:	44 18 00             	sbb    %r8b,(%rax)
     216:	0b 1b                	or     (%rbx),%ebx
     218:	02 00                	add    (%rax),%al
     21a:	00 04 b6             	add    %al,(%rsi,%rsi,4)
     21d:	00 00                	add    %al,(%rax)
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
     21f:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 289 <balancer_ingress+0x289>
  icmp_hdr->icmp6_cksum -= 0x0001;
     225:	03 00                	add    (%rax),%eax
     227:	08 1c 32             	or     %bl,(%rdx,%rsi,1)
  ip6h->hop_limit = DEFAULT_TTL;
     22a:	02 00                	add    (%rax),%al
     22c:	00 05 26 02 a1 04    	add    %al,0x4a10226(%rip)        # 4a10458 <_license+0x4a0e0c3>
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
     232:	09 28                	or     %ebp,(%rax)
     234:	05 20 0a 07 81       	add    $0x81070a20,%eax
     239:	01 00                	add    %eax,(%rax)
     23b:	00 05 21 00 0a 09    	add    %al,0x90a0021(%rip)        # 90a0262 <_license+0x909decd>
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
     241:	64 02 00             	add    %fs:(%rax),%al
     244:	00 05 22 08 0a 0c    	add    %al,0xc0a0822(%rip)        # c0a0a6c <_license+0xc09e6d7>
     24a:	ac                   	lods   %ds:(%rsi),%al
     24b:	02 00                	add    (%rax),%al
     24d:	00 05 23 10 0a 14    	add    %al,0x140a1023(%rip)        # 140a1276 <_license+0x1409eee1>
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
     253:	d0 01                	rolb   (%rcx)
     255:	00 00                	add    %al,(%rax)
     257:	05 24 18 0a 15       	add    $0x150a1824,%eax
     25c:	33 01                	xor    (%rcx),%eax
     25e:	00 00                	add    %al,(%rax)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     260:	05 25 20 00 0b       	add    $0xb002025,%eax
     265:	69 02 00 00 0d 23    	imul   $0x230d0000,(%rdx),%eax
     26b:	14 03                	adc    $0x3,%al
     26d:	3e 0e                	ds (bad)
     26f:	76 02                	jbe    273 <balancer_ingress+0x273>
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     271:	00 00                	add    %al,(%rax)
     273:	03 3f                	add    (%rdi),%edi
     275:	00 0f                	add    %cl,(%rdi)
     277:	10 03                	adc    %al,(%rbx)
     279:	3f                   	(bad)
     27a:	0a 1d bc 01 00 00    	or     0x1bc(%rip),%bl        # 43c <balancer_ingress+0x43c>
     280:	03 40 00             	add    0x0(%rax),%eax
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     283:	0a 1e                	or     (%rsi),%bl
     285:	c4 01 00 00          	(bad)
     289:	03 41 00             	add    0x0(%rcx),%eax
     28c:	00 0a                	add    %cl,(%rdx)
     28e:	1f                   	(bad)
     28f:	a0 02 00 00 03 43 10 	movabs 0x220a104303000002,%al
     296:	0a 22 
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     298:	16                   	(bad)
     299:	01 00                	add    %eax,(%rax)
     29b:	00 03                	add    %al,(%rbx)
     29d:	44 12 00             	adc    (%rax),%r8b
     2a0:	0c a8                	or     $0xa8,%al
     2a2:	02 00                	add    (%rax),%al
     2a4:	00 21                	add    %ah,(%rcx)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2a6:	02 18                	add    (%rax),%bl
     2a8:	06                   	(bad)
     2a9:	20 07                	and    %al,(%rdi)
     2ab:	02 0b                	add    (%rbx),%cl
     2ad:	b1 02                	mov    $0x2,%cl
     2af:	00 00                	add    %al,(%rax)
     2b1:	0d 26 08 03 48       	or     $0x48030826,%eax
     2b6:	0a 24 bf             	or     (%rdi,%rdi,4),%ah
  if (protocol == IPPROTO_ICMPV6) {
     2b9:	00 00                	add    %al,(%rax)
     2bb:	00 03                	add    %al,(%rbx)
     2bd:	49 00 0a             	rex.WB add %cl,(%r10)
  if (icmp_hdr + 1 > data_end) {
     2c0:	25 bf 00 00 00       	and    $0xbf,%eax
     2c5:	03 4a 04             	add    0x4(%rdx),%ecx
     2c8:	00 08                	add    %cl,(%rax)
     2ca:	27                   	(bad)
     2cb:	d4                   	(bad)
     2cc:	02 00                	add    (%rax),%al
  if (icmp_hdr->type == ICMP_ECHO) {
     2ce:	00 05 2f 02 a1 05    	add    %al,0x5a1022f(%rip)        # 5a10503 <_license+0x5a0e16e>
     2d4:	09 28                	or     %ebp,(%rax)
     2d6:	05 29 0a 07 06       	add    $0x6070a29,%eax
     2db:	03 00                	add    (%rax),%eax
     2dd:	00 05 2a 00 0a 09    	add    %al,0x90a002a(%rip)        # 90a030d <_license+0x909df78>
     2e3:	17                   	(bad)
     2e4:	03 00                	add    (%rax),%eax
     2e6:	00 05 2b 08 0a 0c    	add    %al,0xc0a082b(%rip)        # c0a0b17 <_license+0xc09e782>
  icmp_hdr->checksum += 0x0008;
     2ec:	94                   	xchg   %eax,%esp
     2ed:	03 00                	add    (%rax),%eax
     2ef:	00 05 2c 10 0a 14    	add    %al,0x140a102c(%rip)        # 140a1321 <_license+0x1409ef8c>
  iph->ttl = DEFAULT_TTL;
     2f5:	b1 03                	mov    $0x3,%cl
     2f7:	00 00                	add    %al,(%rax)
     2f9:	05 2d 18 0a 15       	add    $0x150a182d,%eax
     2fe:	33 01                	xor    (%rcx),%eax
  iph->daddr = iph->saddr;
     300:	00 00                	add    %al,(%rax)
     302:	05 2e 20 00 0b       	add    $0xb00202e,%eax
     307:	0b 03                	or     (%rbx),%eax
     309:	00 00                	add    %al,(%rax)
     30b:	04 b6                	add    $0xb6,%al
     30d:	00 00                	add    %al,(%rax)
     30f:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 379 <balancer_ingress+0x379>
     315:	09 00                	or     %eax,(%rax)
     317:	0b 1c 03             	or     (%rbx,%rax,1),%ebx
     31a:	00 00                	add    %al,(%rax)
     31c:	0d 2e 28 03 1a       	or     $0x1a03282e,%eax
     321:	0e                   	(bad)
     322:	29 03                	sub    %eax,(%rbx)
     324:	00 00                	add    %al,(%rax)
     326:	03 1b                	add    (%rbx),%ebx
     328:	00 0f                	add    %cl,(%rdi)
     32a:	10 03                	adc    %al,(%rbx)
     32c:	1b 0a                	sbb    (%rdx),%ecx
     32e:	28 bc 01 00 00 03 1c 	sub    %bh,0x1c030000(%rcx,%rax,1)
     335:	00 0a                	add    %cl,(%rdx)
     337:	29 c4                	sub    %eax,%esp
     339:	01 00                	add    %eax,(%rax)
     33b:	00 03                	add    %al,(%rbx)
     33d:	1d 00 00 0e 48       	sbb    $0x480e0000,%eax
    if (csum >> 16)
     342:	03 00                	add    (%rax),%eax
     344:	00 03                	add    %al,(%rbx)
     346:	1f                   	(bad)
     347:	10 0f                	adc    %cl,(%rdi)
     349:	10 03                	adc    %al,(%rbx)
     34b:	1f                   	(bad)
     34c:	0a 2a                	or     (%rdx),%ch
     34e:	bc 01 00 00 03       	mov    $0x3000001,%esp
     353:	20 00                	and    %al,(%rax)
     355:	0a 2b                	or     (%rbx),%ch
     357:	c4 01 00 00          	(bad)
     35b:	03 21                	add    (%rcx),%esp
     35d:	00 00                	add    %al,(%rax)
     35f:	0e                   	(bad)
     360:	67 03 00             	add    (%eax),%eax
     363:	00 03                	add    %al,(%rbx)
     365:	23 20                	and    (%rax),%esp
     367:	0f 04                	(bad)
     369:	03 23                	add    (%rbx),%esp
     36b:	0a 2c bf             	or     (%rdi,%rdi,4),%ch
     36e:	00 00                	add    %al,(%rax)
     370:	00 03                	add    %al,(%rbx)
     372:	24 00                	and    $0x0,%al
     374:	0a 2d 88 03 00 00    	or     0x388(%rip),%ch        # 702 <balancer_ingress+0x702>
     37a:	03 25 00 00 0a 22    	add    0x220a0000(%rip),%esp        # 220a0380 <_license+0x2209dfeb>
     380:	16                   	(bad)
     381:	01 00                	add    %eax,(%rax)
     383:	00 03                	add    %al,(%rbx)
     385:	27                   	(bad)
     386:	24 00                	and    $0x0,%al
     388:	04 a0                	add    $0xa0,%al
     38a:	02 00                	add    (%rax),%al
  return ~csum;
     38c:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 3f6 <balancer_ingress+0x3f6>
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     392:	02 00                	add    (%rax),%al
     394:	0b 99 03 00 00 0d    	or     0xd000003(%rcx),%ebx
     39a:	31 10                	xor    %edx,(%rax)
     39c:	03 4e 0a             	add    0xa(%rsi),%ecx
     39f:	2f                   	(bad)
     3a0:	bf 00 00 00 03       	mov    $0x3000000,%edi
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     3a5:	4f 00 0a             	rex.WRXB add %r9b,(%r10)
     3a8:	30 fe                	xor    %bh,%dh
     3aa:	00 00                	add    %al,(%rax)
     3ac:	00 03                	add    %al,(%rbx)
     3ae:	50                   	push   %rax
     3af:	08 00                	or     %al,(%rax)
     3b1:	0b b6 03 00 00 04    	or     0x4000003(%rsi),%esi
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     3b7:	b6 00                	mov    $0x0,%dh
     3b9:	00 00                	add    %al,(%rax)
     3bb:	10 64 00 00          	adc    %ah,0x0(%rax,%rax,1)
     3bf:	00 e8                	add    %ch,%al
     3c1:	03 00                	add    (%rax),%eax
     3c3:	08 32                	or     %dh,(%rdx)
     3c5:	ce                   	(bad)
     3c6:	03 00                	add    (%rax),%eax
     3c8:	00 05 40 02 a1 06    	add    %al,0x6a10240(%rip)        # 6a1060e <_license+0x6a0e279>
     3ce:	09 28                	or     %ebp,(%rax)
     3d0:	05 32 0a 07 32       	add    $0x32070a32,%eax
  if (protocol == IPPROTO_IPIP) {
     3d5:	04 00                	add    $0x0,%al
     3d7:	00 05 33 00 0a 09    	add    %al,0x90a0033(%rip)        # 90a0410 <_license+0x909e07b>
     3dd:	ba 00 00 00 05       	mov    $0x5000000,%edx
     3e2:	34 08                	xor    $0x8,%al
     3e4:	0a 0c ba             	or     (%rdx,%rdi,4),%cl
     3e7:	00 00                	add    %al,(%rax)
     3e9:	00 05 35 10 0a 14    	add    %al,0x140a1035(%rip)        # 140a1424 <_license+0x1409f08f>
     3ef:	43 04 00             	rex.XB add $0x0,%al
     3f2:	00 05 36 18 0a 15    	add    %al,0x150a1836(%rip)        # 150a1c2e <_license+0x1509f899>
     3f8:	33 01                	xor    (%rcx),%eax
  tcp = data + off;
     3fa:	00 00                	add    %al,(%rax)
     3fc:	05 37 20 0a 33       	add    $0x330a2037,%eax
     401:	54                   	push   %rsp
     402:	04 00                	add    $0x0,%al
  if (tcp + 1 > data_end) {
     404:	00 05 38 28 09 20    	add    %al,0x20092838(%rip)        # 20092c42 <_license+0x200908ad>
     40a:	05 38 0a 07 06       	add    $0x6070a38,%eax
     40f:	03 00                	add    (%rax),%eax
  if (tcp->syn) {
     411:	00 05 38 00 0a 09    	add    %al,0x90a0038(%rip)        # 90a044f <_license+0x909e0ba>
     417:	17                   	(bad)
     418:	03 00                	add    (%rax),%eax
     41a:	00 05 38 08 0a 0c    	add    %al,0xc0a0838(%rip)        # c0a0c58 <_license+0xc09e8c3>
    pckt->flags |= F_SYN_SET;
     420:	94                   	xchg   %eax,%esp
     421:	03 00                	add    (%rax),%eax
     423:	00 05 38 10 0a 14    	add    %al,0x140a1038(%rip)        # 140a1461 <_license+0x1409f0cc>
      pckt->flow.src = iph->saddr;
     429:	b1 03                	mov    $0x3,%cl
     42b:	00 00                	add    %al,(%rax)
      pckt->flow.dst = iph->daddr;
     42d:	05 38 18 00 00       	add    $0x1838,%eax
     432:	0b 37                	or     (%rdi),%esi
     434:	04 00                	add    $0x0,%al
  if (protocol == IPPROTO_ICMPV6) {
     436:	00 04 b6             	add    %al,(%rsi,%rsi,4)
     439:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
     43b:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 4a5 <balancer_ingress+0x4a5>
     441:	0c 00                	or     $0x0,%al
     443:	0b 48 04             	or     0x4(%rax),%ecx
     446:	00 00                	add    %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     448:	04 b6                	add    $0xb6,%al
     44a:	00 00                	add    %al,(%rax)
     44c:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 4b6 <balancer_ingress+0x4b6>
     452:	80 00 04             	addb   $0x4,(%rax)
     455:	5f                   	pop    %rdi
     456:	04 00                	add    $0x0,%al
     458:	00 11                	add    %dl,(%rcx)
     45a:	64 00 00             	add    %al,%fs:(%rax)
     45d:	00 00                	add    %al,(%rax)
     45f:	0b 08                	or     (%rax),%ecx
     461:	04 00                	add    $0x0,%al
     463:	00 08                	add    %cl,(%rax)
     465:	34 6f                	xor    $0x6f,%al
     467:	04 00                	add    $0x0,%al
     469:	00 05 49 02 a1 07    	add    %al,0x7a10249(%rip)        # 7a106b8 <_license+0x7a0e323>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     46f:	09 28                	or     %ebp,(%rax)
     471:	05 43 0a 07 a5       	add    $0xa5070a43,%eax
       sizeof(struct icmp6hdr)) > data_end) {
     476:	00 00                	add    %al,(%rax)
     478:	00 05 44 00 0a 09    	add    %al,0x90a0044(%rip)        # 90a04c2 <_license+0x909e12d>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     47e:	ba 00 00 00 05       	mov    $0x5000000,%edx
     483:	45 08 0a             	or     %r9b,(%r10)
     486:	0c ba                	or     $0xba,%al
     488:	00 00                	add    %al,(%rax)
     48a:	00 05 46 10 0a 14    	add    %al,0x140a1046(%rip)        # 140a14d6 <_license+0x1409f141>
     490:	a1 04 00 00 05 47 18 	movabs 0x150a184705000004,%eax
     497:	0a 15 
     499:	33 01                	xor    (%rcx),%eax
     49b:	00 00                	add    %al,(%rax)
     49d:	05 48 20 00 0b       	add    $0xb002048,%eax
     4a2:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
     4a3:	04 00                	add    $0x0,%al
     4a5:	00 04 b6             	add    %al,(%rsi,%rsi,4)
     4a8:	00 00                	add    %al,(%rax)
     4aa:	00 12                	add    %dl,(%rdx)
     4ac:	64 00 00             	add    %al,%fs:(%rax)
     4af:	00 00                	add    %al,(%rax)
  tcp = data + off;
     4b1:	02 00                	add    (%rax),%al
     4b3:	02 00                	add    (%rax),%al
  if (is_ipv6) {
     4b5:	08 35 c0 04 00 00    	or     %dh,0x4c0(%rip)        # 97b <balancer_ingress+0x97b>
  if (tcp + 1 > data_end) {
     4bb:	05 52 02 a1 08       	add    $0x8a10252,%eax
     4c0:	09 28                	or     %ebp,(%rax)
     4c2:	05 4c 0a 07 a5       	add    $0xa5070a4c,%eax
  if (tcp->syn) {
     4c7:	00 00                	add    %al,(%rax)
     4c9:	00 05 4d 00 0a 09    	add    %al,0x90a004d(%rip)        # 90a051c <_license+0x909e187>
     4cf:	ba 00 00 00 05       	mov    $0x5000000,%edx
    pckt->flags |= F_SYN_SET;
     4d4:	4e 08 0a             	rex.WRX or %r9b,(%rdx)
     4d7:	0c f2                	or     $0xf2,%al
     4d9:	04 00                	add    $0x0,%al
     4db:	00 05 4f 10 0a 14    	add    %al,0x140a104f(%rip)        # 140a1530 <_license+0x1409f19b>
     4e1:	25 05 00 00 05       	and    $0x5000005,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     4e6:	50                   	push   %rax
     4e7:	18 0a                	sbb    %cl,(%rdx)
     4e9:	15 33 01 00 00       	adc    $0x133,%eax
     4ee:	05 51 20 00 0b       	add    $0xb002051,%eax
    if (!icmp_ptb_v6_stats) {
     4f3:	f7 04 00 00 0d 36 14 	testl  $0x14360d00,(%rax,%rax,1)
    icmp_ptb_v6_stats->v1 += 1;
     4fa:	03 54 0e 04          	add    0x4(%rsi,%rcx,1),%edx
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4fe:	05 00 00 03 55       	add    $0x55030000,%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     503:	00 0f                	add    %cl,(%rdi)
     505:	10 03                	adc    %al,(%rbx)
     507:	55                   	push   %rbp
     508:	0a 2a                	or     (%rdx),%ch
     50a:	bc 01 00 00 03       	mov    $0x3000001,%esp
  if (ip6h + 1 > data_end) {
     50f:	56                   	push   %rsi
     510:	00 0a                	add    %cl,(%rdx)
     512:	2b c4                	sub    %esp,%eax
     514:	01 00                	add    %eax,(%rax)
     516:	00 03                	add    %al,(%rbx)
     518:	57                   	push   %rdi
     519:	00 00                	add    %al,(%rax)
     51b:	0a 24 16             	or     (%rsi,%rdx,1),%ah
  pckt->flow.proto = ip6h->nexthdr;
     51e:	01 00                	add    %eax,(%rax)
     520:	00 03                	add    %al,(%rbx)
     522:	59                   	pop    %rcx
     523:	10 00                	adc    %al,(%rax)
  pckt->flags |= F_ICMP;
     525:	0b 2a                	or     (%rdx),%ebp
     527:	05 00 00 04 b6       	add    $0xb6040000,%eax
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     52c:	00 00                	add    %al,(%rax)
     52e:	00 10                	add    %dl,(%rax)
     530:	64 00 00             	add    %al,%fs:(%rax)
     533:	00 00                	add    %al,(%rax)
     535:	10 00                	adc    %al,(%rax)
     537:	08 37                	or     %dh,(%rdi)
     539:	42 05 00 00 05 5b    	rex.X add $0x5b050000,%eax
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     53f:	02 a1 09 09 28 05    	add    0x5280909(%rcx),%ah
     545:	55                   	push   %rbp
     546:	0a 07                	or     (%rdi),%al
     548:	74 05                	je     54f <balancer_ingress+0x54f>
     54a:	00 00                	add    %al,(%rax)
     54c:	05 56 00 0a 09       	add    $0x90a0056,%eax
     551:	ba 00 00 00 05       	mov    $0x5000000,%edx
     556:	57                   	push   %rdi
     557:	08 0a                	or     %cl,(%rdx)
     559:	0c 85                	or     $0x85,%al
     55b:	05 00 00 05 58       	add    $0x58050000,%eax
     560:	10 0a                	adc    %cl,(%rdx)
     562:	14 25                	adc    $0x25,%al
     564:	05 00 00 05 59       	add    $0x59050000,%eax
     569:	18 0a                	sbb    %cl,(%rdx)
     56b:	15 33 01 00 00       	adc    $0x133,%eax
     570:	05 5a 20 00 0b       	add    $0xb00205a,%eax
     575:	79 05                	jns    57c <balancer_ingress+0x57c>
     577:	00 00                	add    %al,(%rax)
     579:	04 b6                	add    $0xb6,%al
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     57b:	00 00                	add    %al,(%rax)
     57d:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 5e7 <balancer_ingress+0x5e7>
     583:	06                   	(bad)
     584:	00 0b                	add    %cl,(%rbx)
     586:	8a 05 00 00 0d 3a    	mov    0x3a0d0000(%rip),%al        # 3a0d058c <_license+0x3a0ce1f7>
     58c:	10 03                	adc    %al,(%rbx)
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
     58e:	5d                   	pop    %rbp
     58f:	0a 38                	or     (%rax),%bh
     591:	fe 00                	incb   (%rax)
     593:	00 00                	add    %al,(%rax)
     595:	03 5e 00             	add    0x0(%rsi),%ebx
     598:	0a 39                	or     (%rcx),%bh
     59a:	fe 00                	incb   (%rax)
     59c:	00 00                	add    %al,(%rax)
     59e:	03 5f 08             	add    0x8(%rdi),%ebx
     5a1:	00 08                	add    %cl,(%rax)
     5a3:	3b ad 05 00 00 05    	cmp    0x5000005(%rbp),%ebp
     5a9:	64 02 a1 0a 09 28 05 	add    %fs:0x528090a(%rcx),%ah
  if (decap_dst_flags) {
     5b0:	5e                   	pop    %rsi
     5b1:	0a 07                	or     (%rdi),%al
     5b3:	74 05                	je     5ba <balancer_ingress+0x5ba>
     5b5:	00 00                	add    %al,(%rax)
     5b7:	05 5f 00 0a 09       	add    $0x90a005f,%eax
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     5bc:	ba 00 00 00 05       	mov    $0x5000000,%edx
     5c1:	60                   	(bad)
     5c2:	08 0a                	or     %cl,(%rdx)
     5c4:	0c ba                	or     $0xba,%al
     5c6:	00 00                	add    %al,(%rax)
    if (!data_stats) {
     5c8:	00 05 61 10 0a 14    	add    %al,0x140a1061(%rip)        # 140a162f <_license+0x1409f29a>
     5ce:	25 05 00 00 05       	and    $0x5000005,%eax
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5d3:	62                   	(bad)
     5d4:	18 0a                	sbb    %cl,(%rdx)
     5d6:	15 33 01 00 00       	adc    $0x133,%eax
     5db:	05 63 20 00 08       	add    $0x8002063,%eax
     5e0:	3c ea                	cmp    $0xea,%al
    if (!--ip6h->hop_limit) {
     5e2:	05 00 00 05 6c       	add    $0x6c050000,%eax
     5e7:	02 a1 0b 09 28 05    	add    0x528090b(%rcx),%ah
     5ed:	66 0a 07             	data16 or (%rdi),%al
     5f0:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5f1:	00 00                	add    %al,(%rax)
     5f3:	00 05 67 00 0a 09    	add    %al,0x90a0067(%rip)        # 90a0660 <_license+0x909e2cb>
     5f9:	ba 00 00 00 05       	mov    $0x5000000,%edx
     5fe:	68 08 0a 0c 64       	push   $0x640c0a08
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     603:	02 00                	add    (%rax),%al
     605:	00 05 69 10 0a 14    	add    %al,0x140a1069(%rip)        # 140a1674 <_license+0x1409f2df>
     60b:	81 01 00 00 05 6a    	addl   $0x6a050000,(%rcx)
     611:	18 0a                	sbb    %cl,(%rdx)
     613:	15 33 01 00 00       	adc    $0x133,%eax
    new_eth->h_proto = BE_ETH_P_IPV6;
     618:	05 6b 20 00 08       	add    $0x800206b,%eax
     61d:	3d 27 06 00 00       	cmp    $0x627,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     622:	05 75 02 a1 0c       	add    $0xca10275,%eax
     627:	09 28                	or     %ebp,(%rax)
     629:	05 6f 0a 07 74       	add    $0x74070a6f,%eax
     62e:	05 00 00 05 70       	add    $0x70050000,%eax
     633:	00 0a                	add    %cl,(%rdx)
     635:	09 ba 00 00 00 05    	or     %edi,0x5000000(%rdx)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     63b:	71 08                	jno    645 <balancer_ingress+0x645>
     63d:	0a 0c 85 05 00 00 05 	or     0x5000005(,%rax,4),%cl
     644:	72 10                	jb     656 <balancer_ingress+0x656>
     646:	0a 14 59             	or     (%rcx,%rbx,2),%dl
  if (!data_stats) {
     649:	06                   	(bad)
     64a:	00 00                	add    %al,(%rax)
     64c:	05 73 18 0a 15       	add    $0x150a1873,%eax
     651:	33 01                	xor    (%rcx),%eax
     653:	00 00                	add    %al,(%rax)
    data_stats->v2 += 1;
     655:	05 74 20 00 0b       	add    $0xb002074,%eax
  if (action >= 0) {
     65a:	5e                   	pop    %rsi
     65b:	06                   	(bad)
     65c:	00 00                	add    %al,(%rax)
     65e:	04 b6                	add    $0xb6,%al
     660:	00 00                	add    %al,(%rax)
     662:	00 10                	add    %dl,(%rax)
  if (decap_dst_flags) {
     664:	64 00 00             	add    %al,%fs:(%rax)
  if (action >= 0) {
     667:	00 00                	add    %al,(%rax)
     669:	04 00                	add    $0x0,%al
     66b:	08 3e                	or     %bh,(%rsi)
     66d:	76 06                	jbe    675 <balancer_ingress+0x675>
     66f:	00 00                	add    %al,(%rax)
     671:	05 7e 02 a1 0d       	add    $0xda1027e,%eax
     676:	09 28                	or     %ebp,(%rax)
     678:	05 78 0a 07 74       	add    $0x74070a78,%eax
     67d:	05 00 00 05 79       	add    $0x79050000,%eax
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     682:	00 0a                	add    %cl,(%rdx)
     684:	09 ba 00 00 00 05    	or     %edi,0x5000000(%rdx)
    if (xpop_stats_data) {
     68a:	7a 08                	jp     694 <balancer_ingress+0x694>
     68c:	0a 0c a8             	or     (%rax,%rbp,4),%cl
        xpop_stats_data->v2 += 1; // IPv6 inner packets
     68f:	06                   	(bad)
     690:	00 00                	add    %al,(%rax)
     692:	05 7b 10 0a 14       	add    $0x140a107b,%eax
     697:	81 01 00 00 05 7c    	addl   $0x7c050000,(%rcx)
  bpf_tail_call(ctx, &subprograms, i);
     69d:	18 0a                	sbb    %cl,(%rdx)
     69f:	15 33 01 00 00       	adc    $0x133,%eax
     6a4:	05 7d 20 00 0b       	add    $0xb00207d,%eax
     6a9:	ad                   	lods   %ds:(%rsi),%eax
     6aa:	06                   	(bad)
     6ab:	00 00                	add    %al,(%rax)
     6ad:	0d 4c 68 03 8e       	or     $0x8e03684c,%eax
     6b2:	0a 3f                	or     (%rdi),%bh
     6b4:	fe 00                	incb   (%rax)
     6b6:	00 00                	add    %al,(%rax)
     6b8:	03 8f 00 0a 40 fe    	add    -0x1bff600(%rdi),%ecx
     6be:	00 00                	add    %al,(%rax)
     6c0:	00 03                	add    %al,(%rbx)
     6c2:	90                   	nop
     6c3:	08 0a                	or     %cl,(%rdx)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     6c5:	41 fe 00             	incb   (%r8)
     6c8:	00 00                	add    %al,(%rax)
     6ca:	03 91 10 0a 42 fe    	add    -0x1bdf5f0(%rcx),%edx
     6d0:	00 00                	add    %al,(%rax)
     6d2:	00 03                	add    %al,(%rbx)
     6d4:	92                   	xchg   %eax,%edx
     6d5:	18 0a                	sbb    %cl,(%rdx)
     6d7:	43 fe 00             	rex.XB incb (%r8)
     6da:	00 00                	add    %al,(%rax)
     6dc:	03 93 20 0a 44 fe    	add    -0x1bbf5e0(%rbx),%edx
     6e2:	00 00                	add    %al,(%rax)
     6e4:	00 03                	add    %al,(%rbx)
     6e6:	94                   	xchg   %eax,%esp
     6e7:	28 0a                	sub    %cl,(%rdx)
     6e9:	45 fe 00             	rex.RB incb (%r8)
     6ec:	00 00                	add    %al,(%rax)
     6ee:	03 95 30 0a 46 fe    	add    -0x1b9f5d0(%rbp),%edx
     6f4:	00 00                	add    %al,(%rax)
     6f6:	00 03                	add    %al,(%rbx)
  if (decap_dst_flags) {
     6f8:	96                   	xchg   %eax,%esi
     6f9:	38 0a                	cmp    %cl,(%rdx)
     6fb:	47 fe 00             	rex.RXB incb (%r8)
     6fe:	00 00                	add    %al,(%rax)
     700:	03 97 40 0a 48 fe    	add    -0x1b7f5c0(%rdi),%edx
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     706:	00 00                	add    %al,(%rax)
     708:	00 03                	add    %al,(%rbx)
     70a:	98                   	cwtl
     70b:	48 0a 49 fe          	rex.W or -0x2(%rcx),%cl
     70f:	00 00                	add    %al,(%rax)
     711:	00 03                	add    %al,(%rbx)
    if (!data_stats) {
     713:	99                   	cltd
     714:	50                   	push   %rax
     715:	0a 4a fe             	or     -0x2(%rdx),%cl
     718:	00 00                	add    %al,(%rax)
     71a:	00 03                	add    %al,(%rbx)
    data_stats->v1 += 1;
     71c:	9a                   	(bad)
     71d:	58                   	pop    %rax
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     71e:	0a 4b fe             	or     -0x2(%rbx),%cl
     721:	00 00                	add    %al,(%rax)
     723:	00 03                	add    %al,(%rbx)
     725:	9b                   	fwait
     726:	60                   	(bad)
     727:	00 08                	add    %cl,(%rax)
     729:	4d 33 07             	xor    (%r15),%r8
    csum = iph->check + 0x0001;
     72c:	00 00                	add    %al,(%rax)
     72e:	05 87 02 a1 0e       	add    $0xea10287,%eax
     733:	09 28                	or     %ebp,(%rax)
    iph->check = (csum & 0xffff) + (csum >> 16);
     735:	05 81 0a 07 74       	add    $0x74070a81,%eax
     73a:	05 00 00 05 82       	add    $0x82050000,%eax
     73f:	00 0a                	add    %cl,(%rdx)
    if (!--iph->ttl) {
     741:	09 ba 00 00 00 05    	or     %edi,0x5000000(%rdx)
     747:	83 08 0a             	orl    $0xa,(%rax)
     74a:	0c 65                	or     $0x65,%al
     74c:	07                   	(bad)
     74d:	00 00                	add    %al,(%rax)
     74f:	05 84 10 0a 14       	add    $0x140a1084,%eax
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     754:	81 01 00 00 05 85    	addl   $0x85050000,(%rcx)
     75a:	18 0a                	sbb    %cl,(%rdx)
     75c:	15 33 01 00 00       	adc    $0x133,%eax
     761:	05 86 20 00 0b       	add    $0xb002086,%eax
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     766:	6a 07                	push   $0x7
     768:	00 00                	add    %al,(%rax)
     76a:	0d 4f 28 03 a7       	or     $0xa703284f,%eax
     76f:	0a 3f                	or     (%rdi),%bh
     771:	fe 00                	incb   (%rax)
    new_eth->h_proto = BE_ETH_P_IP;
     773:	00 00                	add    %al,(%rax)
     775:	03 a8 00 0a 43 fe    	add    -0x1bcf600(%rax),%ebp
     77b:	00 00                	add    %al,(%rax)
     77d:	00 03                	add    %al,(%rbx)
     77f:	a9 08 0a 41 fe       	test   $0xfe410a08,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     784:	00 00                	add    %al,(%rax)
     786:	00 03                	add    %al,(%rbx)
     788:	aa                   	stos   %al,%es:(%rdi)
     789:	10 0a                	adc    %cl,(%rdx)
      if (!decap_v6(xdp, data, data_end, true)) {
     78b:	44 fe 00             	rex.R incb (%rax)
     78e:	00 00                	add    %al,(%rax)
     790:	03 ab 18 0a 4e fe    	add    -0x1b1f5e8(%rbx),%ebp
     796:	00 00                	add    %al,(%rax)
     798:	00 03                	add    %al,(%rbx)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     79a:	ac                   	lods   %ds:(%rsi),%al
     79b:	20 00                	and    %al,(%rax)
     79d:	08 50 a8             	or     %dl,-0x58(%rax)
     7a0:	07                   	(bad)
     7a1:	00 00                	add    %al,(%rax)
     7a3:	05 90 02 a1 0f       	add    $0xfa10290,%eax
  if (!data_stats) {
     7a8:	09 28                	or     %ebp,(%rax)
     7aa:	05 8a 0a 07 74       	add    $0x74070a8a,%eax
     7af:	05 00 00 05 8b       	add    $0x8b050000,%eax
    data_stats->v2 += 1;
     7b4:	00 0a                	add    %cl,(%rdx)
     7b6:	09 ba 00 00 00 05    	or     %edi,0x5000000(%rdx)
  if (action >= 0) {
     7bc:	8c 08                	mov    %cs,(%rax)
     7be:	0a 0c 85 05 00 00 05 	or     0x5000005(,%rax,4),%cl
     7c5:	8d 10                	lea    (%rax),%edx
     7c7:	0a 14 d0             	or     (%rax,%rdx,8),%dl
     7ca:	01 00                	add    %eax,(%rax)
     7cc:	00 05 8e 18 0a 15    	add    %al,0x150a188e(%rip)        # 150a2060 <_license+0x1509fccb>
     7d2:	33 01                	xor    (%rcx),%eax
     7d4:	00 00                	add    %al,(%rax)
     7d6:	05 8f 20 00 08       	add    $0x800208f,%eax
     7db:	51                   	push   %rcx
     7dc:	e5 07                	in     $0x7,%eax
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     7de:	00 00                	add    %al,(%rax)
     7e0:	05 a3 02 a1 10       	add    $0x10a102a3,%eax
     7e5:	09 28                	or     %ebp,(%rax)
     7e7:	05 9d 0a 07 a5       	add    $0xa5070a9d,%eax
    if (xpop_stats_data) {
     7ec:	00 00                	add    %al,(%rax)
        xpop_stats_data->v1 += 1; // IPv4 inner packets
     7ee:	00 05 9e 00 0a 09    	add    %al,0x90a009e(%rip)        # 90a0892 <_license+0x909e4fd>
     7f4:	ba 00 00 00 05       	mov    $0x5000000,%edx
     7f9:	9f                   	lahf
     7fa:	08 0a                	or     %cl,(%rdx)
  bpf_tail_call(ctx, &subprograms, i);
     7fc:	0c ba                	or     $0xba,%al
     7fe:	00 00                	add    %al,(%rax)
     800:	00 05 a0 10 0a 14    	add    %al,0x140a10a0(%rip)        # 140a18a6 <_license+0x1409f511>
     806:	17                   	(bad)
     807:	08 00                	or     %al,(%rax)
     809:	00 05 a1 18 0a 15    	add    %al,0x150a18a1(%rip)        # 150a20b0 <_license+0x1509fd1b>
     80f:	33 01                	xor    (%rcx),%eax
     811:	00 00                	add    %al,(%rax)
     813:	05 a2 20 00 0b       	add    $0xb0020a2,%eax
     818:	1c 08                	sbb    $0x8,%al
     81a:	00 00                	add    %al,(%rax)
     81c:	04 b6                	add    $0xb6,%al
     81e:	00 00                	add    %al,(%rax)
     820:	00 12                	add    %dl,(%rdx)
     822:	64 00 00             	add    %al,%fs:(%rax)
  udp = data + off;
     825:	00 fe                	add    %bh,%dh
  if (is_ipv6) {
     827:	ff                   	(bad)
     828:	ff 00                	incl   (%rax)
  udp = data + off;
     82a:	00 08                	add    %cl,(%rax)
     82c:	52                   	push   %rdx
  if (udp + 1 > data_end) {
     82d:	36 08 00             	ss or  %al,(%rax)
     830:	00 05 dc 02 a1 11    	add    %al,0x11a102dc(%rip)        # 11a10b12 <_license+0x11a0e77d>
     836:	09 28                	or     %ebp,(%rax)
     838:	05 d6 0a 07 74       	add    $0x74070ad6,%eax
     83d:	05 00 00 05 d7       	add    $0xd7050000,%eax
     842:	00 0a                	add    %cl,(%rdx)
     844:	09 ba 00 00 00 05    	or     %edi,0x5000000(%rdx)
     84a:	d8 08                	fmuls  (%rax)
     84c:	0a 0c 68             	or     (%rax,%rbp,2),%cl
     84f:	08 00                	or     %al,(%rax)
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     851:	00 05 d9 10 0a 14    	add    %al,0x140a10d9(%rip)        # 140a1930 <_license+0x1409f59b>
     857:	81 01 00 00 05 da    	addl   $0xda050000,(%rcx)
     85d:	18 0a                	sbb    %cl,(%rdx)
     85f:	15 33 01 00 00       	adc    $0x133,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     864:	05 db 20 00 0b       	add    $0xb0020db,%eax
     869:	6d                   	insl   (%dx),%es:(%rdi)
     86a:	08 00                	or     %al,(%rax)
     86c:	00 0d 55 20 03 9f    	add    %cl,-0x60fcdfab(%rip)        # ffffffff9f0328c7 <server_id_map+0x36ff869498c7>
    if (!icmp_ptb_v4_stats) {
     872:	0a 3f                	or     (%rdi),%bh
     874:	fe 00                	incb   (%rax)
     876:	00 00                	add    %al,(%rax)
    icmp_ptb_v4_stats->v1 += 1;
     878:	03 a0 00 0a 4a fe    	add    -0x1b5f600(%rax),%esp
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     87e:	00 00                	add    %al,(%rax)
     880:	00 03                	add    %al,(%rbx)
      icmp_ptb_v4_stats->v2 += 1;
     882:	a1 08 0a 53 fe 00 00 	movabs 0x3000000fe530a08,%eax
     889:	00 03 
  if (iph + 1 > data_end) {
     88b:	a2 10 0a 54 fe 00 00 	movabs %al,0x3000000fe540a10
     892:	00 03 
  if (iph->ihl != 5) {
     894:	a3 18 00 08 56 a2 08 	movabs %eax,0x8a256080018
     89b:	00 00 
     89d:	05 e4 02 a1 12       	add    $0x12a102e4,%eax
  pckt->flow.proto = iph->protocol;
     8a2:	09 28                	or     %ebp,(%rax)
     8a4:	05 de 0a 07 74       	add    $0x74070ade,%eax
  pckt->flags |= F_ICMP;
     8a9:	05 00 00 05 df       	add    $0xdf050000,%eax
  pckt->flow.src = iph->daddr;
     8ae:	00 0a                	add    %cl,(%rdx)
     8b0:	09 ba 00 00 00 05    	or     %edi,0x5000000(%rdx)
  pckt->flow.dst = iph->saddr;
     8b6:	e0 08                	loopne 8c0 <balancer_ingress+0x8c0>
     8b8:	0a 0c 85 05 00 00 05 	or     0x5000005(,%rax,4),%cl
     8bf:	e1 10                	loope  8d1 <balancer_ingress+0x8d1>
     8c1:	0a 14 d0             	or     (%rax,%rdx,8),%dl
     8c4:	01 00                	add    %eax,(%rax)
     8c6:	00 05 e2 18 0a 15    	add    %al,0x150a18e2(%rip)        # 150a21ae <_license+0x1509fe19>
     8cc:	33 01                	xor    (%rcx),%eax
     8ce:	00 00                	add    %al,(%rax)
     8d0:	05 e3 20 00 08       	add    $0x80020e3,%eax
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     8d5:	57                   	push   %rdi
     8d6:	df 08                	fisttps (%rax)
     8d8:	00 00                	add    %al,(%rax)
     8da:	05 f8 02 a1 13       	add    $0x13a102f8,%eax
     8df:	09 28                	or     %ebp,(%rax)
     8e1:	05 e7 0a 07 4c       	add    $0x4c070ae7,%eax
     8e6:	09 00                	or     %eax,(%rax)
  vip.port = pckt.flow.port16[1];
     8e8:	00 05 e8 00 0a 09    	add    %al,0x90a00e8(%rip)        # 90a09d6 <_license+0x909e641>
  vip.proto = pckt.flow.proto;
     8ee:	64 02 00             	add    %fs:(%rax),%al
     8f1:	00 05 e9 08 0a 0c    	add    %al,0xc0a08e9(%rip)        # c0a11e0 <_license+0xc09ee4b>
     8f7:	ba 00 00 00 05       	mov    $0x5000000,%edx
     8fc:	ea                   	(bad)
     8fd:	10 0a                	adc    %cl,(%rdx)
     8ff:	14 d0                	adc    $0xd0,%al
     901:	01 00                	add    %eax,(%rax)
     903:	00 05 eb 18 0a 15    	add    %al,0x150a18eb(%rip)        # 150a21f4 <_license+0x1509fe5f>
  if (!vip_info) {
     909:	81 01 00 00 05 ec    	addl   $0xec050000,(%rcx)
     90f:	20 0a                	and    %cl,(%rdx)
  if (data_end - data > MAX_PCKT_SIZE) {
     911:	33 5d 09             	xor    0x9(%rbp),%ebx
     914:	00 00                	add    %al,(%rax)
     916:	05 ed 28 09 28       	add    $0x280928ed,%eax
     91b:	05 ed 0a 07 81       	add    $0x81070aed,%eax
     920:	01 00                	add    %eax,(%rax)
     922:	00 05 ed 00 0a 09    	add    %al,0x90a00ed(%rip)        # 90a0a15 <_license+0x909e680>
     928:	ba 00 00 00 05       	mov    $0x5000000,%edx
     92d:	ed                   	in     (%dx),%eax
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     92e:	08 0a                	or     %cl,(%rdx)
     930:	0c 6d                	or     $0x6d,%al
     932:	09 00                	or     %eax,(%rax)
     934:	00 05 ed 10 0a 14    	add    %al,0x140a10ed(%rip)        # 140a1a27 <_license+0x1409f692>
  if (!data_stats) {
     93a:	25 05 00 00 05       	and    $0x5000005,%eax
     93f:	ed                   	in     (%dx),%eax
     940:	18 0a                	sbb    %cl,(%rdx)
     942:	15 81 01 00 00       	adc    $0x181,%eax
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     947:	05 ed 20 00 00       	add    $0x20ed,%eax
    pckt.flow.port16[0] = 0;
     94c:	0b 51 09             	or     0x9(%rcx),%edx
     94f:	00 00                	add    %al,(%rax)
     951:	04 b6                	add    $0xb6,%al
  vip_num = vip_info->vip_num;
     953:	00 00                	add    %al,(%rax)
     955:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 9bf <balancer_ingress+0x9bf>
     95b:	0d 00 04 68 09       	or     $0x9680400,%eax
  __u32 cpu_num = bpf_get_smp_processor_id();
     960:	00 00                	add    %al,(%rax)
     962:	11 64 00 00          	adc    %esp,0x0(%rax,%rax,1)
     966:	00 00                	add    %al,(%rax)
     968:	0b 19                	or     (%rcx),%ebx
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     96a:	09 00                	or     %eax,(%rax)
     96c:	00 0b                	add    %cl,(%rbx)
     96e:	16                   	(bad)
     96f:	01 00                	add    %eax,(%rax)
     971:	00 13                	add    %dl,(%rbx)
     973:	58                   	pop    %rax
     974:	84 09                	test   %cl,(%rcx)
     976:	00 00                	add    %al,(%rax)
     978:	06                   	(bad)
     979:	6c                   	insb   (%dx),%es:(%rdi)
     97a:	a0 b8 8d 94 fa ff ff 	movabs 0xfffffffffa948db8,%al
     981:	ff ff 
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     983:	01 0b                	add    %ecx,(%rbx)
     985:	89 09                	mov    %ecx,(%rcx)
     987:	00 00                	add    %al,(%rax)
     989:	14 b6                	adc    $0xb6,%al
    if (!lru_stats) {
     98b:	00 00                	add    %al,(%rax)
     98d:	00 15 99 09 00 00    	add    %dl,0x999(%rip)        # 132c <balancer_ingress+0x132c>
     993:	15 b6 00 00 00       	adc    $0xb6,%eax
    lru_stats->v1 += 1;
     998:	00 16                	add    %dl,(%rsi)
     99a:	13 59 ac             	adc    -0x54(%rcx),%ebx
     99d:	09 00                	or     %eax,(%rax)
     99f:	00 06                	add    %al,(%rsi)
     9a1:	38 b0 ac a7 83 fa    	cmp    %dh,-0x57c5854(%rax)
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     9a7:	ff                   	(bad)
     9a8:	ff                   	(bad)
     9a9:	ff                   	(bad)
     9aa:	ff 01                	incl   (%rcx)
     9ac:	0b b1 09 00 00 17    	or     0x17000009(%rcx),%esi
     9b2:	06                   	(bad)
     9b3:	01 00                	add    %eax,(%rax)
     9b5:	00 18                	add    %bl,(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
     9b7:	c7 00 00 00 5f 04    	movl   $0x45f0000,(%rax)
     9bd:	07                   	(bad)
     9be:	28 0c 19             	sub    %cl,(%rcx,%rbx,1)
     9c1:	5a                   	pop    %rdx
     9c2:	00 19                	add    %bl,(%rcx)
    if (!icmp_ptb_v4_stats) {
     9c4:	5b                   	pop    %rbx
     9c5:	01 19                	add    %ebx,(%rcx)
     9c7:	5c                   	pop    %rsp
     9c8:	02 19                	add    (%rcx),%bl
     9ca:	5d                   	pop    %rbp
     9cb:	03 19                	add    (%rcx),%ebx
    icmp_ptb_v4_stats->v1 += 1;
     9cd:	5e                   	pop    %rsi
     9ce:	04 00                	add    $0x0,%al
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     9d0:	1a c7                	sbb    %bh,%al
     9d2:	00 00                	add    %al,(%rax)
     9d4:	00 04 08             	add    %al,(%rax,%rcx,1)
      icmp_ptb_v4_stats->v2 += 1;
     9d7:	1d 19 60 00 19       	sbb    $0x19006019,%eax
  if (iph + 1 > data_end) {
     9dc:	61                   	(bad)
     9dd:	01 19                	add    %ebx,(%rcx)
     9df:	62 02                	(bad)
     9e1:	19 63 04             	sbb    %esp,0x4(%rbx)
     9e4:	19 64 06 19          	sbb    %esp,0x19(%rsi,%rax,1)
  if (iph->ihl != 5) {
     9e8:	65 08 19             	or     %bl,%gs:(%rcx)
     9eb:	66 0c 19             	data16 or $0x19,%al
     9ee:	67 11 19             	adc    %ebx,(%ecx)
     9f1:	68 16 19 69 1d       	push   $0x1d691916
  pckt->flow.proto = iph->protocol;
     9f6:	19 6a 21             	sbb    %ebp,0x21(%rdx)
     9f9:	19 6b 29             	sbb    %ebp,0x29(%rbx)
     9fc:	19 6c 2e 19          	sbb    %ebp,0x19(%rsi,%rbp,1)
  pckt->flags |= F_ICMP;
     a00:	6d                   	insl   (%dx),%es:(%rdi)
     a01:	2f                   	(bad)
  pckt->flow.src = iph->daddr;
     a02:	19 6e 32             	sbb    %ebp,0x32(%rsi)
     a05:	19 6f 33             	sbb    %ebp,0x33(%rdi)
     a08:	19 70 5c             	sbb    %esi,0x5c(%rax)
  pckt->flow.dst = iph->saddr;
     a0b:	19 71 5e             	sbb    %esi,0x5e(%rcx)
     a0e:	19 72 62             	sbb    %esi,0x62(%rdx)
     a11:	19 73 67             	sbb    %esi,0x67(%rbx)
     a14:	19 74 6c 19          	sbb    %esi,0x19(%rsp,%rbp,2)
    vip.port = 0;
     a18:	75 73                	jne    a8d <balancer_ingress+0xa8d>
     a1a:	19 76 84             	sbb    %esi,-0x7c(%rsi)
     a1d:	01 19                	add    %ebx,(%rcx)
     a1f:	77 88                	ja     9a9 <balancer_ingress+0x9a9>
     a21:	01 19                	add    %ebx,(%rcx)
     a23:	78 89                	js     9ae <balancer_ingress+0x9ae>
     a25:	01 19                	add    %ebx,(%rcx)
     a27:	79 8f                	jns    9b8 <balancer_ingress+0x9b8>
     a29:	01 19                	add    %ebx,(%rcx)
     a2b:	7a 90                	jp     9bd <balancer_ingress+0x9bd>
     a2d:	01 19                	add    %ebx,(%rcx)
    if (!vip_info) {
     a2f:	7b ff                	jnp    a30 <balancer_ingress+0xa30>
     a31:	01 19                	add    %ebx,(%rcx)
     a33:	7c 80                	jl     9b5 <balancer_ingress+0x9b5>
     a35:	02 19                	add    (%rcx),%bl
     a37:	7d 86                	jge    9bf <balancer_ingress+0x9bf>
     a39:	02 19                	add    (%rcx),%bl
     a3b:	7e 87                	jle    9c4 <balancer_ingress+0x9c4>
     a3d:	02 00                	add    (%rax),%al
     a3f:	06                   	(bad)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     a40:	7f 05                	jg     a47 <balancer_ingress+0xa47>
     a42:	08 0b                	or     %cl,(%rbx)
     a44:	fe 00                	incb   (%rax)
     a46:	00 00                	add    %al,(%rax)
     a48:	0b 60 00             	or     0x0(%rax),%esp
      pckt.flow.port16[1] = 0;
     a4b:	00 00                	add    %al,(%rax)
     a4d:	0b a0 02 00 00 0b    	or     0xb000002(%rax),%esp
     a53:	57                   	push   %rdi
     a54:	0a 00                	or     (%rax),%al
  struct address dst_addr = {};
     a56:	00 0d 8f 28 09 76    	add    %cl,0x7609288f(%rip)        # 760932eb <_license+0x76090f56>
     a5c:	1b 80 16 01 00 00    	sbb    0x116(%rax),%eax
     a62:	09 78 04             	or     %edi,0x4(%rax)
     a65:	00 1b                	add    %bl,(%rbx)
    dst_addr.addr = pckt->flow.dst;
     a67:	81 16 01 00 00 09    	adcl   $0x9000001,(%rsi)
     a6d:	79 04                	jns    a73 <balancer_ingress+0xa73>
     a6f:	04 0a                	add    $0xa,%al
     a71:	82                   	(bad)
     a72:	e1 0a                	loope  a7e <balancer_ingress+0xa7e>
     a74:	00 00                	add    %al,(%rax)
     a76:	09 80 01 0a 83 ed    	or     %eax,-0x127cf5ff(%rax)
     a7c:	0a 00                	or     (%rax),%al
     a7e:	00 09                	add    %cl,(%rcx)
     a80:	82                   	(bad)
     a81:	04 0a                	add    $0xa,%al
     a83:	85 16                	test   %edx,(%rsi)
     a85:	01 00                	add    %eax,(%rax)
     a87:	00 09                	add    %cl,(%rcx)
     a89:	83 06 0a             	addl   $0xa,(%rsi)
  if (decap_dst_flags) {
     a8c:	86 16                	xchg   %dl,(%rsi)
     a8e:	01 00                	add    %eax,(%rax)
     a90:	00 09                	add    %cl,(%rcx)
     a92:	84 07                	test   %al,(%rdi)
     a94:	0e                   	(bad)
     a95:	9c                   	pushf
     a96:	0a 00                	or     (%rax),%al
     a98:	00 09                	add    %cl,(%rcx)
     a9a:	86 08                	xchg   %cl,(%rax)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a9c:	0f 20 09             	mov    %cr1,%rcx
     a9f:	86 0e                	xchg   %cl,(%rsi)
     aa1:	a8 0a                	test   $0xa,%al
     aa3:	00 00                	add    %al,(%rax)
     aa5:	09 86 00 09 20 09    	or     %eax,0x9200900(%rsi)
    if (!data_stats) {
     aab:	86 0a                	xchg   %cl,(%rdx)
     aad:	87 f5                	xchg   %esi,%ebp
     aaf:	0a 00                	or     (%rax),%al
    data_stats->v1 += 1;
     ab1:	00 09                	add    %cl,(%rcx)
     ab3:	86 00                	xchg   %al,(%rax)
     ab5:	0a 8d f5 0a 00 00    	or     0xaf5(%rbp),%cl
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     abb:	09 86 10 00 0a 8e    	or     %eax,-0x71f5fff0(%rsi)
     ac1:	c8 0a 00 00          	enter  $0xa,$0x0
    csum = iph->check + 0x0001;
     ac5:	09 86 00 09 20 09    	or     %eax,0x9200900(%rsi)
     acb:	86 0a                	xchg   %cl,(%rdx)
    iph->check = (csum & 0xffff) + (csum >> 16);
     acd:	87 f5                	xchg   %esi,%ebp
     acf:	0a 00                	or     (%rax),%al
     ad1:	00 09                	add    %cl,(%rcx)
     ad3:	86 00                	xchg   %al,(%rax)
     ad5:	0a 8d f5 0a 00 00    	or     0xaf5(%rbp),%cl
    if (!--iph->ttl) {
     adb:	09 86 10 00 00 00    	or     %eax,0x10(%rsi)
     ae1:	04 16                	add    $0x16,%al
     ae3:	01 00                	add    %eax,(%rax)
     ae5:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # b4f <balancer_ingress+0xb4f>
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     aeb:	03 00                	add    (%rax),%eax
     aed:	0c a0                	or     $0xa0,%al
     aef:	02 00                	add    (%rax),%al
     af1:	00 84 04 20 0d 8c 10 	add    %al,0x108c0d20(%rsp,%rax,1)
     af8:	0a 21                	or     (%rcx),%ah
     afa:	0a 88 03 0b 00 00    	or     0xb03(%rax),%cl
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     b00:	0a 28                	or     (%rax),%ch
     b02:	00 0f                	add    %cl,(%rdi)
     b04:	10 0a                	adc    %cl,(%rdx)
     b06:	22 0a                	and    (%rdx),%cl
     b08:	89 24 0b             	mov    %esp,(%rbx,%rcx,1)
  new_eth->h_proto = BE_ETH_P_IP;
     b0b:	00 00                	add    %al,(%rax)
     b0d:	0a 23                	or     (%rbx),%ah
     b0f:	00 0a                	add    %cl,(%rdx)
     b11:	8a 30                	mov    (%rax),%dh
     b13:	0b 00                	or     (%rax),%eax
     b15:	00 0a                	add    %cl,(%rdx)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     b17:	25 00 0a 8b c4       	and    $0xc48b0a00,%eax
     b1c:	01 00                	add    %eax,(%rax)
     b1e:	00 0a                	add    %cl,(%rdx)
     b20:	26 00 00             	es add %al,(%rax)
     b23:	00 04 16             	add    %al,(%rsi,%rdx,1)
     b26:	01 00                	add    %eax,(%rax)
     b28:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # b92 <balancer_ingress+0xb92>
     b2e:	10 00                	adc    %al,(%rax)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b30:	04 ed                	add    $0xed,%al
     b32:	0a 00                	or     (%rax),%al
     b34:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # b9e <balancer_ingress+0xb9e>
     b3a:	08 00                	or     %al,(%rax)
  if (!data_stats) {
     b3c:	0b 41 0b             	or     0xb(%rcx),%eax
     b3f:	00 00                	add    %al,(%rax)
     b41:	0d 99 14 0b 57       	or     $0x570b1499,%eax
     b46:	1b 90 16 01 00 00    	sbb    0x116(%rax),%edx
    data_stats->v2 += 1;
     b4c:	0b 59 04             	or     0x4(%rcx),%ebx
  if (action >= 0) {
     b4f:	00 1b                	add    %bl,(%rbx)
     b51:	81 16 01 00 00 0b    	adcl   $0xb000001,(%rsi)
     b57:	5a                   	pop    %rdx
  if (decap_dst_flags) {
     b58:	04 04                	add    $0x4,%al
     b5a:	0a 91 16 01 00 00    	or     0x116(%rcx),%dl
  if (action >= 0) {
     b60:	0b 61 01             	or     0x1(%rcx),%esp
     b63:	0a 92 ed 0a 00 00    	or     0xaed(%rdx),%dl
     b69:	0b 62 02             	or     0x2(%rdx),%esp
     b6c:	0a 93 ed 0a 00 00    	or     0xaed(%rbx),%dl
     b72:	0b 63 04             	or     0x4(%rbx),%esp
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b75:	0a 94 ed 0a 00 00 0b 	or     0xb00000a(%rbp,%rbp,8),%dl
     b7c:	64 06                	fs (bad)
     b7e:	0a 95 16 01 00 00    	or     0x116(%rbp),%dl
        xpop_stats_data->v1 += 1; // IPv4 inner packets
     b84:	0b 65 08             	or     0x8(%rbp),%esp
     b87:	0a 96 16 01 00 00    	or     0x116(%rsi),%dl
     b8d:	0b 66 09             	or     0x9(%rsi),%esp
     b90:	0a 97 e6 0b 00 00    	or     0xbe6(%rdi),%dl
     b96:	0b 67 0a             	or     0xa(%rdi),%esp
  bpf_tail_call(ctx, &subprograms, i);
     b99:	0e                   	(bad)
     b9a:	a1 0b 00 00 0b 68 0c 	movabs 0x80f0c680b00000b,%eax
     ba1:	0f 08 
     ba3:	0b 68 0e             	or     0xe(%rax),%ebp
     ba6:	ad                   	lods   %ds:(%rsi),%eax
     ba7:	0b 00                	or     (%rax),%eax
     ba9:	00 0b                	add    %cl,(%rbx)
     bab:	68 00 09 08 0b       	push   $0xb080900
     bb0:	68 0a 87 bc 01       	push   $0x1bc870a
     bb5:	00 00                	add    %al,(%rax)
     bb7:	0b 68 00             	or     0x0(%rax),%ebp
     bba:	0a 8d bc 01 00 00    	or     0x1bc(%rbp),%cl
     bc0:	0b 68 04             	or     0x4(%rax),%ebp
        bpf_map_lookup_elem(&stats, &stats_key);
     bc3:	00 0a                	add    %cl,(%rdx)
     bc5:	8e cd                	mov    %ebp,%cs
     bc7:	0b 00                	or     (%rax),%eax
     bc9:	00 0b                	add    %cl,(%rbx)
     bcb:	68 00 09 08 0b       	push   $0xb080900
    if (!icmp_ptb_v6_stats) {
     bd0:	68 0a 87 bc 01       	push   $0x1bc870a
     bd5:	00 00                	add    %al,(%rax)
     bd7:	0b 68 00             	or     0x0(%rax),%ebp
    icmp_ptb_v6_stats->v1 += 1;
     bda:	0a 8d bc 01 00 00    	or     0x1bc(%rbp),%cl
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     be0:	0b 68 04             	or     0x4(%rax),%ebp
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     be3:	00 00                	add    %al,(%rax)
     be5:	00 0c a0             	add    %cl,(%rax,%riz,4)
     be8:	02 00                	add    (%rax),%al
      icmp_ptb_v6_stats->v2 += 1;
     bea:	00 98 04 26 0b f3    	add    %bl,-0xcf4d9fc(%rax)
  if (ip6h + 1 > data_end) {
     bf0:	0b 00                	or     (%rax),%eax
     bf2:	00 14 99             	add    %dl,(%rcx,%rbx,4)
     bf5:	09 00                	or     %eax,(%rax)
     bf7:	00 15 99 09 00 00    	add    %dl,0x999(%rip)        # 1596 <balancer_ingress+0x1596>
     bfd:	15 99 09 00 00       	adc    $0x999,%eax
  pckt->flow.proto = ip6h->nexthdr;
     c02:	00 0b                	add    %cl,(%rbx)
     c04:	08 0c 00             	or     %cl,(%rax,%rax,1)
     c07:	00 0d 9c 0e 0c 29    	add    %cl,0x290c0e9c(%rip)        # 290c1aa9 <_license+0x290bf714>
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     c0d:	0a 24 16             	or     (%rsi,%rdx,1),%ah
     c10:	01 00                	add    %eax,(%rax)
     c12:	00 0c 2a             	add    %cl,(%rdx,%rbp,1)
     c15:	00 0a                	add    %cl,(%rdx)
     c17:	81 bf 00 00 00 0c 2b 	cmpl   $0x9a0a012b,0xc000000(%rdi)
     c1e:	01 0a 9a 
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     c21:	16                   	(bad)
     c22:	01 00                	add    %eax,(%rax)
     c24:	00 0c 2e             	add    %cl,(%rsi,%rbp,1)
     c27:	05 0a 9b 32 0c       	add    $0xc329b0a,%eax
     c2c:	00 00                	add    %al,(%rax)
     c2e:	0c 32                	or     $0x32,%al
     c30:	06                   	(bad)
     c31:	00 04 16             	add    %al,(%rsi,%rdx,1)
  if (protocol == IPPROTO_IPIP) {
     c34:	01 00                	add    %eax,(%rax)
     c36:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # ca0 <balancer_ingress+0xca0>
     c3c:	08 00                	or     %al,(%rax)
     c3e:	0b 43 0c             	or     0xc(%rbx),%eax
     c41:	00 00                	add    %al,(%rax)
     c43:	0d 9e 09 0c 35       	or     $0x350c099e,%eax
     c48:	0a 24 16             	or     (%rsi,%rdx,1),%ah
     c4b:	01 00                	add    %eax,(%rax)
     c4d:	00 0c 36             	add    %cl,(%rsi,%rsi,1)
     c50:	00 0a                	add    %cl,(%rdx)
     c52:	9d                   	popf
     c53:	32 0c 00             	xor    (%rax,%rax,1),%cl
     c56:	00 0c 37             	add    %cl,(%rdi,%rsi,1)
     c59:	01 00                	add    %eax,(%rax)
     c5b:	0b 60 0c             	or     0xc(%rax),%esp
  struct address dst_addr = {};
     c5e:	00 00                	add    %al,(%rax)
     c60:	14 b6                	adc    $0xb6,%al
     c62:	00 00                	add    %al,(%rax)
     c64:	00 15 99 09 00 00    	add    %dl,0x999(%rip)        # 1603 <balancer_ingress+0x1603>
     c6a:	15 99 09 00 00       	adc    $0x999,%eax
    dst_addr.addr = pckt->flow.dst;
     c6f:	15 99 09 00 00       	adc    $0x999,%eax
     c74:	15 06 01 00 00       	adc    $0x106,%eax
     c79:	00 0b                	add    %cl,(%rbx)
     c7b:	7f 0c                	jg     c89 <balancer_ingress+0xc89>
     c7d:	00 00                	add    %al,(%rax)
     c7f:	0c c7                	or     $0xc7,%al
     c81:	00 00                	add    %al,(%rax)
     c83:	00 9f 0d 35 1c a0    	add    %bl,-0x5fe3caf3(%rdi)
     c89:	00 a8 02 b6 00 00    	add    %ch,0xb602(%rax)
  if (decap_dst_flags) {
     c8f:	00 1d a1 00 a8 02    	add    %bl,0x2a800a1(%rip)        # 2a80d36 <_license+0x2a7e9a1>
     c95:	3e 10 00             	ds adc %al,(%rax)
     c98:	00 1d ac 00 a8 02    	add    %bl,0x2a800ac(%rip)        # 2a80d4a <_license+0x2a7e9b5>
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c9e:	fe 00                	incb   (%rax)
     ca0:	00 00                	add    %al,(%rax)
     ca2:	1d ad 00 a8 02       	sbb    $0x2a800ad,%eax
    if (!data_stats) {
     ca7:	a8 10                	test   $0x10,%al
     ca9:	00 00                	add    %al,(%rax)
     cab:	1e                   	(bad)
     cac:	af                   	scas   %es:(%rdi),%eax
     cad:	00 ae 02 ac 10 00    	add    %ch,0x10ac02(%rsi)
    if ((*data + offset) > *data_end) {
     cb3:	00 1e                	add    %bl,(%rsi)
     cb5:	1d 00 af 02 69       	sbb    $0x6902af00,%eax
     cba:	02 00                	add    (%rax),%al
     cbc:	00 1e                	add    %bl,(%rsi)
     cbe:	a2 00 a9 02 99 09 00 	movabs %al,0x1e0000099902a900
     cc5:	00 1e 
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     cc7:	a3 00 aa 02 99 09 00 	movabs %eax,0x1e0000099902aa00
     cce:	00 1e 
     cd0:	2a 00                	sub    (%rax),%al
    if (!--ip6h->hop_limit) {
     cd2:	ad                   	lods   %ds:(%rsi),%eax
     cd3:	02 f2                	add    %dl,%dh
     cd5:	04 00                	add    $0x0,%al
     cd7:	00 1e                	add    %bl,(%rsi)
     cd9:	b3 00                	mov    $0x0,%bl
     cdb:	b8 02 bf 00 00       	mov    $0xbf02,%eax
     ce0:	00 1e                	add    %bl,(%rsi)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     ce2:	b4 00                	mov    $0x0,%ah
     ce4:	ba 02 fe 00 00       	mov    $0xfe02,%edx
     ce9:	00 1e                	add    %bl,(%rsi)
     ceb:	b5 00                	mov    $0x0,%ch
     ced:	b6 02                	mov    $0x2,%dh
     cef:	b6 00                	mov    $0x0,%dh
     cf1:	00 00                	add    %al,(%rax)
     cf3:	1e                   	(bad)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     cf4:	96                   	xchg   %eax,%esi
     cf5:	00 b3 02 16 01 00    	add    %dh,0x11602(%rbx)
     cfb:	00 1e                	add    %bl,(%rsi)
     cfd:	b6 00                	mov    $0x0,%dh
     cff:	b0 02                	mov    $0x2,%al
     d01:	ac                   	lods   %ds:(%rsi),%al
     d02:	02 00                	add    (%rax),%al
     d04:	00 1e                	add    %bl,(%rsi)
    new_eth->h_proto = BE_ETH_P_IPV6;
     d06:	b7 00                	mov    $0x0,%bh
     d08:	36 03 bf 00 00 00 1e 	ss add 0x1e000000(%rdi),%edi
     d0f:	b8 00 b1 02 85       	mov    $0x8502b100,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     d14:	05 00 00 1e b9       	add    $0xb91e0000,%eax
     d19:	00 46 03             	add    %al,0x3(%rsi)
     d1c:	bf 00 00 00 1e       	mov    $0x1e000000,%edi
     d21:	ba 00 47 03 99       	mov    $0x99034700,%edx
     d26:	09 00                	or     %eax,(%rax)
     d28:	00 1e                	add    %bl,(%rsi)
     d2a:	bb 00 b9 02 a0       	mov    $0xa002b900,%ebx
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     d2f:	02 00                	add    (%rax),%al
     d31:	00 1e                	add    %bl,(%rsi)
     d33:	bc 00 b4 02 a0       	mov    $0xa002b400,%esp
     d38:	02 00                	add    (%rax),%al
     d3a:	00 1e                	add    %bl,(%rsi)
  if (!data_stats) {
     d3c:	bd 00 ab 02 cb       	mov    $0xcb02ab00,%ebp
     d41:	00 00                	add    %al,(%rax)
     d43:	00 1e                	add    %bl,(%rsi)
     d45:	be 00 b2 02 fe       	mov    $0xfe02b200,%esi
    data_stats->v2 += 1;
     d4a:	00 00                	add    %al,(%rax)
     d4c:	00 1e                	add    %bl,(%rsi)
  if (action >= 0) {
     d4e:	25 00 b7 02 bf       	and    $0xbf02b700,%eax
     d53:	00 00                	add    %al,(%rax)
     d55:	00 1f                	add    %bl,(%rdi)
  if (decap_dst_flags) {
     d57:	1e                   	(bad)
     d58:	bf 00 e9 02 a8       	mov    $0xa802e900,%edi
  if (action >= 0) {
     d5d:	10 00                	adc    %al,(%rax)
     d5f:	00 00                	add    %al,(%rax)
     d61:	1f                   	(bad)
     d62:	1e                   	(bad)
     d63:	bf 00 e1 02 a8       	mov    $0xa802e100,%edi
     d68:	10 00                	adc    %al,(%rax)
     d6a:	00 00                	add    %al,(%rax)
     d6c:	1f                   	(bad)
     d6d:	1e                   	(bad)
     d6e:	c0 00 13             	rolb   $0x13,(%rax)
     d71:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     d77:	07                   	(bad)
     d78:	00 13                	add    %dl,(%rbx)
     d7a:	03 d6                	add    %esi,%edx
     d7c:	10 00                	adc    %al,(%rax)
    if (xpop_stats_data) {
     d7e:	00 00                	add    %al,(%rax)
     d80:	1f                   	(bad)
     d81:	1e                   	(bad)
     d82:	c0 00 16             	rolb   $0x16,(%rax)
        xpop_stats_data->v2 += 1; // IPv6 inner packets
     d85:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
     d8b:	07                   	(bad)
     d8c:	00 16                	add    %dl,(%rsi)
     d8e:	03 d6                	add    %esi,%edx
     d90:	10 00                	adc    %al,(%rax)
  bpf_tail_call(ctx, &subprograms, i);
     d92:	00 00                	add    %al,(%rax)
     d94:	1f                   	(bad)
     d95:	1e                   	(bad)
     d96:	c0 00 37             	rolb   $0x37,(%rax)
     d99:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
     d9f:	07                   	(bad)
     da0:	00 37                	add    %dh,(%rdi)
     da2:	03 d6                	add    %esi,%edx
     da4:	10 00                	adc    %al,(%rax)
     da6:	00 1f                	add    %bl,(%rdi)
     da8:	1e                   	(bad)
     da9:	c1 00 37             	roll   $0x37,(%rax)
     dac:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
     db2:	14 00                	adc    $0x0,%al
     db4:	37                   	(bad)
     db5:	03 db                	add    %ebx,%ebx
     db7:	10 00                	adc    %al,(%rax)
  udp = data + off;
     db9:	00 1e                	add    %bl,(%rsi)
     dbb:	c2 00 37             	ret    $0x3700
  if (is_ipv6) {
     dbe:	03 db                	add    %ebx,%ebx
  udp = data + off;
     dc0:	10 00                	adc    %al,(%rax)
     dc2:	00 00                	add    %al,(%rax)
  if (udp + 1 > data_end) {
     dc4:	00 1f                	add    %bl,(%rdi)
     dc6:	1e                   	(bad)
     dc7:	c3                   	ret
     dc8:	00 46 03             	add    %al,0x3(%rsi)
     dcb:	fe 00                	incb   (%rax)
     dcd:	00 00                	add    %al,(%rax)
     dcf:	00 1f                	add    %bl,(%rdi)
     dd1:	1e                   	(bad)
     dd2:	c0 00 47             	rolb   $0x47,(%rax)
     dd5:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
     ddb:	07                   	(bad)
     ddc:	00 47 03             	add    %al,0x3(%rdi)
     ddf:	d6                   	(bad)
     de0:	10 00                	adc    %al,(%rax)
     de2:	00 1f                	add    %bl,(%rdi)
     de4:	1e                   	(bad)
     de5:	c1 00 47             	roll   $0x47,(%rax)
     de8:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
     dee:	14 00                	adc    $0x0,%al
     df0:	47 03 db             	rex.RXB add %r11d,%r11d
     df3:	10 00                	adc    %al,(%rax)
     df5:	00 1e                	add    %bl,(%rsi)
     df7:	c2 00 47             	ret    $0x4700
    vip.vip = pckt.flow.dst;
     dfa:	03 db                	add    %ebx,%ebx
     dfc:	10 00                	adc    %al,(%rax)
     dfe:	00 00                	add    %al,(%rax)
  vip.port = pckt.flow.port16[1];
     e00:	00 1f                	add    %bl,(%rdi)
     e02:	1e                   	(bad)
     e03:	c4                   	(bad)
     e04:	00 4a 03             	add    %cl,0x3(%rdx)
  vip.proto = pckt.flow.proto;
     e07:	bf 00 00 00 1e       	mov    $0x1e000000,%edi
     e0c:	c5 00 4b             	(bad)
     e0f:	03 85 05 00 00 1f    	add    0x1f000005(%rbp),%eax
     e15:	1e                   	(bad)
     e16:	c0 00 4b             	rolb   $0x4b,(%rax)
     e19:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
     e1f:	07                   	(bad)
     e20:	00 4b 03             	add    %cl,0x3(%rbx)
  if (!vip_info) {
     e23:	d6                   	(bad)
     e24:	10 00                	adc    %al,(%rax)
     e26:	00 1f                	add    %bl,(%rdi)
     e28:	1e                   	(bad)
     e29:	c1 00 4b             	roll   $0x4b,(%rax)
  if (data_end - data > MAX_PCKT_SIZE) {
     e2c:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
     e32:	14 00                	adc    $0x0,%al
     e34:	4b 03 db             	rex.WXB add %r11,%rbx
     e37:	10 00                	adc    %al,(%rax)
     e39:	00 1e                	add    %bl,(%rsi)
     e3b:	c2 00 4b             	ret    $0x4b00
     e3e:	03 db                	add    %ebx,%ebx
     e40:	10 00                	adc    %al,(%rax)
     e42:	00 00                	add    %al,(%rax)
     e44:	00 00                	add    %al,(%rax)
     e46:	1f                   	(bad)
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     e47:	1e                   	(bad)
     e48:	c6 00 57             	movb   $0x57,(%rax)
     e4b:	03 a8 10 00 00 1f    	add    0x1f000010(%rax),%ebp
     e51:	1e                   	(bad)
     e52:	c7 00 6a 03 bf 00    	movl   $0xbf036a,(%rax)
  if (!data_stats) {
     e58:	00 00                	add    %al,(%rax)
     e5a:	1e                   	(bad)
     e5b:	c8 00 6b 03          	enter  $0x6b00,$0x3
  data_stats->v1 += 1;
     e5f:	a8 06                	test   $0x6,%al
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     e61:	00 00                	add    %al,(%rax)
     e63:	1e                   	(bad)
     e64:	c9                   	leave
    pckt.flow.port16[0] = 0;
     e65:	00 70 03             	add    %dh,0x3(%rax)
     e68:	e0 10                	loopne e7a <balancer_ingress+0xe7a>
     e6a:	00 00                	add    %al,(%rax)
  vip_num = vip_info->vip_num;
     e6c:	1f                   	(bad)
     e6d:	1e                   	(bad)
     e6e:	c0 00 6c             	rolb   $0x6c,(%rax)
     e71:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
  __u32 cpu_num = bpf_get_smp_processor_id();
     e77:	07                   	(bad)
     e78:	00 6c 03 d6          	add    %ch,-0x2a(%rbx,%rax,1)
     e7c:	10 00                	adc    %al,(%rax)
     e7e:	00 1f                	add    %bl,(%rdi)
     e80:	1e                   	(bad)
     e81:	c1 00 6c             	roll   $0x6c,(%rax)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e84:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
     e8a:	14 00                	adc    $0x0,%al
     e8c:	6c                   	insb   (%dx),%es:(%rdi)
     e8d:	03 db                	add    %ebx,%ebx
     e8f:	10 00                	adc    %al,(%rax)
     e91:	00 1e                	add    %bl,(%rsi)
     e93:	c2 00 6c             	ret    $0x6c00
     e96:	03 db                	add    %ebx,%ebx
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e98:	10 00                	adc    %al,(%rax)
     e9a:	00 00                	add    %al,(%rax)
     e9c:	00 1f                	add    %bl,(%rdi)
     e9e:	1e                   	(bad)
     e9f:	09 00                	or     %eax,(%rax)
     ea1:	75 03                	jne    ea6 <balancer_ingress+0xea6>
     ea3:	bf 00 00 00 1e       	mov    $0x1e000000,%edi
    if (!lru_stats) {
     ea8:	ce                   	(bad)
     ea9:	00 76 03             	add    %dh,0x3(%rsi)
     eac:	ba 00 00 00 1f       	mov    $0x1f000000,%edx
    lru_stats->v1 += 1;
     eb1:	1e                   	(bad)
     eb2:	c0 00 76             	rolb   $0x76,(%rax)
     eb5:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
     ebb:	07                   	(bad)
     ebc:	00 76 03             	add    %dh,0x3(%rsi)
     ebf:	d6                   	(bad)
     ec0:	10 00                	adc    %al,(%rax)
     ec2:	00 1f                	add    %bl,(%rdi)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     ec4:	1e                   	(bad)
     ec5:	c1 00 76             	roll   $0x76,(%rax)
     ec8:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
     ece:	14 00                	adc    $0x0,%al
     ed0:	76 03                	jbe    ed5 <balancer_ingress+0xed5>
     ed2:	db 10                	fistl  (%rax)
     ed4:	00 00                	add    %al,(%rax)
  if (!lru_map) {
     ed6:	1e                   	(bad)
     ed7:	c2 00 76             	ret    $0x7600
     eda:	03 db                	add    %ebx,%ebx
     edc:	10 00                	adc    %al,(%rax)
  if ((vip_info->flags & F_QUIC_VIP)) {
     ede:	00 00                	add    %al,(%rax)
     ee0:	00 1f                	add    %bl,(%rdi)
     ee2:	1e                   	(bad)
     ee3:	cf                   	iret
     ee4:	00 8a 03 b6 00 00    	add    %cl,0xb603(%rdx)
    bool is_icmp = (pckt.flags & F_ICMP);
     eea:	00 1f                	add    %bl,(%rdi)
    if (is_icmp) {
     eec:	1e                   	(bad)
     eed:	c0 00 82             	rolb   $0x82,(%rax)
     ef0:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
     ef6:	07                   	(bad)
     ef7:	00 82 03 d6 10 00    	add    %al,0x10d603(%rdx)
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     efd:	00 1f                	add    %bl,(%rdi)
     eff:	1e                   	(bad)
     f00:	c1 00 82             	roll   $0x82,(%rax)
     f03:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
      if (!quic_packets_stats) {
     f09:	14 00                	adc    $0x0,%al
     f0b:	82                   	(bad)
     f0c:	03 db                	add    %ebx,%ebx
     f0e:	10 00                	adc    %al,(%rax)
     f10:	00 1e                	add    %bl,(%rsi)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     f12:	c2 00 82             	ret    $0x8200
  bool is_icmp = (pckt->flags & F_ICMP);
     f15:	03 db                	add    %ebx,%ebx
     f17:	10 00                	adc    %al,(%rax)
     f19:	00 00                	add    %al,(%rax)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     f1b:	00 00                	add    %al,(%rax)
     f1d:	00 00                	add    %al,(%rax)
     f1f:	1f                   	(bad)
     f20:	1e                   	(bad)
     f21:	b7 00                	mov    $0x0,%bh
     f23:	5f                   	pop    %rdi
     f24:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
     f2a:	b8 00 60 03 85       	mov    $0x85036000,%eax
     f2f:	05 00 00 1f 1e       	add    $0x1e1f0000,%eax
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     f34:	c0 00 60             	rolb   $0x60,(%rax)
     f37:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
     f3d:	07                   	(bad)
     f3e:	00 60 03             	add    %ah,0x3(%rax)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     f41:	d6                   	(bad)
     f42:	10 00                	adc    %al,(%rax)
     f44:	00 1f                	add    %bl,(%rdi)
     f46:	1e                   	(bad)
     f47:	c1 00 60             	roll   $0x60,(%rax)
     f4a:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
  if (!connId) {
     f50:	14 00                	adc    $0x0,%al
     f52:	60                   	(bad)
     f53:	03 db                	add    %ebx,%ebx
     f55:	10 00                	adc    %al,(%rax)
  __u8 connIdVersion = (connId[0] >> 6);
     f57:	00 1e                	add    %bl,(%rsi)
     f59:	c2 00 60             	ret    $0x6000
     f5c:	03 db                	add    %ebx,%ebx
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     f5e:	10 00                	adc    %al,(%rax)
     f60:	00 00                	add    %al,(%rax)
     f62:	00 00                	add    %al,(%rax)
     f64:	00 1f                	add    %bl,(%rdi)
     f66:	1e                   	(bad)
     f67:	c4                   	(bad)
     f68:	00 ea                	add    %ch,%dl
     f6a:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
     f70:	c5 00 eb             	(bad)
     f73:	03 85 05 00 00 1f    	add    0x1f000005(%rbp),%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     f79:	1e                   	(bad)
     f7a:	c0 00 ec             	rolb   $0xec,(%rax)
     f7d:	03 99 09 00 00 1e    	add    0x1e000009(%rcx),%ebx
     f83:	07                   	(bad)
     f84:	00 ec                	add    %ch,%ah
     f86:	03 d6                	add    %esi,%edx
     f88:	10 00                	adc    %al,(%rax)
     f8a:	00 1f                	add    %bl,(%rdi)
     f8c:	1e                   	(bad)
     f8d:	c1 00 ec             	roll   $0xec,(%rax)
     f90:	03 bf 00 00 00 1e    	add    0x1e000000(%rdi),%edi
    vip.port = 0;
     f96:	14 00                	adc    $0x0,%al
     f98:	ec                   	in     (%dx),%al
     f99:	03 db                	add    %ebx,%ebx
     f9b:	10 00                	adc    %al,(%rax)
     f9d:	00 1e                	add    %bl,(%rsi)
     f9f:	c2 00 ec             	ret    $0xec00
     fa2:	03 db                	add    %ebx,%ebx
     fa4:	10 00                	adc    %al,(%rax)
     fa6:	00 00                	add    %al,(%rax)
     fa8:	00 00                	add    %al,(%rax)
    if (!vip_info) {
     faa:	1f                   	(bad)
     fab:	1e                   	(bad)
     fac:	c0 00 0f             	rolb   $0xf,(%rax)
     faf:	04 99                	add    $0x99,%al
     fb1:	09 00                	or     %eax,(%rax)
     fb3:	00 1e                	add    %bl,(%rsi)
     fb5:	07                   	(bad)
     fb6:	00 0f                	add    %cl,(%rdi)
     fb8:	04 d6                	add    $0xd6,%al
     fba:	10 00                	adc    %al,(%rax)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     fbc:	00 1f                	add    %bl,(%rdi)
     fbe:	1e                   	(bad)
     fbf:	14 00                	adc    $0x0,%al
     fc1:	0f 04                	(bad)
     fc3:	db 10                	fistl  (%rax)
      pckt.flow.port16[1] = 0;
     fc5:	00 00                	add    %al,(%rax)
     fc7:	1e                   	(bad)
     fc8:	c2 00 0f             	ret    $0xf00
     fcb:	04 db                	add    $0xdb,%al
     fcd:	10 00                	adc    %al,(%rax)
     fcf:	00 1e                	add    %bl,(%rsi)
     fd1:	c1 00 0f             	roll   $0xf,(%rax)
     fd4:	04 bf                	add    $0xbf,%al
     fd6:	00 00                	add    %al,(%rax)
     fd8:	00 00                	add    %al,(%rax)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fda:	00 1f                	add    %bl,(%rdi)
     fdc:	1e                   	(bad)
     fdd:	c0 00 17             	rolb   $0x17,(%rax)
     fe0:	04 99                	add    $0x99,%al
     fe2:	09 00                	or     %eax,(%rax)
     fe4:	00 1e                	add    %bl,(%rsi)
      if (!data_stats) {
     fe6:	07                   	(bad)
     fe7:	00 17                	add    %dl,(%rdi)
     fe9:	04 d6                	add    $0xd6,%al
     feb:	10 00                	adc    %al,(%rax)
     fed:	00 1f                	add    %bl,(%rdi)
      data_stats->v1 += 1;
     fef:	1e                   	(bad)
     ff0:	14 00                	adc    $0x0,%al
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     ff2:	17                   	(bad)
     ff3:	04 db                	add    $0xdb,%al
     ff5:	10 00                	adc    %al,(%rax)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     ff7:	00 1e                	add    %bl,(%rsi)
     ff9:	c2 00 17             	ret    $0x1700
     ffc:	04 db                	add    $0xdb,%al
     ffe:	10 00                	adc    %al,(%rax)
    1000:	00 1e                	add    %bl,(%rsi)
    1002:	c1 00 17             	roll   $0x17,(%rax)
        data_stats->v2 += 1;
    1005:	04 bf                	add    $0xbf,%al
    1007:	00 00                	add    %al,(%rax)
    1009:	00 00                	add    %al,(%rax)
    100b:	00 1f                	add    %bl,(%rdi)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
    100d:	1e                   	(bad)
    100e:	c0 00 09             	rolb   $0x9,(%rax)
    1011:	04 99                	add    $0x99,%al
    1013:	09 00                	or     %eax,(%rax)
    1015:	00 1e                	add    %bl,(%rsi)
    1017:	07                   	(bad)
    1018:	00 09                	add    %cl,(%rcx)
    101a:	04 d6                	add    $0xd6,%al
    101c:	10 00                	adc    %al,(%rax)
    101e:	00 1f                	add    %bl,(%rdi)
    1020:	1e                   	(bad)
    1021:	c1 00 09             	roll   $0x9,(%rax)
  if (!lru_map) {
    1024:	04 bf                	add    $0xbf,%al
    1026:	00 00                	add    %al,(%rax)
    1028:	00 1e                	add    %bl,(%rsi)
    102a:	14 00                	adc    $0x0,%al
    102c:	09 04 db             	or     %eax,(%rbx,%rbx,8)
    102f:	10 00                	adc    %al,(%rax)
  if ((vip_info->flags & F_QUIC_VIP)) {
    1031:	00 1e                	add    %bl,(%rsi)
    1033:	c2 00 09             	ret    $0x900
    1036:	04 db                	add    $0xdb,%al
    1038:	10 00                	adc    %al,(%rax)
    103a:	00 00                	add    %al,(%rax)
    103c:	00 00                	add    %al,(%rax)
    bool is_icmp = (pckt.flags & F_ICMP);
    103e:	0b 43 10             	or     0x10(%rbx),%eax
    1041:	00 00                	add    %al,(%rax)
    if (is_icmp) {
    1043:	20 ab 38 07 3f 0c    	and    %ch,0xc3f0738(%rbx)
    1049:	21 a2 99 09 00 00    	and    %esp,0x999(%rdx)
    104f:	07                   	(bad)
    1050:	40 0c 00             	rex or $0x0,%al
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
    1053:	21 a3 99 09 00 00    	and    %esp,0x999(%rbx)
    1059:	07                   	(bad)
    105a:	41 0c 08             	rex.B or $0x8,%al
    105d:	21 a4 99 09 00 00 07 	and    %esp,0x7000009(%rcx,%rbx,4)
      if (!quic_packets_stats) {
    1064:	42 0c 10             	rex.X or $0x10,%al
    1067:	21 a5 99 09 00 00    	and    %esp,0x999(%rbp)
  bool is_icmp = (pckt->flags & F_ICMP);
    106d:	07                   	(bad)
    106e:	43 0c 18             	rex.XB or $0x18,%al
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1071:	21 a6 9a 10 00 00    	and    %esp,0x109a(%rsi)
    1077:	07                   	(bad)
    1078:	44 0c 20             	rex.R or $0x20,%al
    107b:	21 a8 a1 10 00 00    	and    %ebp,0x10a1(%rax)
    1081:	07                   	(bad)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    1082:	45 0c 28             	rex.RB or $0x28,%al
    1085:	21 aa bf 00 00 00    	and    %ebp,0xbf(%rdx)
    108b:	07                   	(bad)
    108c:	46 0c 30             	rex.RX or $0x30,%al
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    108f:	21 24 bf             	and    %esp,(%rdi,%rdi,4)
    1092:	00 00                	add    %al,(%rax)
    1094:	00 07                	add    %al,(%rdi)
    1096:	47 0c 34             	rex.RXB or $0x34,%al
    1099:	00 0b                	add    %cl,(%rbx)
    109b:	9f                   	lahf
  if (!connId) {
    109c:	10 00                	adc    %al,(%rax)
    109e:	00 22                	add    %ah,(%rdx)
    10a0:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    10a1:	0b a6 10 00 00 22    	or     0x22000010(%rsi),%esp
  __u8 connIdVersion = (connId[0] >> 6);
    10a7:	a9 06 ae 02 01       	test   $0x102ae06,%eax
    10ac:	0d b2 30 03 2b       	or     $0x2b0330b2,%eax
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10b1:	0a b0 1c 03 00 00    	or     0x31c(%rax),%dh
    10b7:	03 2c 00             	add    (%rax,%rax,1),%ebp
    10ba:	0a b1 bf 00 00 00    	or     0xbf(%rcx),%dh
    10c0:	03 2d 28 0a 24 16    	add    0x16240a28(%rip),%ebp        # 16241aee <_license+0x1623f759>
    10c6:	01 00                	add    %eax,(%rax)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    10c8:	00 03                	add    %al,(%rbx)
    10ca:	2e 2c 0a             	cs sub $0xa,%al
    10cd:	91                   	xchg   %eax,%ecx
    10ce:	16                   	(bad)
    10cf:	01 00                	add    %eax,(%rax)
    10d1:	00 03                	add    %al,(%rbx)
    10d3:	30 2d 00 23 b6 00    	xor    %ch,0xb62300(%rip)        # b633d9 <_license+0xb61044>
    10d9:	00 00                	add    %al,(%rax)
    10db:	23 bf 00 00 00 0d    	and    0xd000000(%rdi),%edi
    10e1:	cd 08                	int    $0x8
    10e3:	0c 3a                	or     $0x3a,%al
    10e5:	0a ca                	or     %dl,%cl
    10e7:	b6 00                	mov    $0x0,%dh
    10e9:	00 00                	add    %al,(%rax)
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    10eb:	0c 3b                	or     $0x3b,%al
    10ed:	00 0a                	add    %cl,(%rdx)
    10ef:	cb                   	lret
    10f0:	16                   	(bad)
    10f1:	01 00                	add    %eax,(%rax)
    10f3:	00 0c 3c             	add    %cl,(%rsp,%rdi,1)
    10f6:	04 0a                	add    $0xa,%al
      if (!data_stats) {
    10f8:	cc                   	int3
    10f9:	a8 10                	test   $0x10,%al
    10fb:	00 00                	add    %al,(%rax)
    10fd:	0c 3d                	or     $0x3d,%al
    10ff:	05 00 1c d0 0c       	add    $0xcd01c00,%eax
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    1104:	c3                   	ret
    1105:	01 b6 00 00 00 1d    	add    %esi,0x1d000000(%rsi)
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    110b:	af                   	scas   %es:(%rdi),%eax
    110c:	0c c4                	or     $0xc4,%al
    110e:	01 6e 11             	add    %ebp,0x11(%rsi)
    1111:	00 00                	add    %al,(%rax)
    1113:	1d 96 0c c5 01       	sbb    $0x1c50c96,%eax
    1118:	6d                   	insl   (%dx),%es:(%rdi)
        data_stats->v2 += 1;
    1119:	09 00                	or     %eax,(%rax)
    111b:	00 1d ac 0c c6 01    	add    %bl,0x1c60cac(%rip)        # 1c61dcd <_license+0x1c5fa38>
    1121:	fe 00                	incb   (%rax)
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1123:	00 00                	add    %al,(%rax)
    1125:	1d b4 0c c7 01       	sbb    $0x1c70cb4,%eax
    112a:	43 0a 00             	rex.XB or (%r8),%al
    112d:	00 1d bb 0c c8 01    	add    %bl,0x1c80cbb(%rip)        # 1c81dee <_license+0x1c7fa59>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1133:	4d 0a 00             	rex.WRB or (%r8),%r8b
    1136:	00 1d a2 0c c9 01    	add    %bl,0x1c90ca2(%rip)        # 1c91dde <_license+0x1c8fa49>
    113c:	99                   	cltd
    113d:	09 00                	or     %eax,(%rax)
    113f:	00 1d a3 0c ca 01    	add    %bl,0x1ca0ca3(%rip)        # 1ca1de8 <_license+0x1c9fa53>
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1145:	99                   	cltd
    1146:	09 00                	or     %eax,(%rax)
    1148:	00 1d ad 0c cb 01    	add    %bl,0x1cb0cad(%rip)        # 1cb1dfb <_license+0x1cafa66>
    114e:	a8 10                	test   $0x10,%al
    1150:	00 00                	add    %al,(%rax)
    1152:	1e                   	(bad)
    1153:	d1 0c cd 01 3c 0b 00 	rorl   0xb3c01(,%rcx,8)
    115a:	00 1e                	add    %bl,(%rsi)
    115c:	d2 0c ce             	rorb   %cl,(%rsi,%rcx,8)
    115f:	01 52 0a             	add    %edx,0xa(%rdx)
    1162:	00 00                	add    %al,(%rax)
    1164:	1e                   	(bad)
    1165:	be 0c cc 01 fe       	mov    $0xfe01cc0c,%esi
  if (!per_vip_stats) {
    116a:	00 00                	add    %al,(%rax)
    116c:	00 00                	add    %al,(%rax)
    116e:	0b ac 10 00 00 1c d3 	or     -0x2ce40000(%rax,%rdx,1),%ebp
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1175:	0e                   	(bad)
    1176:	13 01                	adc    (%rcx),%eax
    1178:	b6 00                	mov    $0x0,%dh
    117a:	00 00                	add    %al,(%rax)
    117c:	1d a2 0e 14 01       	sbb    $0x1140ea2,%eax
    1181:	99                   	cltd
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1182:	09 00                	or     %eax,(%rax)
    1184:	00 1d a3 0e 15 01    	add    %bl,0x1150ea3(%rip)        # 115202d <_license+0x114fc98>
        quic_packets_stats->cid_initial += 1;
    118a:	99                   	cltd
    118b:	09 00                	or     %eax,(%rax)
    118d:	00 1d d4 0e 16 01    	add    %bl,0x1160ed4(%rip)        # 1162067 <_license+0x115fcd2>
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1193:	fe 00                	incb   (%rax)
    1195:	00 00                	add    %al,(%rax)
    1197:	1d af 0e 17 01       	sbb    $0x1170eaf,%eax
    119c:	6e                   	outsb  %ds:(%rsi),(%dx)
    119d:	11 00                	adc    %eax,(%rax)
    119f:	00 1e                	add    %bl,(%rsi)
    11a1:	d5                   	(bad)
    11a2:	0e                   	(bad)
    11a3:	18 01                	sbb    %al,(%rcx)
    11a5:	01 12                	add    %edx,(%rdx)
    11a7:	00 00                	add    %al,(%rax)
    11a9:	1e                   	(bad)
    11aa:	d1 0e                	rorl   (%rsi)
    11ac:	19 01                	sbb    %eax,(%rcx)
    11ae:	3c 0b                	cmp    $0xb,%al
    11b0:	00 00                	add    %al,(%rax)
    11b2:	1f                   	(bad)
    11b3:	1e                   	(bad)
    11b4:	b7 0e                	mov    $0xe,%bh
    11b6:	26 01 bf 00 00 00 1e 	es add %edi,0x1e000000(%rdi)
  if (!per_vip_stats) {
    11bd:	e1 0e                	loope  11cd <balancer_ingress+0x11cd>
    11bf:	27                   	(bad)
    11c0:	01 85 05 00 00 1e    	add    %eax,0x1e000005(%rbp)
    11c6:	de 0e                	fimuls (%rsi)
    11c8:	2d 01 a0 02 00       	sub    $0x2a001,%eax
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    11cd:	00 1f                	add    %bl,(%rdi)
    11cf:	1e                   	(bad)
    11d0:	c0 0e 28             	rorb   $0x28,(%rsi)
    11d3:	01 99 09 00 00 1e    	add    %ebx,0x1e000009(%rcx)
    11d9:	07                   	(bad)
    11da:	0e                   	(bad)
    11db:	28 01                	sub    %al,(%rcx)
  if (!connId) {
    11dd:	d6                   	(bad)
    11de:	10 00                	adc    %al,(%rax)
    11e0:	00 1f                	add    %bl,(%rdi)
    11e2:	1e                   	(bad)
    11e3:	c1 0e 28             	rorl   $0x28,(%rsi)
    11e6:	01 bf 00 00 00 1e    	add    %edi,0x1e000000(%rdi)
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    11ec:	14 0e                	adc    $0xe,%al
    11ee:	28 01                	sub    %al,(%rcx)
    11f0:	db 10                	fistl  (%rax)
    11f2:	00 00                	add    %al,(%rax)
    11f4:	1e                   	(bad)
    11f5:	c2 0e 28             	ret    $0x280e
    11f8:	01 db                	add    %ebx,%ebx
    11fa:	10 00                	adc    %al,(%rax)
    11fc:	00 00                	add    %al,(%rax)
    11fe:	00 00                	add    %al,(%rax)
    1200:	00 0b                	add    %cl,(%rbx)
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1202:	06                   	(bad)
    1203:	12 00                	adc    (%rax),%al
    1205:	00 0d e0 08 13 59    	add    %cl,0x591308e0(%rip)        # 59131aeb <_license+0x5912f756>
    120b:	0a 07                	or     (%rdi),%al
    120d:	16                   	(bad)
    120e:	01 00                	add    %eax,(%rax)
    1210:	00 13                	add    %dl,(%rbx)
    1212:	5a                   	pop    %rdx
    1213:	00 0a                	add    %cl,(%rdx)
    1215:	d6                   	(bad)
    1216:	16                   	(bad)
    1217:	01 00                	add    %eax,(%rax)
    1219:	00 13                	add    %dl,(%rbx)
    121b:	5b                   	pop    %rbx
    121c:	01 0a                	add    %ecx,(%rdx)
    121e:	d7                   	xlat   %ds:(%rbx)
    121f:	e6 0b                	out    %al,$0xb
    1221:	00 00                	add    %al,(%rax)
    1223:	13 5c 02 0a          	adc    0xa(%rdx,%rax,1),%ebx
      if (qpr.server_id > 0) {
    1227:	d8 2f                	fsubrs (%rdi)
    1229:	12 00                	adc    (%rax),%al
    122b:	00 13                	add    %dl,(%rbx)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    122d:	68 04 0f 04 13       	push   $0x13040f04
    1232:	5d                   	pop    %rbp
    1233:	0a d9                	or     %cl,%bl
    1235:	3c 12                	cmp    $0x12,%al
    1237:	00 00                	add    %al,(%rax)
    1239:	13 61 00             	adc    0x0(%rcx),%esp
    quic_packets_stats->cid_v1 += 1;
    123c:	09 04 13             	or     %eax,(%rbx,%rdx,1)
    123f:	5e                   	pop    %rsi
    1240:	0a 93 ed 0a 00 00    	or     0xaed(%rbx),%dl
    1246:	13 5f 00             	adc    0x0(%rdi),%ebx
    quic_packets_stats->cid_v3 += 1;
    1249:	0a da                	or     %dl,%bl
    124b:	ed                   	in     (%dx),%eax
    124c:	0a 00                	or     (%rax),%al
    quic_packets_stats->cid_v0 += 1;
    124e:	00 13                	add    %dl,(%rbx)
    1250:	60                   	(bad)
    1251:	02 00                	add    (%rax),%al
    1253:	0a db                	or     %bl,%bl
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1255:	bc 01 00 00 13       	mov    $0x13000001,%esp
    125a:	62                   	(bad)
        if (real_pos) {
    125b:	00 0a                	add    %cl,(%rdx)
    125d:	dc 65 12             	fsubl  0x12(%rbp)
    1260:	00 00                	add    %al,(%rax)
    1262:	13 66 00             	adc    0x0(%rsi),%esp
    1265:	09 04 13             	or     %eax,(%rbx,%rdx,1)
    1268:	63 0a                	movsxd (%rdx),%ecx
    126a:	dd ed                	fucomp %st(5)
    126c:	0a 00                	or     (%rax),%al
    126e:	00 13                	add    %dl,(%rbx)
          key = *real_pos;
    1270:	64 00 0a             	add    %cl,%fs:(%rdx)
    1273:	de ed                	fsubrp %st,%st(5)
          if (key == 0) {
    1275:	0a 00                	or     (%rax),%al
            pckt.real_index = key;
    1277:	00 13                	add    %dl,(%rbx)
    1279:	65 02 00             	add    %gs:(%rax),%al
            dst = bpf_map_lookup_elem(&reals, &key);
    127c:	0a df                	or     %bh,%bl
    127e:	87 12                	xchg   %edx,(%rdx)
    1280:	00 00                	add    %al,(%rax)
            if (!dst) {
    1282:	13 67 00             	adc    0x0(%rdi),%esp
    1285:	00 00                	add    %al,(%rax)
    1287:	04 16                	add    $0x16,%al
    1289:	01 00                	add    %eax,(%rax)
    128b:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 12f5 <balancer_ingress+0x12f5>
    1291:	04 00                	add    $0x0,%al
    1293:	1c e2                	sbb    $0xe2,%al
    1295:	0e                   	(bad)
    1296:	53                   	push   %rbx
    1297:	01 b6 00 00 00 1d    	add    %esi,0x1d000000(%rsi)
    129d:	a2 0e 54 01 99 09 00 	movabs %al,0x1d0000099901540e
    12a4:	00 1d 
    12a6:	a3 0e 55 01 99 09 00 	movabs %eax,0x1d0000099901550e
    12ad:	00 1d 
    12af:	d4                   	(bad)
  if (dst_lru) {
    12b0:	0e                   	(bad)
    12b1:	56                   	push   %rsi
    12b2:	01 fe                	add    %edi,%esi
    12b4:	00 00                	add    %al,(%rax)
    12b6:	00 1d af 0e 57 01    	add    %bl,0x1570eaf(%rip)        # 157216b <_license+0x156fdd6>
    if (dst_lru->pos == pckt->real_index) {
    12bc:	6e                   	outsb  %ds:(%rsi),(%dx)
    12bd:	11 00                	adc    %eax,(%rax)
    12bf:	00 1d 96 0e 58 01    	add    %bl,0x1580e96(%rip)        # 158215b <_license+0x157fdc6>
              quic_packets_stats->dst_match_in_lru += 1;
    12c5:	16                   	(bad)
    12c6:	01 00                	add    %eax,(%rax)
    12c8:	00 00                	add    %al,(%rax)
    12ca:	24 e3                	and    $0xe3,%al
    12cc:	0e                   	(bad)
    12cd:	3e b6 00             	ds mov $0x0,%dh
    12d0:	00 00                	add    %al,(%rax)
    12d2:	25 a2 0e 3f 99       	and    $0x993f0ea2,%eax
    12d7:	09 00                	or     %eax,(%rax)
    12d9:	00 25 a3 0e 40 99    	add    %ah,-0x66bff15d(%rip)        # ffffffff99402182 <server_id_map+0x36ff80d19182>
    12df:	09 00                	or     %eax,(%rax)
    12e1:	00 26                	add    %ah,(%rsi)
    12e3:	e4 0e                	in     $0xe,%al
  original_sport = pckt.flow.port16[0];
    12e5:	43 bf 00 00 00 26    	rex.XB mov $0x26000000,%r15d
    12eb:	e5 0e                	in     $0xe,%eax
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    12ed:	44 fe 00             	rex.R incb (%rax)
    12f0:	00 00                	add    %al,(%rax)
    12f2:	26 d4                	es (bad)
    12f4:	0e                   	(bad)
    12f5:	45 fe 00             	rex.RB incb (%r8)
    12f8:	00 00                	add    %al,(%rax)
        !(vip_info->flags & F_LRU_BYPASS)) {
    12fa:	26 d5                	es (bad)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    12fc:	0e                   	(bad)
    12fd:	42 01 12             	rex.X add %edx,(%rdx)
    1300:	00 00                	add    %al,(%rax)
    1302:	26 d1 0e             	es rorl (%rsi)
    1305:	41 3c 0b             	rex.B cmp $0xb,%al
    1308:	00 00                	add    %al,(%rax)
    130a:	00 27                	add    %ah,(%rdi)
    130c:	e6 0f                	out    %al,$0xf
    130e:	32 25 d1 0f 33 99    	xor    -0x66ccf02f(%rip),%ah        # ffffffff993322e5 <server_id_map+0x36ff80c492e5>
    1314:	09 00                	or     %eax,(%rax)
    1316:	00 25 e5 0f 34 43    	add    %ah,0x43340fe5(%rip)        # 43342301 <_license+0x4333ff6c>
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    131c:	0a 00                	or     (%rax),%al
    131e:	00 26                	add    %ah,(%rsi)
    1320:	e7 0f                	out    %eax,$0xf
    1322:	35 4d 0a 00 00       	xor    $0xa4d,%eax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1327:	1f                   	(bad)
    1328:	26 e8 0f 37 b6 00    	es call b64a3d <_license+0xb626a8>
    132e:	00 00                	add    %al,(%rax)
    1330:	00 00                	add    %al,(%rax)
    1332:	24 e9                	and    $0xe9,%al
    1334:	0e                   	(bad)
    1335:	e4 b6                	in     $0xb6,%al
    1337:	00 00                	add    %al,(%rax)
    1339:	00 25 a2 0e e5 99    	add    %ah,-0x661af15e(%rip)        # ffffffff99e521e1 <server_id_map+0x36ff817691e1>
    133f:	09 00                	or     %eax,(%rax)
    1341:	00 25 a3 0e e6 99    	add    %ah,-0x6619f15d(%rip)        # ffffffff99e621ea <server_id_map+0x36ff817791ea>
    dst_lru->atime = cur_time;
    1347:	09 00                	or     %eax,(%rax)
    1349:	00 25 d4 0e e7 fe    	add    %ah,-0x118f12c(%rip)        # fffffffffee72223 <server_id_map+0x36ffe6789223>
    134f:	00 00                	add    %al,(%rax)
  key = dst_lru->pos;
    1351:	00 25 af 0e e8 6e    	add    %ah,0x6ee80eaf(%rip)        # 6ee82206 <_license+0x6ee7fe71>
  pckt->real_index = key;
    1357:	11 00                	adc    %eax,(%rax)
    1359:	00 26                	add    %ah,(%rsi)
  *real = bpf_map_lookup_elem(&reals, &key);
    135b:	d5                   	(bad)
    135c:	0e                   	(bad)
    135d:	e9 b2 13 00 00       	jmp    2714 <_license+0x37f>
    1362:	26 d2 0e             	es rorb %cl,(%rsi)
    1365:	ea                   	(bad)
    1366:	52                   	push   %rdx
    1367:	0a 00                	or     (%rax),%al
    1369:	00 1f                	add    %bl,(%rdi)
    136b:	26 b7 0e             	es mov $0xe,%bh
    136e:	f8                   	clc
    136f:	bf 00 00 00 28       	mov    $0x28000000,%edi
    1374:	02 01                	add    (%rcx),%al
    1376:	0e                   	(bad)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1377:	f9                   	stc
    1378:	85 05 00 00 26 de    	test   %eax,-0x21da0000(%rip)        # ffffffffde26137e <server_id_map+0x36ffc5b7837e>
    137e:	0e                   	(bad)
    137f:	ff                   	(bad)
    1380:	bf 00 00 00 1f       	mov    $0x1f000000,%edi
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1385:	26 c0 0e fa          	es rorb $0xfa,(%rsi)
    1389:	99                   	cltd
    138a:	09 00                	or     %eax,(%rax)
    138c:	00 26                	add    %ah,(%rsi)
    138e:	07                   	(bad)
    138f:	0e                   	(bad)
    1390:	fa                   	cli
    1391:	d6                   	(bad)
    1392:	10 00                	adc    %al,(%rax)
    1394:	00 1f                	add    %bl,(%rdi)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1396:	26 c1 0e fa          	es rorl $0xfa,(%rsi)
    139a:	bf 00 00 00 26       	mov    $0x26000000,%edi
    139f:	14 0e                	adc    $0xe,%al
    13a1:	fa                   	cli
  if (!conn_rate_stats) {
    13a2:	db 10                	fistl  (%rax)
    13a4:	00 00                	add    %al,(%rax)
    13a6:	26 c2 0e fa          	es ret $0xfa0e
    13aa:	db 10                	fistl  (%rax)
    13ac:	00 00                	add    %al,(%rax)
    13ae:	00 00                	add    %al,(%rax)
    13b0:	00 00                	add    %al,(%rax)
    13b2:	0b b7 13 00 00 29    	or     0x29000013(%rdi),%esi
  *cur_time = bpf_ktime_get_ns();
    13b8:	01 01                	add    %eax,(%rcx)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    13ba:	08 14 08             	or     %dl,(%rax,%rcx,1)
    13bd:	0a ea                	or     %dl,%ch
    13bf:	16                   	(bad)
    13c0:	01 00                	add    %eax,(%rax)
    13c2:	00 14 0a             	add    %dl,(%rdx,%rcx,1)
    13c5:	00 0a                	add    %cl,(%rdx)
    13c7:	eb 16                	jmp    13df <balancer_ingress+0x13df>
    13c9:	01 00                	add    %eax,(%rax)
    conn_rate_stats->v1 = 1;
    13cb:	00 14 0b             	add    %dl,(%rbx,%rcx,1)
    13ce:	01 0a                	add    %ecx,(%rdx)
    13d0:	ec                   	in     (%dx),%al
    conn_rate_stats->v2 = *cur_time;
    13d1:	e6 0b                	out    %al,$0xb
    13d3:	00 00                	add    %al,(%rax)
    13d5:	14 0c                	adc    $0xc,%al
    conn_rate_stats->v1 += 1;
    13d7:	02 0a                	add    (%rdx),%cl
    13d9:	ed                   	in     (%dx),%eax
    13da:	e1 13                	loope  13ef <balancer_ingress+0x13ef>
    13dc:	00 00                	add    %al,(%rax)
    13de:	14 3f                	adc    $0x3f,%al
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    13e0:	04 0f                	add    $0xf,%al
    13e2:	04 14                	add    $0x14,%al
    13e4:	0f 0a                	(bad)
    13e6:	ee                   	out    %al,(%dx)
    13e7:	1d 14 00 00 14       	sbb    $0x14000014,%eax
    13ec:	10 00                	adc    %al,(%rax)
    13ee:	0a ef                	or     %bh,%ch
    13f0:	29 14 00             	sub    %edx,(%rax,%rax,1)
    13f3:	00 14 11             	add    %dl,(%rcx,%rdx,1)
    13f6:	00 0a                	add    %cl,(%rdx)
    13f8:	f0 87 12             	lock xchg %edx,(%rdx)
    13fb:	00 00                	add    %al,(%rax)
    13fd:	14 12                	adc    $0x12,%al
    13ff:	00 0a                	add    %cl,(%rdx)
    1401:	f1                   	int1
    1402:	35 14 00 00 14       	xor    $0x14000014,%eax
    1407:	17                   	(bad)
    1408:	00 0a                	add    %cl,(%rdx)
    140a:	f4                   	hlt
    140b:	4d 14 00             	rex.WRB adc $0x0,%al
    if (down_reals_map) {
    140e:	00 14 28             	add    %dl,(%rax,%rbp,1)
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1411:	00 0a                	add    %cl,(%rdx)
    1413:	fa                   	cli
    1414:	85 14 00             	test   %edx,(%rax,%rax,1)
    1417:	00 14 3d 00 00 00 04 	add    %dl,0x4000000(,%rdi,1)
    141e:	bc 01 00 00 05       	mov    $0x5000001,%esp
    1423:	64 00 00             	add    %al,%fs:(%rax)
      if (down_real) {
    1426:	00 01                	add    %al,(%rcx)
    1428:	00 04 ed 0a 00 00 05 	add    %al,0x500000a(,%rbp,8)
    142f:	64 00 00             	add    %al,%fs:(%rax)
    1432:	00 02                	add    %al,(%rdx)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1434:	00 0d f3 04 14 14    	add    %cl,0x141404f3(%rip)        # 1414192d <_license+0x1413f598>
    143a:	0a f2                	or     %dl,%dh
    143c:	ed                   	in     (%dx),%eax
    143d:	0a 00                	or     (%rax),%al
    143f:	00 14 15 00 0a da ed 	add    %dl,-0x1225f600(,%rdx,1)
        if (stats_data) {
    1446:	0a 00                	or     (%rax),%al
    1448:	00 14 16             	add    %dl,(%rsi,%rdx,1)
          stats_data->v1 += 1;
    144b:	02 00                	add    (%rax),%al
    144d:	0d f9 04 14 19       	or     $0x191404f9,%eax
    if (!dst) {
    1452:	1b df                	sbb    %edi,%ebx
    1454:	bf 00 00 00 14       	mov    $0x14000000,%edi
    1459:	1b 05 00 1b f5 bf    	sbb    -0x400ae500(%rip),%eax        # ffffffffbff52f5f <server_id_map+0x36ffa7869f5f>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    145f:	00 00                	add    %al,(%rax)
    1461:	00 14 1c             	add    %dl,(%rsp,%rbx,1)
    1464:	01 05 1b f6 bf 00    	add    %eax,0xbff61b(%rip)        # c00a85 <_license+0xbfe6f0>
    146a:	00 00                	add    %al,(%rax)
    146c:	14 1d                	adc    $0x1d,%al
    146e:	01 06                	add    %eax,(%rsi)
    1470:	1b f7                	sbb    %edi,%esi
    1472:	bf 00 00 00 14       	mov    $0x14000000,%edi
    1477:	1e                   	(bad)
    1478:	01 07                	add    %eax,(%rdi)
    147a:	1b f8                	sbb    %eax,%edi
    147c:	bf 00 00 00 14       	mov    $0x14000000,%edi
  if (!data_stats) {
    1481:	1f                   	(bad)
    1482:	18 08                	sbb    %cl,(%rax)
    1484:	00 29                	add    %ch,(%rcx)
    1486:	00 01                	add    %al,(%rcx)
    1488:	04 14                	add    $0x14,%al
    148a:	2a 0a                	sub    (%rdx),%cl
  data_stats->v1 += 1;
    148c:	86 16                	xchg   %dl,(%rsi)
  data_stats->v2 += pkt_bytes;
    148e:	01 00                	add    %eax,(%rax)
    1490:	00 14 2b             	add    %dl,(%rbx,%rbp,1)
    1493:	00 1b                	add    %bl,(%rbx)
    1495:	df 16                	fists  (%rsi)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1497:	01 00                	add    %eax,(%rax)
    1499:	00 14 2d 03 08 1b fb 	add    %dl,-0x4e4f7fd(,%rbp,1)
    14a0:	16                   	(bad)
    14a1:	01 00                	add    %eax,(%rax)
    14a3:	00 14 2e             	add    %dl,(%rsi,%rbp,1)
    14a6:	02 0b                	add    (%rbx),%cl
    14a8:	1b fc                	sbb    %esp,%edi
    14aa:	16                   	(bad)
    14ab:	01 00                	add    %eax,(%rax)
    14ad:	00 14 2f             	add    %dl,(%rdi,%rbp,1)
    14b0:	01 0d 1b fd 16 01    	add    %ecx,0x116fd1b(%rip)        # 11711d1 <_license+0x116ee3c>
    14b6:	00 00                	add    %al,(%rax)
    14b8:	14 30                	adc    $0x30,%al
    14ba:	01 0e                	add    %ecx,(%rsi)
    14bc:	1b fe                	sbb    %esi,%edi
  if (!data_stats) {
    14be:	16                   	(bad)
    14bf:	01 00                	add    %eax,(%rax)
    14c1:	00 14 31             	add    %dl,(%rcx,%rsi,1)
    14c4:	01 0f                	add    %ecx,(%rdi)
    14c6:	0a ff                	or     %bh,%bh
  data_stats->v1 += 1;
    14c8:	ed                   	in     (%dx),%eax
    14c9:	0a 00                	or     (%rax),%al
  data_stats->v2 += pkt_bytes;
    14cb:	00 14 3c             	add    %dl,(%rsp,%rdi,1)
    14ce:	02 00                	add    (%rax),%al
    14d0:	2a 03                	sub    (%rbx),%al
  pckt.flow.port16[0] = original_sport;
    14d2:	01 0e                	add    %ecx,(%rsi)
    14d4:	5e                   	pop    %rsi
    14d5:	b6 00                	mov    $0x0,%dh
  if (dst->flags & F_IPV6) {
    14d7:	00 00                	add    %al,(%rax)
    14d9:	25 a2 0e 5f 99       	and    $0x995f0ea2,%eax
    14de:	09 00                	or     %eax,(%rax)
    14e0:	00 25 a3 0e 60 99    	add    %ah,-0x669ff15d(%rip)        # ffffffff99602389 <server_id_map+0x36ff80f19389>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    14e6:	09 00                	or     %eax,(%rax)
    14e8:	00 26                	add    %ah,(%rsi)
    14ea:	e4 0e                	in     $0xe,%al
    14ec:	63 c4                	movsxd %esp,%eax
    14ee:	01 00                	add    %eax,(%rax)
    14f0:	00 26                	add    %ah,(%rsi)
    14f2:	d4                   	(bad)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    14f3:	0e                   	(bad)
    14f4:	64 fe 00             	incb   %fs:(%rax)
    14f7:	00 00                	add    %al,(%rax)
    14f9:	26 d2 0e             	es rorb %cl,(%rsi)
    14fc:	61                   	(bad)
    14fd:	52                   	push   %rdx
    14fe:	0a 00                	or     (%rax),%al
    1500:	00 26                	add    %ah,(%rsi)
    1502:	d5                   	(bad)
    1503:	0e                   	(bad)
    1504:	62 b2                	(bad)
    1506:	13 00                	adc    (%rax),%eax
  data = (void*)(long)xdp->data;
    1508:	00 00                	add    %al,(%rax)
  data_end = (void*)(long)xdp->data_end;
    150a:	2a 04 01             	sub    (%rcx,%rax,1),%al
    150d:	0e                   	(bad)
  iph = data + sizeof(struct ethhdr);
    150e:	28 b6 00 00 00 25    	sub    %dh,0x25000000(%rsi)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1514:	a2 0e 29 99 09 00 00 	movabs %al,0xa32500000999290e
    151b:	25 a3 
    151d:	0e                   	(bad)
    151e:	2a 99 09 00 00 28    	sub    0x28000009(%rcx),%bl
    1524:	05 01 0e 2b 36       	add    $0x362b0e01,%eax
    1529:	15 00 00 28 0a       	adc    $0xa280000,%eax
    152e:	01 0e                	add    %ecx,(%rsi)
    1530:	2c 60                	sub    $0x60,%al
    1532:	15 00 00 00 0b       	adc    $0xb000000,%eax
    1537:	3b 15 00 00 29 09    	cmp    0x9290000(%rip),%edx        # 929153d <_license+0x928f1a8>
    153d:	01 0e                	add    %ecx,(%rsi)
    153f:	15 ad 2b 06 01       	adc    $0x1062bad,%eax
    1544:	60                   	(bad)
    1545:	15 00 00 15 ae       	adc    $0xae150000,%eax
  memcpy(new_eth->h_dest, cval->mac, 6);
    154a:	00 2b                	add    %ch,(%rbx)
    154c:	07                   	(bad)
    154d:	01 60 15             	add    %esp,0x15(%rax)
    1550:	00 00                	add    %al,(%rax)
    1552:	15 af 06 2b 08       	adc    $0x82b06af,%eax
    1557:	01 ed                	add    %ebp,%ebp
    1559:	0a 00                	or     (%rax),%al
    155b:	00 15 b0 0c 00 04    	add    %dl,0x4000cb0(%rip)        # 4002211 <_license+0x3fffe7c>
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1561:	1e                   	(bad)
    1562:	01 00                	add    %eax,(%rax)
    1564:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 15ce <balancer_ingress+0x15ce>
    156a:	06                   	(bad)
    156b:	00 2a                	add    %ch,(%rdx)
  new_eth->h_proto = BE_ETH_P_IP;
    156d:	0b 01                	or     (%rcx),%eax
    156f:	0f 1d a0 02 00 00 25 	nopl   0x25000002(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1576:	e5 0f                	in     $0xf,%eax
    1578:	1e                   	(bad)
    1579:	fe 00                	incb   (%rax)
    157b:	00 00                	add    %al,(%rax)
  iph->ihl = 5;
    157d:	26 e8 0f 1f b6 00    	es call b63492 <_license+0xb610fd>
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1583:	00 00                	add    %al,(%rax)
    1585:	00 2a                	add    %ch,(%rdx)
    1587:	0c 01                	or     $0x1,%al
  iph->tos = tos;
    1589:	0c 75                	or     $0x75,%al
    158b:	a8 10                	test   $0x10,%al
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    158d:	00 00                	add    %al,(%rax)
    158f:	25 a2 0c 76 99       	and    $0x99760ca2,%eax
  iph->id = 0;
    1594:	09 00                	or     %eax,(%rax)
    1596:	00 25 a3 0c 77 99    	add    %ah,-0x6688f35d(%rip)        # ffffffff9977223f <server_id_map+0x36ff8108923f>
  iph->saddr = saddr;
    159c:	09 00                	or     %eax,(%rax)
    159e:	00 25 ad 0c 78 a8    	add    %ah,-0x5787f353(%rip)        # ffffffffa8782251 <server_id_map+0x36ff90099251>
  iph->ttl = DEFAULT_TTL;
    15a4:	10 00                	adc    %al,(%rax)
    *csum += *next_iph_u16++;
    15a6:	00 25 af 0c 79 6e    	add    %ah,0x6e790caf(%rip)        # 6e79225b <_license+0x6e78fec6>
    15ac:	11 00                	adc    %eax,(%rax)
    15ae:	00 26                	add    %ah,(%rsi)
    15b0:	c6                   	(bad)
    15b1:	0c 7a                	or     $0x7a,%al
    15b3:	a8 10                	test   $0x10,%al
    15b5:	00 00                	add    %al,(%rax)
    15b7:	28 0d 01 0c 7c c9    	sub    %cl,-0x3683f3ff(%rip)        # ffffffffc97c21be <server_id_map+0x36ffb10d91be>
    15bd:	15 00 00 26 d4       	adc    $0xd4260000,%eax
    15c2:	0c 7b                	or     $0x7b,%al
    15c4:	fe 00                	incb   (%rax)
      if (pckt.flow.proto == IPPROTO_TCP) {
    15c6:	00 00                	add    %al,(%rax)
    15c8:	00 0b                	add    %cl,(%rbx)
    15ca:	ce                   	(bad)
    15cb:	15 00 00 29 1f       	adc    $0x1f290000,%eax
    15d0:	01 14 16             	add    %edx,(%rsi,%rdx,1)
    15d3:	19 2b                	sbb    %ebp,(%rbx)
    15d5:	0e                   	(bad)
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    15d6:	01 ed                	add    %ebp,%ebp
    15d8:	0a 00                	or     (%rax),%al
    15da:	00 16                	add    %dl,(%rsi)
    15dc:	1a 00                	sbb    (%rax),%al
    15de:	2b 0f                	sub    (%rdi),%ecx
    15e0:	01 ed                	add    %ebp,%ebp
        if (!lru_stats) {
    15e2:	0a 00                	or     (%rax),%al
    15e4:	00 16                	add    %dl,(%rsi)
    15e6:	1b 02                	sbb    (%rdx),%eax
    15e8:	2b 10                	sub    (%rax),%edx
    15ea:	01 bc 01 00 00 16 1c 	add    %edi,0x1c160000(%rcx,%rax,1)
        if (pckt.flags & F_SYN_SET) {
    15f1:	04 2b                	add    $0x2b,%al
    15f3:	11 01                	adc    %eax,(%rcx)
    15f5:	bc 01 00 00 16       	mov    $0x16000001,%esp
    15fa:	1d 08 2c 12 01       	sbb    $0x1122c08,%eax
  struct real_pos_lru new_dst_lru = {};
    15ff:	a0 02 00 00 16 1f 01 	movabs 0x2c60011f16000002,%al
    1606:	60 2c 
    1608:	13 01                	adc    (%rcx),%eax
    160a:	a0 02 00 00 16 20 03 	movabs 0x2c61032016000002,%al
    1611:	61 2c 
    1613:	14 01                	adc    $0x1,%al
    1615:	a0 02 00 00 16 21 04 	movabs 0x2c64042116000002,%al
    161c:	64 2c 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    161e:	15 01 a0 02 00       	adc    $0x2a001,%eax
    1623:	00 16                	add    %dl,(%rsi)
    1625:	22 01                	and    (%rcx),%al
  if (!conn_rate_stats) {
    1627:	68 2c 16 01 a0       	push   $0xffffffffa001162c
    162c:	02 00                	add    (%rax),%al
    162e:	00 16                	add    %dl,(%rsi)
    1630:	23 01                	and    (%rcx),%eax
    1632:	69 2c 17 01 a0 02 00 	imul   $0x2a001,(%rdi,%rdx,1),%ebp
  *cur_time = bpf_ktime_get_ns();
    1639:	00 16                	add    %dl,(%rsi)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    163b:	24 01                	and    $0x1,%al
    163d:	6a 2c                	push   $0x2c
    163f:	18 01                	sbb    %al,(%rcx)
    1641:	a0 02 00 00 16 25 01 	movabs 0x2c6b012516000002,%al
    1648:	6b 2c 
    conn_rate_stats->v1 = 1;
    164a:	19 01                	sbb    %eax,(%rcx)
    164c:	a0 02 00 00 16 26 01 	movabs 0x2c6c012616000002,%al
    1653:	6c 2c 
    1655:	1a 01                	sbb    (%rcx),%al
    1657:	a0 02 00 00 16 27 01 	movabs 0x2c6d012716000002,%al
    165e:	6d 2c 
    conn_rate_stats->v1 += 1;
    1660:	1b 01                	sbb    (%rcx),%eax
    1662:	a0 02 00 00 16 28 01 	movabs 0x2c6e012816000002,%al
    1669:	6e 2c 
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    166b:	1c 01                	sbb    $0x1,%al
    166d:	a0 02 00 00 16 29 01 	movabs 0x2b6f012916000002,%al
    1674:	6f 2b 
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1676:	1d 01 ed 0a 00       	sbb    $0xaed01,%eax
      pckt->flow.port16[0] = pckt->flow.port16[1];
    167b:	00 16                	add    %dl,(%rsi)
    167d:	39 0e                	cmp    %ecx,(%rsi)
    167f:	0a 97 e6 0b 00 00    	or     0xbe6(%rdi),%dl
      memset(pckt->flow.srcv6, 0, 16);
    1685:	16                   	(bad)
    1686:	3a 10                	cmp    (%rax),%dl
    1688:	2b 1e                	sub    (%rsi),%ebx
    168a:	01 ed                	add    %ebp,%ebp
    168c:	0a 00                	or     (%rax),%al
    168e:	00 16                	add    %dl,(%rsi)
    1690:	3b 12                	cmp    (%rdx),%edx
    1692:	00 2a                	add    %ch,(%rdx)
    1694:	20 01                	and    %al,(%rcx)
        jhash(pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6),
    1696:	0c 49                	or     $0x49,%al
    1698:	fe 00                	incb   (%rax)
    169a:	00 00                	add    %al,(%rax)
    169c:	25 ad 0c 4a a8       	and    $0xa84a0cad,%eax
    16a1:	10 00                	adc    %al,(%rax)
    16a3:	00 25 c6 0c 4b a8    	add    %ah,-0x57b4f33a(%rip)        # ffffffffa84b236f <server_id_map+0x36ff8fdc936f>
        pckt->flow.ports,
    16a9:	10 00                	adc    %al,(%rax)
    return jhash_2words(
    16ab:	00 26                	add    %ah,(%rsi)
    16ad:	d4                   	(bad)
    16ae:	0c 4c                	or     $0x4c,%al
    16b0:	fe 00                	incb   (%rax)
    16b2:	00 00                	add    %al,(%rax)
    16b4:	00 2a                	add    %ch,(%rdx)
    16b6:	21 01                	and    %eax,(%rcx)
    16b8:	00 cb                	add    %cl,%bl
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    16ba:	b6 00                	mov    $0x0,%dh
    16bc:	00 00                	add    %al,(%rax)
    16be:	25 af 00 cb 6e       	and    $0x6ecb00af,%eax
    16c3:	11 00                	adc    %eax,(%rax)
    16c5:	00 25 ad 00 cb a8    	add    %ah,-0x5734ff53(%rip)        # ffffffffa8cb1778 <server_id_map+0x36ff905c8778>
    16cb:	10 00                	adc    %al,(%rax)
    16cd:	00 25 bf 00 cb 39    	add    %ah,0x39cb00bf(%rip)        # 39cb1792 <_license+0x39caf3fd>
    16d3:	17                   	(bad)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    16d4:	00 00                	add    %al,(%rax)
    16d6:	28 22                	sub    %ah,(%rdx)
    16d8:	01 00                	add    %eax,(%rax)
    16da:	cc                   	int3
    16db:	97                   	xchg   %eax,%edi
    16dc:	01 00                	add    %eax,(%rax)
    16de:	00 28                	add    %ch,(%rax)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    16e0:	23 01                	and    (%rcx),%eax
    16e2:	00 d5                	add    %dl,%ch
    if (!real_pos) {
    16e4:	ba 00 00 00 26       	mov    $0x26000000,%edx
    16e9:	b8 00 cd 85 05       	mov    $0x585cd00,%eax
    16ee:	00 00                	add    %al,(%rax)
    16f0:	1f                   	(bad)
    16f1:	26 c0 00 d5          	es rolb $0xd5,(%rax)
    16f5:	99                   	cltd
    16f6:	09 00                	or     %eax,(%rax)
    16f8:	00 26                	add    %ah,(%rsi)
    16fa:	07                   	(bad)
    16fb:	00 d5                	add    %dl,%ch
    16fd:	d6                   	(bad)
    16fe:	10 00                	adc    %al,(%rax)
    1700:	00 00                	add    %al,(%rax)
    key = *real_pos;
    1702:	1f                   	(bad)
    1703:	26 b7 00             	es mov $0x0,%bh
    if (key == 0) {
    1706:	d9 bf 00 00 00 1f    	fnstcw 0x1f000000(%rdi)
  pckt->real_index = key;
    170c:	26 c0 00 da          	es rolb $0xda,(%rax)
  *real = bpf_map_lookup_elem(&reals, &key);
    1710:	99                   	cltd
    1711:	09 00                	or     %eax,(%rax)
    1713:	00 26                	add    %ah,(%rsi)
  if (!(*real)) {
    1715:	07                   	(bad)
    1716:	00 da                	add    %bl,%dl
    1718:	d6                   	(bad)
    1719:	10 00                	adc    %al,(%rax)
    171b:	00 1f                	add    %bl,(%rdi)
    171d:	26 c1 00 da          	es roll $0xda,(%rax)
    1721:	bf 00 00 00 26       	mov    $0x26000000,%edi
    1726:	14 00                	adc    $0x0,%al
    1728:	da db                	fcmovu %st(3),%st
    172a:	10 00                	adc    %al,(%rax)
    172c:	00 26                	add    %ah,(%rsi)
    172e:	c2 00 da             	ret    $0xda00
    1731:	db 10                	fistl  (%rax)
    1733:	00 00                	add    %al,(%rax)
    1735:	00 00                	add    %al,(%rax)
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1737:	00 00                	add    %al,(%rax)
    1739:	0b a8 10 00 00 2d    	or     0x2d000010(%rax),%ebp
    173f:	24 01                	and    $0x1,%al
    1741:	06                   	(bad)
    1742:	9a                   	(bad)
    if (pckt->flow.proto == IPPROTO_UDP) {
    1743:	01 99 09 00 00 2e    	add    %ebx,0x2e000009(%rcx)
    1749:	25 01 06 9a 01       	and    $0x19a0601,%eax
      new_dst_lru.atime = cur_time;
    174e:	99                   	cltd
    new_dst_lru.pos = key;
    174f:	09 00                	or     %eax,(%rax)
    1751:	00 1d 09 06 9a 01    	add    %bl,0x19a0609(%rip)        # 19a1d60 <_license+0x199f9cb>
BPF_MAP_OPS_INLINE(map_update_elem,,
    1757:	99                   	cltd
    1758:	09 00                	or     %eax,(%rax)
    175a:	00 00                	add    %al,(%rax)
    175c:	2a 26                	sub    (%rsi),%ah
    175e:	01 10                	add    %edx,(%rax)
    1760:	55                   	push   %rbp
    1761:	b6 00                	mov    $0x0,%dh
    1763:	00 00                	add    %al,(%rax)
    1765:	25 a2 10 55 99       	and    $0x995510a2,%eax
    176a:	09 00                	or     %eax,(%rax)
    176c:	00 25 a3 10 55 99    	add    %ah,-0x66aaef5d(%rip)        # ffffffff99552815 <server_id_map+0x36ff80e69815>
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    1772:	09 00                	or     %eax,(%rax)
    1774:	00 2f                	add    %ch,(%rdi)
    1776:	27                   	(bad)
    1777:	01 10                	add    %edx,(%rax)
    1779:	55                   	push   %rbp
    177a:	b6 00                	mov    $0x0,%dh
    177c:	00 00                	add    %al,(%rax)
    177e:	25 ad 10 55 a8       	and    $0xa85510ad,%eax
    1783:	10 00                	adc    %al,(%rax)
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    1785:	00 26                	add    %ah,(%rsi)
    1787:	d2 10                	rclb   %cl,(%rax)
    1789:	57                   	push   %rdi
    178a:	52                   	push   %rdx
    178b:	0a 00                	or     (%rax),%al
    178d:	00 26                	add    %ah,(%rsi)
    178f:	d1 10                	rcll   (%rax)
    1791:	56                   	push   %rsi
    1792:	3c 0b                	cmp    $0xb,%al
    1794:	00 00                	add    %al,(%rax)
    1796:	1f                   	(bad)
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    1797:	26 e5 10             	es in  $0x10,%eax
    179a:	67 bf 00 00 00 00    	addr32 mov $0x0,%edi
    17a0:	00 2d 28 01 00 2d    	add    %ch,0x2d000128(%rip)        # 2d0018ce <_license+0x2cfff539>
    17a6:	01 b6 00 00 00 1d    	add    %esi,0x1d000000(%rsi)
                         lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
    17ac:	a2 00 2e 01 a3 18 00 	movabs %al,0x1d000018a3012e00
    17b3:	00 1d 
    17b5:	a3 00 2f 01 a3 18 00 	movabs %eax,0x1d000018a3012f00
    17bc:	00 1d 
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17be:	a1 00 30 01 3e 10 00 	movabs 0x1d0000103e013000,%eax
    17c5:	00 1d 
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17c7:	ad                   	lods   %ds:(%rsi),%eax
    17c8:	00 31                	add    %dh,(%rcx)
    17ca:	01 39                	add    %edi,(%rcx)
    17cc:	17                   	(bad)
    17cd:	00 00                	add    %al,(%rax)
    17cf:	1d 96 00 32 01       	sbb    $0x1320096,%eax
    17d4:	6d                   	insl   (%dx),%es:(%rdi)
  bool vip_match = address_match && port_match && proto_match;
    17d5:	09 00                	or     %eax,(%rax)
    17d7:	00 1d bf 00 33 01    	add    %bl,0x13300bf(%rip)        # 133189c <_license+0x132f507>
    17dd:	a8 10                	test   $0x10,%al
    17df:	00 00                	add    %al,(%rax)
    17e1:	1e                   	(bad)
    __u32 lru_stats_key = pckt->real_index;
    17e2:	b5 00                	mov    $0x0,%ch
    17e4:	34 01                	xor    $0x1,%al
    17e6:	b6 00                	mov    $0x0,%dh
    17e8:	00 00                	add    %al,(%rax)
    17ea:	1e                   	(bad)
    17eb:	b7 00                	mov    $0x0,%bh
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17ed:	55                   	push   %rbp
    17ee:	01 bf 00 00 00 1e    	add    %edi,0x1e000000(%rdi)
    17f4:	b8 00 56 01 85       	mov    $0x85015600,%eax
    17f9:	05 00 00 1f 30       	add    $0x301f0000,%eax
    17fe:	27                   	(bad)
    17ff:	01 00                	add    %eax,(%rax)
    1801:	4b 01 b6 00 00 00 00 	rex.WXB add %rsi,0x0(%r14)
    1808:	1f                   	(bad)
    if (!lru_miss_stat) {
    1809:	30 27                	xor    %ah,(%rdi)
    180b:	01 00                	add    %eax,(%rax)
    180d:	37                   	(bad)
    180e:	01 b6 00 00 00 00    	add    %esi,0x0(%rsi)
      data_stats->v2 += 1;
    1814:	1f                   	(bad)
    1815:	30 27                	xor    %ah,(%rdi)
    1817:	01 00                	add    %eax,(%rax)
    1819:	41 01 b6 00 00 00 00 	add    %esi,0x0(%r14)
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1820:	1f                   	(bad)
    1821:	1e                   	(bad)
    1822:	c0 00 56             	rolb   $0x56,(%rax)
    1825:	01 99 09 00 00 1e    	add    %ebx,0x1e000009(%rcx)
    182b:	07                   	(bad)
    182c:	00 56 01             	add    %dl,0x1(%rsi)
    182f:	d6                   	(bad)
    1830:	10 00                	adc    %al,(%rax)
    1832:	00 1f                	add    %bl,(%rdi)
    1834:	1e                   	(bad)
    1835:	c1 00 56             	roll   $0x56,(%rax)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1838:	01 bf 00 00 00 1e    	add    %edi,0x1e000000(%rdi)
    183e:	14 00                	adc    $0x0,%al
    1840:	56                   	push   %rsi
    1841:	01 db                	add    %ebx,%ebx
    1843:	10 00                	adc    %al,(%rax)
  if (!ch_drop_stats) {
    1845:	00 1e                	add    %bl,(%rsi)
    1847:	c2 00 56             	ret    $0x5600
    184a:	01 db                	add    %ebx,%ebx
    184c:	10 00                	adc    %al,(%rax)
    184e:	00 00                	add    %al,(%rax)
    1850:	00 1f                	add    %bl,(%rdi)
    1852:	30 29                	xor    %ch,(%rcx)
    1854:	01 00                	add    %eax,(%rax)
    1856:	68 01 bf 00 00       	push   $0xbf01
    185b:	00 30                	add    %dh,(%rax)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    185d:	2a 01                	sub    (%rcx),%al
    185f:	00 69 01             	add    %ch,0x1(%rcx)
    1862:	85 05 00 00 30 2b    	test   %eax,0x2b300000(%rip)        # 2b301868 <_license+0x2b2ff4d3>
  if (!ch_drop_stats) {
    1868:	01 00                	add    %eax,(%rax)
    186a:	67 01 a8 10 00 00 1f 	add    %ebp,0x1f000010(%eax)
    1871:	1e                   	(bad)
    1872:	c0 00 6a             	rolb   $0x6a,(%rax)
    1875:	01 99 09 00 00 1e    	add    %ebx,0x1e000009(%rcx)
    187b:	07                   	(bad)
    187c:	00 6a 01             	add    %ch,0x1(%rdx)
    187f:	d6                   	(bad)
    1880:	10 00                	adc    %al,(%rax)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1882:	00 1f                	add    %bl,(%rdi)
    1884:	1e                   	(bad)
    1885:	c1 00 6a             	roll   $0x6a,(%rax)
    1888:	01 bf 00 00 00 1e    	add    %edi,0x1e000000(%rdi)
    188e:	14 00                	adc    $0x0,%al
    1890:	6a 01                	push   $0x1
    1892:	db 10                	fistl  (%rax)
    1894:	00 00                	add    %al,(%rax)
  data = (void*)(long)xdp->data;
    1896:	1e                   	(bad)
    1897:	c2 00 6a             	ret    $0x6a00
  data_end = (void*)(long)xdp->data_end;
    189a:	01 db                	add    %ebx,%ebx
    189c:	10 00                	adc    %al,(%rax)
  ip6h = data + sizeof(struct ethhdr);
    189e:	00 00                	add    %al,(%rax)
    18a0:	00 00                	add    %al,(%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    18a2:	00 0b                	add    %cl,(%rbx)
    18a4:	99                   	cltd
    18a5:	09 00                	or     %eax,(%rax)
    18a7:	00 2a                	add    %ch,(%rdx)
    18a9:	2c 01                	sub    $0x1,%al
    18ab:	11 7d a8             	adc    %edi,-0x58(%rbp)
    18ae:	10 00                	adc    %al,(%rax)
    18b0:	00 25 a1 11 7d 3e    	add    %ah,0x3e7d11a1(%rip)        # 3e7d2a57 <_license+0x3e7d06c2>
    18b6:	10 00                	adc    %al,(%rax)
    18b8:	00 25 a2 11 7d a3    	add    %ah,-0x5c82ee5e(%rip)        # ffffffffa37d2a60 <server_id_map+0x36ff8b0e9a60>
    18be:	18 00                	sbb    %al,(%rax)
    18c0:	00 25 a3 11 7d a3    	add    %ah,-0x5c82ee5d(%rip)        # ffffffffa37d2a69 <server_id_map+0x36ff8b0e9a69>
  memcpy(new_eth->h_dest, cval->mac, 6);
    18c6:	18 00                	sbb    %al,(%rax)
    18c8:	00 2f                	add    %ch,(%rdi)
    18ca:	2d 01 11 7d a8       	sub    $0xa87d1101,%eax
    18cf:	10 00                	adc    %al,(%rax)
    18d1:	00 28                	add    %ch,(%rax)
    18d3:	2e 01 11             	cs add %edx,(%rcx)
    18d6:	7f 36                	jg     190e <balancer_ingress+0x190e>
    18d8:	15 00 00 28 2f       	adc    $0x2f280000,%eax
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    18dd:	01 11                	add    %edx,(%rcx)
    18df:	7e 36                	jle    1917 <balancer_ingress+0x1917>
    18e1:	15 00 00 00 2a       	adc    $0x2a000000,%eax
    18e6:	30 01                	xor    %al,(%rcx)
    18e8:	10 4b b6             	adc    %cl,-0x4a(%rbx)
  new_eth->h_proto = BE_ETH_P_IPV6;
    18eb:	00 00                	add    %al,(%rax)
    18ed:	00 2f                	add    %ch,(%rdi)
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
    18ef:	31 01                	xor    %eax,(%rcx)
    18f1:	10 4c 3e 10          	adc    %cl,0x10(%rsi,%rdi,1)
  saddr[3] = src ^ port;
    18f5:	00 00                	add    %al,(%rax)
    18f7:	26 e8 10 4d b6 00    	es call b6660d <_license+0xb64278>
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    18fd:	00 00                	add    %al,(%rax)
    18ff:	1f                   	(bad)
    1900:	28 32                	sub    %dh,(%rdx)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1902:	01 10                	add    %edx,(%rax)
    1904:	4e 99                	rex.WRX cqto
    1906:	09 00                	or     %eax,(%rax)
    1908:	00 28                	add    %ch,(%rax)
    190a:	33 01                	xor    (%rcx),%eax
    190c:	10 4e fe             	adc    %cl,-0x2(%rsi)
  ip6h->priority = (tc & 0xF0) >> 4;
    190f:	00 00                	add    %al,(%rax)
    1911:	00 00                	add    %al,(%rax)
    1913:	00 2a                	add    %ch,(%rdx)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1915:	34 01                	xor    $0x1,%al
    1917:	0c 5b                	or     $0x5b,%al
    1919:	a8 10                	test   $0x10,%al
  ip6h->nexthdr = proto;
    191b:	00 00                	add    %al,(%rax)
    191d:	25 a2 0c 5c 99       	and    $0x995c0ca2,%eax
  ip6h->payload_len = bpf_htons(payload_len);
    1922:	09 00                	or     %eax,(%rax)
    1924:	00 25 a3 0c 5d 99    	add    %ah,-0x66a2f35d(%rip)        # ffffffff995d25cd <server_id_map+0x36ff80ee95cd>
    192a:	09 00                	or     %eax,(%rax)
    192c:	00 25 ad 0c 5e a8    	add    %ah,-0x57a1f353(%rip)        # ffffffffa85e25df <server_id_map+0x36ff8fef95df>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1932:	10 00                	adc    %al,(%rax)
    1934:	00 25 af 0c 5f 6e    	add    %ah,0x6e5f0caf(%rip)        # 6e5f25e9 <_license+0x6e5f0254>
    193a:	11 00                	adc    %eax,(%rax)
    193c:	00 26                	add    %ah,(%rsi)
    193e:	c6                   	(bad)
    193f:	0c 60                	or     $0x60,%al
    1941:	a8 10                	test   $0x10,%al
  if (!connId) {
    1943:	00 00                	add    %al,(%rax)
    1945:	28 35 01 0c 62 57    	sub    %dh,0x57620c01(%rip)        # 5762254c <_license+0x576201b7>
    194b:	19 00                	sbb    %eax,(%rax)
    194d:	00 26                	add    %ah,(%rsi)
    194f:	d4                   	(bad)
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1950:	0c 61                	or     $0x61,%al
    1952:	fe 00                	incb   (%rax)
    1954:	00 00                	add    %al,(%rax)
    1956:	00 0b                	add    %cl,(%rbx)
    1958:	5c                   	pop    %rsp
    1959:	19 00                	sbb    %eax,(%rax)
    195b:	00 29                	add    %ch,(%rcx)
    195d:	37                   	(bad)
    195e:	01 08                	add    %ecx,(%rax)
    1960:	17                   	(bad)
    1961:	17                   	(bad)
    1962:	2b 0e                	sub    (%rsi),%ecx
    1964:	01 ed                	add    %ebp,%ebp
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1966:	0a 00                	or     (%rax),%al
    1968:	00 17                	add    %dl,(%rdi)
    196a:	18 00                	sbb    %al,(%rax)
    196c:	2b 0f                	sub    (%rdi),%ecx
    196e:	01 ed                	add    %ebp,%ebp
    1970:	0a 00                	or     (%rax),%al
    1972:	00 17                	add    %dl,(%rdi)
    1974:	19 02                	sbb    %eax,(%rdx)
    1976:	2b 36                	sub    (%rsi),%esi
    1978:	01 ed                	add    %ebp,%ebp
    197a:	0a 00                	or     (%rax),%al
    197c:	00 17                	add    %dl,(%rdi)
    197e:	1a 04 0a             	sbb    (%rdx,%rcx,1),%al
    1981:	97                   	xchg   %eax,%edi
    1982:	e6 0b                	out    %al,$0xb
    1984:	00 00                	add    %al,(%rax)
    1986:	17                   	(bad)
    1987:	1b 06                	sbb    (%rsi),%eax
      if (qpr.server_id > 0) {
    1989:	00 2a                	add    %ch,(%rdx)
    198b:	38 01                	cmp    %al,(%rcx)
    198d:	11 92 a8 10 00 00    	adc    %edx,0x10a8(%rdx)
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1993:	25 a1 11 92 3e       	and    $0x3e9211a1,%eax
    1998:	10 00                	adc    %al,(%rax)
    199a:	00 25 a2 11 92 a3    	add    %ah,-0x5c6dee5e(%rip)        # ffffffffa3922b42 <server_id_map+0x36ff8b239b42>
    19a0:	18 00                	sbb    %al,(%rax)
    quic_packets_stats->cid_v1 += 1;
    19a2:	00 25 a3 11 92 a3    	add    %ah,-0x5c6dee5d(%rip)        # ffffffffa3922b4b <server_id_map+0x36ff8b239b4b>
    quic_packets_stats->cid_v2 += 1;
    19a8:	18 00                	sbb    %al,(%rax)
    19aa:	00 28                	add    %ch,(%rax)
    19ac:	2e 01 11             	cs add %edx,(%rcx)
    quic_packets_stats->cid_v3 += 1;
    19af:	94                   	xchg   %eax,%esp
    19b0:	36 15 00 00 28 2f    	ss adc $0x2f280000,%eax
    quic_packets_stats->cid_v0 += 1;
    19b6:	01 11                	add    %edx,(%rcx)
    19b8:	93                   	xchg   %eax,%ebx
    19b9:	36 15 00 00 00 2d    	ss adc $0x2d000000,%eax
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    19bf:	39 01                	cmp    %eax,(%rcx)
        if (real_pos) {
    19c1:	0c 53                	or     $0x53,%al
    19c3:	01 e0                	add    %esp,%eax
    19c5:	10 00                	adc    %al,(%rax)
    19c7:	00 1d a2 0c 54 01    	add    %bl,0x1540ca2(%rip)        # 154266f <_license+0x15402da>
    19cd:	99                   	cltd
    19ce:	09 00                	or     %eax,(%rax)
    19d0:	00 1d a3 0c 55 01    	add    %bl,0x1550ca3(%rip)        # 1552679 <_license+0x15502e4>
          key = *real_pos;
    19d6:	99                   	cltd
    19d7:	09 00                	or     %eax,(%rax)
    19d9:	00 1d ad 0c 56 01    	add    %bl,0x1560cad(%rip)        # 156268c <_license+0x15602f7>
            pckt.real_index = key;
    19df:	a8 10                	test   $0x10,%al
            dst = bpf_map_lookup_elem(&reals, &key);
    19e1:	00 00                	add    %al,(%rax)
    19e3:	1d af 0c 57 01       	sbb    $0x1570caf,%eax
    19e8:	6e                   	outsb  %ds:(%rsi),(%dx)
    19e9:	11 00                	adc    %eax,(%rax)
    19eb:	00 30                	add    %dh,(%rax)
    19ed:	3a 01                	cmp    (%rcx),%al
    19ef:	0c 58                	or     $0x58,%al
    19f1:	01 e0                	add    %esp,%eax
    19f3:	10 00                	adc    %al,(%rax)
    19f5:	00 30                	add    %dh,(%rax)
    19f7:	3b 01                	cmp    (%rcx),%eax
            if (!dst) {
    19f9:	0c 67                	or     $0x67,%al
    19fb:	01 6d 09             	add    %ebp,0x9(%rbp)
    19fe:	00 00                	add    %al,(%rax)
    1a00:	30 3c 01             	xor    %bh,(%rcx,%rax,1)
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
    1a03:	0c 68                	or     $0x68,%al
    1a05:	01 6d 09             	add    %ebp,0x9(%rbp)
    1a08:	00 00                	add    %al,(%rax)
    1a0a:	30 3d 01 0c 69 01    	xor    %bh,0x1690c01(%rip)        # 1692611 <_license+0x169027c>
  if (dst_lru) {
    1a10:	6d                   	insl   (%dx),%es:(%rdi)
    1a11:	09 00                	or     %eax,(%rax)
    1a13:	00 30                	add    %dh,(%rax)
    1a15:	3e 01 0c 8c          	ds add %ecx,(%rsp,%rcx,4)
    if (dst_lru->pos == pckt->real_index) {
    1a19:	01 16                	add    %edx,(%rsi)
    1a1b:	01 00                	add    %eax,(%rax)
    1a1d:	00 1e                	add    %bl,(%rsi)
    1a1f:	c6                   	(bad)
    1a20:	0c 5f                	or     $0x5f,%al
    1a22:	01 a8 10 00 00 1e    	add    %ebp,0x1e000010(%rax)
              quic_packets_stats->dst_match_in_lru += 1;
    1a28:	d4                   	(bad)
    1a29:	0c 60                	or     $0x60,%al
    1a2b:	01 fe                	add    %edi,%esi
    1a2d:	00 00                	add    %al,(%rax)
              quic_packets_stats->cid_unknown_real_dropped += 1;
    1a2f:	00 1f                	add    %bl,(%rdi)
    1a31:	30 3f                	xor    %bh,(%rdi)
    1a33:	01 0c 7b             	add    %ecx,(%rbx,%rdi,2)
    1a36:	01 03                	add    %eax,(%rbx)
    1a38:	0c 00                	or     $0x0,%al
    1a3a:	00 00                	add    %al,(%rax)
    1a3c:	00 2d 40 01 0e 44    	add    %ch,0x440e0140(%rip)        # 440e1b82 <_license+0x440df7ed>
    1a42:	01 a8 10 00 00 1d    	add    %ebp,0x1d000010(%rax)
  original_sport = pckt.flow.port16[0];
    1a48:	a2 0e 44 01 99 09 00 	movabs %al,0x1d0000099901440e
    1a4f:	00 1d 
    1a51:	a3 0e 44 01 99 09 00 	movabs %eax,0x1d0000099901440e
    1a58:	00 1d 
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    1a5a:	ad                   	lods   %ds:(%rsi),%eax
        !(vip_info->flags & F_LRU_BYPASS)) {
    1a5b:	0e                   	(bad)
    1a5c:	44 01 a8 10 00 00 1e 	add    %r13d,0x1e000010(%rax)
    1a63:	d4                   	(bad)
    1a64:	0e                   	(bad)
    1a65:	45 01 fe             	add    %r15d,%r14d
    1a68:	00 00                	add    %al,(%rax)
    1a6a:	00 1f                	add    %bl,(%rdi)
    1a6c:	1e                   	(bad)
    1a6d:	d5                   	(bad)
    1a6e:	0e                   	(bad)
    1a6f:	47 01 b2 13 00 00 00 	rex.RXB add %r14d,0x13(%r10)
    1a76:	1f                   	(bad)
    1a77:	1e                   	(bad)
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1a78:	d5                   	(bad)
    1a79:	0e                   	(bad)
    1a7a:	4c 01 01             	add    %r8,(%rcx)
    1a7d:	12 00                	adc    (%rax),%al
    1a7f:	00 00                	add    %al,(%rax)
    1a81:	00 31                	add    %dh,(%rcx)
    1a83:	41 01 00             	add    %eax,(%r8)
    cur_time = bpf_ktime_get_ns();
    1a86:	7e 02                	jle    1a8a <balancer_ingress+0x1a8a>
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1a88:	1d 25 00 7e 02       	sbb    $0x27e0025,%eax
    1a8d:	bf 00 00 00 2e       	mov    $0x2e000000,%edi
    1a92:	42 01 00             	rex.X add %eax,(%rax)
    1a95:	7e 02                	jle    1a99 <balancer_ingress+0x1a99>
    1a97:	a8 10                	test   $0x10,%al
    1a99:	00 00                	add    %al,(%rax)
    1a9b:	2e 43 01 00          	cs rex.XB add %eax,(%r8)
    1a9f:	7e 02                	jle    1aa3 <balancer_ingress+0x1aa3>
    1aa1:	a8 10                	test   $0x10,%al
    1aa3:	00 00                	add    %al,(%rax)
    1aa5:	30 44 01 00          	xor    %al,0x0(%rcx,%rax,1)
    dst_lru->atime = cur_time;
    1aa9:	7f 02                	jg     1aad <balancer_ingress+0x1aad>
    1aab:	85 05 00 00 1f 1e    	test   %eax,0x1e1f0000(%rip)        # 1e1f1ab1 <_license+0x1e1ef71c>
    1ab1:	c0 00 80             	rolb   $0x80,(%rax)
  key = dst_lru->pos;
    1ab4:	02 99 09 00 00 1e    	add    0x1e000009(%rcx),%bl
  pckt->real_index = key;
    1aba:	07                   	(bad)
    1abb:	00 80 02 d6 10 00    	add    %al,0x10d602(%rax)
    1ac1:	00 1f                	add    %bl,(%rdi)
    1ac3:	1e                   	(bad)
    1ac4:	14 00                	adc    $0x0,%al
    1ac6:	80 02 db             	addb   $0xdb,(%rdx)
    1ac9:	10 00                	adc    %al,(%rax)
  *real = bpf_map_lookup_elem(&reals, &key);
    1acb:	00 1e                	add    %bl,(%rsi)
    1acd:	c2 00 80             	ret    $0x8000
    1ad0:	02 db                	add    %bl,%bl
    1ad2:	10 00                	adc    %al,(%rax)
    1ad4:	00 1e                	add    %bl,(%rsi)
    1ad6:	c1 00 80             	roll   $0x80,(%rax)
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1ad9:	02 bf 00 00 00 00    	add    0x0(%rdi),%bh
    1adf:	00 00                	add    %al,(%rax)
    1ae1:	31 45 01             	xor    %eax,0x1(%rbp)
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1ae4:	00 35 02 1d c8 00    	add    %dh,0xc81d02(%rip)        # c837ec <_license+0xc81457>
    1aea:	36 02 a8 06 00 00 1d 	ss add 0x1d000006(%rax),%ch
    1af1:	cb                   	lret
    1af2:	00 37                	add    %dh,(%rdi)
    1af4:	02 16                	add    (%rsi),%dl
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1af6:	01 00                	add    %eax,(%rax)
    1af8:	00 00                	add    %al,(%rax)
    1afa:	2d 46 01 00 67       	sub    $0x67000146,%eax
    1aff:	02 b6 00 00 00 1d    	add    0x1d000000(%rsi),%dh
  if (!conn_rate_stats) {
    1b05:	af                   	scas   %es:(%rdi),%eax
    1b06:	00 68 02             	add    %ch,0x2(%rax)
    1b09:	6e                   	outsb  %ds:(%rsi),(%dx)
    1b0a:	11 00                	adc    %eax,(%rax)
    1b0c:	00 1d ba 00 69 02    	add    %bl,0x26900ba(%rip)        # 2691bcc <_license+0x268f837>
  *cur_time = bpf_ktime_get_ns();
    1b12:	99                   	cltd
    1b13:	09 00                	or     %eax,(%rax)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1b15:	00 30                	add    %dh,(%rax)
    1b17:	47 01 00             	rex.RXB add %r8d,(%r8)
    1b1a:	77 02                	ja     1b1e <balancer_ingress+0x1b1e>
    1b1c:	99                   	cltd
    1b1d:	03 00                	add    (%rax),%eax
    1b1f:	00 30                	add    %dh,(%rax)
    1b21:	48 01 00             	add    %rax,(%rax)
    conn_rate_stats->v1 = 1;
    1b24:	6a 02                	push   $0x2
    1b26:	94                   	xchg   %eax,%esp
    1b27:	03 00                	add    (%rax),%eax
    1b29:	00 30                	add    %dh,(%rax)
    conn_rate_stats->v2 = *cur_time;
    1b2b:	49 01 00             	add    %rax,(%r8)
    1b2e:	73 02                	jae    1b32 <balancer_ingress+0x1b32>
    1b30:	fe 00                	incb   (%rax)
    conn_rate_stats->v1 += 1;
    1b32:	00 00                	add    %al,(%rax)
    1b34:	00 32                	add    %dh,(%rdx)
    1b36:	4a 01 00             	rex.WX add %rax,(%rax)
    1b39:	b0 2f                	mov    $0x2f,%al
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1b3b:	4b 01 00             	rex.WXB add %rax,(%r8)
    1b3e:	b1 a3                	mov    $0xa3,%cl
    1b40:	1b 00                	sbb    (%rax),%eax
    1b42:	00 25 af 00 b2 6e    	add    %ah,0x6eb200af(%rip)        # 6eb21bf7 <_license+0x6eb1f862>
    1b48:	11 00                	adc    %eax,(%rax)
    1b4a:	00 25 ba 00 b3 99    	add    %ah,-0x664cff46(%rip)        # ffffffff99b31c0a <server_id_map+0x36ff81448c0a>
    1b50:	09 00                	or     %eax,(%rax)
    1b52:	00 2f                	add    %ch,(%rdi)
    1b54:	4c 01 00             	add    %r8,(%rax)
    if (down_reals_map) {
    1b57:	b4 a8                	mov    $0xa8,%ah
    1b59:	10 00                	adc    %al,(%rax)
    1b5b:	00 28                	add    %ch,(%rax)
      void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1b5d:	48 01 00             	add    %rax,(%rax)
    1b60:	b5 94                	mov    $0x94,%ch
    1b62:	03 00                	add    (%rax),%eax
    1b64:	00 28                	add    %ch,(%rax)
    1b66:	49 01 00             	add    %rax,(%r8)
    1b69:	b6 fe                	mov    $0xfe,%dh
      if (down_real) {
    1b6b:	00 00                	add    %al,(%rax)
    1b6d:	00 26                	add    %ah,(%rsi)
    1b6f:	09 00                	or     %eax,(%rax)
    1b71:	b7 bf                	mov    $0xbf,%bh
    1b73:	00 00                	add    %al,(%rax)
    1b75:	00 1f                	add    %bl,(%rdi)
    1b77:	26 c0 00 c5          	es rolb $0xc5,(%rax)
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1b7b:	99                   	cltd
    1b7c:	09 00                	or     %eax,(%rax)
    1b7e:	00 26                	add    %ah,(%rsi)
    1b80:	07                   	(bad)
    1b81:	00 c5                	add    %al,%ch
    1b83:	d6                   	(bad)
    1b84:	10 00                	adc    %al,(%rax)
        if (stats_data) {
    1b86:	00 1f                	add    %bl,(%rdi)
    1b88:	26 c1 00 c5          	es roll $0xc5,(%rax)
    1b8c:	bf 00 00 00 26       	mov    $0x26000000,%edi
          stats_data->v1 += 1;
    1b91:	14 00                	adc    $0x0,%al
    1b93:	c5 db 10             	(bad)
    if (!dst) {
    1b96:	00 00                	add    %al,(%rax)
    1b98:	26 c2 00 c5          	es ret $0xc500
    1b9c:	db 10                	fistl  (%rax)
    1b9e:	00 00                	add    %al,(%rax)
    1ba0:	00 00                	add    %al,(%rax)
    1ba2:	00 0b                	add    %cl,(%rbx)
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1ba4:	f2 04 00             	repnz add $0x0,%al
    1ba7:	00 2d 4d 01 00 8c    	add    %ch,-0x73fffeb3(%rip)        # ffffffff8c001cfa <server_id_map+0x36ff73918cfa>
    1bad:	02 b6 00 00 00 1d    	add    0x1d000000(%rsi),%dh
    1bb3:	2a 00                	sub    (%rax),%al
    1bb5:	8d 02                	lea    (%rdx),%eax
    1bb7:	a3 1b 00 00 1d af 00 	movabs %eax,0x28e00af1d00001b
    1bbe:	8e 02 
    1bc0:	6e                   	outsb  %ds:(%rsi),(%dx)
    1bc1:	11 00                	adc    %eax,(%rax)
    1bc3:	00 1d b6 00 8f 02    	add    %bl,0x28f00b6(%rip)        # 28f1c7f <_license+0x28ef8ea>
  if (!data_stats) {
    1bc9:	ac                   	lods   %ds:(%rsi),%al
    1bca:	02 00                	add    (%rax),%al
    1bcc:	00 1d 1d 00 90 02    	add    %bl,0x290001d(%rip)        # 2901bef <_license+0x28ff85a>
    1bd2:	64 02 00             	add    %fs:(%rax),%al
    1bd5:	00 30                	add    %dh,(%rax)
  data_stats->v1 += 1;
    1bd7:	49 01 00             	add    %rax,(%r8)
  data_stats->v2 += pkt_bytes;
    1bda:	91                   	xchg   %eax,%ecx
    1bdb:	02 fe                	add    %dh,%bh
    1bdd:	00 00                	add    %al,(%rax)
    1bdf:	00 1f                	add    %bl,(%rdi)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1be1:	30 4e 01             	xor    %cl,0x1(%rsi)
    1be4:	00 95 02 99 09 00    	add    %dl,0x99902(%rbp)
    1bea:	00 1f                	add    %bl,(%rdi)
    1bec:	1e                   	(bad)
    1bed:	c0 00 95             	rolb   $0x95,(%rax)
    1bf0:	02 99 09 00 00 1e    	add    0x1e000009(%rcx),%bl
    1bf6:	07                   	(bad)
    1bf7:	00 95 02 d6 10 00    	add    %dl,0x10d602(%rbp)
    1bfd:	00 00                	add    %al,(%rax)
    1bff:	1f                   	(bad)
    1c00:	30 4f 01             	xor    %cl,0x1(%rdi)
    1c03:	00 97 02 99 09 00    	add    %dl,0x99902(%rdi)
  if (!data_stats) {
    1c09:	00 1f                	add    %bl,(%rdi)
    1c0b:	1e                   	(bad)
    1c0c:	b7 00                	mov    $0x0,%bh
    1c0e:	9c                   	pushf
    1c0f:	02 bf 00 00 00 30    	add    0x30000000(%rdi),%bh
  data_stats->v2 += pkt_bytes;
    1c15:	50                   	push   %rax
    1c16:	01 00                	add    %eax,(%rax)
    1c18:	9d                   	popf
    1c19:	02 85 05 00 00 1f    	add    0x1f000005(%rbp),%al
  pckt.flow.port16[0] = original_sport;
    1c1f:	1e                   	(bad)
    1c20:	c0 00 9d             	rolb   $0x9d,(%rax)
    1c23:	02 99 09 00 00 1e    	add    0x1e000009(%rcx),%bl
  if (dst->flags & F_IPV6) {
    1c29:	07                   	(bad)
    1c2a:	00 9d 02 d6 10 00    	add    %bl,0x10d602(%rbp)
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    1c30:	00 1f                	add    %bl,(%rdi)
    1c32:	1e                   	(bad)
    1c33:	c1 00 9d             	roll   $0x9d,(%rax)
    1c36:	02 bf 00 00 00 1e    	add    0x1e000000(%rdi),%bh
    1c3c:	14 00                	adc    $0x0,%al
    1c3e:	9d                   	popf
    1c3f:	02 db                	add    %bl,%bl
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    1c41:	10 00                	adc    %al,(%rax)
    1c43:	00 1e                	add    %bl,(%rsi)
    1c45:	c2 00 9d             	ret    $0x9d00
    1c48:	02 db                	add    %bl,%bl
    1c4a:	10 00                	adc    %al,(%rax)
    1c4c:	00 00                	add    %al,(%rax)
    1c4e:	00 00                	add    %al,(%rax)
    1c50:	00 00                	add    %al,(%rax)
    1c52:	00 2a                	add    %ch,(%rdx)
    1c54:	51                   	push   %rcx
  data = (void*)(long)xdp->data;
    1c55:	01 00                	add    %eax,(%rax)
    1c57:	26 a8 10             	es test $0x10,%al
  data_end = (void*)(long)xdp->data_end;
    1c5a:	00 00                	add    %al,(%rax)
  iph = data + sizeof(struct ethhdr);
    1c5c:	2f                   	(bad)
    1c5d:	49 01 00             	add    %rax,(%r8)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1c60:	27                   	(bad)
    1c61:	43 0a 00             	rex.XB or (%r8),%al
    1c64:	00 28                	add    %ch,(%rax)
    1c66:	52                   	push   %rdx
    1c67:	01 00                	add    %eax,(%rax)
    1c69:	28 bf 00 00 00 28    	sub    %bh,0x28000000(%rdi)
    1c6f:	53                   	push   %rbx
    1c70:	01 00                	add    %eax,(%rax)
    1c72:	29 85 05 00 00 1f    	sub    %eax,0x1f000005(%rbp)
    1c78:	26 c0 00 2a          	es rolb $0x2a,(%rax)
    1c7c:	99                   	cltd
    1c7d:	09 00                	or     %eax,(%rax)
    1c7f:	00 26                	add    %ah,(%rsi)
    1c81:	07                   	(bad)
    1c82:	00 2a                	add    %ch,(%rdx)
    1c84:	d6                   	(bad)
    1c85:	10 00                	adc    %al,(%rax)
    1c87:	00 1f                	add    %bl,(%rdi)
    1c89:	26 c1 00 2a          	es roll $0x2a,(%rax)
    1c8d:	bf 00 00 00 26       	mov    $0x26000000,%edi
    1c92:	14 00                	adc    $0x0,%al
    1c94:	2a db                	sub    %bl,%bl
    1c96:	10 00                	adc    %al,(%rax)
    1c98:	00 26                	add    %ah,(%rsi)
    1c9a:	c2 00 2a             	ret    $0x2a00
    1c9d:	db 10                	fistl  (%rax)
  memcpy(new_eth->h_dest, cval->mac, 6);
    1c9f:	00 00                	add    %al,(%rax)
    1ca1:	00 00                	add    %al,(%rax)
    1ca3:	00 2a                	add    %ch,(%rdx)
    1ca5:	54                   	push   %rsp
    1ca6:	01 11                	add    %edx,(%rcx)
    1ca8:	58                   	pop    %rax
    1ca9:	a8 10                	test   $0x10,%al
    1cab:	00 00                	add    %al,(%rax)
    1cad:	25 a1 11 59 3e       	and    $0x3e5911a1,%eax
    1cb2:	10 00                	adc    %al,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1cb4:	00 25 bd 11 5a cb    	add    %ah,-0x34a5ee43(%rip)        # ffffffffcb5a2e77 <server_id_map+0x36ffb2eb9e77>
    1cba:	00 00                	add    %al,(%rax)
    1cbc:	00 25 af 11 5b 6e    	add    %ah,0x6e5b11af(%rip)        # 6e5b2e71 <_license+0x6e5b0adc>
  new_eth->h_proto = BE_ETH_P_IP;
    1cc2:	11 00                	adc    %eax,(%rax)
    1cc4:	00 25 2a 11 5c f2    	add    %ah,-0xda3eed6(%rip)        # fffffffff25c2df4 <server_id_map+0x36ffd9ed9df4>
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1cca:	04 00                	add    $0x0,%al
    1ccc:	00 25 bb 11 5d bf    	add    %ah,-0x40a2ee45(%rip)        # ffffffffbf5d2e8d <server_id_map+0x36ffa6ee9e8d>
  iph->ihl = 5;
    1cd2:	00 00                	add    %al,(%rax)
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1cd4:	00 28                	add    %ch,(%rax)
    1cd6:	55                   	push   %rbp
    1cd7:	01 11                	add    %edx,(%rcx)
    1cd9:	63 bf 00 00 00 26    	movsxd 0x26000000(%rdi),%edi
    1cdf:	e5 11                	in     $0x11,%eax
    1ce1:	64 fe 00             	incb   %fs:(%rax)
  iph->id = 0;
    1ce4:	00 00                	add    %al,(%rax)
    1ce6:	26 a2 11 5e 99 09 00 	es movabs %al,0xa326000009995e11
    1ced:	00 26 a3 
  iph->ttl = DEFAULT_TTL;
    1cf0:	11 5f 99             	adc    %ebx,-0x67(%rdi)
    1cf3:	09 00                	or     %eax,(%rax)
    1cf5:	00 28                	add    %ch,(%rax)
    1cf7:	2f                   	(bad)
    1cf8:	01 11                	add    %edx,(%rcx)
    1cfa:	61                   	(bad)
    1cfb:	36 15 00 00 26 d1    	ss adc $0xd1260000,%eax
    1d01:	11 60 3c             	adc    %esp,0x3c(%rax)
    1d04:	0b 00                	or     (%rax),%eax
    1d06:	00 28                	add    %ch,(%rax)
    1d08:	2e 01 11             	cs add %edx,(%rcx)
    1d0b:	62 36 15 00 00       	(bad)
    1d10:	00 32                	add    %dh,(%rdx)
    1d12:	56                   	push   %rsi
    1d13:	01 12                	add    %edx,(%rdx)
    1d15:	31 25 d1 12 32 3c    	xor    %esp,0x3c3212d1(%rip)        # 3c322fec <_license+0x3c320c57>
    1d1b:	0b 00                	or     (%rax),%eax
    1d1d:	00 25 91 12 33 16    	add    %ah,0x16331291(%rip)        # 16332fb4 <_license+0x16330c1f>
    if (csum >> 16)
    1d23:	01 00                	add    %eax,(%rax)
    1d25:	00 25 87 12 34 bf    	add    %ah,-0x40cbed79(%rip)        # ffffffffbf342fb2 <server_id_map+0x36ffa6c59fb2>
    1d2b:	00 00                	add    %al,(%rax)
    1d2d:	00 25 8d 12 35 bf    	add    %ah,-0x40caed73(%rip)        # ffffffffbf352fc0 <server_id_map+0x36ffa6c69fc0>
    1d33:	00 00                	add    %al,(%rax)
    1d35:	00 25 bb 12 36 a0    	add    %ah,-0x5fc9ed45(%rip)        # ffffffffa0362ff6 <server_id_map+0x36ff87c79ff6>
    1d3b:	02 00                	add    (%rax),%al
    1d3d:	00 25 22 12 37 16    	add    %ah,0x16371222(%rip)        # 16372f65 <_license+0x16370bd0>
    1d43:	01 00                	add    %eax,(%rax)
    1d45:	00 26                	add    %ah,(%rsi)
    1d47:	e5 12                	in     $0x12,%eax
    1d49:	38 fe                	cmp    %bh,%dh
    1d4b:	00 00                	add    %al,(%rax)
    1d4d:	00 00                	add    %al,(%rax)
    1d4f:	2a 57 01             	sub    0x1(%rdi),%dl
    1d52:	00 57 a8             	add    %dl,-0x58(%rdi)
    1d55:	10 00                	adc    %al,(%rax)
    1d57:	00 2f                	add    %ch,(%rdi)
    1d59:	4b 01 00             	rex.WXB add %rax,(%r8)
    1d5c:	58                   	pop    %rax
    1d5d:	a3 1b 00 00 25 af 00 	movabs %eax,0x6e5900af2500001b
    1d64:	59 6e 
    1d66:	11 00                	adc    %eax,(%rax)
    1d68:	00 25 b6 00 5a ac    	add    %ah,-0x53a5ff4a(%rip)        # ffffffffac5a1e24 <server_id_map+0x36ff93eb8e24>
  iph->check = csum;
    1d6e:	02 00                	add    (%rax),%al
    1d70:	00 25 ad 00 5b a8    	add    %ah,-0x57a4ff53(%rip)        # ffffffffa85b1e23 <server_id_map+0x36ff8fec8e23>
    1d76:	10 00                	adc    %al,(%rax)
      if (pckt.flow.proto == IPPROTO_TCP) {
    1d78:	00 25 ba 00 5c 99    	add    %ah,-0x66a3ff46(%rip)        # ffffffff995c1e38 <server_id_map+0x36ff80ed8e38>
    1d7e:	09 00                	or     %eax,(%rax)
    1d80:	00 28                	add    %ch,(%rax)
    1d82:	47 01 00             	rex.RXB add %r8d,(%r8)
    1d85:	5e                   	pop    %rsi
    1d86:	99                   	cltd
    1d87:	03 00                	add    (%rax),%eax
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    1d89:	00 28                	add    %ch,(%rax)
    1d8b:	58                   	pop    %rax
    1d8c:	01 00                	add    %eax,(%rax)
    1d8e:	5f                   	pop    %rdi
    1d8f:	a8 10                	test   $0x10,%al
    1d91:	00 00                	add    %al,(%rax)
    1d93:	28 59 01             	sub    %bl,0x1(%rcx)
        if (!lru_stats) {
    1d96:	00 60 a8             	add    %ah,-0x58(%rax)
    1d99:	10 00                	adc    %al,(%rax)
    1d9b:	00 28                	add    %ch,(%rax)
        if (pckt.flags & F_SYN_SET) {
    1d9d:	49 01 00             	add    %rax,(%r8)
    1da0:	62                   	(bad)
    1da1:	fe 00                	incb   (%rax)
    1da3:	00 00                	add    %al,(%rax)
    1da5:	28 5a 01             	sub    %bl,0x1(%rdx)
    1da8:	00 63 bf             	add    %ah,-0x41(%rbx)
  struct real_pos_lru new_dst_lru = {};
    1dab:	00 00                	add    %al,(%rax)
    1dad:	00 26                	add    %ah,(%rsi)
    1daf:	09 00                	or     %eax,(%rax)
    1db1:	64 bf 00 00 00 26    	fs mov $0x26000000,%edi
    1db7:	ce                   	(bad)
    1db8:	00 61 ba             	add    %ah,-0x46(%rcx)
    1dbb:	00 00                	add    %al,(%rax)
    1dbd:	00 1f                	add    %bl,(%rdi)
    1dbf:	28 5b 01             	sub    %bl,0x1(%rbx)
    1dc2:	00 86 a8 10 00 00    	add    %al,0x10a8(%rsi)
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1dc8:	1f                   	(bad)
    1dc9:	26 c0 00 92          	es rolb $0x92,(%rax)
    1dcd:	99                   	cltd
    1dce:	09 00                	or     %eax,(%rax)
    1dd0:	00 26                	add    %ah,(%rsi)
    1dd2:	07                   	(bad)
    1dd3:	00 92 d6 10 00 00    	add    %dl,0x10d6(%rdx)
    1dd9:	1f                   	(bad)
    1dda:	26 c1 00 92          	es roll $0x92,(%rax)
    1dde:	bf 00 00 00 26       	mov    $0x26000000,%edi
  *cur_time = bpf_ktime_get_ns();
    1de3:	14 00                	adc    $0x0,%al
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1de5:	92                   	xchg   %eax,%edx
    1de6:	db 10                	fistl  (%rax)
    1de8:	00 00                	add    %al,(%rax)
    1dea:	26 c2 00 92          	es ret $0x9200
    1dee:	db 10                	fistl  (%rax)
    1df0:	00 00                	add    %al,(%rax)
    conn_rate_stats->v1 = 1;
    1df2:	00 00                	add    %al,(%rax)
    1df4:	00 1f                	add    %bl,(%rdi)
    1df6:	26 c0 00 9f          	es rolb $0x9f,(%rax)
    conn_rate_stats->v2 = *cur_time;
    1dfa:	99                   	cltd
    1dfb:	09 00                	or     %eax,(%rax)
    1dfd:	00 26                	add    %ah,(%rsi)
    1dff:	07                   	(bad)
    1e00:	00 9f d6 10 00 00    	add    %bl,0x10d6(%rdi)
    conn_rate_stats->v1 += 1;
    1e06:	1f                   	(bad)
    1e07:	26 c1 00 9f          	es roll $0x9f,(%rax)
    1e0b:	bf 00 00 00 26       	mov    $0x26000000,%edi
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1e10:	14 00                	adc    $0x0,%al
    1e12:	9f                   	lahf
    1e13:	db 10                	fistl  (%rax)
    1e15:	00 00                	add    %al,(%rax)
    1e17:	26 c2 00 9f          	es ret $0x9f00
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1e1b:	db 10                	fistl  (%rax)
    1e1d:	00 00                	add    %al,(%rax)
    1e1f:	00 00                	add    %al,(%rax)
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    1e21:	00 2a                	add    %ch,(%rdx)
    1e23:	5c                   	pop    %rsp
    1e24:	01 00                	add    %eax,(%rax)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1e26:	19 bf 00 00 00 25    	sbb    %edi,0x25000000(%rdi)
    1e2c:	af                   	scas   %es:(%rdi),%eax
    1e2d:	00 1a                	add    %bl,(%rdx)
    1e2f:	6e                   	outsb  %ds:(%rsi),(%dx)
      memset(pckt->flow.srcv6, 0, 16);
    1e30:	11 00                	adc    %eax,(%rax)
    1e32:	00 2f                	add    %ch,(%rdi)
    1e34:	5b                   	pop    %rbx
    1e35:	01 00                	add    %eax,(%rax)
    1e37:	1b a8 10 00 00 00    	sbb    0x10(%rax),%ebp
    1e3d:	2d 5d 01 06 9f       	sub    $0x9f06015d,%eax
    1e42:	01 b6 00 00 00 2e    	add    %esi,0x2e000000(%rsi)
    return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
    1e48:	25 01 06 9f 01       	and    $0x19f0601,%eax
    1e4d:	99                   	cltd
    1e4e:	09 00                	or     %eax,(%rax)
    1e50:	00 1d 09 06 9f 01    	add    %bl,0x19f0609(%rip)        # 19f245f <_license+0x19f00ca>
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1e56:	99                   	cltd
    1e57:	09 00                	or     %eax,(%rax)
    1e59:	00 1d 0c 06 9f 01    	add    %bl,0x19f060c(%rip)        # 19f246b <_license+0x19f00d6>
    1e5f:	99                   	cltd
    1e60:	09 00                	or     %eax,(%rax)
    1e62:	00 1d 24 06 9f 01    	add    %bl,0x19f0624(%rip)        # 19f248c <_license+0x19f00f7>
    1e68:	06                   	(bad)
    1e69:	01 00                	add    %eax,(%rax)
    1e6b:	00 00                	add    %al,(%rax)
    1e6d:	2d 5e 01 00 43       	sub    $0x4300015e,%eax
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1e72:	02 b6 00 00 00 1d    	add    0x1d000000(%rsi),%dh
    1e78:	1d 00 44 02 64       	sbb    $0x64024400,%eax
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1e7d:	02 00                	add    (%rax),%al
    1e7f:	00 1d af 00 45 02    	add    %bl,0x24500af(%rip)        # 2451f34 <_license+0x244fb9f>
    if (!real_pos) {
    1e85:	6e                   	outsb  %ds:(%rsi),(%dx)
    1e86:	11 00                	adc    %eax,(%rax)
    1e88:	00 1d b6 00 46 02    	add    %bl,0x24600b6(%rip)        # 2461f44 <_license+0x245fbaf>
    1e8e:	ac                   	lods   %ds:(%rsi),%al
    1e8f:	02 00                	add    (%rax),%al
    1e91:	00 1d ad 00 47 02    	add    %bl,0x24700ad(%rip)        # 2471f44 <_license+0x246fbaf>
    1e97:	a8 10                	test   $0x10,%al
    1e99:	00 00                	add    %al,(%rax)
    1e9b:	30 5f 01             	xor    %bl,0x1(%rdi)
    key = *real_pos;
    1e9e:	00 4a 02             	add    %cl,0x2(%rdx)
    1ea1:	64 02 00             	add    %fs:(%rax),%al
    if (key == 0) {
    1ea4:	00 30                	add    %dh,(%rax)
    1ea6:	60                   	(bad)
    1ea7:	01 00                	add    %eax,(%rax)
  pckt->real_index = key;
    1ea9:	49 02 bf 00 00 00 30 	rex.WB add 0x30000000(%r15),%dil
  *real = bpf_map_lookup_elem(&reals, &key);
    1eb0:	61                   	(bad)
  if (!(*real)) {
    1eb1:	01 00                	add    %eax,(%rax)
    1eb3:	4f 02 a8 10 00 00 30 	rex.WRXB add 0x30000010(%r8),%r13b
    1eba:	62 01                	(bad)
    1ebc:	00 55 02             	add    %dl,0x2(%rbp)
    1ebf:	a8 10                	test   $0x10,%al
    1ec1:	00 00                	add    %al,(%rax)
    1ec3:	30 63 01             	xor    %ah,0x1(%rbx)
    1ec6:	00 56 02             	add    %dl,0x2(%rsi)
    1ec9:	a8 10                	test   $0x10,%al
    1ecb:	00 00                	add    %al,(%rax)
    1ecd:	30 64 01 00          	xor    %ah,0x0(%rcx,%rax,1)
    1ed1:	57                   	push   %rdi
    1ed2:	02 a8 10 00 00 1f    	add    0x1f000010(%rax),%ch
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1ed8:	30 65 01             	xor    %ah,0x1(%rbp)
    1edb:	00 5a 02             	add    %bl,0x2(%rdx)
    1ede:	ba 00 00 00 1e       	mov    $0x1e000000,%edx
    if (pckt->flow.proto == IPPROTO_UDP) {
    1ee3:	c4                   	(bad)
    1ee4:	00 59 02             	add    %bl,0x2(%rcx)
    1ee7:	bf 00 00 00 1f       	mov    $0x1f000000,%edi
      new_dst_lru.atime = cur_time;
    1eec:	1e                   	(bad)
    1eed:	c0 00 5a             	rolb   $0x5a,(%rax)
    new_dst_lru.pos = key;
    1ef0:	02 99 09 00 00 1e    	add    0x1e000009(%rcx),%bl
    1ef6:	07                   	(bad)
BPF_MAP_OPS_INLINE(map_update_elem,,
    1ef7:	00 5a 02             	add    %bl,0x2(%rdx)
    1efa:	d6                   	(bad)
    1efb:	10 00                	adc    %al,(%rax)
    1efd:	00 1f                	add    %bl,(%rdi)
    1eff:	1e                   	(bad)
    1f00:	14 00                	adc    $0x0,%al
    1f02:	5a                   	pop    %rdx
    1f03:	02 db                	add    %bl,%bl
    1f05:	10 00                	adc    %al,(%rax)
    1f07:	00 1e                	add    %bl,(%rsi)
    1f09:	c2 00 5a             	ret    $0x5a00
    1f0c:	02 db                	add    %bl,%bl
    1f0e:	10 00                	adc    %al,(%rax)
    1f10:	00 1e                	add    %bl,(%rsi)
      (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
    1f12:	c1 00 5a             	roll   $0x5a,(%rax)
    1f15:	02 bf 00 00 00 00    	add    0x0(%rdi),%bh
    1f1b:	00 00                	add    %al,(%rax)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1f1d:	1f                   	(bad)
    1f1e:	1e                   	(bad)
    1f1f:	c0 00 4b             	rolb   $0x4b,(%rax)
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1f22:	02 99 09 00 00 1e    	add    0x1e000009(%rcx),%bl
    1f28:	07                   	(bad)
    1f29:	00 4b 02             	add    %cl,0x2(%rbx)
    1f2c:	d6                   	(bad)
    1f2d:	10 00                	adc    %al,(%rax)
    1f2f:	00 1f                	add    %bl,(%rdi)
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1f31:	1e                   	(bad)
    1f32:	c1 00 4b             	roll   $0x4b,(%rax)
    1f35:	02 bf 00 00 00 1e    	add    0x1e000000(%rdi),%bh
  bool vip_match = address_match && port_match && proto_match;
    1f3b:	14 00                	adc    $0x0,%al
    1f3d:	4b 02 db             	rex.WXB add %r11b,%bl
    1f40:	10 00                	adc    %al,(%rax)
    1f42:	00 1e                	add    %bl,(%rsi)
    1f44:	c2 00 4b             	ret    $0x4b00
    __u32 lru_stats_key = pckt->real_index;
    1f47:	02 db                	add    %bl,%bl
    1f49:	10 00                	adc    %al,(%rax)
    1f4b:	00 00                	add    %al,(%rax)
    1f4d:	00 00                	add    %al,(%rax)
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1f4f:	33 66 01             	xor    0x1(%rsi),%esp
    1f52:	00 4d 28             	add    %cl,0x28(%rbp)
    1f55:	67 01 00             	add    %eax,(%eax)
    1f58:	4e bf 00 00 00 28 68 	rex.WRX movabs $0x4f00016828000000,%rdi
    1f5f:	01 00 4f 
    1f62:	85 05 00 00 1f 26    	test   %eax,0x261f0000(%rip)        # 261f1f68 <_license+0x261efbd3>
    if (!lru_miss_stat) {
    1f68:	c0 00 50             	rolb   $0x50,(%rax)
    1f6b:	99                   	cltd
    1f6c:	09 00                	or     %eax,(%rax)
    *lru_miss_stat += 1;
    1f6e:	00 26                	add    %ah,(%rsi)
      data_stats->v2 += 1;
    1f70:	07                   	(bad)
    1f71:	00 50 d6             	add    %dl,-0x2a(%rax)
    1f74:	10 00                	adc    %al,(%rax)
    1f76:	00 1f                	add    %bl,(%rdi)
    1f78:	26 c1 00 50          	es roll $0x50,(%rax)
    1f7c:	bf 00 00 00 26       	mov    $0x26000000,%edi
    1f81:	14 00                	adc    $0x0,%al
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1f83:	50                   	push   %rax
    1f84:	db 10                	fistl  (%rax)
    1f86:	00 00                	add    %al,(%rax)
    1f88:	26 c2 00 50          	es ret $0x5000
    1f8c:	db 10                	fistl  (%rax)
    1f8e:	00 00                	add    %al,(%rax)
  if (!ch_drop_stats) {
    1f90:	00 00                	add    %al,(%rax)
    1f92:	00 33                	add    %dh,(%rbx)
  ch_drop_stats->v2 += 1;
    1f94:	69 01 00 42 28 67    	imul   $0x67284200,(%rcx),%eax
    1f9a:	01 00                	add    %eax,(%rax)
    1f9c:	43 bf 00 00 00 28    	rex.XB mov $0x28000000,%r15d
}
    1fa2:	68 01 00 44 85       	push   $0xffffffff85440001
    1fa7:	05 00 00 1f 26       	add    $0x261f0000,%eax
    1fac:	c0 00 45             	rolb   $0x45,(%rax)
    1faf:	99                   	cltd
    1fb0:	09 00                	or     %eax,(%rax)
    1fb2:	00 26                	add    %ah,(%rsi)
    1fb4:	07                   	(bad)
    1fb5:	00 45 d6             	add    %al,-0x2a(%rbp)
    1fb8:	10 00                	adc    %al,(%rax)
    1fba:	00 1f                	add    %bl,(%rdi)
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1fbc:	26 c1 00 45          	es roll $0x45,(%rax)
    1fc0:	bf 00 00 00 26       	mov    $0x26000000,%edi
    1fc5:	14 00                	adc    $0x0,%al
    1fc7:	45 db 10             	rex.RB fistl (%r8)
  if (!ch_drop_stats) {
    1fca:	00 00                	add    %al,(%rax)
    1fcc:	26 c2 00 45          	es ret $0x4500
    1fd0:	db 10                	fistl  (%rax)
    1fd2:	00 00                	add    %al,(%rax)
    1fd4:	00 00                	add    %al,(%rax)
    1fd6:	00 2a                	add    %ch,(%rdx)
    1fd8:	6a 01                	push   $0x1
    1fda:	11 2a                	adc    %ebp,(%rdx)
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1fdc:	a8 10                	test   $0x10,%al
    1fde:	00 00                	add    %al,(%rax)
    1fe0:	25 a1 11 2b 3e       	and    $0x3e2b11a1,%eax
    1fe5:	10 00                	adc    %al,(%rax)
    1fe7:	00 25 bd 11 2c cb    	add    %ah,-0x34d3ee43(%rip)        # ffffffffcb2c31aa <server_id_map+0x36ffb2bda1aa>
  data = (void*)(long)xdp->data;
    1fed:	00 00                	add    %al,(%rax)
  data_end = (void*)(long)xdp->data_end;
    1fef:	00 25 ad 11 2d a8    	add    %ah,-0x57d2ee53(%rip)        # ffffffffa82d31a2 <server_id_map+0x36ff8fbea1a2>
  ip6h = data + sizeof(struct ethhdr);
    1ff5:	10 00                	adc    %al,(%rax)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1ff7:	00 25 af 11 2e 6e    	add    %ah,0x6e2e11af(%rip)        # 6e2e31ac <_license+0x6e2e0e17>
    1ffd:	11 00                	adc    %eax,(%rax)
    1fff:	00 25 2a 11 2f f2    	add    %ah,-0xdd0eed6(%rip)        # fffffffff22f312f <server_id_map+0x36ffd9c0a12f>
    2005:	04 00                	add    $0x0,%al
    2007:	00 25 bb 11 30 bf    	add    %ah,-0x40cfee45(%rip)        # ffffffffbf3031c8 <server_id_map+0x36ffa6c1a1c8>
    200d:	00 00                	add    %al,(%rax)
    200f:	00 26                	add    %ah,(%rsi)
    2011:	a2 11 31 99 09 00 00 	movabs %al,0xa326000009993111
    2018:	26 a3 
  memcpy(new_eth->h_dest, cval->mac, 6);
    201a:	11 32                	adc    %esi,(%rdx)
    201c:	99                   	cltd
    201d:	09 00                	or     %eax,(%rax)
    201f:	00 28                	add    %ch,(%rax)
    2021:	2f                   	(bad)
    2022:	01 11                	add    %edx,(%rcx)
    2024:	34 36                	xor    $0x36,%al
    2026:	15 00 00 26 d2       	adc    $0xd2260000,%eax
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    202b:	11 33                	adc    %esi,(%rbx)
    202d:	52                   	push   %rdx
    202e:	0a 00                	or     (%rax),%al
    2030:	00 28                	add    %ch,(%rax)
    2032:	2e 01 11             	cs add %edx,(%rcx)
    2035:	35 36 15 00 00       	xor    $0x1536,%eax
  new_eth->h_proto = BE_ETH_P_IPV6;
    203a:	26 22 11             	es and (%rcx),%dl
    create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
    203d:	38 16                	cmp    %dl,(%rsi)
    203f:	01 00                	add    %eax,(%rax)
  saddr[3] = src ^ port;
    2041:	00 26                	add    %ah,(%rsi)
    2043:	87 11                	xchg   %edx,(%rcx)
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    2045:	37                   	(bad)
    2046:	53                   	push   %rbx
    2047:	20 00                	and    %al,(%rax)
    2049:	00 26                	add    %ah,(%rsi)
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    204b:	83 11 36             	adcl   $0x36,(%rcx)
    204e:	a0 02 00 00 00 04 bf 	movabs 0xbf0400000002,%al
    2055:	00 00 
  ip6h->priority = (tc & 0xF0) >> 4;
    2057:	00 05 64 00 00 00    	add    %al,0x64(%rip)        # 20c1 <balancer_ingress+0x20c1>
    205d:	04 00                	add    $0x0,%al
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    205f:	32 6b 01             	xor    0x1(%rbx),%ch
    2062:	12 21                	adc    (%rcx),%ah
  ip6h->nexthdr = proto;
    2064:	25 1f 12 21 a0       	and    $0xa021121f,%eax
    2069:	02 00                	add    (%rax),%al
  ip6h->payload_len = bpf_htons(payload_len);
    206b:	00 25 28 12 21 bc    	add    %ah,-0x43deedd8(%rip)        # ffffffffbc213299 <server_id_map+0x36ffa3b2a299>
  memcpy(ip6h->saddr.s6_addr32, saddr, 16);
    2071:	01 00                	add    %eax,(%rax)
    2073:	00 25 87 12 21 ba    	add    %ah,-0x45deed79(%rip)        # ffffffffba213300 <server_id_map+0x36ffa1b2a300>
    2079:	00 00                	add    %al,(%rax)
    207b:	00 00                	add    %al,(%rax)
    207d:	32 6c 01 12          	xor    0x12(%rcx,%rax,1),%ch
  memcpy(ip6h->daddr.s6_addr32, daddr, 16);
    2081:	4c 25 d2 12 4d 52    	rex.WR and $0x524d12d2,%rax
    2087:	0a 00                	or     (%rax),%al
    2089:	00 2f                	add    %ch,(%rdi)
    208b:	6d                   	insl   (%dx),%es:(%rdi)
    208c:	01 12                	add    %edx,(%rdx)
    208e:	4e 16                	rex.WRX (bad)
    2090:	01 00                	add    %eax,(%rax)
    2092:	00 25 87 12 4f ba    	add    %ah,-0x45b0ed79(%rip)        # ffffffffba4f331f <server_id_map+0x36ffa1e0a31f>
    2098:	00 00                	add    %al,(%rax)
    209a:	00 25 8d 12 50 ba    	add    %ah,-0x45afed73(%rip)        # ffffffffba50332d <server_id_map+0x36ffa1e1a32d>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    20a0:	00 00                	add    %al,(%rax)
    20a2:	00 25 83 12 51 a0    	add    %ah,-0x5faeed7d(%rip)        # ffffffffa051332b <server_id_map+0x36ff87e2a32b>
    20a8:	02 00                	add    (%rax),%al
    20aa:	00 25 22 12 52 16    	add    %ah,0x16521222(%rip)        # 165232d2 <_license+0x16520f3d>
  if (!conn_rate_stats) {
    20b0:	01 00                	add    %eax,(%rax)
    20b2:	00 00                	add    %al,(%rax)
    20b4:	34 14                	xor    $0x14,%al
    20b6:	53                   	push   %rbx
    20b7:	22 00                	and    (%rax),%al
    20b9:	00 01                	add    %al,(%rcx)
  *cur_time = bpf_ktime_get_ns();
    20bb:	57                   	push   %rdi
    20bc:	7b 01                	jnp    20bf <balancer_ingress+0x20bf>
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    20be:	00 32                	add    %dh,(%rdx)
    20c0:	04 b6                	add    $0xb6,%al
    20c2:	00 00                	add    %al,(%rax)
    20c4:	00 35 00 31 01 00    	add    %dh,0x13100(%rip)        # 151ca <_license+0x12e35>
    20ca:	32 04 3e             	xor    (%rsi,%rdi,1),%al
    conn_rate_stats->v1 = 1;
    20cd:	10 00                	adc    %al,(%rax)
    20cf:	00 36                	add    %dh,(%rsi)
    20d1:	01 a2 00 33 04 99    	add    %esp,-0x66fbcd00(%rdx)
    conn_rate_stats->v2 = *cur_time;
    20d7:	09 00                	or     %eax,(%rax)
    20d9:	00 36                	add    %dh,(%rsi)
      dst_lru->pos = pckt->real_index;
    20db:	02 a3 00 34 04 99    	add    -0x66fbcc00(%rbx),%ah
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    20e1:	09 00                	or     %eax,(%rax)
    20e3:	00 37                	add    %dh,(%rdi)
    20e5:	03 05 01 00 35 04    	add    0x4350001(%rip),%eax        # 43520ec <_license+0x434fd57>
    20eb:	36 15 00 00 36 04    	ss adc $0x4360000,%eax
    20f1:	ac                   	lods   %ds:(%rsi),%al
    20f2:	00 37                	add    %dh,(%rdi)
    20f4:	04 bf                	add    $0xbf,%al
    20f6:	00 00                	add    %al,(%rax)
    20f8:	00 30                	add    %dh,(%rax)
    20fa:	7e 01                	jle    20fd <balancer_ingress+0x20fd>
    20fc:	00 36                	add    %dh,(%rsi)
    20fe:	04 bf                	add    $0xbf,%al
    2100:	00 00                	add    %al,(%rax)
    2102:	00 38                	add    %bh,(%rax)
    2104:	87 0c 00             	xchg   %ecx,(%rax,%rax,1)
  if (!per_vip_stats) {
    2107:	00 00                	add    %al,(%rax)
    2109:	00 42 04             	add    %al,0x4(%rdx)
    per_vip_stats->v2 += 1;
    210c:	0c 39                	or     $0x39,%al
    210e:	05 90 0c 00 00       	add    $0xc90,%eax
    conn_rate_stats->v1 += 1;
    2113:	39 06                	cmp    %eax,(%rsi)
    2115:	99                   	cltd
    2116:	0c 00                	or     $0x0,%al
    2118:	00 39                	add    %bh,(%rcx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    211a:	07                   	(bad)
    211b:	a2 0c 00 00 3a 02 91 	movabs %al,0xab1091023a00000c
    2122:	10 ab 
  struct real_pos_lru new_dst_lru = {};
    2124:	0c 00                	or     $0x0,%al
    2126:	00 3a                	add    %bh,(%rdx)
    2128:	03 91 d8 00 b4 0c    	add    0xcb400d8(%rcx),%edx
    212e:	00 00                	add    %al,(%rax)
    2130:	3b 08                	cmp    (%rax),%ecx
    2132:	bd 0c 00 00 3b       	mov    $0x3b00000c,%ebp
  new_dst_lru.pos = pckt->real_index;
    2137:	09 c6                	or     %eax,%esi
    2139:	0c 00                	or     $0x0,%al
    213b:	00 3b                	add    %bh,(%rbx)
    213d:	0a cf                	or     %bh,%cl
    213f:	0c 00                	or     $0x0,%al
    2141:	00 3b                	add    %bh,(%rbx)
    2143:	0b d8                	or     %eax,%ebx
    2145:	0c 00                	or     $0x0,%al
    2147:	00 3b                	add    %bh,(%rbx)
    2149:	0c e1                	or     $0xe1,%al
    214b:	0c 00                	or     $0x0,%al
              quic_packets_stats->dst_not_found_in_lru += 1;
    214d:	00 3b                	add    %bh,(%rbx)
    214f:	3f                   	(bad)
    2150:	ea                   	(bad)
    2151:	0c 00                	or     $0x0,%al
    2153:	00 3b                	add    %bh,(%rbx)
    2155:	40                   	rex
    2156:	f3 0c 00             	repz or $0x0,%al
            quic_packets_stats->cid_routed += 1;
    2159:	00 3b                	add    %bh,(%rbx)
  original_sport = pckt.flow.port16[0];
    215b:	b5 01                	mov    $0x1,%ch
    215d:	fc                   	cld
    215e:	0c 00                	or     $0x0,%al
    2160:	00 3b                	add    %bh,(%rbx)
    2162:	b6 01                	mov    $0x1,%dh
    2164:	05 0d 00 00 3b       	add    $0x3b00000d,%eax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    2169:	b8 01 0e 0d 00       	mov    $0xd0e01,%eax
    216e:	00 3b                	add    %bh,(%rbx)
    2170:	ba 01 17 0d 00       	mov    $0xd1701,%edx
    2175:	00 3b                	add    %bh,(%rbx)
    2177:	c2 01 20             	ret    $0x2001
    217a:	0d 00 00 3b d0       	or     $0xd03b0000,%eax
    217f:	02 29                	add    (%rcx),%ch
    2181:	0d 00 00 3b 8c       	or     $0x8c3b0000,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    2186:	03 32                	add    (%rdx),%esi
    2188:	0d 00 00 38 01       	or     $0x1380000,%eax
    218d:	11 00                	adc    %eax,(%rax)
    218f:	00 01                	add    %al,(%rcx)
  if (!conn_rate_stats) {
    2191:	00 bb 02 0c 39 0d    	add    %bh,0xd390c02(%rbx)
    2197:	0a 11                	or     (%rcx),%dl
    2199:	00 00                	add    %al,(%rax)
    219b:	39 0e                	cmp    %ecx,(%rsi)
    219d:	1c 11                	sbb    $0x11,%al
    219f:	00 00                	add    %al,(%rax)
  *cur_time = bpf_ktime_get_ns();
    21a1:	39 0f                	cmp    %ecx,(%rdi)
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    21a3:	37                   	(bad)
    21a4:	11 00                	adc    %eax,(%rax)
    21a6:	00 39                	add    %bh,(%rcx)
    21a8:	10 40 11             	adc    %al,0x11(%rax)
    21ab:	00 00                	add    %al,(%rax)
    21ad:	39 11                	cmp    %edx,(%rcx)
    21af:	49 11 00             	adc    %rax,(%r8)
    conn_rate_stats->v1 = 1;
    21b2:	00 3b                	add    %bh,(%rbx)
    21b4:	12 52 11             	adc    0x11(%rdx),%dl
    21b7:	00 00                	add    %al,(%rax)
    conn_rate_stats->v2 = *cur_time;
    21b9:	00 38                	add    %bh,(%rax)
    21bb:	93                   	xchg   %eax,%ebx
    21bc:	12 00                	adc    (%rax),%al
    21be:	00 02                	add    %al,(%rdx)
      dst_lru->pos = pckt->real_index;
    21c0:	00 c0                	add    %al,%al
              quic_packets_stats->dst_mismatch_in_lru += 1;
    21c2:	02 0c 39             	add    (%rcx,%rdi,1),%cl
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    21c5:	41 9c                	rex.B pushf
    21c7:	12 00                	adc    (%rax),%al
    21c9:	00 39                	add    %bh,(%rcx)
    21cb:	42 a5                	rex.X movsl %ds:(%rsi),%es:(%rdi)
    21cd:	12 00                	adc    (%rax),%al
    21cf:	00 39                	add    %bh,(%rcx)
    21d1:	43 ae                	rex.XB scas %es:(%rdi),%al
    21d3:	12 00                	adc    (%rax),%al
    21d5:	00 39                	add    %bh,(%rcx)
    21d7:	44 b7 12             	rex.R mov $0x12,%dil
    21da:	00 00                	add    %al,(%rax)
    21dc:	39 45 c0             	cmp    %eax,-0x40(%rbp)
    21df:	12 00                	adc    (%rax),%al
    21e1:	00 38                	add    %bh,(%rax)
    21e3:	73 11                	jae    21f6 <balancer_ingress+0x21f6>
    21e5:	00 00                	add    %al,(%rax)
    21e7:	03 0e                	add    (%rsi),%ecx
    21e9:	5c                   	pop    %rsp
    21ea:	01 0c 39             	add    %ecx,(%rcx,%rdi,1)
  if (!per_vip_stats) {
    21ed:	13 7c 11 00          	adc    0x0(%rcx,%rdx,1),%edi
    per_vip_stats->v2 += 1;
    21f1:	00 39                	add    %bh,(%rcx)
    21f3:	14 85                	adc    $0x85,%al
    21f5:	11 00                	adc    %eax,(%rax)
    conn_rate_stats->v1 += 1;
    21f7:	00 39                	add    %bh,(%rcx)
    21f9:	15 8e 11 00 00       	adc    $0x118e,%eax
    21fe:	39 16                	cmp    %edx,(%rsi)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    2200:	97                   	xchg   %eax,%edi
    2201:	11 00                	adc    %eax,(%rax)
    2203:	00 3b                	add    %bh,(%rbx)
    2205:	17                   	(bad)
    2206:	a0 11 00 00 3b 89 01 	movabs 0x11a901893b000011,%al
    220d:	a9 11 
  struct real_pos_lru new_dst_lru = {};
    220f:	00 00                	add    %al,(%rax)
    2211:	3c ca                	cmp    $0xca,%al
    2213:	12 00                	adc    (%rax),%al
    2215:	00 15 49 00 00 00    	add    %dl,0x49(%rip)        # 2264 <jhash_2words+0x4>
  new_dst_lru.pos = pckt->real_index;
    221b:	0e                   	(bad)
    221c:	1f                   	(bad)
    221d:	01 0c 3d 01 5f d2 12 	add    %ecx,0x12d25f01(,%rdi,1)
    2224:	00 00                	add    %al,(%rax)
    2226:	3d 01 5d da 12       	cmp    $0x12da5d01,%eax
    222b:	00 00                	add    %al,(%rax)
    222d:	3b 18                	cmp    (%rax),%ebx
    222f:	e2 12                	loop   2243 <balancer_ingress+0x2243>
    2231:	00 00                	add    %al,(%rax)
    2233:	3e 00 ea             	ds add %ch,%dl
              quic_packets_stats->dst_not_found_in_lru += 1;
    2236:	12 00                	adc    (%rax),%al
    2238:	00 3e                	add    %bh,(%rsi)
    223a:	22 f2                	and    %dl,%dh
    223c:	12 00                	adc    (%rax),%al
            quic_packets_stats->cid_routed += 1;
    223e:	00 3a                	add    %bh,(%rdx)
    2240:	01 53 fa             	add    %edx,-0x6(%rbx)
  original_sport = pckt.flow.port16[0];
    2243:	12 00                	adc    (%rax),%al
    2245:	00 3f                	add    %bh,(%rdi)
    2247:	0b 13                	or     (%rbx),%edx
    2249:	00 00                	add    %al,(%rax)
    224b:	16                   	(bad)
    224c:	26 00 00             	es add %al,(%rax)
    224f:	00 0e                	add    %cl,(%rsi)
    2251:	59                   	pop    %rcx
    2252:	03 3b                	add    (%rbx),%edi
    2254:	19 1f                	sbb    %ebx,(%rdi)
    2256:	13 00                	adc    (%rax),%eax
    2258:	00 40 16             	add    %al,0x16(%rax)
    225b:	26 00 00             	es add %al,(%rax)
    225e:	00 3b                	add    %bh,(%rbx)
  a += initval;
    2260:	1a 28                	sbb    (%rax),%ch
    2262:	13 00                	adc    (%rax),%eax
    2264:	00 00                	add    %al,(%rax)
    2266:	00 00                	add    %al,(%rax)
    2268:	40 17                	rex (bad)
  b += initval;
    226a:	23 00                	and    (%rax),%eax
    226c:	00 00                	add    %al,(%rax)
    226e:	3e 8d 04 b3          	ds lea (%rbx,%rsi,4),%eax
  __jhash_final(a, b, c);
    2272:	11 00                	adc    %eax,(%rax)
    2274:	00 3b                	add    %bh,(%rbx)
    2276:	88 01                	mov    %al,(%rcx)
  return (word << shift) | (word >> ((-shift) & 31));
    2278:	bc 11 00 00 40       	mov    $0x40000011,%esp
  __jhash_final(a, b, c);
    227d:	17                   	(bad)
    227e:	0c 00                	or     $0x0,%al
  return (word << shift) | (word >> ((-shift) & 31));
    2280:	00 00                	add    %al,(%rax)
    2282:	3b 87 01 cf 11 00    	cmp    0x11cf01(%rdi),%eax
  __jhash_final(a, b, c);
    2288:	00 41 06             	add    %al,0x6(%rcx)
  return (word << shift) | (word >> ((-shift) & 31));
    228b:	d8 11                	fcoms  (%rcx)
    228d:	00 00                	add    %al,(%rax)
  __jhash_final(a, b, c);
    228f:	40 17                	rex (bad)
  return (word << shift) | (word >> ((-shift) & 31));
    2291:	0c 00                	or     $0x0,%al
    2293:	00 00                	add    %al,(%rax)
  __jhash_final(a, b, c);
    2295:	3e 8d 04 e2          	ds lea (%rdx,%riz,8),%eax
    2299:	11 00                	adc    %eax,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    229b:	00 3e                	add    %bh,(%rsi)
    229d:	80 08 eb             	orb    $0xeb,(%rax)
  __jhash_final(a, b, c);
    22a0:	11 00                	adc    %eax,(%rax)
    22a2:	00 3e                	add    %bh,(%rsi)
  return (word << shift) | (word >> ((-shift) & 31));
    22a4:	08 f4                	or     %dh,%ah
    22a6:	11 00                	adc    %eax,(%rax)
  __jhash_final(a, b, c);
    22a8:	00 00                	add    %al,(%rax)
    22aa:	00 00                	add    %al,(%rax)
  return (word << shift) | (word >> ((-shift) & 31));
    22ac:	00 38                	add    %bh,(%rax)
  __jhash_final(a, b, c);
    22ae:	32 13                	xor    (%rbx),%dl
  return __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 << 2));
    22b0:	00 00                	add    %al,(%rax)
    22b2:	04 0e                	add    $0xe,%al
    22b4:	5a                   	pop    %rdx
    22b5:	01 0c 39             	add    %ecx,(%rcx,%rdi,1)
    22b8:	46 3a 13             	rex.RX cmp (%rbx),%r10b
    22bb:	00 00                	add    %al,(%rax)
    22bd:	39 47 42             	cmp    %eax,0x42(%rdi)
    a += *(u32*)(k);
    22c0:	13 00                	adc    (%rax),%eax
    22c2:	00 39                	add    %bh,(%rcx)
    22c4:	48                   	rex.W
    22c5:	4a 13 00             	rex.WX adc (%rax),%rax
    b += *(u32*)(k + 4);
    22c8:	00 39                	add    %bh,(%rcx)
    22ca:	49 52                	rex.WB push %r10
    22cc:	13 00                	adc    (%rax),%eax
    22ce:	00 3b                	add    %bh,(%rbx)
    c += *(u32*)(k + 8);
    22d0:	4a 5a                	rex.WX pop %rdx
    22d2:	13 00                	adc    (%rax),%eax
    __jhash_mix(a, b, c);
    22d4:	00 3b                	add    %bh,(%rbx)
    c += *(u32*)(k + 8);
    22d6:	a1 01 62 13 00 00 3f 	movabs 0x14d03f0000136201,%eax
    22dd:	d0 14 
  return (word << shift) | (word >> ((-shift) & 31));
    22df:	00 00                	add    %al,(%rax)
    __jhash_mix(a, b, c);
    22e1:	18 17                	sbb    %dl,(%rdi)
    22e3:	00 00                	add    %al,(%rax)
    22e5:	00 0e                	add    %cl,(%rsi)
  return (word << shift) | (word >> ((-shift) & 31));
    22e7:	f0 0c 3d             	lock or $0x3d,%al
    22ea:	01 5f d9             	add    %ebx,-0x27(%rdi)
    __jhash_mix(a, b, c);
    22ed:	14 00                	adc    $0x0,%al
    22ef:	00 3d 01 5d e1 14    	add    %bh,0x14e15d01(%rip)        # 14e17ff6 <_license+0x14e15c61>
    22f5:	00 00                	add    %al,(%rax)
    22f7:	3a 02                	cmp    (%rdx),%al
    22f9:	91                   	xchg   %eax,%ecx
    22fa:	00 e9                	add    %ch,%cl
    22fc:	14 00                	adc    $0x0,%al
    22fe:	00 3e                	add    %bh,(%rsi)
    2300:	00 f1                	add    %dh,%cl
  return (word << shift) | (word >> ((-shift) & 31));
    2302:	14 00                	adc    $0x0,%al
    __jhash_mix(a, b, c);
    2304:	00 00                	add    %al,(%rax)
    2306:	40 19 2a             	rex sbb %ebp,(%rdx)
  return (word << shift) | (word >> ((-shift) & 31));
    2309:	00 00                	add    %al,(%rax)
    230b:	00 3e                	add    %bh,(%rsi)
    230d:	8c 04 6b             	mov    %es,(%rbx,%rbp,2)
    __jhash_mix(a, b, c);
    2310:	13 00                	adc    (%rax),%eax
    2312:	00 3b                	add    %bh,(%rbx)
    2314:	9f                   	lahf
  return (word << shift) | (word >> ((-shift) & 31));
    2315:	01 73 13             	add    %esi,0x13(%rbx)
    2318:	00 00                	add    %al,(%rax)
    231a:	3b a0 01 7c 13 00    	cmp    0x137c01(%rax),%esp
    __jhash_mix(a, b, c);
    2320:	00 40 19             	add    %al,0x19(%rax)
    2323:	0c 00                	or     $0x0,%al
    2325:	00 00                	add    %al,(%rax)
    2327:	3b 9e 01 85 13 00    	cmp    0x138501(%rsi),%ebx
      a += (u32)k[3] << 24;
    232d:	00 41 06             	add    %al,0x6(%rcx)
    2330:	8d 13                	lea    (%rbx),%edx
    2332:	00 00                	add    %al,(%rax)
      a += (u32)k[2] << 16;
    2334:	40 19 0c 00          	rex sbb %ecx,(%rax,%rax,1)
    2338:	00 00                	add    %al,(%rax)
    233a:	3e 8c 04 96          	ds mov %es,(%rsi,%rdx,4)
      a += (u32)k[3] << 24;
    233e:	13 00                	adc    (%rax),%eax
      a += (u32)k[1] << 8;
    2340:	00 3e                	add    %bh,(%rsi)
    2342:	80 08 9e             	orb    $0x9e,(%rax)
    2345:	13 00                	adc    (%rax),%eax
    2347:	00 3e                	add    %bh,(%rsi)
      a += (u32)k[2] << 16;
    2349:	08 a6 13 00 00 00    	or     %ah,0x13(%rsi)
      a += (u32)k[1] << 8;
    234f:	00 00                	add    %al,(%rax)
    2351:	00 00                	add    %al,(%rax)
      a += k[0];
    2353:	3c 86                	cmp    $0x86,%al
    __jhash_mix(a, b, c);
    2355:	15 00 00 1a 2b       	adc    $0x2b1a0000,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    235a:	00 00                	add    %al,(%rax)
    235c:	00 00                	add    %al,(%rax)
      __jhash_final(a, b, c);
    235e:	f4                   	hlt
    235f:	02 0a                	add    (%rdx),%cl
  return (word << shift) | (word >> ((-shift) & 31));
    2361:	3d 01 5f 8f 15       	cmp    $0x158f5f01,%eax
      __jhash_final(a, b, c);
    2366:	00 00                	add    %al,(%rax)
    2368:	3d 01 5d 97 15       	cmp    $0x15975d01,%eax
  return (word << shift) | (word >> ((-shift) & 31));
    236d:	00 00                	add    %al,(%rax)
    236f:	3d 02 30 9f 9f       	cmp    $0x9f9f3002,%eax
    2374:	15 00 00 3d 03       	adc    $0x33d0000,%eax
      __jhash_final(a, b, c);
    2379:	91                   	xchg   %eax,%ecx
    237a:	10 9f a7 15 00 00    	adc    %bl,0x15a7(%rdi)
  return (word << shift) | (word >> ((-shift) & 31));
    2380:	3a 11                	cmp    (%rcx),%dl
      __jhash_final(a, b, c);
    2382:	71 00                	jno    2384 <jhash+0xc4>
    2384:	10 ff                	adc    %bh,%bh
  return (word << shift) | (word >> ((-shift) & 31));
    2386:	01 1a                	add    %ebx,(%rdx)
    2388:	a8 be                	test   $0xbe,%al
      __jhash_final(a, b, c);
    238a:	80 80 00 a8 b9 80 80 	addb   $0x80,-0x7f465800(%rax)
    2391:	00 9f af 15 00 00    	add    %bl,0x15af(%rdi)
    2397:	3b 4b b7             	cmp    -0x49(%rbx),%ecx
    239a:	15 00 00 3f 93       	adc    $0x933f0000,%eax
    239f:	16                   	(bad)
    23a0:	00 00                	add    %al,(%rax)
    23a2:	1b 02                	sbb    (%rdx),%eax
    23a4:	00 00                	add    %al,(%rax)
    23a6:	00 0c 7b             	add    %cl,(%rbx,%rdi,2)
    23a9:	0f 3d                	(bad)
    23ab:	02 30                	add    (%rax),%dh
    23ad:	9f                   	lahf
    23ae:	9c                   	pushf
    23af:	16                   	(bad)
    23b0:	00 00                	add    %al,(%rax)
    23b2:	3d 11 71 00 10       	cmp    $0x10007111,%eax
    23b7:	ff 01                	incl   (%rcx)
    23b9:	1a a8 be 80 80 00    	sbb    0x8080be(%rax),%ch
    23bf:	a8 b9                	test   $0xb9,%al
    23c1:	80 80 00 9f a4 16 00 	addb   $0x0,0x16a49f00(%rax)
    23c8:	00 00                	add    %al,(%rax)
    23ca:	00 3c 14             	add    %bh,(%rsp,%rdx,1)
    23cd:	19 00                	sbb    %eax,(%rax)
    23cf:	00 1c 17             	add    %bl,(%rdi,%rdx,1)
    23d2:	00 00                	add    %al,(%rax)
    23d4:	00 00                	add    %al,(%rax)
    23d6:	f8                   	clc
    23d7:	02 0a                	add    (%rdx),%cl
    23d9:	3d 01 5f 1d 19       	cmp    $0x191d5f01,%eax
    23de:	00 00                	add    %al,(%rax)
    23e0:	3d 01 5d 25 19       	cmp    $0x19255d01,%eax
    23e5:	00 00                	add    %al,(%rax)
    23e7:	3d 02 30 9f 2d       	cmp    $0x2d9f3002,%eax
    23ec:	19 00                	sbb    %eax,(%rax)
    23ee:	00 3d 03 91 10 9f    	add    %bh,-0x60ef6efd(%rip)        # ffffffff9f10b4f7 <server_id_map+0x36ff86a224f7>
    23f4:	35 19 00 00 3a       	xor    $0x3a000019,%eax
    23f9:	11 71 00             	adc    %esi,0x0(%rcx)
    23fc:	10 ff                	adc    %bh,%bh
    23fe:	01 1a                	add    %ebx,(%rdx)
    2400:	a8 be                	test   $0xbe,%al
    2402:	80 80 00 a8 b9 80 80 	addb   $0x80,-0x7f465800(%rax)
    2409:	00 9f 3d 19 00 00    	add    %bl,0x193d(%rdi)
    240f:	3b b2 01 45 19 00    	cmp    0x194501(%rdx),%esi
    2415:	00 3f                	add    %bh,(%rdi)
    2417:	93                   	xchg   %eax,%ebx
    2418:	16                   	(bad)
    2419:	00 00                	add    %al,(%rax)
    241b:	1d 02 00 00 00       	sbb    $0x2,%eax
    2420:	0c 61                	or     $0x61,%al
    2422:	0f 3d                	(bad)
    2424:	02 30                	add    (%rax),%dh
    2426:	9f                   	lahf
    2427:	9c                   	pushf
    2428:	16                   	(bad)
    2429:	00 00                	add    %al,(%rax)
    242b:	3d 11 71 00 10       	cmp    $0x10007111,%eax
    2430:	ff 01                	incl   (%rcx)
    2432:	1a a8 be 80 80 00    	sbb    0x8080be(%rax),%ch
    2438:	a8 b9                	test   $0xb9,%al
    243a:	80 80 00 9f a4 16 00 	addb   $0x0,0x16a49f00(%rax)
    2441:	00 00                	add    %al,(%rax)
    2443:	00 42 05             	add    %al,0x5(%rdx)
    2446:	3b 8b 01 62 0d 00    	cmp    0xd6201(%rbx),%ecx
    244c:	00 38                	add    %bh,(%rax)
    244e:	b5 16                	mov    $0x16,%ch
    2450:	00 00                	add    %al,(%rax)
    2452:	06                   	(bad)
    2453:	00 e2                	add    %ah,%dl
    2455:	02 0e                	add    (%rsi),%cl
    2457:	39 8c 01 be 16 00 00 	cmp    %ecx,0x16be(%rcx,%rax,1)
    245e:	39 8d 01 c6 16 00    	cmp    %ecx,0x16c601(%rbp)
    2464:	00 3a                	add    %bh,(%rdx)
    2466:	02 91 00 d6 16 00    	add    0x16d600(%rcx),%dl
    246c:	00 3b                	add    %bh,(%rbx)
    246e:	90                   	nop
    246f:	01 df                	add    %ebx,%edi
    2471:	16                   	(bad)
    2472:	00 00                	add    %al,(%rax)
    2474:	3b 92 01 e8 16 00    	cmp    0x16e801(%rdx),%edx
    247a:	00 40 1e             	add    %al,0x1e(%rax)
    247d:	1f                   	(bad)
    247e:	00 00                	add    %al,(%rax)
    2480:	00 3b                	add    %bh,(%rbx)
    2482:	8e 01                	mov    (%rcx),%es
    2484:	f1                   	int1
    2485:	16                   	(bad)
    2486:	00 00                	add    %al,(%rax)
    2488:	41 01 f9             	add    %edi,%r9d
    248b:	16                   	(bad)
    248c:	00 00                	add    %al,(%rax)
    248e:	3f                   	(bad)
    248f:	3e 17                	ds (bad)
    2491:	00 00                	add    %al,(%rax)
    2493:	1e                   	(bad)
    2494:	1f                   	(bad)
    2495:	00 00                	add    %al,(%rax)
    2497:	00 00                	add    %al,(%rax)
    2499:	d5                   	(bad)
    249a:	1c 39                	sbb    $0x39,%al
    249c:	8f 01                	pop    (%rcx)
    249e:	48 17                	rex.W (bad)
    24a0:	00 00                	add    %al,(%rax)
    24a2:	3d 01 57 52 17       	cmp    $0x17525701,%eax
    24a7:	00 00                	add    %al,(%rax)
    24a9:	00 00                	add    %al,(%rax)
    24ab:	40 1f                	rex (bad)
    24ad:	18 00                	sbb    %al,(%rax)
    24af:	00 00                	add    %al,(%rax)
    24b1:	3e 86 04 03          	ds xchg %al,(%rbx,%rax,1)
    24b5:	17                   	(bad)
    24b6:	00 00                	add    %al,(%rax)
    24b8:	40 1f                	rex (bad)
    24ba:	0c 00                	or     $0x0,%al
    24bc:	00 00                	add    %al,(%rax)
    24be:	3b 91 01 0c 17 00    	cmp    0x170c01(%rcx),%edx
    24c4:	00 41 06             	add    %al,0x6(%rcx)
    24c7:	14 17                	adc    $0x17,%al
    24c9:	00 00                	add    %al,(%rax)
    24cb:	40 1f                	rex (bad)
    24cd:	0c 00                	or     $0x0,%al
    24cf:	00 00                	add    %al,(%rax)
    24d1:	3e 86 04 1d 17 00 00 	ds xchg %al,0x3e000017(,%rbx,1)
    24d8:	3e 
    24d9:	80 08 25             	orb    $0x25,(%rax)
    24dc:	17                   	(bad)
    24dd:	00 00                	add    %al,(%rax)
    24df:	3e 08 2d 17 00 00 00 	ds or  %ch,0x17(%rip)        # 24fd <_license+0x168>
    24e6:	00 00                	add    %al,(%rax)
    24e8:	00 38                	add    %bh,(%rax)
    24ea:	a1 17 00 00 07 00 e6 	movabs 0xc02e60007000017,%eax
    24f1:	02 0c 
    24f3:	3b 95 01 e1 17 00    	cmp    0x17e101(%rbp),%edx
    24f9:	00 3b                	add    %bh,(%rbx)
    24fb:	97                   	xchg   %eax,%edi
    24fc:	01 ea                	add    %ebp,%edx
    24fe:	17                   	(bad)
    24ff:	00 00                	add    %al,(%rax)
    2501:	3b 99 01 f3 17 00    	cmp    0x17f301(%rcx),%ebx
    2507:	00 40 20             	add    %al,0x20(%rax)
    250a:	6f                   	outsl  %ds:(%rsi),(%dx)
    250b:	00 00                	add    %al,(%rax)
    250d:	00 41 22             	add    %al,0x22(%rcx)
    2510:	15 18 00 00 3c       	adc    $0x3c000018,%eax
    2515:	5c                   	pop    %rsp
    2516:	17                   	(bad)
    2517:	00 00                	add    %al,(%rax)
    2519:	20 32                	and    %dh,(%rdx)
    251b:	00 00                	add    %al,(%rax)
    251d:	00 00                	add    %al,(%rax)
    251f:	45 01 10             	add    %r10d,(%r8)
    2522:	3d 01 5f 65 17       	cmp    $0x17655f01,%eax
    2527:	00 00                	add    %al,(%rax)
    2529:	3d 01 5d 6d 17       	cmp    $0x176d5d01,%eax
    252e:	00 00                	add    %al,(%rax)
    2530:	43 22 75 17          	rex.XB and 0x17(%r13),%sil
    2534:	00 00                	add    %al,(%rax)
    2536:	3d 02 30 9f 7e       	cmp    $0x7e9f3002,%eax
    253b:	17                   	(bad)
    253c:	00 00                	add    %al,(%rax)
    253e:	3b 93 01 8e 17 00    	cmp    0x178e01(%rbx),%edx
    2544:	00 40 20             	add    %al,0x20(%rax)
    2547:	32 00                	xor    (%rax),%al
    2549:	00 00                	add    %al,(%rax)
    254b:	3b 94 01 97 17 00 00 	cmp    0x1797(%rcx,%rax,1),%edx
    2552:	00 00                	add    %al,(%rax)
    2554:	3c 8a                	cmp    $0x8a,%al
    2556:	19 00                	sbb    %eax,(%rax)
    2558:	00 21                	add    %ah,(%rcx)
    255a:	3d 00 00 00 00       	cmp    $0x0,%eax
    255f:	46 01 0c 3a          	add    %r9d,(%rdx,%r15,1)
    2563:	01 5f ab             	add    %ebx,-0x55(%rdi)
    2566:	19 00                	sbb    %eax,(%rax)
    2568:	00 3b                	add    %bh,(%rbx)
    256a:	96                   	xchg   %eax,%esi
    256b:	01 b4 19 00 00 00 00 	add    %esi,0x0(%rcx,%rbx,1)
    2572:	40 22 0c 00          	rex and (%rax,%rax,1),%cl
    2576:	00 00                	add    %al,(%rax)
    2578:	3b 98 01 21 18 00    	cmp    0x182101(%rax),%ebx
    257e:	00 41 06             	add    %al,0x6(%rcx)
    2581:	2a 18                	sub    (%rax),%bl
    2583:	00 00                	add    %al,(%rax)
    2585:	40 22 0c 00          	rex and (%rax,%rax,1),%cl
    2589:	00 00                	add    %al,(%rax)
    258b:	3e 8a 04 34          	ds mov (%rsp,%rsi,1),%al
    258f:	18 00                	sbb    %al,(%rax)
    2591:	00 3e                	add    %bh,(%rsi)
    2593:	80 08 3d             	orb    $0x3d,(%rax)
    2596:	18 00                	sbb    %al,(%rax)
    2598:	00 3e                	add    %bh,(%rsi)
    259a:	08 46 18             	or     %al,0x18(%rsi)
    259d:	00 00                	add    %al,(%rax)
    259f:	00 00                	add    %al,(%rax)
    25a1:	40 23 14 00          	rex and (%rax,%rax,1),%edx
    25a5:	00 00                	add    %al,(%rax)
    25a7:	3e 8e 04 52          	ds mov (%rdx,%rdx,2),%es
    25ab:	18 00                	sbb    %al,(%rax)
    25ad:	00 3b                	add    %bh,(%rbx)
    25af:	9b                   	fwait
    25b0:	01 5c 18 00          	add    %ebx,0x0(%rax,%rbx,1)
    25b4:	00 40 23             	add    %al,0x23(%rax)
    25b7:	0c 00                	or     $0x0,%al
    25b9:	00 00                	add    %al,(%rax)
    25bb:	3b 9a 01 71 18 00    	cmp    0x187101(%rdx),%ebx
    25c1:	00 41 06             	add    %al,0x6(%rcx)
    25c4:	7a 18                	jp     25de <_license+0x249>
    25c6:	00 00                	add    %al,(%rax)
    25c8:	40 23 0c 00          	rex and (%rax,%rax,1),%ecx
    25cc:	00 00                	add    %al,(%rax)
    25ce:	3e 8e 04 84          	ds mov (%rsp,%rax,4),%es
    25d2:	18 00                	sbb    %al,(%rax)
    25d4:	00 3e                	add    %bh,(%rsi)
    25d6:	80 08 8d             	orb    $0x8d,(%rax)
    25d9:	18 00                	sbb    %al,(%rax)
    25db:	00 3e                	add    %bh,(%rsi)
    25dd:	08 96 18 00 00 00    	or     %dl,0x18(%rsi)
    25e3:	00 00                	add    %al,(%rax)
    25e5:	3c e5                	cmp    $0xe5,%al
    25e7:	18 00                	sbb    %al,(%rax)
    25e9:	00 24 28             	add    %ah,(%rax,%rbp,1)
    25ec:	00 00                	add    %al,(%rax)
    25ee:	00 00                	add    %al,(%rax)
    25f0:	73 01                	jae    25f3 <_license+0x25e>
    25f2:	0a 41 00             	or     0x0(%rcx),%al
    25f5:	f7 18                	negl   (%rax)
    25f7:	00 00                	add    %al,(%rax)
    25f9:	40 24 28             	rex and $0x28,%al
    25fc:	00 00                	add    %al,(%rax)
    25fe:	00 3b                	add    %bh,(%rbx)
    2600:	9c                   	pushf
    2601:	01 00                	add    %eax,(%rax)
    2603:	19 00                	sbb    %eax,(%rax)
    2605:	00 3b                	add    %bh,(%rbx)
    2607:	9d                   	popf
    2608:	01 09                	add    %ecx,(%rcx)
    260a:	19 00                	sbb    %eax,(%rax)
    260c:	00 00                	add    %al,(%rax)
    260e:	00 00                	add    %al,(%rax)
    2610:	00 40 25             	add    %al,0x25(%rax)
    2613:	5c                   	pop    %rsp
    2614:	01 00                	add    %eax,(%rax)
    2616:	00 3b                	add    %bh,(%rbx)
    2618:	a2 01 57 0d 00 00 38 	movabs %al,0x16b53800000d5701
    261f:	b5 16 
    2621:	00 00                	add    %al,(%rax)
    2623:	08 00                	or     %al,(%rax)
    2625:	ea                   	(bad)
    2626:	02 0e                	add    (%rsi),%cl
    2628:	39 a3 01 be 16 00    	cmp    %esp,0x16be01(%rbx)
    262e:	00 39                	add    %bh,(%rcx)
    2630:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    2631:	01 c6                	add    %eax,%esi
    2633:	16                   	(bad)
    2634:	00 00                	add    %al,(%rax)
    2636:	3a 02                	cmp    (%rdx),%al
    2638:	91                   	xchg   %eax,%ecx
    2639:	00 d6                	add    %dl,%dh
    263b:	16                   	(bad)
    263c:	00 00                	add    %al,(%rax)
    263e:	3b a7 01 df 16 00    	cmp    0x16df01(%rdi),%esp
    2644:	00 3b                	add    %bh,(%rbx)
    2646:	a9 01 e8 16 00       	test   $0x16e801,%eax
    264b:	00 40 26             	add    %al,0x26(%rax)
    264e:	16                   	(bad)
    264f:	00 00                	add    %al,(%rax)
    2651:	00 3b                	add    %bh,(%rbx)
    2653:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2654:	01 f1                	add    %esi,%ecx
    2656:	16                   	(bad)
    2657:	00 00                	add    %al,(%rax)
    2659:	41 01 f9             	add    %edi,%r9d
    265c:	16                   	(bad)
    265d:	00 00                	add    %al,(%rax)
    265f:	3f                   	(bad)
    2660:	3e 17                	ds (bad)
    2662:	00 00                	add    %al,(%rax)
    2664:	26 16                	es (bad)
    2666:	00 00                	add    %al,(%rax)
    2668:	00 00                	add    %al,(%rax)
    266a:	d5                   	(bad)
    266b:	1c 39                	sbb    $0x39,%al
    266d:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    266e:	01 48 17             	add    %ecx,0x17(%rax)
    2671:	00 00                	add    %al,(%rax)
    2673:	3d 01 57 52 17       	cmp    $0x17525701,%eax
    2678:	00 00                	add    %al,(%rax)
    267a:	00 00                	add    %al,(%rax)
    267c:	40 27                	rex (bad)
    267e:	18 00                	sbb    %al,(%rax)
    2680:	00 00                	add    %al,(%rax)
    2682:	3e 86 04 03          	ds xchg %al,(%rbx,%rax,1)
    2686:	17                   	(bad)
    2687:	00 00                	add    %al,(%rax)
    2689:	40 27                	rex (bad)
    268b:	0c 00                	or     $0x0,%al
    268d:	00 00                	add    %al,(%rax)
    268f:	3b a8 01 0c 17 00    	cmp    0x170c01(%rax),%ebp
    2695:	00 41 06             	add    %al,0x6(%rcx)
    2698:	14 17                	adc    $0x17,%al
    269a:	00 00                	add    %al,(%rax)
    269c:	40 27                	rex (bad)
    269e:	0c 00                	or     $0x0,%al
    26a0:	00 00                	add    %al,(%rax)
    26a2:	3e 86 04 1d 17 00 00 	ds xchg %al,0x3e000017(,%rbx,1)
    26a9:	3e 
    26aa:	80 08 25             	orb    $0x25,(%rax)
    26ad:	17                   	(bad)
    26ae:	00 00                	add    %al,(%rax)
    26b0:	3e 08 2d 17 00 00 00 	ds or  %ch,0x17(%rip)        # 26ce <_license+0x339>
    26b7:	00 00                	add    %al,(%rax)
    26b9:	00 38                	add    %bh,(%rax)
    26bb:	a1 17 00 00 09 00 ee 	movabs 0xc02ee0009000017,%eax
    26c2:	02 0c 
    26c4:	3d 01 5e bd 17       	cmp    $0x17bd5e01,%eax
    26c9:	00 00                	add    %al,(%rax)
    26cb:	3b aa 01 e1 17 00    	cmp    0x17e101(%rdx),%ebp
    26d1:	00 3b                	add    %bh,(%rbx)
    26d3:	ab                   	stos   %eax,%es:(%rdi)
    26d4:	01 ea                	add    %ebp,%edx
    26d6:	17                   	(bad)
    26d7:	00 00                	add    %al,(%rax)
    26d9:	3b ad 01 f3 17 00    	cmp    0x17f301(%rbp),%ebp
    26df:	00 40 28             	add    %al,0x28(%rax)
    26e2:	73 00                	jae    26e4 <_license+0x34f>
    26e4:	00 00                	add    %al,(%rax)
    26e6:	41                   	rex.B
    26e7:	36 fd                	ss std
    26e9:	17                   	(bad)
    26ea:	00 00                	add    %al,(%rax)
    26ec:	3c 5c                	cmp    $0x5c,%al
    26ee:	17                   	(bad)
    26ef:	00 00                	add    %al,(%rax)
    26f1:	29 1e                	sub    %ebx,(%rsi)
    26f3:	00 00                	add    %al,(%rax)
    26f5:	00 00                	add    %al,(%rax)
    26f7:	4f 01 0e             	rex.WRXB add %r9,(%r14)
    26fa:	3d 01 5f 65 17       	cmp    $0x17655f01,%eax
    26ff:	00 00                	add    %al,(%rax)
    2701:	3d 01 5d 6d 17       	cmp    $0x176d5d01,%eax
    2706:	00 00                	add    %al,(%rax)
    2708:	43                   	rex.XB
    2709:	36 75 17             	ss jne 2723 <_license+0x38e>
    270c:	00 00                	add    %al,(%rax)
    270e:	3d 02 31 9f 7e       	cmp    $0x7e9f3102,%eax
    2713:	17                   	(bad)
    2714:	00 00                	add    %al,(%rax)
    2716:	44 86 17             	xchg   %r10b,(%rdi)
    2719:	00 00                	add    %al,(%rax)
    271b:	00 3c a8             	add    %bh,(%rax,%rbp,4)
    271e:	18 00                	sbb    %al,(%rax)
    2720:	00 2a                	add    %ch,(%rdx)
    2722:	43 00 00             	rex.XB add %al,(%r8)
    2725:	00 00                	add    %al,(%rax)
    2727:	50                   	push   %rax
    2728:	01 0a                	add    %ecx,(%rdx)
    272a:	3d 01 5e b1 18       	cmp    $0x18b15e01,%eax
    272f:	00 00                	add    %al,(%rax)
    2731:	3d 02 30 9f c9       	cmp    $0xc99f3002,%eax
    2736:	18 00                	sbb    %al,(%rax)
    2738:	00 3a                	add    %bh,(%rdx)
    273a:	01 5f d2             	add    %ebx,-0x2e(%rdi)
    273d:	18 00                	sbb    %al,(%rax)
    273f:	00 3a                	add    %bh,(%rdx)
    2741:	03 7f 28             	add    0x28(%rdi),%edi
    2744:	9f                   	lahf
    2745:	db 18                	fistpl (%rax)
    2747:	00 00                	add    %al,(%rax)
    2749:	00 00                	add    %al,(%rax)
    274b:	40 2b 0c 00          	rex sub (%rax,%rax,1),%ecx
    274f:	00 00                	add    %al,(%rax)
    2751:	3b ac 01 21 18 00 00 	cmp    0x1821(%rcx,%rax,1),%ebp
    2758:	41 06                	rex.B (bad)
    275a:	2a 18                	sub    (%rax),%bl
    275c:	00 00                	add    %al,(%rax)
    275e:	40 2b 0c 00          	rex sub (%rax,%rax,1),%ecx
    2762:	00 00                	add    %al,(%rax)
    2764:	3e 8a 04 34          	ds mov (%rsp,%rsi,1),%al
    2768:	18 00                	sbb    %al,(%rax)
    276a:	00 3e                	add    %bh,(%rsi)
    276c:	80 08 3d             	orb    $0x3d,(%rax)
    276f:	18 00                	sbb    %al,(%rax)
    2771:	00 3e                	add    %bh,(%rsi)
    2773:	08 46 18             	or     %al,0x18(%rsi)
    2776:	00 00                	add    %al,(%rax)
    2778:	00 00                	add    %al,(%rax)
    277a:	40 2c 15             	rex sub $0x15,%al
    277d:	00 00                	add    %al,(%rax)
    277f:	00 3e                	add    %bh,(%rsi)
    2781:	8e 04 52             	mov    (%rdx,%rdx,2),%es
    2784:	18 00                	sbb    %al,(%rax)
    2786:	00 3b                	add    %bh,(%rbx)
    2788:	af                   	scas   %es:(%rdi),%eax
    2789:	01 5c 18 00          	add    %ebx,0x0(%rax,%rbx,1)
    278d:	00 40 2c             	add    %al,0x2c(%rax)
    2790:	0c 00                	or     $0x0,%al
    2792:	00 00                	add    %al,(%rax)
    2794:	3b ae 01 71 18 00    	cmp    0x187101(%rsi),%ebp
    279a:	00 41 06             	add    %al,0x6(%rcx)
    279d:	7a 18                	jp     27b7 <_license+0x422>
    279f:	00 00                	add    %al,(%rax)
    27a1:	40 2c 0c             	rex sub $0xc,%al
    27a4:	00 00                	add    %al,(%rax)
    27a6:	00 3e                	add    %bh,(%rsi)
    27a8:	8e 04 84             	mov    (%rsp,%rax,4),%es
    27ab:	18 00                	sbb    %al,(%rax)
    27ad:	00 3e                	add    %bh,(%rsi)
    27af:	80 08 8d             	orb    $0x8d,(%rax)
    27b2:	18 00                	sbb    %al,(%rax)
    27b4:	00 3e                	add    %bh,(%rsi)
    27b6:	08 96 18 00 00 00    	or     %dl,0x18(%rsi)
    27bc:	00 00                	add    %al,(%rax)
    27be:	3c e5                	cmp    $0xe5,%al
    27c0:	18 00                	sbb    %al,(%rax)
    27c2:	00 2d 28 00 00 00    	add    %ch,0x28(%rip)        # 27f0 <_license+0x45b>
    27c8:	00 73 01             	add    %dh,0x1(%rbx)
    27cb:	0a 3d 01 5e ee 18    	or     0x18ee5e01(%rip),%bh        # 18ee85d2 <_license+0x18ee623d>
    27d1:	00 00                	add    %al,(%rax)
    27d3:	41 00 f7             	add    %sil,%r15b
    27d6:	18 00                	sbb    %al,(%rax)
    27d8:	00 40 2d             	add    %al,0x2d(%rax)
    27db:	28 00                	sub    %al,(%rax)
    27dd:	00 00                	add    %al,(%rax)
    27df:	3b b0 01 00 19 00    	cmp    0x190001(%rax),%esi
    27e5:	00 3b                	add    %bh,(%rbx)
    27e7:	b1 01                	mov    $0x1,%cl
    27e9:	09 19                	or     %ebx,(%rcx)
    27eb:	00 00                	add    %al,(%rax)
    27ed:	00 00                	add    %al,(%rax)
    27ef:	00 00                	add    %al,(%rax)
    27f1:	40                   	rex
    27f2:	2e 18 00             	cs sbb %al,(%rax)
    27f5:	00 00                	add    %al,(%rax)
    27f7:	3b b3 01 6d 0d 00    	cmp    0xd6d01(%rbx),%esi
    27fd:	00 41 01             	add    %al,0x1(%rcx)
    2800:	76 0d                	jbe    280f <_license+0x47a>
    2802:	00 00                	add    %al,(%rax)
    2804:	3c 3e                	cmp    $0x3e,%al
    2806:	17                   	(bad)
    2807:	00 00                	add    %al,(%rax)
    2809:	2e 18 00             	cs sbb %al,(%rax)
    280c:	00 00                	add    %al,(%rax)
    280e:	00 13                	add    %dl,(%rbx)
    2810:	03 0e                	add    (%rsi),%ecx
    2812:	39 b4 01 48 17 00 00 	cmp    %esi,0x1748(%rcx,%rax,1)
    2819:	3d 04 91 d8 00       	cmp    $0xd89104,%eax
    281e:	9f                   	lahf
    281f:	52                   	push   %rdx
    2820:	17                   	(bad)
    2821:	00 00                	add    %al,(%rax)
    2823:	00 00                	add    %al,(%rax)
    2825:	40 2f                	rex (bad)
    2827:	11 00                	adc    %eax,(%rax)
    2829:	00 00                	add    %al,(%rax)
    282b:	3b cf                	cmp    %edi,%ecx
    282d:	01 81 0d 00 00 41    	add    %eax,0x4100000d(%rcx)
    2833:	01 8a 0d 00 00 3c    	add    %ecx,0x3c00000d(%rdx)
    2839:	3e 17                	ds (bad)
    283b:	00 00                	add    %al,(%rax)
    283d:	2f                   	(bad)
    283e:	11 00                	adc    %eax,(%rax)
    2840:	00 00                	add    %al,(%rax)
    2842:	00 16                	add    %dl,(%rsi)
    2844:	03 10                	add    (%rax),%edx
    2846:	3d 04 91 d8 00       	cmp    $0xd89104,%eax
    284b:	9f                   	lahf
    284c:	52                   	push   %rdx
    284d:	17                   	(bad)
    284e:	00 00                	add    %al,(%rax)
    2850:	00 00                	add    %al,(%rax)
    2852:	40 30 0c 00          	rex xor %cl,(%rax,%rax,1)
    2856:	00 00                	add    %al,(%rax)
    2858:	3b b7 01 95 0d 00    	cmp    0xd9501(%rdi),%esi
    285e:	00 41 06             	add    %al,0x6(%rcx)
    2861:	9e                   	sahf
    2862:	0d 00 00 40 30       	or     $0x30400000,%eax
    2867:	0c 00                	or     $0x0,%al
    2869:	00 00                	add    %al,(%rax)
    286b:	3e 80 04 a8 0d       	ds addb $0xd,(%rax,%rbp,4)
    2870:	00 00                	add    %al,(%rax)
    2872:	3e 80 08 b1          	ds orb $0xb1,(%rax)
    2876:	0d 00 00 3e 08       	or     $0x83e0000,%eax
    287b:	ba 0d 00 00 00       	mov    $0xd,%edx
    2880:	00 40 31             	add    %al,0x31(%rax)
    2883:	0c 00                	or     $0x0,%al
    2885:	00 00                	add    %al,(%rax)
    2887:	3b b9 01 c6 0d 00    	cmp    0xdc601(%rcx),%edi
    288d:	00 00                	add    %al,(%rax)
    288f:	42 0a 3b             	rex.X or (%rbx),%dil
    2892:	bc 01 d1 0d 00       	mov    $0xdd101,%esp
    2897:	00 3b                	add    %bh,(%rbx)
    2899:	bd 01 da 0d 00       	mov    $0xdda01,%ebp
    289e:	00 42 0b             	add    %al,0xb(%rdx)
    28a1:	3b bb 01 e4 0d 00    	cmp    0xde401(%rbx),%edi
    28a7:	00 3b                	add    %bh,(%rbx)
    28a9:	be 01 ed 0d 00       	mov    $0xded01,%esi
    28ae:	00 3b                	add    %bh,(%rbx)
    28b0:	bf 01 f6 0d 00       	mov    $0xdf601,%edi
    28b5:	00 00                	add    %al,(%rax)
    28b7:	00 40 32             	add    %al,0x32(%rax)
    28ba:	2c 00                	sub    $0x0,%al
    28bc:	00 00                	add    %al,(%rax)
    28be:	3e 83 04 02 0e       	ds addl $0xe,(%rdx,%rax,1)
    28c3:	00 00                	add    %al,(%rax)
    28c5:	3b c1                	cmp    %ecx,%eax
    28c7:	01 0b                	add    %ecx,(%rbx)
    28c9:	0e                   	(bad)
    28ca:	00 00                	add    %al,(%rax)
    28cc:	40 32 0c 00          	rex xor (%rax,%rax,1),%cl
    28d0:	00 00                	add    %al,(%rax)
    28d2:	3b c0                	cmp    %eax,%eax
    28d4:	01 15 0e 00 00 41    	add    %edx,0x4100000e(%rip)        # 410028e8 <_license+0x41000553>
    28da:	06                   	(bad)
    28db:	1e                   	(bad)
    28dc:	0e                   	(bad)
    28dd:	00 00                	add    %al,(%rax)
    28df:	40 32 0c 00          	rex xor (%rax,%rax,1),%cl
    28e3:	00 00                	add    %al,(%rax)
    28e5:	3e 83 04 28 0e       	ds addl $0xe,(%rax,%rbp,1)
    28ea:	00 00                	add    %al,(%rax)
    28ec:	3e 80 08 31          	ds orb $0x31,(%rax)
    28f0:	0e                   	(bad)
    28f1:	00 00                	add    %al,(%rax)
    28f3:	3e 08 3a             	ds or  %bh,(%rdx)
    28f6:	0e                   	(bad)
    28f7:	00 00                	add    %al,(%rax)
    28f9:	00 00                	add    %al,(%rax)
    28fb:	00 42 0c             	add    %al,0xc(%rdx)
    28fe:	3b d2                	cmp    %edx,%edx
    2900:	01 51 0e             	add    %edx,0xe(%rcx)
    2903:	00 00                	add    %al,(%rax)
    2905:	3b d4                	cmp    %esp,%edx
    2907:	01 5a 0e             	add    %ebx,0xe(%rdx)
    290a:	00 00                	add    %al,(%rax)
    290c:	3b e3                	cmp    %ebx,%esp
    290e:	01 63 0e             	add    %esp,0xe(%rbx)
    2911:	00 00                	add    %al,(%rax)
    2913:	40 33 0c 00          	rex xor (%rax,%rax,1),%ecx
    2917:	00 00                	add    %al,(%rax)
    2919:	3b d3                	cmp    %ebx,%edx
    291b:	01 6d 0e             	add    %ebp,0xe(%rbp)
    291e:	00 00                	add    %al,(%rax)
    2920:	41 06                	rex.B (bad)
    2922:	76 0e                	jbe    2932 <_license+0x59d>
    2924:	00 00                	add    %al,(%rax)
    2926:	40 33 0c 00          	rex xor (%rax,%rax,1),%ecx
    292a:	00 00                	add    %al,(%rax)
    292c:	3e 00 80 0e 00 00 3e 	ds add %al,0x3e00000e(%rax)
    2933:	01 89 0e 00 00 3e    	add    %ecx,0x3e00000e(%rcx)
    2939:	08 92 0e 00 00 00    	or     %dl,0xe(%rdx)
    293f:	00 38                	add    %bh,(%rax)
    2941:	be 19 00 00 0d       	mov    $0xd000019,%esi
    2946:	00 70 03             	add    %dh,0x3(%rax)
    2949:	26 39 d5             	es cmp %edx,%ebp
    294c:	01 c8                	add    %ecx,%eax
    294e:	19 00                	sbb    %eax,(%rax)
    2950:	00 39                	add    %bh,(%rcx)
    2952:	d6                   	(bad)
    2953:	01 d1                	add    %edx,%ecx
    2955:	19 00                	sbb    %eax,(%rax)
    2957:	00 39                	add    %bh,(%rcx)
    2959:	d7                   	xlat   %ds:(%rbx)
    295a:	01 da                	add    %ebx,%edx
    295c:	19 00                	sbb    %eax,(%rax)
    295e:	00 39                	add    %bh,(%rcx)
    2960:	d8 01                	fadds  (%rcx)
    2962:	e3 19                	jrcxz  297d <_license+0x5e8>
    2964:	00 00                	add    %al,(%rax)
    2966:	3b d9                	cmp    %ecx,%ebx
    2968:	01 ec                	add    %ebp,%esp
    296a:	19 00                	sbb    %eax,(%rax)
    296c:	00 3b                	add    %bh,(%rbx)
    296e:	da 01                	fiaddl (%rcx)
    2970:	f6 19                	negb   (%rcx)
    2972:	00 00                	add    %al,(%rax)
    2974:	3b db                	cmp    %ebx,%ebx
    2976:	01 00                	add    %eax,(%rax)
    2978:	1a 00                	sbb    (%rax),%al
    297a:	00 3b                	add    %bh,(%rbx)
    297c:	dc 01                	faddl  (%rcx)
    297e:	0a 1a                	or     (%rdx),%bl
    2980:	00 00                	add    %al,(%rax)
    2982:	3b dd                	cmp    %ebp,%ebx
    2984:	01 14 1a             	add    %edx,(%rdx,%rbx,1)
    2987:	00 00                	add    %al,(%rax)
    2989:	42 0e                	rex.X (bad)
    298b:	3b b7 02 31 1a 00    	cmp    0x1a3102(%rdi),%esi
    2991:	00 00                	add    %al,(%rax)
    2993:	00 3c 82             	add    %bh,(%rdx,%rax,4)
    2996:	1a 00                	sbb    (%rax),%al
    2998:	00 34 3d 00 00 00 00 	add    %dh,0x0(,%rdi,1)
    299f:	a2 03 09 3d 02 31 9f 	movabs %al,0x1a919f31023d0903
    29a6:	91 1a 
    29a8:	00 00                	add    %al,(%rax)
    29aa:	3d 02 30 9f 9b       	cmp    $0x9b9f3002,%eax
    29af:	1a 00                	sbb    (%rax),%al
    29b1:	00 3b                	add    %bh,(%rbx)
    29b3:	e5 01                	in     $0x1,%eax
    29b5:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    29b6:	1a 00                	sbb    (%rax),%al
    29b8:	00 40 34             	add    %al,0x34(%rax)
    29bb:	2f                   	(bad)
    29bc:	00 00                	add    %al,(%rax)
    29be:	00 3b                	add    %bh,(%rbx)
    29c0:	e4 01                	in     $0x1,%al
    29c2:	b0 1a                	mov    $0x1a,%al
    29c4:	00 00                	add    %al,(%rax)
    29c6:	41 06                	rex.B (bad)
    29c8:	b9 1a 00 00 40       	mov    $0x4000001a,%ecx
    29cd:	34 2f                	xor    $0x2f,%al
    29cf:	00 00                	add    %al,(%rax)
    29d1:	00 3e                	add    %bh,(%rsi)
    29d3:	80 04 c3 1a          	addb   $0x1a,(%rbx,%rax,8)
    29d7:	00 00                	add    %al,(%rax)
    29d9:	3e 08 cc             	ds or  %cl,%ah
    29dc:	1a 00                	sbb    (%rax),%al
    29de:	00 00                	add    %al,(%rax)
    29e0:	00 00                	add    %al,(%rax)
    29e2:	42 0f 3b             	rex.X (bad)
    29e5:	b9 02 9e 0e 00       	mov    $0xe9e02,%ecx
    29ea:	00 3c e1             	add    %bh,(%rcx,%riz,8)
    29ed:	1a 00                	sbb    (%rax),%al
    29ef:	00 35 29 00 00 00    	add    %dh,0x29(%rip)        # 2a1e <_license+0x689>
    29f5:	00 74 03 09          	add    %dh,0x9(%rbx,%rax,1)
    29f9:	3d 01 5e e7 1a       	cmp    $0x1ae75e01,%eax
    29fe:	00 00                	add    %al,(%rax)
    2a00:	39 b8 02 f0 1a 00    	cmp    %edi,0x1af002(%rax)
    2a06:	00 00                	add    %al,(%rax)
    2a08:	40                   	rex
    2a09:	36 06                	ss (bad)
    2a0b:	00 00                	add    %al,(%rax)
    2a0d:	00 3b                	add    %bh,(%rbx)
    2a0f:	ba 02 b1 0e 00       	mov    $0xeb102,%edx
    2a14:	00 41 02             	add    %al,0x2(%rcx)
    2a17:	ba 0e 00 00 40       	mov    $0x4000000e,%edx
    2a1c:	36 06                	ss (bad)
    2a1e:	00 00                	add    %al,(%rax)
    2a20:	00 3a                	add    %bh,(%rdx)
    2a22:	01 52 c4             	add    %edx,-0x3c(%rdx)
    2a25:	0e                   	(bad)
    2a26:	00 00                	add    %al,(%rax)
    2a28:	3e fe                	ds (bad)
    2a2a:	ff                   	(bad)
    2a2b:	ff 07                	incl   (%rdi)
    2a2d:	cd 0e                	int    $0xe
    2a2f:	00 00                	add    %al,(%rax)
    2a31:	3e 08 d6             	ds or  %dl,%dh
    2a34:	0e                   	(bad)
    2a35:	00 00                	add    %al,(%rax)
    2a37:	00 00                	add    %al,(%rax)
    2a39:	42 10 3b             	rex.X adc %dil,(%rbx)
    2a3c:	bf 02 e2 0e 00       	mov    $0xee202,%edi
    2a41:	00 40 37             	add    %al,0x37(%rax)
    2a44:	05 00 00 00 3b       	add    $0x3b000000,%eax
    2a49:	bb 02 ec 0e 00       	mov    $0xeec02,%ebx
    2a4e:	00 41 02             	add    %al,0x2(%rcx)
    2a51:	f5                   	cmc
    2a52:	0e                   	(bad)
    2a53:	00 00                	add    %al,(%rax)
    2a55:	40 37                	rex (bad)
    2a57:	05 00 00 00 3a       	add    $0x3a000000,%eax
    2a5c:	01 50 ff             	add    %edx,-0x1(%rax)
    2a5f:	0e                   	(bad)
    2a60:	00 00                	add    %al,(%rax)
    2a62:	3e 80 20 08          	ds andb $0x8,(%rax)
    2a66:	0f 00 00             	sldt   (%rax)
    2a69:	3e 18 11             	ds sbb %dl,(%rcx)
    2a6c:	0f 00 00             	sldt   (%rax)
    2a6f:	00 00                	add    %al,(%rax)
    2a71:	38 fa                	cmp    %bh,%dl
    2a73:	1a 00                	sbb    (%rax),%al
    2a75:	00 11                	add    %dl,(%rcx)
    2a77:	00 8a 03 17 39 bc    	add    %cl,-0x43c6e8fd(%rdx)
    2a7d:	02 04 1b             	add    (%rbx,%rbx,1),%al
    2a80:	00 00                	add    %al,(%rax)
    2a82:	39 bd 02 0d 1b 00    	cmp    %edi,0x1b0d02(%rbp)
    2a88:	00 3a                	add    %bh,(%rdx)
    2a8a:	02 91 00 16 1b 00    	add    0x1b1600(%rcx),%dl
    2a90:	00 3b                	add    %bh,(%rbx)
    2a92:	be 02 20 1b 00       	mov    $0x1b2002,%esi
    2a97:	00 3c 3e             	add    %bh,(%rsi,%rdi,1)
    2a9a:	17                   	(bad)
    2a9b:	00 00                	add    %al,(%rax)
    2a9d:	38 0b                	cmp    %cl,(%rbx)
    2a9f:	00 00                	add    %al,(%rax)
    2aa1:	00 00                	add    %al,(%rax)
    2aa3:	6a 02                	push   $0x2
    2aa5:	22 3d 03 91 c8 00    	and    0xc89103(%rip),%bh        # c8bbae <_license+0xc89819>
    2aab:	48 17                	rex.W (bad)
    2aad:	00 00                	add    %al,(%rax)
    2aaf:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    2ab4:	52                   	push   %rdx
    2ab5:	17                   	(bad)
    2ab6:	00 00                	add    %al,(%rax)
    2ab8:	00 38                	add    %bh,(%rax)
    2aba:	53                   	push   %rbx
    2abb:	1c 00                	sbb    $0x0,%al
    2abd:	00 12                	add    %dl,(%rdx)
    2abf:	00 74 02 07          	add    %dh,0x7(%rdx,%rax,1)
    2ac3:	3b 87 03 65 1c 00    	cmp    0x1c6503(%rdi),%eax
    2ac9:	00 3b                	add    %bh,(%rbx)
    2acb:	89 03                	mov    %eax,(%rbx)
    2acd:	6e                   	outsb  %ds:(%rsi),(%dx)
    2ace:	1c 00                	sbb    $0x0,%al
    2ad0:	00 40 39             	add    %al,0x39(%rax)
    2ad3:	0c 00                	or     $0x0,%al
    2ad5:	00 00                	add    %al,(%rax)
    2ad7:	3b 88 03 78 1c 00    	cmp    0x1c7803(%rax),%ecx
    2add:	00 41 06             	add    %al,0x6(%rcx)
    2ae0:	80 1c 00 00          	sbbb   $0x0,(%rax,%rax,1)
    2ae4:	40 39 0c 00          	rex cmp %ecx,(%rax,%rax,1)
    2ae8:	00 00                	add    %al,(%rax)
    2aea:	3e 82                	ds (bad)
    2aec:	04 89                	add    $0x89,%al
    2aee:	1c 00                	sbb    $0x0,%al
    2af0:	00 3e                	add    %bh,(%rsi)
    2af2:	80 08 91             	orb    $0x91,(%rax)
    2af5:	1c 00                	sbb    $0x0,%al
    2af7:	00 3e                	add    %bh,(%rsi)
    2af9:	08 99 1c 00 00 00    	or     %bl,0x1c(%rcx)
    2aff:	00 00                	add    %al,(%rax)
    2b01:	3c 3d                	cmp    $0x3d,%al
    2b03:	1e                   	(bad)
    2b04:	00 00                	add    %al,(%rax)
    2b06:	3a 10                	cmp    (%rax),%dl
    2b08:	00 00                	add    %al,(%rax)
    2b0a:	00 00                	add    %al,(%rax)
    2b0c:	79 02                	jns    2b10 <_license+0x77b>
    2b0e:	03 3d 03 91 c8 00    	add    0xc89103(%rip),%edi        # c8bc17 <_license+0xc89882>
    2b14:	47 1e                	rex.RXB (bad)
    2b16:	00 00                	add    %al,(%rax)
    2b18:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    2b1d:	51                   	push   %rcx
    2b1e:	1e                   	(bad)
    2b1f:	00 00                	add    %al,(%rax)
    2b21:	3d 01 57 5a 1e       	cmp    $0x1e5a5701,%eax
    2b26:	00 00                	add    %al,(%rax)
    2b28:	45 00 63 1e          	add    %r12b,0x1e(%r11)
    2b2c:	00 00                	add    %al,(%rax)
    2b2e:	00 00                	add    %al,(%rax)
    2b30:	3c 82                	cmp    $0x82,%al
    2b32:	1a 00                	sbb    (%rax),%al
    2b34:	00 3b                	add    %bh,(%rbx)
    2b36:	31 00                	xor    %eax,(%rax)
    2b38:	00 00                	add    %al,(%rax)
    2b3a:	00 8f 03 0f 3d 02    	add    %cl,0x23d0f03(%rdi)
    2b40:	30 9f 91 1a 00 00    	xor    %bl,0x1a91(%rdi)
    2b46:	3d 02 31 9f 9b       	cmp    $0x9b9f3102,%eax
    2b4b:	1a 00                	sbb    (%rax),%al
    2b4d:	00 3b                	add    %bh,(%rbx)
    2b4f:	8b 03                	mov    (%rbx),%eax
    2b51:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    2b52:	1a 00                	sbb    (%rax),%al
    2b54:	00 40 3b             	add    %al,0x3b(%rax)
    2b57:	26 00 00             	es add %al,(%rax)
    2b5a:	00 3b                	add    %bh,(%rbx)
    2b5c:	8a 03                	mov    (%rbx),%al
    2b5e:	b0 1a                	mov    $0x1a,%al
    2b60:	00 00                	add    %al,(%rax)
    2b62:	41 06                	rex.B (bad)
    2b64:	b9 1a 00 00 40       	mov    $0x4000001a,%ecx
    2b69:	3b 26                	cmp    (%rsi),%esp
    2b6b:	00 00                	add    %al,(%rax)
    2b6d:	00 3e                	add    %bh,(%rsi)
    2b6f:	80 04 c3 1a          	addb   $0x1a,(%rbx,%rax,8)
    2b73:	00 00                	add    %al,(%rax)
    2b75:	3e 08 cc             	ds or  %cl,%ah
    2b78:	1a 00                	sbb    (%rax),%al
    2b7a:	00 00                	add    %al,(%rax)
    2b7c:	00 00                	add    %al,(%rax)
    2b7e:	00 00                	add    %al,(%rax)
    2b80:	00 40 3c             	add    %al,0x3c(%rax)
    2b83:	37                   	(bad)
    2b84:	00 00                	add    %al,(%rax)
    2b86:	00 3e                	add    %bh,(%rsi)
    2b88:	8b 04 20             	mov    (%rax,%riz,1),%eax
    2b8b:	0f 00 00             	sldt   (%rax)
    2b8e:	3b df                	cmp    %edi,%ebx
    2b90:	01 29                	add    %ebp,(%rcx)
    2b92:	0f 00 00             	sldt   (%rax)
    2b95:	40 3c 0c             	rex cmp $0xc,%al
    2b98:	00 00                	add    %al,(%rax)
    2b9a:	00 3b                	add    %bh,(%rbx)
    2b9c:	de 01                	fiadds (%rcx)
    2b9e:	33 0f                	xor    (%rdi),%ecx
    2ba0:	00 00                	add    %al,(%rax)
    2ba2:	41 06                	rex.B (bad)
    2ba4:	3c 0f                	cmp    $0xf,%al
    2ba6:	00 00                	add    %al,(%rax)
    2ba8:	40 3c 0c             	rex cmp $0xc,%al
    2bab:	00 00                	add    %al,(%rax)
    2bad:	00 3e                	add    %bh,(%rsi)
    2baf:	8b 04 46             	mov    (%rsi,%rax,2),%eax
    2bb2:	0f 00 00             	sldt   (%rax)
    2bb5:	3e 80 08 4f          	ds orb $0x4f,(%rax)
    2bb9:	0f 00 00             	sldt   (%rax)
    2bbc:	3e 08 58 0f          	ds or  %bl,0xf(%rax)
    2bc0:	00 00                	add    %al,(%rax)
    2bc2:	00 00                	add    %al,(%rax)
    2bc4:	3c 3d                	cmp    $0x3d,%al
    2bc6:	1a 00                	sbb    (%rax),%al
    2bc8:	00 3d 05 00 00 00    	add    %bh,0x5(%rip)        # 2bd3 <_license+0x83e>
    2bce:	00 66 03             	add    %ah,0x3(%rsi)
    2bd1:	0b 3d 01 5f 47 1a    	or     0x1a475f01(%rip),%edi        # 1a478ad8 <_license+0x1a476743>
    2bd7:	00 00                	add    %al,(%rax)
    2bd9:	3d 01 5d 50 1a       	cmp    $0x1a505d01,%eax
    2bde:	00 00                	add    %al,(%rax)
    2be0:	3d 02 30 9f 59       	cmp    $0x599f3002,%eax
    2be5:	1a 00                	sbb    (%rax),%al
    2be7:	00 3e                	add    %bh,(%rsi)
    2be9:	0e                   	(bad)
    2bea:	62                   	(bad)
    2beb:	1a 00                	sbb    (%rax),%al
    2bed:	00 40 3d             	add    %al,0x3d(%rax)
    2bf0:	05 00 00 00 3a       	add    $0x3a000000,%eax
    2bf5:	03 7f 22             	add    0x22(%rdi),%edi
    2bf8:	9f                   	lahf
    2bf9:	77 1a                	ja     2c15 <_license+0x880>
    2bfb:	00 00                	add    %al,(%rax)
    2bfd:	00 00                	add    %al,(%rax)
    2bff:	00 3c 35 1b 00 00 3e 	add    %bh,0x3e00001b(,%rsi,1)
    2c06:	6d                   	insl   (%dx),%es:(%rdi)
    2c07:	00 00                	add    %al,(%rax)
    2c09:	00 00                	add    %al,(%rax)
    2c0b:	d8 03                	fadds  (%rbx)
    2c0d:	07                   	(bad)
    2c0e:	39 c0                	cmp    %eax,%eax
    2c10:	02 43 1b             	add    0x1b(%rbx),%al
    2c13:	00 00                	add    %al,(%rax)
    2c15:	39 c1                	cmp    %eax,%ecx
    2c17:	02 4b 1b             	add    0x1b(%rbx),%cl
    2c1a:	00 00                	add    %al,(%rax)
    2c1c:	39 c2                	cmp    %eax,%edx
    2c1e:	02 53 1b             	add    0x1b(%rbx),%dl
    2c21:	00 00                	add    %al,(%rax)
    2c23:	3b c3                	cmp    %ebx,%eax
    2c25:	02 5c 1b 00          	add    0x0(%rbx,%rbx,1),%bl
    2c29:	00 3b                	add    %bh,(%rbx)
    2c2b:	c4 02 65 1b          	(bad)
    2c2f:	00 00                	add    %al,(%rax)
    2c31:	3b c5                	cmp    %ebp,%eax
    2c33:	02 6e 1b             	add    0x1b(%rsi),%ch
    2c36:	00 00                	add    %al,(%rax)
    2c38:	3f                   	(bad)
    2c39:	3e 17                	ds (bad)
    2c3b:	00 00                	add    %al,(%rax)
    2c3d:	3e 0b 00             	ds or  (%rax),%eax
    2c40:	00 00                	add    %al,(%rax)
    2c42:	00 b8 0d 3d 03 91    	add    %bh,-0x6efcc2f3(%rax)
    2c48:	c8 00 48 17          	enter  $0x4800,$0x17
    2c4c:	00 00                	add    %al,(%rax)
    2c4e:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    2c53:	52                   	push   %rdx
    2c54:	17                   	(bad)
    2c55:	00 00                	add    %al,(%rax)
    2c57:	00 40 3f             	add    %al,0x3f(%rax)
    2c5a:	16                   	(bad)
    2c5b:	00 00                	add    %al,(%rax)
    2c5d:	00 3e                	add    %bh,(%rsi)
    2c5f:	00 77 1b             	add    %dh,0x1b(%rdi)
    2c62:	00 00                	add    %al,(%rax)
    2c64:	41 02 7f 1b          	add    0x1b(%r15),%dil
    2c68:	00 00                	add    %al,(%rax)
    2c6a:	40 3f                	rex (bad)
    2c6c:	16                   	(bad)
    2c6d:	00 00                	add    %al,(%rax)
    2c6f:	00 3b                	add    %bh,(%rbx)
    2c71:	c6 02 88             	movb   $0x88,(%rdx)
    2c74:	1b 00                	sbb    (%rax),%eax
    2c76:	00 3e                	add    %bh,(%rsi)
    2c78:	80 20 90             	andb   $0x90,(%rax)
    2c7b:	1b 00                	sbb    (%rax),%eax
    2c7d:	00 3e                	add    %bh,(%rsi)
    2c7f:	18 98 1b 00 00 00    	sbb    %bl,0x1b(%rax)
    2c85:	00 00                	add    %al,(%rax)
    2c87:	3c a8                	cmp    $0xa8,%al
    2c89:	1b 00                	sbb    (%rax),%eax
    2c8b:	00 40 bf             	add    %al,-0x41(%rax)
    2c8e:	00 00                	add    %al,(%rax)
    2c90:	00 00                	add    %al,(%rax)
    2c92:	e5 03                	in     $0x3,%eax
    2c94:	05 3d 03 91 10       	add    $0x1091033d,%eax
    2c99:	9f                   	lahf
    2c9a:	bb 1b 00 00 3d       	mov    $0x3d00001b,%ebx
    2c9f:	03 91 c0 00 c4 1b    	add    0x1bc400c0(%rcx),%edx
    2ca5:	00 00                	add    %al,(%rax)
    2ca7:	3d 04 91 d8 00       	cmp    $0xd89104,%eax
    2cac:	9f                   	lahf
    2cad:	cd 1b                	int    $0x1b
    2caf:	00 00                	add    %al,(%rax)
    2cb1:	3c 53                	cmp    $0x53,%al
    2cb3:	1c 00                	sbb    $0x0,%al
    2cb5:	00 41 4c             	add    %al,0x4c(%rcx)
    2cb8:	00 00                	add    %al,(%rax)
    2cba:	00 00                	add    %al,(%rax)
    2cbc:	93                   	xchg   %eax,%ebx
    2cbd:	02 32                	add    (%rdx),%dh
    2cbf:	3e 82                	ds (bad)
    2cc1:	04 65                	add    $0x65,%al
    2cc3:	1c 00                	sbb    $0x0,%al
    2cc5:	00 3b                	add    %bh,(%rbx)
    2cc7:	c8 02 6e 1c          	enter  $0x6e02,$0x1c
    2ccb:	00 00                	add    %al,(%rax)
    2ccd:	40                   	rex
    2cce:	41 0c 00             	rex.B or $0x0,%al
    2cd1:	00 00                	add    %al,(%rax)
    2cd3:	3b c7                	cmp    %edi,%eax
    2cd5:	02 78 1c             	add    0x1c(%rax),%bh
    2cd8:	00 00                	add    %al,(%rax)
    2cda:	41 06                	rex.B (bad)
    2cdc:	80 1c 00 00          	sbbb   $0x0,(%rax,%rax,1)
    2ce0:	40                   	rex
    2ce1:	41 0c 00             	rex.B or $0x0,%al
    2ce4:	00 00                	add    %al,(%rax)
    2ce6:	3e 82                	ds (bad)
    2ce8:	04 89                	add    $0x89,%al
    2cea:	1c 00                	sbb    $0x0,%al
    2cec:	00 3e                	add    %bh,(%rsi)
    2cee:	80 08 91             	orb    $0x91,(%rax)
    2cf1:	1c 00                	sbb    $0x0,%al
    2cf3:	00 3e                	add    %bh,(%rsi)
    2cf5:	08 99 1c 00 00 00    	or     %bl,0x1c(%rcx)
    2cfb:	00 00                	add    %al,(%rax)
    2cfd:	40                   	rex
    2cfe:	42 54                	rex.X push %rsp
    2d00:	00 00                	add    %al,(%rax)
    2d02:	00 3b                	add    %bh,(%rbx)
    2d04:	cb                   	lret
    2d05:	02 e1                	add    %cl,%ah
    2d07:	1b 00                	sbb    (%rax),%eax
    2d09:	00 40 42             	add    %al,0x42(%rax)
    2d0c:	15 00 00 00 3b       	adc    $0x3b000000,%eax
    2d11:	c9                   	leave
    2d12:	02 ec                	add    %ah,%ch
    2d14:	1b 00                	sbb    (%rax),%eax
    2d16:	00 41 0d             	add    %al,0xd(%rcx)
    2d19:	f5                   	cmc
    2d1a:	1b 00                	sbb    (%rax),%eax
    2d1c:	00 3c 3e             	add    %bh,(%rsi,%rdi,1)
    2d1f:	17                   	(bad)
    2d20:	00 00                	add    %al,(%rax)
    2d22:	42 15 00 00 00 00    	rex.X adc $0x0,%eax
    2d28:	95                   	xchg   %eax,%ebp
    2d29:	02 1c 39             	add    (%rcx,%rdi,1),%bl
    2d2c:	ca 02 48             	lret   $0x4802
    2d2f:	17                   	(bad)
    2d30:	00 00                	add    %al,(%rax)
    2d32:	3d 04 91 d8 00       	cmp    $0xd89104,%eax
    2d37:	9f                   	lahf
    2d38:	52                   	push   %rdx
    2d39:	17                   	(bad)
    2d3a:	00 00                	add    %al,(%rax)
    2d3c:	00 00                	add    %al,(%rax)
    2d3e:	40                   	rex
    2d3f:	43 3a 00             	rex.XB cmp (%r8),%al
    2d42:	00 00                	add    %al,(%rax)
    2d44:	3b cc                	cmp    %esp,%ecx
    2d46:	02 00                	add    (%rax),%al
    2d48:	1c 00                	sbb    $0x0,%al
    2d4a:	00 3c 3e             	add    %bh,(%rsi,%rdi,1)
    2d4d:	17                   	(bad)
    2d4e:	00 00                	add    %al,(%rax)
    2d50:	44 09 00             	or     %r8d,(%rax)
    2d53:	00 00                	add    %al,(%rax)
    2d55:	00 97 02 19 3d 01    	add    %dl,0x13d1902(%rdi)
    2d5b:	50                   	push   %rax
    2d5c:	48 17                	rex.W (bad)
    2d5e:	00 00                	add    %al,(%rax)
    2d60:	3d 01 54 52 17       	cmp    $0x17525401,%eax
    2d65:	00 00                	add    %al,(%rax)
    2d67:	00 40 45             	add    %al,0x45(%rax)
    2d6a:	1d 00 00 00 3e       	sbb    $0x3e000000,%eax
    2d6f:	8f 04 0b             	pop    (%rbx,%rcx,1)
    2d72:	1c 00                	sbb    $0x0,%al
    2d74:	00 3b                	add    %bh,(%rbx)
    2d76:	ce                   	(bad)
    2d77:	02 14 1c             	add    (%rsp,%rbx,1),%dl
    2d7a:	00 00                	add    %al,(%rax)
    2d7c:	40                   	rex
    2d7d:	45 0c 00             	rex.RB or $0x0,%al
    2d80:	00 00                	add    %al,(%rax)
    2d82:	3b cd                	cmp    %ebp,%ecx
    2d84:	02 1f                	add    (%rdi),%bl
    2d86:	1c 00                	sbb    $0x0,%al
    2d88:	00 41 06             	add    %al,0x6(%rcx)
    2d8b:	28 1c 00             	sub    %bl,(%rax,%rax,1)
    2d8e:	00 40 45             	add    %al,0x45(%rax)
    2d91:	0c 00                	or     $0x0,%al
    2d93:	00 00                	add    %al,(%rax)
    2d95:	3e 8f 04 32          	ds pop (%rdx,%rsi,1)
    2d99:	1c 00                	sbb    $0x0,%al
    2d9b:	00 3e                	add    %bh,(%rsi)
    2d9d:	80 08 3b             	orb    $0x3b,(%rax)
    2da0:	1c 00                	sbb    $0x0,%al
    2da2:	00 3e                	add    %bh,(%rsi)
    2da4:	08 44 1c 00          	or     %al,0x0(%rsp,%rbx,1)
    2da8:	00 00                	add    %al,(%rax)
    2daa:	00 00                	add    %al,(%rax)
    2dac:	00 00                	add    %al,(%rax)
    2dae:	00 40 46             	add    %al,0x46(%rax)
    2db1:	23 00                	and    (%rax),%eax
    2db3:	00 00                	add    %al,(%rax)
    2db5:	3e 81 04 66 0f 00 00 	ds addl $0x3b00000f,(%rsi,%riz,2)
    2dbc:	3b 
    2dbd:	e0 02                	loopne 2dc1 <_license+0xa2c>
    2dbf:	6f                   	outsl  %ds:(%rsi),(%dx)
    2dc0:	0f 00 00             	sldt   (%rax)
    2dc3:	40                   	rex
    2dc4:	46 0c 00             	rex.RX or $0x0,%al
    2dc7:	00 00                	add    %al,(%rax)
    2dc9:	3b df                	cmp    %edi,%ebx
    2dcb:	02 79 0f             	add    0xf(%rcx),%bh
    2dce:	00 00                	add    %al,(%rax)
    2dd0:	41 06                	rex.B (bad)
    2dd2:	82                   	(bad)
    2dd3:	0f 00 00             	sldt   (%rax)
    2dd6:	40                   	rex
    2dd7:	46 0c 00             	rex.RX or $0x0,%al
    2dda:	00 00                	add    %al,(%rax)
    2ddc:	3e 81 04 8c 0f 00 00 	ds addl $0x3e00000f,(%rsp,%rcx,4)
    2de3:	3e 
    2de4:	80 08 95             	orb    $0x95,(%rax)
    2de7:	0f 00 00             	sldt   (%rax)
    2dea:	3e 08 9e 0f 00 00 00 	ds or  %bl,0xf(%rsi)
    2df1:	00 00                	add    %al,(%rax)
    2df3:	38 4f 1d             	cmp    %cl,0x1d(%rdi)
    2df6:	00 00                	add    %al,(%rax)
    2df8:	13 00                	adc    (%rax),%eax
    2dfa:	fb                   	sti
    2dfb:	03 0c 39             	add    (%rcx,%rdi,1),%ecx
    2dfe:	e1 02                	loope  2e02 <_license+0xa6d>
    2e00:	61                   	(bad)
    2e01:	1d 00 00 39 e2       	sbb    $0xe2390000,%eax
    2e06:	02 69 1d             	add    0x1d(%rcx),%ch
    2e09:	00 00                	add    %al,(%rax)
    2e0b:	39 e3                	cmp    %esp,%ebx
    2e0d:	02 71 1d             	add    0x1d(%rcx),%dh
    2e10:	00 00                	add    %al,(%rax)
    2e12:	39 e4                	cmp    %esp,%esp
    2e14:	02 79 1d             	add    0x1d(%rcx),%bh
    2e17:	00 00                	add    %al,(%rax)
    2e19:	3a 02                	cmp    (%rdx),%al
    2e1b:	91                   	xchg   %eax,%ecx
    2e1c:	00 81 1d 00 00 3b    	add    %al,0x3b00001d(%rcx)
    2e22:	e5 02                	in     $0x2,%eax
    2e24:	8a 1d 00 00 3b e6    	mov    -0x19c50000(%rip),%bl        # ffffffffe63b2e2a <server_id_map+0x36ffcdcc9e2a>
    2e2a:	02 93 1d 00 00 3b    	add    0x3b00001d(%rbx),%dl
    2e30:	e7 02                	out    %eax,$0x2
    2e32:	9c                   	pushf
    2e33:	1d 00 00 3b ed       	sbb    $0xed3b0000,%eax
    2e38:	02 a5 1d 00 00 3b    	add    0x3b00001d(%rbp),%ah
    2e3e:	ee                   	out    %al,(%dx)
    2e3f:	02 ae 1d 00 00 3f    	add    0x3f00001d(%rsi),%ch
    2e45:	53                   	push   %rbx
    2e46:	1c 00                	sbb    $0x0,%al
    2e48:	00 47 4e             	add    %al,0x4e(%rdi)
    2e4b:	00 00                	add    %al,(%rax)
    2e4d:	00 00                	add    %al,(%rax)
    2e4f:	66 11 3e             	adc    %di,(%rsi)
    2e52:	82                   	(bad)
    2e53:	04 65                	add    $0x65,%al
    2e55:	1c 00                	sbb    $0x0,%al
    2e57:	00 3b                	add    %bh,(%rbx)
    2e59:	e9 02 6e 1c 00       	jmp    1c9c60 <_license+0x1c78cb>
    2e5e:	00 40 47             	add    %al,0x47(%rax)
    2e61:	0e                   	(bad)
    2e62:	00 00                	add    %al,(%rax)
    2e64:	00 3b                	add    %bh,(%rbx)
    2e66:	e8 02 78 1c 00       	call   1ca66d <_license+0x1c82d8>
    2e6b:	00 41 06             	add    %al,0x6(%rcx)
    2e6e:	80 1c 00 00          	sbbb   $0x0,(%rax,%rax,1)
    2e72:	40                   	rex
    2e73:	47 0e                	rex.RXB (bad)
    2e75:	00 00                	add    %al,(%rax)
    2e77:	00 3e                	add    %bh,(%rsi)
    2e79:	82                   	(bad)
    2e7a:	04 89                	add    $0x89,%al
    2e7c:	1c 00                	sbb    $0x0,%al
    2e7e:	00 3e                	add    %bh,(%rsi)
    2e80:	80 08 91             	orb    $0x91,(%rax)
    2e83:	1c 00                	sbb    $0x0,%al
    2e85:	00 3e                	add    %bh,(%rsi)
    2e87:	08 99 1c 00 00 00    	or     %bl,0x1c(%rcx)
    2e8d:	00 00                	add    %al,(%rax)
    2e8f:	42 14 3b             	rex.X adc $0x3b,%al
    2e92:	ea                   	(bad)
    2e93:	02 bf 1d 00 00 46    	add    0x4600001d(%rdi),%bh
    2e99:	22 1e                	and    (%rsi),%bl
    2e9b:	00 00                	add    %al,(%rax)
    2e9d:	15 00 8f 0c 39       	adc    $0x390c8f00,%eax
    2ea2:	eb 02                	jmp    2ea6 <_license+0xb11>
    2ea4:	2b 1e                	sub    (%rsi),%ebx
    2ea6:	00 00                	add    %al,(%rax)
    2ea8:	39 ec                	cmp    %ebp,%esp
    2eaa:	02 33                	add    (%rbx),%dh
    2eac:	1e                   	(bad)
    2ead:	00 00                	add    %al,(%rax)
    2eaf:	00 40 48             	add    %al,0x48(%rax)
    2eb2:	05 00 00 00 3b       	add    $0x3b000000,%eax
    2eb7:	ef                   	out    %eax,(%dx)
    2eb8:	02 c9                	add    %cl,%cl
    2eba:	1d 00 00 41 02       	sbb    $0x2410000,%eax
    2ebf:	d1 1d 00 00 40 48    	rcrl   0x48400000(%rip)        # 48402ec5 <_license+0x48400b30>
    2ec5:	05 00 00 00 3a       	add    $0x3a000000,%eax
    2eca:	01 50 da             	add    %edx,-0x26(%rax)
    2ecd:	1d 00 00 3e 80       	sbb    $0x803e0000,%eax
    2ed2:	84 80 10 e2 1d 00    	test   %al,0x1de210(%rax)
    2ed8:	00 3e                	add    %bh,(%rsi)
    2eda:	08 ea                	or     %ch,%dl
    2edc:	1d 00 00 00 00       	sbb    $0x0,%eax
    2ee1:	3f                   	(bad)
    2ee2:	4f 1f                	rex.WRXB (bad)
    2ee4:	00 00                	add    %al,(%rax)
    2ee6:	49 11 00             	adc    %rax,(%r8)
    2ee9:	00 00                	add    %al,(%rax)
    2eeb:	00 9a 07 3e 89 04    	add    %bl,0x4893e07(%rdx)
    2ef1:	54                   	push   %rsp
    2ef2:	1f                   	(bad)
    2ef3:	00 00                	add    %al,(%rax)
    2ef5:	3b f5                	cmp    %ebp,%esi
    2ef7:	02 5d 1f             	add    0x1f(%rbp),%bl
    2efa:	00 00                	add    %al,(%rax)
    2efc:	40                   	rex
    2efd:	49 0c 00             	rex.WB or $0x0,%al
    2f00:	00 00                	add    %al,(%rax)
    2f02:	3b f4                	cmp    %esp,%esi
    2f04:	02 67 1f             	add    0x1f(%rdi),%ah
    2f07:	00 00                	add    %al,(%rax)
    2f09:	41 06                	rex.B (bad)
    2f0b:	6f                   	outsl  %ds:(%rsi),(%dx)
    2f0c:	1f                   	(bad)
    2f0d:	00 00                	add    %al,(%rax)
    2f0f:	40                   	rex
    2f10:	49 0c 00             	rex.WB or $0x0,%al
    2f13:	00 00                	add    %al,(%rax)
    2f15:	3e 89 04 78          	ds mov %eax,(%rax,%rdi,2)
    2f19:	1f                   	(bad)
    2f1a:	00 00                	add    %al,(%rax)
    2f1c:	3e 80 08 80          	ds orb $0x80,(%rax)
    2f20:	1f                   	(bad)
    2f21:	00 00                	add    %al,(%rax)
    2f23:	3e 08 88 1f 00 00 00 	ds or  %cl,0x1f(%rax)
    2f2a:	00 00                	add    %al,(%rax)
    2f2c:	00 40 4a             	add    %al,0x4a(%rax)
    2f2f:	05 00 00 00 3b       	add    $0x3b000000,%eax
    2f34:	f0 02 f6             	lock add %dh,%dh
    2f37:	1d 00 00 41 02       	sbb    $0x2410000,%eax
    2f3c:	fe                   	(bad)
    2f3d:	1d 00 00 40 4a       	sbb    $0x4a400000,%eax
    2f42:	05 00 00 00 3a       	add    $0x3a000000,%eax
    2f47:	01 50 07             	add    %edx,0x7(%rax)
    2f4a:	1e                   	(bad)
    2f4b:	00 00                	add    %al,(%rax)
    2f4d:	3e 80 20 0f          	ds andb $0xf,(%rax)
    2f51:	1e                   	(bad)
    2f52:	00 00                	add    %al,(%rax)
    2f54:	3e 18 17             	ds sbb %dl,(%rdi)
    2f57:	1e                   	(bad)
    2f58:	00 00                	add    %al,(%rax)
    2f5a:	00 00                	add    %al,(%rax)
    2f5c:	3f                   	(bad)
    2f5d:	3d 1e 00 00 4b       	cmp    $0x4b00001e,%eax
    2f62:	10 00                	adc    %al,(%rax)
    2f64:	00 00                	add    %al,(%rax)
    2f66:	00 ab 05 3d 03 91    	add    %ch,-0x6efcc2fb(%rbx)
    2f6c:	c8 00 47 1e          	enter  $0x4700,$0x1e
    2f70:	00 00                	add    %al,(%rax)
    2f72:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    2f77:	51                   	push   %rcx
    2f78:	1e                   	(bad)
    2f79:	00 00                	add    %al,(%rax)
    2f7b:	3d 01 57 5a 1e       	cmp    $0x1e5a5701,%eax
    2f80:	00 00                	add    %al,(%rax)
    2f82:	45 00 63 1e          	add    %r12b,0x1e(%r11)
    2f86:	00 00                	add    %al,(%rax)
    2f88:	00 3f                	add    %bh,(%rdi)
    2f8a:	93                   	xchg   %eax,%ebx
    2f8b:	1f                   	(bad)
    2f8c:	00 00                	add    %al,(%rax)
    2f8e:	4c 13 00             	adc    (%rax),%r8
    2f91:	00 00                	add    %al,(%rax)
    2f93:	00 a3 05 3e 89 04    	add    %ah,0x4893e05(%rbx)
    2f99:	98                   	cwtl
    2f9a:	1f                   	(bad)
    2f9b:	00 00                	add    %al,(%rax)
    2f9d:	3b f7                	cmp    %edi,%esi
    2f9f:	02 a1 1f 00 00 40    	add    0x4000001f(%rcx),%ah
    2fa5:	4c 0c 00             	rex.WR or $0x0,%al
    2fa8:	00 00                	add    %al,(%rax)
    2faa:	3b f6                	cmp    %esi,%esi
    2fac:	02 ab 1f 00 00 41    	add    0x4100001f(%rbx),%ch
    2fb2:	06                   	(bad)
    2fb3:	b3 1f                	mov    $0x1f,%bl
    2fb5:	00 00                	add    %al,(%rax)
    2fb7:	40                   	rex
    2fb8:	4c 0c 00             	rex.WR or $0x0,%al
    2fbb:	00 00                	add    %al,(%rax)
    2fbd:	3e 89 04 bc          	ds mov %eax,(%rsp,%rdi,4)
    2fc1:	1f                   	(bad)
    2fc2:	00 00                	add    %al,(%rax)
    2fc4:	3e 80 08 c4          	ds orb $0xc4,(%rax)
    2fc8:	1f                   	(bad)
    2fc9:	00 00                	add    %al,(%rax)
    2fcb:	3e 08 cc             	ds or  %cl,%ah
    2fce:	1f                   	(bad)
    2fcf:	00 00                	add    %al,(%rax)
    2fd1:	00 00                	add    %al,(%rax)
    2fd3:	00 00                	add    %al,(%rax)
    2fd5:	3c 6d                	cmp    $0x6d,%al
    2fd7:	1e                   	(bad)
    2fd8:	00 00                	add    %al,(%rax)
    2fda:	4d 5e                	rex.WRB pop %r14
    2fdc:	00 00                	add    %al,(%rax)
    2fde:	00 00                	add    %al,(%rax)
    2fe0:	00 04 0b             	add    %al,(%rbx,%rcx,1)
    2fe3:	3d 04 91 d8 00       	cmp    $0xd89104,%eax
    2fe8:	9f                   	lahf
    2fe9:	77 1e                	ja     3009 <_license+0xc74>
    2feb:	00 00                	add    %al,(%rax)
    2fed:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    2ff2:	80 1e 00             	sbbb   $0x0,(%rsi)
    2ff5:	00 3d 03 91 c0 00    	add    %bh,0xc09103(%rip)        # c0c0fe <_license+0xc09d69>
    2ffb:	89 1e                	mov    %ebx,(%rsi)
    2ffd:	00 00                	add    %al,(%rax)
    2fff:	3d 02 30 9f 92       	cmp    $0x929f3002,%eax
    3004:	1e                   	(bad)
    3005:	00 00                	add    %al,(%rax)
    3007:	3b f1                	cmp    %ecx,%esi
    3009:	02 9b 1e 00 00 3e    	add    0x3e00001e(%rbx),%bl
    300f:	00 a5 1e 00 00 40    	add    %ah,0x4000001e(%rbp)
    3015:	4e 2a 00             	rex.WRX sub (%rax),%r8b
    3018:	00 00                	add    %al,(%rax)
    301a:	3b f3                	cmp    %ebx,%esi
    301c:	02 d8                	add    %al,%bl
    301e:	1e                   	(bad)
    301f:	00 00                	add    %al,(%rax)
    3021:	40                   	rex
    3022:	4f 19 00             	rex.WRXB sbb %r8,(%r8)
    3025:	00 00                	add    %al,(%rax)
    3027:	3b f2                	cmp    %edx,%esi
    3029:	02 ec                	add    %ah,%ch
    302b:	1e                   	(bad)
    302c:	00 00                	add    %al,(%rax)
    302e:	41 06                	rex.B (bad)
    3030:	f5                   	cmc
    3031:	1e                   	(bad)
    3032:	00 00                	add    %al,(%rax)
    3034:	40                   	rex
    3035:	4f 19 00             	rex.WRXB sbb %r8,(%r8)
    3038:	00 00                	add    %al,(%rax)
    303a:	3e 80 20 ff          	ds andb $0xff,(%rax)
    303e:	1e                   	(bad)
    303f:	00 00                	add    %al,(%rax)
    3041:	3e 08 08             	ds or  %cl,(%rax)
    3044:	1f                   	(bad)
    3045:	00 00                	add    %al,(%rax)
    3047:	00 00                	add    %al,(%rax)
    3049:	00 00                	add    %al,(%rax)
    304b:	40 50                	rex push %rax
    304d:	23 00                	and    (%rax),%eax
    304f:	00 00                	add    %al,(%rax)
    3051:	3b cf                	cmp    %edi,%ecx
    3053:	02 ab 0f 00 00 41    	add    0x4100000f(%rbx),%ch
    3059:	06                   	(bad)
    305a:	b4 0f                	mov    $0xf,%ah
    305c:	00 00                	add    %al,(%rax)
    305e:	40 50                	rex push %rax
    3060:	23 00                	and    (%rax),%eax
    3062:	00 00                	add    %al,(%rax)
    3064:	3e 80 08 be          	ds orb $0xbe,(%rax)
    3068:	0f 00 00             	sldt   (%rax)
    306b:	3e 08 c7             	ds or  %al,%bh
    306e:	0f 00 00             	sldt   (%rax)
    3071:	00 00                	add    %al,(%rax)
    3073:	40 51                	rex push %rcx
    3075:	28 00                	sub    %al,(%rax)
    3077:	00 00                	add    %al,(%rax)
    3079:	3b d1                	cmp    %ecx,%edx
    307b:	02 dc                	add    %ah,%bl
    307d:	0f 00 00             	sldt   (%rax)
    3080:	41 06                	rex.B (bad)
    3082:	e5 0f                	in     $0xf,%eax
    3084:	00 00                	add    %al,(%rax)
    3086:	40 51                	rex push %rcx
    3088:	28 00                	sub    %al,(%rax)
    308a:	00 00                	add    %al,(%rax)
    308c:	3b d2                	cmp    %edx,%edx
    308e:	02 ef                	add    %bh,%ch
    3090:	0f 00 00             	sldt   (%rax)
    3093:	3b d3                	cmp    %ebx,%edx
    3095:	02 f8                	add    %al,%bh
    3097:	0f 00 00             	sldt   (%rax)
    309a:	00 00                	add    %al,(%rax)
    309c:	3c a4                	cmp    $0xa4,%al
    309e:	1c 00                	sbb    $0x0,%al
    30a0:	00 52 e2             	add    %dl,-0x1e(%rdx)
    30a3:	00 00                	add    %al,(%rax)
    30a5:	00 00                	add    %al,(%rax)
    30a7:	29 04 0a             	sub    %eax,(%rdx,%rcx,1)
    30aa:	3d 03 91 d0 00       	cmp    $0xd09103,%eax
    30af:	ad                   	lods   %ds:(%rsi),%eax
    30b0:	1c 00                	sbb    $0x0,%al
    30b2:	00 3d 03 91 10 9f    	add    %bh,-0x60ef6efd(%rip)        # ffffffff9f10c1bb <server_id_map+0x36ff86a231bb>
    30b8:	bd 1c 00 00 3d       	mov    $0x3d00001c,%ebp
    30bd:	01 5d c5             	add    %ebx,-0x3b(%rbp)
    30c0:	1c 00                	sbb    $0x0,%al
    30c2:	00 3b                	add    %bh,(%rbx)
    30c4:	d4                   	(bad)
    30c5:	02 d5                	add    %ch,%dl
    30c7:	1c 00                	sbb    $0x0,%al
    30c9:	00 3b                	add    %bh,(%rbx)
    30cb:	d5                   	(bad)
    30cc:	02 de                	add    %dh,%bl
    30ce:	1c 00                	sbb    $0x0,%al
    30d0:	00 3b                	add    %bh,(%rbx)
    30d2:	d6                   	(bad)
    30d3:	02 e6                	add    %dh,%ah
    30d5:	1c 00                	sbb    $0x0,%al
    30d7:	00 3b                	add    %bh,(%rbx)
    30d9:	d7                   	xlat   %ds:(%rbx)
    30da:	02 ee                	add    %dh,%ch
    30dc:	1c 00                	sbb    $0x0,%al
    30de:	00 3b                	add    %bh,(%rbx)
    30e0:	d8 02                	fadds  (%rdx)
    30e2:	f6 1c 00             	negb   (%rax,%rax,1)
    30e5:	00 3b                	add    %bh,(%rbx)
    30e7:	d9 02                	flds   (%rdx)
    30e9:	ff 1c 00             	lcall  *(%rax,%rax,1)
    30ec:	00 3b                	add    %bh,(%rbx)
    30ee:	da 02                	fiaddl (%rdx)
    30f0:	07                   	(bad)
    30f1:	1d 00 00 3f 11       	sbb    $0x113f0000,%eax
    30f6:	1d 00 00 53 41       	sbb    $0x41530000,%eax
    30fb:	00 00                	add    %al,(%rax)
    30fd:	00 11                	add    %dl,(%rcx)
    30ff:	75 03                	jne    3104 <_license+0xd6f>
    3101:	39 dc                	cmp    %ebx,%esp
    3103:	02 1e                	add    (%rsi),%bl
    3105:	1d 00 00 39 db       	sbb    $0xdb390000,%eax
    310a:	02 26                	add    (%rsi),%ah
    310c:	1d 00 00 3d 01       	sbb    $0x13d0000,%eax
    3111:	50                   	push   %rax
    3112:	2e 1d 00 00 45 04    	cs sbb $0x4450000,%eax
    3118:	3e 1d 00 00 3e 00    	ds sbb $0x3e0000,%eax
    311e:	46 1d 00 00 3f 0b    	rex.RX sbb $0xb3f0000,%eax
    3124:	13 00                	adc    (%rax),%eax
    3126:	00 54 1b 00          	add    %dl,0x0(%rbx,%rbx,1)
    312a:	00 00                	add    %al,(%rax)
    312c:	12 48 03             	adc    0x3(%rax),%cl
    312f:	3d 03 72 0e 9f       	cmp    $0x9f0e7203,%eax
    3134:	0f 13 00             	movlps %xmm0,(%rax)
    3137:	00 3b                	add    %bh,(%rbx)
    3139:	de 02                	fiadds (%rdx)
    313b:	1f                   	(bad)
    313c:	13 00                	adc    (%rax),%eax
    313e:	00 40 54             	add    %al,0x54(%rax)
    3141:	1b 00                	sbb    (%rax),%eax
    3143:	00 00                	add    %al,(%rax)
    3145:	3b dd                	cmp    %ebp,%ebx
    3147:	02 28                	add    (%rax),%ch
    3149:	13 00                	adc    (%rax),%eax
    314b:	00 00                	add    %al,(%rax)
    314d:	00 00                	add    %al,(%rax)
    314f:	00 3c d7             	add    %bh,(%rdi,%rdx,8)
    3152:	1f                   	(bad)
    3153:	00 00                	add    %al,(%rax)
    3155:	55                   	push   %rbp
    3156:	93                   	xchg   %eax,%ebx
    3157:	00 00                	add    %al,(%rax)
    3159:	00 00                	add    %al,(%rax)
    315b:	25 04 0a 3d 03       	and    $0x33d0a04,%eax
    3160:	91                   	xchg   %eax,%ecx
    3161:	d0 00                	rolb   (%rax)
    3163:	e0 1f                	loopne 3184 <_license+0xdef>
    3165:	00 00                	add    %al,(%rax)
    3167:	3d 02 30 9f f0       	cmp    $0xf09f3002,%eax
    316c:	1f                   	(bad)
    316d:	00 00                	add    %al,(%rax)
    316f:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    3174:	f8                   	clc
    3175:	1f                   	(bad)
    3176:	00 00                	add    %al,(%rax)
    3178:	3d 01 5d 00 20       	cmp    $0x20005d01,%eax
    317d:	00 00                	add    %al,(%rax)
    317f:	3d 12 73 00 10       	cmp    $0x10007312,%eax
    3184:	ff                   	(bad)
    3185:	ff 03                	incl   (%rbx)
    3187:	1a a8 c3 80 80 00    	sbb    0x8080c3(%rax),%ch
    318d:	a8 b4                	test   $0xb4,%al
    318f:	80 80 00 9f 08 20 00 	addb   $0x0,0x20089f00(%rax)
    3196:	00 3b                	add    %bh,(%rbx)
    3198:	f8                   	clc
    3199:	02 10                	add    (%rax),%dl
    319b:	20 00                	and    %al,(%rax)
    319d:	00 3b                	add    %bh,(%rbx)
    319f:	f9                   	stc
    31a0:	02 18                	add    (%rax),%bl
    31a2:	20 00                	and    %al,(%rax)
    31a4:	00 3b                	add    %bh,(%rbx)
    31a6:	fa                   	cli
    31a7:	02 20                	add    (%rax),%ah
    31a9:	20 00                	and    %al,(%rax)
    31ab:	00 3b                	add    %bh,(%rbx)
    31ad:	fb                   	sti
    31ae:	02 29                	add    (%rcx),%ch
    31b0:	20 00                	and    %al,(%rax)
    31b2:	00 3b                	add    %bh,(%rbx)
    31b4:	fc                   	cld
    31b5:	02 31                	add    (%rcx),%dh
    31b7:	20 00                	and    %al,(%rax)
    31b9:	00 3b                	add    %bh,(%rbx)
    31bb:	fd                   	std
    31bc:	02 3a                	add    (%rdx),%bh
    31be:	20 00                	and    %al,(%rax)
    31c0:	00 3b                	add    %bh,(%rbx)
    31c2:	fe 02                	incb   (%rdx)
    31c4:	42 20 00             	rex.X and %al,(%rax)
    31c7:	00 3b                	add    %bh,(%rbx)
    31c9:	ff 02                	incl   (%rdx)
    31cb:	4a 20 00             	rex.WX and %al,(%rax)
    31ce:	00 47 5f             	add    %al,0x5f(%rdi)
    31d1:	20 00                	and    %al,(%rax)
    31d3:	00 56 04             	add    %dl,0x4(%rsi)
    31d6:	00 00                	add    %al,(%rax)
    31d8:	00 11                	add    %dl,(%rcx)
    31da:	4f 05 3f 7d 20 00    	rex.WRXB add $0x207d3f,%rax
    31e0:	00 57 24             	add    %dl,0x24(%rdi)
    31e3:	00 00                	add    %al,(%rax)
    31e5:	00 11                	add    %dl,(%rcx)
    31e7:	53                   	push   %rbx
    31e8:	03 39                	add    (%rcx),%edi
    31ea:	80 03 8a             	addb   $0x8a,(%rbx)
    31ed:	20 00                	and    %al,(%rax)
    31ef:	00 3d 01 5d 9b 20    	add    %bh,0x209b5d01(%rip)        # 209b8ef6 <_license+0x209b6b61>
    31f5:	00 00                	add    %al,(%rax)
    31f7:	3d 01 53 a3 20       	cmp    $0x20a35301,%eax
    31fc:	00 00                	add    %al,(%rax)
    31fe:	45 04 ab             	rex.RB add $0xab,%al
    3201:	20 00                	and    %al,(%rax)
    3203:	00 00                	add    %al,(%rax)
    3205:	00 00                	add    %al,(%rax)
    3207:	38 87 0c 00 00 16    	cmp    %al,0x1600000c(%rdi)
    320d:	00 44 04 0c          	add    %al,0xc(%rsp,%rax,1)
    3211:	39 1b                	cmp    %ebx,(%rbx)
    3213:	90                   	nop
    3214:	0c 00                	or     $0x0,%al
    3216:	00 39                	add    %bh,(%rcx)
    3218:	1c 99                	sbb    $0x99,%al
    321a:	0c 00                	or     $0x0,%al
    321c:	00 39                	add    %bh,(%rcx)
    321e:	1d a2 0c 00 00       	sbb    $0xca2,%eax
    3223:	3a 02                	cmp    (%rdx),%al
    3225:	91                   	xchg   %eax,%ecx
    3226:	10 ab 0c 00 00 3a    	adc    %ch,0x3a00000c(%rbx)
    322c:	03 91 d8 00 b4 0c    	add    0xcb400d8(%rcx),%edx
    3232:	00 00                	add    %al,(%rax)
    3234:	3b 1e                	cmp    (%rsi),%ebx
    3236:	bd 0c 00 00 3b       	mov    $0x3b00000c,%ebp
    323b:	1f                   	(bad)
    323c:	c6                   	(bad)
    323d:	0c 00                	or     $0x0,%al
    323f:	00 3b                	add    %bh,(%rbx)
    3241:	20 cf                	and    %cl,%bh
    3243:	0c 00                	or     $0x0,%al
    3245:	00 3b                	add    %bh,(%rbx)
    3247:	21 d8                	and    %ebx,%eax
    3249:	0c 00                	or     $0x0,%al
    324b:	00 3b                	add    %bh,(%rbx)
    324d:	22 e1                	and    %cl,%ah
    324f:	0c 00                	or     $0x0,%al
    3251:	00 3b                	add    %bh,(%rbx)
    3253:	2f                   	(bad)
    3254:	ea                   	(bad)
    3255:	0c 00                	or     $0x0,%al
    3257:	00 3b                	add    %bh,(%rbx)
    3259:	30 f3                	xor    %dh,%bl
    325b:	0c 00                	or     $0x0,%al
    325d:	00 3b                	add    %bh,(%rbx)
    325f:	79 fc                	jns    325d <_license+0xec8>
    3261:	0c 00                	or     $0x0,%al
    3263:	00 3b                	add    %bh,(%rbx)
    3265:	7a 05                	jp     326c <_license+0xed7>
    3267:	0d 00 00 3b 7c       	or     $0x7c3b0000,%eax
    326c:	0e                   	(bad)
    326d:	0d 00 00 3b 7e       	or     $0x7e3b0000,%eax
    3272:	17                   	(bad)
    3273:	0d 00 00 3b 86       	or     $0x863b0000,%eax
    3278:	01 20                	add    %esp,(%rax)
    327a:	0d 00 00 3b 85       	or     $0x853b0000,%eax
    327f:	02 29                	add    (%rcx),%ch
    3281:	0d 00 00 3b 86       	or     $0x863b0000,%eax
    3286:	03 32                	add    (%rdx),%esi
    3288:	0d 00 00 38 01       	or     $0x1380000,%eax
    328d:	11 00                	adc    %eax,(%rax)
    328f:	00 17                	add    %dl,(%rdi)
    3291:	00 bb 02 0c 39 23    	add    %bh,0x23390c02(%rbx)
    3297:	0a 11                	or     (%rcx),%dl
    3299:	00 00                	add    %al,(%rax)
    329b:	39 24 1c             	cmp    %esp,(%rsp,%rbx,1)
    329e:	11 00                	adc    %eax,(%rax)
    32a0:	00 39                	add    %bh,(%rcx)
    32a2:	25 37 11 00 00       	and    $0x1137,%eax
    32a7:	39 26                	cmp    %esp,(%rsi)
    32a9:	40 11 00             	rex adc %eax,(%rax)
    32ac:	00 39                	add    %bh,(%rcx)
    32ae:	27                   	(bad)
    32af:	49 11 00             	adc    %rax,(%r8)
    32b2:	00 3b                	add    %bh,(%rbx)
    32b4:	28 5b 11             	sub    %bl,0x11(%rbx)
    32b7:	00 00                	add    %al,(%rax)
    32b9:	3b 29                	cmp    (%rcx),%ebp
    32bb:	64 11 00             	adc    %eax,%fs:(%rax)
    32be:	00 00                	add    %al,(%rax)
    32c0:	38 93 12 00 00 18    	cmp    %dl,0x18000012(%rbx)
    32c6:	00 c0                	add    %al,%al
    32c8:	02 0c 39             	add    (%rcx,%rdi,1),%cl
    32cb:	31 9c 12 00 00 39 32 	xor    %ebx,0x32390000(%rdx,%rdx,1)
    32d2:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    32d3:	12 00                	adc    (%rax),%al
    32d5:	00 39                	add    %bh,(%rcx)
    32d7:	33 ae 12 00 00 39    	xor    0x39000012(%rsi),%ebp
    32dd:	34 b7                	xor    $0xb7,%al
    32df:	12 00                	adc    (%rax),%al
    32e1:	00 39                	add    %bh,(%rcx)
    32e3:	35 c0 12 00 00       	xor    $0x12c0,%eax
    32e8:	38 32                	cmp    %dh,(%rdx)
    32ea:	13 00                	adc    (%rax),%eax
    32ec:	00 19                	add    %bl,(%rcx)
    32ee:	0e                   	(bad)
    32ef:	5a                   	pop    %rdx
    32f0:	01 0c 39             	add    %ecx,(%rcx,%rdi,1)
    32f3:	2a 3a                	sub    (%rdx),%bh
    32f5:	13 00                	adc    (%rax),%eax
    32f7:	00 39                	add    %bh,(%rcx)
    32f9:	2b 42 13             	sub    0x13(%rdx),%eax
    32fc:	00 00                	add    %al,(%rax)
    32fe:	39 2c 4a             	cmp    %ebp,(%rdx,%rcx,2)
    3301:	13 00                	adc    (%rax),%eax
    3303:	00 39                	add    %bh,(%rcx)
    3305:	2d 52 13 00 00       	sub    $0x1352,%eax
    330a:	3b 2e                	cmp    (%rsi),%ebp
    330c:	5a                   	pop    %rdx
    330d:	13 00                	adc    (%rax),%eax
    330f:	00 3b                	add    %bh,(%rbx)
    3311:	4f 62 13             	rex.WRXB (bad)
    3314:	00 00                	add    %al,(%rax)
    3316:	40 58                	rex pop %rax
    3318:	2a 00                	sub    (%rax),%al
    331a:	00 00                	add    %al,(%rax)
    331c:	3e 8c 04 6b          	ds mov %es,(%rbx,%rbp,2)
    3320:	13 00                	adc    (%rax),%eax
    3322:	00 3b                	add    %bh,(%rbx)
    3324:	4d 73 13             	rex.WRB jae 333a <_license+0xfa5>
    3327:	00 00                	add    %al,(%rax)
    3329:	3b 4e 7c             	cmp    0x7c(%rsi),%ecx
    332c:	13 00                	adc    (%rax),%eax
    332e:	00 40 58             	add    %al,0x58(%rax)
    3331:	0c 00                	or     $0x0,%al
    3333:	00 00                	add    %al,(%rax)
    3335:	3b 4c 85 13          	cmp    0x13(%rbp,%rax,4),%ecx
    3339:	00 00                	add    %al,(%rax)
    333b:	41 06                	rex.B (bad)
    333d:	8d 13                	lea    (%rbx),%edx
    333f:	00 00                	add    %al,(%rax)
    3341:	40 58                	rex pop %rax
    3343:	0c 00                	or     $0x0,%al
    3345:	00 00                	add    %al,(%rax)
    3347:	3e 8c 04 96          	ds mov %es,(%rsi,%rdx,4)
    334b:	13 00                	adc    (%rax),%eax
    334d:	00 3e                	add    %bh,(%rsi)
    334f:	80 08 9e             	orb    $0x9e,(%rax)
    3352:	13 00                	adc    (%rax),%eax
    3354:	00 3e                	add    %bh,(%rsi)
    3356:	08 a6 13 00 00 00    	or     %ah,0x13(%rsi)
    335c:	00 00                	add    %al,(%rax)
    335e:	00 38                	add    %bh,(%rax)
    3360:	73 11                	jae    3373 <_license+0xfde>
    3362:	00 00                	add    %al,(%rax)
    3364:	1a 0e                	sbb    (%rsi),%cl
    3366:	5c                   	pop    %rsp
    3367:	01 0c 39             	add    %ecx,(%rcx,%rdi,1)
    336a:	36 7c 11             	ss jl  337e <_license+0xfe9>
    336d:	00 00                	add    %al,(%rax)
    336f:	39 37                	cmp    %esi,(%rdi)
    3371:	85 11                	test   %edx,(%rcx)
    3373:	00 00                	add    %al,(%rax)
    3375:	39 38                	cmp    %edi,(%rax)
    3377:	8e 11                	mov    (%rcx),%ss
    3379:	00 00                	add    %al,(%rax)
    337b:	39 39                	cmp    %edi,(%rcx)
    337d:	97                   	xchg   %eax,%edi
    337e:	11 00                	adc    %eax,(%rax)
    3380:	00 3b                	add    %bh,(%rbx)
    3382:	3a a0 11 00 00 3b    	cmp    0x3b000011(%rax),%ah
    3388:	76 a9                	jbe    3333 <_license+0xf9e>
    338a:	11 00                	adc    %eax,(%rax)
    338c:	00 3c ca             	add    %bh,(%rdx,%rcx,8)
    338f:	12 00                	adc    (%rax),%al
    3391:	00 59 46             	add    %bl,0x46(%rcx)
    3394:	00 00                	add    %al,(%rax)
    3396:	00 0e                	add    %cl,(%rsi)
    3398:	1f                   	(bad)
    3399:	01 0c 3d 01 5f d2 12 	add    %ecx,0x12d25f01(,%rdi,1)
    33a0:	00 00                	add    %al,(%rax)
    33a2:	3d 01 5d da 12       	cmp    $0x12da5d01,%eax
    33a7:	00 00                	add    %al,(%rax)
    33a9:	3b 3b                	cmp    (%rbx),%edi
    33ab:	e2 12                	loop   33bf <_license+0x102a>
    33ad:	00 00                	add    %al,(%rax)
    33af:	3e 00 ea             	ds add %ch,%dl
    33b2:	12 00                	adc    (%rax),%al
    33b4:	00 3e                	add    %bh,(%rsi)
    33b6:	22 f2                	and    %dl,%dh
    33b8:	12 00                	adc    (%rax),%al
    33ba:	00 3a                	add    %bh,(%rdx)
    33bc:	03 7f 22             	add    0x22(%rdi),%edi
    33bf:	9f                   	lahf
    33c0:	fa                   	cli
    33c1:	12 00                	adc    (%rax),%al
    33c3:	00 3f                	add    %bh,(%rdi)
    33c5:	0b 13                	or     (%rbx),%edx
    33c7:	00 00                	add    %al,(%rax)
    33c9:	5a                   	pop    %rdx
    33ca:	26 00 00             	es add %al,(%rax)
    33cd:	00 0e                	add    %cl,(%rsi)
    33cf:	59                   	pop    %rcx
    33d0:	03 3b                	add    (%rbx),%edi
    33d2:	3d 1f 13 00 00       	cmp    $0x131f,%eax
    33d7:	40 5a                	rex pop %rdx
    33d9:	26 00 00             	es add %al,(%rax)
    33dc:	00 3b                	add    %bh,(%rbx)
    33de:	3c 28                	cmp    $0x28,%al
    33e0:	13 00                	adc    (%rax),%eax
    33e2:	00 00                	add    %al,(%rax)
    33e4:	00 00                	add    %al,(%rax)
    33e6:	40 5b                	rex pop %rbx
    33e8:	23 00                	and    (%rax),%eax
    33ea:	00 00                	add    %al,(%rax)
    33ec:	3e 8d 04 b3          	ds lea (%rbx,%rsi,4),%eax
    33f0:	11 00                	adc    %eax,(%rax)
    33f2:	00 3b                	add    %bh,(%rbx)
    33f4:	75 bc                	jne    33b2 <_license+0x101d>
    33f6:	11 00                	adc    %eax,(%rax)
    33f8:	00 40 5b             	add    %al,0x5b(%rax)
    33fb:	0c 00                	or     $0x0,%al
    33fd:	00 00                	add    %al,(%rax)
    33ff:	3b 74 cf 11          	cmp    0x11(%rdi,%rcx,8),%esi
    3403:	00 00                	add    %al,(%rax)
    3405:	41 06                	rex.B (bad)
    3407:	d8 11                	fcoms  (%rcx)
    3409:	00 00                	add    %al,(%rax)
    340b:	40 5b                	rex pop %rbx
    340d:	0c 00                	or     $0x0,%al
    340f:	00 00                	add    %al,(%rax)
    3411:	3e 8d 04 e2          	ds lea (%rdx,%riz,8),%eax
    3415:	11 00                	adc    %eax,(%rax)
    3417:	00 3e                	add    %bh,(%rsi)
    3419:	80 08 eb             	orb    $0xeb,(%rax)
    341c:	11 00                	adc    %eax,(%rax)
    341e:	00 3e                	add    %bh,(%rsi)
    3420:	08 f4                	or     %dh,%ah
    3422:	11 00                	adc    %eax,(%rax)
    3424:	00 00                	add    %al,(%rax)
    3426:	00 00                	add    %al,(%rax)
    3428:	00 00                	add    %al,(%rax)
    342a:	3c 86                	cmp    $0x86,%al
    342c:	15 00 00 5c 2b       	adc    $0x2b5c0000,%eax
    3431:	00 00                	add    %al,(%rax)
    3433:	00 00                	add    %al,(%rax)
    3435:	f4                   	hlt
    3436:	02 0a                	add    (%rdx),%cl
    3438:	3d 01 5f 8f 15       	cmp    $0x158f5f01,%eax
    343d:	00 00                	add    %al,(%rax)
    343f:	3d 01 5d 97 15       	cmp    $0x15975d01,%eax
    3444:	00 00                	add    %al,(%rax)
    3446:	3d 02 31 9f 9f       	cmp    $0x9f9f3102,%eax
    344b:	15 00 00 3d 03       	adc    $0x33d0000,%eax
    3450:	91                   	xchg   %eax,%ecx
    3451:	10 9f a7 15 00 00    	adc    %bl,0x15a7(%rdi)
    3457:	3a 11                	cmp    (%rcx),%dl
    3459:	71 00                	jno    345b <_license+0x10c6>
    345b:	10 ff                	adc    %bh,%bh
    345d:	01 1a                	add    %ebx,(%rdx)
    345f:	a8 be                	test   $0xbe,%al
    3461:	80 80 00 a8 b9 80 80 	addb   $0x80,-0x7f465800(%rax)
    3468:	00 9f af 15 00 00    	add    %bl,0x15af(%rdi)
    346e:	3b 3e                	cmp    (%rsi),%edi
    3470:	b7 15                	mov    $0x15,%bh
    3472:	00 00                	add    %al,(%rax)
    3474:	3f                   	(bad)
    3475:	93                   	xchg   %eax,%ebx
    3476:	16                   	(bad)
    3477:	00 00                	add    %al,(%rax)
    3479:	5d                   	pop    %rbp
    347a:	02 00                	add    (%rax),%al
    347c:	00 00                	add    %al,(%rax)
    347e:	0c 7b                	or     $0x7b,%al
    3480:	0f 3d                	(bad)
    3482:	02 31                	add    (%rcx),%dh
    3484:	9f                   	lahf
    3485:	9c                   	pushf
    3486:	16                   	(bad)
    3487:	00 00                	add    %al,(%rax)
    3489:	3d 11 71 00 10       	cmp    $0x10007111,%eax
    348e:	ff 01                	incl   (%rcx)
    3490:	1a a8 be 80 80 00    	sbb    0x8080be(%rax),%ch
    3496:	a8 b9                	test   $0xb9,%al
    3498:	80 80 00 9f a4 16 00 	addb   $0x0,0x16a49f00(%rax)
    349f:	00 00                	add    %al,(%rax)
    34a1:	00 3c 14             	add    %bh,(%rsp,%rdx,1)
    34a4:	19 00                	sbb    %eax,(%rax)
    34a6:	00 5e 17             	add    %bl,0x17(%rsi)
    34a9:	00 00                	add    %al,(%rax)
    34ab:	00 00                	add    %al,(%rax)
    34ad:	f8                   	clc
    34ae:	02 0a                	add    (%rdx),%cl
    34b0:	3d 01 5f 1d 19       	cmp    $0x191d5f01,%eax
    34b5:	00 00                	add    %al,(%rax)
    34b7:	3d 01 5d 25 19       	cmp    $0x19255d01,%eax
    34bc:	00 00                	add    %al,(%rax)
    34be:	3d 02 31 9f 2d       	cmp    $0x2d9f3102,%eax
    34c3:	19 00                	sbb    %eax,(%rax)
    34c5:	00 3d 03 91 10 9f    	add    %bh,-0x60ef6efd(%rip)        # ffffffff9f10c5ce <server_id_map+0x36ff86a235ce>
    34cb:	35 19 00 00 3a       	xor    $0x3a000019,%eax
    34d0:	11 71 00             	adc    %esi,0x0(%rcx)
    34d3:	10 ff                	adc    %bh,%bh
    34d5:	01 1a                	add    %ebx,(%rdx)
    34d7:	a8 be                	test   $0xbe,%al
    34d9:	80 80 00 a8 b9 80 80 	addb   $0x80,-0x7f465800(%rax)
    34e0:	00 9f 3d 19 00 00    	add    %bl,0x193d(%rdi)
    34e6:	3b 73 45             	cmp    0x45(%rbx),%esi
    34e9:	19 00                	sbb    %eax,(%rax)
    34eb:	00 3f                	add    %bh,(%rdi)
    34ed:	93                   	xchg   %eax,%ebx
    34ee:	16                   	(bad)
    34ef:	00 00                	add    %al,(%rax)
    34f1:	5f                   	pop    %rdi
    34f2:	02 00                	add    (%rax),%al
    34f4:	00 00                	add    %al,(%rax)
    34f6:	0c 61                	or     $0x61,%al
    34f8:	0f 3d                	(bad)
    34fa:	02 31                	add    (%rcx),%dh
    34fc:	9f                   	lahf
    34fd:	9c                   	pushf
    34fe:	16                   	(bad)
    34ff:	00 00                	add    %al,(%rax)
    3501:	3d 11 71 00 10       	cmp    $0x10007111,%eax
    3506:	ff 01                	incl   (%rcx)
    3508:	1a a8 be 80 80 00    	sbb    0x8080be(%rax),%ch
    350e:	a8 b9                	test   $0xb9,%al
    3510:	80 80 00 9f a4 16 00 	addb   $0x0,0x16a49f00(%rax)
    3517:	00 00                	add    %al,(%rax)
    3519:	00 40 60             	add    %al,0x60(%rax)
    351c:	4b 01 00             	rex.WXB add %rax,(%r8)
    351f:	00 3b                	add    %bh,(%rbx)
    3521:	50                   	push   %rax
    3522:	57                   	push   %rdi
    3523:	0d 00 00 38 b5       	or     $0xb5380000,%eax
    3528:	16                   	(bad)
    3529:	00 00                	add    %al,(%rax)
    352b:	1b 00                	sbb    (%rax),%eax
    352d:	ea                   	(bad)
    352e:	02 0e                	add    (%rsi),%cl
    3530:	39 51 be             	cmp    %edx,-0x42(%rcx)
    3533:	16                   	(bad)
    3534:	00 00                	add    %al,(%rax)
    3536:	39 52 c6             	cmp    %edx,-0x3a(%rdx)
    3539:	16                   	(bad)
    353a:	00 00                	add    %al,(%rax)
    353c:	3a 02                	cmp    (%rdx),%al
    353e:	91                   	xchg   %eax,%ecx
    353f:	00 d6                	add    %dl,%dh
    3541:	16                   	(bad)
    3542:	00 00                	add    %al,(%rax)
    3544:	3b 55 df             	cmp    -0x21(%rbp),%edx
    3547:	16                   	(bad)
    3548:	00 00                	add    %al,(%rax)
    354a:	3b 57 e8             	cmp    -0x18(%rdi),%edx
    354d:	16                   	(bad)
    354e:	00 00                	add    %al,(%rax)
    3550:	40 61                	rex (bad)
    3552:	1f                   	(bad)
    3553:	00 00                	add    %al,(%rax)
    3555:	00 3b                	add    %bh,(%rbx)
    3557:	53                   	push   %rbx
    3558:	f1                   	int1
    3559:	16                   	(bad)
    355a:	00 00                	add    %al,(%rax)
    355c:	41 01 f9             	add    %edi,%r9d
    355f:	16                   	(bad)
    3560:	00 00                	add    %al,(%rax)
    3562:	3f                   	(bad)
    3563:	3e 17                	ds (bad)
    3565:	00 00                	add    %al,(%rax)
    3567:	61                   	(bad)
    3568:	1f                   	(bad)
    3569:	00 00                	add    %al,(%rax)
    356b:	00 00                	add    %al,(%rax)
    356d:	d5                   	(bad)
    356e:	1c 39                	sbb    $0x39,%al
    3570:	54                   	push   %rsp
    3571:	48 17                	rex.W (bad)
    3573:	00 00                	add    %al,(%rax)
    3575:	3d 01 57 52 17       	cmp    $0x17525701,%eax
    357a:	00 00                	add    %al,(%rax)
    357c:	00 00                	add    %al,(%rax)
    357e:	40 62                	rex (bad)
    3580:	18 00                	sbb    %al,(%rax)
    3582:	00 00                	add    %al,(%rax)
    3584:	3e 86 04 03          	ds xchg %al,(%rbx,%rax,1)
    3588:	17                   	(bad)
    3589:	00 00                	add    %al,(%rax)
    358b:	40 62                	rex (bad)
    358d:	0c 00                	or     $0x0,%al
    358f:	00 00                	add    %al,(%rax)
    3591:	3b 56 0c             	cmp    0xc(%rsi),%edx
    3594:	17                   	(bad)
    3595:	00 00                	add    %al,(%rax)
    3597:	41 06                	rex.B (bad)
    3599:	14 17                	adc    $0x17,%al
    359b:	00 00                	add    %al,(%rax)
    359d:	40 62                	rex (bad)
    359f:	0c 00                	or     $0x0,%al
    35a1:	00 00                	add    %al,(%rax)
    35a3:	3e 86 04 1d 17 00 00 	ds xchg %al,0x3e000017(,%rbx,1)
    35aa:	3e 
    35ab:	80 08 25             	orb    $0x25,(%rax)
    35ae:	17                   	(bad)
    35af:	00 00                	add    %al,(%rax)
    35b1:	3e 08 2d 17 00 00 00 	ds or  %ch,0x17(%rip)        # 35cf <_license+0x123a>
    35b8:	00 00                	add    %al,(%rax)
    35ba:	00 38                	add    %bh,(%rax)
    35bc:	a1 17 00 00 1c 00 ee 	movabs 0xc02ee001c000017,%eax
    35c3:	02 0c 
    35c5:	3b 59 e1             	cmp    -0x1f(%rcx),%ebx
    35c8:	17                   	(bad)
    35c9:	00 00                	add    %al,(%rax)
    35cb:	3b 5a ea             	cmp    -0x16(%rdx),%ebx
    35ce:	17                   	(bad)
    35cf:	00 00                	add    %al,(%rax)
    35d1:	3b 5c f3 17          	cmp    0x17(%rbx,%rsi,8),%ebx
    35d5:	00 00                	add    %al,(%rax)
    35d7:	40 63 5e 00          	rex movsxd 0x0(%rsi),%ebx
    35db:	00 00                	add    %al,(%rax)
    35dd:	41                   	rex.B
    35de:	36 fd                	ss std
    35e0:	17                   	(bad)
    35e1:	00 00                	add    %al,(%rax)
    35e3:	3c 5c                	cmp    $0x5c,%al
    35e5:	17                   	(bad)
    35e6:	00 00                	add    %al,(%rax)
    35e8:	63 1e                	movsxd (%rsi),%ebx
    35ea:	00 00                	add    %al,(%rax)
    35ec:	00 00                	add    %al,(%rax)
    35ee:	4f 01 0e             	rex.WRXB add %r9,(%r14)
    35f1:	3d 01 5f 65 17       	cmp    $0x17655f01,%eax
    35f6:	00 00                	add    %al,(%rax)
    35f8:	3d 01 5d 6d 17       	cmp    $0x176d5d01,%eax
    35fd:	00 00                	add    %al,(%rax)
    35ff:	43                   	rex.XB
    3600:	36 75 17             	ss jne 361a <_license+0x1285>
    3603:	00 00                	add    %al,(%rax)
    3605:	3d 02 31 9f 7e       	cmp    $0x7e9f3102,%eax
    360a:	17                   	(bad)
    360b:	00 00                	add    %al,(%rax)
    360d:	3b 58 86             	cmp    -0x7a(%rax),%ebx
    3610:	17                   	(bad)
    3611:	00 00                	add    %al,(%rax)
    3613:	00 3c a8             	add    %bh,(%rax,%rbp,4)
    3616:	18 00                	sbb    %al,(%rax)
    3618:	00 64 40 00          	add    %ah,0x0(%rax,%rax,2)
    361c:	00 00                	add    %al,(%rax)
    361e:	00 50 01             	add    %dl,0x1(%rax)
    3621:	0a 3d 02 30 9f c9    	or     -0x3660cffe(%rip),%bh        # ffffffffc99f6629 <server_id_map+0x36ffb130d629>
    3627:	18 00                	sbb    %al,(%rax)
    3629:	00 3a                	add    %bh,(%rdx)
    362b:	01 5f d2             	add    %ebx,-0x2e(%rdi)
    362e:	18 00                	sbb    %al,(%rax)
    3630:	00 3a                	add    %bh,(%rdx)
    3632:	03 7f 28             	add    0x28(%rdi),%edi
    3635:	9f                   	lahf
    3636:	db 18                	fistpl (%rax)
    3638:	00 00                	add    %al,(%rax)
    363a:	00 00                	add    %al,(%rax)
    363c:	40                   	rex
    363d:	65 0c 00             	gs or  $0x0,%al
    3640:	00 00                	add    %al,(%rax)
    3642:	3b 5b 21             	cmp    0x21(%rbx),%ebx
    3645:	18 00                	sbb    %al,(%rax)
    3647:	00 41 06             	add    %al,0x6(%rcx)
    364a:	2a 18                	sub    (%rax),%bl
    364c:	00 00                	add    %al,(%rax)
    364e:	40                   	rex
    364f:	65 0c 00             	gs or  $0x0,%al
    3652:	00 00                	add    %al,(%rax)
    3654:	3e 8a 04 34          	ds mov (%rsp,%rsi,1),%al
    3658:	18 00                	sbb    %al,(%rax)
    365a:	00 3e                	add    %bh,(%rsi)
    365c:	80 08 3d             	orb    $0x3d,(%rax)
    365f:	18 00                	sbb    %al,(%rax)
    3661:	00 3e                	add    %bh,(%rsi)
    3663:	08 46 18             	or     %al,0x18(%rsi)
    3666:	00 00                	add    %al,(%rax)
    3668:	00 00                	add    %al,(%rax)
    366a:	40                   	rex
    366b:	66 15 00 00          	adc    $0x0,%ax
    366f:	00 3e                	add    %bh,(%rsi)
    3671:	8e 04 52             	mov    (%rdx,%rdx,2),%es
    3674:	18 00                	sbb    %al,(%rax)
    3676:	00 3b                	add    %bh,(%rbx)
    3678:	5e                   	pop    %rsi
    3679:	5c                   	pop    %rsp
    367a:	18 00                	sbb    %al,(%rax)
    367c:	00 40 66             	add    %al,0x66(%rax)
    367f:	0c 00                	or     $0x0,%al
    3681:	00 00                	add    %al,(%rax)
    3683:	3b 5d 71             	cmp    0x71(%rbp),%ebx
    3686:	18 00                	sbb    %al,(%rax)
    3688:	00 41 06             	add    %al,0x6(%rcx)
    368b:	7a 18                	jp     36a5 <_license+0x1310>
    368d:	00 00                	add    %al,(%rax)
    368f:	40                   	rex
    3690:	66 0c 00             	data16 or $0x0,%al
    3693:	00 00                	add    %al,(%rax)
    3695:	3e 8e 04 84          	ds mov (%rsp,%rax,4),%es
    3699:	18 00                	sbb    %al,(%rax)
    369b:	00 3e                	add    %bh,(%rsi)
    369d:	80 08 8d             	orb    $0x8d,(%rax)
    36a0:	18 00                	sbb    %al,(%rax)
    36a2:	00 3e                	add    %bh,(%rsi)
    36a4:	08 96 18 00 00 00    	or     %dl,0x18(%rsi)
    36aa:	00 00                	add    %al,(%rax)
    36ac:	3c e5                	cmp    $0xe5,%al
    36ae:	18 00                	sbb    %al,(%rax)
    36b0:	00 67 28             	add    %ah,0x28(%rdi)
    36b3:	00 00                	add    %al,(%rax)
    36b5:	00 00                	add    %al,(%rax)
    36b7:	73 01                	jae    36ba <_license+0x1325>
    36b9:	0a 41 00             	or     0x0(%rcx),%al
    36bc:	f7 18                	negl   (%rax)
    36be:	00 00                	add    %al,(%rax)
    36c0:	40                   	rex
    36c1:	67 28 00             	sub    %al,(%eax)
    36c4:	00 00                	add    %al,(%rax)
    36c6:	3b 5f 00             	cmp    0x0(%rdi),%ebx
    36c9:	19 00                	sbb    %eax,(%rax)
    36cb:	00 3b                	add    %bh,(%rbx)
    36cd:	60                   	(bad)
    36ce:	09 19                	or     %ebx,(%rcx)
    36d0:	00 00                	add    %al,(%rax)
    36d2:	00 00                	add    %al,(%rax)
    36d4:	00 00                	add    %al,(%rax)
    36d6:	40 68 5e 01 00 00    	rex push $0x15e
    36dc:	3b 61 62             	cmp    0x62(%rcx),%esp
    36df:	0d 00 00 38 b5       	or     $0xb5380000,%eax
    36e4:	16                   	(bad)
    36e5:	00 00                	add    %al,(%rax)
    36e7:	1d 00 e2 02 0e       	sbb    $0xe02e200,%eax
    36ec:	39 62 be             	cmp    %esp,-0x42(%rdx)
    36ef:	16                   	(bad)
    36f0:	00 00                	add    %al,(%rax)
    36f2:	39 63 c6             	cmp    %esp,-0x3a(%rbx)
    36f5:	16                   	(bad)
    36f6:	00 00                	add    %al,(%rax)
    36f8:	3a 02                	cmp    (%rdx),%al
    36fa:	91                   	xchg   %eax,%ecx
    36fb:	00 d6                	add    %dl,%dh
    36fd:	16                   	(bad)
    36fe:	00 00                	add    %al,(%rax)
    3700:	3b 66 df             	cmp    -0x21(%rsi),%esp
    3703:	16                   	(bad)
    3704:	00 00                	add    %al,(%rax)
    3706:	3b 68 e8             	cmp    -0x18(%rax),%ebp
    3709:	16                   	(bad)
    370a:	00 00                	add    %al,(%rax)
    370c:	40 69 1f 00 00 00 3b 	rex imul $0x3b000000,(%rdi),%ebx
    3713:	64 f1                	fs int1
    3715:	16                   	(bad)
    3716:	00 00                	add    %al,(%rax)
    3718:	41 01 f9             	add    %edi,%r9d
    371b:	16                   	(bad)
    371c:	00 00                	add    %al,(%rax)
    371e:	3f                   	(bad)
    371f:	3e 17                	ds (bad)
    3721:	00 00                	add    %al,(%rax)
    3723:	69 1f 00 00 00 00    	imul   $0x0,(%rdi),%ebx
    3729:	d5                   	(bad)
    372a:	1c 39                	sbb    $0x39,%al
    372c:	65 48 17             	gs rex.W (bad)
    372f:	00 00                	add    %al,(%rax)
    3731:	3d 01 57 52 17       	cmp    $0x17525701,%eax
    3736:	00 00                	add    %al,(%rax)
    3738:	00 00                	add    %al,(%rax)
    373a:	40 6a 18             	rex push $0x18
    373d:	00 00                	add    %al,(%rax)
    373f:	00 3e                	add    %bh,(%rsi)
    3741:	86 04 03             	xchg   %al,(%rbx,%rax,1)
    3744:	17                   	(bad)
    3745:	00 00                	add    %al,(%rax)
    3747:	40 6a 0c             	rex push $0xc
    374a:	00 00                	add    %al,(%rax)
    374c:	00 3b                	add    %bh,(%rbx)
    374e:	67 0c 17             	addr32 or $0x17,%al
    3751:	00 00                	add    %al,(%rax)
    3753:	41 06                	rex.B (bad)
    3755:	14 17                	adc    $0x17,%al
    3757:	00 00                	add    %al,(%rax)
    3759:	40 6a 0c             	rex push $0xc
    375c:	00 00                	add    %al,(%rax)
    375e:	00 3e                	add    %bh,(%rsi)
    3760:	86 04 1d 17 00 00 3e 	xchg   %al,0x3e000017(,%rbx,1)
    3767:	80 08 25             	orb    $0x25,(%rax)
    376a:	17                   	(bad)
    376b:	00 00                	add    %al,(%rax)
    376d:	3e 08 2d 17 00 00 00 	ds or  %ch,0x17(%rip)        # 378b <_license+0x13f6>
    3774:	00 00                	add    %al,(%rax)
    3776:	00 38                	add    %bh,(%rax)
    3778:	a1 17 00 00 1e 00 e6 	movabs 0xc02e6001e000017,%eax
    377f:	02 0c 
    3781:	3b 6b e1             	cmp    -0x1f(%rbx),%ebp
    3784:	17                   	(bad)
    3785:	00 00                	add    %al,(%rax)
    3787:	3b 6c ea 17          	cmp    0x17(%rdx,%rbp,8),%ebp
    378b:	00 00                	add    %al,(%rax)
    378d:	3b 6e f3             	cmp    -0xd(%rsi),%ebp
    3790:	17                   	(bad)
    3791:	00 00                	add    %al,(%rax)
    3793:	40 6b 72 00 00       	rex imul $0x0,0x0(%rdx),%esi
    3798:	00 41 36             	add    %al,0x36(%rcx)
    379b:	09 18                	or     %ebx,(%rax)
    379d:	00 00                	add    %al,(%rax)
    379f:	3c 5c                	cmp    $0x5c,%al
    37a1:	17                   	(bad)
    37a2:	00 00                	add    %al,(%rax)
    37a4:	6b 32 00             	imul   $0x0,(%rdx),%esi
    37a7:	00 00                	add    %al,(%rax)
    37a9:	00 3b                	add    %bh,(%rbx)
    37ab:	01 10                	add    %edx,(%rax)
    37ad:	3d 01 5f 65 17       	cmp    $0x17655f01,%eax
    37b2:	00 00                	add    %al,(%rax)
    37b4:	3d 01 5d 6d 17       	cmp    $0x176d5d01,%eax
    37b9:	00 00                	add    %al,(%rax)
    37bb:	43                   	rex.XB
    37bc:	36 75 17             	ss jne 37d6 <_license+0x1441>
    37bf:	00 00                	add    %al,(%rax)
    37c1:	3d 02 30 9f 7e       	cmp    $0x7e9f3002,%eax
    37c6:	17                   	(bad)
    37c7:	00 00                	add    %al,(%rax)
    37c9:	3b 69 8e             	cmp    -0x72(%rcx),%ebp
    37cc:	17                   	(bad)
    37cd:	00 00                	add    %al,(%rax)
    37cf:	40 6b 32 00          	rex imul $0x0,(%rdx),%esi
    37d3:	00 00                	add    %al,(%rax)
    37d5:	3b 6a 97             	cmp    -0x69(%rdx),%ebp
    37d8:	17                   	(bad)
    37d9:	00 00                	add    %al,(%rax)
    37db:	00 00                	add    %al,(%rax)
    37dd:	3c a8                	cmp    $0xa8,%al
    37df:	18 00                	sbb    %al,(%rax)
    37e1:	00 6c 3a 00          	add    %ch,0x0(%rdx,%rdi,1)
    37e5:	00 00                	add    %al,(%rax)
    37e7:	00 3c 01             	add    %bh,(%rcx,%rax,1)
    37ea:	0c 3d                	or     $0x3d,%al
    37ec:	02 31                	add    (%rcx),%dh
    37ee:	9f                   	lahf
    37ef:	c9                   	leave
    37f0:	18 00                	sbb    %al,(%rax)
    37f2:	00 3a                	add    %bh,(%rdx)
    37f4:	01 5f d2             	add    %ebx,-0x2e(%rdi)
    37f7:	18 00                	sbb    %al,(%rax)
    37f9:	00 3a                	add    %bh,(%rdx)
    37fb:	03 7f 28             	add    0x28(%rdi),%edi
    37fe:	9f                   	lahf
    37ff:	db 18                	fistpl (%rax)
    3801:	00 00                	add    %al,(%rax)
    3803:	00 00                	add    %al,(%rax)
    3805:	40 6d                	rex insl (%dx),%es:(%rdi)
    3807:	0c 00                	or     $0x0,%al
    3809:	00 00                	add    %al,(%rax)
    380b:	3b 6d 21             	cmp    0x21(%rbp),%ebp
    380e:	18 00                	sbb    %al,(%rax)
    3810:	00 41 06             	add    %al,0x6(%rcx)
    3813:	2a 18                	sub    (%rax),%bl
    3815:	00 00                	add    %al,(%rax)
    3817:	40 6d                	rex insl (%dx),%es:(%rdi)
    3819:	0c 00                	or     $0x0,%al
    381b:	00 00                	add    %al,(%rax)
    381d:	3e 8a 04 34          	ds mov (%rsp,%rsi,1),%al
    3821:	18 00                	sbb    %al,(%rax)
    3823:	00 3e                	add    %bh,(%rsi)
    3825:	80 08 3d             	orb    $0x3d,(%rax)
    3828:	18 00                	sbb    %al,(%rax)
    382a:	00 3e                	add    %bh,(%rsi)
    382c:	08 46 18             	or     %al,0x18(%rsi)
    382f:	00 00                	add    %al,(%rax)
    3831:	00 00                	add    %al,(%rax)
    3833:	40 6e                	rex outsb %ds:(%rsi),(%dx)
    3835:	14 00                	adc    $0x0,%al
    3837:	00 00                	add    %al,(%rax)
    3839:	3e 8e 04 52          	ds mov (%rdx,%rdx,2),%es
    383d:	18 00                	sbb    %al,(%rax)
    383f:	00 3b                	add    %bh,(%rbx)
    3841:	70 5c                	jo     389f <_license+0x150a>
    3843:	18 00                	sbb    %al,(%rax)
    3845:	00 40 6e             	add    %al,0x6e(%rax)
    3848:	0c 00                	or     $0x0,%al
    384a:	00 00                	add    %al,(%rax)
    384c:	3b 6f 71             	cmp    0x71(%rdi),%ebp
    384f:	18 00                	sbb    %al,(%rax)
    3851:	00 41 06             	add    %al,0x6(%rcx)
    3854:	7a 18                	jp     386e <_license+0x14d9>
    3856:	00 00                	add    %al,(%rax)
    3858:	40 6e                	rex outsb %ds:(%rsi),(%dx)
    385a:	0c 00                	or     $0x0,%al
    385c:	00 00                	add    %al,(%rax)
    385e:	3e 8e 04 84          	ds mov (%rsp,%rax,4),%es
    3862:	18 00                	sbb    %al,(%rax)
    3864:	00 3e                	add    %bh,(%rsi)
    3866:	80 08 8d             	orb    $0x8d,(%rax)
    3869:	18 00                	sbb    %al,(%rax)
    386b:	00 3e                	add    %bh,(%rsi)
    386d:	08 96 18 00 00 00    	or     %dl,0x18(%rsi)
    3873:	00 00                	add    %al,(%rax)
    3875:	3c e5                	cmp    $0xe5,%al
    3877:	18 00                	sbb    %al,(%rax)
    3879:	00 6f 28             	add    %ch,0x28(%rdi)
    387c:	00 00                	add    %al,(%rax)
    387e:	00 00                	add    %al,(%rax)
    3880:	73 01                	jae    3883 <_license+0x14ee>
    3882:	0a 41 00             	or     0x0(%rcx),%al
    3885:	f7 18                	negl   (%rax)
    3887:	00 00                	add    %al,(%rax)
    3889:	40 6f                	rex outsl %ds:(%rsi),(%dx)
    388b:	28 00                	sub    %al,(%rax)
    388d:	00 00                	add    %al,(%rax)
    388f:	3b 71 00             	cmp    0x0(%rcx),%esi
    3892:	19 00                	sbb    %eax,(%rax)
    3894:	00 3b                	add    %bh,(%rbx)
    3896:	72 09                	jb     38a1 <_license+0x150c>
    3898:	19 00                	sbb    %eax,(%rax)
    389a:	00 00                	add    %al,(%rax)
    389c:	00 00                	add    %al,(%rax)
    389e:	00 40 70             	add    %al,0x70(%rax)
    38a1:	18 00                	sbb    %al,(%rax)
    38a3:	00 00                	add    %al,(%rax)
    38a5:	3b 77 6d             	cmp    0x6d(%rdi),%esi
    38a8:	0d 00 00 41 01       	or     $0x1410000,%eax
    38ad:	76 0d                	jbe    38bc <_license+0x1527>
    38af:	00 00                	add    %al,(%rax)
    38b1:	3c 3e                	cmp    $0x3e,%al
    38b3:	17                   	(bad)
    38b4:	00 00                	add    %al,(%rax)
    38b6:	70 18                	jo     38d0 <_license+0x153b>
    38b8:	00 00                	add    %al,(%rax)
    38ba:	00 00                	add    %al,(%rax)
    38bc:	13 03                	adc    (%rbx),%eax
    38be:	0e                   	(bad)
    38bf:	39 78 48             	cmp    %edi,0x48(%rax)
    38c2:	17                   	(bad)
    38c3:	00 00                	add    %al,(%rax)
    38c5:	3d 04 91 d8 00       	cmp    $0xd89104,%eax
    38ca:	9f                   	lahf
    38cb:	52                   	push   %rdx
    38cc:	17                   	(bad)
    38cd:	00 00                	add    %al,(%rax)
    38cf:	00 00                	add    %al,(%rax)
    38d1:	40 71 11             	rex jno 38e5 <_license+0x1550>
    38d4:	00 00                	add    %al,(%rax)
    38d6:	00 3b                	add    %bh,(%rbx)
    38d8:	8a 01                	mov    (%rcx),%al
    38da:	81 0d 00 00 41 01 8a 	orl    $0xd8a,0x1410000(%rip)        # 14138e4 <_license+0x141154f>
    38e1:	0d 00 00 
    38e4:	3c 3e                	cmp    $0x3e,%al
    38e6:	17                   	(bad)
    38e7:	00 00                	add    %al,(%rax)
    38e9:	71 11                	jno    38fc <_license+0x1567>
    38eb:	00 00                	add    %al,(%rax)
    38ed:	00 00                	add    %al,(%rax)
    38ef:	16                   	(bad)
    38f0:	03 10                	add    (%rax),%edx
    38f2:	3d 04 91 d8 00       	cmp    $0xd89104,%eax
    38f7:	9f                   	lahf
    38f8:	52                   	push   %rdx
    38f9:	17                   	(bad)
    38fa:	00 00                	add    %al,(%rax)
    38fc:	00 00                	add    %al,(%rax)
    38fe:	40 72 0c             	rex jb 390d <_license+0x1578>
    3901:	00 00                	add    %al,(%rax)
    3903:	00 3b                	add    %bh,(%rbx)
    3905:	7b 95                	jnp    389c <_license+0x1507>
    3907:	0d 00 00 41 06       	or     $0x6410000,%eax
    390c:	9e                   	sahf
    390d:	0d 00 00 40 72       	or     $0x72400000,%eax
    3912:	0c 00                	or     $0x0,%al
    3914:	00 00                	add    %al,(%rax)
    3916:	3e 80 04 a8 0d       	ds addb $0xd,(%rax,%rbp,4)
    391b:	00 00                	add    %al,(%rax)
    391d:	3e 80 08 b1          	ds orb $0xb1,(%rax)
    3921:	0d 00 00 3e 08       	or     $0x83e0000,%eax
    3926:	ba 0d 00 00 00       	mov    $0xd,%edx
    392b:	00 40 73             	add    %al,0x73(%rax)
    392e:	0c 00                	or     $0x0,%al
    3930:	00 00                	add    %al,(%rax)
    3932:	3b 7d c6             	cmp    -0x3a(%rbp),%edi
    3935:	0d 00 00 00 42       	or     $0x42000000,%eax
    393a:	1f                   	(bad)
    393b:	3b 80 01 d1 0d 00    	cmp    0xdd101(%rax),%eax
    3941:	00 3b                	add    %bh,(%rbx)
    3943:	81 01 da 0d 00 00    	addl   $0xdda,(%rcx)
    3949:	42 20 3b             	rex.X and %dil,(%rbx)
    394c:	7f e4                	jg     3932 <_license+0x159d>
    394e:	0d 00 00 3b 82       	or     $0x823b0000,%eax
    3953:	01 ed                	add    %ebp,%ebp
    3955:	0d 00 00 3b 83       	or     $0x833b0000,%eax
    395a:	01 f6                	add    %esi,%esi
    395c:	0d 00 00 00 00       	or     $0x0,%eax
    3961:	40 74 27             	rex je 398b <_license+0x15f6>
    3964:	00 00                	add    %al,(%rax)
    3966:	00 3e                	add    %bh,(%rsi)
    3968:	83 04 02 0e          	addl   $0xe,(%rdx,%rax,1)
    396c:	00 00                	add    %al,(%rax)
    396e:	3b 85 01 0b 0e 00    	cmp    0xe0b01(%rbp),%eax
    3974:	00 40 74             	add    %al,0x74(%rax)
    3977:	0c 00                	or     $0x0,%al
    3979:	00 00                	add    %al,(%rax)
    397b:	3b 84 01 15 0e 00 00 	cmp    0xe15(%rcx,%rax,1),%eax
    3982:	41 06                	rex.B (bad)
    3984:	1e                   	(bad)
    3985:	0e                   	(bad)
    3986:	00 00                	add    %al,(%rax)
    3988:	40 74 0c             	rex je 3997 <_license+0x1602>
    398b:	00 00                	add    %al,(%rax)
    398d:	00 3e                	add    %bh,(%rsi)
    398f:	83 04 28 0e          	addl   $0xe,(%rax,%rbp,1)
    3993:	00 00                	add    %al,(%rax)
    3995:	3e 80 08 31          	ds orb $0x31,(%rax)
    3999:	0e                   	(bad)
    399a:	00 00                	add    %al,(%rax)
    399c:	3e 08 3a             	ds or  %bh,(%rdx)
    399f:	0e                   	(bad)
    39a0:	00 00                	add    %al,(%rax)
    39a2:	00 00                	add    %al,(%rax)
    39a4:	00 42 21             	add    %al,0x21(%rdx)
    39a7:	3b c3                	cmp    %ebx,%eax
    39a9:	01 51 0e             	add    %edx,0xe(%rcx)
    39ac:	00 00                	add    %al,(%rax)
    39ae:	3b c5                	cmp    %ebp,%eax
    39b0:	01 5a 0e             	add    %ebx,0xe(%rdx)
    39b3:	00 00                	add    %al,(%rax)
    39b5:	3b e0                	cmp    %eax,%esp
    39b7:	01 63 0e             	add    %esp,0xe(%rbx)
    39ba:	00 00                	add    %al,(%rax)
    39bc:	40 75 0c             	rex jne 39cb <_license+0x1636>
    39bf:	00 00                	add    %al,(%rax)
    39c1:	00 3b                	add    %bh,(%rbx)
    39c3:	c4 01 6d 0e          	(bad)
    39c7:	00 00                	add    %al,(%rax)
    39c9:	41 06                	rex.B (bad)
    39cb:	76 0e                	jbe    39db <_license+0x1646>
    39cd:	00 00                	add    %al,(%rax)
    39cf:	40 75 0c             	rex jne 39de <_license+0x1649>
    39d2:	00 00                	add    %al,(%rax)
    39d4:	00 3e                	add    %bh,(%rsi)
    39d6:	00 80 0e 00 00 3e    	add    %al,0x3e00000e(%rax)
    39dc:	01 89 0e 00 00 3e    	add    %ecx,0x3e00000e(%rcx)
    39e2:	08 92 0e 00 00 00    	or     %dl,0xe(%rdx)
    39e8:	00 38                	add    %bh,(%rax)
    39ea:	be 19 00 00 22       	mov    $0x22000019,%esi
    39ef:	00 70 03             	add    %dh,0x3(%rax)
    39f2:	26 39 c6             	es cmp %eax,%esi
    39f5:	01 c8                	add    %ecx,%eax
    39f7:	19 00                	sbb    %eax,(%rax)
    39f9:	00 39                	add    %bh,(%rcx)
    39fb:	c7 01 d1 19 00 00    	movl   $0x19d1,(%rcx)
    3a01:	39 c8                	cmp    %ecx,%eax
    3a03:	01 da                	add    %ebx,%edx
    3a05:	19 00                	sbb    %eax,(%rax)
    3a07:	00 39                	add    %bh,(%rcx)
    3a09:	c9                   	leave
    3a0a:	01 e3                	add    %esp,%ebx
    3a0c:	19 00                	sbb    %eax,(%rax)
    3a0e:	00 3b                	add    %bh,(%rbx)
    3a10:	ca 01 ec             	lret   $0xec01
    3a13:	19 00                	sbb    %eax,(%rax)
    3a15:	00 3b                	add    %bh,(%rbx)
    3a17:	cb                   	lret
    3a18:	01 f6                	add    %esi,%esi
    3a1a:	19 00                	sbb    %eax,(%rax)
    3a1c:	00 3b                	add    %bh,(%rbx)
    3a1e:	cc                   	int3
    3a1f:	01 00                	add    %eax,(%rax)
    3a21:	1a 00                	sbb    (%rax),%al
    3a23:	00 3b                	add    %bh,(%rbx)
    3a25:	cd 01                	int    $0x1
    3a27:	0a 1a                	or     (%rdx),%bl
    3a29:	00 00                	add    %al,(%rax)
    3a2b:	3b ce                	cmp    %esi,%ecx
    3a2d:	01 14 1a             	add    %edx,(%rdx,%rbx,1)
    3a30:	00 00                	add    %al,(%rax)
    3a32:	42 23 3b             	rex.X and (%rbx),%edi
    3a35:	e6 01                	out    %al,$0x1
    3a37:	31 1a                	xor    %ebx,(%rdx)
    3a39:	00 00                	add    %al,(%rax)
    3a3b:	00 00                	add    %al,(%rax)
    3a3d:	3c 82                	cmp    $0x82,%al
    3a3f:	1a 00                	sbb    (%rax),%al
    3a41:	00 76 34             	add    %dh,0x34(%rsi)
    3a44:	00 00                	add    %al,(%rax)
    3a46:	00 00                	add    %al,(%rax)
    3a48:	a2 03 09 3d 02 31 9f 	movabs %al,0x1a919f31023d0903
    3a4f:	91 1a 
    3a51:	00 00                	add    %al,(%rax)
    3a53:	3d 02 30 9f 9b       	cmp    $0x9b9f3002,%eax
    3a58:	1a 00                	sbb    (%rax),%al
    3a5a:	00 3b                	add    %bh,(%rbx)
    3a5c:	e2 01                	loop   3a5f <_license+0x16ca>
    3a5e:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    3a5f:	1a 00                	sbb    (%rax),%al
    3a61:	00 40 76             	add    %al,0x76(%rax)
    3a64:	26 00 00             	es add %al,(%rax)
    3a67:	00 3b                	add    %bh,(%rbx)
    3a69:	e1 01                	loope  3a6c <_license+0x16d7>
    3a6b:	b0 1a                	mov    $0x1a,%al
    3a6d:	00 00                	add    %al,(%rax)
    3a6f:	41 06                	rex.B (bad)
    3a71:	b9 1a 00 00 40       	mov    $0x4000001a,%ecx
    3a76:	76 26                	jbe    3a9e <_license+0x1709>
    3a78:	00 00                	add    %al,(%rax)
    3a7a:	00 3e                	add    %bh,(%rsi)
    3a7c:	80 04 c3 1a          	addb   $0x1a,(%rbx,%rax,8)
    3a80:	00 00                	add    %al,(%rax)
    3a82:	3e 08 cc             	ds or  %cl,%ah
    3a85:	1a 00                	sbb    (%rax),%al
    3a87:	00 00                	add    %al,(%rax)
    3a89:	00 00                	add    %al,(%rax)
    3a8b:	42 24 3b             	rex.X and $0x3b,%al
    3a8e:	e8 01 9e 0e 00       	call   ed894 <_license+0xeb4ff>
    3a93:	00 3c e1             	add    %bh,(%rcx,%riz,8)
    3a96:	1a 00                	sbb    (%rax),%al
    3a98:	00 77 29             	add    %dh,0x29(%rdi)
    3a9b:	00 00                	add    %al,(%rax)
    3a9d:	00 00                	add    %al,(%rax)
    3a9f:	74 03                	je     3aa4 <_license+0x170f>
    3aa1:	09 3d 01 5e e7 1a    	or     %edi,0x1ae75e01(%rip)        # 1ae798a8 <_license+0x1ae77513>
    3aa7:	00 00                	add    %al,(%rax)
    3aa9:	39 e7                	cmp    %esp,%edi
    3aab:	01 f0                	add    %esi,%eax
    3aad:	1a 00                	sbb    (%rax),%al
    3aaf:	00 00                	add    %al,(%rax)
    3ab1:	40 78 06             	rex js 3aba <_license+0x1725>
    3ab4:	00 00                	add    %al,(%rax)
    3ab6:	00 3b                	add    %bh,(%rbx)
    3ab8:	e9 01 b1 0e 00       	jmp    eebbe <_license+0xec829>
    3abd:	00 41 02             	add    %al,0x2(%rcx)
    3ac0:	ba 0e 00 00 40       	mov    $0x4000000e,%edx
    3ac5:	78 06                	js     3acd <_license+0x1738>
    3ac7:	00 00                	add    %al,(%rax)
    3ac9:	00 3a                	add    %bh,(%rdx)
    3acb:	01 51 c4             	add    %edx,-0x3c(%rcx)
    3ace:	0e                   	(bad)
    3acf:	00 00                	add    %al,(%rax)
    3ad1:	3e fe                	ds (bad)
    3ad3:	ff                   	(bad)
    3ad4:	ff 07                	incl   (%rdi)
    3ad6:	cd 0e                	int    $0xe
    3ad8:	00 00                	add    %al,(%rax)
    3ada:	3e 08 d6             	ds or  %dl,%dh
    3add:	0e                   	(bad)
    3ade:	00 00                	add    %al,(%rax)
    3ae0:	00 00                	add    %al,(%rax)
    3ae2:	42 25 3b ee 01 e2    	rex.X and $0xe201ee3b,%eax
    3ae8:	0e                   	(bad)
    3ae9:	00 00                	add    %al,(%rax)
    3aeb:	40 79 06             	rex jns 3af4 <_license+0x175f>
    3aee:	00 00                	add    %al,(%rax)
    3af0:	00 3b                	add    %bh,(%rbx)
    3af2:	ea                   	(bad)
    3af3:	01 ec                	add    %ebp,%esp
    3af5:	0e                   	(bad)
    3af6:	00 00                	add    %al,(%rax)
    3af8:	41 02 f5             	add    %r13b,%sil
    3afb:	0e                   	(bad)
    3afc:	00 00                	add    %al,(%rax)
    3afe:	40 79 06             	rex jns 3b07 <_license+0x1772>
    3b01:	00 00                	add    %al,(%rax)
    3b03:	00 3a                	add    %bh,(%rdx)
    3b05:	01 52 ff             	add    %edx,-0x1(%rdx)
    3b08:	0e                   	(bad)
    3b09:	00 00                	add    %al,(%rax)
    3b0b:	3e 80 20 08          	ds andb $0x8,(%rax)
    3b0f:	0f 00 00             	sldt   (%rax)
    3b12:	3e 18 11             	ds sbb %dl,(%rcx)
    3b15:	0f 00 00             	sldt   (%rax)
    3b18:	00 00                	add    %al,(%rax)
    3b1a:	38 fa                	cmp    %bh,%dl
    3b1c:	1a 00                	sbb    (%rax),%al
    3b1e:	00 26                	add    %ah,(%rsi)
    3b20:	00 8a 03 17 39 eb    	add    %cl,-0x14c6e8fd(%rdx)
    3b26:	01 04 1b             	add    %eax,(%rbx,%rbx,1)
    3b29:	00 00                	add    %al,(%rax)
    3b2b:	39 ec                	cmp    %ebp,%esp
    3b2d:	01 0d 1b 00 00 3a    	add    %ecx,0x3a00001b(%rip)        # 3a003b4e <_license+0x3a0017b9>
    3b33:	02 91 00 16 1b 00    	add    0x1b1600(%rcx),%dl
    3b39:	00 3b                	add    %bh,(%rbx)
    3b3b:	ed                   	in     (%dx),%eax
    3b3c:	01 20                	add    %esp,(%rax)
    3b3e:	1b 00                	sbb    (%rax),%eax
    3b40:	00 3c 3e             	add    %bh,(%rsi,%rdi,1)
    3b43:	17                   	(bad)
    3b44:	00 00                	add    %al,(%rax)
    3b46:	7a 0b                	jp     3b53 <_license+0x17be>
    3b48:	00 00                	add    %al,(%rax)
    3b4a:	00 00                	add    %al,(%rax)
    3b4c:	6a 02                	push   $0x2
    3b4e:	22 3d 01 53 48 17    	and    0x17485301(%rip),%bh        # 17488e55 <_license+0x17486ac0>
    3b54:	00 00                	add    %al,(%rax)
    3b56:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    3b5b:	52                   	push   %rdx
    3b5c:	17                   	(bad)
    3b5d:	00 00                	add    %al,(%rax)
    3b5f:	00 38                	add    %bh,(%rax)
    3b61:	53                   	push   %rbx
    3b62:	1c 00                	sbb    $0x0,%al
    3b64:	00 27                	add    %ah,(%rdi)
    3b66:	00 74 02 07          	add    %dh,0x7(%rdx,%rax,1)
    3b6a:	3b 81 03 65 1c 00    	cmp    0x1c6503(%rcx),%eax
    3b70:	00 3b                	add    %bh,(%rbx)
    3b72:	83 03 6e             	addl   $0x6e,(%rbx)
    3b75:	1c 00                	sbb    $0x0,%al
    3b77:	00 40 7b             	add    %al,0x7b(%rax)
    3b7a:	0c 00                	or     $0x0,%al
    3b7c:	00 00                	add    %al,(%rax)
    3b7e:	3b 82 03 78 1c 00    	cmp    0x1c7803(%rdx),%eax
    3b84:	00 41 06             	add    %al,0x6(%rcx)
    3b87:	80 1c 00 00          	sbbb   $0x0,(%rax,%rax,1)
    3b8b:	40 7b 0c             	rex jnp 3b9a <_license+0x1805>
    3b8e:	00 00                	add    %al,(%rax)
    3b90:	00 3e                	add    %bh,(%rsi)
    3b92:	82                   	(bad)
    3b93:	04 89                	add    $0x89,%al
    3b95:	1c 00                	sbb    $0x0,%al
    3b97:	00 3e                	add    %bh,(%rsi)
    3b99:	80 08 91             	orb    $0x91,(%rax)
    3b9c:	1c 00                	sbb    $0x0,%al
    3b9e:	00 3e                	add    %bh,(%rsi)
    3ba0:	08 99 1c 00 00 00    	or     %bl,0x1c(%rcx)
    3ba6:	00 00                	add    %al,(%rax)
    3ba8:	3c 3d                	cmp    $0x3d,%al
    3baa:	1e                   	(bad)
    3bab:	00 00                	add    %al,(%rax)
    3bad:	7c 13                	jl     3bc2 <_license+0x182d>
    3baf:	00 00                	add    %al,(%rax)
    3bb1:	00 00                	add    %al,(%rax)
    3bb3:	79 02                	jns    3bb7 <_license+0x1822>
    3bb5:	03 3d 01 53 47 1e    	add    0x1e475301(%rip),%edi        # 1e478ebc <_license+0x1e476b27>
    3bbb:	00 00                	add    %al,(%rax)
    3bbd:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    3bc2:	51                   	push   %rcx
    3bc3:	1e                   	(bad)
    3bc4:	00 00                	add    %al,(%rax)
    3bc6:	3d 01 57 5a 1e       	cmp    $0x1e5a5701,%eax
    3bcb:	00 00                	add    %al,(%rax)
    3bcd:	45 00 63 1e          	add    %r12b,0x1e(%r11)
    3bd1:	00 00                	add    %al,(%rax)
    3bd3:	00 00                	add    %al,(%rax)
    3bd5:	3c 82                	cmp    $0x82,%al
    3bd7:	1a 00                	sbb    (%rax),%al
    3bd9:	00 7d 31             	add    %bh,0x31(%rbp)
    3bdc:	00 00                	add    %al,(%rax)
    3bde:	00 00                	add    %al,(%rax)
    3be0:	8f 03                	pop    (%rbx)
    3be2:	0f 3d                	(bad)
    3be4:	02 30                	add    (%rax),%dh
    3be6:	9f                   	lahf
    3be7:	91                   	xchg   %eax,%ecx
    3be8:	1a 00                	sbb    (%rax),%al
    3bea:	00 3d 02 31 9f 9b    	add    %bh,-0x6460cefe(%rip)        # ffffffff9b9f6cf2 <server_id_map+0x36ff8330dcf2>
    3bf0:	1a 00                	sbb    (%rax),%al
    3bf2:	00 3b                	add    %bh,(%rbx)
    3bf4:	85 03                	test   %eax,(%rbx)
    3bf6:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    3bf7:	1a 00                	sbb    (%rax),%al
    3bf9:	00 40 7d             	add    %al,0x7d(%rax)
    3bfc:	26 00 00             	es add %al,(%rax)
    3bff:	00 3b                	add    %bh,(%rbx)
    3c01:	84 03                	test   %al,(%rbx)
    3c03:	b0 1a                	mov    $0x1a,%al
    3c05:	00 00                	add    %al,(%rax)
    3c07:	41 06                	rex.B (bad)
    3c09:	b9 1a 00 00 40       	mov    $0x4000001a,%ecx
    3c0e:	7d 26                	jge    3c36 <_license+0x18a1>
    3c10:	00 00                	add    %al,(%rax)
    3c12:	00 3e                	add    %bh,(%rsi)
    3c14:	80 04 c3 1a          	addb   $0x1a,(%rbx,%rax,8)
    3c18:	00 00                	add    %al,(%rax)
    3c1a:	3e 08 cc             	ds or  %cl,%ah
    3c1d:	1a 00                	sbb    (%rax),%al
    3c1f:	00 00                	add    %al,(%rax)
    3c21:	00 00                	add    %al,(%rax)
    3c23:	00 00                	add    %al,(%rax)
    3c25:	00 40 7e             	add    %al,0x7e(%rax)
    3c28:	32 00                	xor    (%rax),%al
    3c2a:	00 00                	add    %al,(%rax)
    3c2c:	3e 8b 04 20          	ds mov (%rax,%riz,1),%eax
    3c30:	0f 00 00             	sldt   (%rax)
    3c33:	3b d1                	cmp    %ecx,%edx
    3c35:	01 29                	add    %ebp,(%rcx)
    3c37:	0f 00 00             	sldt   (%rax)
    3c3a:	40 7e 0c             	rex jle 3c49 <_license+0x18b4>
    3c3d:	00 00                	add    %al,(%rax)
    3c3f:	00 3b                	add    %bh,(%rbx)
    3c41:	d0 01                	rolb   (%rcx)
    3c43:	33 0f                	xor    (%rdi),%ecx
    3c45:	00 00                	add    %al,(%rax)
    3c47:	41 06                	rex.B (bad)
    3c49:	3c 0f                	cmp    $0xf,%al
    3c4b:	00 00                	add    %al,(%rax)
    3c4d:	40 7e 0c             	rex jle 3c5c <_license+0x18c7>
    3c50:	00 00                	add    %al,(%rax)
    3c52:	00 3e                	add    %bh,(%rsi)
    3c54:	8b 04 46             	mov    (%rsi,%rax,2),%eax
    3c57:	0f 00 00             	sldt   (%rax)
    3c5a:	3e 80 08 4f          	ds orb $0x4f,(%rax)
    3c5e:	0f 00 00             	sldt   (%rax)
    3c61:	3e 08 58 0f          	ds or  %bl,0xf(%rax)
    3c65:	00 00                	add    %al,(%rax)
    3c67:	00 00                	add    %al,(%rax)
    3c69:	3c 3d                	cmp    $0x3d,%al
    3c6b:	1a 00                	sbb    (%rax),%al
    3c6d:	00 7f 05             	add    %bh,0x5(%rdi)
    3c70:	00 00                	add    %al,(%rax)
    3c72:	00 00                	add    %al,(%rax)
    3c74:	66 03 0b             	add    (%rbx),%cx
    3c77:	3d 01 5f 47 1a       	cmp    $0x1a475f01,%eax
    3c7c:	00 00                	add    %al,(%rax)
    3c7e:	3d 01 5d 50 1a       	cmp    $0x1a505d01,%eax
    3c83:	00 00                	add    %al,(%rax)
    3c85:	3d 02 31 9f 59       	cmp    $0x599f3102,%eax
    3c8a:	1a 00                	sbb    (%rax),%al
    3c8c:	00 3e                	add    %bh,(%rsi)
    3c8e:	0e                   	(bad)
    3c8f:	62                   	(bad)
    3c90:	1a 00                	sbb    (%rax),%al
    3c92:	00 40 7f             	add    %al,0x7f(%rax)
    3c95:	05 00 00 00 3a       	add    $0x3a000000,%eax
    3c9a:	03 7f 36             	add    0x36(%rdi),%edi
    3c9d:	9f                   	lahf
    3c9e:	6c                   	insb   (%dx),%es:(%rdi)
    3c9f:	1a 00                	sbb    (%rax),%al
    3ca1:	00 00                	add    %al,(%rax)
    3ca3:	00 00                	add    %al,(%rax)
    3ca5:	3c 35                	cmp    $0x35,%al
    3ca7:	1b 00                	sbb    (%rax),%eax
    3ca9:	00 80 01 6d 00 00    	add    %al,0x6d01(%rax)
    3caf:	00 00                	add    %al,(%rax)
    3cb1:	d8 03                	fadds  (%rbx)
    3cb3:	07                   	(bad)
    3cb4:	39 ef                	cmp    %ebp,%edi
    3cb6:	01 43 1b             	add    %eax,0x1b(%rbx)
    3cb9:	00 00                	add    %al,(%rax)
    3cbb:	39 f0                	cmp    %esi,%eax
    3cbd:	01 4b 1b             	add    %ecx,0x1b(%rbx)
    3cc0:	00 00                	add    %al,(%rax)
    3cc2:	39 f1                	cmp    %esi,%ecx
    3cc4:	01 53 1b             	add    %edx,0x1b(%rbx)
    3cc7:	00 00                	add    %al,(%rax)
    3cc9:	3b f2                	cmp    %edx,%esi
    3ccb:	01 5c 1b 00          	add    %ebx,0x0(%rbx,%rbx,1)
    3ccf:	00 3b                	add    %bh,(%rbx)
    3cd1:	f3 01 65 1b          	repz add %esp,0x1b(%rbp)
    3cd5:	00 00                	add    %al,(%rax)
    3cd7:	3b f4                	cmp    %esp,%esi
    3cd9:	01 6e 1b             	add    %ebp,0x1b(%rsi)
    3cdc:	00 00                	add    %al,(%rax)
    3cde:	3f                   	(bad)
    3cdf:	3e 17                	ds (bad)
    3ce1:	00 00                	add    %al,(%rax)
    3ce3:	80 01 0b             	addb   $0xb,(%rcx)
    3ce6:	00 00                	add    %al,(%rax)
    3ce8:	00 00                	add    %al,(%rax)
    3cea:	b8 0d 3d 03 91       	mov    $0x91033d0d,%eax
    3cef:	f8                   	clc
    3cf0:	00 48 17             	add    %cl,0x17(%rax)
    3cf3:	00 00                	add    %al,(%rax)
    3cf5:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    3cfa:	52                   	push   %rdx
    3cfb:	17                   	(bad)
    3cfc:	00 00                	add    %al,(%rax)
    3cfe:	00 40 81             	add    %al,-0x7f(%rax)
    3d01:	01 16                	add    %edx,(%rsi)
    3d03:	00 00                	add    %al,(%rax)
    3d05:	00 3e                	add    %bh,(%rsi)
    3d07:	00 77 1b             	add    %dh,0x1b(%rdi)
    3d0a:	00 00                	add    %al,(%rax)
    3d0c:	41 02 7f 1b          	add    0x1b(%r15),%dil
    3d10:	00 00                	add    %al,(%rax)
    3d12:	40 81 01 16 00 00 00 	rex addl $0x16,(%rcx)
    3d19:	3b f5                	cmp    %ebp,%esi
    3d1b:	01 88 1b 00 00 3e    	add    %ecx,0x3e00001b(%rax)
    3d21:	80 20 90             	andb   $0x90,(%rax)
    3d24:	1b 00                	sbb    (%rax),%eax
    3d26:	00 3e                	add    %bh,(%rsi)
    3d28:	18 98 1b 00 00 00    	sbb    %bl,0x1b(%rax)
    3d2e:	00 00                	add    %al,(%rax)
    3d30:	3c a8                	cmp    $0xa8,%al
    3d32:	1b 00                	sbb    (%rax),%eax
    3d34:	00 82 01 da 00 00    	add    %al,0xda01(%rdx)
    3d3a:	00 00                	add    %al,(%rax)
    3d3c:	e5 03                	in     $0x3,%eax
    3d3e:	05 3d 03 91 10       	add    $0x1091033d,%eax
    3d43:	9f                   	lahf
    3d44:	bb 1b 00 00 39       	mov    $0x3900001b,%ebx
    3d49:	f6 01 c4             	testb  $0xc4,(%rcx)
    3d4c:	1b 00                	sbb    (%rax),%eax
    3d4e:	00 3d 04 91 d8 00    	add    %bh,0xd89104(%rip)        # d8ce58 <_license+0xd8aac3>
    3d54:	9f                   	lahf
    3d55:	cd 1b                	int    $0x1b
    3d57:	00 00                	add    %al,(%rax)
    3d59:	3c 53                	cmp    $0x53,%al
    3d5b:	1c 00                	sbb    $0x0,%al
    3d5d:	00 83 01 58 00 00    	add    %al,0x5801(%rbx)
    3d63:	00 00                	add    %al,(%rax)
    3d65:	93                   	xchg   %eax,%ebx
    3d66:	02 32                	add    (%rdx),%dh
    3d68:	3e 82                	ds (bad)
    3d6a:	04 65                	add    $0x65,%al
    3d6c:	1c 00                	sbb    $0x0,%al
    3d6e:	00 3b                	add    %bh,(%rbx)
    3d70:	f8                   	clc
    3d71:	01 6e 1c             	add    %ebp,0x1c(%rsi)
    3d74:	00 00                	add    %al,(%rax)
    3d76:	40 83 01 0c          	rex addl $0xc,(%rcx)
    3d7a:	00 00                	add    %al,(%rax)
    3d7c:	00 3b                	add    %bh,(%rbx)
    3d7e:	f7 01 78 1c 00 00    	testl  $0x1c78,(%rcx)
    3d84:	41 06                	rex.B (bad)
    3d86:	80 1c 00 00          	sbbb   $0x0,(%rax,%rax,1)
    3d8a:	40 83 01 0c          	rex addl $0xc,(%rcx)
    3d8e:	00 00                	add    %al,(%rax)
    3d90:	00 3e                	add    %bh,(%rsi)
    3d92:	82                   	(bad)
    3d93:	04 89                	add    $0x89,%al
    3d95:	1c 00                	sbb    $0x0,%al
    3d97:	00 3e                	add    %bh,(%rsi)
    3d99:	80 08 91             	orb    $0x91,(%rax)
    3d9c:	1c 00                	sbb    $0x0,%al
    3d9e:	00 3e                	add    %bh,(%rsi)
    3da0:	08 99 1c 00 00 00    	or     %bl,0x1c(%rcx)
    3da6:	00 00                	add    %al,(%rax)
    3da8:	40 84 01             	rex test %al,(%rcx)
    3dab:	63 00                	movsxd (%rax),%eax
    3dad:	00 00                	add    %al,(%rax)
    3daf:	3b fb                	cmp    %ebx,%edi
    3db1:	01 e1                	add    %esp,%ecx
    3db3:	1b 00                	sbb    (%rax),%eax
    3db5:	00 40 84             	add    %al,-0x7c(%rax)
    3db8:	01 1e                	add    %ebx,(%rsi)
    3dba:	00 00                	add    %al,(%rax)
    3dbc:	00 3b                	add    %bh,(%rbx)
    3dbe:	f9                   	stc
    3dbf:	01 ec                	add    %ebp,%esp
    3dc1:	1b 00                	sbb    (%rax),%eax
    3dc3:	00 41 0d             	add    %al,0xd(%rcx)
    3dc6:	f5                   	cmc
    3dc7:	1b 00                	sbb    (%rax),%eax
    3dc9:	00 3c 3e             	add    %bh,(%rsi,%rdi,1)
    3dcc:	17                   	(bad)
    3dcd:	00 00                	add    %al,(%rax)
    3dcf:	84 01                	test   %al,(%rcx)
    3dd1:	1e                   	(bad)
    3dd2:	00 00                	add    %al,(%rax)
    3dd4:	00 00                	add    %al,(%rax)
    3dd6:	95                   	xchg   %eax,%ebp
    3dd7:	02 1c 39             	add    (%rcx,%rdi,1),%bl
    3dda:	fa                   	cli
    3ddb:	01 48 17             	add    %ecx,0x17(%rax)
    3dde:	00 00                	add    %al,(%rax)
    3de0:	3d 04 91 d8 00       	cmp    $0xd89104,%eax
    3de5:	9f                   	lahf
    3de6:	52                   	push   %rdx
    3de7:	17                   	(bad)
    3de8:	00 00                	add    %al,(%rax)
    3dea:	00 00                	add    %al,(%rax)
    3dec:	40 85 01             	rex test %eax,(%rcx)
    3def:	40 00 00             	rex add %al,(%rax)
    3df2:	00 3b                	add    %bh,(%rbx)
    3df4:	fe 01                	incb   (%rcx)
    3df6:	00 1c 00             	add    %bl,(%rax,%rax,1)
    3df9:	00 3c 3e             	add    %bh,(%rsi,%rdi,1)
    3dfc:	17                   	(bad)
    3dfd:	00 00                	add    %al,(%rax)
    3dff:	86 01                	xchg   %al,(%rcx)
    3e01:	0f 00 00             	sldt   (%rax)
    3e04:	00 00                	add    %al,(%rax)
    3e06:	97                   	xchg   %eax,%edi
    3e07:	02 19                	add    (%rcx),%bl
    3e09:	39 fd                	cmp    %edi,%ebp
    3e0b:	01 48 17             	add    %ecx,0x17(%rax)
    3e0e:	00 00                	add    %al,(%rax)
    3e10:	39 fc                	cmp    %edi,%esp
    3e12:	01 52 17             	add    %edx,0x17(%rdx)
    3e15:	00 00                	add    %al,(%rax)
    3e17:	00 40 87             	add    %al,-0x79(%rax)
    3e1a:	01 1d 00 00 00 3e    	add    %ebx,0x3e000000(%rip)        # 3e003e20 <_license+0x3e001a8b>
    3e20:	8f 04 0b             	pop    (%rbx,%rcx,1)
    3e23:	1c 00                	sbb    $0x0,%al
    3e25:	00 3b                	add    %bh,(%rbx)
    3e27:	80 02 14             	addb   $0x14,(%rdx)
    3e2a:	1c 00                	sbb    $0x0,%al
    3e2c:	00 40 87             	add    %al,-0x79(%rax)
    3e2f:	01 0c 00             	add    %ecx,(%rax,%rax,1)
    3e32:	00 00                	add    %al,(%rax)
    3e34:	3b ff                	cmp    %edi,%edi
    3e36:	01 1f                	add    %ebx,(%rdi)
    3e38:	1c 00                	sbb    $0x0,%al
    3e3a:	00 41 06             	add    %al,0x6(%rcx)
    3e3d:	28 1c 00             	sub    %bl,(%rax,%rax,1)
    3e40:	00 40 87             	add    %al,-0x79(%rax)
    3e43:	01 0c 00             	add    %ecx,(%rax,%rax,1)
    3e46:	00 00                	add    %al,(%rax)
    3e48:	3e 8f 04 32          	ds pop (%rdx,%rsi,1)
    3e4c:	1c 00                	sbb    $0x0,%al
    3e4e:	00 3e                	add    %bh,(%rsi)
    3e50:	80 08 3b             	orb    $0x3b,(%rax)
    3e53:	1c 00                	sbb    $0x0,%al
    3e55:	00 3e                	add    %bh,(%rsi)
    3e57:	08 44 1c 00          	or     %al,0x0(%rsp,%rbx,1)
    3e5b:	00 00                	add    %al,(%rax)
    3e5d:	00 00                	add    %al,(%rax)
    3e5f:	00 00                	add    %al,(%rax)
    3e61:	00 40 88             	add    %al,-0x78(%rax)
    3e64:	01 23                	add    %esp,(%rbx)
    3e66:	00 00                	add    %al,(%rax)
    3e68:	00 3e                	add    %bh,(%rsi)
    3e6a:	81 04 66 0f 00 00 3b 	addl   $0x3b00000f,(%rsi,%riz,2)
    3e71:	95                   	xchg   %eax,%ebp
    3e72:	02 6f 0f             	add    0xf(%rdi),%ch
    3e75:	00 00                	add    %al,(%rax)
    3e77:	40 88 01             	rex mov %al,(%rcx)
    3e7a:	0c 00                	or     $0x0,%al
    3e7c:	00 00                	add    %al,(%rax)
    3e7e:	3b 94 02 79 0f 00 00 	cmp    0xf79(%rdx,%rax,1),%edx
    3e85:	41 06                	rex.B (bad)
    3e87:	82                   	(bad)
    3e88:	0f 00 00             	sldt   (%rax)
    3e8b:	40 88 01             	rex mov %al,(%rcx)
    3e8e:	0c 00                	or     $0x0,%al
    3e90:	00 00                	add    %al,(%rax)
    3e92:	3e 81 04 8c 0f 00 00 	ds addl $0x3e00000f,(%rsp,%rcx,4)
    3e99:	3e 
    3e9a:	80 08 95             	orb    $0x95,(%rax)
    3e9d:	0f 00 00             	sldt   (%rax)
    3ea0:	3e 08 9e 0f 00 00 00 	ds or  %bl,0xf(%rsi)
    3ea7:	00 00                	add    %al,(%rax)
    3ea9:	38 4f 1d             	cmp    %cl,0x1d(%rdi)
    3eac:	00 00                	add    %al,(%rax)
    3eae:	28 00                	sub    %al,(%rax)
    3eb0:	fb                   	sti
    3eb1:	03 0c 39             	add    (%rcx,%rdi,1),%ecx
    3eb4:	96                   	xchg   %eax,%esi
    3eb5:	02 61 1d             	add    0x1d(%rcx),%ah
    3eb8:	00 00                	add    %al,(%rax)
    3eba:	39 97 02 71 1d 00    	cmp    %edx,0x1d7102(%rdi)
    3ec0:	00 39                	add    %bh,(%rcx)
    3ec2:	98                   	cwtl
    3ec3:	02 79 1d             	add    0x1d(%rcx),%bh
    3ec6:	00 00                	add    %al,(%rax)
    3ec8:	3a 02                	cmp    (%rdx),%al
    3eca:	91                   	xchg   %eax,%ecx
    3ecb:	00 81 1d 00 00 3b    	add    %al,0x3b00001d(%rcx)
    3ed1:	99                   	cltd
    3ed2:	02 8a 1d 00 00 3b    	add    0x3b00001d(%rdx),%cl
    3ed8:	9a                   	(bad)
    3ed9:	02 93 1d 00 00 3b    	add    0x3b00001d(%rbx),%dl
    3edf:	9b                   	fwait
    3ee0:	02 9c 1d 00 00 3b 9f 	add    -0x60c50000(%rbp,%rbx,1),%bl
    3ee7:	02 a5 1d 00 00 3b    	add    0x3b00001d(%rbp),%ah
    3eed:	a0 02 ae 1d 00 00 3f 	movabs 0x1c533f00001dae02,%al
    3ef4:	53 1c 
    3ef6:	00 00                	add    %al,(%rax)
    3ef8:	89 01                	mov    %eax,(%rcx)
    3efa:	54                   	push   %rsp
    3efb:	00 00                	add    %al,(%rax)
    3efd:	00 00                	add    %al,(%rax)
    3eff:	66 11 3e             	adc    %di,(%rsi)
    3f02:	82                   	(bad)
    3f03:	04 65                	add    $0x65,%al
    3f05:	1c 00                	sbb    $0x0,%al
    3f07:	00 3b                	add    %bh,(%rbx)
    3f09:	9d                   	popf
    3f0a:	02 6e 1c             	add    0x1c(%rsi),%ch
    3f0d:	00 00                	add    %al,(%rax)
    3f0f:	40 89 01             	rex mov %eax,(%rcx)
    3f12:	0e                   	(bad)
    3f13:	00 00                	add    %al,(%rax)
    3f15:	00 3b                	add    %bh,(%rbx)
    3f17:	9c                   	pushf
    3f18:	02 78 1c             	add    0x1c(%rax),%bh
    3f1b:	00 00                	add    %al,(%rax)
    3f1d:	41 06                	rex.B (bad)
    3f1f:	80 1c 00 00          	sbbb   $0x0,(%rax,%rax,1)
    3f23:	40 89 01             	rex mov %eax,(%rcx)
    3f26:	0e                   	(bad)
    3f27:	00 00                	add    %al,(%rax)
    3f29:	00 3e                	add    %bh,(%rsi)
    3f2b:	82                   	(bad)
    3f2c:	04 89                	add    $0x89,%al
    3f2e:	1c 00                	sbb    $0x0,%al
    3f30:	00 3e                	add    %bh,(%rsi)
    3f32:	80 08 91             	orb    $0x91,(%rax)
    3f35:	1c 00                	sbb    $0x0,%al
    3f37:	00 3e                	add    %bh,(%rsi)
    3f39:	08 99 1c 00 00 00    	or     %bl,0x1c(%rcx)
    3f3f:	00 00                	add    %al,(%rax)
    3f41:	42 29 3b             	rex.X sub %edi,(%rbx)
    3f44:	9e                   	sahf
    3f45:	02 bf 1d 00 00 3f    	add    0x3f00001d(%rdi),%bh
    3f4b:	22 1e                	and    (%rsi),%bl
    3f4d:	00 00                	add    %al,(%rax)
    3f4f:	8a 01                	mov    (%rcx),%al
    3f51:	23 00                	and    (%rax),%eax
    3f53:	00 00                	add    %al,(%rax)
    3f55:	00 8f 0c 3d 03 91    	add    %cl,-0x6efcc2f4(%rdi)
    3f5b:	10 9f 2b 1e 00 00    	adc    %bl,0x1e2b(%rdi)
    3f61:	3d 02 31 9f 33       	cmp    $0x339f3102,%eax
    3f66:	1e                   	(bad)
    3f67:	00 00                	add    %al,(%rax)
    3f69:	00 40 8b             	add    %al,-0x75(%rax)
    3f6c:	01 05 00 00 00 3b    	add    %eax,0x3b000000(%rip)        # 3b003f72 <_license+0x3b001bdd>
    3f72:	a1 02 c9 1d 00 00 41 	movabs 0xd1024100001dc902,%eax
    3f79:	02 d1 
    3f7b:	1d 00 00 40 8b       	sbb    $0x8b400000,%eax
    3f80:	01 05 00 00 00 3a    	add    %eax,0x3a000000(%rip)        # 3a003f86 <_license+0x3a001bf1>
    3f86:	01 50 da             	add    %edx,-0x26(%rax)
    3f89:	1d 00 00 3e 80       	sbb    $0x803e0000,%eax
    3f8e:	84 80 10 e2 1d 00    	test   %al,0x1de210(%rax)
    3f94:	00 3e                	add    %bh,(%rsi)
    3f96:	08 ea                	or     %ch,%dl
    3f98:	1d 00 00 00 00       	sbb    $0x0,%eax
    3f9d:	3f                   	(bad)
    3f9e:	4f 1f                	rex.WRXB (bad)
    3fa0:	00 00                	add    %al,(%rax)
    3fa2:	8c 01                	mov    %es,(%rcx)
    3fa4:	1a 00                	sbb    (%rax),%al
    3fa6:	00 00                	add    %al,(%rax)
    3fa8:	00 9a 07 3e 89 04    	add    %bl,0x4893e07(%rdx)
    3fae:	54                   	push   %rsp
    3faf:	1f                   	(bad)
    3fb0:	00 00                	add    %al,(%rax)
    3fb2:	3b a9 02 5d 1f 00    	cmp    0x1f5d02(%rcx),%ebp
    3fb8:	00 40 8c             	add    %al,-0x74(%rax)
    3fbb:	01 0c 00             	add    %ecx,(%rax,%rax,1)
    3fbe:	00 00                	add    %al,(%rax)
    3fc0:	3b a8 02 67 1f 00    	cmp    0x1f6702(%rax),%ebp
    3fc6:	00 41 06             	add    %al,0x6(%rcx)
    3fc9:	6f                   	outsl  %ds:(%rsi),(%dx)
    3fca:	1f                   	(bad)
    3fcb:	00 00                	add    %al,(%rax)
    3fcd:	40 8c 01             	rex mov %es,(%rcx)
    3fd0:	0c 00                	or     $0x0,%al
    3fd2:	00 00                	add    %al,(%rax)
    3fd4:	3e 89 04 78          	ds mov %eax,(%rax,%rdi,2)
    3fd8:	1f                   	(bad)
    3fd9:	00 00                	add    %al,(%rax)
    3fdb:	3e 80 08 80          	ds orb $0x80,(%rax)
    3fdf:	1f                   	(bad)
    3fe0:	00 00                	add    %al,(%rax)
    3fe2:	3e 08 88 1f 00 00 00 	ds or  %cl,0x1f(%rax)
    3fe9:	00 00                	add    %al,(%rax)
    3feb:	00 40 8d             	add    %al,-0x73(%rax)
    3fee:	01 05 00 00 00 3b    	add    %eax,0x3b000000(%rip)        # 3b003ff4 <_license+0x3b001c5f>
    3ff4:	a2 02 f6 1d 00 00 41 	movabs %al,0xfe024100001df602
    3ffb:	02 fe 
    3ffd:	1d 00 00 40 8d       	sbb    $0x8d400000,%eax
    4002:	01 05 00 00 00 3a    	add    %eax,0x3a000000(%rip)        # 3a004008 <_license+0x3a001c73>
    4008:	01 50 07             	add    %edx,0x7(%rax)
    400b:	1e                   	(bad)
    400c:	00 00                	add    %al,(%rax)
    400e:	3e 80 20 0f          	ds andb $0xf,(%rax)
    4012:	1e                   	(bad)
    4013:	00 00                	add    %al,(%rax)
    4015:	3e 18 17             	ds sbb %dl,(%rdi)
    4018:	1e                   	(bad)
    4019:	00 00                	add    %al,(%rax)
    401b:	00 00                	add    %al,(%rax)
    401d:	3f                   	(bad)
    401e:	3d 1e 00 00 8e       	cmp    $0x8e00001e,%eax
    4023:	01 10                	add    %edx,(%rax)
    4025:	00 00                	add    %al,(%rax)
    4027:	00 00                	add    %al,(%rax)
    4029:	ab                   	stos   %eax,%es:(%rdi)
    402a:	05 3d 03 91 f8       	add    $0xf891033d,%eax
    402f:	00 47 1e             	add    %al,0x1e(%rdi)
    4032:	00 00                	add    %al,(%rax)
    4034:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    4039:	51                   	push   %rcx
    403a:	1e                   	(bad)
    403b:	00 00                	add    %al,(%rax)
    403d:	3d 01 57 5a 1e       	cmp    $0x1e5a5701,%eax
    4042:	00 00                	add    %al,(%rax)
    4044:	45 00 63 1e          	add    %r12b,0x1e(%r11)
    4048:	00 00                	add    %al,(%rax)
    404a:	00 3f                	add    %bh,(%rdi)
    404c:	93                   	xchg   %eax,%ebx
    404d:	1f                   	(bad)
    404e:	00 00                	add    %al,(%rax)
    4050:	8f 01                	pop    (%rcx)
    4052:	1a 00                	sbb    (%rax),%al
    4054:	00 00                	add    %al,(%rax)
    4056:	00 a3 05 3e 89 04    	add    %ah,0x4893e05(%rbx)
    405c:	98                   	cwtl
    405d:	1f                   	(bad)
    405e:	00 00                	add    %al,(%rax)
    4060:	3b ab 02 a1 1f 00    	cmp    0x1fa102(%rbx),%ebp
    4066:	00 40 8f             	add    %al,-0x71(%rax)
    4069:	01 0c 00             	add    %ecx,(%rax,%rax,1)
    406c:	00 00                	add    %al,(%rax)
    406e:	3b aa 02 ab 1f 00    	cmp    0x1fab02(%rdx),%ebp
    4074:	00 41 06             	add    %al,0x6(%rcx)
    4077:	b3 1f                	mov    $0x1f,%bl
    4079:	00 00                	add    %al,(%rax)
    407b:	40 8f 01             	rex pop (%rcx)
    407e:	0c 00                	or     $0x0,%al
    4080:	00 00                	add    %al,(%rax)
    4082:	3e 89 04 bc          	ds mov %eax,(%rsp,%rdi,4)
    4086:	1f                   	(bad)
    4087:	00 00                	add    %al,(%rax)
    4089:	3e 80 08 c4          	ds orb $0xc4,(%rax)
    408d:	1f                   	(bad)
    408e:	00 00                	add    %al,(%rax)
    4090:	3e 08 cc             	ds or  %cl,%ah
    4093:	1f                   	(bad)
    4094:	00 00                	add    %al,(%rax)
    4096:	00 00                	add    %al,(%rax)
    4098:	00 00                	add    %al,(%rax)
    409a:	3c 6d                	cmp    $0x6d,%al
    409c:	1e                   	(bad)
    409d:	00 00                	add    %al,(%rax)
    409f:	90                   	nop
    40a0:	01 a3 00 00 00 00    	add    %esp,0x0(%rbx)
    40a6:	00 04 0b             	add    %al,(%rbx,%rcx,1)
    40a9:	3d 04 91 d8 00       	cmp    $0xd89104,%eax
    40ae:	9f                   	lahf
    40af:	77 1e                	ja     40cf <_license+0x1d3a>
    40b1:	00 00                	add    %al,(%rax)
    40b3:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    40b8:	80 1e 00             	sbbb   $0x0,(%rsi)
    40bb:	00 3d 02 31 9f 92    	add    %bh,-0x6d60cefe(%rip)        # ffffffff929f71c3 <server_id_map+0x36ff7a30e1c3>
    40c1:	1e                   	(bad)
    40c2:	00 00                	add    %al,(%rax)
    40c4:	3b a3 02 9b 1e 00    	cmp    0x1e9b02(%rbx),%esp
    40ca:	00 3e                	add    %bh,(%rsi)
    40cc:	00 a5 1e 00 00 3b    	add    %ah,0x3b00001e(%rbp)
    40d2:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    40d3:	02 af 1e 00 00 3b    	add    0x3b00001e(%rdi),%ch
    40d9:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    40da:	02 b9 1e 00 00 40    	add    0x4000001e(%rcx),%bh
    40e0:	91                   	xchg   %eax,%ecx
    40e1:	01 32                	add    %esi,(%rdx)
    40e3:	00 00                	add    %al,(%rax)
    40e5:	00 3b                	add    %bh,(%rbx)
    40e7:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    40e8:	02 d8                	add    %al,%bl
    40ea:	1e                   	(bad)
    40eb:	00 00                	add    %al,(%rax)
    40ed:	40 92                	rex xchg %eax,%edx
    40ef:	01 1d 00 00 00 3b    	add    %ebx,0x3b000000(%rip)        # 3b0040f5 <_license+0x3b001d60>
    40f5:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    40f6:	02 ec                	add    %ah,%ch
    40f8:	1e                   	(bad)
    40f9:	00 00                	add    %al,(%rax)
    40fb:	41 06                	rex.B (bad)
    40fd:	f5                   	cmc
    40fe:	1e                   	(bad)
    40ff:	00 00                	add    %al,(%rax)
    4101:	40 92                	rex xchg %eax,%edx
    4103:	01 1d 00 00 00 3e    	add    %ebx,0x3e000000(%rip)        # 3e004109 <_license+0x3e001d74>
    4109:	80 20 ff             	andb   $0xff,(%rax)
    410c:	1e                   	(bad)
    410d:	00 00                	add    %al,(%rax)
    410f:	3e 08 08             	ds or  %cl,(%rax)
    4112:	1f                   	(bad)
    4113:	00 00                	add    %al,(%rax)
    4115:	00 00                	add    %al,(%rax)
    4117:	00 00                	add    %al,(%rax)
    4119:	42 2a 3b             	rex.X sub (%rbx),%dil
    411c:	81 02 ab 0f 00 00    	addl   $0xfab,(%rdx)
    4122:	3b 82 02 b4 0f 00    	cmp    0xfb402(%rdx),%eax
    4128:	00 42 2b             	add    %al,0x2b(%rdx)
    412b:	3b 83 02 be 0f 00    	cmp    0xfbe02(%rbx),%eax
    4131:	00 3b                	add    %bh,(%rbx)
    4133:	84 02                	test   %al,(%rdx)
    4135:	c7                   	(bad)
    4136:	0f 00 00             	sldt   (%rax)
    4139:	00 00                	add    %al,(%rax)
    413b:	40 93                	rex xchg %eax,%ebx
    413d:	01 28                	add    %ebp,(%rax)
    413f:	00 00                	add    %al,(%rax)
    4141:	00 3b                	add    %bh,(%rbx)
    4143:	86 02                	xchg   %al,(%rdx)
    4145:	dc 0f                	fmull  (%rdi)
    4147:	00 00                	add    %al,(%rax)
    4149:	41 06                	rex.B (bad)
    414b:	e5 0f                	in     $0xf,%eax
    414d:	00 00                	add    %al,(%rax)
    414f:	40 93                	rex xchg %eax,%ebx
    4151:	01 28                	add    %ebp,(%rax)
    4153:	00 00                	add    %al,(%rax)
    4155:	00 3b                	add    %bh,(%rbx)
    4157:	87 02                	xchg   %eax,(%rdx)
    4159:	ef                   	out    %eax,(%dx)
    415a:	0f 00 00             	sldt   (%rax)
    415d:	3b 88 02 f8 0f 00    	cmp    0xff802(%rax),%ecx
    4163:	00 00                	add    %al,(%rax)
    4165:	00 3c a4             	add    %bh,(%rsp,%riz,4)
    4168:	1c 00                	sbb    $0x0,%al
    416a:	00 94 01 e3 00 00 00 	add    %dl,0xe3(%rcx,%rax,1)
    4171:	00 29                	add    %ch,(%rcx)
    4173:	04 0a                	add    $0xa,%al
    4175:	3d 03 91 d0 00       	cmp    $0xd09103,%eax
    417a:	ad                   	lods   %ds:(%rsi),%eax
    417b:	1c 00                	sbb    $0x0,%al
    417d:	00 3d 03 91 10 9f    	add    %bh,-0x60ef6efd(%rip)        # ffffffff9f10d286 <server_id_map+0x36ff86a24286>
    4183:	bd 1c 00 00 3d       	mov    $0x3d00001c,%ebp
    4188:	01 5d c5             	add    %ebx,-0x3b(%rbp)
    418b:	1c 00                	sbb    $0x0,%al
    418d:	00 3b                	add    %bh,(%rbx)
    418f:	89 02                	mov    %eax,(%rdx)
    4191:	d5                   	(bad)
    4192:	1c 00                	sbb    $0x0,%al
    4194:	00 3b                	add    %bh,(%rbx)
    4196:	8a 02                	mov    (%rdx),%al
    4198:	de 1c 00             	ficomps (%rax,%rax,1)
    419b:	00 3b                	add    %bh,(%rbx)
    419d:	8b 02                	mov    (%rdx),%eax
    419f:	e6 1c                	out    %al,$0x1c
    41a1:	00 00                	add    %al,(%rax)
    41a3:	3b 8c 02 ee 1c 00 00 	cmp    0x1cee(%rdx,%rax,1),%ecx
    41aa:	3b 8d 02 f6 1c 00    	cmp    0x1cf602(%rbp),%ecx
    41b0:	00 3b                	add    %bh,(%rbx)
    41b2:	8e 02                	mov    (%rdx),%es
    41b4:	ff 1c 00             	lcall  *(%rax,%rax,1)
    41b7:	00 3b                	add    %bh,(%rbx)
    41b9:	8f 02                	pop    (%rdx)
    41bb:	07                   	(bad)
    41bc:	1d 00 00 3f 11       	sbb    $0x113f0000,%eax
    41c1:	1d 00 00 95 01       	sbb    $0x1950000,%eax
    41c6:	49 00 00             	rex.WB add %al,(%r8)
    41c9:	00 11                	add    %dl,(%rcx)
    41cb:	75 03                	jne    41d0 <_license+0x1e3b>
    41cd:	39 91 02 1e 1d 00    	cmp    %edx,0x1d1e02(%rcx)
    41d3:	00 39                	add    %bh,(%rcx)
    41d5:	90                   	nop
    41d6:	02 26                	add    (%rsi),%ah
    41d8:	1d 00 00 3d 01       	sbb    $0x13d0000,%eax
    41dd:	50                   	push   %rax
    41de:	2e 1d 00 00 45 04    	cs sbb $0x4450000,%eax
    41e4:	3e 1d 00 00 3e 00    	ds sbb $0x3e0000,%eax
    41ea:	46 1d 00 00 3f 0b    	rex.RX sbb $0xb3f0000,%eax
    41f0:	13 00                	adc    (%rax),%eax
    41f2:	00 96 01 20 00 00    	add    %dl,0x2001(%rsi)
    41f8:	00 12                	add    %dl,(%rdx)
    41fa:	48 03 3d 03 72 0e 9f 	add    -0x60f18dfd(%rip),%rdi        # ffffffff9f0eb404 <server_id_map+0x36ff86a02404>
    4201:	0f 13 00             	movlps %xmm0,(%rax)
    4204:	00 3b                	add    %bh,(%rbx)
    4206:	93                   	xchg   %eax,%ebx
    4207:	02 1f                	add    (%rdi),%bl
    4209:	13 00                	adc    (%rax),%eax
    420b:	00 40 96             	add    %al,-0x6a(%rax)
    420e:	01 20                	add    %esp,(%rax)
    4210:	00 00                	add    %al,(%rax)
    4212:	00 3b                	add    %bh,(%rbx)
    4214:	92                   	xchg   %eax,%edx
    4215:	02 28                	add    (%rax),%ch
    4217:	13 00                	adc    (%rax),%eax
    4219:	00 00                	add    %al,(%rax)
    421b:	00 00                	add    %al,(%rax)
    421d:	00 3c d7             	add    %bh,(%rdi,%rdx,8)
    4220:	1f                   	(bad)
    4221:	00 00                	add    %al,(%rax)
    4223:	97                   	xchg   %eax,%edi
    4224:	01 ae 00 00 00 00    	add    %ebp,0x0(%rsi)
    422a:	25 04 0a 3d 03       	and    $0x33d0a04,%eax
    422f:	91                   	xchg   %eax,%ecx
    4230:	d0 00                	rolb   (%rax)
    4232:	e0 1f                	loopne 4253 <_license+0x1ebe>
    4234:	00 00                	add    %al,(%rax)
    4236:	3d 02 31 9f f0       	cmp    $0xf09f3102,%eax
    423b:	1f                   	(bad)
    423c:	00 00                	add    %al,(%rax)
    423e:	3d 03 91 10 9f       	cmp    $0x9f109103,%eax
    4243:	f8                   	clc
    4244:	1f                   	(bad)
    4245:	00 00                	add    %al,(%rax)
    4247:	3d 01 5d 00 20       	cmp    $0x20005d01,%eax
    424c:	00 00                	add    %al,(%rax)
    424e:	39 ac 02 08 20 00 00 	cmp    %ebp,0x2008(%rdx,%rax,1)
    4255:	3b ad 02 10 20 00    	cmp    0x201002(%rbp),%ebp
    425b:	00 3b                	add    %bh,(%rbx)
    425d:	ae                   	scas   %es:(%rdi),%al
    425e:	02 18                	add    (%rax),%bl
    4260:	20 00                	and    %al,(%rax)
    4262:	00 3b                	add    %bh,(%rbx)
    4264:	af                   	scas   %es:(%rdi),%eax
    4265:	02 20                	add    (%rax),%ah
    4267:	20 00                	and    %al,(%rax)
    4269:	00 3b                	add    %bh,(%rbx)
    426b:	b0 02                	mov    $0x2,%al
    426d:	29 20                	sub    %esp,(%rax)
    426f:	00 00                	add    %al,(%rax)
    4271:	3b b1 02 31 20 00    	cmp    0x203102(%rcx),%esi
    4277:	00 3b                	add    %bh,(%rbx)
    4279:	b2 02                	mov    $0x2,%dl
    427b:	3a 20                	cmp    (%rax),%ah
    427d:	00 00                	add    %al,(%rax)
    427f:	3b b3 02 42 20 00    	cmp    0x204202(%rbx),%esi
    4285:	00 3b                	add    %bh,(%rbx)
    4287:	b4 02                	mov    $0x2,%ah
    4289:	4a 20 00             	rex.WX and %al,(%rax)
    428c:	00 47 5f             	add    %al,0x5f(%rdi)
    428f:	20 00                	and    %al,(%rax)
    4291:	00 98 01 04 00 00    	add    %bl,0x401(%rax)
    4297:	00 11                	add    %dl,(%rcx)
    4299:	4b 05 3f 7d 20 00    	rex.WXB add $0x207d3f,%rax
    429f:	00 99 01 2f 00 00    	add    %bl,0x2f01(%rcx)
    42a5:	00 11                	add    %dl,(%rcx)
    42a7:	53                   	push   %rbx
    42a8:	03 39                	add    (%rcx),%edi
    42aa:	b6 02                	mov    $0x2,%dh
    42ac:	8a 20                	mov    (%rax),%ah
    42ae:	00 00                	add    %al,(%rax)
    42b0:	3d 01 5d 9b 20       	cmp    $0x209b5d01,%eax
    42b5:	00 00                	add    %al,(%rax)
    42b7:	39 b5 02 a3 20 00    	cmp    %esi,0x20a302(%rbp)
    42bd:	00 45 29             	add    %al,0x29(%rbp)
    42c0:	ab                   	stos   %eax,%es:(%rdi)
    42c1:	20 00                	and    %al,(%rax)
    42c3:	00 00                	add    %al,(%rax)
    42c5:	00 00                	add    %al,(%rax)
    42c7:	48 87 0c 00          	xchg   %rcx,(%rax,%rax,1)
    42cb:	00 2c 00             	add    %ch,(%rax,%rax,1)
    42ce:	00 38                	add    %bh,(%rax)
    42d0:	93                   	xchg   %eax,%ebx
    42d1:	12 00                	adc    (%rax),%al
    42d3:	00 2d 00 c0 02 0c    	add    %ch,0xc02c000(%rip)        # c0302d9 <_license+0xc02df44>
    42d9:	3c 32                	cmp    $0x32,%al
    42db:	13 00                	adc    (%rax),%eax
    42dd:	00 9a 01 75 00 00    	add    %bl,0x7501(%rdx)
    42e3:	00 0e                	add    %cl,(%rsi)
    42e5:	5a                   	pop    %rdx
    42e6:	01 0c 3f             	add    %ecx,(%rdi,%rdi,1)
    42e9:	d0 14 00             	rclb   (%rax,%rax,1)
    42ec:	00 9a 01 75 00 00    	add    %bl,0x7501(%rdx)
    42f2:	00 0e                	add    %cl,(%rsi)
    42f4:	f0 0c 47             	lock or $0x47,%al
    42f7:	0a 15 00 00 9b 01    	or     0x19b0000(%rip),%dl        # 19b42fd <_license+0x19b1f68>
    42fd:	34 00                	xor    $0x0,%al
    42ff:	00 00                	add    %al,(%rax)
    4301:	0e                   	(bad)
    4302:	76 0a                	jbe    430e <_license+0x1f79>
    4304:	00 00                	add    %al,(%rax)
    4306:	3c 73                	cmp    $0x73,%al
    4308:	11 00                	adc    %eax,(%rax)
    430a:	00 9c 01 92 00 00 00 	add    %bl,0x92(%rcx,%rax,1)
    4311:	0e                   	(bad)
    4312:	5c                   	pop    %rsp
    4313:	01 0c 3c             	add    %ecx,(%rsp,%rdi,1)
    4316:	ca 12 00             	lret   $0x12
    4319:	00 9c 01 92 00 00 00 	add    %bl,0x92(%rcx,%rax,1)
    4320:	0e                   	(bad)
    4321:	1f                   	(bad)
    4322:	01 0c 3f             	add    %ecx,(%rdi,%rdi,1)
    4325:	0b 13                	or     (%rbx),%edx
    4327:	00 00                	add    %al,(%rax)
    4329:	9c                   	pushf
    432a:	01 60 00             	add    %esp,0x0(%rax)
    432d:	00 00                	add    %al,(%rax)
    432f:	0e                   	(bad)
    4330:	59                   	pop    %rcx
    4331:	03 47 6c             	add    0x6c(%rdi),%eax
    4334:	15 00 00 9d 01       	adc    $0x19d0000,%eax
    4339:	4e 00 00             	rex.WRX add %r8b,(%rax)
    433c:	00 0f                	add    %cl,(%rdi)
    433e:	3a 0b                	cmp    (%rbx),%cl
    4340:	00 47 0a             	add    %al,0xa(%rdi)
    4343:	15 00 00 9e 01       	adc    $0x19e0000,%eax
    4348:	2d 00 00 00 0e       	sub    $0xe000000,%eax
    434d:	5b                   	pop    %rbx
    434e:	0a 00                	or     (%rax),%al
    4350:	00 00                	add    %al,(%rax)
    4352:	3c a4                	cmp    $0xa4,%al
    4354:	1c 00                	sbb    $0x0,%al
    4356:	00 9f 01 66 00 00    	add    %bl,0x6601(%rdi)
    435c:	00 00                	add    %al,(%rax)
    435e:	29 04 0a             	sub    %eax,(%rdx,%rcx,1)
    4361:	3f                   	(bad)
    4362:	11 1d 00 00 9f 01    	adc    %ebx,0x19f0000(%rip)        # 19f4368 <_license+0x19f1fd3>
    4368:	66 00 00             	data16 add %al,(%rax)
    436b:	00 11                	add    %dl,(%rcx)
    436d:	75 03                	jne    4372 <_license+0x1fdd>
    436f:	3f                   	(bad)
    4370:	0b 13                	or     (%rbx),%edx
    4372:	00 00                	add    %al,(%rax)
    4374:	9f                   	lahf
    4375:	01 5d 00             	add    %ebx,0x0(%rbp)
    4378:	00 00                	add    %al,(%rax)
    437a:	12 48 03             	adc    0x3(%rax),%cl
    437d:	47 6c                	rex.RXB insb (%dx),%es:(%rdi)
    437f:	15 00 00 a0 01       	adc    $0x1a00000,%eax
    4384:	4e 00 00             	rex.WRX add %r8b,(%rax)
    4387:	00 0f                	add    %cl,(%rdi)
    4389:	3a 0b                	cmp    (%rbx),%cl
    438b:	00 00                	add    %al,(%rax)
    438d:	00 3c d7             	add    %bh,(%rdi,%rdx,8)
    4390:	1f                   	(bad)
    4391:	00 00                	add    %al,(%rax)
    4393:	a1 01 27 00 00 00 00 	movabs 0x425000000002701,%eax
    439a:	25 04 
    439c:	0a 47 7d             	or     0x7d(%rdi),%al
    439f:	20 00                	and    %al,(%rax)
    43a1:	00 a1 01 27 00 00    	add    %ah,0x2701(%rcx)
    43a7:	00 11                	add    %dl,(%rcx)
    43a9:	53                   	push   %rbx
    43aa:	03 00                	add    (%rax),%eax
    43ac:	3c 4f                	cmp    $0x4f,%al
    43ae:	1d 00 00 a2 01       	sbb    $0x1a20000,%eax
    43b3:	07                   	(bad)
    43b4:	00 00                	add    %al,(%rax)
    43b6:	00 00                	add    %al,(%rax)
    43b8:	fb                   	sti
    43b9:	03 0c 47             	add    (%rdi,%rax,2),%ecx
    43bc:	4f 1f                	rex.WRXB (bad)
    43be:	00 00                	add    %al,(%rax)
    43c0:	a2 01 04 00 00 00 00 	movabs %al,0x79a000000000401
    43c7:	9a 07 
    43c9:	00 00                	add    %al,(%rax)
    43cb:	49 01 52 a3          	add    %rdx,-0x5d(%r10)
    43cf:	01 49 01             	add    %ecx,0x1(%rcx)
    43d2:	50                   	push   %rax
    43d3:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
    43d4:	01 49 01             	add    %ecx,0x1(%rcx)
    43d7:	52                   	push   %rdx
    43d8:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    43d9:	01 49 01             	add    %ecx,0x1(%rcx)
    43dc:	50                   	push   %rax
    43dd:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
    43de:	01 49 01             	add    %ecx,0x1(%rcx)
    43e1:	50                   	push   %rax
    43e2:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
    43e3:	01 49 01             	add    %ecx,0x1(%rcx)
    43e6:	50                   	push   %rax
    43e7:	a8 01                	test   $0x1,%al
    43e9:	49 01 52 a9          	add    %rdx,-0x57(%r10)
    43ed:	01 49 01             	add    %ecx,0x1(%rcx)
    43f0:	50                   	push   %rax
    43f1:	aa                   	stos   %al,%es:(%rdi)
    43f2:	01 49 01             	add    %ecx,0x1(%rcx)
    43f5:	50                   	push   %rax
    43f6:	ab                   	stos   %eax,%es:(%rdi)
    43f7:	01 49 01             	add    %ecx,0x1(%rcx)
    43fa:	50                   	push   %rax
    43fb:	ac                   	lods   %ds:(%rsi),%al
    43fc:	01 49 01             	add    %ecx,0x1(%rcx)
    43ff:	50                   	push   %rax
    4400:	ad                   	lods   %ds:(%rsi),%eax
    4401:	01 49 01             	add    %ecx,0x1(%rcx)
    4404:	50                   	push   %rax
    4405:	ae                   	scas   %es:(%rdi),%al
    4406:	01 49 01             	add    %ecx,0x1(%rcx)
    4409:	50                   	push   %rax
    440a:	af                   	scas   %es:(%rdi),%eax
    440b:	01 49 01             	add    %ecx,0x1(%rcx)
    440e:	50                   	push   %rax
    440f:	b0 01                	mov    $0x1,%al
    4411:	49 01 50 b1          	add    %rdx,-0x4f(%r8)
    4415:	01 49 01             	add    %ecx,0x1(%rcx)
    4418:	50                   	push   %rax
    4419:	b2 01                	mov    $0x1,%dl
    441b:	49 01 50 b3          	add    %rdx,-0x4d(%r8)
    441f:	01 49 01             	add    %ecx,0x1(%rcx)
    4422:	50                   	push   %rax
    4423:	b4 01                	mov    $0x1,%ah
    4425:	49 01 50 b5          	add    %rdx,-0x4b(%r8)
    4429:	01 49 01             	add    %ecx,0x1(%rcx)
    442c:	50                   	push   %rax
    442d:	b6 01                	mov    $0x1,%dh
    442f:	49 01 50 b7          	add    %rdx,-0x49(%r8)
    4433:	01 49 01             	add    %ecx,0x1(%rcx)
    4436:	52                   	push   %rdx
    4437:	b8 01 49 01 50       	mov    $0x50014901,%eax
    443c:	b9 01 49 01 50       	mov    $0x50014901,%ecx
    4441:	ba 01 49 01 50       	mov    $0x50014901,%edx
    4446:	bb 01 49 01 50       	mov    $0x50014901,%ebx
    444b:	bc 01 49 01 50       	mov    $0x50014901,%esp
    4450:	bd 01 49 01 50       	mov    $0x50014901,%ebp
    4455:	be 01 49 01 50       	mov    $0x50014901,%esi
    445a:	bf 01 49 01 52       	mov    $0x52014901,%edi
    445f:	c0 01 49             	rolb   $0x49,(%rcx)
    4462:	01 50 c1             	add    %edx,-0x3f(%rax)
    4465:	01 49 01             	add    %ecx,0x1(%rcx)
    4468:	50                   	push   %rax
    4469:	c2 01 49             	ret    $0x4901
    446c:	01 50 c3             	add    %edx,-0x3d(%rax)
    446f:	01 49 01             	add    %ecx,0x1(%rcx)
    4472:	50                   	push   %rax
    4473:	c4 01 49 01          	(bad)
    4477:	50                   	push   %rax
    4478:	c5 01 49             	(bad)
    447b:	01 50 c6             	add    %edx,-0x3a(%rax)
    447e:	01 49 01             	add    %ecx,0x1(%rcx)
    4481:	50                   	push   %rax
    4482:	c7 01 49 01 50 c8    	movl   $0xc8500149,(%rcx)
    4488:	01 49 01             	add    %ecx,0x1(%rcx)
    448b:	50                   	push   %rax
    448c:	c9                   	leave
    448d:	01 00                	add    %eax,(%rax)
    448f:	2a 6e 01             	sub    0x1(%rsi),%ch
    4492:	0d 66 7f 0c 00       	or     $0xc7f66,%eax
    4497:	00 2f                	add    %ch,(%rdi)
    4499:	6f                   	outsl  %ds:(%rsi),(%dx)
    449a:	01 0d 66 7f 0c 00    	add    %ecx,0xc7f66(%rip)        # cc406 <_license+0xca071>
    44a0:	00 2f                	add    %ch,(%rdi)
    44a2:	70 01                	jo     44a5 <_license+0x2110>
    44a4:	0d 66 7f 0c 00       	or     $0xc7f66,%eax
    44a9:	00 2f                	add    %ch,(%rdi)
    44ab:	71 01                	jno    44ae <_license+0x2119>
    44ad:	0d 66 7f 0c 00       	or     $0xc7f66,%eax
    44b2:	00 2f                	add    %ch,(%rdi)
    44b4:	72 01                	jb     44b7 <_license+0x2122>
    44b6:	0d 66 7f 0c 00       	or     $0xc7f66,%eax
    44bb:	00 00                	add    %al,(%rax)
    44bd:	2a 73 01             	sub    0x1(%rbx),%dh
    44c0:	0d 07 bf 00 00       	or     $0xbf07,%eax
    44c5:	00 2f                	add    %ch,(%rdi)
    44c7:	74 01                	je     44ca <_license+0x2135>
    44c9:	0d 07 bf 00 00       	or     $0xbf07,%eax
    44ce:	00 2f                	add    %ch,(%rdi)
    44d0:	75 01                	jne    44d3 <_license+0x213e>
    44d2:	0d 07 c7 00 00       	or     $0xc707,%eax
    44d7:	00 00                	add    %al,(%rax)
    44d9:	4a ca 01 51          	rex.WX lretq $0x5101
    44dd:	00 00                	add    %al,(%rax)
    44df:	00 01                	add    %al,(%rcx)
    44e1:	57                   	push   %rdi
    44e2:	7c 01                	jl     44e5 <_license+0x2150>
    44e4:	0d 6e 03 7f 0c       	or     $0xc7f036e,%eax
    44e9:	00 00                	add    %al,(%rax)
    44eb:	4b 8d 03             	rex.WXB lea (%r11),%rax
    44ee:	6f                   	outsl  %ds:(%rsi),(%dx)
    44ef:	01 0d 6e 7f 0c 00    	add    %ecx,0xc7f6e(%rip)        # cc463 <_license+0xca0ce>
    44f5:	00 4b 8e             	add    %cl,-0x72(%rbx)
    44f8:	03 70 01             	add    0x1(%rax),%esi
    44fb:	0d 6e 7f 0c 00       	or     $0xc7f6e,%eax
    4500:	00 4b 91             	add    %cl,-0x6f(%rbx)
    4503:	03 72 01             	add    0x1(%rdx),%esi
    4506:	0d 6e 7f 0c 00       	or     $0xc7f6e,%eax
    450b:	00 3f                	add    %bh,(%rdi)
    450d:	8f 44 00 00          	pop    0x0(%rax,%rax,1)
    4511:	ca 01 50             	lret   $0x5001
    4514:	00 00                	add    %al,(%rax)
    4516:	00 0d 6f 0a 39 8f    	add    %cl,-0x70c6f591(%rip)        # ffffffff8f394f8b <server_id_map+0x36ff76cabf8b>
    451c:	03 98 44 00 00 39    	add    0x39000044(%rax),%ebx
    4522:	90                   	nop
    4523:	03 a1 44 00 00 39    	add    0x39000044(%rcx),%esp
    4529:	92                   	xchg   %eax,%edx
    452a:	03 aa 44 00 00 39    	add    0x39000044(%rdx),%ebp
    4530:	93                   	xchg   %eax,%ebx
    4531:	03 b3 44 00 00 3f    	add    0x3f000044(%rbx),%esi
    4537:	bd 44 00 00 cb       	mov    $0xcb000044,%ebp
    453c:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d004542 <_license+0xd0021ad>
    4542:	6a 03                	push   $0x3
    4544:	3d 01 54 c6 44       	cmp    $0x44c65401,%eax
    4549:	00 00                	add    %al,(%rax)
    454b:	45 0e                	rex.RB (bad)
    454d:	cf                   	iret
    454e:	44 00 00             	add    %r8b,(%rax)
    4551:	00 3f                	add    %bh,(%rdi)
    4553:	bd 44 00 00 cc       	mov    $0xcc000044,%ebp
    4558:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d00455e <_license+0xd0021c9>
    455e:	6a 03                	push   $0x3
    4560:	3d 01 50 c6 44       	cmp    $0x44c65001,%eax
    4565:	00 00                	add    %al,(%rax)
    4567:	45 0b cf             	or     %r15d,%r9d
    456a:	44 00 00             	add    %r8b,(%rax)
    456d:	00 3f                	add    %bh,(%rdi)
    456f:	bd 44 00 00 cd       	mov    $0xcd000044,%ebp
    4574:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d00457a <_license+0xd0021e5>
    457a:	6a 03                	push   $0x3
    457c:	3d 01 55 c6 44       	cmp    $0x44c65501,%eax
    4581:	00 00                	add    %al,(%rax)
    4583:	45 19 cf             	sbb    %r9d,%r15d
    4586:	44 00 00             	add    %r8b,(%rax)
    4589:	00 3f                	add    %bh,(%rdi)
    458b:	bd 44 00 00 ce       	mov    $0xce000044,%ebp
    4590:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d004596 <_license+0xd002201>
    4596:	6a 03                	push   $0x3
    4598:	3d 01 54 c6 44       	cmp    $0x44c65401,%eax
    459d:	00 00                	add    %al,(%rax)
    459f:	45 10 cf             	adc    %r9b,%r15b
    45a2:	44 00 00             	add    %r8b,(%rax)
    45a5:	00 3f                	add    %bh,(%rdi)
    45a7:	bd 44 00 00 cf       	mov    $0xcf000044,%ebp
    45ac:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d0045b2 <_license+0xd00221d>
    45b2:	6a 03                	push   $0x3
    45b4:	3d 01 50 c6 44       	cmp    $0x44c65001,%eax
    45b9:	00 00                	add    %al,(%rax)
    45bb:	45 04 cf             	rex.RB add $0xcf,%al
    45be:	44 00 00             	add    %r8b,(%rax)
    45c1:	00 3f                	add    %bh,(%rdi)
    45c3:	bd 44 00 00 d0       	mov    $0xd0000044,%ebp
    45c8:	01 03                	add    %eax,(%rbx)
    45ca:	00 00                	add    %al,(%rax)
    45cc:	00 0d 6a 03 3d 01    	add    %cl,0x13d036a(%rip)        # 13d493c <_license+0x13d25a7>
    45d2:	55                   	push   %rbp
    45d3:	c6 44 00 00 45       	movb   $0x45,0x0(%rax,%rax,1)
    45d8:	0e                   	(bad)
    45d9:	cf                   	iret
    45da:	44 00 00             	add    %r8b,(%rax)
    45dd:	00 3f                	add    %bh,(%rdi)
    45df:	bd 44 00 00 d1       	mov    $0xd1000044,%ebp
    45e4:	01 03                	add    %eax,(%rbx)
    45e6:	00 00                	add    %al,(%rax)
    45e8:	00 0d 6a 03 3d 01    	add    %cl,0x13d036a(%rip)        # 13d4958 <_license+0x13d25c3>
    45ee:	54                   	push   %rsp
    45ef:	c6 44 00 00 45       	movb   $0x45,0x0(%rax,%rax,1)
    45f4:	18 cf                	sbb    %cl,%bh
    45f6:	44 00 00             	add    %r8b,(%rax)
    45f9:	00 00                	add    %al,(%rax)
    45fb:	00 4a d2             	add    %cl,-0x2e(%rdx)
    45fe:	01 d5                	add    %edx,%ebp
    4600:	00 00                	add    %al,(%rax)
    4602:	00 01                	add    %al,(%rcx)
    4604:	57                   	push   %rdi
    4605:	7d 01                	jge    4608 <_license+0x2273>
    4607:	0d 37 03 7f 0c       	or     $0xc7f0337,%eax
    460c:	00 00                	add    %al,(%rax)
    460e:	4c 94                	rex.WR xchg %rax,%rsp
    4610:	03 09                	add    (%rcx),%ecx
    4612:	0d 37 c0 47 00       	or     $0x47c037,%eax
    4617:	00 4b 96             	add    %cl,-0x6a(%rbx)
    461a:	03 7f 01             	add    0x1(%rdi),%edi
    461d:	0d 37 7f 0c 00       	or     $0xc7f37,%eax
    4622:	00 4b 95             	add    %cl,-0x6b(%rbx)
    4625:	03 72 01             	add    0x1(%rdx),%esi
    4628:	0d 37 7f 0c 00       	or     $0xc7f37,%eax
    462d:	00 4d 97             	add    %cl,-0x69(%rbp)
    4630:	03 80 01 0d 39 c6    	add    -0x39c6f2ff(%rax),%eax
    4636:	47 00 00             	rex.RXB add %r8b,(%r8)
    4639:	4d 98                	rex.WRB cltq
    463b:	03 6f 01             	add    0x1(%rdi),%ebp
    463e:	0d 38 7f 0c 00       	or     $0xc7f38,%eax
    4643:	00 4d 99             	add    %cl,-0x67(%rbp)
    4646:	03 71 01             	add    0x1(%rcx),%esi
    4649:	0d 38 7f 0c 00       	or     $0xc7f38,%eax
    464e:	00 4d 9a             	add    %cl,-0x66(%rbp)
    4651:	03 70 01             	add    0x1(%rax),%esi
    4654:	0d 38 7f 0c 00       	or     $0xc7f38,%eax
    4659:	00 3f                	add    %bh,(%rdi)
    465b:	bd 44 00 00 d3       	mov    $0xd3000044,%ebp
    4660:	01 04 00             	add    %eax,(%rax,%rax,1)
    4663:	00 00                	add    %al,(%rax)
    4665:	0d 41 05 3d 01       	or     $0x13d0541,%eax
    466a:	59                   	pop    %rcx
    466b:	c6 44 00 00 45       	movb   $0x45,0x0(%rax,%rax,1)
    4670:	04 cf                	add    $0xcf,%al
    4672:	44 00 00             	add    %r8b,(%rax)
    4675:	00 3f                	add    %bh,(%rdi)
    4677:	bd 44 00 00 d4       	mov    $0xd4000044,%ebp
    467c:	01 06                	add    %eax,(%rsi)
    467e:	00 00                	add    %al,(%rax)
    4680:	00 0d 41 05 3d 01    	add    %cl,0x13d0541(%rip)        # 13d4bc7 <_license+0x13d2832>
    4686:	59                   	pop    %rcx
    4687:	c6 44 00 00 45       	movb   $0x45,0x0(%rax,%rax,1)
    468c:	06                   	(bad)
    468d:	cf                   	iret
    468e:	44 00 00             	add    %r8b,(%rax)
    4691:	00 3f                	add    %bh,(%rdi)
    4693:	bd 44 00 00 d5       	mov    $0xd5000044,%ebp
    4698:	01 03                	add    %eax,(%rbx)
    469a:	00 00                	add    %al,(%rax)
    469c:	00 0d 41 05 3d 01    	add    %cl,0x13d0541(%rip)        # 13d4be3 <_license+0x13d284e>
    46a2:	52                   	push   %rdx
    46a3:	c6 44 00 00 45       	movb   $0x45,0x0(%rax,%rax,1)
    46a8:	08 cf                	or     %cl,%bh
    46aa:	44 00 00             	add    %r8b,(%rax)
    46ad:	00 3f                	add    %bh,(%rdi)
    46af:	bd 44 00 00 d6       	mov    $0xd6000044,%ebp
    46b4:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d0046ba <_license+0xd002325>
    46ba:	41 05 3d 01 52 c6    	rex.B add $0xc652013d,%eax
    46c0:	44 00 00             	add    %r8b,(%rax)
    46c3:	45 10 cf             	adc    %r9b,%r15b
    46c6:	44 00 00             	add    %r8b,(%rax)
    46c9:	00 3f                	add    %bh,(%rdi)
    46cb:	bd 44 00 00 d7       	mov    $0xd7000044,%ebp
    46d0:	01 07                	add    %eax,(%rdi)
    46d2:	00 00                	add    %al,(%rax)
    46d4:	00 0d 41 05 3d 01    	add    %cl,0x13d0541(%rip)        # 13d4c1b <_license+0x13d2886>
    46da:	54                   	push   %rsp
    46db:	c6 44 00 00 45       	movb   $0x45,0x0(%rax,%rax,1)
    46e0:	13 cf                	adc    %edi,%ecx
    46e2:	44 00 00             	add    %r8b,(%rax)
    46e5:	00 3f                	add    %bh,(%rdi)
    46e7:	bd 44 00 00 d8       	mov    $0xd8000044,%ebp
    46ec:	01 04 00             	add    %eax,(%rax,%rax,1)
    46ef:	00 00                	add    %al,(%rax)
    46f1:	0d 41 05 45 04       	or     $0x4450541,%eax
    46f6:	cf                   	iret
    46f7:	44 00 00             	add    %r8b,(%rax)
    46fa:	00 3f                	add    %bh,(%rdi)
    46fc:	bd 44 00 00 d9       	mov    $0xd9000044,%ebp
    4701:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d004707 <_license+0xd002372>
    4707:	5e                   	pop    %rsi
    4708:	07                   	(bad)
    4709:	3d 01 50 c6 44       	cmp    $0x44c65001,%eax
    470e:	00 00                	add    %al,(%rax)
    4710:	45 0e                	rex.RB (bad)
    4712:	cf                   	iret
    4713:	44 00 00             	add    %r8b,(%rax)
    4716:	00 3f                	add    %bh,(%rdi)
    4718:	bd 44 00 00 da       	mov    $0xda000044,%ebp
    471d:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d004723 <_license+0xd00238e>
    4723:	5e                   	pop    %rsi
    4724:	07                   	(bad)
    4725:	3d 01 52 c6 44       	cmp    $0x44c65201,%eax
    472a:	00 00                	add    %al,(%rax)
    472c:	45 0b cf             	or     %r15d,%r9d
    472f:	44 00 00             	add    %r8b,(%rax)
    4732:	00 3f                	add    %bh,(%rdi)
    4734:	bd 44 00 00 db       	mov    $0xdb000044,%ebp
    4739:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d00473f <_license+0xd0023aa>
    473f:	5e                   	pop    %rsi
    4740:	07                   	(bad)
    4741:	3d 01 51 c6 44       	cmp    $0x44c65101,%eax
    4746:	00 00                	add    %al,(%rax)
    4748:	45 19 cf             	sbb    %r9d,%r15d
    474b:	44 00 00             	add    %r8b,(%rax)
    474e:	00 3f                	add    %bh,(%rdi)
    4750:	bd 44 00 00 dc       	mov    $0xdc000044,%ebp
    4755:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d00475b <_license+0xd0023c6>
    475b:	5e                   	pop    %rsi
    475c:	07                   	(bad)
    475d:	3d 01 50 c6 44       	cmp    $0x44c65001,%eax
    4762:	00 00                	add    %al,(%rax)
    4764:	45 10 cf             	adc    %r9b,%r15b
    4767:	44 00 00             	add    %r8b,(%rax)
    476a:	00 3f                	add    %bh,(%rdi)
    476c:	bd 44 00 00 dd       	mov    $0xdd000044,%ebp
    4771:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d004777 <_license+0xd0023e2>
    4777:	5e                   	pop    %rsi
    4778:	07                   	(bad)
    4779:	3d 01 52 c6 44       	cmp    $0x44c65201,%eax
    477e:	00 00                	add    %al,(%rax)
    4780:	45 04 cf             	rex.RB add $0xcf,%al
    4783:	44 00 00             	add    %r8b,(%rax)
    4786:	00 3f                	add    %bh,(%rdi)
    4788:	bd 44 00 00 de       	mov    $0xde000044,%ebp
    478d:	01 03                	add    %eax,(%rbx)
    478f:	00 00                	add    %al,(%rax)
    4791:	00 0d 5e 07 3d 01    	add    %cl,0x13d075e(%rip)        # 13d4ef5 <_license+0x13d2b60>
    4797:	51                   	push   %rcx
    4798:	c6 44 00 00 45       	movb   $0x45,0x0(%rax,%rax,1)
    479d:	0e                   	(bad)
    479e:	cf                   	iret
    479f:	44 00 00             	add    %r8b,(%rax)
    47a2:	00 3f                	add    %bh,(%rdi)
    47a4:	bd 44 00 00 df       	mov    $0xdf000044,%ebp
    47a9:	01 05 00 00 00 0d    	add    %eax,0xd000000(%rip)        # d0047af <_license+0xd00241a>
    47af:	5e                   	pop    %rsi
    47b0:	07                   	(bad)
    47b1:	3d 01 50 c6 44       	cmp    $0x44c65001,%eax
    47b6:	00 00                	add    %al,(%rax)
    47b8:	45 18 cf             	sbb    %r9b,%r15b
    47bb:	44 00 00             	add    %r8b,(%rax)
    47be:	00 00                	add    %al,(%rax)
    47c0:	0b c5                	or     %ebp,%eax
    47c2:	47 00 00             	rex.RXB add %r8b,(%r8)
    47c5:	4e 0b cb             	rex.WRX or %rbx,%r9
    47c8:	47 00 00             	rex.RXB add %r8b,(%r8)
    47cb:	23 1e                	and    (%rsi),%ebx
    47cd:	01 00                	add    %eax,(%rax)
	...

Disassembly of section .debug_rnglists:

0000000000000000 <.debug_rnglists>:
  void* data = (void*)(long)ctx->data;
   0:	f9                   	stc
   1:	03 00                	add    (%rax),%eax
   3:	00 05 00 08 00 2f    	add    %al,0x2f000800(%rip)        # 2f000809 <_license+0x2effe474>
   9:	00 00                	add    %al,(%rax)
   b:	00 bc 00 00 00 fa 00 	add    %bh,0xfa0000(%rax,%rax,1)
  12:	00 00                	add    %al,(%rax)
  14:	0c 01                	or     $0x1,%al
  16:	00 00                	add    %al,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
  18:	28 01                	sub    %al,(%rcx)
  1a:	00 00                	add    %al,(%rax)
  if (data + nh_off > data_end) {
  1c:	35 01 00 00 47       	xor    $0x47000001,%eax
  21:	01 00                	add    %eax,(%rax)
  23:	00 54 01 00          	add    %dl,0x0(%rcx,%rax,1)
  27:	00 61 01             	add    %ah,0x1(%rcx)
  2a:	00 00                	add    %al,(%rax)
  2c:	6e                   	outsb  %ds:(%rsi),(%dx)
  2d:	01 00                	add    %eax,(%rax)
  eth_proto = eth->h_proto; 
  2f:	00 7b 01             	add    %bh,0x1(%rbx)
  32:	00 00                	add    %al,(%rax)
  34:	88 01                	mov    %al,(%rcx)
  36:	00 00                	add    %al,(%rax)
  38:	95                   	xchg   %eax,%ebp
  if (eth_proto == BE_ETH_P_IP) {
  39:	01 00                	add    %eax,(%rax)
  3b:	00 a2 01 00 00 be    	add    %ah,-0x41ffffff(%rdx)
  41:	01 00                	add    %eax,(%rax)
  43:	00 d0                	add    %dl,%al
  45:	01 00                	add    %eax,(%rax)
  47:	00 dd                	add    %bl,%ch
  49:	01 00                	add    %eax,(%rax)
  4b:	00 ef                	add    %ch,%bh
  struct packet_description pckt = {};
  4d:	01 00                	add    %eax,(%rax)
  4f:	00 fc                	add    %bh,%ah
  51:	01 00                	add    %eax,(%rax)
  53:	00 0e                	add    %cl,(%rsi)
  55:	02 00                	add    (%rax),%al
  57:	00 1b                	add    %bl,(%rbx)
  59:	02 00                	add    (%rax),%al
  5b:	00 2d 02 00 00 3a    	add    %ch,0x3a000002(%rip)        # 3a000063 <_license+0x39ffdcce>
  61:	02 00                	add    (%rax),%al
  63:	00 47 02             	add    %al,0x2(%rdi)
  66:	00 00                	add    %al,(%rax)
  68:	7c 02                	jl     6c <balancer_ingress+0x6c>
  6a:	00 00                	add    %al,(%rax)
  6c:	89 02                	mov    %eax,(%rdx)
  6e:	00 00                	add    %al,(%rax)
  70:	a0 02 00 00 ad 02 00 	movabs 0xba000002ad000002,%al
  77:	00 ba 
  79:	02 00                	add    (%rax),%al
  7b:	00 c7                	add    %al,%bh
  7d:	02 00                	add    (%rax),%al
  7f:	00 d4                	add    %dl,%ah
  81:	02 00                	add    (%rax),%al
  struct vip_definition vip = {};
  83:	00 e1                	add    %ah,%cl
  85:	02 00                	add    (%rax),%al
  87:	00 ee                	add    %ch,%dh
  89:	02 00                	add    (%rax),%al
  8b:	00 fb                	add    %bh,%bl
  8d:	02 00                	add    (%rax),%al
  8f:	00 08                	add    %cl,(%rax)
  91:	03 00                	add    (%rax),%eax
  93:	00 1f                	add    %bl,(%rdi)
  95:	03 00                	add    (%rax),%eax
  97:	00 31                	add    %dh,(%rcx)
  99:	03 00                	add    (%rax),%eax
  9b:	00 3e                	add    %bh,(%rsi)
    if (iph + 1 > data_end) {
  9d:	03 00                	add    (%rax),%eax
  9f:	00 4b 03             	add    %cl,0x3(%rbx)
  a2:	00 00                	add    %al,(%rax)
  a4:	58                   	pop    %rax
  a5:	03 00                	add    (%rax),%eax
  a7:	00 6a 03             	add    %ch,0x3(%rdx)
    if (iph->ihl != 5) {
  aa:	00 00                	add    %al,(%rax)
  ac:	77 03                	ja     b1 <balancer_ingress+0xb1>
  ae:	00 00                	add    %al,(%rax)
  b0:	84 03                	test   %al,(%rbx)
  b2:	00 00                	add    %al,(%rax)
  b4:	91                   	xchg   %eax,%ecx
  b5:	03 00                	add    (%rax),%eax
    pckt->tos = iph->tos;
  b7:	00 a3 03 00 00 b5    	add    %ah,-0x4afffffd(%rbx)
  bd:	03 00                	add    (%rax),%eax
  bf:	00 d6                	add    %dl,%dh
    *protocol = iph->protocol;
  c1:	03 00                	add    (%rax),%eax
  c3:	00 e3                	add    %ah,%bl
    pckt->flow.proto = *protocol;
  c5:	03 00                	add    (%rax),%eax
  c7:	00 01                	add    %al,(%rcx)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  c9:	14 04                	adc    $0x4,%al
  cb:	4d d8 02             	rex.WRB fadds (%r10)
  ce:	04 a5                	add    $0xa5,%al
  d0:	08 db                	or     %bl,%bl
  d2:	09 04 a6             	or     %eax,(%rsi,%riz,4)
  d5:	13 97 14 04 d5 14    	adc    0x14d50414(%rdi),%edx
  db:	c4                   	(bad)
  dc:	1d 04 92 1f d0       	sbb    $0xd01f9204,%eax
    if (*protocol == IPPROTO_ICMP) {
  e1:	1f                   	(bad)
  e2:	04 8c                	add    $0x8c,%al
  e4:	20 a2 22 04 f5 22    	and    %ah,0x22f50422(%rdx)
  if (icmp_hdr + 1 > data_end) {
  ea:	cb                   	lret
  eb:	23 04 b0             	and    (%rax,%rsi,4),%eax
  ee:	32 af 34 04 b8 34    	xor    0x34b80434(%rdi),%ch
  f4:	91                   	xchg   %eax,%ecx
  if (icmp_hdr->type == ICMP_ECHO) {
  f5:	3a 04 f7             	cmp    (%rdi,%rsi,8),%al
  f8:	3a 94 3f 04 bc 3f ee 	cmp    -0x11c043fc(%rdi,%rdi,1),%dl
  ff:	40 04 84             	rex add $0x84,%al
 102:	43 d3 44 00 01       	roll   %cl,0x1(%r8,%r8,1)
 107:	14 04                	adc    $0x4,%al
 109:	9d                   	popf
 10a:	01 da                	add    %ebx,%edx
 10c:	01 04 df             	add    %eax,(%rdi,%rbx,8)
  icmp_hdr->type = ICMP_ECHOREPLY;
 10f:	01 e8                	add    %ebp,%eax
 111:	01 04 a5 08 b5 08 00 	add    %eax,0x8b508(,%riz,4)
  icmp_hdr->checksum += 0x0008;
 118:	01 14 04             	add    %edx,(%rsp,%rax,1)
 11b:	e8 01 d8 02 04       	call   402d921 <_license+0x402b58c>
  iph->ttl = DEFAULT_TTL;
 120:	b5 08                	mov    $0x8,%ch
 122:	84 09                	test   %cl,(%rcx)
 124:	04 a6                	add    $0xa6,%al
 126:	13 97 14 04 c3 17    	adc    0x17c30414(%rdi),%edx
  iph->daddr = iph->saddr;
 12c:	fa                   	cli
 12d:	17                   	(bad)
  iph->saddr = tmp_addr;
 12e:	04 ff                	add    $0xff,%al
 130:	17                   	(bad)
 131:	ae                   	scas   %es:(%rdi),%al
    *csum += *next_iph_u16++;
 132:	18 00                	sbb    %al,(%rax)
 134:	01 14 04             	add    %edx,(%rsp,%rax,1)
 137:	e8 01 d8 02 04       	call   402d93d <_license+0x402b5a8>
 13c:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
 13d:	13 97 14 00 01 14    	adc    0x14010014(%rdi),%edx
 143:	04 ba                	add    $0xba,%al
 145:	08 84 09 04 c3 17 fa 	or     %al,-0x5e83cfc(%rcx,%rcx,1)
 14c:	17                   	(bad)
 14d:	04 ff                	add    $0xff,%al
 14f:	17                   	(bad)
 150:	ae                   	scas   %es:(%rdi),%al
 151:	18 00                	sbb    %al,(%rax)
 153:	01 14 04             	add    %edx,(%rsp,%rax,1)
 156:	d5                   	(bad)
 157:	14 b3                	adc    $0xb3,%al
  struct packet_description pckt = {};
 159:	15 04 b7 15 b9       	adc    $0xb915b704,%eax
 15e:	17                   	(bad)
 15f:	00 01                	add    %al,(%rcx)
 161:	14 04                	adc    $0x4,%al
 163:	d5                   	(bad)
 164:	14 b3                	adc    $0xb3,%al
 166:	15 04 d8 16 db       	adc    $0xdb16d804,%eax
 16b:	16                   	(bad)
 16c:	00 01                	add    %al,(%rcx)
 16e:	14 04                	adc    $0x4,%al
 170:	b7 15                	mov    $0x15,%bh
 172:	d8 16                	fcoms  (%rsi)
 174:	04 db                	add    $0xdb,%al
 176:	16                   	(bad)
 177:	b9 17 00 01 14       	mov    $0x14010017,%ecx
 17c:	04 dd                	add    $0xdd,%al
 17e:	18 b2 19 04 d7 1a    	sbb    %dh,0x1ad70419(%rdx)
 184:	da 1a                	ficompl (%rdx)
 186:	00 01                	add    %al,(%rcx)
 188:	14 04                	adc    $0x4,%al
 18a:	b2 19                	mov    $0x19,%dl
 18c:	d7                   	xlat   %ds:(%rbx)
 18d:	1a 04 da             	sbb    (%rdx,%rbx,8),%al
  struct vip_definition vip = {};
 190:	1a b9 1b 00 01 14    	sbb    0x1401001b(%rcx),%bh
 196:	04 82                	add    $0x82,%al
 198:	1d 8e 1d 04 8c       	sbb    $0x8c041d8e,%eax
 19d:	20 a2 20 00 01 14    	and    %ah,0x14010020(%rdx)
 1a3:	04 82                	add    $0x82,%al
 1a5:	1d 8e 1d 04 8c       	sbb    $0x8c041d8e,%eax
    if (ip6h + 1 > data_end) {
 1aa:	20 a2 20 00 01 14    	and    %ah,0x14010020(%rdx)
 1b0:	04 d3                	add    $0xd3,%al
 1b2:	20 e1                	and    %ah,%cl
 1b4:	21 04 f5 22 cb 23 04 	and    %eax,0x423cb22(,%rsi,8)
    pckt->flow.proto = *protocol;
 1bb:	b0 32                	mov    $0x32,%al
 1bd:	af                   	scas   %es:(%rdi),%eax
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1be:	34 04                	xor    $0x4,%al
 1c0:	b8 34 c0 34 04       	mov    $0x434c034,%eax
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1c5:	84 43 c2             	test   %al,-0x3e(%rbx)
 1c8:	44 00 01             	add    %r8b,(%rcx)
 1cb:	14 04                	adc    $0x4,%al
 1cd:	e8 20 e1 21 04       	call   421e2f2 <_license+0x421bf5d>
 1d2:	f5                   	cmc
 1d3:	22 8a 23 04 b0 32    	and    0x32b00423(%rdx),%cl
    if (*protocol == IPPROTO_FRAGMENT) {
 1d9:	89 33                	mov    %esi,(%rbx)
 1db:	00 01                	add    %al,(%rcx)
 1dd:	14 04                	adc    $0x4,%al
 1df:	f5                   	cmc
 1e0:	22 8a 23 04 b0 32    	and    0x32b00423(%rdx),%cl
 1e6:	bb 32 00 01 14       	mov    $0x14010032,%ebx
  if (icmp_hdr + 1 > data_end) {
 1eb:	04 91                	add    $0x91,%al
 1ed:	33 af 34 04 b8 34    	xor    0x34b80434(%rdi),%ebp
 1f3:	c0 34 04 84          	shlb   $0x84,(%rsp,%rax,1)
 1f7:	43 c2 44 00          	rex.XB ret $0x44
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 1fb:	01 14 04             	add    %edx,(%rsp,%rax,1)
 1fe:	dc 33                	fdivl  (%rbx)
 200:	af                   	scas   %es:(%rdi),%eax
 201:	34 04                	xor    $0x4,%al
 203:	84 43 c2             	test   %al,-0x3e(%rbx)
 206:	44 00 01             	add    %r8b,(%rcx)
 209:	14 04                	adc    $0x4,%al
 20b:	83 34 a3 34          	xorl   $0x34,(%rbx,%riz,4)
 20f:	04 84                	add    $0x84,%al
 211:	43 c1 43 04 f6       	rex.XB roll $0xf6,0x4(%r11)
 216:	43 b4 44             	rex.XB mov $0x44,%r12b
 219:	00 01                	add    %al,(%rcx)
 21b:	14 04                	adc    $0x4,%al
 21d:	84 43 bf             	test   %al,-0x41(%rbx)
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
 220:	43 04 f6             	rex.XB add $0xf6,%al
  icmp_hdr->icmp6_cksum -= 0x0001;
 223:	43 87 44 00 01       	xchg   %eax,0x1(%r8,%r8,1)
  ip6h->hop_limit = DEFAULT_TTL;
 228:	14 04                	adc    $0x4,%al
 22a:	ab                   	stos   %eax,%es:(%rdi)
 22b:	3b 87 3e 04 83 3f    	cmp    0x3f83043e(%rdi),%eax
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
 231:	94                   	xchg   %eax,%esp
 232:	3f                   	(bad)
 233:	04 bc                	add    $0xbc,%al
 235:	3f                   	(bad)
 236:	cf                   	iret
 237:	3f                   	(bad)
 238:	00 01                	add    %al,(%rcx)
 23a:	14 04                	adc    $0x4,%al
 23c:	9b                   	fwait
 23d:	3c a8                	cmp    $0xa8,%al
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
 23f:	3d 04 83 3f 94       	cmp    $0x943f8304,%eax
 244:	3f                   	(bad)
 245:	00 01                	add    %al,(%rcx)
 247:	14 04                	adc    $0x4,%al
 249:	a0 3c a6 3c 04 c4 3c 	movabs 0x3cd43cc4043ca63c,%al
 250:	d4 3c 
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
 252:	00 01                	add    %al,(%rcx)
 254:	14 04                	adc    $0x4,%al
 256:	d8 02                	fadds  (%rdx)
 258:	9e                   	sahf
 259:	04 04                	add    $0x4,%al
 25b:	93                   	xchg   %eax,%ebx
 25c:	05 ad 06 04 d3       	add    $0xd30406ad,%eax
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 261:	07                   	(bad)
 262:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
 263:	08 04 e5 09 a6 13 04 	or     %al,0x413a609(,%riz,8)
 26a:	97                   	xchg   %eax,%edi
 26b:	14 d5                	adc    $0xd5,%al
 26d:	14 04                	adc    $0x4,%al
 26f:	c4                   	(bad)
 270:	1d 92 1f 04 da       	sbb    $0xda041f92,%eax
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 275:	1f                   	(bad)
 276:	8c 20                	mov    %fs,(%rax)
 278:	04 a2                	add    $0xa2,%al
 27a:	22 f5                	and    %ch,%dh
 27c:	22 04 cb             	and    (%rbx,%rcx,8),%al
 27f:	23 b0 32 04 9f 41    	and    0x419f0432(%rax),%esi
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 285:	fa                   	cli
 286:	42 00 01             	rex.X add %al,(%rcx)
 289:	14 04                	adc    $0x4,%al
 28b:	a8 03                	test   $0x3,%al
 28d:	eb 03                	jmp    292 <balancer_ingress+0x292>
 28f:	04 93                	add    $0x93,%al
 291:	05 b7 05 00 01       	add    $0x10005b7,%eax
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 296:	14 04                	adc    $0x4,%al
 298:	eb 03                	jmp    29d <balancer_ingress+0x29d>
 29a:	9e                   	sahf
 29b:	04 04                	add    $0x4,%al
 29d:	b7 05                	mov    $0x5,%bh
 29f:	ad                   	lods   %ds:(%rsi),%eax
 2a0:	06                   	(bad)
 2a1:	04 e5                	add    $0xe5,%al
 2a3:	09 ce                	or     %ecx,%esi
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2a5:	0a 04 d1             	or     (%rcx,%rdx,8),%al
 2a8:	10 c2                	adc    %al,%dl
 2aa:	11 00                	adc    %eax,(%rax)
 2ac:	01 14 04             	add    %edx,(%rsp,%rax,1)
 2af:	eb 03                	jmp    2b4 <balancer_ingress+0x2b4>
 2b1:	9e                   	sahf
 2b2:	04 04                	add    $0x4,%al
 2b4:	e5 09                	in     $0x9,%eax
 2b6:	ce                   	(bad)
  if (protocol == IPPROTO_ICMPV6) {
 2b7:	0a 00                	or     (%rax),%al
 2b9:	01 14 04             	add    %edx,(%rsp,%rax,1)
 2bc:	c0 05 ad 06 04 d1 10 	rolb   $0x10,-0x2efbf953(%rip)        # ffffffffd1040970 <server_id_map+0x36ffb8957970>
  if (icmp_hdr + 1 > data_end) {
 2c3:	c2 11 00             	ret    $0x11
 2c6:	01 14 04             	add    %edx,(%rsp,%rax,1)
 2c9:	fa                   	cli
 2ca:	0a d3                	or     %bl,%dl
 2cc:	0b 04 e3             	or     (%rbx,%riz,8),%eax
  if (icmp_hdr->type == ICMP_ECHO) {
 2cf:	0c e6                	or     $0xe6,%al
 2d1:	0c 00                	or     $0x0,%al
 2d3:	01 14 04             	add    %edx,(%rsp,%rax,1)
 2d6:	d3 0b                	rorl   %cl,(%rbx)
 2d8:	e3 0c                	jrcxz  2e6 <balancer_ingress+0x2e6>
 2da:	04 e6                	add    $0xe6,%al
 2dc:	0c c5                	or     $0xc5,%al
 2de:	0d 00 01 14 04       	or     $0x4140100,%eax
 2e3:	c5 0d 9e             	(bad)
 2e6:	0e                   	(bad)
  icmp_hdr->type = ICMP_ECHOREPLY;
 2e7:	04 c2                	add    $0xc2,%al
 2e9:	0f c5                	pextrw $0xc5,(bad),%ecx
 2eb:	0f 00 01             	sldt   (%rcx)
  icmp_hdr->checksum += 0x0008;
 2ee:	14 04                	adc    $0x4,%al
 2f0:	9e                   	sahf
 2f1:	0e                   	(bad)
  iph->ttl = DEFAULT_TTL;
 2f2:	c2 0f 04             	ret    $0x40f
 2f5:	c5 0f a3             	(bad)
 2f8:	10 00                	adc    %al,(%rax)
 2fa:	01 14 04             	add    %edx,(%rsp,%rax,1)
 2fd:	e9 12 f5 12 04       	jmp    412f814 <_license+0x412d47f>
  iph->daddr = iph->saddr;
 302:	c4                   	(bad)
  iph->saddr = tmp_addr;
 303:	1d d5 1d 00 01       	sbb    $0x1001dd5,%eax
 308:	14 04                	adc    $0x4,%al
 30a:	e9 12 f5 12 04       	jmp    412f821 <_license+0x412d48c>
 30f:	c4                   	(bad)
 310:	1d d5 1d 00 01       	sbb    $0x1001dd5,%eax
 315:	14 04                	adc    $0x4,%al
 317:	fc                   	cld
 318:	1d 92 1f 04 a2       	sbb    $0xa2041f92,%eax
 31d:	22 f5                	and    %ch,%dh
 31f:	22 04 cb             	and    (%rbx,%rcx,8),%al
 322:	23 d9                	and    %ecx,%ebx
 324:	25 04 9f 41 db       	and    $0xdb419f04,%eax
 329:	42 00 01             	rex.X add %al,(%rcx)
 32c:	14 04                	adc    $0x4,%al
 32e:	91                   	xchg   %eax,%ecx
 32f:	1e                   	(bad)
 330:	92                   	xchg   %eax,%edx
 331:	1f                   	(bad)
 332:	04 a2                	add    $0xa2,%al
 334:	22 b8 22 04 cb 23    	and    0x23cb0422(%rax),%bh
 33a:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
 33b:	24 00                	and    $0x0,%al
 33d:	01 14 04             	add    %edx,(%rsp,%rax,1)
    if (csum >> 16)
 340:	a2 22 b8 22 04 cb 23 	movabs %al,0x23d623cb0422b822
 347:	d6 23 
 349:	00 01                	add    %al,(%rcx)
 34b:	14 04                	adc    $0x4,%al
 34d:	ac                   	lods   %ds:(%rsi),%al
 34e:	24 d9                	and    $0xd9,%al
 350:	25 04 9f 41 db       	and    $0xdb419f04,%eax
 355:	42 00 01             	rex.X add %al,(%rcx)
 358:	14 04                	adc    $0x4,%al
 35a:	f7 24 d1             	mull   (%rcx,%rdx,8)
 35d:	25 04 9f 41 db       	and    $0xdb419f04,%eax
 362:	42 00 01             	rex.X add %al,(%rcx)
 365:	14 04                	adc    $0x4,%al
 367:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
 368:	25 c5 25 04 9f       	and    $0x9f0425c5,%eax
 36d:	41 dc 41 04          	faddl  0x4(%r9)
 371:	91                   	xchg   %eax,%ecx
 372:	42 cd 42             	rex.X int $0x42
 375:	00 01                	add    %al,(%rcx)
 377:	14 04                	adc    $0x4,%al
 379:	9f                   	lahf
 37a:	41 da 41 04          	fiaddl 0x4(%r9)
 37e:	91                   	xchg   %eax,%ecx
 37f:	42 a2 42 00 01 14 04 	rex.X movabs %al,0xe72bfe0414010042
 386:	fe 2b e7 
 389:	2e 04 b8             	cs add $0xb8,%al
  return ~csum;
 38c:	30 f6                	xor    %dh,%dh
  iph->check = csum;
 38e:	30 00                	xor    %al,(%rax)
 390:	01 14 04             	add    %edx,(%rsp,%rax,1)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 393:	f5                   	cmc
 394:	2c 8c                	sub    $0x8c,%al
 396:	2e 04 b8             	cs add $0xb8,%al
 399:	30 d2                	xor    %dl,%dl
 39b:	30 00                	xor    %al,(%rax)
 39d:	01 14 04             	add    %edx,(%rsp,%rax,1)
 3a0:	da 28                	fisubrl (%rax)
 3a2:	fd                   	std
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 3a3:	28 04 9d 30 ae 30 04 	sub    %al,0x430ae30(,%rbx,4)
 3aa:	e9 42 fa 42 00       	jmp    42fdf1 <_license+0x42da5c>
 3af:	01 14 04             	add    %edx,(%rsp,%rax,1)
 3b2:	da 28                	fisubrl (%rax)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 3b4:	fd                   	std
 3b5:	28 04 9d 30 ae 30 04 	sub    %al,0x430ae30(,%rbx,4)
 3bc:	e9 42 fa 42 00       	jmp    42fe03 <_license+0x42da6e>
 3c1:	01 14 04             	add    %edx,(%rsp,%rax,1)
 3c4:	9e                   	sahf
 3c5:	04 93                	add    $0x93,%al
 3c7:	05 04 ad 06 c4       	add    $0xc406ad04,%eax
 3cc:	07                   	(bad)
 3cd:	04 af                	add    $0xaf,%al
 3cf:	34 b8                	xor    $0xb8,%al
 3d1:	34 04                	xor    $0x4,%al
  if (protocol == IPPROTO_IPIP) {
 3d3:	91                   	xchg   %eax,%ecx
 3d4:	3a f7                	cmp    %bh,%dh
 3d6:	3a 04 94             	cmp    (%rsp,%rdx,4),%al
 3d9:	3f                   	(bad)
 3da:	9b                   	fwait
 3db:	3f                   	(bad)
 3dc:	04 ee                	add    $0xee,%al
 3de:	40 95                	rex xchg %eax,%ebp
 3e0:	41 00 01             	add    %al,(%r9)
 3e3:	14 04                	adc    $0x4,%al
 3e5:	9e                   	sahf
 3e6:	04 93                	add    $0x93,%al
 3e8:	05 04 ad 06 c4       	add    $0xc406ad04,%eax
 3ed:	07                   	(bad)
 3ee:	00 03                	add    %al,(%rbx)
 3f0:	14 d3                	adc    $0xd3,%al
 3f2:	44 03 ca             	add    %edx,%r9d
 3f5:	01 51 03             	add    %edx,0x3(%rcx)
 3f8:	d2 01                	rolb   %cl,(%rcx)
  tcp = data + off;
 3fa:	d5                   	(bad)
 3fb:	01 00                	add    %eax,(%rax)

Disassembly of section .debug_str_offsets:

0000000000000000 <.debug_str_offsets>:
  void* data = (void*)(long)ctx->data;
   0:	08 06                	or     %al,(%rsi)
   2:	00 00                	add    %al,(%rax)
   4:	05 00 00 00 00       	add    $0x0,%eax
   9:	00 00                	add    %al,(%rax)
   b:	00 dc                	add    %bl,%ah
   d:	02 00                	add    (%rax),%al
   f:	00 fa                	add    %bh,%dl
  11:	02 00                	add    (%rax),%al
  13:	00 25 03 00 00 89    	add    %ah,-0x76fffffd(%rip)        # ffffffff8900001c <server_id_map+0x36ff7091701c>
  void* data_end = (void*)(long)ctx->data_end;
  19:	03 00                	add    (%rax),%eax
  1b:	00 2e                	add    %ch,(%rsi)
  if (data + nh_off > data_end) {
  1d:	03 00                	add    (%rax),%eax
  1f:	00 42 03             	add    %al,0x3(%rdx)
  22:	00 00                	add    %al,(%rax)
  24:	ab                   	stos   %eax,%es:(%rdi)
  25:	0b 00                	or     (%rax),%eax
  27:	00 55 03             	add    %dl,0x3(%rbp)
  2a:	00 00                	add    %al,(%rax)
  2c:	91                   	xchg   %eax,%ecx
  2d:	0f 00 00             	sldt   (%rax)
  eth_proto = eth->h_proto; 
  30:	4c 03 00             	add    (%rax),%r8
  33:	00 59 03             	add    %bl,0x3(%rcx)
  36:	00 00                	add    %al,(%rax)
  38:	97                   	xchg   %eax,%edi
  if (eth_proto == BE_ETH_P_IP) {
  39:	03 00                	add    (%rax),%eax
  3b:	00 5f 03             	add    %bl,0x3(%rdi)
  3e:	00 00                	add    %al,(%rax)
  40:	72 03                	jb     45 <balancer_ingress+0x45>
  42:	00 00                	add    %al,(%rax)
  44:	78 03                	js     49 <balancer_ingress+0x49>
  46:	00 00                	add    %al,(%rax)
  48:	eb 0c                	jmp    56 <balancer_ingress+0x56>
  4a:	00 00                	add    %al,(%rax)
  4c:	80 03 00             	addb   $0x0,(%rbx)
  struct packet_description pckt = {};
  4f:	00 8e 03 00 00 93    	add    %cl,-0x6cfffffd(%rsi)
  55:	03 00                	add    (%rax),%eax
  57:	00 9d 03 00 00 a9    	add    %bl,-0x56fffffd(%rbp)
  5d:	03 00                	add    (%rax),%eax
  5f:	00 63 0d             	add    %ah,0xd(%rbx)
  62:	00 00                	add    %al,(%rax)
  64:	a8 08                	test   $0x8,%al
  66:	00 00                	add    %al,(%rax)
  68:	b3 03                	mov    $0x3,%bl
  6a:	00 00                	add    %al,(%rax)
  6c:	ba 03 00 00 c1       	mov    $0xc1000003,%edx
  71:	03 00                	add    (%rax),%eax
  73:	00 c9                	add    %cl,%cl
  75:	03 00                	add    (%rax),%eax
  77:	00 d5                	add    %dl,%ch
  79:	03 00                	add    (%rax),%eax
  7b:	00 35 10 00 00 dd    	add    %dh,-0x22fffff0(%rip)        # ffffffffdd000091 <server_id_map+0x36ffc4917091>
  81:	03 00                	add    (%rax),%eax
  struct vip_definition vip = {};
  83:	00 25 0a 00 00 e3    	add    %ah,-0x1cfffff6(%rip)        # ffffffffe3000093 <server_id_map+0x36ffca917093>
  89:	03 00                	add    (%rax),%eax
  8b:	00 f2                	add    %dh,%dl
  8d:	03 00                	add    (%rax),%eax
  8f:	00 bb 11 00 00 f8    	add    %bh,-0x7ffffef(%rbx)
  95:	03 00                	add    (%rax),%eax
  97:	00 ad 03 00 00 07    	add    %ch,0x7000003(%rbp)
    if (iph + 1 > data_end) {
  9d:	04 00                	add    $0x0,%al
  9f:	00 0f                	add    %cl,(%rdi)
  a1:	04 00                	add    $0x0,%al
  a3:	00 18                	add    %bl,(%rax)
  a5:	04 00                	add    $0x0,%al
  a7:	00 f7                	add    %dh,%bh
  a9:	10 00                	adc    %al,(%rax)
    if (iph->ihl != 5) {
  ab:	00 27                	add    %ah,(%rdi)
  ad:	04 00                	add    $0x0,%al
  af:	00 69 0d             	add    %ch,0xd(%rcx)
  b2:	00 00                	add    %al,(%rax)
  b4:	2d 04 00 00 33       	sub    $0x33000004,%eax
    pckt->tos = iph->tos;
  b9:	04 00                	add    $0x0,%al
  bb:	00 39                	add    %bh,(%rcx)
  bd:	04 00                	add    $0x0,%al
  bf:	00 40 04             	add    %al,0x4(%rax)
    *protocol = iph->protocol;
  c2:	00 00                	add    %al,(%rax)
  c4:	c6                   	(bad)
    pckt->flow.proto = *protocol;
  c5:	0a 00                	or     (%rax),%al
  c7:	00 49 04             	add    %cl,0x4(%rcx)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  ca:	00 00                	add    %al,(%rax)
  cc:	4f 04 00             	rex.WRXB add $0x0,%al
  cf:	00 5c 04 00          	add    %bl,0x0(%rsp,%rax,1)
  d3:	00 68 04             	add    %ch,0x4(%rax)
  d6:	00 00                	add    %al,(%rax)
  d8:	6f                   	outsl  %ds:(%rsi),(%dx)
  d9:	04 00                	add    $0x0,%al
  db:	00 78 04             	add    %bh,0x4(%rax)
  de:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
  e0:	7e 04                	jle    e6 <balancer_ingress+0xe6>
  e2:	00 00                	add    %al,(%rax)
  e4:	8e 04 00             	mov    (%rax,%rax,1),%es
  e7:	00 39                	add    %bh,(%rcx)
  if (icmp_hdr + 1 > data_end) {
  e9:	05 00 00 40 05       	add    $0x5400000,%eax
  ee:	00 00                	add    %al,(%rax)
  f0:	9a                   	(bad)
  f1:	04 00                	add    $0x0,%al
  f3:	00 18                	add    %bl,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
  f5:	10 00                	adc    %al,(%rax)
  f7:	00 a3 04 00 00 45    	add    %ah,0x45000004(%rbx)
  fd:	0b 00                	or     (%rax),%eax
  ff:	00 b2 04 00 00 c1    	add    %dh,-0x3efffffc(%rdx)
 105:	04 00                	add    $0x0,%al
 107:	00 cb                	add    %cl,%bl
 109:	04 00                	add    $0x0,%al
 10b:	00 d7                	add    %dl,%bh
 10d:	04 00                	add    $0x0,%al
  icmp_hdr->type = ICMP_ECHOREPLY;
 10f:	00 ed                	add    %ch,%ch
 111:	04 00                	add    $0x0,%al
 113:	00 0a                	add    %cl,(%rdx)
  icmp_hdr->checksum += 0x0008;
 115:	05 00 00 15 05       	add    $0x5150000,%eax
 11a:	00 00                	add    %al,(%rax)
 11c:	2e 05 00 00 35 05    	cs add $0x5350000,%eax
  iph->ttl = DEFAULT_TTL;
 122:	00 00                	add    %al,(%rax)
 124:	3c 05                	cmp    $0x5,%al
 126:	00 00                	add    %al,(%rax)
 128:	43 05 00 00 4a 05    	rex.XB add $0x54a0000,%eax
  iph->saddr = tmp_addr;
 12e:	00 00                	add    %al,(%rax)
 130:	5b                   	pop    %rbx
 131:	05 00 00 6f 05       	add    $0x56f0000,%eax
    *csum += *next_iph_u16++;
 136:	00 00                	add    %al,(%rax)
 138:	84 05 00 00 9a 05    	test   %al,0x59a0000(%rip)        # 59a013e <_license+0x599dda9>
 13e:	00 00                	add    %al,(%rax)
 140:	aa                   	stos   %al,%es:(%rdi)
 141:	05 00 00 be 05       	add    $0x5be0000,%eax
 146:	00 00                	add    %al,(%rax)
 148:	d9 05 00 00 e9 05    	flds   0x5e90000(%rip)        # 5e9014e <_license+0x5e8ddb9>
 14e:	00 00                	add    %al,(%rax)
 150:	f7 05 00 00 05 06 00 	testl  $0x6100000,0x6050000(%rip)        # 605015a <_license+0x604ddc5>
 157:	00 10 06 
  struct packet_description pckt = {};
 15a:	00 00                	add    %al,(%rax)
 15c:	18 06                	sbb    %al,(%rsi)
 15e:	00 00                	add    %al,(%rax)
 160:	2d 06 00 00 3d       	sub    $0x3d000006,%eax
 165:	06                   	(bad)
 166:	00 00                	add    %al,(%rax)
 168:	53                   	push   %rbx
 169:	06                   	(bad)
 16a:	00 00                	add    %al,(%rax)
 16c:	67 06                	addr32 (bad)
 16e:	00 00                	add    %al,(%rax)
 170:	78 06                	js     178 <balancer_ingress+0x178>
 172:	00 00                	add    %al,(%rax)
 174:	84 06                	test   %al,(%rsi)
 176:	00 00                	add    %al,(%rax)
 178:	8d 06                	lea    (%rsi),%eax
 17a:	00 00                	add    %al,(%rax)
 17c:	96                   	xchg   %eax,%esi
 17d:	06                   	(bad)
 17e:	00 00                	add    %al,(%rax)
 180:	9d                   	popf
 181:	06                   	(bad)
 182:	00 00                	add    %al,(%rax)
 184:	aa                   	stos   %al,%es:(%rdi)
 185:	06                   	(bad)
 186:	00 00                	add    %al,(%rax)
 188:	b5 06                	mov    $0x6,%ch
 18a:	00 00                	add    %al,(%rax)
 18c:	c0 06 00             	rolb   $0x0,(%rsi)
  struct vip_definition vip = {};
 18f:	00 cd                	add    %cl,%ch
 191:	06                   	(bad)
 192:	00 00                	add    %al,(%rax)
 194:	da 06                	fiaddl (%rsi)
 196:	00 00                	add    %al,(%rax)
 198:	e7 06                	out    %eax,$0x6
 19a:	00 00                	add    %al,(%rax)
 19c:	f3 06                	repz (bad)
 19e:	00 00                	add    %al,(%rax)
 1a0:	ff 06                	incl   (%rsi)
 1a2:	00 00                	add    %al,(%rax)
 1a4:	0b 07                	or     (%rdi),%eax
 1a6:	00 00                	add    %al,(%rax)
    if (ip6h + 1 > data_end) {
 1a8:	17                   	(bad)
 1a9:	07                   	(bad)
 1aa:	00 00                	add    %al,(%rax)
 1ac:	23 07                	and    (%rdi),%eax
 1ae:	00 00                	add    %al,(%rax)
 1b0:	2e 07                	cs (bad)
 1b2:	00 00                	add    %al,(%rax)
 1b4:	3b 07                	cmp    (%rdi),%eax
    *protocol = ip6h->nexthdr;
 1b6:	00 00                	add    %al,(%rax)
 1b8:	48 07                	rex.W (bad)
    pckt->flow.proto = *protocol;
 1ba:	00 00                	add    %al,(%rax)
 1bc:	55                   	push   %rbp
 1bd:	07                   	(bad)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1be:	00 00                	add    %al,(%rax)
 1c0:	61                   	(bad)
 1c1:	07                   	(bad)
 1c2:	00 00                	add    %al,(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1c4:	6d                   	insl   (%dx),%es:(%rdi)
 1c5:	07                   	(bad)
 1c6:	00 00                	add    %al,(%rax)
 1c8:	78 07                	js     1d1 <balancer_ingress+0x1d1>
 1ca:	00 00                	add    %al,(%rax)
 1cc:	84 07                	test   %al,(%rdi)
 1ce:	00 00                	add    %al,(%rax)
 1d0:	93                   	xchg   %eax,%ebx
 1d1:	07                   	(bad)
 1d2:	00 00                	add    %al,(%rax)
    *protocol = ip6h->nexthdr;
 1d4:	a1 07 00 00 ad 07 00 	movabs 0xba000007ad000007,%eax
 1db:	00 ba 
 1dd:	07                   	(bad)
 1de:	00 00                	add    %al,(%rax)
 1e0:	c7 07 00 00 d4 07    	movl   $0x7d40000,(%rdi)
    if (*protocol == IPPROTO_FRAGMENT) {
 1e6:	00 00                	add    %al,(%rax)
 1e8:	e4 07                	in     $0x7,%al
 1ea:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 1ec:	f1                   	int1
 1ed:	07                   	(bad)
 1ee:	00 00                	add    %al,(%rax)
 1f0:	02 08                	add    (%rax),%cl
 1f2:	00 00                	add    %al,(%rax)
 1f4:	12 08                	adc    (%rax),%cl
 1f6:	00 00                	add    %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 1f8:	1e                   	(bad)
 1f9:	08 00                	or     %al,(%rax)
 1fb:	00 2a                	add    %ch,(%rdx)
 1fd:	08 00                	or     %al,(%rax)
 1ff:	00 38                	add    %bh,(%rax)
 201:	08 00                	or     %al,(%rax)
 203:	00 6d 03             	add    %ch,0x3(%rbp)
 206:	00 00                	add    %al,(%rax)
 208:	44 08 00             	or     %r8b,(%rax)
 20b:	00 9c 0a 00 00 4d 08 	add    %bl,0x84d0000(%rdx,%rcx,1)
 212:	00 00                	add    %al,(%rax)
 214:	56                   	push   %rsi
 215:	08 00                	or     %al,(%rax)
 217:	00 62 08             	add    %ah,0x8(%rdx)
 21a:	00 00                	add    %al,(%rax)
 21c:	69 08 00 00 71 08    	imul   $0x8710000,(%rax),%ecx
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
 222:	00 00                	add    %al,(%rax)
  icmp_hdr->icmp6_cksum -= 0x0001;
 224:	7b 08                	jnp    22e <balancer_ingress+0x22e>
 226:	00 00                	add    %al,(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
 228:	81 08 00 00 87 08    	orl    $0x8870000,(%rax)
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
 22e:	00 00                	add    %al,(%rax)
 230:	90                   	nop
 231:	08 00                	or     %al,(%rax)
 233:	00 9a 08 00 00 a4    	add    %bl,-0x5bfffff8(%rdx)
 239:	08 00                	or     %al,(%rax)
 23b:	00 ad 08 00 00 b3    	add    %ch,-0x4cfffff8(%rbp)
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
 241:	08 00                	or     %al,(%rax)
 243:	00 b9 08 00 00 c1    	add    %bh,-0x3efffff8(%rcx)
 249:	08 00                	or     %al,(%rax)
 24b:	00 c5                	add    %al,%ch
 24d:	08 00                	or     %al,(%rax)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
 24f:	00 c9                	add    %cl,%cl
 251:	08 00                	or     %al,(%rax)
 253:	00 13                	add    %dl,(%rbx)
 255:	09 00                	or     %eax,(%rax)
 257:	00 d1                	add    %dl,%cl
 259:	08 00                	or     %al,(%rax)
 25b:	00 a9 0d 00 00 da    	add    %ch,-0x25fffff3(%rcx)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 261:	08 00                	or     %al,(%rax)
 263:	00 e3                	add    %ah,%bl
 265:	08 00                	or     %al,(%rax)
 267:	00 e9                	add    %ch,%cl
 269:	08 00                	or     %al,(%rax)
 26b:	00 f1                	add    %dh,%cl
 26d:	08 00                	or     %al,(%rax)
 26f:	00 f7                	add    %dh,%bh
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 271:	08 00                	or     %al,(%rax)
 273:	00 04 09             	add    %al,(%rcx,%rcx,1)
 276:	00 00                	add    %al,(%rax)
 278:	16                   	(bad)
 279:	09 00                	or     %eax,(%rax)
 27b:	00 08                	add    %cl,(%rax)
 27d:	09 00                	or     %eax,(%rax)
 27f:	00 27                	add    %ah,(%rdi)
 281:	09 00                	or     %eax,(%rax)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 283:	00 5b 03             	add    %bl,0x3(%rbx)
 286:	00 00                	add    %al,(%rax)
 288:	39 09                	cmp    %ecx,(%rcx)
 28a:	00 00                	add    %al,(%rax)
 28c:	48 09 00             	or     %rax,(%rax)
 28f:	00 5b 0e             	add    %bl,0xe(%rbx)
 292:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 294:	4c 09 00             	or     %r8,(%rax)
 297:	00 55 09             	add    %dl,0x9(%rbp)
 29a:	00 00                	add    %al,(%rax)
 29c:	5f                   	pop    %rdi
 29d:	09 00                	or     %eax,(%rax)
 29f:	00 6f 09             	add    %ch,0x9(%rdi)
 2a2:	00 00                	add    %al,(%rax)
 2a4:	73 09                	jae    2af <balancer_ingress+0x2af>
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2a6:	00 00                	add    %al,(%rax)
 2a8:	80 09 00             	orb    $0x0,(%rcx)
 2ab:	00 84 09 00 00 91 09 	add    %al,0x9910000(%rcx,%rcx,1)
 2b2:	00 00                	add    %al,(%rax)
 2b4:	9a                   	(bad)
 2b5:	09 00                	or     %eax,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 2b7:	00 a1 09 00 00 a8    	add    %ah,-0x57fffff7(%rcx)
 2bd:	09 00                	or     %eax,(%rax)
 2bf:	00 b0 09 00 00 c2    	add    %dh,-0x3dfffff7(%rax)
  if (icmp_hdr + 1 > data_end) {
 2c5:	0d 00 00 b6 09       	or     $0x9b60000,%eax
 2ca:	00 00                	add    %al,(%rax)
 2cc:	bb 09 00 00 c6       	mov    $0xc6000009,%ebx
  if (icmp_hdr->type == ICMP_ECHO) {
 2d1:	09 00                	or     %eax,(%rax)
 2d3:	00 d9                	add    %bl,%cl
 2d5:	09 00                	or     %eax,(%rax)
 2d7:	00 e6                	add    %ah,%dh
 2d9:	09 00                	or     %eax,(%rax)
 2db:	00 ae 06 00 00 ed    	add    %ch,-0x12fffffa(%rsi)
 2e1:	09 00                	or     %eax,(%rax)
 2e3:	00 cc                	add    %cl,%ah
 2e5:	0d 00 00 f6 09       	or     $0x9f60000,%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
 2ea:	00 00                	add    %al,(%rax)
  icmp_hdr->checksum += 0x0008;
 2ec:	01 0a                	add    %ecx,(%rdx)
 2ee:	00 00                	add    %al,(%rax)
 2f0:	09 0a                	or     %ecx,(%rdx)
  iph->ttl = DEFAULT_TTL;
 2f2:	00 00                	add    %al,(%rax)
 2f4:	11 0a                	adc    %ecx,(%rdx)
 2f6:	00 00                	add    %al,(%rax)
 2f8:	1b 0a                	sbb    (%rdx),%ecx
 2fa:	00 00                	add    %al,(%rax)
 2fc:	2a 0a                	sub    (%rdx),%cl
 2fe:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
 300:	2f                   	(bad)
 301:	0a 00                	or     (%rax),%al
  iph->saddr = tmp_addr;
 303:	00 37                	add    %dh,(%rdi)
 305:	0a 00                	or     (%rax),%al
 307:	00 3c 0a             	add    %bh,(%rdx,%rcx,1)
 30a:	00 00                	add    %al,(%rax)
 30c:	43 0a 00             	rex.XB or (%r8),%al
 30f:	00 47 0a             	add    %al,0xa(%rdi)
 312:	00 00                	add    %al,(%rax)
 314:	51                   	push   %rcx
 315:	0a 00                	or     (%rax),%al
 317:	00 5d 0a             	add    %bl,0xa(%rbp)
 31a:	00 00                	add    %al,(%rax)
 31c:	6b 0a 00             	imul   $0x0,(%rdx),%ecx
 31f:	00 75 0a             	add    %dh,0xa(%rbp)
 322:	00 00                	add    %al,(%rax)
 324:	7d 0a                	jge    330 <balancer_ingress+0x330>
 326:	00 00                	add    %al,(%rax)
 328:	87 05 00 00 94 0a    	xchg   %eax,0xa940000(%rip)        # a94032e <_license+0xa93df99>
 32e:	00 00                	add    %al,(%rax)
 330:	e3 04                	jrcxz  336 <balancer_ingress+0x336>
 332:	00 00                	add    %al,(%rax)
 334:	98                   	cwtl
 335:	0a 00                	or     (%rax),%al
 337:	00 a4 0a 00 00 af 0a 	add    %ah,0xaaf0000(%rdx,%rcx,1)
 33e:	00 00                	add    %al,(%rax)
    if (csum >> 16)
 340:	c1 0a 00             	rorl   $0x0,(%rdx)
 343:	00 ca                	add    %cl,%dl
 345:	0a 00                	or     (%rax),%al
 347:	00 ce                	add    %cl,%dh
 349:	0a 00                	or     (%rax),%al
 34b:	00 df                	add    %bl,%bh
 34d:	0a 00                	or     (%rax),%al
 34f:	00 e3                	add    %ah,%bl
 351:	0a 00                	or     (%rax),%al
 353:	00 e8                	add    %ch,%al
 355:	0a 00                	or     (%rax),%al
 357:	00 d6                	add    %dl,%dh
 359:	08 00                	or     %al,(%rax)
 35b:	00 f3                	add    %dh,%bl
 35d:	0a 00                	or     (%rax),%al
 35f:	00 b6 0b 00 00 fc    	add    %dh,-0x3fffff5(%rsi)
 365:	0a 00                	or     (%rax),%al
 367:	00 d1                	add    %dl,%cl
 369:	0b 00                	or     (%rax),%eax
 36b:	00 0a                	add    %cl,(%rdx)
 36d:	0c 00                	or     $0x0,%al
 36f:	00 05 0b 00 00 0e    	add    %al,0xe00000b(%rip)        # e000380 <_license+0xdffdfeb>
 375:	0b 00                	or     (%rax),%eax
 377:	00 16                	add    %dl,(%rsi)
 379:	0b 00                	or     (%rax),%eax
 37b:	00 1b                	add    %bl,(%rbx)
 37d:	0b 00                	or     (%rax),%eax
 37f:	00 24 0b             	add    %ah,(%rbx,%rcx,1)
 382:	00 00                	add    %al,(%rax)
 384:	28 0b                	sub    %cl,(%rbx)
 386:	00 00                	add    %al,(%rax)
 388:	31 0b                	xor    %ecx,(%rbx)
 38a:	00 00                	add    %al,(%rax)
  return ~csum;
 38c:	39 0b                	cmp    %ecx,(%rbx)
  iph->check = csum;
 38e:	00 00                	add    %al,(%rax)
 390:	4b 0b 00             	rex.WXB or (%r8),%rax
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 393:	00 5a 0b             	add    %bl,0xb(%rdx)
 396:	00 00                	add    %al,(%rax)
 398:	6a 0b                	push   $0xb
 39a:	00 00                	add    %al,(%rax)
 39c:	73 0b                	jae    3a9 <balancer_ingress+0x3a9>
 39e:	00 00                	add    %al,(%rax)
 3a0:	78 0b                	js     3ad <balancer_ingress+0x3ad>
 3a2:	00 00                	add    %al,(%rax)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 3a4:	89 0b                	mov    %ecx,(%rbx)
 3a6:	00 00                	add    %al,(%rax)
 3a8:	96                   	xchg   %eax,%esi
 3a9:	0b 00                	or     (%rax),%eax
 3ab:	00 98 0b 00 00 a5    	add    %bl,-0x5afffff5(%rax)
 3b1:	0b 00                	or     (%rax),%eax
 3b3:	00 b0 0b 00 00 bb    	add    %dh,-0x44fffff5(%rax)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 3b9:	0b 00                	or     (%rax),%eax
 3bb:	00 c7                	add    %al,%bh
 3bd:	0b 00                	or     (%rax),%eax
 3bf:	00 d4                	add    %dl,%ah
 3c1:	0b 00                	or     (%rax),%eax
 3c3:	00 de                	add    %bl,%dh
 3c5:	0b 00                	or     (%rax),%eax
 3c7:	00 e8                	add    %ch,%al
 3c9:	0b 00                	or     (%rax),%eax
 3cb:	00 f1                	add    %dh,%cl
 3cd:	0b 00                	or     (%rax),%eax
 3cf:	00 f8                	add    %bh,%al
 3d1:	0b 00                	or     (%rax),%eax
  if (protocol == IPPROTO_IPIP) {
 3d3:	00 03                	add    %al,(%rbx)
 3d5:	0c 00                	or     $0x0,%al
 3d7:	00 0f                	add    %cl,(%rdi)
 3d9:	0c 00                	or     $0x0,%al
 3db:	00 19                	add    %bl,(%rcx)
 3dd:	0c 00                	or     $0x0,%al
 3df:	00 22                	add    %ah,(%rdx)
 3e1:	0c 00                	or     $0x0,%al
 3e3:	00 2c 0c             	add    %ch,(%rsp,%rcx,1)
 3e6:	00 00                	add    %al,(%rax)
 3e8:	33 0c 00             	xor    (%rax,%rax,1),%ecx
 3eb:	00 3d 0c 00 00 4c    	add    %bh,0x4c00000c(%rip)        # 4c0003fd <_license+0x4bffe068>
 3f1:	0c 00                	or     $0x0,%al
 3f3:	00 54 0c 00          	add    %dl,0x0(%rsp,%rcx,1)
 3f7:	00 60 0c             	add    %ah,0xc(%rax)
  tcp = data + off;
 3fa:	00 00                	add    %al,(%rax)
 3fc:	6b 0c 00 00          	imul   $0x0,(%rax,%rax,1),%ecx
 400:	71 0c                	jno    40e <balancer_ingress+0x40e>
 402:	00 00                	add    %al,(%rax)
  if (tcp + 1 > data_end) {
 404:	79 0c                	jns    412 <balancer_ingress+0x412>
 406:	00 00                	add    %al,(%rax)
 408:	85 0c 00             	test   %ecx,(%rax,%rax,1)
 40b:	00 92 0c 00 00 9b    	add    %dl,-0x64fffff4(%rdx)
  if (tcp->syn) {
 411:	0c 00                	or     $0x0,%al
 413:	00 ad 0c 00 00 be    	add    %ch,-0x41fffff4(%rbp)
 419:	0c 00                	or     $0x0,%al
    pckt->flags |= F_SYN_SET;
 41b:	00 07                	add    %al,(%rdi)
 41d:	0e                   	(bad)
 41e:	00 00                	add    %al,(%rax)
 420:	d0 0c 00             	rorb   (%rax,%rax,1)
 423:	00 d7                	add    %dl,%bh
      pckt->flow.src = iph->saddr;
 425:	0c 00                	or     $0x0,%al
 427:	00 b9 11 00 00 e0    	add    %bh,-0x1fffffef(%rcx)
      pckt->flow.dst = iph->daddr;
 42d:	0c 00                	or     $0x0,%al
 42f:	00 e7                	add    %ah,%bh
 431:	0c 00                	or     $0x0,%al
 433:	00 ef                	add    %ch,%bh
  if (protocol == IPPROTO_ICMPV6) {
 435:	0c 00                	or     $0x0,%al
 437:	00 00                	add    %al,(%rax)
 439:	0d 00 00 06 0d       	or     $0xd060000,%eax
  if (icmp_hdr + 1 > data_end) {
 43e:	00 00                	add    %al,(%rax)
 440:	d9 0c 00             	(bad)  (%rax,%rax,1)
 443:	00 d2                	add    %dl,%dl
 445:	0c 00                	or     $0x0,%al
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 447:	00 0e                	add    %cl,(%rsi)
 449:	0d 00 00 0a 0d       	or     $0xd0a0000,%eax
 44e:	00 00                	add    %al,(%rax)
 450:	12 0d 00 00 15 0d    	adc    0xd150000(%rip),%cl        # d150456 <_license+0xd14e0c1>
 456:	00 00                	add    %al,(%rax)
 458:	1a 0d 00 00 1f 0d    	sbb    0xd1f0000(%rip),%cl        # d1f045e <_license+0xd1ee0c9>
 45e:	00 00                	add    %al,(%rax)
 460:	14 06                	adc    $0x6,%al
 462:	00 00                	add    %al,(%rax)
 464:	23 0d 00 00 27 0d    	and    0xd270000(%rip),%ecx        # d27046a <_license+0xd26e0d5>
 46a:	00 00                	add    %al,(%rax)
 46c:	2b 0d 00 00 2f 0d    	sub    0xd2f0000(%rip),%ecx        # d2f0472 <_license+0xd2ee0dd>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 472:	00 00                	add    %al,(%rax)
 474:	33 0d 00 00 37 0d    	xor    0xd370000(%rip),%ecx        # d37047a <_license+0xd36e0e5>
 47a:	00 00                	add    %al,(%rax)
 47c:	3b 0d 00 00 42 0d    	cmp    0xd420000(%rip),%ecx        # d420482 <_license+0xd41e0ed>
 482:	00 00                	add    %al,(%rax)
 484:	4a 0d 00 00 51 0d    	rex.WX or $0xd510000,%rax
 48a:	00 00                	add    %al,(%rax)
 48c:	5d                   	pop    %rbp
 48d:	0d 00 00 6d 0d       	or     $0xd6d0000,%eax
 492:	00 00                	add    %al,(%rax)
 494:	76 0d                	jbe    4a3 <balancer_ingress+0x4a3>
 496:	00 00                	add    %al,(%rax)
 498:	86 0d 00 00 f3 05    	xchg   %cl,0x5f30000(%rip)        # 5f3049e <_license+0x5f2e109>
 49e:	00 00                	add    %al,(%rax)
 4a0:	9f                   	lahf
 4a1:	0d 00 00 56 0d       	or     $0xd560000,%eax
 4a6:	00 00                	add    %al,(%rax)
 4a8:	ad                   	lods   %ds:(%rsi),%eax
 4a9:	0d 00 00 c7 0d       	or     $0xdc70000,%eax
 4ae:	00 00                	add    %al,(%rax)
  tcp = data + off;
 4b0:	d6                   	(bad)
 4b1:	0d 00 00 e6 0d       	or     $0xde60000,%eax
 4b6:	00 00                	add    %al,(%rax)
 4b8:	f1                   	int1
 4b9:	0d 00 00 fa 0d       	or     $0xdfa0000,%eax
  if (tcp + 1 > data_end) {
 4be:	00 00                	add    %al,(%rax)
 4c0:	03 0e                	add    (%rsi),%ecx
 4c2:	00 00                	add    %al,(%rax)
 4c4:	0b 0e                	or     (%rsi),%ecx
 4c6:	00 00                	add    %al,(%rax)
  if (tcp->syn) {
 4c8:	13 0e                	adc    (%rsi),%ecx
 4ca:	00 00                	add    %al,(%rax)
 4cc:	1f                   	(bad)
 4cd:	0e                   	(bad)
 4ce:	00 00                	add    %al,(%rax)
 4d0:	23 0e                	and    (%rsi),%ecx
    pckt->flags |= F_SYN_SET;
 4d2:	00 00                	add    %al,(%rax)
 4d4:	2c 0e                	sub    $0xe,%al
 4d6:	00 00                	add    %al,(%rax)
 4d8:	31 0e                	xor    %ecx,(%rsi)
 4da:	00 00                	add    %al,(%rax)
 4dc:	37                   	(bad)
 4dd:	0e                   	(bad)
 4de:	00 00                	add    %al,(%rax)
 4e0:	5e                   	pop    %rsi
 4e1:	08 00                	or     %al,(%rax)
 4e3:	00 3b                	add    %bh,(%rbx)
        bpf_map_lookup_elem(&stats, &stats_key);
 4e5:	0e                   	(bad)
 4e6:	00 00                	add    %al,(%rax)
 4e8:	42 0e                	rex.X (bad)
 4ea:	00 00                	add    %al,(%rax)
 4ec:	4b 0e                	rex.WXB (bad)
 4ee:	00 00                	add    %al,(%rax)
 4f0:	ba 0a 00 00 56       	mov    $0x5600000a,%edx
    if (!icmp_ptb_v6_stats) {
 4f5:	0e                   	(bad)
 4f6:	00 00                	add    %al,(%rax)
 4f8:	60                   	(bad)
 4f9:	0e                   	(bad)
    icmp_ptb_v6_stats->v1 += 1;
 4fa:	00 00                	add    %al,(%rax)
 4fc:	69 0e 00 00 70 0e    	imul   $0xe700000,(%rsi),%ecx
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 502:	00 00                	add    %al,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 504:	1b 09                	sbb    (%rcx),%ecx
 506:	00 00                	add    %al,(%rax)
 508:	7e 0e                	jle    518 <balancer_ingress+0x518>
 50a:	00 00                	add    %al,(%rax)
      icmp_ptb_v6_stats->v2 += 1;
 50c:	97                   	xchg   %eax,%edi
 50d:	0e                   	(bad)
 50e:	00 00                	add    %al,(%rax)
  if (ip6h + 1 > data_end) {
 510:	b4 0e                	mov    $0xe,%ah
 512:	00 00                	add    %al,(%rax)
 514:	bc 0e 00 00 ca       	mov    $0xca00000e,%esp
 519:	0e                   	(bad)
 51a:	00 00                	add    %al,(%rax)
  pckt->flow.proto = ip6h->nexthdr;
 51c:	d8 0e                	fmuls  (%rsi)
 51e:	00 00                	add    %al,(%rax)
 520:	f9                   	stc
 521:	0e                   	(bad)
 522:	00 00                	add    %al,(%rax)
 524:	1c 0f                	sbb    $0xf,%al
  pckt->flags |= F_ICMP;
 526:	00 00                	add    %al,(%rax)
 528:	20 0f                	and    %cl,(%rdi)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 52a:	00 00                	add    %al,(%rax)
 52c:	28 0f                	sub    %cl,(%rdi)
 52e:	00 00                	add    %al,(%rax)
 530:	31 0f                	xor    %ecx,(%rdi)
 532:	00 00                	add    %al,(%rax)
 534:	73 0f                	jae    545 <balancer_ingress+0x545>
 536:	00 00                	add    %al,(%rax)
 538:	49 0f 00 00          	rex.WB sldt (%r8)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 53c:	55                   	push   %rbp
 53d:	0f 00 00             	sldt   (%rax)
 540:	44 06                	rex.R (bad)
 542:	00 00                	add    %al,(%rax)
 544:	6e                   	outsb  %ds:(%rsi),(%dx)
 545:	0f 00 00             	sldt   (%rax)
 548:	db 0d 00 00 78 0f    	fisttpl 0xf780000(%rip)        # f78054e <_license+0xf77e1b9>
 54e:	00 00                	add    %al,(%rax)
 550:	87 0f                	xchg   %ecx,(%rdi)
 552:	00 00                	add    %al,(%rax)
 554:	95                   	xchg   %eax,%ebp
 555:	0f 00 00             	sldt   (%rax)
 558:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
 559:	0f 00 00             	sldt   (%rax)
 55c:	ae                   	scas   %es:(%rdi),%al
 55d:	0f 00 00             	sldt   (%rax)
 560:	b5 0f                	mov    $0xf,%ch
 562:	00 00                	add    %al,(%rax)
 564:	c3                   	ret
 565:	0f 00 00             	sldt   (%rax)
 568:	7b 0f                	jnp    579 <balancer_ingress+0x579>
 56a:	00 00                	add    %al,(%rax)
 56c:	d2 0f                	rorb   %cl,(%rdi)
 56e:	00 00                	add    %al,(%rax)
 570:	f4                   	hlt
 571:	0f 00 00             	sldt   (%rax)
 574:	dc 0f                	fmull  (%rdi)
 576:	00 00                	add    %al,(%rax)
 578:	e9 0f 00 00 f9       	jmp    fffffffff900058c <server_id_map+0x36ffe091758c>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 57d:	0f 00 00             	sldt   (%rax)
 580:	0d 10 00 00 27       	or     $0x27000010,%eax
 585:	10 00                	adc    %al,(%rax)
 587:	00 39                	add    %bh,(%rcx)
 589:	10 00                	adc    %al,(%rax)
 58b:	00 4c 10 00          	add    %cl,0x0(%rax,%rdx,1)
BPF_MAP_OPS_INLINE(map_lookup_elem, real_,
 58f:	00 5a 10             	add    %bl,0x10(%rdx)
 592:	00 00                	add    %al,(%rax)
 594:	65 10 00             	adc    %al,%gs:(%rax)
 597:	00 71 10             	add    %dh,0x10(%rcx)
 59a:	00 00                	add    %al,(%rax)
 59c:	7b 10                	jnp    5ae <balancer_ingress+0x5ae>
 59e:	00 00                	add    %al,(%rax)
 5a0:	89 10                	mov    %edx,(%rax)
 5a2:	00 00                	add    %al,(%rax)
 5a4:	a2 10 00 00 b4 10 00 	movabs %al,0xc2000010b4000010
 5ab:	00 c2 
  if (decap_dst_flags) {
 5ad:	10 00                	adc    %al,(%rax)
 5af:	00 dc                	add    %bl,%ah
 5b1:	10 00                	adc    %al,(%rax)
 5b3:	00 e5                	add    %ah,%ch
 5b5:	10 00                	adc    %al,(%rax)
 5b7:	00 fb                	add    %bh,%bl
 5b9:	10 00                	adc    %al,(%rax)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 5bb:	00 09                	add    %cl,(%rcx)
 5bd:	11 00                	adc    %eax,(%rax)
 5bf:	00 0c 11             	add    %cl,(%rcx,%rdx,1)
 5c2:	00 00                	add    %al,(%rax)
 5c4:	90                   	nop
 5c5:	0c 00                	or     $0x0,%al
    if (!data_stats) {
 5c7:	00 1b                	add    %bl,(%rbx)
 5c9:	11 00                	adc    %eax,(%rax)
 5cb:	00 f8                	add    %bh,%al
 5cd:	02 00                	add    (%rax),%al
 5cf:	00 1d 11 00 00 25    	add    %bl,0x25000011(%rip)        # 250005e6 <_license+0x24ffe251>
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
 5d5:	11 00                	adc    %eax,(%rax)
 5d7:	00 2b                	add    %ch,(%rbx)
 5d9:	11 00                	adc    %eax,(%rax)
 5db:	00 30                	add    %dh,(%rax)
 5dd:	11 00                	adc    %eax,(%rax)
 5df:	00 36                	add    %dh,(%rsi)
    if (!--ip6h->hop_limit) {
 5e1:	11 00                	adc    %eax,(%rax)
 5e3:	00 49 11             	add    %cl,0x11(%rcx)
 5e6:	00 00                	add    %al,(%rax)
 5e8:	5b                   	pop    %rbx
 5e9:	11 00                	adc    %eax,(%rax)
 5eb:	00 6d 11             	add    %ch,0x11(%rbp)
 5ee:	00 00                	add    %al,(%rax)
 5f0:	80 11 00             	adcb   $0x0,(%rcx)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
 5f3:	00 93 11 00 00 a4    	add    %dl,-0x5bffffef(%rbx)
 5f9:	11 00                	adc    %eax,(%rax)
 5fb:	00 b1 11 00 00 b7    	add    %dh,-0x48ffffef(%rcx)
 601:	11 00                	adc    %eax,(%rax)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 603:	00 c1                	add    %al,%cl
 605:	11 00                	adc    %eax,(%rax)
 607:	00                   	.byte 0x0
 608:	2d                   	.byte 0x2d
 609:	0d                   	.byte 0xd
	...

Disassembly of section .debug_str:

0000000000000000 <.debug_str>:
  void* data = (void*)(long)ctx->data;
       0:	44                   	rex.R
       1:	65 62                	gs (bad)
       3:	69 61 6e 20 63 6c 61 	imul   $0x616c6320,0x6e(%rcx),%esp
       a:	6e                   	outsb  %ds:(%rsi),(%dx)
       b:	67 20 76 65          	and    %dh,0x65(%esi)
       f:	72 73                	jb     84 <balancer_ingress+0x84>
      11:	69 6f 6e 20 31 38 2e 	imul   $0x2e383120,0x6e(%rdi),%ebp
  void* data_end = (void*)(long)ctx->data_end;
      18:	31 2e                	xor    %ebp,(%rsi)
      1a:	38 20                	cmp    %ah,(%rax)
  if (data + nh_off > data_end) {
      1c:	28 2b                	sub    %ch,(%rbx)
      1e:	2b 32                	sub    (%rdx),%esi
      20:	30 32                	xor    %dh,(%rdx)
      22:	34 30                	xor    $0x30,%al
      24:	37                   	(bad)
      25:	33 31                	xor    (%rcx),%esi
      27:	30 32                	xor    %dh,(%rdx)
      29:	34 38                	xor    $0x38,%al
      2b:	32 36                	xor    (%rsi),%dh
      2d:	2b 33                	sub    (%rbx),%esi
  eth_proto = eth->h_proto; 
      2f:	62 35                	(bad)
      31:	62 35                	(bad)
      33:	63 31                	movsxd (%rcx),%esi
      35:	65 63 34 61          	movsxd %gs:(%rcx,%riz,2),%esi
  if (eth_proto == BE_ETH_P_IP) {
      39:	33 2d 31 7e 65 78    	xor    0x78657e31(%rip),%ebp        # 78657e70 <_license+0x78655adb>
      3f:	70 31                	jo     72 <balancer_ingress+0x72>
      41:	7e 32                	jle    75 <balancer_ingress+0x75>
      43:	30 32                	xor    %dh,(%rdx)
      45:	34 30                	xor    $0x30,%al
      47:	37                   	(bad)
      48:	33 31                	xor    (%rcx),%esi
      4a:	31 34 34             	xor    %esi,(%rsp,%rsi,1)
  struct packet_description pckt = {};
      4d:	38 34 33             	cmp    %dh,(%rbx,%rsi,1)
      50:	2e 31 34 35 29 20 2f 	cs xor %esi,0x752f2029(,%rsi,1)
      57:	75 
      58:	73 72                	jae    cc <balancer_ingress+0xcc>
      5a:	2f                   	(bad)
      5b:	6c                   	insb   (%dx),%es:(%rdi)
      5c:	69 62 2f 6c 6c 76 6d 	imul   $0x6d766c6c,0x2f(%rdx),%esp
      63:	2d 31 38 2f 62       	sub    $0x622f3831,%eax
      68:	69 6e 2f 63 6c 61 6e 	imul   $0x6e616c63,0x2f(%rsi),%ebp
      6f:	67 20 2d 67 20 2d 4f 	and    %ch,0x4f2d2067(%eip)        # 4f2d20dd <_license+0x4f2cfd48>
      76:	33 20                	xor    (%rax),%esp
      78:	2d 66 6c 74 6f       	sub    $0x6f746c66,%eax
      7d:	3d 66 75 6c 6c       	cmp    $0x6c6c7566,%eax
      82:	20 2d 44 20 49 4e    	and    %ch,0x4e492044(%rip)        # 4e4920cc <_license+0x4e48fd37>
  struct vip_definition vip = {};
      88:	4c                   	rex.WR
      89:	49                   	rex.WB
      8a:	4e                   	rex.WRX
      8b:	45 5f                	rex.RB pop %r15
      8d:	44                   	rex.R
      8e:	45                   	rex.RB
      8f:	43                   	rex.XB
      90:	41 50                	push   %r8
      92:	20 2d 44 20 5f 5f    	and    %ch,0x5f5f2044(%rip)        # 5f5f20dc <_license+0x5f5efd47>
      98:	54                   	push   %rsp
      99:	41 52                	push   %r10
      9b:	47                   	rex.RXB
      9c:	45 54                	rex.RB push %r12
    if (iph + 1 > data_end) {
      9e:	5f                   	pop    %rdi
      9f:	41 52                	push   %r10
      a1:	43                   	rex.XB
      a2:	48 5f                	rex.W pop %rdi
      a4:	78 38                	js     de <balancer_ingress+0xde>
      a6:	36 20 2d 44 20 5f 5f 	ss and %ch,0x5f5f2044(%rip)        # 5f5f20f1 <_license+0x5f5efd5c>
    if (iph->ihl != 5) {
      ad:	4b                   	rex.WXB
      ae:	45 52                	rex.RB push %r10
      b0:	4e                   	rex.WRX
      b1:	45                   	rex.RB
      b2:	4c 5f                	rex.WR pop %rdi
      b4:	5f                   	pop    %rdi
      b5:	20 2d 44 20 5f 5f    	and    %ch,0x5f5f2044(%rip)        # 5f5f20ff <_license+0x5f5efd6a>
    pckt->tos = iph->tos;
      bb:	4a                   	rex.WX
      bc:	42 20 2d 57 6e 6f 2d 	rex.X and %bpl,0x2d6f6e57(%rip)        # 2d6f6f1a <_license+0x2d6f4b85>
    *protocol = iph->protocol;
      c3:	75 6e                	jne    133 <balancer_ingress+0x133>
    pckt->flow.proto = *protocol;
      c5:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
    if (iph->frag_off & PCKT_FRAGMENTED) {
      c9:	6e                   	outsb  %ds:(%rsi),(%dx)
      ca:	2d 61 74 74 72       	sub    $0x72747461,%eax
      cf:	69 62 75 74 65 73 20 	imul   $0x20736574,0x75(%rdx),%esp
      d6:	2d 57 6e 6f 2d       	sub    $0x2d6f6e57,%eax
      db:	75 6e                	jne    14b <balancer_ingress+0x14b>
      dd:	75 73                	jne    152 <balancer_ingress+0x152>
    if (*protocol == IPPROTO_ICMP) {
      df:	65 64 2d 76 61 72 69 	gs fs sub $0x69726176,%eax
      e6:	61                   	(bad)
      e7:	62                   	(bad)
  if (icmp_hdr + 1 > data_end) {
      e8:	6c                   	insb   (%dx),%es:(%rdi)
      e9:	65 20 2d 57 6e 6f 2d 	and    %ch,%gs:0x2d6f6e57(%rip)        # 2d6f6f47 <_license+0x2d6f4bb2>
      f0:	70 6f                	jo     161 <balancer_ingress+0x161>
      f2:	69 6e 74 65 72 2d 73 	imul   $0x732d7265,0x74(%rsi),%ebp
  if (icmp_hdr->type == ICMP_ECHO) {
      f9:	69 67 6e 20 2d 57 6e 	imul   $0x6e572d20,0x6e(%rdi),%esp
     100:	6f                   	outsl  %ds:(%rsi),(%dx)
     101:	2d 63 6f 6d 70       	sub    $0x706d6f63,%eax
     106:	61                   	(bad)
     107:	72 65                	jb     16e <balancer_ingress+0x16e>
     109:	2d 64 69 73 74       	sub    $0x74736964,%eax
     10e:	69 6e 63 74 2d 70 6f 	imul   $0x6f702d74,0x63(%rsi),%ebp
  icmp_hdr->checksum += 0x0008;
     115:	69 6e 74 65 72 2d 74 	imul   $0x742d7265,0x74(%rsi),%ebp
     11c:	79 70                	jns    18e <balancer_ingress+0x18e>
  iph->ttl = DEFAULT_TTL;
     11e:	65 73 20             	gs jae 141 <balancer_ingress+0x141>
     121:	2d 6d 63 6d 6f       	sub    $0x6f6d636d,%eax
     126:	64 65 6c             	fs gs insb (%dx),%es:(%rdi)
     129:	3d 6c 61 72 67       	cmp    $0x6772616c,%eax
  iph->saddr = tmp_addr;
     12e:	65 20 2d 66 6e 6f 2d 	and    %ch,%gs:0x2d6f6e66(%rip)        # 2d6f6f9b <_license+0x2d6f4c06>
    *csum += *next_iph_u16++;
     135:	70 69                	jo     1a0 <balancer_ingress+0x1a0>
     137:	63 20                	movsxd (%rax),%esp
     139:	2d 66 6e 6f 2d       	sub    $0x2d6f6e66,%eax
     13e:	70 69                	jo     1a9 <balancer_ingress+0x1a9>
     140:	65 20 2d 6e 6f 2d 70 	and    %ch,%gs:0x702d6f6e(%rip)        # 702d70b5 <_license+0x702d4d20>
     147:	69 65 20 2d 6e 6f 73 	imul   $0x736f6e2d,0x20(%rbp),%esp
     14e:	74 61                	je     1b1 <balancer_ingress+0x1b1>
     150:	72 74                	jb     1c6 <balancer_ingress+0x1c6>
     152:	66 69 6c 65 73 20 2d 	imul   $0x2d20,0x73(%rbp,%riz,2),%bp
  struct packet_description pckt = {};
     159:	66 63 66 2d          	movsxd 0x2d(%rsi),%sp
     15d:	70 72                	jo     1d1 <balancer_ingress+0x1d1>
     15f:	6f                   	outsl  %ds:(%rsi),(%dx)
     160:	74 65                	je     1c7 <balancer_ingress+0x1c7>
     162:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
     166:	6e                   	outsb  %ds:(%rsi),(%dx)
     167:	3d 62 72 61 6e       	cmp    $0x6e617262,%eax
     16c:	63 68 20             	movsxd 0x20(%rax),%ebp
     16f:	2d 6d 73 6b 69       	sub    $0x696b736d,%eax
     174:	70 2d                	jo     1a3 <balancer_ingress+0x1a3>
     176:	72 61                	jb     1d9 <balancer_ingress+0x1d9>
     178:	78 2d                	js     1a7 <balancer_ingress+0x1a7>
     17a:	73 65                	jae    1e1 <balancer_ingress+0x1e1>
     17c:	74 75                	je     1f3 <balancer_ingress+0x1f3>
     17e:	70 20                	jo     1a0 <balancer_ingress+0x1a0>
     180:	2d 66 6e 6f 2d       	sub    $0x2d6f6e66,%eax
     185:	6a 75                	push   $0x75
     187:	6d                   	insl   (%dx),%es:(%rdi)
     188:	70 2d                	jo     1b7 <balancer_ingress+0x1b7>
     18a:	74 61                	je     1ed <balancer_ingress+0x1ed>
     18c:	62                   	(bad)
     18d:	6c                   	insb   (%dx),%es:(%rdi)
  struct vip_definition vip = {};
     18e:	65 73 20             	gs jae 1b1 <balancer_ingress+0x1b1>
     191:	2d 6d 6e 6f 2d       	sub    $0x2d6f6e6d,%eax
     196:	72 65                	jb     1fd <balancer_ingress+0x1fd>
     198:	64 2d 7a 6f 6e 65    	fs sub $0x656e6f7a,%eax
     19e:	20 2d 6d 6e 6f 2d    	and    %ch,0x2d6f6e6d(%rip)        # 2d6f7011 <_license+0x2d6f4c7c>
     1a4:	73 73                	jae    219 <balancer_ingress+0x219>
     1a6:	65 20 2d 6d 6e 6f 2d 	and    %ch,%gs:0x2d6f6e6d(%rip)        # 2d6f701a <_license+0x2d6f4c85>
    if (ip6h + 1 > data_end) {
     1ad:	73 73                	jae    222 <balancer_ingress+0x222>
     1af:	65 32 20             	xor    %gs:(%rax),%ah
     1b2:	2d 6d 6e 6f 2d       	sub    $0x2d6f6e6d,%eax
    *protocol = ip6h->nexthdr;
     1b7:	61                   	(bad)
     1b8:	76 78                	jbe    232 <balancer_ingress+0x232>
    pckt->flow.proto = *protocol;
     1ba:	20 2d 6d 6e 6f 2d    	and    %ch,0x2d6f6e6d(%rip)        # 2d6f702d <_license+0x2d6f4c98>
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1c0:	6d                   	insl   (%dx),%es:(%rdi)
     1c1:	6d                   	insl   (%dx),%es:(%rdi)
     1c2:	78 20                	js     1e4 <balancer_ingress+0x1e4>
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1c4:	2d 6d 6e 6f 2d       	sub    $0x2d6f6e6d,%eax
     1c9:	78 38                	js     203 <balancer_ingress+0x203>
     1cb:	37                   	(bad)
     1cc:	20 2d 6d 6e 6f 2d    	and    %ch,0x2d6f6e6d(%rip)        # 2d6f703f <_license+0x2d6f4caa>
     1d2:	78 38                	js     20c <balancer_ingress+0x20c>
    *protocol = ip6h->nexthdr;
     1d4:	37                   	(bad)
     1d5:	20 2d 66 6e 6f 2d    	and    %ch,0x2d6f6e66(%rip)        # 2d6f7041 <_license+0x2d6f4cac>
    if (*protocol == IPPROTO_FRAGMENT) {
     1db:	64 65 6c             	fs gs insb (%dx),%es:(%rdi)
     1de:	65 74 65             	gs je  246 <balancer_ingress+0x246>
     1e1:	2d 6e 75 6c 6c       	sub    $0x6c6c756e,%eax
     1e6:	2d 70 6f 69 6e       	sub    $0x6e696f70,%eax
  if (icmp_hdr + 1 > data_end) {
     1eb:	74 65                	je     252 <balancer_ingress+0x252>
     1ed:	72 2d                	jb     21c <balancer_ingress+0x21c>
     1ef:	63 68 65             	movsxd 0x65(%rax),%ebp
     1f2:	63 6b 73             	movsxd 0x73(%rbx),%ebp
     1f5:	20 2d 57 66 72 61    	and    %ch,0x61726657(%rip)        # 61726852 <_license+0x617244bd>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1fb:	6d                   	insl   (%dx),%es:(%rdi)
     1fc:	65 2d 6c 61 72 67    	gs sub $0x6772616c,%eax
     202:	65 72 2d             	gs jb  232 <balancer_ingress+0x232>
     205:	74 68                	je     26f <balancer_ingress+0x26f>
     207:	61                   	(bad)
     208:	6e                   	outsb  %ds:(%rsi),(%dx)
     209:	3d 35 31 32 20       	cmp    $0x20323135,%eax
     20e:	2d 49 20 2e 2f       	sub    $0x2f2e2049,%eax
     213:	2e 68 65 61 64 65    	cs push $0x65646165
     219:	72 5f                	jb     27a <balancer_ingress+0x27a>
     21b:	6f                   	outsl  %ds:(%rsi),(%dx)
     21c:	76 65                	jbe    283 <balancer_ingress+0x283>
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
     21e:	72 72                	jb     292 <balancer_ingress+0x292>
     220:	69 64 65 2f 36 2f 20 	imul   $0x2d202f36,0x2f(%rbp,%riz,2),%esp
     227:	2d 
  ip6h->hop_limit = DEFAULT_TTL;
     228:	49 20 2e             	rex.WB and %bpl,(%r14)
     22b:	2f                   	(bad)
     22c:	75 73                	jne    2a1 <balancer_ingress+0x2a1>
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
     22e:	72 2f                	jb     25f <balancer_ingress+0x25f>
     230:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
     237:	20 2d 49 20 2e 2f    	and    %ch,0x2f2e2049(%rip)        # 2f2e2286 <_license+0x2f2dfef1>
     23d:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
     244:	20 2d 49 20 2e 20    	and    %ch,0x202e2049(%rip)        # 202e2293 <_license+0x202dfefe>
     24a:	2d 49 20 2e 2f       	sub    $0x2f2e2049,%eax
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
     24f:	76 6d                	jbe    2be <balancer_ingress+0x2be>
     251:	6c                   	insb   (%dx),%es:(%rdi)
     252:	69 6e 75 78 2f 20 2d 	imul   $0x2d202f78,0x75(%rsi),%ebp
     259:	57                   	push   %rdi
     25a:	6c                   	insb   (%dx),%es:(%rdi)
     25b:	2c 2d                	sub    $0x2d,%al
     25d:	54                   	push   %rsp
     25e:	2c 2e                	sub    $0x2e,%al
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     260:	2f                   	(bad)
     261:	2e 6c                	cs insb (%dx),%es:(%rdi)
     263:	69 6e 6b 65 72 5f 73 	imul   $0x735f7265,0x6b(%rsi),%ebp
     26a:	63 72 69             	movsxd 0x69(%rdx),%esi
     26d:	70 74                	jo     2e3 <balancer_ingress+0x2e3>
     26f:	73 2f                	jae    2a0 <balancer_ingress+0x2a0>
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     271:	62 61 6c 61 6e       	(bad)
     276:	63 65 72             	movsxd 0x72(%rbp),%esp
     279:	2e 62                	cs (bad)
     27b:	70 66                	jo     2e3 <balancer_ingress+0x2e3>
     27d:	2e 6c                	cs insb (%dx),%es:(%rdi)
     27f:	64 20 6b 61          	and    %ch,%fs:0x61(%rbx)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     283:	74 72                	je     2f7 <balancer_ingress+0x2f7>
     285:	61                   	(bad)
     286:	6e                   	outsb  %ds:(%rsi),(%dx)
     287:	2f                   	(bad)
     288:	6c                   	insb   (%dx),%es:(%rdi)
     289:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
     290:	62 61 6c 61 6e       	(bad)
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     295:	63 65 72             	movsxd 0x72(%rbp),%esp
     298:	2e 62                	cs (bad)
     29a:	70 66                	jo     302 <balancer_ingress+0x302>
     29c:	2e 63 20             	cs movsxd (%rax),%esp
     29f:	2d 6f 20 62 70       	sub    $0x7062206f,%eax
     2a4:	66 2f                	data16 (bad)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2a6:	6e                   	outsb  %ds:(%rsi),(%dx)
     2a7:	61                   	(bad)
     2a8:	74 69                	je     313 <balancer_ingress+0x313>
     2aa:	76 65                	jbe    311 <balancer_ingress+0x311>
     2ac:	2f                   	(bad)
     2ad:	62 61 6c 61 6e       	(bad)
     2b2:	63 65 72             	movsxd 0x72(%rbp),%esp
     2b5:	2e 62                	cs (bad)
  if (protocol == IPPROTO_ICMPV6) {
     2b7:	70 66                	jo     31f <balancer_ingress+0x31f>
     2b9:	20 2d 64 75 6d 70    	and    %ch,0x706d7564(%rip)        # 706d7823 <_license+0x706d548e>
     2bf:	64 69 72 20 62 70 66 	imul   $0x2f667062,%fs:0x20(%rdx),%esi
     2c6:	2f 
  if (icmp_hdr + 1 > data_end) {
     2c7:	6e                   	outsb  %ds:(%rsi),(%dx)
     2c8:	61                   	(bad)
     2c9:	74 69                	je     334 <balancer_ingress+0x334>
     2cb:	76 65                	jbe    332 <balancer_ingress+0x332>
  if (icmp_hdr->type == ICMP_ECHO) {
     2cd:	2f                   	(bad)
     2ce:	62 61 6c 61 6e       	(bad)
     2d3:	63 65 72             	movsxd 0x72(%rbp),%esp
     2d6:	2e 62                	cs (bad)
     2d8:	70 66                	jo     340 <balancer_ingress+0x340>
     2da:	2d 00 6b 61 74       	sub    $0x74616b00,%eax
     2df:	72 61                	jb     342 <balancer_ingress+0x342>
     2e1:	6e                   	outsb  %ds:(%rsi),(%dx)
     2e2:	2f                   	(bad)
     2e3:	6c                   	insb   (%dx),%es:(%rdi)
     2e4:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
  icmp_hdr->type = ICMP_ECHOREPLY;
     2eb:	62 61 6c 61 6e       	(bad)
  icmp_hdr->checksum += 0x0008;
     2f0:	63 65 72             	movsxd 0x72(%rbp),%esp
  iph->ttl = DEFAULT_TTL;
     2f3:	2e 62                	cs (bad)
     2f5:	70 66                	jo     35d <balancer_ingress+0x35d>
     2f7:	2e 63 00             	cs movsxd (%rax),%eax
     2fa:	2f                   	(bad)
     2fb:	72 6f                	jb     36c <balancer_ingress+0x36c>
     2fd:	6f                   	outsl  %ds:(%rsi),(%dx)
     2fe:	74 2f                	je     32f <balancer_ingress+0x32f>
  iph->daddr = iph->saddr;
     300:	57                   	push   %rdi
     301:	6f                   	outsl  %ds:(%rsi),(%dx)
     302:	72 6b                	jb     36f <balancer_ingress+0x36f>
  iph->saddr = tmp_addr;
     304:	73 70                	jae    376 <balancer_ingress+0x376>
     306:	61                   	(bad)
     307:	63 65 2f             	movsxd 0x2f(%rbp),%esp
     30a:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
     30e:	61                   	(bad)
     30f:	6e                   	outsb  %ds:(%rsi),(%dx)
     310:	2f                   	(bad)
     311:	5f                   	pop    %rdi
     312:	62 75                	(bad)
     314:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
     31b:	73 
     31c:	2f                   	(bad)
     31d:	62                   	(bad)
     31e:	70 66                	jo     386 <balancer_ingress+0x386>
     320:	70 72                	jo     394 <balancer_ingress+0x394>
     322:	6f                   	outsl  %ds:(%rsi),(%dx)
     323:	67 00 5f 6c          	add    %bl,0x6c(%edi)
     327:	69 63 65 6e 73 65 00 	imul   $0x65736e,0x65(%rbx),%esp
     32e:	5f                   	pop    %rdi
     32f:	5f                   	pop    %rdi
     330:	41 52                	push   %r10
     332:	52                   	push   %rdx
     333:	41 59                	pop    %r9
     335:	5f                   	pop    %rdi
     336:	53                   	push   %rbx
     337:	49 5a                	rex.WB pop %r10
     339:	45 5f                	rex.RB pop %r15
     33b:	54                   	push   %rsp
     33c:	59                   	pop    %rcx
     33d:	50                   	push   %rax
     33e:	45 5f                	rex.RB pop %r15
    if (csum >> 16)
     340:	5f                   	pop    %rdi
     341:	00 63 74             	add    %ah,0x74(%rbx)
     344:	6c                   	insb   (%dx),%es:(%rdi)
     345:	5f                   	pop    %rdi
     346:	61                   	(bad)
     347:	72 72                	jb     3bb <balancer_ingress+0x3bb>
     349:	61                   	(bad)
     34a:	79 00                	jns    34c <balancer_ingress+0x34c>
     34c:	75 6e                	jne    3bc <balancer_ingress+0x3bc>
     34e:	73 69                	jae    3b9 <balancer_ingress+0x3b9>
     350:	67 6e                	outsb  %ds:(%esi),(%dx)
     352:	65 64 20 69 6e       	gs and %ch,%fs:0x6e(%rcx)
     357:	74 00                	je     359 <balancer_ingress+0x359>
     359:	5f                   	pop    %rdi
     35a:	5f                   	pop    %rdi
     35b:	75 33                	jne    390 <balancer_ingress+0x390>
     35d:	32 00                	xor    (%rax),%al
     35f:	75 6e                	jne    3cf <balancer_ingress+0x3cf>
     361:	73 69                	jae    3cc <balancer_ingress+0x3cc>
     363:	67 6e                	outsb  %ds:(%esi),(%dx)
     365:	65 64 20 6c 6f 6e    	gs and %ch,%fs:0x6e(%rdi,%rbp,2)
     36b:	67 20 6c 6f 6e       	and    %ch,0x6e(%edi,%ebp,2)
     370:	67 00 5f 5f          	add    %bl,0x5f(%edi)
     374:	75 36                	jne    3ac <balancer_ingress+0x3ac>
     376:	34 00                	xor    $0x0,%al
     378:	69 66 69 6e 64 65 78 	imul   $0x7865646e,0x69(%rsi),%esp
     37f:	00 75 6e             	add    %dh,0x6e(%rbp)
     382:	73 69                	jae    3ed <balancer_ingress+0x3ed>
     384:	67 6e                	outsb  %ds:(%esi),(%dx)
     386:	65 64 20 63 68       	gs and %ah,%fs:0x68(%rbx)
  return ~csum;
     38b:	61                   	(bad)
     38c:	72 00                	jb     38e <balancer_ingress+0x38e>
  iph->check = csum;
     38e:	5f                   	pop    %rdi
     38f:	5f                   	pop    %rdi
     390:	75 38                	jne    3ca <balancer_ingress+0x3ca>
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     392:	00 63 74             	add    %ah,0x74(%rbx)
     395:	6c                   	insb   (%dx),%es:(%rdi)
     396:	5f                   	pop    %rdi
     397:	76 61                	jbe    3fa <balancer_ingress+0x3fa>
     399:	6c                   	insb   (%dx),%es:(%rdi)
     39a:	75 65                	jne    401 <balancer_ingress+0x401>
     39c:	00 6d 61             	add    %ch,0x61(%rbp)
     39f:	78 5f                	js     400 <balancer_ingress+0x400>
     3a1:	65 6e                	outsb  %gs:(%rsi),(%dx)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     3a3:	74 72                	je     417 <balancer_ingress+0x417>
     3a5:	69 65 73 00 6d 61 70 	imul   $0x70616d00,0x73(%rbp),%esp
     3ac:	5f                   	pop    %rdi
     3ad:	66 6c                	data16 insb (%dx),%es:(%rdi)
     3af:	61                   	(bad)
     3b0:	67 73 00             	addr32 jae 3b3 <balancer_ingress+0x3b3>
     3b3:	5f                   	pop    %rdi
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     3b4:	5f                   	pop    %rdi
     3b5:	62 65                	(bad)
     3b7:	33 32                	xor    (%rdx),%esi
     3b9:	00 61 64             	add    %ah,0x64(%rcx)
     3bc:	64 72 76             	fs jb  435 <balancer_ingress+0x435>
     3bf:	36 00 61 64          	ss add %ah,0x64(%rcx)
     3c3:	64 72 65             	fs jb  42b <balancer_ingress+0x42b>
     3c6:	73 73                	jae    43b <balancer_ingress+0x43b>
     3c8:	00 73 75             	add    %dh,0x75(%rbx)
     3cb:	62                   	(bad)
     3cc:	70 72                	jo     440 <balancer_ingress+0x440>
     3ce:	6f                   	outsl  %ds:(%rsi),(%dx)
     3cf:	67 72 61             	addr32 jb 433 <balancer_ingress+0x433>
     3d2:	6d                   	insl   (%dx),%es:(%rdi)
  if (protocol == IPPROTO_IPIP) {
     3d3:	73 00                	jae    3d5 <balancer_ingress+0x3d5>
     3d5:	76 69                	jbe    440 <balancer_ingress+0x440>
     3d7:	70 5f                	jo     438 <balancer_ingress+0x438>
     3d9:	6d                   	insl   (%dx),%es:(%rdi)
     3da:	61                   	(bad)
     3db:	70 00                	jo     3dd <balancer_ingress+0x3dd>
     3dd:	76 69                	jbe    448 <balancer_ingress+0x448>
     3df:	70 76                	jo     457 <balancer_ingress+0x457>
     3e1:	36 00 75 6e          	ss add %dh,0x6e(%rbp)
     3e5:	73 69                	jae    450 <balancer_ingress+0x450>
     3e7:	67 6e                	outsb  %ds:(%esi),(%dx)
     3e9:	65 64 20 73 68       	gs and %dh,%fs:0x68(%rbx)
     3ee:	6f                   	outsl  %ds:(%rsi),(%dx)
     3ef:	72 74                	jb     465 <balancer_ingress+0x465>
     3f1:	00 5f 5f             	add    %bl,0x5f(%rdi)
     3f4:	75 31                	jne    427 <balancer_ingress+0x427>
     3f6:	36 00 76 69          	ss add %dh,0x69(%rsi)
  tcp = data + off;
     3fa:	70 5f                	jo     45b <balancer_ingress+0x45b>
     3fc:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
     403:	69 
  if (tcp + 1 > data_end) {
     404:	6f                   	outsl  %ds:(%rsi),(%dx)
     405:	6e                   	outsb  %ds:(%rsi),(%dx)
     406:	00 76 69             	add    %dh,0x69(%rsi)
     409:	70 5f                	jo     46a <balancer_ingress+0x46a>
     40b:	6e                   	outsb  %ds:(%rsi),(%dx)
     40c:	75 6d                	jne    47b <balancer_ingress+0x47b>
     40e:	00 76 69             	add    %dh,0x69(%rsi)
  if (tcp->syn) {
     411:	70 5f                	jo     472 <balancer_ingress+0x472>
     413:	6d                   	insl   (%dx),%es:(%rdi)
     414:	65 74 61             	gs je  478 <balancer_ingress+0x478>
     417:	00 66 61             	add    %ah,0x61(%rsi)
     41a:	6c                   	insb   (%dx),%es:(%rdi)
    pckt->flags |= F_SYN_SET;
     41b:	6c                   	insb   (%dx),%es:(%rdi)
     41c:	62 61                	(bad)
     41e:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
     421:	63 61 63             	movsxd 0x63(%rcx),%esp
     424:	68 65 00 73 72       	push   $0x72730065
      pckt->flow.src = iph->saddr;
     429:	63 76 36             	movsxd 0x36(%rsi),%esi
     42c:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
      pckt->flow.dst = iph->daddr;
     430:	76 36                	jbe    468 <balancer_ingress+0x468>
     432:	00 70 6f             	add    %dh,0x6f(%rax)
  if (protocol == IPPROTO_ICMPV6) {
     435:	72 74                	jb     4ab <balancer_ingress+0x4ab>
     437:	73 00                	jae    439 <balancer_ingress+0x439>
     439:	70 6f                	jo     4aa <balancer_ingress+0x4aa>
  if (icmp_hdr + 1 > data_end) {
     43b:	72 74                	jb     4b1 <balancer_ingress+0x4b1>
     43d:	31 36                	xor    %esi,(%rsi)
     43f:	00 66 6c             	add    %ah,0x6c(%rsi)
     442:	6f                   	outsl  %ds:(%rsi),(%dx)
     443:	77 5f                	ja     4a4 <balancer_ingress+0x4a4>
     445:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     449:	61                   	(bad)
     44a:	74 69                	je     4b5 <balancer_ingress+0x4b5>
     44c:	6d                   	insl   (%dx),%es:(%rdi)
     44d:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
     451:	61                   	(bad)
     452:	6c                   	insb   (%dx),%es:(%rdi)
     453:	5f                   	pop    %rdi
     454:	70 6f                	jo     4c5 <balancer_ingress+0x4c5>
     456:	73 5f                	jae    4b7 <balancer_ingress+0x4b7>
     458:	6c                   	insb   (%dx),%es:(%rdi)
     459:	72 75                	jb     4d0 <balancer_ingress+0x4d0>
     45b:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
     45f:	5f                   	pop    %rdi
     460:	6d                   	insl   (%dx),%es:(%rdi)
     461:	61                   	(bad)
     462:	70 70                	jo     4d4 <balancer_ingress+0x4d4>
     464:	69 6e 67 00 76 61 6c 	imul   $0x6c617600,0x67(%rsi),%ebp
     46b:	75 65                	jne    4d2 <balancer_ingress+0x4d2>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     46d:	73 00                	jae    46f <balancer_ingress+0x46f>
     46f:	63 68 5f             	movsxd 0x5f(%rax),%ebp
     472:	72 69                	jb     4dd <balancer_ingress+0x4dd>
     474:	6e                   	outsb  %ds:(%rsi),(%dx)
     475:	67 73 00             	addr32 jae 478 <balancer_ingress+0x478>
       sizeof(struct icmp6hdr)) > data_end) {
     478:	72 65                	jb     4df <balancer_ingress+0x4df>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     47a:	61                   	(bad)
     47b:	6c                   	insb   (%dx),%es:(%rdi)
     47c:	73 00                	jae    47e <balancer_ingress+0x47e>
     47e:	72 65                	jb     4e5 <balancer_ingress+0x4e5>
     480:	61                   	(bad)
     481:	6c                   	insb   (%dx),%es:(%rdi)
     482:	5f                   	pop    %rdi
     483:	64 65 66 69 6e 69 74 	fs imul $0x6974,%gs:0x69(%rsi),%bp
     48a:	69 
     48b:	6f                   	outsl  %ds:(%rsi),(%dx)
     48c:	6e                   	outsb  %ds:(%rsi),(%dx)
     48d:	00 72 65             	add    %dh,0x65(%rdx)
     490:	61                   	(bad)
     491:	6c                   	insb   (%dx),%es:(%rdi)
     492:	73 5f                	jae    4f3 <balancer_ingress+0x4f3>
     494:	73 74                	jae    50a <balancer_ingress+0x50a>
     496:	61                   	(bad)
     497:	74 73                	je     50c <balancer_ingress+0x50c>
     499:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
     49d:	73 74                	jae    513 <balancer_ingress+0x513>
     49f:	61                   	(bad)
     4a0:	74 73                	je     515 <balancer_ingress+0x515>
     4a2:	00 76 69             	add    %dh,0x69(%rsi)
     4a5:	70 5f                	jo     506 <balancer_ingress+0x506>
     4a7:	6d                   	insl   (%dx),%es:(%rdi)
     4a8:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
     4af:	74 73                	je     524 <balancer_ingress+0x524>
  tcp = data + off;
     4b1:	00 71 75             	add    %dh,0x75(%rcx)
  if (is_ipv6) {
     4b4:	69 63 5f 73 74 61 74 	imul   $0x74617473,0x5f(%rbx),%esp
  if (tcp + 1 > data_end) {
     4bb:	73 5f                	jae    51c <balancer_ingress+0x51c>
     4bd:	6d                   	insl   (%dx),%es:(%rdi)
     4be:	61                   	(bad)
     4bf:	70 00                	jo     4c1 <balancer_ingress+0x4c1>
     4c1:	63 68 5f             	movsxd 0x5f(%rax),%ebp
     4c4:	72 6f                	jb     535 <balancer_ingress+0x535>
     4c6:	75 74                	jne    53c <balancer_ingress+0x53c>
  if (tcp->syn) {
     4c8:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
     4cd:	64 5f                	fs pop %rdi
     4cf:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
    pckt->flags |= F_SYN_SET;
     4d6:	00 63 69             	add    %ah,0x69(%rbx)
     4d9:	64 5f                	fs pop %rdi
     4db:	69 6e 76 61 6c 69 64 	imul   $0x64696c61,0x76(%rsi),%ebp
     4e2:	5f                   	pop    %rdi
     4e3:	73 65                	jae    54a <balancer_ingress+0x54a>
        bpf_map_lookup_elem(&stats, &stats_key);
     4e5:	72 76                	jb     55d <balancer_ingress+0x55d>
     4e7:	65 72 5f             	gs jb  549 <balancer_ingress+0x549>
     4ea:	69 64 00 63 69 64 5f 	imul   $0x695f6469,0x63(%rax,%rax,1),%esp
     4f1:	69 
    if (!icmp_ptb_v6_stats) {
     4f2:	6e                   	outsb  %ds:(%rsi),(%dx)
     4f3:	76 61                	jbe    556 <balancer_ingress+0x556>
     4f5:	6c                   	insb   (%dx),%es:(%rdi)
     4f6:	69 64 5f 73 65 72 76 	imul   $0x65767265,0x73(%rdi,%rbx,2),%esp
     4fd:	65 
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4fe:	72 5f                	jb     55f <balancer_ingress+0x55f>
     500:	69 64 5f 73 61 6d 70 	imul   $0x6c706d61,0x73(%rdi,%rbx,2),%esp
     507:	6c 
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     508:	65 00 63 69          	add    %ah,%gs:0x69(%rbx)
      icmp_ptb_v6_stats->v2 += 1;
     50c:	64 5f                	fs pop %rdi
     50e:	72 6f                	jb     57f <balancer_ingress+0x57f>
  if (ip6h + 1 > data_end) {
     510:	75 74                	jne    586 <balancer_ingress+0x586>
     512:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
     517:	64 5f                	fs pop %rdi
     519:	75 6e                	jne    589 <balancer_ingress+0x589>
     51b:	6b 6e 6f 77          	imul   $0x77,0x6f(%rsi),%ebp
  pckt->flow.proto = ip6h->nexthdr;
     51f:	6e                   	outsb  %ds:(%rsi),(%dx)
     520:	5f                   	pop    %rdi
     521:	72 65                	jb     588 <balancer_ingress+0x588>
     523:	61                   	(bad)
     524:	6c                   	insb   (%dx),%es:(%rdi)
  pckt->flags |= F_ICMP;
     525:	5f                   	pop    %rdi
     526:	64 72 6f             	fs jb  598 <balancer_ingress+0x598>
     529:	70 70                	jo     59b <balancer_ingress+0x59b>
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     52b:	65 64 00 63 69       	gs add %ah,%fs:0x69(%rbx)
     530:	64 5f                	fs pop %rdi
     532:	76 30                	jbe    564 <balancer_ingress+0x564>
     534:	00 63 69             	add    %ah,0x69(%rbx)
     537:	64 5f                	fs pop %rdi
     539:	76 31                	jbe    56c <balancer_ingress+0x56c>
     53b:	00 63 69             	add    %ah,0x69(%rbx)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     53e:	64 5f                	fs pop %rdi
     540:	76 32                	jbe    574 <balancer_ingress+0x574>
     542:	00 63 69             	add    %ah,0x69(%rbx)
     545:	64 5f                	fs pop %rdi
     547:	76 33                	jbe    57c <balancer_ingress+0x57c>
     549:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
     54d:	5f                   	pop    %rdi
     54e:	6d                   	insl   (%dx),%es:(%rdi)
     54f:	61                   	(bad)
     550:	74 63                	je     5b5 <balancer_ingress+0x5b5>
     552:	68 5f 69 6e 5f       	push   $0x5f6e695f
     557:	6c                   	insb   (%dx),%es:(%rdi)
     558:	72 75                	jb     5cf <balancer_ingress+0x5cf>
     55a:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
     55e:	5f                   	pop    %rdi
     55f:	6d                   	insl   (%dx),%es:(%rdi)
     560:	69 73 6d 61 74 63 68 	imul   $0x68637461,0x6d(%rbx),%esi
     567:	5f                   	pop    %rdi
     568:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
     56f:	64 73 74             	fs jae 5e6 <balancer_ingress+0x5e6>
     572:	5f                   	pop    %rdi
     573:	6e                   	outsb  %ds:(%rsi),(%dx)
     574:	6f                   	outsl  %ds:(%rsi),(%dx)
     575:	74 5f                	je     5d6 <balancer_ingress+0x5d6>
     577:	66 6f                	outsw  %ds:(%rsi),(%dx)
     579:	75 6e                	jne    5e9 <balancer_ingress+0x5e9>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     57b:	64 5f                	fs pop %rdi
     57d:	69 6e 5f 6c 72 75 00 	imul   $0x75726c,0x5f(%rsi),%ebp
     584:	6c                   	insb   (%dx),%es:(%rdi)
     585:	62                   	(bad)
     586:	5f                   	pop    %rdi
     587:	71 75                	jno    5fe <balancer_ingress+0x5fe>
     589:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
     590:	65 74 73             	gs je  606 <balancer_ingress+0x606>
     593:	5f                   	pop    %rdi
     594:	73 74                	jae    60a <balancer_ingress+0x60a>
     596:	61                   	(bad)
     597:	74 73                	je     60c <balancer_ingress+0x60c>
     599:	00 73 74             	add    %dh,0x74(%rbx)
     59c:	61                   	(bad)
     59d:	62                   	(bad)
     59e:	6c                   	insb   (%dx),%es:(%rdi)
     59f:	65 5f                	gs pop %rdi
     5a1:	72 74                	jb     617 <balancer_ingress+0x617>
     5a3:	5f                   	pop    %rdi
     5a4:	73 74                	jae    61a <balancer_ingress+0x61a>
     5a6:	61                   	(bad)
     5a7:	74 73                	je     61c <balancer_ingress+0x61c>
     5a9:	00 69 6e             	add    %ch,0x6e(%rcx)
  if (decap_dst_flags) {
     5ac:	76 61                	jbe    60f <balancer_ingress+0x60f>
     5ae:	6c                   	insb   (%dx),%es:(%rdi)
     5af:	69 64 5f 70 61 63 6b 	imul   $0x656b6361,0x70(%rdi,%rbx,2),%esp
     5b6:	65 
     5b7:	74 5f                	je     618 <balancer_ingress+0x618>
     5b9:	74 79                	je     634 <balancer_ingress+0x634>
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     5bb:	70 65                	jo     622 <balancer_ingress+0x622>
     5bd:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
     5c1:	73 74                	jae    637 <balancer_ingress+0x637>
     5c3:	61                   	(bad)
     5c4:	62                   	(bad)
     5c5:	6c                   	insb   (%dx),%es:(%rdi)
     5c6:	65 5f                	gs pop %rdi
    if (!data_stats) {
     5c8:	72 74                	jb     63e <balancer_ingress+0x63e>
     5ca:	5f                   	pop    %rdi
     5cb:	70 61                	jo     62e <balancer_ingress+0x62e>
     5cd:	63 6b 65             	movsxd 0x65(%rbx),%ebp
    data_stats->v1 += 1;
     5d0:	74 73                	je     645 <balancer_ingress+0x645>
     5d2:	5f                   	pop    %rdi
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5d3:	73 74                	jae    649 <balancer_ingress+0x649>
     5d5:	61                   	(bad)
     5d6:	74 73                	je     64b <balancer_ingress+0x64b>
     5d8:	00 64 65 63          	add    %ah,0x63(%rbp,%riz,2)
     5dc:	61                   	(bad)
     5dd:	70 5f                	jo     63e <balancer_ingress+0x63e>
     5df:	76 69                	jbe    64a <balancer_ingress+0x64a>
    if (!--ip6h->hop_limit) {
     5e1:	70 5f                	jo     642 <balancer_ingress+0x642>
     5e3:	73 74                	jae    659 <balancer_ingress+0x659>
     5e5:	61                   	(bad)
     5e6:	74 73                	je     65b <balancer_ingress+0x65b>
     5e8:	00 73 65             	add    %dh,0x65(%rbx)
     5eb:	72 76                	jb     663 <balancer_ingress+0x663>
     5ed:	65 72 5f             	gs jb  64f <balancer_ingress+0x64f>
     5f0:	69 64 5f 6d 61 70 00 	imul   $0x74007061,0x6d(%rdi,%rbx,2),%esp
     5f7:	74 
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5f8:	70 72                	jo     66c <balancer_ingress+0x66c>
     5fa:	5f                   	pop    %rdi
     5fb:	73 74                	jae    671 <balancer_ingress+0x671>
     5fd:	61                   	(bad)
     5fe:	74 73                	je     673 <balancer_ingress+0x673>
     600:	5f                   	pop    %rdi
     601:	6d                   	insl   (%dx),%es:(%rdi)
     602:	61                   	(bad)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     603:	70 00                	jo     605 <balancer_ingress+0x605>
     605:	73 69                	jae    670 <balancer_ingress+0x670>
     607:	64 5f                	fs pop %rdi
     609:	72 6f                	jb     67a <balancer_ingress+0x67a>
     60b:	75 74                	jne    681 <balancer_ingress+0x681>
     60d:	65 64 00 74 63 70    	gs add %dh,%fs:0x70(%rbx,%riz,2)
     613:	5f                   	pop    %rdi
    new_eth->h_proto = BE_ETH_P_IPV6;
     614:	73 79                	jae    68f <balancer_ingress+0x68f>
     616:	6e                   	outsb  %ds:(%rsi),(%dx)
     617:	00 6c 62 5f          	add    %ch,0x5f(%rdx,%riz,2)
     61b:	74 70                	je     68d <balancer_ingress+0x68d>
     61d:	72 5f                	jb     67e <balancer_ingress+0x67e>
     61f:	70 61                	jo     682 <balancer_ingress+0x682>
     621:	63 6b 65             	movsxd 0x65(%rbx),%ebp
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     624:	74 73                	je     699 <balancer_ingress+0x699>
     626:	5f                   	pop    %rdi
     627:	73 74                	jae    69d <balancer_ingress+0x69d>
     629:	61                   	(bad)
     62a:	74 73                	je     69f <balancer_ingress+0x69f>
     62c:	00 73 65             	add    %dh,0x65(%rbx)
     62f:	72 76                	jb     6a7 <balancer_ingress+0x6a7>
     631:	65 72 5f             	gs jb  693 <balancer_ingress+0x693>
     634:	69 64 5f 73 74 61 74 	imul   $0x73746174,0x73(%rdi,%rbx,2),%esp
     63b:	73 
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     63c:	00 76 69             	add    %dh,0x69(%rsi)
     63f:	70 5f                	jo     6a0 <balancer_ingress+0x6a0>
     641:	74 6f                	je     6b2 <balancer_ingress+0x6b2>
     643:	5f                   	pop    %rdi
     644:	64 6f                	outsl  %fs:(%rsi),(%dx)
     646:	77 6e                	ja     6b6 <balancer_ingress+0x6b6>
  if (!data_stats) {
     648:	5f                   	pop    %rdi
     649:	72 65                	jb     6b0 <balancer_ingress+0x6b0>
     64b:	61                   	(bad)
     64c:	6c                   	insb   (%dx),%es:(%rdi)
     64d:	73 5f                	jae    6ae <balancer_ingress+0x6ae>
     64f:	6d                   	insl   (%dx),%es:(%rdi)
     650:	61                   	(bad)
     651:	70 00                	jo     653 <balancer_ingress+0x653>
     653:	62                   	(bad)
     654:	70 66                	jo     6bc <balancer_ingress+0x6bc>
    data_stats->v2 += 1;
     656:	5f                   	pop    %rdi
     657:	78 64                	js     6bd <balancer_ingress+0x6bd>
  if (action >= 0) {
     659:	70 5f                	jo     6ba <balancer_ingress+0x6ba>
     65b:	61                   	(bad)
     65c:	64 6a 75             	fs push $0x75
     65f:	73 74                	jae    6d5 <balancer_ingress+0x6d5>
     661:	5f                   	pop    %rdi
     662:	68 65 61 64 00       	push   $0x646165
     667:	62                   	(bad)
     668:	70 66                	jo     6d0 <balancer_ingress+0x6d0>
     66a:	5f                   	pop    %rdi
     66b:	6b 74 69 6d 65       	imul   $0x65,0x6d(%rcx,%rbp,2),%esi
     670:	5f                   	pop    %rdi
     671:	67 65 74 5f          	addr32 gs je 6d4 <balancer_ingress+0x6d4>
     675:	6e                   	outsb  %ds:(%rsi),(%dx)
     676:	73 00                	jae    678 <balancer_ingress+0x678>
     678:	58                   	pop    %rax
     679:	44 50                	rex.R push %rax
     67b:	5f                   	pop    %rdi
     67c:	41                   	rex.B
     67d:	42                   	rex.X
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     67e:	4f 52                	rex.WRXB push %r10
     680:	54                   	push   %rsp
     681:	45                   	rex.RB
     682:	44 00 58 44          	add    %r11b,0x44(%rax)
     686:	50                   	push   %rax
     687:	5f                   	pop    %rdi
     688:	44 52                	rex.R push %rdx
    if (xpop_stats_data) {
     68a:	4f 50                	rex.WRXB push %r8
     68c:	00 58 44             	add    %bl,0x44(%rax)
        xpop_stats_data->v2 += 1; // IPv6 inner packets
     68f:	50                   	push   %rax
     690:	5f                   	pop    %rdi
     691:	50                   	push   %rax
     692:	41 53                	push   %r11
     694:	53                   	push   %rbx
     695:	00 58 44             	add    %bl,0x44(%rax)
     698:	50                   	push   %rax
     699:	5f                   	pop    %rdi
     69a:	54                   	push   %rsp
     69b:	58                   	pop    %rax
     69c:	00 58 44             	add    %bl,0x44(%rax)
  bpf_tail_call(ctx, &subprograms, i);
     69f:	50                   	push   %rax
     6a0:	5f                   	pop    %rdi
     6a1:	52                   	push   %rdx
     6a2:	45                   	rex.RB
     6a3:	44                   	rex.R
     6a4:	49 52                	rex.WB push %r10
     6a6:	45                   	rex.RB
     6a7:	43 54                	rex.XB push %r12
     6a9:	00 78 64             	add    %bh,0x64(%rax)
     6ac:	70 5f                	jo     70d <balancer_ingress+0x70d>
     6ae:	61                   	(bad)
     6af:	63 74 69 6f          	movsxd 0x6f(%rcx,%rbp,2),%esi
     6b3:	6e                   	outsb  %ds:(%rsi),(%dx)
     6b4:	00 49 50             	add    %cl,0x50(%rcx)
     6b7:	50                   	push   %rax
     6b8:	52                   	push   %rdx
     6b9:	4f 54                	rex.WRXB push %r12
     6bb:	4f 5f                	rex.WRXB pop %r15
     6bd:	49 50                	rex.WB push %r8
     6bf:	00 49 50             	add    %cl,0x50(%rcx)
     6c2:	50                   	push   %rax
     6c3:	52                   	push   %rdx
     6c4:	4f 54                	rex.WRXB push %r12
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     6c6:	4f 5f                	rex.WRXB pop %r15
     6c8:	49                   	rex.WB
     6c9:	43                   	rex.XB
     6ca:	4d 50                	rex.WRB push %r8
     6cc:	00 49 50             	add    %cl,0x50(%rcx)
     6cf:	50                   	push   %rax
     6d0:	52                   	push   %rdx
     6d1:	4f 54                	rex.WRXB push %r12
     6d3:	4f 5f                	rex.WRXB pop %r15
     6d5:	49                   	rex.WB
     6d6:	47                   	rex.RXB
     6d7:	4d 50                	rex.WRB push %r8
     6d9:	00 49 50             	add    %cl,0x50(%rcx)
     6dc:	50                   	push   %rax
     6dd:	52                   	push   %rdx
     6de:	4f 54                	rex.WRXB push %r12
     6e0:	4f 5f                	rex.WRXB pop %r15
     6e2:	49 50                	rex.WB push %r8
     6e4:	49 50                	rex.WB push %r8
     6e6:	00 49 50             	add    %cl,0x50(%rcx)
     6e9:	50                   	push   %rax
     6ea:	52                   	push   %rdx
     6eb:	4f 54                	rex.WRXB push %r12
     6ed:	4f 5f                	rex.WRXB pop %r15
     6ef:	54                   	push   %rsp
     6f0:	43 50                	rex.XB push %r8
     6f2:	00 49 50             	add    %cl,0x50(%rcx)
     6f5:	50                   	push   %rax
     6f6:	52                   	push   %rdx
  if (decap_dst_flags) {
     6f7:	4f 54                	rex.WRXB push %r12
     6f9:	4f 5f                	rex.WRXB pop %r15
     6fb:	45                   	rex.RB
     6fc:	47 50                	rex.RXB push %r8
     6fe:	00 49 50             	add    %cl,0x50(%rcx)
     701:	50                   	push   %rax
     702:	52                   	push   %rdx
     703:	4f 54                	rex.WRXB push %r12
     705:	4f 5f                	rex.WRXB pop %r15
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     707:	50                   	push   %rax
     708:	55                   	push   %rbp
     709:	50                   	push   %rax
     70a:	00 49 50             	add    %cl,0x50(%rcx)
     70d:	50                   	push   %rax
     70e:	52                   	push   %rdx
     70f:	4f 54                	rex.WRXB push %r12
     711:	4f 5f                	rex.WRXB pop %r15
    if (!data_stats) {
     713:	55                   	push   %rbp
     714:	44 50                	rex.R push %rax
     716:	00 49 50             	add    %cl,0x50(%rcx)
     719:	50                   	push   %rax
     71a:	52                   	push   %rdx
    data_stats->v1 += 1;
     71b:	4f 54                	rex.WRXB push %r12
     71d:	4f 5f                	rex.WRXB pop %r15
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     71f:	49                   	rex.WB
     720:	44 50                	rex.R push %rax
     722:	00 49 50             	add    %cl,0x50(%rcx)
     725:	50                   	push   %rax
     726:	52                   	push   %rdx
     727:	4f 54                	rex.WRXB push %r12
     729:	4f 5f                	rex.WRXB pop %r15
     72b:	54                   	push   %rsp
    csum = iph->check + 0x0001;
     72c:	50                   	push   %rax
     72d:	00 49 50             	add    %cl,0x50(%rcx)
     730:	50                   	push   %rax
     731:	52                   	push   %rdx
     732:	4f 54                	rex.WRXB push %r12
    iph->check = (csum & 0xffff) + (csum >> 16);
     734:	4f 5f                	rex.WRXB pop %r15
     736:	44                   	rex.R
     737:	43                   	rex.XB
     738:	43 50                	rex.XB push %r8
     73a:	00 49 50             	add    %cl,0x50(%rcx)
     73d:	50                   	push   %rax
     73e:	52                   	push   %rdx
     73f:	4f 54                	rex.WRXB push %r12
    if (!--iph->ttl) {
     741:	4f 5f                	rex.WRXB pop %r15
     743:	49 50                	rex.WB push %r8
     745:	56                   	push   %rsi
     746:	36 00 49 50          	ss add %cl,0x50(%rcx)
     74a:	50                   	push   %rax
     74b:	52                   	push   %rdx
     74c:	4f 54                	rex.WRXB push %r12
     74e:	4f 5f                	rex.WRXB pop %r15
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     750:	52                   	push   %rdx
     751:	53                   	push   %rbx
     752:	56                   	push   %rsi
     753:	50                   	push   %rax
     754:	00 49 50             	add    %cl,0x50(%rcx)
     757:	50                   	push   %rax
     758:	52                   	push   %rdx
     759:	4f 54                	rex.WRXB push %r12
     75b:	4f 5f                	rex.WRXB pop %r15
     75d:	47 52                	rex.RXB push %r10
     75f:	45 00 49 50          	add    %r9b,0x50(%r9)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     763:	50                   	push   %rax
     764:	52                   	push   %rdx
     765:	4f 54                	rex.WRXB push %r12
     767:	4f 5f                	rex.WRXB pop %r15
     769:	45 53                	rex.RB push %r11
     76b:	50                   	push   %rax
     76c:	00 49 50             	add    %cl,0x50(%rcx)
     76f:	50                   	push   %rax
     770:	52                   	push   %rdx
     771:	4f 54                	rex.WRXB push %r12
    new_eth->h_proto = BE_ETH_P_IP;
     773:	4f 5f                	rex.WRXB pop %r15
     775:	41                   	rex.B
     776:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
     77a:	50                   	push   %rax
     77b:	52                   	push   %rdx
     77c:	4f 54                	rex.WRXB push %r12
     77e:	4f 5f                	rex.WRXB pop %r15
     780:	4d 54                	rex.WRB push %r12
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     782:	50                   	push   %rax
     783:	00 49 50             	add    %cl,0x50(%rcx)
     786:	50                   	push   %rax
     787:	52                   	push   %rdx
     788:	4f 54                	rex.WRXB push %r12
      if (!decap_v6(xdp, data, data_end, true)) {
     78a:	4f 5f                	rex.WRXB pop %r15
     78c:	42                   	rex.X
     78d:	45                   	rex.RB
     78e:	45 54                	rex.RB push %r12
     790:	50                   	push   %rax
     791:	48 00 49 50          	rex.W add %cl,0x50(%rcx)
     795:	50                   	push   %rax
     796:	52                   	push   %rdx
     797:	4f 54                	rex.WRXB push %r12
     799:	4f 5f                	rex.WRXB pop %r15
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     79b:	45                   	rex.RB
     79c:	4e                   	rex.WRX
     79d:	43                   	rex.XB
     79e:	41 50                	push   %r8
     7a0:	00 49 50             	add    %cl,0x50(%rcx)
     7a3:	50                   	push   %rax
     7a4:	52                   	push   %rdx
     7a5:	4f 54                	rex.WRXB push %r12
  if (!data_stats) {
     7a7:	4f 5f                	rex.WRXB pop %r15
     7a9:	50                   	push   %rax
     7aa:	49                   	rex.WB
     7ab:	4d 00 49 50          	rex.WRB add %r9b,0x50(%r9)
     7af:	50                   	push   %rax
     7b0:	52                   	push   %rdx
     7b1:	4f 54                	rex.WRXB push %r12
     7b3:	4f 5f                	rex.WRXB pop %r15
    data_stats->v2 += 1;
     7b5:	43                   	rex.XB
     7b6:	4f                   	rex.WRXB
     7b7:	4d 50                	rex.WRB push %r8
  if (action >= 0) {
     7b9:	00 49 50             	add    %cl,0x50(%rcx)
     7bc:	50                   	push   %rax
     7bd:	52                   	push   %rdx
     7be:	4f 54                	rex.WRXB push %r12
     7c0:	4f 5f                	rex.WRXB pop %r15
  if (decap_dst_flags) {
     7c2:	4c 32 54 50 00       	rex.WR xor 0x0(%rax,%rdx,2),%r10b
  if (action >= 0) {
     7c7:	49 50                	rex.WB push %r8
     7c9:	50                   	push   %rax
     7ca:	52                   	push   %rdx
     7cb:	4f 54                	rex.WRXB push %r12
     7cd:	4f 5f                	rex.WRXB pop %r15
     7cf:	53                   	push   %rbx
     7d0:	43 54                	rex.XB push %r12
     7d2:	50                   	push   %rax
     7d3:	00 49 50             	add    %cl,0x50(%rcx)
     7d6:	50                   	push   %rax
     7d7:	52                   	push   %rdx
     7d8:	4f 54                	rex.WRXB push %r12
     7da:	4f 5f                	rex.WRXB pop %r15
     7dc:	55                   	push   %rbp
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     7dd:	44 50                	rex.R push %rax
     7df:	4c                   	rex.WR
     7e0:	49 54                	rex.WB push %r12
     7e2:	45 00 49 50          	add    %r9b,0x50(%r9)
     7e6:	50                   	push   %rax
     7e7:	52                   	push   %rdx
     7e8:	4f 54                	rex.WRXB push %r12
    if (xpop_stats_data) {
     7ea:	4f 5f                	rex.WRXB pop %r15
     7ec:	4d 50                	rex.WRB push %r8
        xpop_stats_data->v1 += 1; // IPv4 inner packets
     7ee:	4c 53                	rex.WR push %rbx
     7f0:	00 49 50             	add    %cl,0x50(%rcx)
     7f3:	50                   	push   %rax
     7f4:	52                   	push   %rdx
     7f5:	4f 54                	rex.WRXB push %r12
     7f7:	4f 5f                	rex.WRXB pop %r15
     7f9:	45 54                	rex.RB push %r12
  bpf_tail_call(ctx, &subprograms, i);
     7fb:	48                   	rex.W
     7fc:	45 52                	rex.RB push %r10
     7fe:	4e                   	rex.WRX
     7ff:	45 54                	rex.RB push %r12
     801:	00 49 50             	add    %cl,0x50(%rcx)
     804:	50                   	push   %rax
     805:	52                   	push   %rdx
     806:	4f 54                	rex.WRXB push %r12
     808:	4f 5f                	rex.WRXB pop %r15
     80a:	41                   	rex.B
     80b:	47                   	rex.RXB
     80c:	47                   	rex.RXB
     80d:	46 52                	rex.RX push %rdx
     80f:	41                   	rex.B
     810:	47 00 49 50          	rex.RXB add %r9b,0x50(%r9)
     814:	50                   	push   %rax
     815:	52                   	push   %rdx
     816:	4f 54                	rex.WRXB push %r12
     818:	4f 5f                	rex.WRXB pop %r15
     81a:	52                   	push   %rdx
     81b:	41 57                	push   %r15
     81d:	00 49 50             	add    %cl,0x50(%rcx)
     820:	50                   	push   %rax
     821:	52                   	push   %rdx
     822:	4f 54                	rex.WRXB push %r12
  udp = data + off;
     824:	4f 5f                	rex.WRXB pop %r15
     826:	53                   	push   %rbx
  if (is_ipv6) {
     827:	4d                   	rex.WRB
     828:	43 00 49 50          	rex.XB add %cl,0x50(%r9)
  udp = data + off;
     82c:	50                   	push   %rax
  if (udp + 1 > data_end) {
     82d:	52                   	push   %rdx
     82e:	4f 54                	rex.WRXB push %r12
     830:	4f 5f                	rex.WRXB pop %r15
     832:	4d 50                	rex.WRB push %r8
     834:	54                   	push   %rsp
     835:	43 50                	rex.XB push %r8
     837:	00 49 50             	add    %cl,0x50(%rcx)
     83a:	50                   	push   %rax
     83b:	52                   	push   %rdx
     83c:	4f 54                	rex.WRXB push %r12
     83e:	4f 5f                	rex.WRXB pop %r15
     840:	4d                   	rex.WRB
     841:	41 58                	pop    %r8
     843:	00 70 72             	add    %dh,0x72(%rax)
     846:	69 6f 72 69 74 79 00 	imul   $0x797469,0x72(%rdi),%ebp
     84d:	66 6c                	data16 insb (%dx),%es:(%rdi)
     84f:	6f                   	outsl  %ds:(%rsi),(%dx)
     850:	77 5f                	ja     8b1 <balancer_ingress+0x8b1>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     852:	6c                   	insb   (%dx),%es:(%rdi)
     853:	62                   	(bad)
     854:	6c                   	insb   (%dx),%es:(%rdi)
     855:	00 70 61             	add    %dh,0x61(%rax)
     858:	79 6c                	jns    8c6 <balancer_ingress+0x8c6>
     85a:	6f                   	outsl  %ds:(%rsi),(%dx)
     85b:	61                   	(bad)
     85c:	64 5f                	fs pop %rdi
     85e:	6c                   	insb   (%dx),%es:(%rdi)
     85f:	65 6e                	outsb  %gs:(%rsi),(%dx)
     861:	00 5f 5f             	add    %bl,0x5f(%rdi)
        bpf_map_lookup_elem(&stats, &stats_key);
     864:	62 65                	(bad)
     866:	31 36                	xor    %esi,(%rsi)
     868:	00 6e 65             	add    %ch,0x65(%rsi)
     86b:	78 74                	js     8e1 <balancer_ingress+0x8e1>
     86d:	68 64 72 00 68       	push   $0x68007264
    if (!icmp_ptb_v4_stats) {
     872:	6f                   	outsl  %ds:(%rsi),(%dx)
     873:	70 5f                	jo     8d4 <balancer_ingress+0x8d4>
     875:	6c                   	insb   (%dx),%es:(%rdi)
     876:	69 6d 69 74 00 73 61 	imul   $0x61730074,0x69(%rbp),%ebp
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     87d:	64 64 72 00          	fs fs jb 881 <balancer_ingress+0x881>
      icmp_ptb_v4_stats->v2 += 1;
     881:	69 6e 36 5f 75 00 75 	imul   $0x7500755f,0x36(%rsi),%ebp
  if (iph + 1 > data_end) {
     888:	36 5f                	ss pop %rdi
     88a:	61                   	(bad)
     88b:	64 64 72 38          	fs fs jb 8c7 <balancer_ingress+0x8c7>
     88f:	00 75 36             	add    %dh,0x36(%rbp)
  if (iph->ihl != 5) {
     892:	5f                   	pop    %rdi
     893:	61                   	(bad)
     894:	64 64 72 31          	fs fs jb 8c9 <balancer_ingress+0x8c9>
     898:	36 00 75 36          	ss add %dh,0x36(%rbp)
     89c:	5f                   	pop    %rdi
     89d:	61                   	(bad)
     89e:	64 64 72 33          	fs fs jb 8d5 <balancer_ingress+0x8d5>
  pckt->flow.proto = iph->protocol;
     8a2:	32 00                	xor    (%rax),%al
     8a4:	69 6e 36 5f 61 64 64 	imul   $0x6464615f,0x36(%rsi),%ebp
  pckt->flags |= F_ICMP;
     8ab:	72 00                	jb     8ad <balancer_ingress+0x8ad>
  pckt->flow.src = iph->daddr;
     8ad:	64 61                	fs (bad)
     8af:	64 64 72 00          	fs fs jb 8b3 <balancer_ingress+0x8b3>
     8b3:	61                   	(bad)
     8b4:	64 64 72 73          	fs fs jb 92b <balancer_ingress+0x92b>
  pckt->flow.dst = iph->saddr;
     8b8:	00 69 70             	add    %ch,0x70(%rcx)
     8bb:	76 36                	jbe    8f3 <balancer_ingress+0x8f3>
     8bd:	68 64 72 00 69       	push   $0x69007264
     8c2:	68 6c 00 74 6f       	push   $0x6f74006c
     8c7:	73 00                	jae    8c9 <balancer_ingress+0x8c9>
     8c9:	74 6f                	je     93a <balancer_ingress+0x93a>
     8cb:	74 5f                	je     92c <balancer_ingress+0x92c>
     8cd:	6c                   	insb   (%dx),%es:(%rdi)
     8ce:	65 6e                	outsb  %gs:(%rsi),(%dx)
     8d0:	00 66 72             	add    %ah,0x72(%rsi)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     8d3:	61                   	(bad)
     8d4:	67 5f                	addr32 pop %rdi
     8d6:	6f                   	outsl  %ds:(%rsi),(%dx)
     8d7:	66 66 00 70 72       	data16 data16 add %dh,0x72(%rax)
     8dc:	6f                   	outsl  %ds:(%rsi),(%dx)
     8dd:	74 6f                	je     94e <balancer_ingress+0x94e>
     8df:	63 6f 6c             	movsxd 0x6c(%rdi),%ebp
     8e2:	00 63 68             	add    %ah,0x68(%rbx)
     8e5:	65 63 6b 00          	movsxd %gs:0x0(%rbx),%ebp
  vip.port = pckt.flow.port16[1];
     8e9:	5f                   	pop    %rdi
     8ea:	5f                   	pop    %rdi
     8eb:	73 75                	jae    962 <balancer_ingress+0x962>
  vip.proto = pckt.flow.proto;
     8ed:	6d                   	insl   (%dx),%es:(%rdi)
     8ee:	31 36                	xor    %esi,(%rsi)
     8f0:	00 69 70             	add    %ch,0x70(%rcx)
     8f3:	68 64 72 00 63       	push   $0x63007264
     8f8:	6f                   	outsl  %ds:(%rsi),(%dx)
     8f9:	6e                   	outsb  %ds:(%rsi),(%dx)
     8fa:	6e                   	outsb  %ds:(%rsi),(%dx)
     8fb:	5f                   	pop    %rdi
     8fc:	69 64 5f 6c 65 6e 73 	imul   $0x736e65,0x6c(%rdi,%rbx,2),%esp
     903:	00 
     904:	64 73 74             	fs jae 97b <balancer_ingress+0x97b>
     907:	5f                   	pop    %rdi
  if (!vip_info) {
     908:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
     90b:	6e                   	outsb  %ds:(%rsi),(%dx)
     90c:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
  if (data_end - data > MAX_PCKT_SIZE) {
     911:	6e                   	outsb  %ds:(%rsi),(%dx)
     912:	5f                   	pop    %rdi
     913:	69 64 00 71 75 69 63 	imul   $0x5f636975,0x71(%rax,%rax,1),%esp
     91a:	5f 
     91b:	6c                   	insb   (%dx),%es:(%rdi)
     91c:	6f                   	outsl  %ds:(%rsi),(%dx)
     91d:	6e                   	outsb  %ds:(%rsi),(%dx)
     91e:	67 5f                	addr32 pop %rdi
     920:	68 65 61 64 65       	push   $0x65646165
     925:	72 00                	jb     927 <balancer_ingress+0x927>
     927:	71 75                	jno    99e <balancer_ingress+0x99e>
     929:	69 63 5f 73 68 6f 72 	imul   $0x726f6873,0x5f(%rbx),%esp
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     930:	74 5f                	je     991 <balancer_ingress+0x991>
     932:	68 65 61 64 65       	push   $0x65646165
     937:	72 00                	jb     939 <balancer_ingress+0x939>
     939:	70 72                	jo     9ad <balancer_ingress+0x9ad>
  if (!data_stats) {
     93b:	6f                   	outsl  %ds:(%rsi),(%dx)
     93c:	63 65 73             	movsxd 0x73(%rbp),%esp
     93f:	73 5f                	jae    9a0 <balancer_ingress+0x9a0>
     941:	70 61                	jo     9a4 <balancer_ingress+0x9a4>
  data_stats->v1 += 1;
     943:	63 6b 65             	movsxd 0x65(%rbx),%ebp
     946:	74 00                	je     948 <balancer_ingress+0x948>
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     948:	78 64                	js     9ae <balancer_ingress+0x9ae>
     94a:	70 00                	jo     94c <balancer_ingress+0x94c>
    pckt.flow.port16[0] = 0;
     94c:	64 61                	fs (bad)
     94e:	74 61                	je     9b1 <balancer_ingress+0x9b1>
     950:	5f                   	pop    %rdi
     951:	65 6e                	outsb  %gs:(%rsi),(%dx)
  vip_num = vip_info->vip_num;
     953:	64 00 64 61 74       	add    %ah,%fs:0x74(%rcx,%riz,2)
     958:	61                   	(bad)
     959:	5f                   	pop    %rdi
     95a:	6d                   	insl   (%dx),%es:(%rdi)
     95b:	65 74 61             	gs je  9bf <balancer_ingress+0x9bf>
  __u32 cpu_num = bpf_get_smp_processor_id();
     95e:	00 64 61 74          	add    %ah,0x74(%rcx,%riz,2)
     962:	61                   	(bad)
     963:	5f                   	pop    %rdi
     964:	68 61 72 64 5f       	push   $0x5f647261
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     969:	73 74                	jae    9df <balancer_ingress+0x9df>
     96b:	61                   	(bad)
     96c:	72 74                	jb     9e2 <balancer_ingress+0x9e2>
     96e:	00 72 78             	add    %dh,0x78(%rdx)
     971:	71 00                	jno    973 <balancer_ingress+0x973>
     973:	78 64                	js     9d9 <balancer_ingress+0x9d9>
     975:	70 5f                	jo     9d6 <balancer_ingress+0x9d6>
     977:	72 78                	jb     9f1 <balancer_ingress+0x9f1>
     979:	71 5f                	jno    9da <balancer_ingress+0x9da>
     97b:	69 6e 66 6f 00 74 78 	imul   $0x7874006f,0x66(%rsi),%ebp
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     982:	71 00                	jno    984 <balancer_ingress+0x984>
     984:	78 64                	js     9ea <balancer_ingress+0x9ea>
     986:	70 5f                	jo     9e7 <balancer_ingress+0x9e7>
     988:	74 78                	je     a02 <balancer_ingress+0xa02>
     98a:	71 5f                	jno    9eb <balancer_ingress+0x9eb>
    if (!lru_stats) {
     98c:	69 6e 66 6f 00 66 72 	imul   $0x7266006f,0x66(%rsi),%ebp
     993:	61                   	(bad)
    lru_stats->v1 += 1;
     994:	6d                   	insl   (%dx),%es:(%rdi)
     995:	65 5f                	gs pop %rdi
     997:	73 7a                	jae    a13 <balancer_ingress+0xa13>
     999:	00 78 64             	add    %bh,0x64(%rax)
     99c:	70 5f                	jo     9fd <balancer_ingress+0x9fd>
     99e:	6d                   	insl   (%dx),%es:(%rdi)
     99f:	64 00 6e 68          	add    %ch,%fs:0x68(%rsi)
     9a3:	5f                   	pop    %rdi
     9a4:	6f                   	outsl  %ds:(%rsi),(%dx)
     9a5:	66 66 00 69 73       	data16 data16 add %ch,0x73(%rcx)
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     9aa:	5f                   	pop    %rdi
     9ab:	69 70 76 36 00 5f 42 	imul   $0x425f0036,0x76(%rax),%esi
     9b2:	6f                   	outsl  %ds:(%rsi),(%dx)
     9b3:	6f                   	outsl  %ds:(%rsi),(%dx)
     9b4:	6c                   	insb   (%dx),%es:(%rdi)
     9b5:	00 66 6c             	add    %ah,0x6c(%rsi)
        bpf_map_lookup_elem(&stats, &stats_key);
     9b8:	6f                   	outsl  %ds:(%rsi),(%dx)
     9b9:	77 00                	ja     9bb <balancer_ingress+0x9bb>
     9bb:	72 65                	jb     a22 <balancer_ingress+0xa22>
     9bd:	61                   	(bad)
     9be:	6c                   	insb   (%dx),%es:(%rdi)
     9bf:	5f                   	pop    %rdi
     9c0:	69 6e 64 65 78 00 70 	imul   $0x70007865,0x64(%rsi),%ebp
    if (!icmp_ptb_v4_stats) {
     9c7:	61                   	(bad)
     9c8:	63 6b 65             	movsxd 0x65(%rbx),%ebp
     9cb:	74 5f                	je     a2c <balancer_ingress+0xa2c>
    icmp_ptb_v4_stats->v1 += 1;
     9cd:	64 65 73 63          	fs gs jae a34 <balancer_ingress+0xa34>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     9d1:	72 69                	jb     a3c <balancer_ingress+0xa3c>
     9d3:	70 74                	jo     a49 <balancer_ingress+0xa49>
     9d5:	69 6f 6e 00 6d 61 63 	imul   $0x63616d00,0x6e(%rdi),%ebp
  if (iph + 1 > data_end) {
     9dc:	5f                   	pop    %rdi
     9dd:	61                   	(bad)
     9de:	64 64 72 5f          	fs fs jb a41 <balancer_ingress+0xa41>
     9e2:	70 6f                	jo     a53 <balancer_ingress+0xa53>
     9e4:	73 00                	jae    9e6 <balancer_ingress+0x9e6>
     9e6:	74 68                	je     a50 <balancer_ingress+0xa50>
  if (iph->ihl != 5) {
     9e8:	5f                   	pop    %rdi
     9e9:	6f                   	outsl  %ds:(%rsi),(%dx)
     9ea:	66 66 00 76 69       	data16 data16 add %dh,0x69(%rsi)
     9ef:	70 5f                	jo     a50 <balancer_ingress+0xa50>
     9f1:	69 6e 66 6f 00 64 61 	imul   $0x6164006f,0x66(%rsi),%ebp
  pckt->flow.proto = iph->protocol;
     9f8:	74 61                	je     a5b <balancer_ingress+0xa5b>
     9fa:	5f                   	pop    %rdi
     9fb:	73 74                	jae    a71 <balancer_ingress+0xa71>
  pckt->flags |= F_ICMP;
     9fd:	61                   	(bad)
     9fe:	74 73                	je     a73 <balancer_ingress+0xa73>
     a00:	00 63 70             	add    %ah,0x70(%rbx)
  pckt->flow.src = iph->daddr;
     a03:	75 5f                	jne    a64 <balancer_ingress+0xa64>
     a05:	6e                   	outsb  %ds:(%rsi),(%dx)
     a06:	75 6d                	jne    a75 <balancer_ingress+0xa75>
     a08:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
  pckt->flow.dst = iph->saddr;
     a0c:	5f                   	pop    %rdi
     a0d:	6d                   	insl   (%dx),%es:(%rdi)
     a0e:	61                   	(bad)
     a0f:	70 00                	jo     a11 <balancer_ingress+0xa11>
     a11:	70 6b                	jo     a7e <balancer_ingress+0xa7e>
     a13:	74 5f                	je     a74 <balancer_ingress+0xa74>
     a15:	62                   	(bad)
     a16:	79 74                	jns    a8c <balancer_ingress+0xa8c>
    vip.port = 0;
     a18:	65 73 00             	gs jae a1b <balancer_ingress+0xa1b>
     a1b:	6f                   	outsl  %ds:(%rsi),(%dx)
     a1c:	72 69                	jb     a87 <balancer_ingress+0xa87>
     a1e:	67 69 6e 61 6c 5f 73 	imul   $0x70735f6c,0x61(%esi),%ebp
     a25:	70 
     a26:	6f                   	outsl  %ds:(%rsi),(%dx)
     a27:	72 74                	jb     a9d <balancer_ingress+0xa9d>
     a29:	00 63 76             	add    %ah,0x76(%rbx)
     a2c:	61                   	(bad)
     a2d:	6c                   	insb   (%dx),%es:(%rdi)
     a2e:	00 69 70             	add    %ch,0x70(%rcx)
    if (!vip_info) {
     a31:	68 5f 6c 65 6e       	push   $0x6e656c5f
     a36:	00 70 61             	add    %dh,0x61(%rax)
     a39:	73 73                	jae    aae <balancer_ingress+0xaae>
     a3b:	00 5f 5f             	add    %bl,0x5f(%rdi)
     a3e:	65 6c                	gs insb (%dx),%es:(%rdi)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     a40:	65 6d                	gs insl (%dx),%es:(%rdi)
     a42:	00 69 64             	add    %ch,0x64(%rcx)
     a45:	78 00                	js     a47 <balancer_ingress+0xa47>
     a47:	65 6c                	gs insb (%dx),%es:(%rdi)
      pckt.flow.port16[1] = 0;
     a49:	65 6d                	gs insl (%dx),%es:(%rdi)
     a4b:	5f                   	pop    %rdi
     a4c:	73 69                	jae    ab7 <balancer_ingress+0xab7>
     a4e:	7a 65                	jp     ab5 <balancer_ingress+0xab5>
     a50:	00 5f 5f             	add    %bl,0x5f(%rdi)
     a53:	70 65                	jo     aba <balancer_ingress+0xaba>
  struct address dst_addr = {};
     a55:	72 63                	jb     aba <balancer_ingress+0xaba>
     a57:	70 75                	jo     ace <balancer_ingress+0xace>
     a59:	5f                   	pop    %rdi
     a5a:	69 64 00 6c 72 75 5f 	imul   $0x735f7572,0x6c(%rax,%rax,1),%esp
     a61:	73 
     a62:	74 61                	je     ac5 <balancer_ingress+0xac5>
     a64:	74 73                	je     ad9 <balancer_ingress+0xad9>
    dst_addr.addr = pckt->flow.dst;
     a66:	5f                   	pop    %rdi
     a67:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
     a6b:	6c                   	insb   (%dx),%es:(%rdi)
     a6c:	72 75                	jb     ae3 <balancer_ingress+0xae3>
     a6e:	5f                   	pop    %rdi
     a6f:	73 74                	jae    ae5 <balancer_ingress+0xae5>
     a71:	61                   	(bad)
     a72:	74 73                	je     ae7 <balancer_ingress+0xae7>
     a74:	00 69 73             	add    %ch,0x73(%rcx)
     a77:	5f                   	pop    %rdi
     a78:	69 63 6d 70 00 71 75 	imul   $0x75710070,0x6d(%rbx),%esp
     a7f:	69 63 5f 70 61 63 6b 	imul   $0x6b636170,0x5f(%rbx),%esp
     a86:	65 74 73             	gs je  afc <balancer_ingress+0xafc>
     a89:	5f                   	pop    %rdi
     a8a:	73 74                	jae    b00 <balancer_ingress+0xb00>
  if (decap_dst_flags) {
     a8c:	61                   	(bad)
     a8d:	74 73                	je     b02 <balancer_ingress+0xb02>
     a8f:	5f                   	pop    %rdi
     a90:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
     a94:	71 70                	jno    b06 <balancer_ingress+0xb06>
     a96:	72 00                	jb     a98 <balancer_ingress+0xa98>
     a98:	63 69 64             	movsxd 0x64(%rcx),%ebp
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a9b:	5f                   	pop    %rdi
     a9c:	76 65                	jbe    b03 <balancer_ingress+0xb03>
     a9e:	72 73                	jb     b13 <balancer_ingress+0xb13>
     aa0:	69 6f 6e 00 69 73 5f 	imul   $0x5f736900,0x6e(%rdi),%ebp
    if (!data_stats) {
     aa7:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%rsi),%ebp
     aae:	00 71 75             	add    %dh,0x75(%rcx)
    data_stats->v1 += 1;
     ab1:	69 63 5f 70 61 72 73 	imul   $0x73726170,0x5f(%rbx),%esp
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     ab8:	65 5f                	gs pop %rdi
     aba:	72 65                	jb     b21 <balancer_ingress+0xb21>
     abc:	73 75                	jae    b33 <balancer_ingress+0xb33>
     abe:	6c                   	insb   (%dx),%es:(%rdi)
     abf:	74 00                	je     ac1 <balancer_ingress+0xac1>
     ac1:	72 65                	jb     b28 <balancer_ingress+0xb28>
     ac3:	61                   	(bad)
     ac4:	6c                   	insb   (%dx),%es:(%rdi)
    csum = iph->check + 0x0001;
     ac5:	5f                   	pop    %rdi
     ac6:	70 6f                	jo     b37 <balancer_ingress+0xb37>
     ac8:	73 00                	jae    aca <balancer_ingress+0xaca>
     aca:	72 65                	jb     b31 <balancer_ingress+0xb31>
     acc:	73 00                	jae    ace <balancer_ingress+0xace>
    iph->check = (csum & 0xffff) + (csum >> 16);
     ace:	70 61                	jo     b31 <balancer_ingress+0xb31>
     ad0:	72 73                	jb     b45 <balancer_ingress+0xb45>
     ad2:	65 5f                	gs pop %rdi
     ad4:	6c                   	insb   (%dx),%es:(%rdi)
     ad5:	33 5f 68             	xor    0x68(%rdi),%ebx
     ad8:	65 61                	gs (bad)
    if (!--iph->ttl) {
     ada:	64 65 72 73          	fs gs jb b51 <balancer_ingress+0xb51>
     ade:	00 69 70             	add    %ch,0x70(%rcx)
     ae1:	68 00 69 70 36       	push   $0x36706900
     ae6:	68 00 70 61 72       	push   $0x72617000
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     aeb:	73 65                	jae    b52 <balancer_ingress+0xb52>
     aed:	5f                   	pop    %rdi
     aee:	69 63 6d 70 00 69 63 	imul   $0x63690070,0x6d(%rbx),%esp
     af5:	6d                   	insl   (%dx),%es:(%rdi)
     af6:	70 5f                	jo     b57 <balancer_ingress+0xb57>
     af8:	68 64 72 00 63       	push   $0x63007264
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     afd:	68 65 63 6b 73       	push   $0x736b6365
     b02:	75 6d                	jne    b71 <balancer_ingress+0xb71>
     b04:	00 73 65             	add    %dh,0x65(%rbx)
     b07:	71 75                	jno    b7e <balancer_ingress+0xb7e>
  new_eth->h_proto = BE_ETH_P_IP;
     b09:	65 6e                	outsb  %gs:(%rsi),(%dx)
     b0b:	63 65 00             	movsxd 0x0(%rbp),%esp
     b0e:	67 61                	addr32 (bad)
     b10:	74 65                	je     b77 <balancer_ingress+0xb77>
     b12:	77 61                	ja     b75 <balancer_ingress+0xb75>
     b14:	79 00                	jns    b16 <balancer_ingress+0xb16>
     b16:	66 72 61             	data16 jb b7a <balancer_ingress+0xb7a>
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     b19:	67 00 5f 5f          	add    %bl,0x5f(%edi)
     b1d:	75 6e                	jne    b8d <balancer_ingress+0xb8d>
     b1f:	75 73                	jne    b94 <balancer_ingress+0xb94>
     b21:	65 64 00 6d 74       	gs add %ch,%fs:0x74(%rbp)
     b26:	75 00                	jne    b28 <balancer_ingress+0xb28>
     b28:	72 65                	jb     b8f <balancer_ingress+0xb8f>
     b2a:	73 65                	jae    b91 <balancer_ingress+0xb91>
     b2c:	72 76                	jb     ba4 <balancer_ingress+0xba4>
     b2e:	65 64 00 69 63       	gs add %ch,%fs:0x63(%rcx)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b33:	6d                   	insl   (%dx),%es:(%rdi)
     b34:	70 68                	jo     b9e <balancer_ingress+0xb9e>
     b36:	64 72 00             	fs jb  b39 <balancer_ingress+0xb39>
     b39:	69 63 6d 70 5f 70 74 	imul   $0x74705f70,0x6d(%rbx),%esp
  if (!data_stats) {
     b40:	62                   	(bad)
     b41:	5f                   	pop    %rdi
     b42:	76 34                	jbe    b78 <balancer_ingress+0xb78>
     b44:	5f                   	pop    %rdi
     b45:	73 74                	jae    bbb <balancer_ingress+0xbbb>
     b47:	61                   	(bad)
     b48:	74 73                	je     bbd <balancer_ingress+0xbbd>
    data_stats->v2 += 1;
     b4a:	00 68 61             	add    %ch,0x61(%rax)
     b4d:	6e                   	outsb  %ds:(%rsi),(%dx)
  if (action >= 0) {
     b4e:	64 6c                	fs insb (%dx),%es:(%rdi)
     b50:	65 5f                	gs pop %rdi
     b52:	69 66 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rsi),%esp
  if (decap_dst_flags) {
     b59:	00 73 65             	add    %dh,0x65(%rbx)
  if (action >= 0) {
     b5c:	6e                   	outsb  %ds:(%rsi),(%dx)
     b5d:	64 5f                	fs pop %rdi
     b5f:	69 63 6d 70 5f 72 65 	imul   $0x65725f70,0x6d(%rbx),%esp
     b66:	70 6c                	jo     bd4 <balancer_ingress+0xbd4>
     b68:	79 00                	jns    b6a <balancer_ingress+0xb6a>
     b6a:	74 6d                	je     bd9 <balancer_ingress+0xbd9>
     b6c:	70 5f                	jo     bcd <balancer_ingress+0xbcd>
     b6e:	61                   	(bad)
     b6f:	64 64 72 00          	fs fs jb b73 <balancer_ingress+0xb73>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b73:	63 73 75             	movsxd 0x75(%rbx),%esi
     b76:	6d                   	insl   (%dx),%es:(%rdi)
     b77:	00 69 70             	add    %ch,0x70(%rcx)
     b7a:	76 34                	jbe    bb0 <balancer_ingress+0xbb0>
     b7c:	5f                   	pop    %rdi
     b7d:	63 73 75             	movsxd 0x75(%rbx),%esi
    if (xpop_stats_data) {
     b80:	6d                   	insl   (%dx),%es:(%rdi)
     b81:	5f                   	pop    %rdi
     b82:	69 6e 6c 69 6e 65 00 	imul   $0x656e69,0x6c(%rsi),%ebp
     b89:	6e                   	outsb  %ds:(%rsi),(%dx)
     b8a:	65 78 74             	gs js  c01 <balancer_ingress+0xc01>
     b8d:	5f                   	pop    %rdi
     b8e:	69 70 68 5f 75 31 36 	imul   $0x3631755f,0x68(%rax),%esi
     b95:	00 69 00             	add    %ch,0x0(%rcx)
     b98:	70 61                	jo     bfb <balancer_ingress+0xbfb>
  bpf_tail_call(ctx, &subprograms, i);
     b9a:	72 73                	jb     c0f <balancer_ingress+0xc0f>
     b9c:	65 5f                	gs pop %rdi
     b9e:	69 63 6d 70 76 36 00 	imul   $0x367670,0x6d(%rbx),%esp
     ba5:	69 63 6d 70 36 5f 74 	imul   $0x745f3670,0x6d(%rbx),%esp
     bac:	79 70                	jns    c1e <balancer_ingress+0xc1e>
     bae:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
     bb2:	6d                   	insl   (%dx),%es:(%rdi)
     bb3:	70 36                	jo     beb <balancer_ingress+0xbeb>
     bb5:	5f                   	pop    %rdi
     bb6:	63 6f 64             	movsxd 0x64(%rdi),%ebp
     bb9:	65 00 69 63          	add    %ch,%gs:0x63(%rcx)
     bbd:	6d                   	insl   (%dx),%es:(%rdi)
     bbe:	70 36                	jo     bf6 <balancer_ingress+0xbf6>
     bc0:	5f                   	pop    %rdi
     bc1:	63 6b 73             	movsxd 0x73(%rbx),%ebp
        bpf_map_lookup_elem(&stats, &stats_key);
     bc4:	75 6d                	jne    c33 <balancer_ingress+0xc33>
     bc6:	00 69 63             	add    %ch,0x63(%rcx)
     bc9:	6d                   	insl   (%dx),%es:(%rdi)
     bca:	70 36                	jo     c02 <balancer_ingress+0xc02>
     bcc:	5f                   	pop    %rdi
     bcd:	64 61                	fs (bad)
    if (!icmp_ptb_v6_stats) {
     bcf:	74 61                	je     c32 <balancer_ingress+0xc32>
     bd1:	75 6e                	jne    c41 <balancer_ingress+0xc41>
     bd3:	00 75 6e             	add    %dh,0x6e(%rbp)
     bd6:	5f                   	pop    %rdi
     bd7:	64 61                	fs (bad)
    icmp_ptb_v6_stats->v1 += 1;
     bd9:	74 61                	je     c3c <balancer_ingress+0xc3c>
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     bdb:	33 32                	xor    (%rdx),%esi
     bdd:	00 75 6e             	add    %dh,0x6e(%rbp)
     be0:	5f                   	pop    %rdi
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     be1:	64 61                	fs (bad)
     be3:	74 61                	je     c46 <balancer_ingress+0xc46>
     be5:	31 36                	xor    %esi,(%rsi)
     be7:	00 75 6e             	add    %dh,0x6e(%rbp)
      icmp_ptb_v6_stats->v2 += 1;
     bea:	5f                   	pop    %rdi
     beb:	64 61                	fs (bad)
  if (ip6h + 1 > data_end) {
     bed:	74 61                	je     c50 <balancer_ingress+0xc50>
     bef:	38 00                	cmp    %al,(%rax)
     bf1:	75 5f                	jne    c52 <balancer_ingress+0xc52>
     bf3:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
     bf7:	00 69 64             	add    %ch,0x64(%rcx)
     bfa:	65 6e                	outsb  %gs:(%rsi),(%dx)
     bfc:	74 69                	je     c67 <balancer_ingress+0xc67>
     bfe:	66 69 65 72 00 69    	imul   $0x6900,0x72(%rbp),%sp
  pckt->flow.proto = ip6h->nexthdr;
     c04:	63 6d 70             	movsxd 0x70(%rbp),%ebp
     c07:	76 36                	jbe    c3f <balancer_ingress+0xc3f>
  pckt->flags |= F_ICMP;
     c09:	5f                   	pop    %rdi
     c0a:	65 63 68 6f          	movsxd %gs:0x6f(%rax),%ebp
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     c0e:	00 75 5f             	add    %dh,0x5f(%rbp)
     c11:	6e                   	outsb  %ds:(%rsi),(%dx)
     c12:	64 5f                	fs pop %rdi
     c14:	61                   	(bad)
     c15:	64 76 74             	fs jbe c8c <balancer_ingress+0xc8c>
     c18:	00 6f 76             	add    %ch,0x76(%rdi)
     c1b:	65 72 72             	gs jb  c90 <balancer_ingress+0xc90>
     c1e:	69 64 65 00 73 6f 6c 	imul   $0x696c6f73,0x0(%rbp,%riz,2),%esp
     c25:	69 
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     c26:	63 69 74             	movsxd 0x74(%rcx),%ebp
     c29:	65 64 00 72 6f       	gs add %dh,%fs:0x6f(%rdx)
     c2e:	75 74                	jne    ca4 <balancer_ingress+0xca4>
     c30:	65 72 00             	gs jb  c33 <balancer_ingress+0xc33>
  if (protocol == IPPROTO_IPIP) {
     c33:	72 65                	jb     c9a <balancer_ingress+0xc9a>
     c35:	73 65                	jae    c9c <balancer_ingress+0xc9c>
     c37:	72 76                	jb     caf <balancer_ingress+0xcaf>
     c39:	65 64 32 00          	gs xor %fs:(%rax),%al
     c3d:	69 63 6d 70 76 36 5f 	imul   $0x5f367670,0x6d(%rbx),%esp
     c44:	6e                   	outsb  %ds:(%rsi),(%dx)
     c45:	64 5f                	fs pop %rdi
     c47:	61                   	(bad)
     c48:	64 76 74             	fs jbe cbf <balancer_ingress+0xcbf>
     c4b:	00 75 5f             	add    %dh,0x5f(%rbp)
     c4e:	6e                   	outsb  %ds:(%rsi),(%dx)
     c4f:	64 5f                	fs pop %rdi
     c51:	72 61                	jb     cb4 <balancer_ingress+0xcb4>
     c53:	00 72 6f             	add    %dh,0x6f(%rdx)
     c56:	75 74                	jne    ccc <balancer_ingress+0xccc>
     c58:	65 72 5f             	gs jb  cba <balancer_ingress+0xcba>
     c5b:	70 72                	jo     ccf <balancer_ingress+0xccf>
  struct address dst_addr = {};
     c5d:	65 66 00 68 6f       	data16 add %ch,%gs:0x6f(%rax)
     c62:	6d                   	insl   (%dx),%es:(%rdi)
     c63:	65 5f                	gs pop %rdi
     c65:	61                   	(bad)
     c66:	67 65 6e             	outsb  %gs:(%esi),(%dx)
     c69:	74 00                	je     c6b <balancer_ingress+0xc6b>
     c6b:	6f                   	outsl  %ds:(%rsi),(%dx)
     c6c:	74 68                	je     cd6 <balancer_ingress+0xcd6>
    dst_addr.addr = pckt->flow.dst;
     c6e:	65 72 00             	gs jb  c71 <balancer_ingress+0xc71>
     c71:	6d                   	insl   (%dx),%es:(%rdi)
     c72:	61                   	(bad)
     c73:	6e                   	outsb  %ds:(%rsi),(%dx)
     c74:	61                   	(bad)
     c75:	67 65 64 00 72 74    	gs add %dh,%fs:0x74(%edx)
     c7b:	5f                   	pop    %rdi
     c7c:	6c                   	insb   (%dx),%es:(%rdi)
     c7d:	69 66 65 74 69 6d 65 	imul   $0x656d6974,0x65(%rsi),%esp
     c84:	00 69 63             	add    %ch,0x63(%rcx)
     c87:	6d                   	insl   (%dx),%es:(%rdi)
     c88:	70 76                	jo     d00 <balancer_ingress+0xd00>
     c8a:	36 5f                	ss pop %rdi
  if (decap_dst_flags) {
     c8c:	6e                   	outsb  %ds:(%rsi),(%dx)
     c8d:	64 5f                	fs pop %rdi
     c8f:	72 61                	jb     cf2 <balancer_ingress+0xcf2>
     c91:	00 69 63             	add    %ch,0x63(%rcx)
     c94:	6d                   	insl   (%dx),%es:(%rdi)
     c95:	70 36                	jo     ccd <balancer_ingress+0xccd>
     c97:	68 64 72 00 69       	push   $0x69007264
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c9c:	63 6d 70             	movsxd 0x70(%rbp),%ebp
     c9f:	5f                   	pop    %rdi
     ca0:	70 74                	jo     d16 <balancer_ingress+0xd16>
     ca2:	62                   	(bad)
     ca3:	5f                   	pop    %rdi
     ca4:	76 36                	jbe    cdc <balancer_ingress+0xcdc>
    if (!data_stats) {
     ca6:	5f                   	pop    %rdi
     ca7:	73 74                	jae    d1d <balancer_ingress+0xd1d>
     ca9:	61                   	(bad)
     caa:	74 73                	je     d1f <balancer_ingress+0xd1f>
     cac:	00 73 65             	add    %dh,0x65(%rbx)
    data_stats->v1 += 1;
     caf:	6e                   	outsb  %ds:(%rsi),(%dx)
     cb0:	64 5f                	fs pop %rdi
    if ((*data + offset) > *data_end) {
     cb2:	69 63 6d 70 36 5f 72 	imul   $0x725f3670,0x6d(%rbx),%esp
     cb9:	65 70 6c             	gs jo  d28 <balancer_ingress+0xd28>
     cbc:	79 00                	jns    cbe <balancer_ingress+0xcbe>
     cbe:	73 77                	jae    d37 <balancer_ingress+0xd37>
     cc0:	61                   	(bad)
     cc1:	70 5f                	jo     d22 <balancer_ingress+0xd22>
     cc3:	6d                   	insl   (%dx),%es:(%rdi)
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     cc4:	61                   	(bad)
     cc5:	63 5f 61             	movsxd 0x61(%rdi),%ebx
     cc8:	6e                   	outsb  %ds:(%rsi),(%dx)
     cc9:	64 5f                	fs pop %rdi
     ccb:	73 65                	jae    d32 <balancer_ingress+0xd32>
     ccd:	6e                   	outsb  %ds:(%rsi),(%dx)
     cce:	64 00 68 5f          	add    %ch,%fs:0x5f(%rax)
    if (!--ip6h->hop_limit) {
     cd2:	64 65 73 74          	fs gs jae d4a <balancer_ingress+0xd4a>
     cd6:	00 68 5f             	add    %ch,0x5f(%rax)
     cd9:	73 6f                	jae    d4a <balancer_ingress+0xd4a>
     cdb:	75 72                	jne    d4f <balancer_ingress+0xd4f>
     cdd:	63 65 00             	movsxd 0x0(%rbp),%esp
     ce0:	65 74 68             	gs je  d4b <balancer_ingress+0xd4b>
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     ce3:	68 64 72 00 74       	push   $0x74007264
     ce8:	6d                   	insl   (%dx),%es:(%rdi)
     ce9:	70 5f                	jo     d4a <balancer_ingress+0xd4a>
     ceb:	6d                   	insl   (%dx),%es:(%rdi)
     cec:	61                   	(bad)
     ced:	63 00                	movsxd (%rax),%eax
     cef:	63 73 75             	movsxd 0x75(%rbx),%esi
     cf2:	6d                   	insl   (%dx),%es:(%rdi)
     cf3:	5f                   	pop    %rdi
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     cf4:	66 6f                	outsw  %ds:(%rsi),(%dx)
     cf6:	6c                   	insb   (%dx),%es:(%rdi)
     cf7:	64 5f                	fs pop %rdi
     cf9:	68 65 6c 70 65       	push   $0x65706c65
     cfe:	72 00                	jb     d00 <balancer_ingress+0xd00>
     d00:	70 61                	jo     d63 <balancer_ingress+0xd63>
     d02:	72 73                	jb     d77 <balancer_ingress+0xd77>
     d04:	65 5f                	gs pop %rdi
    new_eth->h_proto = BE_ETH_P_IPV6;
     d06:	74 63                	je     d6b <balancer_ingress+0xd6b>
     d08:	70 00                	jo     d0a <balancer_ingress+0xd0a>
     d0a:	61                   	(bad)
     d0b:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
     d0e:	73 65                	jae    d75 <balancer_ingress+0xd75>
     d10:	71 00                	jno    d12 <balancer_ingress+0xd12>
     d12:	61                   	(bad)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     d13:	65 00 72 65          	add    %dh,%gs:0x65(%rdx)
     d17:	73 31                	jae    d4a <balancer_ingress+0xd4a>
     d19:	00 64 6f 66          	add    %ah,0x66(%rdi,%rbp,2)
     d1d:	66 00 66 69          	data16 add %ah,0x69(%rsi)
     d21:	6e                   	outsb  %ds:(%rsi),(%dx)
     d22:	00 72 73             	add    %dh,0x73(%rdx)
     d25:	74 00                	je     d27 <balancer_ingress+0xd27>
     d27:	70 73                	jo     d9c <balancer_ingress+0xd9c>
     d29:	68 00 61 63 6b       	push   $0x6b636100
     d2e:	00 75 72             	add    %dh,0x72(%rbp)
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     d31:	67 00 65 63          	add    %ah,0x63(%ebp)
     d35:	65 00 63 77          	add    %ah,%gs:0x77(%rbx)
     d39:	72 00                	jb     d3b <balancer_ingress+0xd3b>
  if (!data_stats) {
     d3b:	77 69                	ja     da6 <balancer_ingress+0xda6>
     d3d:	6e                   	outsb  %ds:(%rsi),(%dx)
     d3e:	64 6f                	outsl  %fs:(%rsi),(%dx)
     d40:	77 00                	ja     d42 <balancer_ingress+0xd42>
     d42:	75 72                	jne    db6 <balancer_ingress+0xdb6>
     d44:	67 5f                	addr32 pop %rdi
     d46:	70 74                	jo     dbc <balancer_ingress+0xdbc>
     d48:	72 00                	jb     d4a <balancer_ingress+0xd4a>
    data_stats->v2 += 1;
     d4a:	74 63                	je     daf <balancer_ingress+0xdaf>
     d4c:	70 68                	jo     db6 <balancer_ingress+0xdb6>
  if (action >= 0) {
     d4e:	64 72 00             	fs jb  d51 <balancer_ingress+0xd51>
     d51:	63 61 6c             	movsxd 0x6c(%rcx),%esp
     d54:	63 5f 6f             	movsxd 0x6f(%rdi),%ebx
  if (decap_dst_flags) {
     d57:	66 66 73 65          	data16 data16 jae dc0 <balancer_ingress+0xdc0>
  if (action >= 0) {
     d5b:	74 00                	je     d5d <balancer_ingress+0xd5d>
     d5d:	63 68 65             	movsxd 0x65(%rax),%ebp
     d60:	63 6b 5f             	movsxd 0x5f(%rbx),%ebp
     d63:	64 65 63 61 70       	fs movsxd %gs:0x70(%rcx),%esp
     d68:	5f                   	pop    %rdi
     d69:	64 73 74             	fs jae de0 <balancer_ingress+0xde0>
     d6c:	00 64 73 74          	add    %ah,0x74(%rbx,%rsi,2)
     d70:	5f                   	pop    %rdi
     d71:	61                   	(bad)
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     d72:	64 64 72 00          	fs fs jb d76 <balancer_ingress+0xd76>
     d76:	64 65 63 61 70       	fs movsxd %gs:0x70(%rcx),%esp
     d7b:	5f                   	pop    %rdi
     d7c:	64 73 74             	fs jae df3 <balancer_ingress+0xdf3>
    if (xpop_stats_data) {
     d7f:	5f                   	pop    %rdi
     d80:	66 6c                	data16 insb (%dx),%es:(%rdi)
     d82:	61                   	(bad)
        xpop_stats_data->v2 += 1; // IPv6 inner packets
     d83:	67 73 00             	addr32 jae d86 <balancer_ingress+0xd86>
     d86:	72 65                	jb     ded <balancer_ingress+0xded>
     d88:	61                   	(bad)
     d89:	6c                   	insb   (%dx),%es:(%rdi)
     d8a:	5f                   	pop    %rdi
     d8b:	62                   	(bad)
     d8c:	70 66                	jo     df4 <balancer_ingress+0xdf4>
     d8e:	5f                   	pop    %rdi
     d8f:	6d                   	insl   (%dx),%es:(%rdi)
     d90:	61                   	(bad)
  bpf_tail_call(ctx, &subprograms, i);
     d91:	70 5f                	jo     df2 <balancer_ingress+0xdf2>
     d93:	6c                   	insb   (%dx),%es:(%rdi)
     d94:	6f                   	outsl  %ds:(%rsi),(%dx)
     d95:	6f                   	outsl  %ds:(%rsi),(%dx)
     d96:	6b 75 70 5f          	imul   $0x5f,0x70(%rbp),%esi
     d9a:	65 6c                	gs insb (%dx),%es:(%rdi)
     d9c:	65 6d                	gs insl (%dx),%es:(%rdi)
     d9e:	00 64 65 63          	add    %ah,0x63(%rbp,%riz,2)
     da2:	72 65                	jb     e09 <balancer_ingress+0xe09>
     da4:	6d                   	insl   (%dx),%es:(%rdi)
     da5:	65 6e                	outsb  %gs:(%rsi),(%dx)
     da7:	74 5f                	je     e08 <balancer_ingress+0xe08>
     da9:	74 74                	je     e1f <balancer_ingress+0xe1f>
     dab:	6c                   	insb   (%dx),%es:(%rdi)
     dac:	00 70 72             	add    %dh,0x72(%rax)
     daf:	6f                   	outsl  %ds:(%rsi),(%dx)
     db0:	63 65 73             	movsxd 0x73(%rbp),%esp
     db3:	73 5f                	jae    e14 <balancer_ingress+0xe14>
     db5:	65 6e                	outsb  %gs:(%rsi),(%dx)
     db7:	63 61 70             	movsxd 0x70(%rcx),%esp
  udp = data + off;
     dba:	65 64 5f             	gs fs pop %rdi
  if (is_ipv6) {
     dbd:	69 70 69 70 5f 70 63 	imul   $0x63705f70,0x69(%rax),%esi
  if (udp + 1 > data_end) {
     dc4:	6b 74 00 78 70       	imul   $0x70,0x78(%rax,%rax,1),%esi
     dc9:	6f                   	outsl  %ds:(%rsi),(%dx)
     dca:	70 5f                	jo     e2b <balancer_ingress+0xe2b>
     dcc:	73 74                	jae    e42 <balancer_ingress+0xe42>
     dce:	61                   	(bad)
     dcf:	74 73                	je     e44 <balancer_ingress+0xe44>
     dd1:	5f                   	pop    %rdi
     dd2:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
     dd6:	78 70                	js     e48 <balancer_ingress+0xe48>
     dd8:	6f                   	outsl  %ds:(%rsi),(%dx)
     dd9:	70 5f                	jo     e3a <balancer_ingress+0xe3a>
     ddb:	73 74                	jae    e51 <balancer_ingress+0xe51>
     ddd:	61                   	(bad)
     dde:	74 73                	je     e53 <balancer_ingress+0xe53>
     de0:	5f                   	pop    %rdi
     de1:	64 61                	fs (bad)
     de3:	74 61                	je     e46 <balancer_ingress+0xe46>
     de5:	00 69 6e             	add    %ch,0x6e(%rcx)
     de8:	6e                   	outsb  %ds:(%rsi),(%dx)
     de9:	65 72 5f             	gs jb  e4b <balancer_ingress+0xe4b>
     dec:	69 70 76 36 00 64 65 	imul   $0x65640036,0x76(%rax),%esi
     df3:	63 61 70             	movsxd 0x70(%rcx),%esp
     df6:	5f                   	pop    %rdi
     df7:	76 36                	jbe    e2f <balancer_ingress+0xe2f>
    vip.vip = pckt.flow.dst;
     df9:	00 69 6e             	add    %ch,0x6e(%rcx)
     dfc:	6e                   	outsb  %ds:(%rsi),(%dx)
     dfd:	65 72 5f             	gs jb  e5f <balancer_ingress+0xe5f>
  vip.port = pckt.flow.port16[1];
     e00:	76 34                	jbe    e36 <balancer_ingress+0xe36>
     e02:	00 6f 6c             	add    %ch,0x6c(%rdi)
  vip.proto = pckt.flow.proto;
     e05:	64 5f                	fs pop %rdi
     e07:	65 74 68             	gs je  e72 <balancer_ingress+0xe72>
     e0a:	00 6e 65             	add    %ch,0x65(%rsi)
     e0d:	77 5f                	ja     e6e <balancer_ingress+0xe6e>
     e0f:	65 74 68             	gs je  e7a <balancer_ingress+0xe7a>
     e12:	00 72 65             	add    %dh,0x65(%rdx)
     e15:	63 69 72             	movsxd 0x72(%rcx),%ebp
     e18:	63 75 6c             	movsxd 0x6c(%rbp),%esi
     e1b:	61                   	(bad)
     e1c:	74 65                	je     e83 <balancer_ingress+0xe83>
     e1e:	00 63 74             	add    %ah,0x74(%rbx)
  if (!vip_info) {
     e21:	78 00                	js     e23 <balancer_ingress+0xe23>
     e23:	62                   	(bad)
     e24:	70 66                	jo     e8c <balancer_ingress+0xe8c>
     e26:	5f                   	pop    %rdi
     e27:	70 72                	jo     e9b <balancer_ingress+0xe9b>
     e29:	6f                   	outsl  %ds:(%rsi),(%dx)
  if (data_end - data > MAX_PCKT_SIZE) {
     e2a:	67 00 66 75          	add    %ah,0x75(%esi)
     e2e:	6e                   	outsb  %ds:(%rsi),(%dx)
     e2f:	63 00                	movsxd (%rax),%eax
     e31:	70 61                	jo     e94 <balancer_ingress+0xe94>
     e33:	72 73                	jb     ea8 <balancer_ingress+0xea8>
     e35:	65 5f                	gs pop %rdi
     e37:	75 64                	jne    e9d <balancer_ingress+0xe9d>
     e39:	70 00                	jo     e3b <balancer_ingress+0xe3b>
     e3b:	75 64                	jne    ea1 <balancer_ingress+0xea1>
     e3d:	70 68                	jo     ea7 <balancer_ingress+0xea7>
     e3f:	64 72 00             	fs jb  e42 <balancer_ingress+0xe42>
     e42:	64 65 63 61 70       	fs movsxd %gs:0x70(%rcx),%esp
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     e47:	5f                   	pop    %rdi
     e48:	76 34                	jbe    e7e <balancer_ingress+0xe7e>
     e4a:	00 70 61             	add    %dh,0x61(%rax)
     e4d:	72 73                	jb     ec2 <balancer_ingress+0xec2>
     e4f:	65 5f                	gs pop %rdi
     e51:	71 75                	jno    ec8 <balancer_ingress+0xec8>
  if (!data_stats) {
     e53:	69 63 00 71 75 69 63 	imul   $0x63697571,0x0(%rbx),%esp
     e5a:	5f                   	pop    %rdi
     e5b:	64 61                	fs (bad)
  data_stats->v1 += 1;
     e5d:	74 61                	je     ec0 <balancer_ingress+0xec0>
     e5f:	00 70 6b             	add    %dh,0x6b(%rax)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     e62:	74 5f                	je     ec3 <balancer_ingress+0xec3>
     e64:	74 79                	je     edf <balancer_ingress+0xedf>
    pckt.flow.port16[0] = 0;
     e66:	70 65                	jo     ecd <balancer_ingress+0xecd>
     e68:	00 63 6f             	add    %ah,0x6f(%rbx)
     e6b:	6e                   	outsb  %ds:(%rsi),(%dx)
  vip_num = vip_info->vip_num;
     e6c:	6e                   	outsb  %ds:(%rsi),(%dx)
     e6d:	49                   	rex.WB
     e6e:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
     e72:	6e                   	outsb  %ds:(%rsi),(%dx)
     e73:	6e                   	outsb  %ds:(%rsi),(%dx)
     e74:	49                   	rex.WB
     e75:	64 56                	fs push %rsi
  __u32 cpu_num = bpf_get_smp_processor_id();
     e77:	65 72 73             	gs jb  eed <balancer_ingress+0xeed>
     e7a:	69 6f 6e 00 69 67 6e 	imul   $0x6e676900,0x6e(%rdi),%ebp
     e81:	6f                   	outsl  %ds:(%rsi),(%dx)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e82:	72 61                	jb     ee5 <balancer_ingress+0xee5>
     e84:	62                   	(bad)
     e85:	6c                   	insb   (%dx),%es:(%rdi)
     e86:	65 5f                	gs pop %rdi
     e88:	71 75                	jno    eff <balancer_ingress+0xeff>
     e8a:	69 63 5f 69 63 6d 70 	imul   $0x706d6369,0x5f(%rbx),%esp
     e91:	5f                   	pop    %rdi
     e92:	63 6f 64             	movsxd 0x64(%rdi),%ebp
     e95:	65 00 69 6e          	add    %ch,%gs:0x6e(%rcx)
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e99:	63 72 5f             	movsxd 0x5f(%rdx),%esi
     e9c:	73 65                	jae    f03 <balancer_ingress+0xf03>
     e9e:	72 76                	jb     f16 <balancer_ingress+0xf16>
     ea0:	65 72 5f             	gs jb  f02 <balancer_ingress+0xf02>
     ea3:	69 64 5f 72 6f 75 74 	imul   $0x6974756f,0x72(%rdi,%rbx,2),%esp
     eaa:	69 
    if (!lru_stats) {
     eab:	6e                   	outsb  %ds:(%rsi),(%dx)
     eac:	67 5f                	addr32 pop %rdi
    lru_stats->v1 += 1;
     eae:	73 74                	jae    f24 <balancer_ingress+0xf24>
     eb0:	61                   	(bad)
     eb1:	74 73                	je     f26 <balancer_ingress+0xf26>
     eb3:	00 6e 65             	add    %ch,0x65(%rsi)
     eb6:	77 43                	ja     efb <balancer_ingress+0xefb>
     eb8:	6f                   	outsl  %ds:(%rsi),(%dx)
     eb9:	6e                   	outsb  %ds:(%rsi),(%dx)
     eba:	6e                   	outsb  %ds:(%rsi),(%dx)
     ebb:	00 6d 69             	add    %ch,0x69(%rbp)
     ebe:	73 4d                	jae    f0d <balancer_ingress+0xf0d>
     ec0:	61                   	(bad)
     ec1:	74 63                	je     f26 <balancer_ingress+0xf26>
     ec3:	68 49 6e 4c 52       	push   $0x524c6e49
     ec8:	55                   	push   %rbp
     ec9:	00 70 65             	add    %dh,0x65(%rax)
     ecc:	72 5f                	jb     f2d <balancer_ingress+0xf2d>
     ece:	76 69                	jbe    f39 <balancer_ingress+0xf39>
     ed0:	70 5f                	jo     f31 <balancer_ingress+0xf31>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     ed2:	73 74                	jae    f48 <balancer_ingress+0xf48>
     ed4:	61                   	(bad)
  if (!lru_map) {
     ed5:	74 73                	je     f4a <balancer_ingress+0xf4a>
     ed7:	00 69 6e             	add    %ch,0x6e(%rcx)
     eda:	63 72 65             	movsxd 0x65(%rdx),%esi
     edd:	6d                   	insl   (%dx),%es:(%rdi)
  if ((vip_info->flags & F_QUIC_VIP)) {
     ede:	65 6e                	outsb  %gs:(%rsi),(%dx)
     ee0:	74 5f                	je     f41 <balancer_ingress+0xf41>
     ee2:	71 75                	jno    f59 <balancer_ingress+0xf59>
     ee4:	69 63 5f 63 69 64 5f 	imul   $0x5f646963,0x5f(%rbx),%esp
    bool is_icmp = (pckt.flags & F_ICMP);
     eeb:	76 65                	jbe    f52 <balancer_ingress+0xf52>
    if (is_icmp) {
     eed:	72 73                	jb     f62 <balancer_ingress+0xf62>
     eef:	69 6f 6e 5f 73 74 61 	imul   $0x6174735f,0x6e(%rdi),%ebp
     ef6:	74 73                	je     f6b <balancer_ingress+0xf6b>
     ef8:	00 63 68             	add    %ah,0x68(%rbx)
     efb:	65 63 6b 5f          	movsxd %gs:0x5f(%rbx),%ebp
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     eff:	61                   	(bad)
     f00:	6e                   	outsb  %ds:(%rsi),(%dx)
     f01:	64 5f                	fs pop %rdi
     f03:	75 70                	jne    f75 <balancer_ingress+0xf75>
     f05:	64 61                	fs (bad)
     f07:	74 65                	je     f6e <balancer_ingress+0xf6e>
      if (!quic_packets_stats) {
     f09:	5f                   	pop    %rdi
     f0a:	72 65                	jb     f71 <balancer_ingress+0xf71>
     f0c:	61                   	(bad)
     f0d:	6c                   	insb   (%dx),%es:(%rdi)
     f0e:	5f                   	pop    %rdi
     f0f:	69 6e 64 65 78 5f 69 	imul   $0x695f7865,0x64(%rsi),%ebp
  bool is_icmp = (pckt->flags & F_ICMP);
     f16:	6e                   	outsb  %ds:(%rsi),(%dx)
     f17:	5f                   	pop    %rdi
     f18:	6c                   	insb   (%dx),%es:(%rdi)
     f19:	72 75                	jb     f90 <balancer_ingress+0xf90>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     f1b:	00 6e 65             	add    %ch,0x65(%rsi)
     f1e:	77 5f                	ja     f7f <balancer_ingress+0xf7f>
     f20:	64 73 74             	fs jae f97 <balancer_ingress+0xf97>
     f23:	5f                   	pop    %rdi
     f24:	6c                   	insb   (%dx),%es:(%rdi)
     f25:	72 75                	jb     f9c <balancer_ingress+0xf9c>
     f27:	00 63 75             	add    %ah,0x75(%rbx)
     f2a:	72 5f                	jb     f8b <balancer_ingress+0xf8b>
     f2c:	74 69                	je     f97 <balancer_ingress+0xf97>
     f2e:	6d                   	insl   (%dx),%es:(%rdi)
     f2f:	65 00 63 6f          	add    %ah,%gs:0x6f(%rbx)
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     f33:	6e                   	outsb  %ds:(%rsi),(%dx)
     f34:	6e                   	outsb  %ds:(%rsi),(%dx)
     f35:	65 63 74 69 6f       	movsxd %gs:0x6f(%rcx,%rbp,2),%esi
     f3a:	6e                   	outsb  %ds:(%rsi),(%dx)
     f3b:	5f                   	pop    %rdi
     f3c:	74 61                	je     f9f <balancer_ingress+0xf9f>
     f3e:	62                   	(bad)
     f3f:	6c                   	insb   (%dx),%es:(%rdi)
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     f40:	65 5f                	gs pop %rdi
     f42:	6c                   	insb   (%dx),%es:(%rdi)
     f43:	6f                   	outsl  %ds:(%rsi),(%dx)
     f44:	6f                   	outsl  %ds:(%rsi),(%dx)
     f45:	6b 75 70 00          	imul   $0x0,0x70(%rbp),%esi
     f49:	69 73 47 6c 6f 62 61 	imul   $0x61626f6c,0x47(%rbx),%esi
  if (!connId) {
     f50:	6c                   	insb   (%dx),%es:(%rdi)
     f51:	4c 72 75             	rex.WR jb fc9 <balancer_ingress+0xfc9>
     f54:	00 63 68             	add    %ah,0x68(%rbx)
  __u8 connIdVersion = (connId[0] >> 6);
     f57:	65 63 6b 5f          	movsxd %gs:0x5f(%rbx),%ebp
     f5b:	75 64                	jne    fc1 <balancer_ingress+0xfc1>
     f5d:	70 5f                	jo     fbe <balancer_ingress+0xfbe>
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     f5f:	66 6c                	data16 insb (%dx),%es:(%rdi)
     f61:	6f                   	outsl  %ds:(%rsi),(%dx)
     f62:	77 5f                	ja     fc3 <balancer_ingress+0xfc3>
     f64:	6d                   	insl   (%dx),%es:(%rdi)
     f65:	69 67 72 61 74 69 6f 	imul   $0x6f697461,0x72(%rdi),%esp
     f6c:	6e                   	outsb  %ds:(%rsi),(%dx)
     f6d:	00 64 6f 77          	add    %ah,0x77(%rdi,%rbp,2)
     f71:	6e                   	outsb  %ds:(%rsi),(%dx)
     f72:	5f                   	pop    %rdi
     f73:	72 65                	jb     fda <balancer_ingress+0xfda>
     f75:	61                   	(bad)
     f76:	6c                   	insb   (%dx),%es:(%rdi)
     f77:	00 69 73             	add    %ch,0x73(%rcx)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     f7a:	5f                   	pop    %rdi
     f7b:	75 6e                	jne    feb <balancer_ingress+0xfeb>
     f7d:	64 65 72 5f          	fs gs jb fe0 <balancer_ingress+0xfe0>
     f81:	66 6c                	data16 insb (%dx),%es:(%rdi)
     f83:	6f                   	outsl  %ds:(%rsi),(%dx)
     f84:	6f                   	outsl  %ds:(%rsi),(%dx)
     f85:	64 00 63 6f          	add    %ah,%fs:0x6f(%rbx)
     f89:	6e                   	outsb  %ds:(%rsi),(%dx)
     f8a:	6e                   	outsb  %ds:(%rsi),(%dx)
     f8b:	5f                   	pop    %rdi
     f8c:	72 61                	jb     fef <balancer_ingress+0xfef>
     f8e:	74 65                	je     ff5 <balancer_ingress+0xff5>
     f90:	5f                   	pop    %rdi
     f91:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
    vip.port = 0;
     f95:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
     f98:	6e                   	outsb  %ds:(%rsi),(%dx)
     f99:	5f                   	pop    %rdi
     f9a:	72 61                	jb     ffd <balancer_ingress+0xffd>
     f9c:	74 65                	je     1003 <balancer_ingress+0x1003>
     f9e:	5f                   	pop    %rdi
     f9f:	73 74                	jae    1015 <balancer_ingress+0x1015>
     fa1:	61                   	(bad)
     fa2:	74 73                	je     1017 <balancer_ingress+0x1017>
     fa4:	00 65 6e             	add    %ah,0x6e(%rbp)
     fa7:	63 61 70             	movsxd 0x70(%rcx),%esp
    if (!vip_info) {
     faa:	5f                   	pop    %rdi
     fab:	76 34                	jbe    fe1 <balancer_ingress+0xfe1>
     fad:	00 69 70             	add    %ch,0x70(%rcx)
     fb0:	5f                   	pop    %rdi
     fb1:	73 72                	jae    1025 <balancer_ingress+0x1025>
     fb3:	63 00                	movsxd (%rax),%eax
     fb5:	63 72 65             	movsxd 0x65(%rdx),%esi
     fb8:	61                   	(bad)
     fb9:	74 65                	je     1020 <balancer_ingress+0x1020>
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     fbb:	5f                   	pop    %rdi
     fbc:	76 34                	jbe    ff2 <balancer_ingress+0xff2>
     fbe:	5f                   	pop    %rdi
     fbf:	68 64 72 00 67       	push   $0x67007264
      pckt.flow.port16[1] = 0;
     fc4:	65 74 5f             	gs je  1026 <balancer_ingress+0x1026>
     fc7:	70 61                	jo     102a <balancer_ingress+0x102a>
     fc9:	63 6b 65             	movsxd 0x65(%rbx),%ebp
     fcc:	74 5f                	je     102d <balancer_ingress+0x102d>
     fce:	64 73 74             	fs jae 1045 <balancer_ingress+0x1045>
     fd1:	00 73 72             	add    %dh,0x72(%rbx)
     fd4:	63 5f 66             	movsxd 0x66(%rdi),%ebx
     fd7:	6f                   	outsl  %ds:(%rsi),(%dx)
     fd8:	75 6e                	jne    1048 <balancer_ingress+0x1048>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fda:	64 00 68 61          	add    %ch,%fs:0x61(%rax)
     fde:	73 68                	jae    1048 <balancer_ingress+0x1048>
     fe0:	5f                   	pop    %rdi
     fe1:	31 36                	xor    %esi,(%rsi)
     fe3:	62                   	(bad)
     fe4:	79 74                	jns    105a <balancer_ingress+0x105a>
      if (!data_stats) {
     fe6:	65 73 00             	gs jae fe9 <balancer_ingress+0xfe9>
     fe9:	67 65 74 5f          	addr32 gs je 104c <balancer_ingress+0x104c>
     fed:	70 61                	jo     1050 <balancer_ingress+0x1050>
      data_stats->v1 += 1;
     fef:	63 6b 65             	movsxd 0x65(%rbx),%ebp
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     ff2:	74 5f                	je     1053 <balancer_ingress+0x1053>
     ff4:	68 61 73 68 00       	push   $0x687361
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     ff9:	62                   	(bad)
     ffa:	70 66                	jo     1062 <balancer_ingress+0x1062>
     ffc:	5f                   	pop    %rdi
     ffd:	6d                   	insl   (%dx),%es:(%rdi)
     ffe:	61                   	(bad)
     fff:	70 5f                	jo     1060 <balancer_ingress+0x1060>
    1001:	75 70                	jne    1073 <balancer_ingress+0x1073>
        data_stats->v2 += 1;
    1003:	64 61                	fs (bad)
    1005:	74 65                	je     106c <balancer_ingress+0x106c>
    1007:	5f                   	pop    %rdi
    1008:	65 6c                	gs insb (%dx),%es:(%rdi)
    100a:	65 6d                	gs insl (%dx),%es:(%rdi)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
    100c:	00 75 70             	add    %dh,0x70(%rbp)
    100f:	64 61                	fs (bad)
    1011:	74 65                	je     1078 <balancer_ingress+0x1078>
    1013:	5f                   	pop    %rdi
    1014:	76 69                	jbe    107f <balancer_ingress+0x107f>
    1016:	70 5f                	jo     1077 <balancer_ingress+0x1077>
    1018:	6c                   	insb   (%dx),%es:(%rdi)
    1019:	72 75                	jb     1090 <balancer_ingress+0x1090>
    101b:	5f                   	pop    %rdi
    101c:	6d                   	insl   (%dx),%es:(%rdi)
    101d:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
  if (!lru_map) {
    1024:	74 73                	je     1099 <balancer_ingress+0x1099>
    1026:	00 6c 72 75          	add    %ch,0x75(%rdx,%rsi,2)
    102a:	5f                   	pop    %rdi
    102b:	6d                   	insl   (%dx),%es:(%rdi)
    102c:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
  if ((vip_info->flags & F_QUIC_VIP)) {
    1033:	74 5f                	je     1094 <balancer_ingress+0x1094>
    1035:	76 69                	jbe    10a0 <balancer_ingress+0x10a0>
    1037:	70 00                	jo     1039 <balancer_ingress+0x1039>
    1039:	76 69                	jbe    10a4 <balancer_ingress+0x10a4>
    103b:	70 5f                	jo     109c <balancer_ingress+0x109c>
    103d:	6d                   	insl   (%dx),%es:(%rdi)
    bool is_icmp = (pckt.flags & F_ICMP);
    103e:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
    if (is_icmp) {
    1045:	74 73                	je     10ba <balancer_ingress+0x10ba>
    1047:	5f                   	pop    %rdi
    1048:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
    104c:	61                   	(bad)
    104d:	64 64 72 65          	fs fs jb 10b6 <balancer_ingress+0x10b6>
    1051:	73 73                	jae    10c6 <balancer_ingress+0x10c6>
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
    1053:	5f                   	pop    %rdi
    1054:	6d                   	insl   (%dx),%es:(%rdi)
    1055:	61                   	(bad)
    1056:	74 63                	je     10bb <balancer_ingress+0x10bb>
    1058:	68 00 70 6f 72       	push   $0x726f7000
    105d:	74 5f                	je     10be <balancer_ingress+0x10be>
      if (!quic_packets_stats) {
    105f:	6d                   	insl   (%dx),%es:(%rdi)
    1060:	61                   	(bad)
    1061:	74 63                	je     10c6 <balancer_ingress+0x10c6>
    1063:	68 00 70 72 6f       	push   $0x6f727000
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1068:	74 6f                	je     10d9 <balancer_ingress+0x10d9>
    106a:	5f                   	pop    %rdi
    106b:	6d                   	insl   (%dx),%es:(%rdi)
  bool is_icmp = (pckt->flags & F_ICMP);
    106c:	61                   	(bad)
    106d:	74 63                	je     10d2 <balancer_ingress+0x10d2>
    106f:	68 00 76 69 70       	push   $0x70697600
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1074:	5f                   	pop    %rdi
    1075:	6d                   	insl   (%dx),%es:(%rdi)
    1076:	61                   	(bad)
    1077:	74 63                	je     10dc <balancer_ingress+0x10dc>
    1079:	68 00 6c 72 75       	push   $0x75726c00
    107e:	5f                   	pop    %rdi
    107f:	6d                   	insl   (%dx),%es:(%rdi)
    1080:	69 73 73 5f 73 74 61 	imul   $0x6174735f,0x73(%rbx),%esi
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    1087:	74 00                	je     1089 <balancer_ingress+0x1089>
    1089:	69 6e 63 72 65 6d 65 	imul   $0x656d6572,0x63(%rsi),%ebp
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    1090:	6e                   	outsb  %ds:(%rsi),(%dx)
    1091:	74 5f                	je     10f2 <balancer_ingress+0x10f2>
    1093:	63 68 5f             	movsxd 0x5f(%rax),%ebp
    1096:	64 72 6f             	fs jb  1108 <balancer_ingress+0x1108>
    1099:	70 5f                	jo     10fa <balancer_ingress+0x10fa>
    109b:	72 65                	jb     1102 <balancer_ingress+0x1102>
  if (!connId) {
    109d:	61                   	(bad)
    109e:	6c                   	insb   (%dx),%es:(%rdi)
    109f:	5f                   	pop    %rdi
    10a0:	30 00                	xor    %al,(%rax)
    10a2:	63 68 5f             	movsxd 0x5f(%rax),%ebp
  __u8 connIdVersion = (connId[0] >> 6);
    10a5:	64 72 6f             	fs jb  1117 <balancer_ingress+0x1117>
    10a8:	70 5f                	jo     1109 <balancer_ingress+0x1109>
    10aa:	73 74                	jae    1120 <balancer_ingress+0x1120>
    10ac:	61                   	(bad)
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10ad:	74 73                	je     1122 <balancer_ingress+0x1122>
    10af:	5f                   	pop    %rdi
    10b0:	6b 65 79 00          	imul   $0x0,0x79(%rbp),%esp
    10b4:	63 68 5f             	movsxd 0x5f(%rax),%ebp
    10b7:	64 72 6f             	fs jb  1129 <balancer_ingress+0x1129>
    10ba:	70 5f                	jo     111b <balancer_ingress+0x111b>
    10bc:	73 74                	jae    1132 <balancer_ingress+0x1132>
    10be:	61                   	(bad)
    10bf:	74 73                	je     1134 <balancer_ingress+0x1134>
    10c1:	00 69 6e             	add    %ch,0x6e(%rcx)
    10c4:	63 72 65             	movsxd 0x65(%rdx),%esi
    10c7:	6d                   	insl   (%dx),%es:(%rdi)
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    10c8:	65 6e                	outsb  %gs:(%rsi),(%dx)
    10ca:	74 5f                	je     112b <balancer_ingress+0x112b>
    10cc:	63 68 5f             	movsxd 0x5f(%rax),%ebp
    10cf:	64 72 6f             	fs jb  1141 <balancer_ingress+0x1141>
    10d2:	70 5f                	jo     1133 <balancer_ingress+0x1133>
    10d4:	6e                   	outsb  %ds:(%rsi),(%dx)
    10d5:	6f                   	outsl  %ds:(%rsi),(%dx)
    10d6:	5f                   	pop    %rdi
    10d7:	72 65                	jb     113e <balancer_ingress+0x113e>
    10d9:	61                   	(bad)
    10da:	6c                   	insb   (%dx),%es:(%rdi)
    10db:	00 65 6e             	add    %ah,0x6e(%rbp)
    10de:	63 61 70             	movsxd 0x70(%rcx),%esp
    10e1:	5f                   	pop    %rdi
    10e2:	76 36                	jbe    111a <balancer_ingress+0x111a>
    10e4:	00 63 72             	add    %ah,0x72(%rbx)
    10e7:	65 61                	gs (bad)
    10e9:	74 65                	je     1150 <balancer_ingress+0x1150>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    10eb:	5f                   	pop    %rdi
    10ec:	65 6e                	outsb  %gs:(%rsi),(%dx)
    10ee:	63 61 70             	movsxd 0x70(%rcx),%esp
    10f1:	5f                   	pop    %rdi
    10f2:	69 70 76 36 5f 73 72 	imul   $0x72735f36,0x76(%rax),%esi
      if (!data_stats) {
    10f9:	63 00                	movsxd (%rax),%eax
    10fb:	63 72 65             	movsxd 0x65(%rdx),%esi
    10fe:	61                   	(bad)
    10ff:	74 65                	je     1166 <balancer_ingress+0x1166>
      data_stats->v1 += 1;
    1101:	5f                   	pop    %rdi
    1102:	76 36                	jbe    113a <balancer_ingress+0x113a>
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    1104:	5f                   	pop    %rdi
    1105:	68 64 72 00 74       	push   $0x74007264
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    110a:	63 00                	movsxd (%rax),%eax
    110c:	5f                   	pop    %rdi
    110d:	5f                   	pop    %rdi
    110e:	6a 68                	push   $0x68
    1110:	61                   	(bad)
    1111:	73 68                	jae    117b <balancer_ingress+0x117b>
    1113:	5f                   	pop    %rdi
    1114:	6e                   	outsb  %ds:(%rsi),(%dx)
    1115:	77 6f                	ja     1186 <balancer_ingress+0x1186>
    1117:	72 64                	jb     117d <balancer_ingress+0x117d>
        data_stats->v2 += 1;
    1119:	73 00                	jae    111b <balancer_ingress+0x111b>
    111b:	62                   	(bad)
    111c:	00 69 6e             	add    %ch,0x6e(%rcx)
    111f:	69 74 76 61 6c 00 72 	imul   $0x6f72006c,0x61(%rsi,%rsi,2),%esi
    1126:	6f 
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1127:	6c                   	insb   (%dx),%es:(%rdi)
    1128:	33 32                	xor    (%rdx),%esi
    112a:	00 77 6f             	add    %dh,0x6f(%rdi)
    112d:	72 64                	jb     1193 <balancer_ingress+0x1193>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    112f:	00 73 68             	add    %dh,0x68(%rbx)
    1132:	69 66 74 00 44 57 5f 	imul   $0x5f574400,0x74(%rsi),%esp
        quic_packets_stats->cid_initial += 1;
    1139:	41 54                	push   %r12
    113b:	45 5f                	rex.RB pop %r15
    113d:	75 6e                	jne    11ad <balancer_ingress+0x11ad>
    113f:	73 69                	jae    11aa <balancer_ingress+0x11aa>
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1141:	67 6e                	outsb  %ds:(%esi),(%dx)
    1143:	65 64 5f             	gs fs pop %rdi
    1146:	31 36                	xor    %esi,(%rsi)
    1148:	00 44 57 5f          	add    %al,0x5f(%rdi,%rdx,2)
    114c:	41 54                	push   %r12
    114e:	45 5f                	rex.RB pop %r15
    1150:	75 6e                	jne    11c0 <balancer_ingress+0x11c0>
    1152:	73 69                	jae    11bd <balancer_ingress+0x11bd>
    1154:	67 6e                	outsb  %ds:(%esi),(%dx)
    1156:	65 64 5f             	gs fs pop %rdi
    1159:	31 00                	xor    %eax,(%rax)
    115b:	44 57                	rex.R push %rdi
    115d:	5f                   	pop    %rdi
    115e:	41 54                	push   %r12
    1160:	45 5f                	rex.RB pop %r15
    1162:	75 6e                	jne    11d2 <balancer_ingress+0x11d2>
    1164:	73 69                	jae    11cf <balancer_ingress+0x11cf>
    1166:	67 6e                	outsb  %ds:(%esi),(%dx)
  if (!per_vip_stats) {
    1168:	65 64 5f             	gs fs pop %rdi
    116b:	38 00                	cmp    %al,(%rax)
    116d:	44 57                	rex.R push %rdi
    116f:	5f                   	pop    %rdi
    1170:	41 54                	push   %r12
    1172:	45 5f                	rex.RB pop %r15
    1174:	75 6e                	jne    11e4 <balancer_ingress+0x11e4>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1176:	73 69                	jae    11e1 <balancer_ingress+0x11e1>
    1178:	67 6e                	outsb  %ds:(%esi),(%dx)
    117a:	65 64 5f             	gs fs pop %rdi
    117d:	33 32                	xor    (%rdx),%esi
    117f:	00 44 57 5f          	add    %al,0x5f(%rdi,%rdx,2)
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1183:	41 54                	push   %r12
    1185:	45 5f                	rex.RB pop %r15
    1187:	75 6e                	jne    11f7 <balancer_ingress+0x11f7>
    1189:	73 69                	jae    11f4 <balancer_ingress+0x11f4>
        quic_packets_stats->cid_initial += 1;
    118b:	67 6e                	outsb  %ds:(%esi),(%dx)
    118d:	65 64 5f             	gs fs pop %rdi
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1190:	36 34 00             	ss xor $0x0,%al
    1193:	62 61 6c 61 6e       	(bad)
    1198:	63 65 72             	movsxd 0x72(%rbp),%esp
    119b:	5f                   	pop    %rdi
    119c:	69 6e 67 72 65 73 73 	imul   $0x73736572,0x67(%rsi),%ebp
    11a3:	00 6a 68             	add    %ch,0x68(%rdx)
    11a6:	61                   	(bad)
    11a7:	73 68                	jae    1211 <balancer_ingress+0x1211>
    11a9:	5f                   	pop    %rdi
    11aa:	32 77 6f             	xor    0x6f(%rdi),%dh
    11ad:	72 64                	jb     1213 <balancer_ingress+0x1213>
    11af:	73 00                	jae    11b1 <balancer_ingress+0x11b1>
    11b1:	6a 68                	push   $0x68
    11b3:	61                   	(bad)
    11b4:	73 68                	jae    121e <balancer_ingress+0x121e>
    11b6:	00 65 74             	add    %ah,0x74(%rbp)
    11b9:	68 5f 70 72 6f       	push   $0x6f72705f
  if (!per_vip_stats) {
    11be:	74 6f                	je     122f <balancer_ingress+0x122f>
    11c0:	00 6c 65 6e          	add    %ch,0x6e(%rbp,%riz,2)
    11c4:	67 74 68             	addr32 je 122f <balancer_ingress+0x122f>
	...

Disassembly of section .debug_addr:

0000000000000000 <.debug_addr>:
  void* data = (void*)(long)ctx->data;
   0:	04 07                	add    $0x7,%al
   2:	00 00                	add    %al,(%rax)
   4:	05 00 08 00 95       	add    $0x95000800,%eax
   9:	23 00                	and    (%rax),%eax
   b:	00 00                	add    %al,(%rax)
   d:	00 00                	add    %al,(%rax)
   f:	00 00                	add    %al,(%rax)
  11:	20 98 07 81 88 ff    	and    %bl,-0x777ef9(%rax)
  17:	ff 00                	incl   (%rax)
  void* data_end = (void*)(long)ctx->data_end;
  19:	c0 d5 5b             	rcl    $0x5b,%ch
  if (data + nh_off > data_end) {
  1c:	81 88 ff ff 00 24 98 	orl    $0x88810798,0x2400ffff(%rax)
  23:	07 81 88 
  26:	ff                   	(bad)
  27:	ff 00                	incl   (%rax)
  29:	c8 d5 5b 81          	enter  $0x5bd5,$0x81
  2d:	88 ff                	mov    %bh,%bh
  eth_proto = eth->h_proto; 
  2f:	ff 00                	incl   (%rax)
  31:	d0 d5                	rcl    %ch
  33:	5b                   	pop    %rbx
  34:	81 88 ff ff 00 30 5e 	orl    $0x88814c5e,0x3000ffff(%rax)
  3b:	4c 81 88 
  if (eth_proto == BE_ETH_P_IP) {
  3e:	ff                   	(bad)
  3f:	ff 00                	incl   (%rax)
  41:	60                   	(bad)
  42:	63 08                	movsxd (%rax),%ecx
  44:	00 c9                	add    %cl,%cl
  46:	ff                   	(bad)
  47:	ff 00                	incl   (%rax)
  49:	b0 6b                	mov    $0x6b,%al
  4b:	18 00                	sbb    %al,(%rax)
  struct packet_description pckt = {};
  4d:	c9                   	leave
  4e:	ff                   	(bad)
  4f:	ff 00                	incl   (%rax)
  51:	50                   	push   %rax
  52:	6d                   	insl   (%dx),%es:(%rdi)
  53:	18 00                	sbb    %al,(%rax)
  55:	c9                   	leave
  56:	ff                   	(bad)
  57:	ff 00                	incl   (%rax)
  59:	f0 6d                	lock insl (%dx),%es:(%rdi)
  5b:	18 00                	sbb    %al,(%rax)
  5d:	c9                   	leave
  5e:	ff                   	(bad)
  5f:	ff 00                	incl   (%rax)
  61:	28 98 07 81 88 ff    	sub    %bl,-0x777ef9(%rax)
  67:	ff 00                	incl   (%rax)
  69:	00 54 4c 81          	add    %dl,-0x7f(%rsp,%rcx,2)
  6d:	88 ff                	mov    %bh,%bh
  6f:	ff 00                	incl   (%rax)
  71:	2c 98                	sub    $0x98,%al
  73:	07                   	(bad)
  74:	81 88 ff ff 00 30 98 	orl    $0x88810798,0x3000ffff(%rax)
  7b:	07 81 88 
  7e:	ff                   	(bad)
  7f:	ff 00                	incl   (%rax)
  81:	00 54 6d 81          	add    %dl,-0x7f(%rbp,%rbp,2)
  struct vip_definition vip = {};
  85:	88 ff                	mov    %bh,%bh
  87:	ff 00                	incl   (%rax)
  89:	90                   	nop
  8a:	6e                   	outsb  %ds:(%rsi),(%dx)
  8b:	18 00                	sbb    %al,(%rax)
  8d:	c9                   	leave
  8e:	ff                   	(bad)
  8f:	ff 00                	incl   (%rax)
  91:	34 98                	xor    $0x98,%al
  93:	07                   	(bad)
  94:	81 88 ff ff 00 40 54 	orl    $0x88816d54,0x4000ffff(%rax)
  9b:	6d 81 88 
    if (iph + 1 > data_end) {
  9e:	ff                   	(bad)
  9f:	ff 00                	incl   (%rax)
  a1:	e8 d5 5b 81 88       	call   ffffffff88815c7b <server_id_map+0x36ff7012cc7b>
  a6:	ff                   	(bad)
  a7:	ff 00                	incl   (%rax)
  a9:	00 00                	add    %al,(%rax)
    if (iph->ihl != 5) {
  ab:	00 00                	add    %al,(%rax)
  ad:	00 00                	add    %al,(%rax)
  af:	00 0f                	add    %cl,(%rdi)
  b1:	01 00                	add    %eax,(%rax)
  b3:	00 00                	add    %al,(%rax)
  b5:	00 00                	add    %al,(%rax)
    pckt->tos = iph->tos;
  b7:	00 32                	add    %dh,(%rdx)
  b9:	01 00                	add    %eax,(%rax)
  bb:	00 00                	add    %al,(%rax)
  bd:	00 00                	add    %al,(%rax)
  bf:	00 b7 09 00 00 00    	add    %dh,0x9(%rdi)
    pckt->flow.proto = *protocol;
  c5:	00 00                	add    %al,(%rax)
  c7:	00 6d 04             	add    %ch,0x4(%rbp)
    if (iph->frag_off & PCKT_FRAGMENTED) {
  ca:	00 00                	add    %al,(%rax)
  cc:	00 00                	add    %al,(%rax)
  ce:	00 00                	add    %al,(%rax)
  d0:	c3                   	ret
  d1:	0b 00                	or     (%rax),%eax
  d3:	00 00                	add    %al,(%rax)
  d5:	00 00                	add    %al,(%rax)
  d7:	00 b0 04 00 00 00    	add    %dh,0x4(%rax)
  dd:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_ICMP) {
  df:	00 b4 04 00 00 00 00 	add    %dh,0x0(%rsp,%rax,1)
  e6:	00 00                	add    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
  e8:	b9 0d 00 00 00       	mov    $0xd,%ecx
  ed:	00 00                	add    %al,(%rax)
  ef:	00 bd 0d 00 00 00    	add    %bh,0xd(%rbp)
  if (icmp_hdr->type == ICMP_ECHO) {
  f5:	00 00                	add    %al,(%rax)
  f7:	00 6d 0a             	add    %ch,0xa(%rbp)
  fa:	00 00                	add    %al,(%rax)
  fc:	00 00                	add    %al,(%rax)
  fe:	00 00                	add    %al,(%rax)
 100:	9b                   	fwait
 101:	0a 00                	or     (%rax),%al
 103:	00 00                	add    %al,(%rax)
 105:	00 00                	add    %al,(%rax)
 107:	00 b7 0a 00 00 00    	add    %dh,0xa(%rdi)
 10d:	00 00                	add    %al,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
 10f:	00 e9                	add    %ch,%cl
 111:	0a 00                	or     (%rax),%al
 113:	00 00                	add    %al,(%rax)
  icmp_hdr->checksum += 0x0008;
 115:	00 00                	add    %al,(%rax)
 117:	00 30                	add    %dh,(%rax)
 119:	0b 00                	or     (%rax),%eax
 11b:	00 00                	add    %al,(%rax)
  iph->ttl = DEFAULT_TTL;
 11d:	00 00                	add    %al,(%rax)
 11f:	00 73 0b             	add    %dh,0xb(%rbx)
 122:	00 00                	add    %al,(%rax)
 124:	00 00                	add    %al,(%rax)
 126:	00 00                	add    %al,(%rax)
 128:	91                   	xchg   %eax,%ecx
 129:	0b 00                	or     (%rax),%eax
  iph->daddr = iph->saddr;
 12b:	00 00                	add    %al,(%rax)
 12d:	00 00                	add    %al,(%rax)
  iph->saddr = tmp_addr;
 12f:	00 5d 0c             	add    %bl,0xc(%rbp)
    *csum += *next_iph_u16++;
 132:	00 00                	add    %al,(%rax)
 134:	00 00                	add    %al,(%rax)
 136:	00 00                	add    %al,(%rax)
 138:	75 0c                	jne    146 <balancer_ingress+0x146>
 13a:	00 00                	add    %al,(%rax)
 13c:	00 00                	add    %al,(%rax)
 13e:	00 00                	add    %al,(%rax)
 140:	9a                   	(bad)
 141:	0c 00                	or     $0x0,%al
 143:	00 00                	add    %al,(%rax)
 145:	00 00                	add    %al,(%rax)
 147:	00 b2 0c 00 00 00    	add    %dh,0xc(%rdx)
 14d:	00 00                	add    %al,(%rax)
 14f:	00 c4                	add    %al,%ah
 151:	0c 00                	or     $0x0,%al
 153:	00 00                	add    %al,(%rax)
 155:	00 00                	add    %al,(%rax)
 157:	00 e2                	add    %ah,%dl
  struct packet_description pckt = {};
 159:	0c 00                	or     $0x0,%al
 15b:	00 00                	add    %al,(%rax)
 15d:	00 00                	add    %al,(%rax)
 15f:	00 2f                	add    %ch,(%rdi)
 161:	0d 00 00 00 00       	or     $0x0,%eax
 166:	00 00                	add    %al,(%rax)
 168:	72 0d                	jb     177 <balancer_ingress+0x177>
 16a:	00 00                	add    %al,(%rax)
 16c:	00 00                	add    %al,(%rax)
 16e:	00 00                	add    %al,(%rax)
 170:	91                   	xchg   %eax,%ecx
 171:	0d 00 00 00 00       	or     $0x0,%eax
 176:	00 00                	add    %al,(%rax)
 178:	09 0e                	or     %ecx,(%rsi)
 17a:	00 00                	add    %al,(%rax)
 17c:	00 00                	add    %al,(%rax)
 17e:	00 00                	add    %al,(%rax)
 180:	99                   	cltd
 181:	0f 00 00             	sldt   (%rax)
 184:	00 00                	add    %al,(%rax)
 186:	00 00                	add    %al,(%rax)
 188:	47 0e                	rex.RXB (bad)
 18a:	00 00                	add    %al,(%rax)
 18c:	00 00                	add    %al,(%rax)
  struct vip_definition vip = {};
 18e:	00 00                	add    %al,(%rax)
 190:	76 0e                	jbe    1a0 <balancer_ingress+0x1a0>
 192:	00 00                	add    %al,(%rax)
 194:	00 00                	add    %al,(%rax)
 196:	00 00                	add    %al,(%rax)
 198:	98                   	cwtl
 199:	0e                   	(bad)
 19a:	00 00                	add    %al,(%rax)
 19c:	00 00                	add    %al,(%rax)
 19e:	00 00                	add    %al,(%rax)
 1a0:	53                   	push   %rbx
 1a1:	10 00                	adc    %al,(%rax)
 1a3:	00 00                	add    %al,(%rax)
 1a5:	00 00                	add    %al,(%rax)
 1a7:	00 8e 11 00 00 00    	add    %cl,0x11(%rsi)
    if (ip6h + 1 > data_end) {
 1ad:	00 00                	add    %al,(%rax)
 1af:	00 91 19 00 00 00    	add    %dl,0x19(%rcx)
    *protocol = ip6h->nexthdr;
 1b5:	00 00                	add    %al,(%rax)
 1b7:	00 ba 19 00 00 00    	add    %bh,0x19(%rdx)
    pckt->flow.proto = *protocol;
 1bd:	00 00                	add    %al,(%rax)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1bf:	00 e0                	add    %ah,%al
 1c1:	19 00                	sbb    %eax,(%rax)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1c3:	00 00                	add    %al,(%rax)
 1c5:	00 00                	add    %al,(%rax)
 1c7:	00 03                	add    %al,(%rbx)
 1c9:	1a 00                	sbb    (%rax),%al
 1cb:	00 00                	add    %al,(%rax)
 1cd:	00 00                	add    %al,(%rax)
 1cf:	00 84 21 00 00 00 00 	add    %al,0x0(%rcx,%riz,1)
    *protocol = ip6h->nexthdr;
 1d6:	00 00                	add    %al,(%rax)
    if (*protocol == IPPROTO_FRAGMENT) {
 1d8:	24 22                	and    $0x22,%al
 1da:	00 00                	add    %al,(%rax)
 1dc:	00 00                	add    %al,(%rax)
 1de:	00 00                	add    %al,(%rax)
 1e0:	c5 21 00             	(bad)
 1e3:	00 00                	add    %al,(%rax)
 1e5:	00 00                	add    %al,(%rax)
 1e7:	00 eb                	add    %ch,%bl
 1e9:	10 00                	adc    %al,(%rax)
  if (icmp_hdr + 1 > data_end) {
 1eb:	00 00                	add    %al,(%rax)
 1ed:	00 00                	add    %al,(%rax)
 1ef:	00 03                	add    %al,(%rbx)
 1f1:	11 00                	adc    %eax,(%rax)
 1f3:	00 00                	add    %al,(%rax)
 1f5:	00 00                	add    %al,(%rax)
 1f7:	00 65 1a             	add    %ah,0x1a(%rbp)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 1fa:	00 00                	add    %al,(%rax)
 1fc:	00 00                	add    %al,(%rax)
 1fe:	00 00                	add    %al,(%rax)
 200:	bc 1a 00 00 00       	mov    $0x1a,%esp
 205:	00 00                	add    %al,(%rax)
 207:	00 d7                	add    %dl,%bh
 209:	1a 00                	sbb    (%rax),%al
 20b:	00 00                	add    %al,(%rax)
 20d:	00 00                	add    %al,(%rax)
 20f:	00 f6                	add    %dh,%dh
 211:	1a 00                	sbb    (%rax),%al
 213:	00 00                	add    %al,(%rax)
 215:	00 00                	add    %al,(%rax)
 217:	00 42 1b             	add    %al,0x1b(%rdx)
 21a:	00 00                	add    %al,(%rax)
 21c:	00 00                	add    %al,(%rax)
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
 21e:	00 00                	add    %al,(%rax)
 220:	5c                   	pop    %rsp
 221:	1b 00                	sbb    (%rax),%eax
  icmp_hdr->icmp6_cksum -= 0x0001;
 223:	00 00                	add    %al,(%rax)
 225:	00 00                	add    %al,(%rax)
 227:	00 61 1b             	add    %ah,0x1b(%rcx)
  ip6h->hop_limit = DEFAULT_TTL;
 22a:	00 00                	add    %al,(%rax)
 22c:	00 00                	add    %al,(%rax)
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
 22e:	00 00                	add    %al,(%rax)
 230:	79 1b                	jns    24d <balancer_ingress+0x24d>
 232:	00 00                	add    %al,(%rax)
 234:	00 00                	add    %al,(%rax)
 236:	00 00                	add    %al,(%rax)
 238:	88 1d 00 00 00 00    	mov    %bl,0x0(%rip)        # 23e <balancer_ingress+0x23e>
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
 23e:	00 00                	add    %al,(%rax)
 240:	c6                   	(bad)
 241:	1d 00 00 00 00       	sbb    $0x0,%eax
 246:	00 00                	add    %al,(%rax)
 248:	7b 1e                	jnp    268 <balancer_ingress+0x268>
 24a:	00 00                	add    %al,(%rax)
 24c:	00 00                	add    %al,(%rax)
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
 24e:	00 00                	add    %al,(%rax)
 250:	83 1f 00             	sbbl   $0x0,(%rdi)
 253:	00 00                	add    %al,(%rax)
 255:	00 00                	add    %al,(%rax)
 257:	00 ac 1e 00 00 00 00 	add    %ch,0x0(%rsi,%rbx,1)
 25e:	00 00                	add    %al,(%rax)
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 260:	f7 1e                	negl   (%rsi)
 262:	00 00                	add    %al,(%rax)
 264:	00 00                	add    %al,(%rax)
 266:	00 00                	add    %al,(%rax)
 268:	bc 1f 00 00 00       	mov    $0x1f,%esp
 26d:	00 00                	add    %al,(%rax)
 26f:	00 11                	add    %dl,(%rcx)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 271:	1f                   	(bad)
 272:	00 00                	add    %al,(%rax)
 274:	00 00                	add    %al,(%rax)
 276:	00 00                	add    %al,(%rax)
 278:	45 1f                	rex.RB (bad)
 27a:	00 00                	add    %al,(%rax)
 27c:	00 00                	add    %al,(%rax)
 27e:	00 00                	add    %al,(%rax)
 280:	4f 1f                	rex.WRXB (bad)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 282:	00 00                	add    %al,(%rax)
 284:	00 00                	add    %al,(%rax)
 286:	00 00                	add    %al,(%rax)
 288:	a4                   	movsb  %ds:(%rsi),%es:(%rdi)
 289:	1b 00                	sbb    (%rax),%eax
 28b:	00 00                	add    %al,(%rax)
 28d:	00 00                	add    %al,(%rax)
 28f:	00 e0                	add    %ah,%al
 291:	1b 00                	sbb    (%rax),%eax
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 293:	00 00                	add    %al,(%rax)
 295:	00 00                	add    %al,(%rax)
 297:	00 2f                	add    %ch,(%rdi)
 299:	1c 00                	sbb    $0x0,%al
 29b:	00 00                	add    %al,(%rax)
 29d:	00 00                	add    %al,(%rax)
 29f:	00 d0                	add    %dl,%al
 2a1:	1c 00                	sbb    $0x0,%al
 2a3:	00 00                	add    %al,(%rax)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2a5:	00 00                	add    %al,(%rax)
 2a7:	00 f6                	add    %dh,%dh
 2a9:	1c 00                	sbb    $0x0,%al
 2ab:	00 00                	add    %al,(%rax)
 2ad:	00 00                	add    %al,(%rax)
 2af:	00 db                	add    %bl,%bl
 2b1:	1f                   	(bad)
 2b2:	00 00                	add    %al,(%rax)
 2b4:	00 00                	add    %al,(%rax)
 2b6:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 2b8:	41 20 00             	and    %al,(%r8)
 2bb:	00 00                	add    %al,(%rax)
 2bd:	00 00                	add    %al,(%rax)
 2bf:	00 4a 20             	add    %cl,0x20(%rdx)
  if (icmp_hdr + 1 > data_end) {
 2c2:	00 00                	add    %al,(%rax)
 2c4:	00 00                	add    %al,(%rax)
 2c6:	00 00                	add    %al,(%rax)
 2c8:	e5 04                	in     $0x4,%eax
 2ca:	00 00                	add    %al,(%rax)
 2cc:	00 00                	add    %al,(%rax)
  if (icmp_hdr->type == ICMP_ECHO) {
 2ce:	00 00                	add    %al,(%rax)
 2d0:	e7 02                	out    %eax,$0x2
 2d2:	00 00                	add    %al,(%rax)
 2d4:	00 00                	add    %al,(%rax)
 2d6:	00 00                	add    %al,(%rax)
 2d8:	07                   	(bad)
 2d9:	03 00                	add    (%rax),%eax
 2db:	00 00                	add    %al,(%rax)
 2dd:	00 00                	add    %al,(%rax)
 2df:	00 62 08             	add    %ah,0x8(%rdx)
 2e2:	00 00                	add    %al,(%rax)
 2e4:	00 00                	add    %al,(%rax)
 2e6:	00 00                	add    %al,(%rax)
  icmp_hdr->type = ICMP_ECHOREPLY;
 2e8:	fa                   	cli
 2e9:	03 00                	add    (%rax),%eax
 2eb:	00 00                	add    %al,(%rax)
  icmp_hdr->checksum += 0x0008;
 2ed:	00 00                	add    %al,(%rax)
 2ef:	00 fe                	add    %bh,%dh
 2f1:	03 00                	add    (%rax),%eax
  iph->ttl = DEFAULT_TTL;
 2f3:	00 00                	add    %al,(%rax)
 2f5:	00 00                	add    %al,(%rax)
 2f7:	00 23                	add    %ah,(%rbx)
 2f9:	08 00                	or     %al,(%rax)
 2fb:	00 00                	add    %al,(%rax)
 2fd:	00 00                	add    %al,(%rax)
  iph->daddr = iph->saddr;
 2ff:	00 27                	add    %ah,(%rdi)
 301:	08 00                	or     %al,(%rax)
  iph->saddr = tmp_addr;
 303:	00 00                	add    %al,(%rax)
 305:	00 00                	add    %al,(%rax)
 307:	00 7a 05             	add    %bh,0x5(%rdx)
 30a:	00 00                	add    %al,(%rax)
 30c:	00 00                	add    %al,(%rax)
 30e:	00 00                	add    %al,(%rax)
 310:	8d 05 00 00 00 00    	lea    0x0(%rip),%eax        # 316 <balancer_ingress+0x316>
 316:	00 00                	add    %al,(%rax)
 318:	bb 05 00 00 00       	mov    $0x5,%ebx
 31d:	00 00                	add    %al,(%rax)
 31f:	00 d3                	add    %dl,%bl
 321:	05 00 00 00 00       	add    $0x0,%eax
 326:	00 00                	add    %al,(%rax)
 328:	f1                   	int1
 329:	05 00 00 00 00       	add    $0x0,%eax
 32e:	00 00                	add    %al,(%rax)
 330:	3b 06                	cmp    (%rsi),%eax
 332:	00 00                	add    %al,(%rax)
 334:	00 00                	add    %al,(%rax)
 336:	00 00                	add    %al,(%rax)
 338:	7e 06                	jle    340 <balancer_ingress+0x340>
 33a:	00 00                	add    %al,(%rax)
 33c:	00 00                	add    %al,(%rax)
 33e:	00 00                	add    %al,(%rax)
    if (csum >> 16)
 340:	9d                   	popf
 341:	06                   	(bad)
 342:	00 00                	add    %al,(%rax)
 344:	00 00                	add    %al,(%rax)
 346:	00 00                	add    %al,(%rax)
 348:	c5 06 00             	(bad)
 34b:	00 00                	add    %al,(%rax)
 34d:	00 00                	add    %al,(%rax)
 34f:	00 d8                	add    %bl,%al
 351:	06                   	(bad)
 352:	00 00                	add    %al,(%rax)
 354:	00 00                	add    %al,(%rax)
 356:	00 00                	add    %al,(%rax)
 358:	06                   	(bad)
 359:	07                   	(bad)
 35a:	00 00                	add    %al,(%rax)
 35c:	00 00                	add    %al,(%rax)
 35e:	00 00                	add    %al,(%rax)
 360:	1e                   	(bad)
 361:	07                   	(bad)
 362:	00 00                	add    %al,(%rax)
 364:	00 00                	add    %al,(%rax)
 366:	00 00                	add    %al,(%rax)
 368:	50                   	push   %rax
 369:	07                   	(bad)
 36a:	00 00                	add    %al,(%rax)
 36c:	00 00                	add    %al,(%rax)
 36e:	00 00                	add    %al,(%rax)
 370:	9a                   	(bad)
 371:	07                   	(bad)
 372:	00 00                	add    %al,(%rax)
 374:	00 00                	add    %al,(%rax)
 376:	00 00                	add    %al,(%rax)
 378:	dd 07                	fldl   (%rdi)
 37a:	00 00                	add    %al,(%rax)
 37c:	00 00                	add    %al,(%rax)
 37e:	00 00                	add    %al,(%rax)
 380:	fb                   	sti
 381:	07                   	(bad)
 382:	00 00                	add    %al,(%rax)
 384:	00 00                	add    %al,(%rax)
 386:	00 00                	add    %al,(%rax)
 388:	f0 08 00             	lock or %al,(%rax)
  return ~csum;
 38b:	00 00                	add    %al,(%rax)
  iph->check = csum;
 38d:	00 00                	add    %al,(%rax)
 38f:	00 1e                	add    %bl,(%rsi)
 391:	0a 00                	or     (%rax),%al
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
 393:	00 00                	add    %al,(%rax)
 395:	00 00                	add    %al,(%rax)
 397:	00 2e                	add    %ch,(%rsi)
 399:	09 00                	or     %eax,(%rax)
 39b:	00 00                	add    %al,(%rax)
 39d:	00 00                	add    %al,(%rax)
 39f:	00 5d 09             	add    %bl,0x9(%rbp)
 3a2:	00 00                	add    %al,(%rax)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
 3a4:	00 00                	add    %al,(%rax)
 3a6:	00 00                	add    %al,(%rax)
 3a8:	7f 09                	jg     3b3 <balancer_ingress+0x3b3>
 3aa:	00 00                	add    %al,(%rax)
 3ac:	00 00                	add    %al,(%rax)
 3ae:	00 00                	add    %al,(%rax)
 3b0:	fc                   	cld
 3b1:	0e                   	(bad)
 3b2:	00 00                	add    %al,(%rax)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
 3b4:	00 00                	add    %al,(%rax)
 3b6:	00 00                	add    %al,(%rax)
 3b8:	41 11 00             	adc    %eax,(%r8)
 3bb:	00 00                	add    %al,(%rax)
 3bd:	00 00                	add    %al,(%rax)
 3bf:	00 2c 12             	add    %ch,(%rdx,%rdx,1)
 3c2:	00 00                	add    %al,(%rax)
 3c4:	00 00                	add    %al,(%rax)
 3c6:	00 00                	add    %al,(%rax)
 3c8:	55                   	push   %rbp
 3c9:	12 00                	adc    (%rax),%al
 3cb:	00 00                	add    %al,(%rax)
 3cd:	00 00                	add    %al,(%rax)
 3cf:	00 7b 12             	add    %bh,0x12(%rbx)
 3d2:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_IPIP) {
 3d4:	00 00                	add    %al,(%rax)
 3d6:	00 00                	add    %al,(%rax)
 3d8:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
 3d9:	12 00                	adc    (%rax),%al
 3db:	00 00                	add    %al,(%rax)
 3dd:	00 00                	add    %al,(%rax)
 3df:	00 9f 20 00 00 00    	add    %bl,0x20(%rdi)
 3e5:	00 00                	add    %al,(%rax)
 3e7:	00 3a                	add    %bh,(%rdx)
 3e9:	21 00                	and    %eax,(%rax)
 3eb:	00 00                	add    %al,(%rax)
 3ed:	00 00                	add    %al,(%rax)
 3ef:	00 e0                	add    %ah,%al
 3f1:	20 00                	and    %al,(%rax)
 3f3:	00 00                	add    %al,(%rax)
 3f5:	00 00                	add    %al,(%rax)
 3f7:	00 da                	add    %bl,%dl
 3f9:	0f 00 00             	sldt   (%rax)
  tcp = data + off;
 3fc:	00 00                	add    %al,(%rax)
  if (is_ipv6) {
 3fe:	00 00                	add    %al,(%rax)
  tcp = data + off;
 400:	f2 0f 00 00          	repnz sldt (%rax)
  if (tcp + 1 > data_end) {
 404:	00 00                	add    %al,(%rax)
 406:	00 00                	add    %al,(%rax)
 408:	04 13                	add    $0x13,%al
 40a:	00 00                	add    %al,(%rax)
 40c:	00 00                	add    %al,(%rax)
 40e:	00 00                	add    %al,(%rax)
 410:	5b                   	pop    %rbx
  if (tcp->syn) {
 411:	13 00                	adc    (%rax),%eax
 413:	00 00                	add    %al,(%rax)
 415:	00 00                	add    %al,(%rax)
 417:	00 77 13             	add    %dh,0x13(%rdi)
 41a:	00 00                	add    %al,(%rax)
    pckt->flags |= F_SYN_SET;
 41c:	00 00                	add    %al,(%rax)
 41e:	00 00                	add    %al,(%rax)
 420:	96                   	xchg   %eax,%esi
 421:	13 00                	adc    (%rax),%eax
 423:	00 00                	add    %al,(%rax)
      pckt->flow.src = iph->saddr;
 425:	00 00                	add    %al,(%rax)
 427:	00 ee                	add    %ch,%dh
 429:	13 00                	adc    (%rax),%eax
 42b:	00 00                	add    %al,(%rax)
      pckt->flow.dst = iph->daddr;
 42d:	00 00                	add    %al,(%rax)
 42f:	00 11                	add    %dl,(%rcx)
 431:	14 00                	adc    $0x0,%al
 433:	00 00                	add    %al,(%rax)
  if (protocol == IPPROTO_ICMPV6) {
 435:	00 00                	add    %al,(%rax)
 437:	00 16                	add    %dl,(%rsi)
 439:	14 00                	adc    $0x0,%al
  if (icmp_hdr + 1 > data_end) {
 43b:	00 00                	add    %al,(%rax)
 43d:	00 00                	add    %al,(%rax)
 43f:	00 34 14             	add    %dh,(%rsp,%rdx,1)
 442:	00 00                	add    %al,(%rax)
 444:	00 00                	add    %al,(%rax)
 446:	00 00                	add    %al,(%rax)
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 448:	d6                   	(bad)
 449:	15 00 00 00 00       	adc    $0x0,%eax
 44e:	00 00                	add    %al,(%rax)
 450:	19 16                	sbb    %edx,(%rsi)
 452:	00 00                	add    %al,(%rax)
 454:	00 00                	add    %al,(%rax)
 456:	00 00                	add    %al,(%rax)
 458:	96                   	xchg   %eax,%esi
 459:	16                   	(bad)
 45a:	00 00                	add    %al,(%rax)
 45c:	00 00                	add    %al,(%rax)
 45e:	00 00                	add    %al,(%rax)
 460:	df 16                	fists  (%rsi)
 462:	00 00                	add    %al,(%rax)
 464:	00 00                	add    %al,(%rax)
 466:	00 00                	add    %al,(%rax)
 468:	38 18                	cmp    %bl,(%rax)
 46a:	00 00                	add    %al,(%rax)
 46c:	00 00                	add    %al,(%rax)
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 46e:	00 00                	add    %al,(%rax)
 470:	10 17                	adc    %dl,(%rdi)
 472:	00 00                	add    %al,(%rax)
 474:	00 00                	add    %al,(%rax)
       sizeof(struct icmp6hdr)) > data_end) {
 476:	00 00                	add    %al,(%rax)
 478:	57                   	push   %rdi
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 479:	17                   	(bad)
 47a:	00 00                	add    %al,(%rax)
 47c:	00 00                	add    %al,(%rax)
 47e:	00 00                	add    %al,(%rax)
 480:	5c                   	pop    %rsp
 481:	18 00                	sbb    %al,(%rax)
 483:	00 00                	add    %al,(%rax)
 485:	00 00                	add    %al,(%rax)
 487:	00 71 17             	add    %dh,0x17(%rcx)
 48a:	00 00                	add    %al,(%rax)
 48c:	00 00                	add    %al,(%rax)
 48e:	00 00                	add    %al,(%rax)
 490:	e2 17                	loop   4a9 <balancer_ingress+0x4a9>
 492:	00 00                	add    %al,(%rax)
 494:	00 00                	add    %al,(%rax)
 496:	00 00                	add    %al,(%rax)
 498:	ec                   	in     (%dx),%al
 499:	17                   	(bad)
 49a:	00 00                	add    %al,(%rax)
 49c:	00 00                	add    %al,(%rax)
 49e:	00 00                	add    %al,(%rax)
 4a0:	96                   	xchg   %eax,%esi
 4a1:	14 00                	adc    $0x0,%al
 4a3:	00 00                	add    %al,(%rax)
 4a5:	00 00                	add    %al,(%rax)
 4a7:	00 e2                	add    %ah,%dl
 4a9:	14 00                	adc    $0x0,%al
 4ab:	00 00                	add    %al,(%rax)
 4ad:	00 00                	add    %al,(%rax)
 4af:	00 7c 15 00          	add    %bh,0x0(%rbp,%rdx,1)
  tcp = data + off;
 4b3:	00 00                	add    %al,(%rax)
  if (is_ipv6) {
 4b5:	00 00                	add    %al,(%rax)
  tcp = data + off;
 4b7:	00 a5 15 00 00 00    	add    %ah,0x15(%rbp)
  if (tcp + 1 > data_end) {
 4bd:	00 00                	add    %al,(%rax)
 4bf:	00 82 18 00 00 00    	add    %al,0x18(%rdx)
 4c5:	00 00                	add    %al,(%rax)
  if (tcp->syn) {
 4c7:	00 f4                	add    %dh,%ah
 4c9:	18 00                	sbb    %al,(%rax)
 4cb:	00 00                	add    %al,(%rax)
 4cd:	00 00                	add    %al,(%rax)
 4cf:	00 01                	add    %al,(%rcx)
    pckt->flags |= F_SYN_SET;
 4d1:	19 00                	sbb    %eax,(%rax)
 4d3:	00 00                	add    %al,(%rax)
 4d5:	00 00                	add    %al,(%rax)
 4d7:	00 1e                	add    %bl,(%rsi)
 4d9:	02 00                	add    (%rax),%al
 4db:	00 00                	add    %al,(%rax)
 4dd:	00 00                	add    %al,(%rax)
 4df:	00 5f 02             	add    %bl,0x2(%rdi)
 4e2:	00 00                	add    %al,(%rax)
 4e4:	00 00                	add    %al,(%rax)
        bpf_map_lookup_elem(&stats, &stats_key);
 4e6:	00 00                	add    %al,(%rax)
 4e8:	2d 03 00 00 00       	sub    $0x3,%eax
 4ed:	00 00                	add    %al,(%rax)
 4ef:	00 3f                	add    %bh,(%rdi)
    if (!icmp_ptb_v6_stats) {
 4f1:	03 00                	add    (%rax),%eax
 4f3:	00 00                	add    %al,(%rax)
 4f5:	00 00                	add    %al,(%rax)
 4f7:	00 92 03 00 00 00    	add    %dl,0x3(%rdx)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 4fd:	00 00                	add    %al,(%rax)
 4ff:	00 11                	add    %dl,(%rcx)
 501:	1d 00 00 00 00       	sbb    $0x0,%eax
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 506:	00 00                	add    %al,(%rax)
 508:	20 1d 00 00 00 00    	and    %bl,0x0(%rip)        # 50e <balancer_ingress+0x50e>
      icmp_ptb_v6_stats->v2 += 1;
 50e:	00 00                	add    %al,(%rax)
  if (ip6h + 1 > data_end) {
 510:	6e                   	outsb  %ds:(%rsi),(%dx)
 511:	20 00                	and    %al,(%rax)
 513:	00 00                	add    %al,(%rax)
 515:	00 00                	add    %al,(%rax)
 517:	00 94 1f 00 00 00 00 	add    %dl,0x0(%rdi,%rbx,1)
  pckt->flow.proto = ip6h->nexthdr;
 51e:	00 00                	add    %al,(%rax)
 520:	a6                   	cmpsb  %es:(%rdi),%ds:(%rsi)
 521:	05 00 00 00 00       	add    $0x0,%eax
  pckt->flags |= F_ICMP;
 526:	00 00                	add    %al,(%rax)
 528:	29 06                	sub    %eax,(%rsi)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 52a:	00 00                	add    %al,(%rax)
 52c:	00 00                	add    %al,(%rax)
 52e:	00 00                	add    %al,(%rax)
 530:	f1                   	int1
 531:	06                   	(bad)
 532:	00 00                	add    %al,(%rax)
 534:	00 00                	add    %al,(%rax)
 536:	00 00                	add    %al,(%rax)
 538:	88 07                	mov    %al,(%rdi)
 53a:	00 00                	add    %al,(%rax)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 53c:	00 00                	add    %al,(%rax)
 53e:	00 00                	add    %al,(%rax)
 540:	08 09                	or     %cl,(%rcx)
 542:	00 00                	add    %al,(%rax)
 544:	00 00                	add    %al,(%rax)
 546:	00 00                	add    %al,(%rax)
 548:	2c 0a                	sub    $0xa,%al
 54a:	00 00                	add    %al,(%rax)
 54c:	00 00                	add    %al,(%rax)
 54e:	00 00                	add    %al,(%rax)
 550:	86 0a                	xchg   %cl,(%rdx)
 552:	00 00                	add    %al,(%rax)
 554:	00 00                	add    %al,(%rax)
 556:	00 00                	add    %al,(%rax)
 558:	1e                   	(bad)
 559:	0b 00                	or     (%rax),%eax
 55b:	00 00                	add    %al,(%rax)
 55d:	00 00                	add    %al,(%rax)
 55f:	00 88 0c 00 00 00    	add    %cl,0xc(%rax)
 565:	00 00                	add    %al,(%rax)
 567:	00 1d 0d 00 00 00    	add    %bl,0xd(%rip)        # 57a <balancer_ingress+0x57a>
 56d:	00 00                	add    %al,(%rax)
 56f:	00 21                	add    %ah,(%rcx)
 571:	0e                   	(bad)
 572:	00 00                	add    %al,(%rax)
 574:	00 00                	add    %al,(%rax)
 576:	00 00                	add    %al,(%rax)
 578:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
 579:	0f 00 00             	sldt   (%rax)
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 57c:	00 00                	add    %al,(%rax)
 57e:	00 00                	add    %al,(%rax)
 580:	b0 12                	mov    $0x12,%al
 582:	00 00                	add    %al,(%rax)
 584:	00 00                	add    %al,(%rax)
 586:	00 00                	add    %al,(%rax)
 588:	0f 13 00             	movlps %xmm0,(%rax)
 58b:	00 00                	add    %al,(%rax)
 58d:	00 00                	add    %al,(%rax)
 58f:	00 27                	add    %ah,(%rdi)
 591:	13 00                	adc    (%rax),%eax
 593:	00 00                	add    %al,(%rax)
 595:	00 00                	add    %al,(%rax)
 597:	00 ba 13 00 00 00    	add    %bh,0x13(%rdx)
 59d:	00 00                	add    %al,(%rax)
 59f:	00 03                	add    %al,(%rbx)
 5a1:	14 00                	adc    $0x0,%al
 5a3:	00 00                	add    %al,(%rax)
 5a5:	00 00                	add    %al,(%rax)
 5a7:	00 1c 14             	add    %bl,(%rsp,%rdx,1)
 5aa:	00 00                	add    %al,(%rax)
  if (decap_dst_flags) {
 5ac:	00 00                	add    %al,(%rax)
 5ae:	00 00                	add    %al,(%rax)
 5b0:	fa                   	cli
 5b1:	14 00                	adc    $0x0,%al
 5b3:	00 00                	add    %al,(%rax)
 5b5:	00 00                	add    %al,(%rax)
 5b7:	00 38                	add    %bh,(%rax)
 5b9:	16                   	(bad)
 5ba:	00 00                	add    %al,(%rax)
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 5bc:	00 00                	add    %al,(%rax)
 5be:	00 00                	add    %al,(%rax)
 5c0:	a7                   	cmpsl  %es:(%rdi),%ds:(%rsi)
 5c1:	16                   	(bad)
 5c2:	00 00                	add    %al,(%rax)
 5c4:	00 00                	add    %al,(%rax)
 5c6:	00 00                	add    %al,(%rax)
    if (!data_stats) {
 5c8:	b9 16 00 00 00       	mov    $0x16,%ecx
 5cd:	00 00                	add    %al,(%rax)
 5cf:	00 67 17             	add    %ah,0x17(%rdi)
    data_stats->v1 += 1;
 5d2:	00 00                	add    %al,(%rax)
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
 5d4:	00 00                	add    %al,(%rax)
 5d6:	00 00                	add    %al,(%rax)
 5d8:	89 18                	mov    %ebx,(%rax)
 5da:	00 00                	add    %al,(%rax)
 5dc:	00 00                	add    %al,(%rax)
 5de:	00 00                	add    %al,(%rax)
 5e0:	0e                   	(bad)
    if (!--ip6h->hop_limit) {
 5e1:	1a 00                	sbb    (%rax),%al
 5e3:	00 00                	add    %al,(%rax)
 5e5:	00 00                	add    %al,(%rax)
 5e7:	00 70 1a             	add    %dh,0x1a(%rax)
 5ea:	00 00                	add    %al,(%rax)
 5ec:	00 00                	add    %al,(%rax)
 5ee:	00 00                	add    %al,(%rax)
 5f0:	88 1a                	mov    %bl,(%rdx)
  memcpy(new_eth->h_source, old_eth->h_source, 6);
 5f2:	00 00                	add    %al,(%rax)
 5f4:	00 00                	add    %al,(%rax)
 5f6:	00 00                	add    %al,(%rax)
 5f8:	14 1b                	adc    $0x1b,%al
 5fa:	00 00                	add    %al,(%rax)
 5fc:	00 00                	add    %al,(%rax)
 5fe:	00 00                	add    %al,(%rax)
 600:	57                   	push   %rdi
 601:	1b 00                	sbb    (%rax),%eax
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 603:	00 00                	add    %al,(%rax)
 605:	00 00                	add    %al,(%rax)
 607:	00 6a 1b             	add    %ch,0x1b(%rdx)
 60a:	00 00                	add    %al,(%rax)
 60c:	00 00                	add    %al,(%rax)
 60e:	00 00                	add    %al,(%rax)
 610:	48 1c 00             	rex.W sbb $0x0,%al
 613:	00 00                	add    %al,(%rax)
    new_eth->h_proto = BE_ETH_P_IPV6;
 615:	00 00                	add    %al,(%rax)
 617:	00 e2                	add    %ah,%dl
 619:	1d 00 00 00 00       	sbb    $0x0,%eax
 61e:	00 00                	add    %al,(%rax)
 620:	54                   	push   %rsp
 621:	1e                   	(bad)
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
 622:	00 00                	add    %al,(%rax)
 624:	00 00                	add    %al,(%rax)
 626:	00 00                	add    %al,(%rax)
 628:	07                   	(bad)
 629:	1f                   	(bad)
 62a:	00 00                	add    %al,(%rax)
 62c:	00 00                	add    %al,(%rax)
 62e:	00 00                	add    %al,(%rax)
 630:	e2 1f                	loop   651 <balancer_ingress+0x651>
 632:	00 00                	add    %al,(%rax)
 634:	00 00                	add    %al,(%rax)
 636:	00 00                	add    %al,(%rax)
 638:	bd 20 00 00 00       	mov    $0x20,%ebp
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 63d:	00 00                	add    %al,(%rax)
 63f:	00 4d 21             	add    %cl,0x21(%rbp)
 642:	00 00                	add    %al,(%rax)
 644:	00 00                	add    %al,(%rax)
 646:	00 00                	add    %al,(%rax)
  if (!data_stats) {
 648:	a2 21 00 00 00 00 00 	movabs %al,0x3400000000000021
 64f:	00 34 
 651:	22 00                	and    (%rax),%al
 653:	00 00                	add    %al,(%rax)
    data_stats->v2 += 1;
 655:	00 00                	add    %al,(%rax)
 657:	00 60 22             	add    %ah,0x22(%rax)
  if (action >= 0) {
 65a:	00 00                	add    %al,(%rax)
 65c:	00 00                	add    %al,(%rax)
 65e:	00 00                	add    %al,(%rax)
 660:	77 22                	ja     684 <balancer_ingress+0x684>
 662:	00 00                	add    %al,(%rax)
  if (decap_dst_flags) {
 664:	00 00                	add    %al,(%rax)
  if (action >= 0) {
 666:	00 00                	add    %al,(%rax)
 668:	80 22 00             	andb   $0x0,(%rdx)
 66b:	00 00                	add    %al,(%rax)
 66d:	00 00                	add    %al,(%rax)
 66f:	00 89 22 00 00 00    	add    %cl,0x22(%rcx)
 675:	00 00                	add    %al,(%rax)
 677:	00 90 22 00 00 00    	add    %dl,0x22(%rax)
 67d:	00 00                	add    %al,(%rax)
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
 67f:	00 9b 22 00 00 00    	add    %bl,0x22(%rbx)
 685:	00 00                	add    %al,(%rax)
 687:	00 a4 22 00 00 00 00 	add    %ah,0x0(%rdx,%riz,1)
    if (xpop_stats_data) {
 68e:	00 00                	add    %al,(%rax)
        xpop_stats_data->v2 += 1; // IPv6 inner packets
 690:	ab                   	stos   %eax,%es:(%rdi)
 691:	22 00                	and    (%rax),%al
 693:	00 00                	add    %al,(%rax)
 695:	00 00                	add    %al,(%rax)
 697:	00 c0                	add    %al,%al
 699:	22 00                	and    (%rax),%al
 69b:	00 00                	add    %al,(%rax)
  bpf_tail_call(ctx, &subprograms, i);
 69d:	00 00                	add    %al,(%rax)
 69f:	00 dd                	add    %bl,%ch
 6a1:	22 00                	and    (%rax),%al
 6a3:	00 00                	add    %al,(%rax)
 6a5:	00 00                	add    %al,(%rax)
 6a7:	00 e7                	add    %ah,%bh
 6a9:	22 00                	and    (%rax),%al
 6ab:	00 00                	add    %al,(%rax)
 6ad:	00 00                	add    %al,(%rax)
 6af:	00 01                	add    %al,(%rcx)
 6b1:	23 00                	and    (%rax),%eax
 6b3:	00 00                	add    %al,(%rax)
 6b5:	00 00                	add    %al,(%rax)
 6b7:	00 09                	add    %cl,(%rcx)
 6b9:	23 00                	and    (%rax),%eax
 6bb:	00 00                	add    %al,(%rax)
 6bd:	00 00                	add    %al,(%rax)
 6bf:	00 15 23 00 00 00    	add    %dl,0x23(%rip)        # 6e8 <balancer_ingress+0x6e8>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 6c5:	00 00                	add    %al,(%rax)
 6c7:	00 28                	add    %ch,(%rax)
 6c9:	23 00                	and    (%rax),%eax
 6cb:	00 00                	add    %al,(%rax)
 6cd:	00 00                	add    %al,(%rax)
 6cf:	00 59 23             	add    %bl,0x23(%rcx)
 6d2:	00 00                	add    %al,(%rax)
 6d4:	00 00                	add    %al,(%rax)
 6d6:	00 00                	add    %al,(%rax)
 6d8:	60                   	(bad)
 6d9:	23 00                	and    (%rax),%eax
 6db:	00 00                	add    %al,(%rax)
 6dd:	00 00                	add    %al,(%rax)
 6df:	00 6b 23             	add    %ch,0x23(%rbx)
 6e2:	00 00                	add    %al,(%rax)
 6e4:	00 00                	add    %al,(%rax)
 6e6:	00 00                	add    %al,(%rax)
 6e8:	74 23                	je     70d <balancer_ingress+0x70d>
 6ea:	00 00                	add    %al,(%rax)
 6ec:	00 00                	add    %al,(%rax)
 6ee:	00 00                	add    %al,(%rax)
 6f0:	7d 23                	jge    715 <balancer_ingress+0x715>
 6f2:	00 00                	add    %al,(%rax)
 6f4:	00 00                	add    %al,(%rax)
 6f6:	00 00                	add    %al,(%rax)
  if (decap_dst_flags) {
 6f8:	86 23                	xchg   %ah,(%rbx)
 6fa:	00 00                	add    %al,(%rax)
 6fc:	00 00                	add    %al,(%rax)
 6fe:	00 00                	add    %al,(%rax)
 700:	8b 23                	mov    (%rbx),%esp
 702:	00 00                	add    %al,(%rax)
 704:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_line:

0000000000000000 <.debug_line>:
  void* data = (void*)(long)ctx->data;
       0:	b1 19                	mov    $0x19,%cl
       2:	00 00                	add    %al,(%rax)
       4:	05 00 08 00 2e       	add    $0x2e000800,%eax
       9:	02 00                	add    (%rax),%al
       b:	00 01                	add    %al,(%rcx)
       d:	01 01                	add    %eax,(%rcx)
       f:	fb                   	sti
      10:	0e                   	(bad)
      11:	0d 00 01 01 01       	or     $0x1010100,%eax
      16:	01 00                	add    %eax,(%rax)
  void* data_end = (void*)(long)ctx->data_end;
      18:	00 00                	add    %al,(%rax)
      1a:	01 00                	add    %eax,(%rax)
  if (data + nh_off > data_end) {
      1c:	00 01                	add    %al,(%rcx)
      1e:	01 01                	add    %eax,(%rcx)
      20:	1f                   	(bad)
      21:	06                   	(bad)
      22:	00 00                	add    %al,(%rax)
      24:	00 00                	add    %al,(%rax)
      26:	2b 00                	sub    (%rax),%eax
      28:	00 00                	add    %al,(%rax)
      2a:	3c 00                	cmp    $0x0,%al
      2c:	00 00                	add    %al,(%rax)
  eth_proto = eth->h_proto; 
      2e:	55                   	push   %rbp
      2f:	00 00                	add    %al,(%rax)
      31:	00 68 00             	add    %ch,0x0(%rax)
      34:	00 00                	add    %al,(%rax)
      36:	97                   	xchg   %eax,%edi
      37:	00 00                	add    %al,(%rax)
  if (eth_proto == BE_ETH_P_IP) {
      39:	00 03                	add    %al,(%rbx)
      3b:	01 1f                	add    %ebx,(%rdi)
      3d:	02 0f                	add    (%rdi),%cl
      3f:	05 1e 18 b3 00       	add    $0xb3181e,%eax
      44:	00 00                	add    %al,(%rax)
      46:	00 57 ea             	add    %dl,-0x16(%rdi)
      49:	56                   	push   %rsi
      4a:	31 e7                	xor    %esp,%edi
      4c:	89 21                	mov    %esp,(%rcx)
  struct packet_description pckt = {};
      4e:	ec                   	in     (%dx),%al
      4f:	1d e4 15 0c 45       	sbb    $0x450c15e4,%eax
      54:	e3 d9                	jrcxz  2f <balancer_ingress+0x2f>
      56:	de d1                	(bad)
      58:	00 00                	add    %al,(%rax)
      5a:	00 01                	add    %al,(%rcx)
      5c:	5b                   	pop    %rbx
      5d:	e9 d1 d0 ad 34       	jmp    34add133 <_license+0x34adad9e>
      62:	bd 71 a1 66 7a       	mov    $0x7a66a171,%ebp
      67:	92                   	xchg   %eax,%edx
      68:	98                   	cwtl
      69:	70 c0                	jo     2b <balancer_ingress+0x2b>
      6b:	11 e5                	adc    %esp,%ebp
      6d:	00 00                	add    %al,(%rax)
      6f:	00 02                	add    %al,(%rdx)
      71:	b8 10 f2 70 73       	mov    $0x7370f210,%eax
      76:	3e 10 63 19          	ds adc %ah,0x19(%rbx)
      7a:	b6 7e                	mov    $0x7e,%dh
      7c:	f5                   	cmc
      7d:	12 c6                	adc    %dh,%al
      7f:	24 6e                	and    $0x6e,%al
      81:	f0 00 00             	lock add %al,(%rax)
  struct vip_definition vip = {};
      84:	00 01                	add    %al,(%rcx)
      86:	bc 5f e5 9e a4       	mov    $0xa49ee55f,%esp
      8b:	ca 18 d4             	lret   $0xd418
      8e:	61                   	(bad)
      8f:	6a 93                	push   $0xffffffffffffff93
      91:	aa                   	stos   %al,%es:(%rdi)
      92:	35 0e 3d 0b 03       	xor    $0x30b3d0e,%eax
      97:	01 00                	add    %eax,(%rax)
      99:	00 03                	add    %al,(%rbx)
      9b:	c0 ad e1 a1 a3 09 d6 	shrb   $0xd6,0x9a3a1e1(%rbp)
    if (iph + 1 > data_end) {
      a2:	89 6c e6 08          	mov    %ebp,0x8(%rsi,%riz,8)
      a6:	0a 51 a2             	or     -0x5e(%rcx),%dl
      a9:	d1 05 0b 01 00 00    	roll   0x10b(%rip)        # 1ba <balancer_ingress+0x1ba>
    if (iph->ihl != 5) {
      af:	01 b5 26 23 e8 bc    	add    %esi,-0x4317dcda(%rbp)
      b5:	42 2f                	rex.X (bad)
    pckt->tos = iph->tos;
      b7:	8a 08                	mov    (%rax),%cl
      b9:	35 23 90 b1 84       	xor    $0x84b19023,%eax
      be:	d4                   	(bad)
      bf:	30 1b                	xor    %bl,(%rbx)
    *protocol = iph->protocol;
      c1:	01 00                	add    %eax,(%rax)
      c3:	00 04 7e             	add    %al,(%rsi,%rdi,2)
    pckt->flow.proto = *protocol;
      c6:	74 1d                	je     e5 <balancer_ingress+0xe5>
      c8:	e2 10                	loop   da <balancer_ingress+0xda>
    if (iph->frag_off & PCKT_FRAGMENTED) {
      ca:	41 8b 3b             	mov    (%r11),%edi
      cd:	57                   	push   %rdi
      ce:	0e                   	(bad)
      cf:	bc 83 cf 80 ee       	mov    $0xee80cf83,%esp
      d4:	c9                   	leave
      d5:	29 01                	sub    %eax,(%rcx)
      d7:	00 00                	add    %al,(%rax)
      d9:	04 1a                	add    $0x1a,%al
      db:	44 71 1e             	rex.R jno fc <balancer_ingress+0xfc>
      de:	c9                   	leave
    if (*protocol == IPPROTO_ICMP) {
      df:	6a fe                	push   $0xfffffffffffffffe
      e1:	11 5d c1             	adc    %ebx,-0x3f(%rbp)
      e4:	30 dc                	xor    %bl,%ah
      e6:	e0 25                	loopne 10d <balancer_ingress+0x10d>
  if (icmp_hdr + 1 > data_end) {
      e8:	7a 60                	jp     14a <balancer_ingress+0x14a>
      ea:	2f                   	(bad)
      eb:	01 00                	add    %eax,(%rax)
      ed:	00 03                	add    %al,(%rbx)
      ef:	fc                   	cld
      f0:	de 28                	fisubrs (%rax)
      f2:	42 9f                	rex.X lahf
      f4:	cb                   	lret
  if (icmp_hdr->type == ICMP_ECHO) {
      f5:	e6 6e                	out    %al,$0x6e
      f7:	10 9e 5f e5 b9 9c    	adc    %bl,-0x63461aa1(%rsi)
      fd:	cd 45                	int    $0x45
      ff:	34 01                	xor    $0x1,%al
     101:	00 00                	add    %al,(%rax)
     103:	03 d2                	add    %edx,%edx
     105:	88 e3                	mov    %ah,%bl
     107:	08 e1                	or     %ah,%cl
     109:	42 e5 1c             	rex.X in $0x1c,%eax
     10c:	48 e7 42             	rex.W out %eax,$0x42
  icmp_hdr->type = ICMP_ECHOREPLY;
     10f:	2f                   	(bad)
     110:	4f bb aa 3f 3b 01 00 	rex.WRXB movabs $0xfc030000013b3faa,%r11
     117:	00 03 fc 
  icmp_hdr->checksum += 0x0008;
     11a:	a1 88 9f 02 74 df 06 	movabs 0x496e06df74029f88,%eax
     121:	6e 49 
  iph->ttl = DEFAULT_TTL;
     123:	cf                   	iret
     124:	4d 8d b8 01 1e 41 01 	lea    0x1411e01(%r8),%r15
  iph->daddr = iph->saddr;
     12b:	00 00                	add    %al,(%rax)
     12d:	03 5c 58 d0          	add    -0x30(%rax,%rbx,2),%ebx
  iph->saddr = tmp_addr;
     131:	77 e9                	ja     11c <balancer_ingress+0x11c>
    *csum += *next_iph_u16++;
     133:	10 b6 c2 58 85 5d    	adc    %dh,0x5d8558c2(%rsi)
     139:	ca 54 d0             	lret   $0xd054
     13c:	ec                   	in     (%dx),%al
     13d:	22 46 01             	and    0x1(%rsi),%al
     140:	00 00                	add    %al,(%rax)
     142:	01 dd                	add    %ebx,%ebp
     144:	5f                   	pop    %rdi
     145:	2d 0c a8 b9 51       	sub    $0x51b9a80c,%eax
     14a:	1e                   	(bad)
     14b:	8f a8 d1 c6          	(bad)
     14f:	4e d3 b3 ac 55 01 00 	rex.WRX shlq %cl,0x155ac(%rbx)
     156:	00 05 02 65 bf 5d    	add    %al,0x5dbf6502(%rip)        # 5dbf665e <_license+0x5dbf42c9>
  struct packet_description pckt = {};
     15c:	da 79 6c             	fidivrl 0x6c(%rcx)
     15f:	c0 b0 02 70 b2 7d c7 	shlb   $0xc7,0x7db27002(%rax)
     166:	a1 8e 5d 01 00 00 01 	movabs 0x5c24010000015d8e,%eax
     16d:	24 5c 
     16f:	80 12 ea             	adcb   $0xea,(%rdx)
     172:	92                   	xchg   %eax,%edx
     173:	00 48 b4             	add    %cl,-0x4c(%rax)
     176:	e4 bf                	in     $0xbf,%al
     178:	3b 10                	cmp    (%rax),%edx
     17a:	c5 7e 15             	(bad)
     17d:	6b 01 00             	imul   $0x0,(%rcx),%eax
     180:	00 01                	add    %al,(%rcx)
     182:	f0 b1 d3             	lock mov $0xd3,%cl
     185:	dc 61 ec             	fsubl  -0x14(%rcx)
     188:	02 2c e5 2a 49 e7 c4 	add    -0x3b18b6d6(,%riz,8),%ch
  struct vip_definition vip = {};
     18f:	a9 2a d6 7a 01       	test   $0x17ad62a,%eax
     194:	00 00                	add    %al,(%rax)
     196:	01 75 b7             	add    %esi,-0x49(%rbp)
     199:	ee                   	out    %al,(%dx)
     19a:	85 ad 3d 58 f4 a4    	test   %ebp,-0x5b0ba7c3(%rbp)
     1a0:	79 2b                	jns    1cd <balancer_ingress+0x1cd>
     1a2:	e6 16                	out    %al,$0x16
     1a4:	28 46 ca             	sub    %al,-0x36(%rsi)
     1a7:	8d 01                	lea    (%rcx),%eax
    if (ip6h + 1 > data_end) {
     1a9:	00 00                	add    %al,(%rax)
     1ab:	01 5a 90             	add    %ebx,-0x70(%rdx)
     1ae:	58                   	pop    %rax
     1af:	46 07                	rex.RX (bad)
     1b1:	61                   	(bad)
     1b2:	27                   	(bad)
     1b3:	c3                   	ret
     1b4:	c1 4a e0 0e          	rorl   $0xe,-0x20(%rdx)
    *protocol = ip6h->nexthdr;
     1b8:	b0 62                	mov    $0x62,%al
    pckt->flow.proto = *protocol;
     1ba:	0c ca                	or     $0xca,%al
     1bc:	9a                   	(bad)
     1bd:	01 00                	add    %eax,(%rax)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1bf:	00 01                	add    %al,(%rcx)
     1c1:	8a eb                	mov    %bl,%ch
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1c3:	55                   	push   %rbp
     1c4:	f9                   	stc
     1c5:	37                   	(bad)
     1c6:	57                   	push   %rdi
     1c7:	66 5e                	pop    %si
     1c9:	31 61 34             	xor    %esp,0x34(%rcx)
     1cc:	d7                   	xlat   %ds:(%rbx)
     1cd:	5b                   	pop    %rbx
     1ce:	72 4a                	jb     21a <balancer_ingress+0x21a>
     1d0:	48                   	rex.W
     1d1:	64 01 00             	add    %eax,%fs:(%rax)
    *protocol = ip6h->nexthdr;
     1d4:	00 03                	add    %al,(%rbx)
     1d6:	a5                   	movsl  %ds:(%rsi),%es:(%rdi)
    if (*protocol == IPPROTO_FRAGMENT) {
     1d7:	05 63 28 98 dc       	add    $0xdc982863,%eax
     1dc:	e5 46                	in     $0x46,%eax
     1de:	63 8b 33 44 62 7d    	movsxd 0x7d624433(%rbx),%ecx
     1e4:	33 4b aa             	xor    -0x56(%rbx),%ecx
     1e7:	01 00                	add    %eax,(%rax)
     1e9:	00 03                	add    %al,(%rbx)
  if (icmp_hdr + 1 > data_end) {
     1eb:	c5 73 77             	(bad)
     1ee:	4d 0b 3c 9a          	or     (%r10,%rbx,4),%r15
     1f2:	61                   	(bad)
     1f3:	b5 51                	mov    $0x51,%ch
     1f5:	0b e7                	or     %edi,%esp
     1f7:	5a                   	pop    %rdx
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     1f8:	6f                   	outsl  %ds:(%rsi),(%dx)
     1f9:	f3 74 b3             	repz je 1af <balancer_ingress+0x1af>
     1fc:	01 00                	add    %eax,(%rax)
     1fe:	00 03                	add    %al,(%rbx)
     200:	16                   	(bad)
     201:	3f                   	(bad)
     202:	54                   	push   %rsp
     203:	fb                   	sti
     204:	1a f2                	sbb    %dl,%dh
     206:	e2 1f                	loop   227 <balancer_ingress+0x227>
     208:	ea                   	(bad)
     209:	41 0f 14 eb          	unpcklps %xmm11,%xmm5
     20d:	18 fa                	sbb    %bh,%dl
     20f:	76 be                	jbe    1cf <balancer_ingress+0x1cf>
     211:	01 00                	add    %eax,(%rax)
     213:	00 03                	add    %al,(%rbx)
     215:	5c                   	pop    %rsp
     216:	57                   	push   %rdi
     217:	70 df                	jo     1f8 <balancer_ingress+0x1f8>
     219:	b5 68                	mov    $0x68,%ch
     21b:	97                   	xchg   %eax,%edi
     21c:	d0 23                	shlb   (%rbx)
  icmp_hdr->icmp6_type = ICMPV6_ECHO_REPLY;
     21e:	c1 9c 17 13 f3 42 24 	rcrl   $0xc4,0x2442f313(%rdi,%rdx,1)
     225:	c4 
  icmp_hdr->icmp6_cksum -= 0x0001;
     226:	01 00                	add    %eax,(%rax)
  ip6h->hop_limit = DEFAULT_TTL;
     228:	00 03                	add    %al,(%rbx)
     22a:	45 bc 38 cb 16 db    	rex.RB mov $0xdb16cb38,%r12d
  memcpy(tmp_addr, ip6h->saddr.s6_addr32, 16);
     230:	bc 75 84 26 5a       	mov    $0x5a268475,%esp
     235:	fc                   	cld
     236:	29 89 c9 cc 04 00    	sub    %ecx,0x4ccc9(%rcx)
     23c:	05 22 0a 00 09       	add    $0x9000a22,%eax
  memcpy(ip6h->saddr.s6_addr32, ip6h->daddr.s6_addr32, 16);
     241:	02 00                	add    (%rax),%al
     243:	00 00                	add    %al,(%rax)
     245:	00 00                	add    %al,(%rax)
     247:	00 00                	add    %al,(%rax)
     249:	00 03                	add    %al,(%rbx)
     24b:	b2 08                	mov    $0x8,%dl
     24d:	01 05 26 08 75 05    	add    %eax,0x5750826(%rip)        # 5750a79 <_license+0x574e6e4>
  memcpy(ip6h->daddr.s6_addr32, tmp_addr, 16);
     253:	0c 50                	or     $0x50,%al
     255:	05 15 06 90 05       	add    $0x5900615,%eax
     25a:	07                   	(bad)
     25b:	3c 05                	cmp    $0x5,%al
     25d:	14 06                	adc    $0x6,%al
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     25f:	6b 05 07 ae 06 03 bf 	imul   $0xffffffbf,0x306ae07(%rip),%eax        # 306b06d <_license+0x3068cd8>
     266:	77 66                	ja     2ce <balancer_ingress+0x2ce>
     268:	03 c1                	add    %ecx,%eax
     26a:	08 58 05             	or     %bl,0x5(%rax)
     26d:	1d 06 03 ed 7c       	sbb    $0x7ced0306,%eax
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     272:	90                   	nop
     273:	05 19 02 36 13       	add    $0x13360219,%eax
     278:	04 0c                	add    $0xc,%al
     27a:	05 0d 03 bb 7e       	add    $0x7ebb030d,%eax
     27f:	08 90 05 11 06 4a    	or     %dl,0x4a061105(%rax)
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     285:	05 09 3c 05 0e       	add    $0xe053c09,%eax
     28a:	06                   	(bad)
     28b:	6a 05                	push   $0x5
     28d:	12 06                	adc    (%rsi),%al
     28f:	58                   	pop    %rax
     290:	05 09 2e 05 16       	add    $0x16052e09,%eax
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     295:	06                   	(bad)
     296:	6b 05 0f 06 58 05 16 	imul   $0x16,0x558060f(%rip),%eax        # 55808ac <_license+0x557e517>
     29d:	06                   	(bad)
     29e:	4b 59                	rex.WXB pop %r9
     2a0:	05 0e 4e 05 17       	add    $0x17054e0e,%eax
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2a5:	06                   	(bad)
     2a6:	58                   	pop    %rax
     2a7:	04 00                	add    $0x0,%al
     2a9:	05 00 03 87 7c       	add    $0x7c870300,%eax
     2ae:	ba 04 0c 05 13       	mov    $0x13050c04,%edx
     2b3:	06                   	(bad)
     2b4:	03 fd                	add    %ebp,%edi
     2b6:	03 58 05             	add    0x5(%rax),%ebx
  if (protocol == IPPROTO_ICMPV6) {
     2b9:	09 06                	or     %eax,(%rsi)
     2bb:	3c 04                	cmp    $0x4,%al
     2bd:	0e                   	(bad)
     2be:	05 10 06 03 9e       	add    $0x9e030610,%eax
  if (icmp_hdr + 1 > data_end) {
     2c3:	7e 66                	jle    32b <balancer_ingress+0x32b>
     2c5:	05 14 06 4a 05       	add    $0x54a0614,%eax
     2ca:	11 06                	adc    %eax,(%rsi)
     2cc:	93                   	xchg   %eax,%ebx
  if (icmp_hdr->type == ICMP_ECHO) {
     2cd:	05 07 06 66 03       	add    $0x3660607,%eax
     2d2:	e2 7d                	loop   351 <balancer_ingress+0x351>
     2d4:	66 03 9e 02 58 05 12 	add    0x12055802(%rsi),%bx
     2db:	06                   	(bad)
     2dc:	03 b1 7e 90 05 16    	add    0x1605907e(%rcx),%esi
     2e2:	5c                   	pop    %rsp
     2e3:	05 0c 91 05 0e       	add    $0xe05910c,%eax
  icmp_hdr->type = ICMP_ECHOREPLY;
     2e8:	ca 4b 04             	lret   $0x44b
     2eb:	0f 03 61 4a          	lsl    0x4a(%rcx),%esp
  icmp_hdr->checksum += 0x0008;
     2ef:	05 0b 06 9e 05       	add    $0x59e060b,%eax
  iph->ttl = DEFAULT_TTL;
     2f4:	0e                   	(bad)
     2f5:	66 05 0b 58          	add    $0x580b,%ax
     2f9:	05 0e 3c 05 0b       	add    $0xb053c0e,%eax
     2fe:	3c 03                	cmp    $0x3,%al
  iph->daddr = iph->saddr;
     300:	48                   	rex.W
     301:	66 04 00             	data16 add $0x0,%al
  iph->saddr = tmp_addr;
     304:	05 1d 06 03 ae       	add    $0xae03061d,%eax
     309:	05 58 05 19 02       	add    $0x2190558,%eax
     30e:	36 13 04 0c          	ss adc (%rsp,%rcx,1),%eax
     312:	05 0e 03 a2 7e       	add    $0x7ea2030e,%eax
     317:	08 90 05 12 06 4a    	or     %dl,0x4a061205(%rax)
     31d:	05 09 3c 05 17       	add    $0x17053c09,%eax
     322:	06                   	(bad)
     323:	6b 05 16 59 05 18 4d 	imul   $0x4d,0x18055916(%rip),%eax        # 18055c40 <_license+0x180538ab>
     32a:	05 1f 59 05 1b       	add    $0x1b05591f,%eax
     32f:	06                   	(bad)
     330:	58                   	pop    %rax
     331:	05 0f 82 05 17       	add    $0x1705820f,%eax
     336:	06                   	(bad)
     337:	45 05 09 03 09 3c    	rex.RB add $0x3c090309,%eax
     33d:	05 00 06 03 a1       	add    $0xa1030600,%eax
    if (csum >> 16)
     342:	7c 66                	jl     3aa <balancer_ingress+0x3aa>
     344:	05 09 03 df 03       	add    $0x3df0309,%eax
     349:	58                   	pop    %rax
     34a:	04 0e                	add    $0xe,%al
     34c:	05 10 06 03 8d       	add    $0x8d030610,%eax
     351:	7e 90                	jle    2e3 <balancer_ingress+0x2e3>
     353:	05 14 06 4a 05       	add    $0x54a0614,%eax
     358:	07                   	(bad)
     359:	3c 05                	cmp    $0x5,%al
     35b:	11 06                	adc    %eax,(%rsi)
     35d:	69 05 07 06 66 03 91 	imul   $0x3e47e91,0x3660607(%rip),%eax        # 366096e <_license+0x365e5d9>
     364:	7e e4 03 
     367:	ef                   	out    %eax,(%dx)
     368:	01 58 05             	add    %ebx,0x5(%rax)
     36b:	18 06                	sbb    %al,(%rsi)
     36d:	03 fe                	add    %esi,%edi
     36f:	7e ba                	jle    32b <balancer_ingress+0x32b>
     371:	05 19 5c 05 13       	add    $0x13055c19,%eax
     376:	59                   	pop    %rcx
     377:	05 03 59 08 13       	add    $0x13085903,%eax
     37c:	f3 03 b9 7f 08 12 08 	repz add 0x812087f(%rcx),%edi
     383:	21 08                	and    %ecx,(%rax)
     385:	13 04 0c             	adc    (%rsp,%rcx,1),%eax
     388:	05 07 03 b5 03       	add    $0x3b50307,%eax
  iph->check = csum;
     38d:	08 12                	or     %dl,(%rdx)
     38f:	08 21                	or     %ah,(%rcx)
     391:	04 0e                	add    $0xe,%al
  memcpy(tmp_mac, eth->h_source, ETH_ALEN);
     393:	03 f3                	add    %ebx,%esi
     395:	7e 08                	jle    39f <balancer_ingress+0x39f>
     397:	20 05 10 03 42 90    	and    %al,-0x6fbdfcf0(%rip)        # ffffffff904206ad <server_id_map+0x36ff77d376ad>
     39d:	05 14 06 4a 05       	add    $0x54a0614,%eax
     3a2:	07                   	(bad)
  memcpy(eth->h_source, eth->h_dest, ETH_ALEN);
     3a3:	3c 05                	cmp    $0x5,%al
     3a5:	11 06                	adc    %eax,(%rsi)
     3a7:	69 05 07 06 66 03 e2 	imul   $0x3667de2,0x3660607(%rip),%eax        # 36609b8 <_license+0x365e623>
     3ae:	7d 66 03 
     3b1:	9e                   	sahf
     3b2:	02 58 05             	add    0x5(%rax),%bl
  memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
     3b5:	12 06                	adc    (%rsi),%al
     3b7:	03 b1 7e 90 05 16    	add    0x1605907e(%rcx),%esi
     3bd:	5c                   	pop    %rsp
     3be:	05 0c 67 05 0e       	add    $0xe05670c,%eax
     3c3:	ca 4b 04             	lret   $0x44b
     3c6:	0f 03 61 4a          	lsl    0x4a(%rcx),%esp
     3ca:	05 0b 06 9e 05       	add    $0x59e060b,%eax
     3cf:	0e                   	(bad)
     3d0:	3c 05                	cmp    $0x5,%al
     3d2:	0b 58 05             	or     0x5(%rax),%ebx
  if (protocol == IPPROTO_IPIP) {
     3d5:	0e                   	(bad)
     3d6:	66 05 0b 82          	add    $0x820b,%ax
     3da:	05 0e 66 05 0b       	add    $0xb05660e,%eax
     3df:	66 05 0e 3c          	add    $0x3c0e,%ax
     3e3:	05 0b 3c 05 09       	add    $0x9053c0b,%eax
     3e8:	06                   	(bad)
     3e9:	03 6a 66             	add    0x66(%rdx),%ebp
     3ec:	05 0e 06 c8 05       	add    $0x5c8060e,%eax
     3f1:	09 66 05             	or     %esp,0x5(%rsi)
     3f4:	0e                   	(bad)
     3f5:	08 12                	or     %dl,(%rdx)
     3f7:	05 09 74 05 0e       	add    $0xe057409,%eax
  tcp = data + off;
     3fc:	f2 05 09 74 05 0a    	repnz add $0xa057409,%eax
     402:	06                   	(bad)
     403:	a1 04 0e 05 0e 03 35 	movabs 0x52e35030e050e04,%eax
     40a:	2e 05 
  if (tcp + 1 > data_end) {
     40c:	03 03                	add    (%rbx),%eax
     40e:	54                   	push   %rsp
     40f:	58                   	pop    %rax
     410:	08 13                	or     %dl,(%rbx)
  if (tcp->syn) {
     412:	08 13                	or     %dl,(%rbx)
     414:	05 00 06 03 50       	add    $0x50030600,%eax
     419:	ac                   	lods   %ds:(%rsi),%al
     41a:	04 00                	add    $0x0,%al
    pckt->flags |= F_SYN_SET;
     41c:	05 07 06 03 e0       	add    $0xe0030607,%eax
     421:	05 08 3c 04 0c       	add    $0xc043c08,%eax
      pckt->flow.src = iph->saddr;
     426:	05 0e 03 9d 7b       	add    $0x7b9d030e,%eax
     42b:	02 27                	add    (%rdi),%ah
      pckt->flow.dst = iph->daddr;
     42d:	01 05 07 03 50 4a    	add    %eax,0x4a500307(%rip)        # 4a50073a <_license+0x4a4fe3a5>
     433:	05 0e 03 30 2e       	add    $0x2e30030e,%eax
  if (protocol == IPPROTO_ICMPV6) {
     438:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
  if (icmp_hdr + 1 > data_end) {
     43d:	06                   	(bad)
     43e:	4a 05 07 3c 06 6a    	rex.WX add $0x6a063c07,%rax
     444:	06                   	(bad)
     445:	4a 05 11 06 67 05    	rex.WX add $0x5670611,%rax
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     44b:	1d 03 fc 02 9e       	sbb    $0x9e02fc03,%eax
     450:	05 16 06 4a 05       	add    $0x54a0616,%eax
     455:	1d 06 4b 05 16       	sbb    $0x16054b06,%eax
     45a:	06                   	(bad)
     45b:	4a 04 0e             	rex.WX add $0xe,%al
     45e:	05 07 06 03 d8       	add    $0xd8030607,%eax
     463:	7e 4a                	jle    4af <balancer_ingress+0x4af>
     465:	05 10 03 93 7f       	add    $0x7f930310,%eax
     46a:	58                   	pop    %rax
     46b:	05 14 06 4a 05       	add    $0x54a0614,%eax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     470:	07                   	(bad)
     471:	3c 05                	cmp    $0x5,%al
     473:	11 06                	adc    %eax,(%rsi)
     475:	69 05 07 06 66 03 91 	imul   $0x3e47e91,0x3660607(%rip),%eax        # 3660a86 <_license+0x365e6f1>
     47c:	7e e4 03 
     47f:	ef                   	out    %eax,(%dx)
     480:	01 58 05             	add    %ebx,0x5(%rax)
     483:	3e 06                	ds (bad)
     485:	03 f6                	add    %esi,%esi
     487:	7e ba                	jle    443 <balancer_ingress+0x443>
     489:	05 21 91 05 07       	add    $0x7059121,%eax
     48e:	3b 06                	cmp    (%rsi),%eax
     490:	03 9b 7f ac 04 00    	add    0x4ac7f(%rbx),%ebx
     496:	06                   	(bad)
     497:	03 e0                	add    %eax,%esp
     499:	05 58 04 0c 05       	add    $0x50c0458,%eax
     49e:	0e                   	(bad)
     49f:	03 9d 7b 02 27 01    	add    0x127027b(%rbp),%ebx
     4a5:	05 07 03 50 4a       	add    $0x4a500307,%eax
     4aa:	05 0e 03 30 2e       	add    $0x2e30030e,%eax
     4af:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
  if (is_ipv6) {
     4b4:	06                   	(bad)
     4b5:	4a 05 07 3c 06 6a    	rex.WX add $0x6a063c07,%rax
  if (tcp + 1 > data_end) {
     4bb:	06                   	(bad)
     4bc:	4a 05 11 06 67 06    	rex.WX add $0x6670611,%rax
     4c2:	03 fc                	add    %esp,%edi
     4c4:	7e 9e                	jle    464 <balancer_ingress+0x464>
     4c6:	04 0e                	add    $0xe,%al
  if (tcp->syn) {
     4c8:	05 09 06 03 fa       	add    $0xfa030609,%eax
     4cd:	01 9e 05 0a bb 05    	add    %ebx,0x5bb0a05(%rsi)
    pckt->flags |= F_SYN_SET;
     4d3:	09 06                	or     %eax,(%rsi)
     4d5:	3c 05                	cmp    $0x5,%al
     4d7:	1b 06                	sbb    (%rsi),%eax
     4d9:	69 05 11 3d 05 0d 67 	imul   $0x6090567,0xd053d11(%rip),%eax        # d0541f4 <_license+0xd051e5f>
     4e0:	05 09 06 
     4e3:	66 05 1d 06          	add    $0x61d,%ax
        bpf_map_lookup_elem(&stats, &stats_key);
     4e7:	2f                   	(bad)
     4e8:	05 0c 52 05 10       	add    $0x1005520c,%eax
     4ed:	06                   	(bad)
     4ee:	4a 05 07 3c 05 1c    	rex.WX add $0x1c053c07,%rax
    if (!icmp_ptb_v6_stats) {
     4f4:	06                   	(bad)
     4f5:	69 05 14 06 58 05 0f 	imul   $0x54b060f,0x5580614(%rip),%eax        # 5580b13 <_license+0x557e77e>
     4fc:	06 4b 05 
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     4ff:	03 59 08             	add    0x8(%rcx),%ebx
     502:	21 06                	and    %eax,(%rsi)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     504:	03 f1                	add    %ecx,%esi
     506:	7d 08                	jge    510 <balancer_ingress+0x510>
     508:	20 04 00             	and    %al,(%rax,%rax,1)
      icmp_ptb_v6_stats->v2 += 1;
     50b:	05 07 06 03 e0       	add    $0xe0030607,%eax
  if (ip6h + 1 > data_end) {
     510:	05 58 05 05 03       	add    $0x3050558,%eax
     515:	f1                   	int1
     516:	7b 02                	jnp    51a <balancer_ingress+0x51a>
     518:	27                   	(bad)
     519:	01 04 06             	add    %eax,(%rsi,%rax,1)
  pckt->flow.proto = ip6h->nexthdr;
     51c:	05 01 03 c9 01       	add    $0x1c90301,%eax
     521:	08 2e                	or     %ch,(%rsi)
     523:	06                   	(bad)
     524:	03 e6                	add    %esi,%esp
  pckt->flags |= F_ICMP;
     526:	7c 08                	jl     530 <balancer_ingress+0x530>
     528:	82                   	(bad)
     529:	03 9a 03 3c 04 00    	add    0x43c03(%rdx),%ebx
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     52f:	05 07 06 03 bd       	add    $0xbd030607,%eax
     534:	7e 3c                	jle    572 <balancer_ingress+0x572>
     536:	06                   	(bad)
     537:	3c 03                	cmp    $0x3,%al
     539:	a9 7e 2e 05 12       	test   $0x12052e7e,%eax
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     53e:	06                   	(bad)
     53f:	03 da                	add    %edx,%ebx
     541:	01 9e 05 0a bb 05    	add    %ebx,0x5bb0a05(%rsi)
     547:	09 06                	or     %eax,(%rsi)
     549:	3c 05                	cmp    $0x5,%al
     54b:	14 06                	adc    $0x6,%al
     54d:	69 04 10 05 18 03 fc 	imul   $0xfc031805,(%rax,%rdx,1),%eax
     554:	7e 3c                	jle    592 <balancer_ingress+0x592>
     556:	05 32 06 90 05       	add    $0x5900632,%eax
     55b:	09 3c 05 0a 06 32 05 	or     %edi,0x532060a(,%rax,1)
     562:	09 06                	or     %eax,(%rsi)
     564:	90                   	nop
     565:	04 11                	add    $0x11,%al
     567:	05 03 06 03 24       	add    $0x24030603,%eax
     56c:	74 08                	je     576 <balancer_ingress+0x576>
     56e:	21 05 16 08 16 05    	and    %eax,0x5160816(%rip)        # 5160d8a <_license+0x515e9f5>
     574:	07                   	(bad)
     575:	d8 06                	fadds  (%rsi)
     577:	03 f7                	add    %edi,%esi
     579:	7e e4                	jle    55f <balancer_ingress+0x55f>
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     57b:	04 00                	add    $0x0,%al
     57d:	05 21 06 03 d6       	add    $0xd6030621,%eax
     582:	02 9e 05 08 bb 05    	add    0x5bb0805(%rsi),%bl
     588:	07                   	(bad)
     589:	06                   	(bad)
     58a:	82                   	(bad)
     58b:	05 14 06 6a 05       	add    $0x56a0614,%eax
     590:	0e                   	(bad)
     591:	4e 05 07 06 74 06    	rex.WRX add $0x6740607,%rax
     597:	03 f8                	add    %eax,%edi
     599:	7e 3c                	jle    5d7 <balancer_ingress+0x5d7>
     59b:	03 88 01 3c 06 03    	add    0x3063c01(%rax),%ecx
     5a1:	a1 7d d6 05 09 06 03 	movabs 0x2ea03060905d67d,%eax
     5a8:	ea 02 
     5aa:	9e                   	sahf
     5ab:	bb 06 3c 05 1d       	mov    $0x1d053c06,%ebx
  if (decap_dst_flags) {
     5b0:	06                   	(bad)
     5b1:	30 06                	xor    %al,(%rsi)
     5b3:	03 93 7d 4a 04 10    	add    0x10044a7d(%rbx),%edx
     5b9:	05 03 06 03 ce       	add    $0xce030603,%eax
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     5be:	00 9e 06 03 b2 7f    	add    %bl,0x7fb20306(%rsi)
     5c4:	3c 03                	cmp    $0x3,%al
     5c6:	ce                   	(bad)
    if (!data_stats) {
     5c7:	00 58 3c             	add    %bl,0x3c(%rax)
     5ca:	66 04 00             	data16 add $0x0,%al
     5cd:	05 05 06 03 83       	add    $0x83030605,%eax
    data_stats->v1 += 1;
     5d2:	01 08                	add    %ecx,(%rax)
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     5d4:	66 04 06             	data16 add $0x6,%al
     5d7:	05 01 03 c9 01       	add    $0x1c90301,%eax
     5dc:	08 2e                	or     %ch,(%rsi)
     5de:	06                   	(bad)
     5df:	03 e6                	add    %esi,%esp
    if (!--ip6h->hop_limit) {
     5e1:	7c 08                	jl     5eb <balancer_ingress+0x5eb>
     5e3:	82                   	(bad)
     5e4:	03 9a 03 3c 04 00    	add    0x43c03(%rdx),%ebx
     5ea:	05 07 06 03 bd       	add    $0xbd030607,%eax
     5ef:	7e 3c                	jle    62d <balancer_ingress+0x62d>
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     5f1:	06                   	(bad)
     5f2:	3c 03                	cmp    $0x3,%al
     5f4:	a9 7e 2e 05 12       	test   $0x12052e7e,%eax
     5f9:	06                   	(bad)
     5fa:	03 da                	add    %edx,%ebx
     5fc:	01 9e 05 0a bb 05    	add    %ebx,0x5bb0a05(%rsi)
     602:	09 06                	or     %eax,(%rsi)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     604:	3c 05                	cmp    $0x5,%al
     606:	14 06                	adc    $0x6,%al
     608:	69 04 10 05 18 03 85 	imul   $0x85031805,(%rax,%rdx,1),%eax
     60f:	7f 3c                	jg     64d <balancer_ingress+0x64d>
     611:	05 30 06 90 05       	add    $0x5900630,%eax
    new_eth->h_proto = BE_ETH_P_IPV6;
     616:	09 3c 05 11 06 33 05 	or     %edi,0x5330611(,%rax,1)
     61d:	17                   	(bad)
     61e:	06                   	(bad)
     61f:	58                   	pop    %rax
     620:	05 2a 06 3d 05       	add    $0x53d062a,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     625:	22 06                	and    (%rsi),%al
     627:	3c 05                	cmp    $0x5,%al
     629:	10 4a 05             	adc    %cl,0x5(%rdx)
     62c:	0a 06                	or     (%rsi),%al
     62e:	59                   	pop    %rcx
     62f:	04 11                	add    $0x11,%al
     631:	05 03 03 18 f2       	add    $0xf2180303,%eax
     636:	08 21                	or     %ah,(%rcx)
     638:	05 16 08 14 05       	add    $0x5140816,%eax
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     63d:	07                   	(bad)
     63e:	da 04 00             	fiaddl (%rax,%rax,1)
     641:	05 0b 03 b3 01       	add    $0x1b3030b,%eax
     646:	90                   	nop
  if (!data_stats) {
     647:	06                   	(bad)
     648:	03 c4                	add    %esp,%eax
     64a:	7d 66                	jge    6b2 <balancer_ingress+0x6b2>
     64c:	05 21 06 03 d6       	add    $0xd6030621,%eax
     651:	02 9e 05 08 bb 05    	add    0x5bb0805(%rsi),%bl
    data_stats->v2 += 1;
     657:	07                   	(bad)
     658:	06                   	(bad)
  if (action >= 0) {
     659:	82                   	(bad)
     65a:	05 14 06 6a 05       	add    $0x56a0614,%eax
     65f:	0e                   	(bad)
     660:	4e 05 07 06 74 06    	rex.WRX add $0x6740607,%rax
     666:	03 f8                	add    %eax,%edi
     668:	7e 3c                	jle    6a6 <balancer_ingress+0x6a6>
     66a:	03 88 01 3c 06 03    	add    0x3063c01(%rax),%ecx
     670:	a1 7d d6 05 09 06 03 	movabs 0x2ea03060905d67d,%eax
     677:	ea 02 
     679:	9e                   	sahf
     67a:	bb 06 3c 05 1d       	mov    $0x1d053c06,%ebx
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     67f:	06                   	(bad)
     680:	32 06                	xor    (%rsi),%al
     682:	03 91 7d 3c 04 10    	add    0x10043c7d(%rcx),%edx
     688:	05 03 06 03 ce       	add    $0xce030603,%eax
    if (xpop_stats_data) {
     68d:	00 9e 06 03 b2 7f    	add    %bl,0x7fb20306(%rsi)
     693:	3c 03                	cmp    $0x3,%al
     695:	ce                   	(bad)
     696:	00 58 3c             	add    %bl,0x3c(%rax)
     699:	66 04 0c             	data16 add $0xc,%al
     69c:	05 0e 06 03 15       	add    $0x1503060e,%eax
     6a1:	08 66 05             	or     %ah,0x5(%rsi)
     6a4:	07                   	(bad)
  bpf_tail_call(ctx, &subprograms, i);
     6a5:	03 6a 4a             	add    0x4a(%rdx),%ebp
     6a8:	05 0e 03 16 2e       	add    $0x2e16030e,%eax
     6ad:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
     6b2:	06                   	(bad)
     6b3:	4a 05 07 3c 03 9b    	rex.WX add $0xffffffff9b033c07,%rax
     6b9:	7f 66                	jg     721 <balancer_ingress+0x721>
     6bb:	04 0e                	add    $0xe,%al
     6bd:	05 16 06 03 a5       	add    $0xa5030616,%eax
     6c2:	02 08                	add    (%rax),%cl
     6c4:	66 05 07 06          	add    $0x607,%ax
    memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
     6c8:	58                   	pop    %rax
     6c9:	03 db                	add    %ebx,%ebx
     6cb:	7d 2e                	jge    6fb <balancer_ingress+0x6fb>
     6cd:	05 09 06 03 a8       	add    $0xa8030609,%eax
     6d2:	02 9e 05 0a bb 05    	add    0x5bb0a05(%rsi),%bl
     6d8:	09 06                	or     %eax,(%rsi)
     6da:	3c 05                	cmp    $0x5,%al
     6dc:	1b 06                	sbb    (%rsi),%eax
     6de:	69 05 0d 3e 05 09 06 	imul   $0x1d055806,0x9053e0d(%rip),%eax        # 90544f5 <_license+0x9052160>
     6e5:	58 05 1d 
     6e8:	06                   	(bad)
     6e9:	2f                   	(bad)
     6ea:	05 0b 50 05 0f       	add    $0xf05500b,%eax
     6ef:	06                   	(bad)
     6f0:	4a 05 07 3c 05 0c    	rex.WX add $0xc053c07,%rax
     6f6:	06                   	(bad)
  if (decap_dst_flags) {
     6f7:	69 05 10 06 58 05 07 	imul   $0x1b052e07,0x5580610(%rip),%eax        # 5580d11 <_license+0x557e97c>
     6fe:	2e 05 1b 
     701:	06                   	(bad)
     702:	69 05 14 06 58 05 0f 	imul   $0x54b060f,0x5580614(%rip),%eax        # 5580d20 <_license+0x557e98b>
     709:	06 4b 05 
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     70c:	19 59 05             	sbb    %ebx,0x5(%rcx)
     70f:	12 06                	adc    (%rsi),%al
     711:	4a 05 19 06 4b 05    	rex.WX add $0x54b0619,%rax
    if (!data_stats) {
     717:	12 06                	adc    (%rsi),%al
     719:	4a 04 00             	rex.WX add $0x0,%al
    data_stats->v1 += 1;
     71c:	05 00 03 c2 7d       	add    $0x7dc20300,%eax
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     721:	90                   	nop
     722:	05 05 06 03 8c       	add    $0x8c030605,%eax
     727:	06                   	(bad)
     728:	08 12                	or     %dl,(%rdx)
     72a:	05 0c 08 41 05       	add    $0x541080c,%eax
    csum = iph->check + 0x0001;
     72f:	0d 59 04 06 05       	or     $0x5060459,%eax
    iph->check = (csum & 0xffff) + (csum >> 16);
     734:	01 03                	add    %eax,(%rbx)
     736:	88 7d 4a             	mov    %bh,0x4a(%rbp)
     739:	04 00                	add    $0x0,%al
     73b:	05 08 03 fa 02       	add    $0x2fa0308,%eax
    if (!--iph->ttl) {
     740:	08 74 05 07          	or     %dh,0x7(%rbp,%rax,1)
     744:	06                   	(bad)
     745:	3c 05                	cmp    $0x5,%al
     747:	10 06                	adc    %al,(%rsi)
     749:	03 0f                	add    (%rdi),%ecx
     74b:	66 05 17 06          	add    $0x617,%ax
     74f:	66 05 07 74          	add    $0x7407,%ax
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     753:	03 dd                	add    %ebp,%ebx
     755:	79 66                	jns    7bd <balancer_ingress+0x7bd>
     757:	05 10 06 03 b7       	add    $0xb7030610,%eax
     75c:	06                   	(bad)
     75d:	9e                   	sahf
     75e:	05 08 bb 05 07       	add    $0x705bb08,%eax
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     763:	06                   	(bad)
     764:	3c 05                	cmp    $0x5,%al
     766:	12 06                	adc    (%rsi),%al
     768:	6b 05 18 4c 05 07 06 	imul   $0x6,0x7054c18(%rip),%eax        # 7055387 <_license+0x7052ff2>
     76f:	3c 05                	cmp    $0x5,%al
     771:	19 06                	sbb    %eax,(%rsi)
    new_eth->h_proto = BE_ETH_P_IP;
     773:	31 05 17 77 05 13    	xor    %eax,0x13057717(%rip)        # 13057e90 <_license+0x13055afb>
     779:	9f                   	lahf
     77a:	bb 06 66 03 b9       	mov    $0xb9036606,%ebx
     77f:	79 66                	jns    7e7 <balancer_ingress+0x7e7>
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     781:	05 22 06 03 cb       	add    $0xcb030622,%eax
     786:	06                   	(bad)
     787:	9e                   	sahf
     788:	05 0a bb 05 09       	add    $0x905bb0a,%eax
      if (!decap_v6(xdp, data, data_end, true)) {
     78d:	06                   	(bad)
     78e:	3c 05                	cmp    $0x5,%al
     790:	13 06                	adc    (%rsi),%eax
     792:	6c                   	insb   (%dx),%es:(%rdi)
     793:	04 0e                	add    $0xe,%al
     795:	05 16 03 d3 7b       	add    $0x7bd30316,%eax
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     79a:	08 20                	or     %ah,(%rax)
     79c:	05 07 06 58 03       	add    $0x3580607,%eax
     7a1:	db 7d 2e             	fstpt  0x2e(%rbp)
     7a4:	05 09 06 03 a8       	add    $0xa8030609,%eax
  if (!data_stats) {
     7a9:	02 9e 05 0a bb 05    	add    0x5bb0a05(%rsi),%bl
     7af:	09 06                	or     %eax,(%rsi)
     7b1:	3c 05                	cmp    $0x5,%al
     7b3:	1b 06                	sbb    (%rsi),%eax
    data_stats->v2 += 1;
     7b5:	69 05 0d 3e 05 09 06 	imul   $0x1d055806,0x9053e0d(%rip),%eax        # 90545cc <_license+0x9052237>
     7bc:	58 05 1d 
  if (action >= 0) {
     7bf:	06                   	(bad)
     7c0:	2f                   	(bad)
     7c1:	05 0b 50 05 0f       	add    $0xf05500b,%eax
     7c6:	06                   	(bad)
     7c7:	4a 05 07 3c 05 0c    	rex.WX add $0xc053c07,%rax
     7cd:	06                   	(bad)
     7ce:	69 05 10 06 58 05 07 	imul   $0x1b052e07,0x5580610(%rip),%eax        # 5580de8 <_license+0x557ea53>
     7d5:	2e 05 1b 
     7d8:	06                   	(bad)
     7d9:	69 05 14 06 58 05 0f 	imul   $0x54b060f,0x5580614(%rip),%eax        # 5580df7 <_license+0x557ea62>
     7e0:	06 4b 05 
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     7e3:	19 59 05             	sbb    %ebx,0x5(%rcx)
     7e6:	12 06                	adc    (%rsi),%al
     7e8:	4a 05 19 06 4b 05    	rex.WX add $0x54b0619,%rax
        xpop_stats_data->v1 += 1; // IPv4 inner packets
     7ee:	12 06                	adc    (%rsi),%al
     7f0:	4a 04 00             	rex.WX add $0x0,%al
     7f3:	05 0e 06 03 d7       	add    $0xd703060e,%eax
     7f8:	03 90 04 06 05 01    	add    0x1050604(%rax),%edx
     7fe:	03 85 7d 74 06 03    	add    0x306747d(%rbp),%eax
  bpf_tail_call(ctx, &subprograms, i);
     804:	e6 7c                	out    %al,$0x7c
     806:	3c 03                	cmp    $0x3,%al
     808:	9a                   	(bad)
     809:	03 58 03             	add    0x3(%rax),%ebx
     80c:	e6 7c                	out    %al,$0x7c
     80e:	66 04 00             	data16 add $0x0,%al
     811:	05 0a 06 03 97       	add    $0x9703060a,%eax
     816:	06                   	(bad)
     817:	3c 05                	cmp    $0x5,%al
     819:	09 06                	or     %eax,(%rsi)
     81b:	82                   	(bad)
     81c:	03 e9                	add    %ecx,%ebp
     81e:	79 66                	jns    886 <balancer_ingress+0x886>
     820:	05 30 06 03 9b       	add    $0x9b030630,%eax
  udp = data + off;
     825:	06                   	(bad)
     826:	3c 05                	cmp    $0x5,%al
  if (is_ipv6) {
     828:	1b 94 05 12 03 ad 7b 	sbb    0x7bad0312(%rbp,%rax,1),%edx
  if (udp + 1 > data_end) {
     82f:	ba 05 20 08 19       	mov    $0x19082005,%edx
     834:	05 13 06 4a 04       	add    $0x44a0613,%eax
     839:	06                   	(bad)
     83a:	05 01 06 03 c7       	add    $0xc7030601,%eax
     83f:	01 3c 06             	add    %edi,(%rsi,%rax,1)
     842:	03 e6                	add    %esi,%esp
     844:	7c c8                	jl     80e <balancer_ingress+0x80e>
     846:	03 9a 03 66 03 e6    	add    -0x19fc99fd(%rdx),%ebx
     84c:	7c 66                	jl     8b4 <balancer_ingress+0x8b4>
     84e:	03 9a 03 3c 04 00    	add    0x43c03(%rdx),%ebx
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     854:	05 07 06 03 bd       	add    $0xbd030607,%eax
     859:	7e 3c                	jle    897 <balancer_ingress+0x897>
     85b:	06                   	(bad)
     85c:	3c 03                	cmp    $0x3,%al
     85e:	a9 7e 2e 05 12       	test   $0x12052e7e,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     863:	06                   	(bad)
     864:	03 da                	add    %edx,%ebx
     866:	01 9e 05 0a bb 05    	add    %ebx,0x5bb0a05(%rsi)
     86c:	09 06                	or     %eax,(%rsi)
    if (!icmp_ptb_v4_stats) {
     86e:	3c 05                	cmp    $0x5,%al
     870:	14 06                	adc    $0x6,%al
     872:	69 05 00 06 03 a2 7e 	imul   $0x10043c7e,-0x5dfcfa00(%rip),%eax        # ffffffffa2030e7c <server_id_map+0x36ff89947e7c>
     879:	3c 04 10 
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     87c:	05 18 06 03 e3       	add    $0xe3030618,%eax
      icmp_ptb_v4_stats->v2 += 1;
     881:	00 4a 05             	add    %cl,0x5(%rdx)
     884:	30 06                	xor    %al,(%rsi)
  if (iph + 1 > data_end) {
     886:	90                   	nop
     887:	05 09 3c 05 11       	add    $0x11053c09,%eax
     88c:	06                   	(bad)
     88d:	33 05 17 06 58 05    	xor    0x5580617(%rip),%eax        # 5580eaa <_license+0x557eb15>
  if (iph->ihl != 5) {
     893:	2a 06                	sub    (%rsi),%al
     895:	3d 05 22 06 3c       	cmp    $0x3c062205,%eax
     89a:	05 10 4a 05 0a       	add    $0xa054a10,%eax
  pckt->flow.proto = iph->protocol;
     89f:	06                   	(bad)
     8a0:	59                   	pop    %rcx
     8a1:	04 11                	add    $0x11,%al
     8a3:	05 03 03 2d f2       	add    $0xf22d0303,%eax
  pckt->flags |= F_ICMP;
     8a8:	08 21                	or     %ah,(%rcx)
     8aa:	05 14 d7 05 07       	add    $0x705d714,%eax
  pckt->flow.src = iph->daddr;
     8af:	d7                   	xlat   %ds:(%rbx)
     8b0:	06                   	(bad)
     8b1:	03 e6                	add    %esi,%esp
     8b3:	7e e4                	jle    899 <balancer_ingress+0x899>
  pckt->flow.dst = iph->saddr;
     8b5:	04 00                	add    $0x0,%al
     8b7:	05 21 06 03 d6       	add    $0xd6030621,%eax
     8bc:	02 9e 05 08 bb 05    	add    0x5bb0805(%rsi),%bl
     8c2:	07                   	(bad)
     8c3:	06                   	(bad)
     8c4:	82                   	(bad)
     8c5:	05 14 06 6a 05       	add    $0x56a0614,%eax
     8ca:	0e                   	(bad)
     8cb:	4e 05 07 06 74 06    	rex.WRX add $0x6740607,%rax
     8d1:	03 f8                	add    %eax,%edi
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     8d3:	7e 3c                	jle    911 <balancer_ingress+0x911>
     8d5:	03 88 01 3c 06 03    	add    0x3063c01(%rax),%ecx
     8db:	a1 7d d6 05 09 06 03 	movabs 0x2ea03060905d67d,%eax
     8e2:	ea 02 
     8e4:	9e                   	sahf
     8e5:	bb 06 3c 05 1d       	mov    $0x1d053c06,%ebx
  vip.port = pckt.flow.port16[1];
     8ea:	06                   	(bad)
     8eb:	32 06                	xor    (%rsi),%al
  vip.proto = pckt.flow.proto;
     8ed:	03 91 7d 3c 04 10    	add    0x10043c7d(%rcx),%edx
     8f3:	05 03 06 03 ce       	add    $0xce030603,%eax
     8f8:	00 9e 06 03 b2 7f    	add    %bl,0x7fb20306(%rsi)
     8fe:	3c 03                	cmp    $0x3,%al
     900:	ce                   	(bad)
     901:	00 58 3c             	add    %bl,0x3c(%rax)
     904:	66 03 b2 7f 08 66 04 	add    0x466087f(%rdx),%si
  if (!vip_info) {
     90b:	0e                   	(bad)
     90c:	05 09 06 03 fa       	add    $0xfa030609,%eax
  if (data_end - data > MAX_PCKT_SIZE) {
     911:	01 9e 05 0a bb 05    	add    %ebx,0x5bb0a05(%rsi)
     917:	09 06                	or     %eax,(%rsi)
     919:	3c 05                	cmp    $0x5,%al
     91b:	1b 06                	sbb    (%rsi),%eax
     91d:	69 05 11 3d 05 0d 67 	imul   $0x6090567,0xd053d11(%rip),%eax        # d054638 <_license+0xd0522a3>
     924:	05 09 06 
     927:	66 05 1d 06          	add    $0x61d,%ax
     92b:	2f                   	(bad)
     92c:	05 0c 52 05 10       	add    $0x1005520c,%eax
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     931:	06                   	(bad)
     932:	4a 05 07 3c 04 00    	rex.WX add $0x43c07,%rax
     938:	05 00 03 f7 7d       	add    $0x7df70300,%eax
  if (!data_stats) {
     93d:	66 04 0e             	data16 add $0xe,%al
     940:	05 1c 06 03 8c       	add    $0x8c03061c,%eax
  data_stats->v1 += 1;
     945:	02 58 05             	add    0x5(%rax),%bl
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     948:	14 06                	adc    $0x6,%al
     94a:	58                   	pop    %rax
     94b:	05 0f 06 4b 05       	add    $0x54b060f,%eax
    pckt.flow.port16[0] = 0;
     950:	03 59 08             	add    0x8(%rcx),%ebx
  vip_num = vip_info->vip_num;
     953:	21 06                	and    %eax,(%rsi)
     955:	03 f1                	add    %ecx,%esi
     957:	7d e4                	jge    93d <balancer_ingress+0x93d>
     959:	04 00                	add    $0x0,%al
     95b:	05 07 06 03 e0       	add    $0xe0030607,%eax
  __u32 cpu_num = bpf_get_smp_processor_id();
     960:	05 58 06 03 a0       	add    $0xa0030658,%eax
     965:	7a 02                	jp     969 <balancer_ingress+0x969>
     967:	27                   	(bad)
     968:	01 05 12 06 03 cc    	add    %eax,-0x33fcf9ee(%rip)        # ffffffffcc030f80 <server_id_map+0x36ffb3947f80>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     96e:	01 3c 05 20 08 19 05 	add    %edi,0x5190820(,%rax,1)
     975:	13 06                	adc    (%rsi),%eax
     977:	4a 04 06             	rex.WX add $0x6,%al
     97a:	05 01 06 03 c7       	add    $0xc7030601,%eax
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     97f:	01 3c 04             	add    %edi,(%rsp,%rax,1)
     982:	00 05 07 03 bd 7e    	add    %al,0x7ebd0307(%rip)        # 7ebd0c8f <_license+0x7ebce8fa>
     988:	08 58 06             	or     %bl,0x6(%rax)
    if (!lru_stats) {
     98b:	3c 03                	cmp    $0x3,%al
     98d:	a9 7e 2e 05 12       	test   $0x12052e7e,%eax
     992:	06                   	(bad)
     993:	03 da                	add    %edx,%ebx
    lru_stats->v1 += 1;
     995:	01 9e 05 0a bb 05    	add    %ebx,0x5bb0a05(%rsi)
     99b:	09 06                	or     %eax,(%rsi)
     99d:	3c 05                	cmp    $0x5,%al
     99f:	14 06                	adc    $0x6,%al
     9a1:	69 05 10 03 ee 00 3c 	imul   $0x61a053c,0xee0310(%rip),%eax        # ee0cbb <_license+0xede926>
     9a8:	05 1a 06 
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     9ab:	90                   	nop
     9ac:	05 09 3c 04 10       	add    $0x10043c09,%eax
     9b1:	05 18 06 03 8e       	add    $0x8e030618,%eax
     9b6:	7e 66                	jle    a1e <balancer_ingress+0xa1e>
        bpf_map_lookup_elem(&stats, &stats_key);
     9b8:	05 32 06 90 05       	add    $0x5900632,%eax
     9bd:	09 3c 05 0a 06 32 05 	or     %edi,0x532060a(,%rax,1)
    if (!icmp_ptb_v4_stats) {
     9c4:	09 06                	or     %eax,(%rsi)
     9c6:	90                   	nop
     9c7:	04 11                	add    $0x11,%al
     9c9:	05 03 06 03 24       	add    $0x24030603,%eax
    icmp_ptb_v4_stats->v1 += 1;
     9ce:	74 08                	je     9d8 <balancer_ingress+0x9d8>
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     9d0:	21 05 16 08 16 05    	and    %eax,0x5160816(%rip)        # 51611ec <_license+0x515ee57>
      icmp_ptb_v4_stats->v2 += 1;
     9d6:	07                   	(bad)
     9d7:	d8 06                	fadds  (%rsi)
     9d9:	03 f7                	add    %edi,%esi
  if (iph + 1 > data_end) {
     9db:	7e 08                	jle    9e5 <balancer_ingress+0x9e5>
     9dd:	20 04 00             	and    %al,(%rax,%rax,1)
     9e0:	05 21 06 03 d6       	add    $0xd6030621,%eax
     9e5:	02 9e 05 08 bb 05    	add    0x5bb0805(%rsi),%bl
  if (iph->ihl != 5) {
     9eb:	07                   	(bad)
     9ec:	06                   	(bad)
     9ed:	82                   	(bad)
     9ee:	05 14 06 6a 05       	add    $0x56a0614,%eax
     9f3:	0e                   	(bad)
  pckt->flow.proto = iph->protocol;
     9f4:	4e 05 07 06 74 06    	rex.WRX add $0x6740607,%rax
     9fa:	03 f8                	add    %eax,%edi
     9fc:	7e 3c                	jle    a3a <balancer_ingress+0xa3a>
  pckt->flags |= F_ICMP;
     9fe:	03 88 01 3c 06 03    	add    0x3063c01(%rax),%ecx
  pckt->flow.src = iph->daddr;
     a04:	a1 7d d6 05 09 06 03 	movabs 0x2ea03060905d67d,%eax
     a0b:	ea 02 
  pckt->flow.dst = iph->saddr;
     a0d:	9e                   	sahf
     a0e:	bb 06 3c 05 1d       	mov    $0x1d053c06,%ebx
     a13:	06                   	(bad)
     a14:	30 06                	xor    %al,(%rsi)
     a16:	03 93 7d 4a 04 10    	add    0x10044a7d(%rbx),%edx
    vip.port = 0;
     a1c:	05 03 06 03 ce       	add    $0xce030603,%eax
     a21:	00 9e 06 03 b2 7f    	add    %bl,0x7fb20306(%rsi)
     a27:	3c 03                	cmp    $0x3,%al
     a29:	ce                   	(bad)
     a2a:	00 58 3c             	add    %bl,0x3c(%rax)
     a2d:	66 04 0c             	data16 add $0xc,%al
    if (!vip_info) {
     a30:	05 0e 06 03 15       	add    $0x1503060e,%eax
     a35:	08 66 05             	or     %ah,0x5(%rsi)
     a38:	07                   	(bad)
     a39:	03 6a 4a             	add    0x4a(%rdx),%ebp
     a3c:	05 0e 03 16 2e       	add    $0x2e16030e,%eax
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     a41:	05 0b 4c 05 0f       	add    $0xf054c0b,%eax
     a46:	06                   	(bad)
     a47:	4a 05 07 3c 03 9b    	rex.WX add $0xffffffff9b033c07,%rax
      pckt.flow.port16[1] = 0;
     a4d:	7f 66                	jg     ab5 <balancer_ingress+0xab5>
     a4f:	04 00                	add    $0x0,%al
     a51:	05 19 06 03 8e       	add    $0x8e030619,%eax
  struct address dst_addr = {};
     a56:	06                   	(bad)
     a57:	02 28                	add    (%rax),%ch
     a59:	01 05 0d 06 4a 05    	add    %eax,0x54a060d(%rip)        # 54a106c <_license+0x549ecd7>
     a5f:	0c 06                	or     $0x6,%al
     a61:	4d 05 0d 59 04 06    	rex.WRB add $0x604590d,%rax
    dst_addr.addr = pckt->flow.dst;
     a67:	05 01 03 88 7d       	add    $0x7d880301,%eax
     a6c:	4a 04 00             	rex.WX add $0x0,%al
     a6f:	05 08 03 fa 02       	add    $0x2fa0308,%eax
     a74:	08 74 05 07          	or     %dh,0x7(%rbp,%rax,1)
     a78:	06                   	(bad)
     a79:	3c 05                	cmp    $0x5,%al
     a7b:	10 06                	adc    %al,(%rsi)
     a7d:	03 0f                	add    (%rdi),%ecx
     a7f:	66 05 17 06          	add    $0x617,%ax
     a83:	66 05 07 74          	add    $0x7407,%ax
     a87:	03 dd                	add    %ebp,%ebx
     a89:	79 66                	jns    af1 <balancer_ingress+0xaf1>
     a8b:	05 10 06 03 b7       	add    $0xb7030610,%eax
  if (decap_dst_flags) {
     a90:	06                   	(bad)
     a91:	9e                   	sahf
     a92:	05 08 bb 05 07       	add    $0x705bb08,%eax
     a97:	06                   	(bad)
     a98:	3c 05                	cmp    $0x5,%al
     a9a:	12 06                	adc    (%rsi),%al
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a9c:	6b 05 18 4c 05 07 06 	imul   $0x6,0x7054c18(%rip),%eax        # 70556bb <_license+0x7053326>
     aa3:	3c 05                	cmp    $0x5,%al
     aa5:	19 06                	sbb    %eax,(%rsi)
    if (!data_stats) {
     aa7:	31 05 17 77 05 13    	xor    %eax,0x13057717(%rip)        # 130581c4 <_license+0x13055e2f>
     aad:	9f                   	lahf
     aae:	bb 06 66 03 b9       	mov    $0xb9036606,%ebx
     ab3:	79 66                	jns    b1b <balancer_ingress+0xb1b>
     ab5:	05 22 06 03 cb       	add    $0xcb030622,%eax
    if ((data + offset + sizeof(struct iphdr)) > data_end) {
     aba:	06                   	(bad)
     abb:	9e                   	sahf
     abc:	05 0a bb 05 09       	add    $0x905bb0a,%eax
     ac1:	06                   	(bad)
     ac2:	3c 05                	cmp    $0x5,%al
     ac4:	13 06                	adc    (%rsi),%eax
    csum = iph->check + 0x0001;
     ac6:	6c                   	insb   (%dx),%es:(%rdi)
     ac7:	06                   	(bad)
     ac8:	03 ae 79 c8 06 03    	add    0x306c879(%rsi),%ebp
    iph->check = (csum & 0xffff) + (csum >> 16);
     ace:	c7 06 9e 06 03 b9    	movl   $0xb903069e,(%rsi)
     ad4:	79 3c                	jns    b12 <balancer_ingress+0xb12>
     ad6:	03 c7                	add    %edi,%eax
     ad8:	06                   	(bad)
    if (!--iph->ttl) {
     ad9:	9e                   	sahf
     ada:	05 08 06 4b 05       	add    $0x54b0608,%eax
     adf:	07                   	(bad)
     ae0:	06                   	(bad)
     ae1:	3c 05                	cmp    $0x5,%al
     ae3:	18 06                	sbb    %al,(%rsi)
     ae5:	03 0e                	add    (%rsi),%ecx
     ae7:	66 05 07 06          	add    $0x607,%ax
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     aeb:	3c 05                	cmp    $0x5,%al
     aed:	14 06                	adc    $0x6,%al
     aef:	67 05 09 59 06 03    	addr32 add $0x3065909,%eax
     af5:	a8 79                	test   $0x79,%al
     af7:	66 05 0b 06          	add    $0x60b,%ax
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     afb:	03 ec                	add    %esp,%ebp
     afd:	06                   	(bad)
     afe:	9e                   	sahf
     aff:	05 0c bb 05 0b       	add    $0xb05bb0c,%eax
     b04:	06                   	(bad)
     b05:	3c 04                	cmp    $0x4,%al
     b07:	0c 05                	or     $0x5,%al
  new_eth->h_proto = BE_ETH_P_IP;
     b09:	0d 06 03 f6 7b       	or     $0x7bf60306,%eax
     b0e:	66 05 12 46          	add    $0x4612,%ax
     b12:	05 0d 5c 05 2b       	add    $0x2b055c0d,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
     b17:	06                   	(bad)
     b18:	4a 05 3b 4a 05 07    	rex.WX add $0x7054a3b,%rax
     b1e:	3c 03                	cmp    $0x3,%al
     b20:	9d                   	popf
     b21:	7d 66                	jge    b89 <balancer_ingress+0xb89>
     b23:	05 08 06 03 ef       	add    $0xef030608,%eax
     b28:	02 82 05 26 06 58    	add    0x58062605(%rdx),%al
     b2e:	05 07 2e 05 13       	add    $0x13052e07,%eax
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b33:	06                   	(bad)
     b34:	03 14 66             	add    (%rsi,%riz,2),%edx
     b37:	05 36 06 4a 05       	add    $0x54a0636,%eax
  if (!data_stats) {
     b3c:	09 3c 05 08 06 6b 05 	or     %edi,0x56b0608(,%rax,1)
     b43:	07                   	(bad)
     b44:	06                   	(bad)
     b45:	3c 05                	cmp    $0x5,%al
     b47:	19 06                	sbb    %eax,(%rsi)
     b49:	6a 05                	push   $0x5
    data_stats->v2 += 1;
     b4b:	07                   	(bad)
     b4c:	84 05 15 08 a2 05    	test   %al,0x5a20815(%rip)        # 5a21367 <_license+0x5a1efd2>
  if (action >= 0) {
     b52:	1d 06 3c 05 27       	sbb    $0x27053c06,%eax
     b57:	3c 05                	cmp    $0x5,%al
  if (decap_dst_flags) {
     b59:	24 4a                	and    $0x4a,%al
  if (action >= 0) {
     b5b:	05 3a 3c 03 ee       	add    $0xee033c3a,%eax
     b60:	7c 4a                	jl     bac <balancer_ingress+0xbac>
     b62:	04 00                	add    $0x0,%al
     b64:	05 0e 06 03 95       	add    $0x9503060e,%eax
     b69:	06                   	(bad)
     b6a:	82                   	(bad)
     b6b:	04 06                	add    $0x6,%al
     b6d:	05 01 03 85 7d       	add    $0x7d850301,%eax
     b72:	74 06                	je     b7a <balancer_ingress+0xb7a>
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     b74:	03 e6                	add    %esi,%esp
     b76:	7c 3c                	jl     bb4 <balancer_ingress+0xbb4>
     b78:	03 9a 03 58 03 e6    	add    -0x19fca7fd(%rdx),%ebx
     b7e:	7c 66                	jl     be6 <balancer_ingress+0xbe6>
    if (xpop_stats_data) {
     b80:	04 00                	add    $0x0,%al
     b82:	05 0a 06 03 97       	add    $0x9703060a,%eax
     b87:	06                   	(bad)
     b88:	3c 05                	cmp    $0x5,%al
     b8a:	09 06                	or     %eax,(%rsi)
     b8c:	82                   	(bad)
     b8d:	03 e9                	add    %ecx,%ebp
     b8f:	79 66                	jns    bf7 <balancer_ingress+0xbf7>
  bpf_tail_call(ctx, &subprograms, i);
     b91:	05 30 06 03 9b       	add    $0x9b030630,%eax
     b96:	06                   	(bad)
     b97:	3c 05                	cmp    $0x5,%al
     b99:	1b 94 06 03 e1 79 ba 	sbb    -0x45861efd(%rsi,%rax,1),%edx
     ba0:	05 25 06 03 e0       	add    $0xe0030625,%eax
     ba5:	06                   	(bad)
     ba6:	9e                   	sahf
     ba7:	05 0c bb 05 0b       	add    $0xb05bb0c,%eax
     bac:	06                   	(bad)
     bad:	3c 05                	cmp    $0x5,%al
     baf:	16                   	(bad)
     bb0:	06                   	(bad)
     bb1:	69 04 0e 05 14 03 e5 	imul   $0xe5031405,(%rsi,%rcx,1),%eax
     bb8:	7b 3c                	jnp    bf6 <balancer_ingress+0xbf6>
     bba:	04 00                	add    $0x0,%al
     bbc:	05 0b 03 9d 04       	add    $0x49d030b,%eax
     bc1:	58                   	pop    %rax
     bc2:	05 15 bb 06 03       	add    $0x306bb15,%eax
        bpf_map_lookup_elem(&stats, &stats_key);
     bc7:	99                   	cltd
     bc8:	79 4a                	jns    c14 <balancer_ingress+0xc14>
     bca:	05 13 06 03 c7       	add    $0xc7030613,%eax
    if (!icmp_ptb_v6_stats) {
     bcf:	06                   	(bad)
     bd0:	58                   	pop    %rax
     bd1:	06                   	(bad)
     bd2:	03 b9 79 3c 03 c7    	add    -0x38fcc387(%rcx),%edi
    icmp_ptb_v6_stats->v1 += 1;
     bd8:	06                   	(bad)
     bd9:	9e                   	sahf
     bda:	03 b9 79 4a 05 08    	add    0x8054a79(%rcx),%edi
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     be0:	06                   	(bad)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     be1:	03 c8                	add    %eax,%ecx
     be3:	06                   	(bad)
     be4:	58                   	pop    %rax
     be5:	05 07 06 3c 03       	add    $0x33c0607,%eax
      icmp_ptb_v6_stats->v2 += 1;
     bea:	b8 79 66 05 18       	mov    $0x18056679,%eax
  if (ip6h + 1 > data_end) {
     bef:	06                   	(bad)
     bf0:	03 d6                	add    %esi,%edx
     bf2:	06                   	(bad)
     bf3:	58                   	pop    %rax
     bf4:	05 07 06 82 05       	add    $0x5820607,%eax
     bf9:	14 06                	adc    $0x6,%al
     bfb:	67 05 09 59 06 03    	addr32 add $0x3065909,%eax
  pckt->flow.proto = ip6h->nexthdr;
     c01:	a8 79                	test   $0x79,%al
     c03:	66 05 0b 06          	add    $0x60b,%ax
     c07:	03 ec                	add    %esp,%ebp
  pckt->flags |= F_ICMP;
     c09:	06                   	(bad)
     c0a:	9e                   	sahf
     c0b:	05 0c bb 05 0b       	add    $0xb05bb0c,%eax
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     c10:	06                   	(bad)
     c11:	3c 04                	cmp    $0x4,%al
     c13:	0c 05                	or     $0x5,%al
     c15:	0d 06 03 f6 7b       	or     $0x7bf60306,%eax
     c1a:	66 05 12 46          	add    $0x4612,%ax
     c1e:	05 0d 5c 05 2b       	add    $0x2b055c0d,%eax
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     c23:	06                   	(bad)
     c24:	4a 05 3b 4a 05 07    	rex.WX add $0x7054a3b,%rax
     c2a:	3c 05                	cmp    $0x5,%al
     c2c:	08 06                	or     %al,(%rsi)
     c2e:	03 0c 66             	add    (%rsi,%riz,2),%ecx
     c31:	05 26 06 58 05       	add    $0x5580626,%eax
  if (protocol == IPPROTO_IPIP) {
     c36:	07                   	(bad)
     c37:	2e 05 13 06 03 14    	cs add $0x14030613,%eax
     c3d:	66 05 36 06          	add    $0x636,%ax
     c41:	4a 05 09 3c 05 08    	rex.WX add $0x8053c09,%rax
     c47:	06                   	(bad)
     c48:	6b 05 07 06 3c 05 19 	imul   $0x19,0x53c0607(%rip),%eax        # 53c1256 <_license+0x53beec1>
     c4f:	06                   	(bad)
     c50:	6a 05                	push   $0x5
     c52:	07                   	(bad)
     c53:	84 05 15 08 a2 05    	test   %al,0x5a20815(%rip)        # 5a2146e <_license+0x5a1f0d9>
     c59:	1d 06 3c 05 27       	sbb    $0x27053c06,%eax
  struct address dst_addr = {};
     c5e:	3c 05                	cmp    $0x5,%al
     c60:	24 4a                	and    $0x4a,%al
     c62:	05 3a 3c 03 ee       	add    $0xee033c3a,%eax
     c67:	7c 4a                	jl     cb3 <balancer_ingress+0xcb3>
     c69:	04 00                	add    $0x0,%al
     c6b:	05 25 06 03 e0       	add    $0xe0030625,%eax
    dst_addr.addr = pckt->flow.dst;
     c70:	06                   	(bad)
     c71:	08 20                	or     %ah,(%rax)
     c73:	05 0c bb 05 0b       	add    $0xb05bb0c,%eax
     c78:	06                   	(bad)
     c79:	3c 05                	cmp    $0x5,%al
     c7b:	16                   	(bad)
     c7c:	06                   	(bad)
     c7d:	69 04 0e 05 14 03 ea 	imul   $0xea031405,(%rsi,%rcx,1),%eax
     c84:	7b 3c                	jnp    cc2 <balancer_ingress+0xcc2>
     c86:	04 00                	add    $0x0,%al
     c88:	05 0b 03 98 04       	add    $0x498030b,%eax
  if (decap_dst_flags) {
     c8d:	58                   	pop    %rax
     c8e:	05 15 08 13 06       	add    $0x6130815,%eax
     c93:	03 99 79 4a 04 0c    	add    0xc044a79(%rcx),%ebx
     c99:	05 13 06 03 f1       	add    $0xf1030613,%eax
    data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     c9e:	02 58 05             	add    0x5(%rax),%bl
     ca1:	35 06 4a 05 09       	xor    $0x9054a06,%eax
    if (!data_stats) {
     ca6:	3c 05                	cmp    $0x5,%al
     ca8:	2d 06 69 05 09       	sub    $0x9056906,%eax
     cad:	06                   	(bad)
     cae:	3c 04                	cmp    $0x4,%al
    data_stats->v1 += 1;
     cb0:	00 05 29 06 03 ad    	add    %al,-0x52fcf9d7(%rip)        # ffffffffad0312df <server_id_map+0x36ff949482df>
    if ((*data + offset) > *data_end) {
     cb6:	04 66                	add    $0x66,%al
     cb8:	06                   	(bad)
     cb9:	03 df                	add    %edi,%ebx
     cbb:	78 4a                	js     d07 <balancer_ingress+0xd07>
     cbd:	05 07 06 03 80       	add    $0x80030607,%eax
     cc2:	05 58 06 03 80       	add    $0x80030658,%eax
    if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
     cc7:	7b 66                	jnp    d2f <balancer_ingress+0xd2f>
     cc9:	03 80 05 3c 03 80    	add    -0x7ffcc3fb(%rax),%eax
     ccf:	7b 66                	jnp    d37 <balancer_ingress+0xd37>
     cd1:	03 80 05 9e 05 08    	add    0x8059e05(%rax),%eax
    if (!--ip6h->hop_limit) {
     cd7:	06                   	(bad)
     cd8:	c9                   	leave
     cd9:	05 07 06 3c 04       	add    $0x43c0607,%eax
     cde:	0c 05                	or     $0x5,%al
     ce0:	13 06                	adc    (%rsi),%eax
  memcpy(new_eth->h_source, old_eth->h_source, 6);
     ce2:	03 f0                	add    %eax,%esi
     ce4:	7d ac                	jge    c92 <balancer_ingress+0xc92>
     ce6:	05 35 06 4a 05       	add    $0x54a0635,%eax
     ceb:	09 3c 05 2d 06 69 05 	or     %edi,0x569062d(,%rax,1)
     cf2:	09 06                	or     %eax,(%rsi)
  memcpy(new_eth->h_dest, old_eth->h_dest, 6);
     cf4:	2e 04 00             	cs add $0x0,%al
     cf7:	05 29 06 03 ad       	add    $0xad030629,%eax
     cfc:	04 66                	add    $0x66,%al
     cfe:	05 07 03 df 7d       	add    $0x7ddf0307,%eax
     d03:	4a 06                	rex.WX (bad)
    new_eth->h_proto = BE_ETH_P_IPV6;
     d05:	03 80 7b 82 03 80    	add    -0x7ffc7d85(%rax),%eax
     d0b:	05 58 03 80 7b       	add    $0x7b800358,%eax
     d10:	66 03 80 05 e4 05 08 	add    0x805e405(%rax),%ax
  if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
     d17:	06                   	(bad)
     d18:	c9                   	leave
     d19:	05 07 06 3c 04       	add    $0x43c0607,%eax
     d1e:	0c 05                	or     $0x5,%al
     d20:	23 06                	and    (%rsi),%eax
     d22:	03 fc                	add    %esp,%edi
     d24:	7d ac                	jge    cd2 <balancer_ingress+0xcd2>
     d26:	06                   	(bad)
     d27:	03 83 7d 58 05 08    	add    0x805587d(%rbx),%eax
     d2d:	06                   	(bad)
     d2e:	03 88 03 c8 05 07    	add    0x705c803(%rax),%ecx
  struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     d34:	06                   	(bad)
     d35:	3c 05                	cmp    $0x5,%al
     d37:	19 06                	sbb    %eax,(%rsi)
     d39:	03 0d ac 05 23 06    	add    0x62305ac(%rip),%ecx        # 62312eb <_license+0x622ef56>
  if (!data_stats) {
     d3f:	4a 05 2d 3c 05 37    	rex.WX add $0x37053c2d,%rax
     d45:	4a 05 2a 3c 05 40    	rex.WX add $0x40053c2a,%rax
    data_stats->v2 += 1;
     d4b:	2e 03 eb             	cs add %ebx,%ebp
  if (action >= 0) {
     d4e:	7c 4a                	jl     d9a <balancer_ingress+0xd9a>
     d50:	05 14 06 03 99       	add    $0x99030614,%eax
     d55:	03 2e                	add    (%rsi),%ebp
  if (decap_dst_flags) {
     d57:	05 1e 06 74 05       	add    $0x574061e,%eax
  if (action >= 0) {
     d5c:	28 4a 05             	sub    %cl,0x5(%rdx)
     d5f:	1b 3c 05 32 2e 05 3c 	sbb    0x3c052e32(,%rax,1),%edi
     d66:	4a 05 2f 3c 05 45    	rex.WX add $0x45053c2f,%rax
     d6c:	2e 03 e7             	cs add %edi,%esp
     d6f:	7c 4a                	jl     dbb <balancer_ingress+0xdbb>
     d71:	04 00                	add    $0x0,%al
        bpf_map_lookup_elem(&stats, &xpop_stats_key);
     d73:	05 19 06 03 f1       	add    $0xf1030619,%eax
     d78:	06                   	(bad)
     d79:	66 05 0b 06          	add    $0x60b,%ax
     d7d:	2e 05 07 06 03 c7    	cs add $0xc7030607,%eax
        xpop_stats_data->v2 += 1; // IPv6 inner packets
     d83:	7d 66                	jge    deb <balancer_ingress+0xdeb>
     d85:	05 19 f3 06 03       	add    $0x306f319,%eax
     d8a:	c7                   	(bad)
     d8b:	7b 4a                	jnp    dd7 <balancer_ingress+0xdd7>
     d8d:	06                   	(bad)
     d8e:	03 bb 04 2e 06 03    	add    0x3062e04(%rbx),%edi
     d94:	c5 7b 4a             	(bad)
     d97:	06                   	(bad)
     d98:	03 bd 04 2e 06 03    	add    0x3062e04(%rbp),%edi
  bpf_tail_call(ctx, &subprograms, i);
     d9e:	c3                   	ret
     d9f:	7b 4a                	jnp    deb <balancer_ingress+0xdeb>
     da1:	06                   	(bad)
     da2:	03 bf 04 2e 05 00    	add    0x52e04(%rdi),%edi
     da8:	06                   	(bad)
     da9:	03 c1                	add    %ecx,%eax
     dab:	7b 4a                	jnp    df7 <balancer_ingress+0xdf7>
     dad:	05 1b 06 03 f6       	add    $0xf603061b,%eax
     db2:	06                   	(bad)
     db3:	3c 05                	cmp    $0x5,%al
     db5:	0d 67 06 03 89       	or     $0x89030667,%eax
  udp = data + off;
     dba:	79 2e                	jns    dea <balancer_ingress+0xdea>
     dbc:	03 f7                	add    %edi,%esi
  if (is_ipv6) {
     dbe:	06                   	(bad)
  udp = data + off;
     dbf:	d6                   	(bad)
     dc0:	05 11 06 5a 05       	add    $0x55a0611,%eax
  if (udp + 1 > data_end) {
     dc5:	0f 59 05 1d 35 05 13 	mulps  0x1305351d(%rip),%xmm0        # 130542e9 <_license+0x13051f54>
     dcc:	4b 05 11 67 06 03    	rex.WXB add $0x3066711,%rax
     dd2:	fd                   	std
     dd3:	78 66                	js     e3b <balancer_ingress+0xe3b>
     dd5:	03 83 07 08 20 03    	add    0x3200807(%rbx),%eax
     ddb:	fd                   	std
     ddc:	78 90                	js     d6e <balancer_ingress+0xd6e>
     dde:	04 06                	add    $0x6,%al
     de0:	05 01 06 03 9a       	add    $0x9a030601,%eax
     de5:	03 3c 04             	add    (%rsp,%rax,1),%edi
     de8:	00 05 07 03 d1 01    	add    %al,0x1d10307(%rip)        # 1d110f5 <_license+0x1d0ed60>
     dee:	ac                   	lods   %ds:(%rsi),%al
     def:	06                   	(bad)
     df0:	3c 05                	cmp    $0x5,%al
     df2:	1f                   	(bad)
     df3:	06                   	(bad)
     df4:	67 05 16 06 4a 05    	addr32 add $0x54a0616,%eax
    vip.vip = pckt.flow.dst;
     dfa:	09 2e                	or     %ebp,(%rsi)
     dfc:	05 23 06 03 a0       	add    $0xa0030623,%eax
  vip.port = pckt.flow.port16[1];
     e01:	02 66 05             	add    0x5(%rsi),%ah
     e04:	00 06                	add    %al,(%rsi)
  vip.proto = pckt.flow.proto;
     e06:	03 f4                	add    %esp,%esi
     e08:	78 ba                	js     dc4 <balancer_ingress+0xdc4>
     e0a:	05 14 06 03 b0       	add    $0xb0030614,%eax
     e0f:	07                   	(bad)
     e10:	08 2e                	or     %ch,(%rsi)
     e12:	05 1e 03 26 90       	add    $0x9026031e,%eax
     e17:	05 2b 06 9e 05       	add    $0x59e062b,%eax
     e1c:	1b 06                	sbb    (%rsi),%eax
     e1e:	2f                   	(bad)
     e1f:	05 09 3b 06 03       	add    $0x3063b09,%eax
  if (!vip_info) {
     e24:	aa                   	stos   %al,%es:(%rdi)
     e25:	78 2e                	js     e55 <balancer_ingress+0xe55>
     e27:	04 06                	add    $0x6,%al
     e29:	05 01 06 03 9a       	add    $0x9a030601,%eax
  if (data_end - data > MAX_PCKT_SIZE) {
     e2e:	03 66 04             	add    0x4(%rsi),%esp
     e31:	00 05 08 03 9f 7e    	add    %al,0x7e9f0308(%rip)        # 7e9f113f <_license+0x7e9eedaa>
     e37:	ac                   	lods   %ds:(%rsi),%al
     e38:	05 07 06 3c 05       	add    $0x53c0607,%eax
     e3d:	00 03                	add    %al,(%rbx)
     e3f:	c7                   	(bad)
     e40:	7e 2e                	jle    e70 <balancer_ingress+0xe70>
     e42:	05 28 06 03 bc       	add    $0xbc030628,%eax
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     e47:	01 3c 05 07 06 58 03 	add    %edi,0x3580607(,%rax,1)
     e4e:	c4                   	(bad)
     e4f:	7e 2e                	jle    e7f <balancer_ingress+0xe7f>
     e51:	05 10 06 03 bd       	add    $0xbd030610,%eax
  if (!data_stats) {
     e56:	01 74 05 12          	add    %esi,0x12(%rbp,%rax,1)
     e5a:	2f                   	(bad)
     e5b:	05 23 06 08 12       	add    $0x12080623,%eax
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     e60:	05 09 3c 03 c2       	add    $0xc2033c09,%eax
    pckt.flow.port16[0] = 0;
     e65:	7e 2e                	jle    e95 <balancer_ingress+0xe95>
     e67:	05 14 06 03 c1       	add    $0xc1030614,%eax
  vip_num = vip_info->vip_num;
     e6c:	01 9e 05 12 4c 06    	add    %ebx,0x64c1205(%rsi)
     e72:	03 bd 7e 3c 03 c3    	add    -0x3cfcc382(%rbp),%edi
  __u32 cpu_num = bpf_get_smp_processor_id();
     e78:	01 3c 05 14 06 67 05 	add    %edi,0x5670614(,%rax,1)
     e7f:	0b 4b 06             	or     0x6(%rbx),%ecx
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     e82:	03 bb 7e 4a 03 c5    	add    -0x3afcb582(%rbx),%edi
     e88:	01 9e 03 bb 7e 82    	add    %ebx,-0x7d8144fd(%rsi)
     e8e:	05 1f 06 03 92       	add    $0x9203061f,%eax
     e93:	05 66 05 2e 06       	add    $0x62e0566,%eax
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     e98:	58                   	pop    %rax
     e99:	05 17 06 67 05       	add    $0x5670617,%eax
     e9e:	2e 06                	cs (bad)
     ea0:	4a 03 ed             	rex.WX add %rbp,%rbp
     ea3:	7a 66                	jp     f0b <balancer_ingress+0xf0b>
    if (!lru_stats) {
     ea5:	05 07 06 03 2a       	add    $0x2a030607,%eax
     eaa:	9e                   	sahf
     eab:	05 08 bb 05 07       	add    $0x705bb08,%eax
    lru_stats->v1 += 1;
     eb0:	06                   	(bad)
     eb1:	3c 03                	cmp    $0x3,%al
     eb3:	55                   	push   %rbp
     eb4:	66 05 0f 06          	add    $0x60f,%ax
     eb8:	03 2e                	add    (%rsi),%ebp
     eba:	c8 05 12 32          	enter  $0x1205,$0x32
     ebe:	05 29 06 74 05       	add    $0x5740629,%eax
     ec3:	07                   	(bad)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     ec4:	74 05                	je     ecb <balancer_ingress+0xecb>
     ec6:	19 06                	sbb    %eax,(%rsi)
     ec8:	30 75 68             	xor    %dh,0x68(%rbp)
     ecb:	05 1d 91 05 09       	add    $0x905911d,%eax
     ed0:	06                   	(bad)
     ed1:	ba 04 06 05 01       	mov    $0x1050604,%edx
  if (!lru_map) {
     ed6:	06                   	(bad)
     ed7:	03 e2                	add    %edx,%esp
     ed9:	02 2e                	add    (%rsi),%ch
     edb:	06                   	(bad)
     edc:	03 e6                	add    %esi,%esp
  if ((vip_info->flags & F_QUIC_VIP)) {
     ede:	7c 08                	jl     ee8 <balancer_ingress+0xee8>
     ee0:	4a 03 9a 03 3c 03 e6 	rex.WX add -0x19fcc3fd(%rdx),%rbx
    bool is_icmp = (pckt.flags & F_ICMP);
     ee7:	7c 3c                	jl     f25 <balancer_ingress+0xf25>
     ee9:	04 00                	add    $0x0,%al
     eeb:	05 09 06 03 96       	add    $0x96030609,%eax
    if (is_icmp) {
     ef0:	05 3c 06 3c 05       	add    $0x53c063c,%eax
     ef5:	19 06                	sbb    %eax,(%rsi)
     ef7:	2f                   	(bad)
     ef8:	04 06                	add    $0x6,%al
     efa:	05 01 03 83 7e       	add    $0x7e830301,%eax
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     eff:	58                   	pop    %rax
     f00:	06                   	(bad)
     f01:	03 e6                	add    %esi,%esp
     f03:	7c 66                	jl     f6b <balancer_ingress+0xf6b>
     f05:	03 9a 03 3c 03 e6    	add    -0x19fcc3fd(%rdx),%ebx
      if (!quic_packets_stats) {
     f0b:	7c 3c                	jl     f49 <balancer_ingress+0xf49>
     f0d:	04 00                	add    $0x0,%al
     f0f:	05 0b 06 03 98       	add    $0x9803060b,%eax
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     f14:	05 3c 06 3c 03       	add    $0x33c063c,%eax
  bool is_icmp = (pckt->flags & F_ICMP);
     f19:	e8 7a 2e 05 27       	call   27053d98 <_license+0x27051a03>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     f1e:	06                   	(bad)
     f1f:	03 9d 05 9e 05 0d    	add    0xd059e05(%rbp),%ebx
     f25:	bb 06 3c 05 1a       	mov    $0x1a053c06,%ebx
     f2a:	06                   	(bad)
     f2b:	67 05 0a 03 c9 02    	addr32 add $0x2c9030a,%eax
     f31:	82                   	(bad)
     f32:	05 09 06 3c 05       	add    $0x53c0609,%eax
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     f37:	10 06                	adc    %al,(%rsi)
     f39:	03 27                	add    (%rdi),%esp
     f3b:	66 06                	data16 (bad)
     f3d:	66 03 f1             	add    %cx,%si
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     f40:	77 66                	ja     fa8 <balancer_ingress+0xfa8>
     f42:	03 8f 08 9e 05 08    	add    0x8059e08(%rdi),%ecx
     f48:	06                   	(bad)
     f49:	c9                   	leave
     f4a:	05 07 06 3c 03       	add    $0x33c0607,%eax
  if (!connId) {
     f4f:	f0 77 66             	lock ja fb8 <balancer_ingress+0xfb8>
     f52:	05 12 06 03 93       	add    $0x93030612,%eax
  __u8 connIdVersion = (connId[0] >> 6);
     f57:	08 58 05             	or     %bl,0x5(%rax)
     f5a:	15 3d 05 12 06       	adc    $0x612053d,%eax
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     f5f:	4a 05 10 06 4d 06    	rex.WX add $0x64d0610,%rax
     f65:	03 e9                	add    %ecx,%ebp
     f67:	77 08                	ja     f71 <balancer_ingress+0xf71>
     f69:	12 03                	adc    (%rbx),%al
     f6b:	97                   	xchg   %eax,%edi
     f6c:	08 9e 05 08 06 c9    	or     %bl,-0x36f9f7fb(%rsi)
     f72:	05 07 06 3c 05       	add    $0x53c0607,%eax
     f77:	12 06                	adc    (%rsi),%al
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     f79:	69 3d 05 17 89 05 12 	imul   $0x7055912,0x5891705(%rip),%edi        # 5892688 <_license+0x58902f3>
     f80:	59 05 07 
     f83:	06                   	(bad)
     f84:	58                   	pop    %rax
     f85:	04 11                	add    $0x11,%al
     f87:	05 49 06 03 bf       	add    $0xbf030649,%eax
     f8c:	78 66                	js     ff4 <balancer_ingress+0xff4>
     f8e:	06                   	(bad)
     f8f:	03 9d 7f 58 05 07    	add    0x705587f(%rbp),%ebx
    vip.port = 0;
     f95:	06                   	(bad)
     f96:	03 e6                	add    %esi,%esp
     f98:	00 ba 06 90 03 9a    	add    %bh,-0x65fc6ffa(%rdx)
     f9e:	7f 66                	jg     1006 <balancer_ingress+0x1006>
     fa0:	05 1c 06 03 e9       	add    $0xe903061c,%eax
     fa5:	00 58 05             	add    %bl,0x5(%rax)
     fa8:	20 3d 05 0e 4c 05    	and    %bh,0x54c0e05(%rip)        # 54c1db3 <_license+0x54bfa1e>
    if (!vip_info) {
     fae:	13 4c 05 1e          	adc    0x1e(%rbp,%rax,1),%ecx
     fb2:	06                   	(bad)
     fb3:	3c 03                	cmp    $0x3,%al
     fb5:	92                   	xchg   %eax,%edx
     fb6:	7f 66                	jg     101e <balancer_ingress+0x101e>
     fb8:	03 ee                	add    %esi,%ebp
     fba:	00 90 03 92 7f 90    	add    %dl,-0x6f806dfd(%rax)
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     fc0:	05 03 06 03 f1       	add    $0xf1030603,%eax
      pckt.flow.port16[1] = 0;
     fc5:	00 08                	add    %cl,(%rax)
     fc7:	ba 08 4b 05 14       	mov    $0x14054b08,%edx
     fcc:	d7                   	xlat   %ds:(%rbx)
     fcd:	05 1c 68 04 12       	add    $0x1204681c,%eax
     fd2:	05 0c 03 45 90       	add    $0x9045030c,%eax
     fd7:	05 12 03 09 4a       	add    $0x4a090312,%eax
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     fdc:	05 0c 8c 05 10       	add    $0x10058c0c,%eax
     fe1:	4e 05 0b 59 05 0e    	rex.WRX add $0xe05590b,%rax
      if (!data_stats) {
     fe7:	75 3d                	jne    1026 <balancer_ingress+0x1026>
     fe9:	05 0c 3d 04 0f       	add    $0xf043d0c,%eax
     fee:	05 0e 03 71 66       	add    $0x6671030e,%eax
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     ff3:	05 0b 06 ba 05       	add    $0x5ba060b,%eax
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     ff8:	0e                   	(bad)
     ff9:	3c 05                	cmp    $0x5,%al
     ffb:	0b 3c 05 0e 3c 05 0b 	or     0xb053c0e(,%rax,1),%edi
    1002:	3c 04                	cmp    $0x4,%al
        data_stats->v2 += 1;
    1004:	00 05 1b 06 03 b1    	add    %al,-0x4efcf9e5(%rip)        # ffffffffb1031625 <server_id_map+0x36ff98948625>
    100a:	07                   	(bad)
    100b:	82                   	(bad)
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
    100c:	05 0b 06 58 03       	add    $0x358060b,%eax
    1011:	97                   	xchg   %eax,%edi
    1012:	78 2e                	js     1042 <balancer_ingress+0x1042>
    1014:	05 0d 06 03 ec       	add    $0xec03060d,%eax
    1019:	07                   	(bad)
    101a:	9e                   	sahf
    101b:	05 0e bb 05 0d       	add    $0xd05bb0e,%eax
    1020:	06                   	(bad)
    1021:	3c 05                	cmp    $0x5,%al
  if (!lru_map) {
    1023:	18 06                	sbb    %al,(%rsi)
    1025:	69 05 00 06 03 90 78 	imul   $0x17059e78,-0x6ffcfa00(%rip),%eax        # ffffffff9003162f <server_id_map+0x36ff7794862f>
    102c:	9e 05 17 
    102f:	06                   	(bad)
  if ((vip_info->flags & F_QUIC_VIP)) {
    1030:	03 de                	add    %esi,%ebx
    1032:	00 90 05 07 03 4c    	add    %dl,0x4c030705(%rax)
    1038:	08 9e 06 03 56 ba    	or     %bl,-0x45a9fcfa(%rsi)
    bool is_icmp = (pckt.flags & F_ICMP);
    103e:	05 08 06 03 2b       	add    $0x2b030608,%eax
    if (is_icmp) {
    1043:	2e 05 07 06 3c 03    	cs add $0x33c0607,%eax
    1049:	55                   	push   %rbp
    104a:	2e 05 0f 06 03 2e    	cs add $0x2e03060f,%eax
    1050:	9e                   	sahf
    1051:	05 12 5c 05 29       	add    $0x29055c12,%eax
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
    1056:	06                   	(bad)
    1057:	4a 05 07 66 05 19    	rex.WX add $0x19056607,%rax
    105d:	06                   	(bad)
    105e:	30 83 06 03 4b 66    	xor    %al,0x664b0306(%rbx)
      if (!quic_packets_stats) {
    1064:	06                   	(bad)
    1065:	03 37                	add    (%rdi),%esi
    1067:	58                   	pop    %rax
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1068:	05 1d ad 05 09       	add    $0x905ad1d,%eax
  bool is_icmp = (pckt->flags & F_ICMP);
    106d:	06                   	(bad)
    106e:	66 03 48 2e          	add    0x2e(%rax),%cx
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
    1072:	05 19 06 03 88       	add    $0x88030619,%eax
    1077:	01 82 05 09 06 3c    	add    %eax,0x3c060905(%rdx)
    107d:	05 1e 06 32 05       	add    $0x532061e,%eax
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
    1082:	1c 06                	sbb    $0x6,%al
    1084:	58                   	pop    %rax
    1085:	05 07 06 59 05       	add    $0x5590607,%eax
    108a:	09 03                	or     %eax,(%rbx)
    108c:	91                   	xchg   %eax,%ecx
    108d:	7f 08                	jg     1097 <balancer_ingress+0x1097>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
    108f:	20 05 14 08 13 05    	and    %al,0x5130814(%rip)        # 51318a9 <_license+0x512f514>
    1095:	0c 48                	or     $0x48,%al
    1097:	05 30 03 f2 00       	add    $0xf20330,%eax
  if (!connId) {
    109c:	d6                   	(bad)
    109d:	06                   	(bad)
    109e:	03 f1                	add    %ecx,%esi
    10a0:	7e 08                	jle    10aa <balancer_ingress+0x10aa>
    10a2:	74 05                	je     10a9 <balancer_ingress+0x10a9>
    10a4:	22 06                	and    (%rsi),%al
  __u8 connIdVersion = (connId[0] >> 6);
    10a6:	03 90 01 3c 05 15    	add    0x15053c01(%rax),%edx
    10ac:	06                   	(bad)
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
    10ad:	4a 05 2b 58 05 10    	rex.WX add $0x1005582b,%rax
    10b3:	06                   	(bad)
    10b4:	30 05 09 59 06 03    	xor    %al,0x3065909(%rip)        # 30669c3 <_license+0x306462e>
    10ba:	ed                   	in     (%dx),%eax
    10bb:	7e 66                	jle    1123 <balancer_ingress+0x1123>
    10bd:	03 93 01 d6 05 0b    	add    0xb05d601(%rbx),%edx
    10c3:	06                   	(bad)
    10c4:	93                   	xchg   %eax,%ebx
    10c5:	05 09 59 05 14       	add    $0x14055909,%eax
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
    10ca:	6d                   	insl   (%dx),%es:(%rdi)
    10cb:	05 0b 4b 05 07       	add    $0x7054b0b,%eax
    10d0:	59                   	pop    %rcx
    10d1:	06                   	(bad)
    10d2:	03 e0                	add    %eax,%esp
    10d4:	7e 66                	jle    113c <balancer_ingress+0x113c>
    10d6:	03 a0 01 08 20 05    	add    0x5200801(%rax),%esp
    10dc:	24 06                	and    $0x6,%al
    10de:	96                   	xchg   %eax,%esi
    10df:	05 34 06 90 05       	add    $0x5900634,%eax
    10e4:	1a 06                	sbb    (%rsi),%al
    10e6:	4b 05 09 06 58 05    	rex.WXB add $0x5580609,%rax
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
    10ec:	19 06                	sbb    %eax,(%rsi)
    10ee:	2f                   	(bad)
    10ef:	05 15 5a 06 03       	add    $0x3065a15,%eax
    10f4:	d6                   	(bad)
    10f5:	7e 3c                	jle    1133 <balancer_ingress+0x1133>
      if (!data_stats) {
    10f7:	04 06                	add    $0x6,%al
    10f9:	05 01 06 03 9f       	add    $0x9f030601,%eax
    10fe:	03 58 06             	add    0x6(%rax),%ebx
      data_stats->v1 += 1;
    1101:	03 e1                	add    %ecx,%esp
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
    1103:	7c 3c                	jl     1141 <balancer_ingress+0x1141>
    1105:	03 9f 03 82 03 e1    	add    -0x1efc7dfd(%rdi),%ebx
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
    110b:	7c 58                	jl     1165 <balancer_ingress+0x1165>
    110d:	04 00                	add    $0x0,%al
    110f:	05 1a 06 03 d0       	add    $0xd003061a,%eax
    1114:	04 9e                	add    $0x9e,%al
    1116:	05 36 06 4a 05       	add    $0x54a0636,%eax
        data_stats->v2 += 1;
    111b:	47                   	rex.RXB
    111c:	4a 03 b0 7b 2e 05 1a 	rex.WX add 0x1a052e7b(%rax),%rsi
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1123:	06                   	(bad)
    1124:	03 d1                	add    %ecx,%edx
    1126:	04 9e                	add    $0x9e,%al
    1128:	05 36 06 2e 05       	add    $0x52e0636,%eax
    112d:	47                   	rex.RXB
    112e:	4a 03 af 7b 2e 05 1a 	rex.WX add 0x1a052e7b(%rdi),%rbp
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1135:	06                   	(bad)
    1136:	03 d2                	add    %edx,%edx
        quic_packets_stats->cid_initial += 1;
    1138:	04 9e                	add    $0x9e,%al
    113a:	05 36 06 2e 05       	add    $0x52e0636,%eax
    113f:	47                   	rex.RXB
    1140:	4a 03 ae 7b 2e 05 1a 	rex.WX add 0x1a052e7b(%rsi),%rbp
    1147:	06                   	(bad)
    1148:	03 d3                	add    %ebx,%edx
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    114a:	04 9e                	add    $0x9e,%al
    114c:	05 36 06 2e 03       	add    $0x32e0636,%eax
    1151:	ad                   	lods   %ds:(%rsi),%eax
    1152:	7b 74                	jnp    11c8 <balancer_ingress+0x11c8>
    1154:	05 28 06 03 d5       	add    $0xd5030628,%eax
    1159:	04 9e                	add    $0x9e,%al
    115b:	05 35 06 3c 05       	add    $0x53c0635,%eax
    1160:	36 06                	ss (bad)
    1162:	59                   	pop    %rcx
    1163:	05 2f 06 e4 05       	add    $0x5e4062f,%eax
  if (!per_vip_stats) {
    1168:	22 06                	and    (%rsi),%al
    116a:	2f                   	(bad)
    116b:	05 21 ca 05 1c       	add    $0x1c05ca21,%eax
    1170:	9f                   	lahf
    1171:	06                   	(bad)
    1172:	03 a6 7b 66 03 da    	add    -0x25fc9985(%rsi),%esp
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
    1178:	04 9e                	add    $0x9e,%al
    117a:	05 0a 06 c9 05       	add    $0x5c9060a,%eax
    117f:	09 06                	or     %eax,(%rsi)
    1181:	3c 05                	cmp    $0x5,%al
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
    1183:	14 06                	adc    $0x6,%al
    1185:	69 05 16 03 a7 03 2e 	imul   $0x310052e,0x3a70316(%rip),%eax        # 3a714a5 <_license+0x3a6f110>
    118c:	05 10 03 
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    118f:	0a 90 06 66 03 f1    	or     -0xefc99fa(%rax),%dl
    1195:	77 ac                	ja     1143 <balancer_ingress+0x1143>
    1197:	05 07 06 03 d0       	add    $0xd0030607,%eax
    119c:	00 9e 05 08 bb 06    	add    %bl,0x6bb0805(%rsi)
    11a2:	03 af 7f d6 05 07    	add    0x705d67f(%rdi),%ebp
    11a8:	06                   	(bad)
    11a9:	03 c5                	add    %ebp,%eax
    11ab:	00 9e 05 08 bb 05    	add    %bl,0x5bb0805(%rsi)
    11b1:	07                   	(bad)
    11b2:	06                   	(bad)
    11b3:	3c 03                	cmp    $0x3,%al
    11b5:	ba 7f ac 04 11       	mov    $0x1104ac7f,%edx
    11ba:	06                   	(bad)
    11bb:	03 3a                	add    (%rdx),%edi
  if (!per_vip_stats) {
    11bd:	ba 06 90 03 46       	mov    $0x46039006,%edx
    11c2:	66 05 1c 06          	add    $0x61c,%ax
    11c6:	03 3d 58 05 20 3d    	add    0x3d200558(%rip),%edi        # 3d201724 <_license+0x3d1ff38f>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    11cc:	05 0f 4c 05 13       	add    $0x13054c0f,%eax
    11d1:	4c 05 1e 06 3c 03    	rex.WR add $0x33c061e,%rax
    11d7:	be 7f 66 03 c2       	mov    $0xc203667f,%esi
    11dc:	00 90 03 be 7f 90    	add    %dl,-0x6f8041fd(%rax)
  if (!connId) {
    11e2:	05 03 06 03 c5       	add    $0xc5030603,%eax
    11e7:	00 9e 08 4b 05 14    	add    %bl,0x14054b08(%rsi)
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    11ed:	d7                   	xlat   %ds:(%rbx)
    11ee:	05 1b 6a 04 12       	add    $0x12046a1b,%eax
    11f3:	05 12 03 5a 58       	add    $0x585a0312,%eax
    11f8:	04 11                	add    $0x11,%al
    11fa:	05 1d 03 27 4a       	add    $0x4a27031d,%eax
    11ff:	51                   	push   %rcx
    1200:	04 12                	add    $0x12,%al
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1202:	05 03 59 05 12       	add    $0x12055903,%eax
    1207:	bc 05 23 83 05       	mov    $0x5832305,%esp
    120c:	15 06 3c 05 11       	adc    $0x11053c06,%eax
    1211:	06                   	(bad)
    1212:	40 05 17 67 05 15    	rex add $0x15056717,%eax
    1218:	06                   	(bad)
    1219:	58                   	pop    %rax
    121a:	04 0c                	add    $0xc,%al
    121c:	05 23 06 03 a1       	add    $0xa1030623,%eax
    1221:	02 9e 06 03 83 7d    	add    0x7d830306(%rsi),%bl
      if (qpr.server_id > 0) {
    1227:	58                   	pop    %rax
    1228:	05 08 06 03 88       	add    $0x88030608,%eax
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    122d:	03 c8                	add    %eax,%ecx
    122f:	05 07 06 3c 05       	add    $0x53c0607,%eax
    1234:	19 06                	sbb    %eax,(%rsi)
    1236:	03 0d ac 05 23 06    	add    0x62305ac(%rip),%ecx        # 62317e8 <_license+0x622f453>
    quic_packets_stats->cid_v1 += 1;
    123c:	4a 05 2d 3c 05 37    	rex.WX add $0x37053c2d,%rax
    quic_packets_stats->cid_v2 += 1;
    1242:	4a 05 2a 3c 05 40    	rex.WX add $0x40053c2a,%rax
    quic_packets_stats->cid_v3 += 1;
    1248:	2e 03 eb             	cs add %ebx,%ebp
    124b:	7c 4a                	jl     1297 <balancer_ingress+0x1297>
    124d:	05 14 06 03 99       	add    $0x99030614,%eax
    1252:	03 2e                	add    (%rsi),%ebp
    1254:	05 1e 06 74 05       	add    $0x574061e,%eax
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1259:	28 4a 05             	sub    %cl,0x5(%rdx)
        if (real_pos) {
    125c:	1b 3c 05 32 2e 05 3c 	sbb    0x3c052e32(,%rax,1),%edi
    1263:	4a 05 2f 3c 05 45    	rex.WX add $0x45053c2f,%rax
    1269:	2e 03 e7             	cs add %edi,%esp
    126c:	7c 4a                	jl     12b8 <balancer_ingress+0x12b8>
    126e:	04 00                	add    $0x0,%al
          key = *real_pos;
    1270:	05 19 06 03 f1       	add    $0xf1030619,%eax
          if (key == 0) {
    1275:	06                   	(bad)
    1276:	66 05 0b 06          	add    $0x60b,%ax
            pckt.real_index = key;
    127a:	2e 05 07 06 03 c7    	cs add $0xc7030607,%eax
            dst = bpf_map_lookup_elem(&reals, &key);
    1280:	7d 66                	jge    12e8 <balancer_ingress+0x12e8>
            if (!dst) {
    1282:	05 19 f3 06 03       	add    $0x306f319,%eax
    1287:	c7                   	(bad)
    1288:	7b 4a                	jnp    12d4 <balancer_ingress+0x12d4>
    128a:	06                   	(bad)
    128b:	03 bb 04 2e 06 03    	add    0x3062e04(%rbx),%edi
    1291:	c5 7b 4a             	(bad)
    1294:	06                   	(bad)
    1295:	03 bd 04 2e 06 03    	add    0x3062e04(%rbp),%edi
    129b:	c3                   	ret
    129c:	7b 4a                	jnp    12e8 <balancer_ingress+0x12e8>
    129e:	06                   	(bad)
    129f:	03 bf 04 2e 05 00    	add    0x52e04(%rdi),%edi
    12a5:	06                   	(bad)
    12a6:	03 c1                	add    %ecx,%eax
    12a8:	7b 4a                	jnp    12f4 <balancer_ingress+0x12f4>
    12aa:	05 1b 06 03 f6       	add    $0xf603061b,%eax
    12af:	06                   	(bad)
  if (dst_lru) {
    12b0:	3c 05                	cmp    $0x5,%al
    12b2:	0d 67 06 03 89       	or     $0x89030667,%eax
    12b7:	79 2e                	jns    12e7 <balancer_ingress+0x12e7>
    if (dst_lru->pos == pckt->real_index) {
    12b9:	03 f7                	add    %edi,%esi
    12bb:	06                   	(bad)
    12bc:	d6                   	(bad)
    12bd:	05 11 06 5a 05       	add    $0x55a0611,%eax
    12c2:	0f 59 05 1d 35 05 13 	mulps  0x1305351d(%rip),%xmm0        # 130547e6 <_license+0x13052451>
              quic_packets_stats->dst_match_in_lru += 1;
    12c9:	4b 05 11 59 06 03    	rex.WXB add $0x3065911,%rax
    12cf:	fd                   	std
    12d0:	78 2e                	js     1300 <balancer_ingress+0x1300>
    12d2:	03 83 07 08 20 03    	add    0x3200807(%rbx),%eax
    12d8:	fd                   	std
    12d9:	78 58                	js     1333 <balancer_ingress+0x1333>
    12db:	04 06                	add    $0x6,%al
    12dd:	05 01 06 03 9a       	add    $0x9a030601,%eax
    12e2:	03 58 04             	add    0x4(%rax),%ebx
  original_sport = pckt.flow.port16[0];
    12e5:	00 05 07 03 d1 01    	add    %al,0x1d10307(%rip)        # 1d115f2 <_license+0x1d0f25d>
    12eb:	ac                   	lods   %ds:(%rsi),%al
    12ec:	06                   	(bad)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    12ed:	3c 05                	cmp    $0x5,%al
    12ef:	1f                   	(bad)
    12f0:	06                   	(bad)
    12f1:	67 05 16 06 4a 05    	addr32 add $0x54a0616,%eax
    12f7:	09 2e                	or     %ebp,(%rsi)
        !(vip_info->flags & F_LRU_BYPASS)) {
    12f9:	05 23 06 03 a0       	add    $0xa0030623,%eax
    12fe:	02 66 05             	add    0x5(%rsi),%ah
    1301:	3c 03                	cmp    $0x3,%al
    1303:	79 ba                	jns    12bf <balancer_ingress+0x12bf>
    1305:	05 00 06 03 fb       	add    $0xfb030600,%eax
    130a:	78 90                	js     129c <balancer_ingress+0x129c>
    130c:	05 14 06 03 b0       	add    $0xb0030614,%eax
  if (!dst_lru) {
    1311:	07                   	(bad)
    1312:	f2 05 1e 03 26 ba    	repnz add $0xba26031e,%eax
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    1318:	05 2b 06 58 05       	add    $0x558062b,%eax
    131d:	1b 06                	sbb    (%rsi),%eax
    131f:	2f                   	(bad)
    1320:	05 09 3b 06 03       	add    $0x3063b09,%eax
    cur_time = bpf_ktime_get_ns();
    1325:	aa                   	stos   %al,%es:(%rdi)
    1326:	78 2e                	js     1356 <balancer_ingress+0x1356>
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    1328:	04 06                	add    $0x6,%al
    132a:	05 01 06 03 9a       	add    $0x9a030601,%eax
    132f:	03 58 04             	add    0x4(%rax),%ebx
    1332:	00 05 08 03 9f 7e    	add    %al,0x7e9f0308(%rip)        # 7e9f1640 <_license+0x7e9ef2ab>
    1338:	ac                   	lods   %ds:(%rsi),%al
    1339:	05 07 06 3c 05       	add    $0x53c0607,%eax
    133e:	00 03                	add    %al,(%rbx)
    1340:	c7                   	(bad)
    1341:	7e 2e                	jle    1371 <balancer_ingress+0x1371>
    1343:	05 28 06 03 bc       	add    $0xbc030628,%eax
    dst_lru->atime = cur_time;
    1348:	01 3c 05 07 06 58 03 	add    %edi,0x3580607(,%rax,1)
    134f:	c4                   	(bad)
    1350:	7e 2e                	jle    1380 <balancer_ingress+0x1380>
  key = dst_lru->pos;
    1352:	05 10 06 03 bd       	add    $0xbd030610,%eax
  pckt->real_index = key;
    1357:	01 74 05 12          	add    %esi,0x12(%rbp,%rax,1)
  *real = bpf_map_lookup_elem(&reals, &key);
    135b:	2f                   	(bad)
    135c:	05 23 06 08 12       	add    $0x12080623,%eax
    1361:	05 09 3c 03 c2       	add    $0xc2033c09,%eax
    1366:	7e 2e                	jle    1396 <balancer_ingress+0x1396>
    1368:	05 14 06 03 c1       	add    $0xc1030614,%eax
    136d:	01 9e 05 12 4c 06    	add    %ebx,0x64c1205(%rsi)
    1373:	03 bd 7e 3c 03 c3    	add    -0x3cfcc382(%rbp),%edi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1379:	01 3c 05 14 06 67 05 	add    %edi,0x5670614(,%rax,1)
    1380:	0b 4b 06             	or     0x6(%rbx),%ecx
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    1383:	03 bb 7e 4a 03 c5    	add    -0x3afcb582(%rbx),%edi
    1389:	01 9e 03 bb 7e 82    	add    %ebx,-0x7d8144fd(%rsi)
    138f:	05 1f 06 03 92       	add    $0x9203061f,%eax
    1394:	05 58 05 2e 06       	add    $0x62e0558,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1399:	58                   	pop    %rax
    139a:	05 17 06 67 05       	add    $0x5670617,%eax
    139f:	2e 06                	cs (bad)
    13a1:	4a 03 ed             	rex.WX add %rbp,%rbp
  if (!conn_rate_stats) {
    13a4:	7a 66                	jp     140c <balancer_ingress+0x140c>
    13a6:	05 07 06 03 2a       	add    $0x2a030607,%eax
    13ab:	9e                   	sahf
    13ac:	05 08 bb 05 07       	add    $0x705bb08,%eax
    13b1:	06                   	(bad)
    13b2:	3c 03                	cmp    $0x3,%al
    13b4:	55                   	push   %rbp
    13b5:	66 05 0f 06          	add    $0x60f,%ax
  *cur_time = bpf_ktime_get_ns();
    13b9:	03 2e                	add    (%rsi),%ebp
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    13bb:	74 05                	je     13c2 <balancer_ingress+0x13c2>
    13bd:	12 32                	adc    (%rdx),%dh
    13bf:	05 29 06 74 05       	add    $0x5740629,%eax
    13c4:	07                   	(bad)
    13c5:	74 05                	je     13cc <balancer_ingress+0x13cc>
    13c7:	19 06                	sbb    %eax,(%rsi)
    13c9:	30 75 68             	xor    %dh,0x68(%rbp)
    conn_rate_stats->v1 = 1;
    13cc:	05 1d 91 05 09       	add    $0x905911d,%eax
    conn_rate_stats->v2 = *cur_time;
    13d1:	06                   	(bad)
    13d2:	66 04 06             	data16 add $0x6,%al
    13d5:	05 01 06 03 e2       	add    $0xe2030601,%eax
    conn_rate_stats->v1 += 1;
    13da:	02 2e                	add    (%rsi),%ch
    13dc:	04 00                	add    $0x0,%al
    13de:	05 09 03 fc 01       	add    $0x1fc0309,%eax
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    13e3:	08 4a 06             	or     %cl,0x6(%rdx)
    13e6:	3c 05                	cmp    $0x5,%al
    13e8:	19 06                	sbb    %eax,(%rsi)
    13ea:	2f                   	(bad)
    13eb:	04 06                	add    $0x6,%al
    13ed:	05 01 03 83 7e       	add    $0x7e830301,%eax
    13f2:	58                   	pop    %rax
    13f3:	04 00                	add    $0x0,%al
    13f5:	05 0b 03 fe 01       	add    $0x1fe030b,%eax
    13fa:	90                   	nop
    13fb:	06                   	(bad)
    13fc:	3c 03                	cmp    $0x3,%al
    13fe:	e8 7a 2e 05 27       	call   2705427d <_license+0x27051ee8>
    1403:	06                   	(bad)
    1404:	03 9d 05 9e 05 0d    	add    0xd059e05(%rbp),%ebx
    140a:	bb 06 3c 05 1a       	mov    $0x1a053c06,%ebx
    if (down_reals_map) {
    140f:	06                   	(bad)
    1410:	67 05 0a 03 c9 02    	addr32 add $0x2c9030a,%eax
    1416:	82                   	(bad)
    1417:	05 09 06 3c 03       	add    $0x33c0609,%eax
    141c:	98                   	cwtl
    141d:	78 66                	js     1485 <balancer_ingress+0x1485>
    141f:	05 10 06 03 8f       	add    $0x8f030610,%eax
    1424:	08 58 06             	or     %bl,0x6(%rax)
      if (down_real) {
    1427:	66 03 f1             	add    %cx,%si
    142a:	77 66                	ja     1492 <balancer_ingress+0x1492>
    142c:	03 8f 08 9e 05 08    	add    0x8059e08(%rdi),%ecx
    1432:	06                   	(bad)
    1433:	c9                   	leave
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1434:	05 07 06 3c 03       	add    $0x33c0607,%eax
    1439:	f0 77 66             	lock ja 14a2 <balancer_ingress+0x14a2>
    143c:	05 12 06 03 93       	add    $0x93030612,%eax
        if (stats_data) {
    1441:	08 66 05             	or     %ah,0x5(%rsi)
    1444:	15 3d 05 12 06       	adc    $0x612053d,%eax
          stats_data->v1 += 1;
    1449:	3c 05                	cmp    $0x5,%al
    144b:	10 06                	adc    %al,(%rsi)
    144d:	4d 06                	rex.WRB (bad)
    144f:	03 e9                	add    %ecx,%ebp
    if (!dst) {
    1451:	77 08                	ja     145b <balancer_ingress+0x145b>
    1453:	12 03                	adc    (%rbx),%al
    1455:	97                   	xchg   %eax,%edi
    1456:	08 9e 05 08 06 c9    	or     %bl,-0x36f9f7fb(%rsi)
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    145c:	05 07 06 3c 05       	add    $0x53c0607,%eax
    1461:	12 06                	adc    (%rsi),%al
    1463:	69 3d 05 17 b3 05 12 	imul   $0x7055912,0x5b31705(%rip),%edi        # 5b32b72 <_license+0x5b307dd>
    146a:	59 05 07 
    146d:	06                   	(bad)
    146e:	58                   	pop    %rax
    146f:	04 11                	add    $0x11,%al
    1471:	05 49 06 03 bf       	add    $0xbf030649,%eax
    1476:	78 66                	js     14de <balancer_ingress+0x14de>
    1478:	06                   	(bad)
    1479:	03 9d 7f 66 05 07    	add    0x705667f(%rbp),%ebx
  if (!data_stats) {
    147f:	06                   	(bad)
    1480:	03 e6                	add    %esi,%esp
    1482:	00 ba 06 90 03 9a    	add    %bh,-0x65fc6ffa(%rdx)
    1488:	7f 66                	jg     14f0 <balancer_ingress+0x14f0>
    148a:	05 1c 06 03 e9       	add    $0xe903061c,%eax
  data_stats->v2 += pkt_bytes;
    148f:	00 58 05             	add    %bl,0x5(%rax)
    1492:	20 3d 05 0e 4c 05    	and    %bh,0x54c0e05(%rip)        # 54c229d <_license+0x54bff08>
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1498:	13 4c 05 1e          	adc    0x1e(%rbp,%rax,1),%ecx
    149c:	06                   	(bad)
    149d:	3c 03                	cmp    $0x3,%al
    149f:	92                   	xchg   %eax,%edx
    14a0:	7f 66                	jg     1508 <balancer_ingress+0x1508>
    14a2:	03 ee                	add    %esi,%ebp
    14a4:	00 90 03 92 7f 90    	add    %dl,-0x6f806dfd(%rax)
    14aa:	05 03 06 03 f1       	add    $0xf1030603,%eax
    14af:	00 02                	add    %al,(%rdx)
    14b1:	23 01                	and    (%rcx),%eax
    14b3:	08 4b 05             	or     %cl,0x5(%rbx)
    14b6:	14 d7                	adc    $0xd7,%al
    14b8:	05 1c 68 04 12       	add    $0x1204681c,%eax
    14bd:	05 0c 03 45 90       	add    $0x9045030c,%eax
  if (!data_stats) {
    14c2:	05 12 03 09 4a       	add    $0x4a090312,%eax
  data_stats->v1 += 1;
    14c7:	05 0c 70 05 10       	add    $0x1005700c,%eax
  data_stats->v2 += pkt_bytes;
    14cc:	4e 05 0b 4b 05 0e    	rex.WRX add $0xe054b0b,%rax
  pckt.flow.port16[0] = original_sport;
    14d2:	75 3d                	jne    1511 <balancer_ingress+0x1511>
    14d4:	05 0c 3d 04 0f       	add    $0xf043d0c,%eax
  if (dst->flags & F_IPV6) {
    14d9:	05 0e 03 71 66       	add    $0x6671030e,%eax
    14de:	05 0b 06 ac 05       	add    $0x5ac060b,%eax
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    14e3:	0e                   	(bad)
    14e4:	3c 05                	cmp    $0x5,%al
    14e6:	0b 4a 05             	or     0x5(%rdx),%ecx
    14e9:	0e                   	(bad)
    14ea:	3c 05                	cmp    $0x5,%al
    14ec:	0b 3c 3c             	or     (%rsp,%rdi,1),%edi
    14ef:	05 0e 3c 05 0b       	add    $0xb053c0e,%eax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    14f4:	3c 05                	cmp    $0x5,%al
    14f6:	09 06                	or     %eax,(%rsi)
    14f8:	03 6a 90             	add    -0x70(%rdx),%ebp
    14fb:	05 0e 06 c8 05       	add    $0x5c8060e,%eax
    1500:	09 66 05             	or     %esp,0x5(%rsi)
    1503:	0e                   	(bad)
    1504:	08 12                	or     %dl,(%rdx)
    1506:	05 09 74 05 0e       	add    $0xe057409,%eax
  data_end = (void*)(long)xdp->data_end;
    150b:	f2 05 09 74 05 0a    	repnz add $0xa057409,%eax
  iph = data + sizeof(struct ethhdr);
    1511:	06                   	(bad)
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    1512:	a1 04 12 05 0e 03 24 	movabs 0x42e24030e051204,%eax
    1519:	2e 04 
    151b:	00 05 1b 03 a0 07    	add    %al,0x7a0031b(%rip)        # 7a0183c <_license+0x79ff4a7>
    1521:	90                   	nop
    1522:	05 0b 06 58 03       	add    $0x358060b,%eax
    1527:	97                   	xchg   %eax,%edi
    1528:	78 2e                	js     1558 <balancer_ingress+0x1558>
    152a:	05 0d 06 03 ec       	add    $0xec03060d,%eax
    152f:	07                   	(bad)
    1530:	9e                   	sahf
    1531:	05 0e bb 05 0d       	add    $0xd05bb0e,%eax
    1536:	06                   	(bad)
    1537:	3c 05                	cmp    $0x5,%al
    1539:	18 06                	sbb    %al,(%rsi)
    153b:	69 05 00 06 03 90 78 	imul   $0x17059e78,-0x6ffcfa00(%rip),%eax        # ffffffff90031b45 <server_id_map+0x36ff77948b45>
    1542:	9e 05 17 
    1545:	06                   	(bad)
    1546:	03 de                	add    %esi,%ebx
    1548:	00 4a 05             	add    %cl,0x5(%rdx)
  memcpy(new_eth->h_dest, cval->mac, 6);
    154b:	07                   	(bad)
    154c:	03 4c 08 9e          	add    -0x62(%rax,%rcx,1),%ecx
    1550:	06                   	(bad)
    1551:	03 56 ba             	add    -0x46(%rsi),%edx
    1554:	05 08 06 03 2b       	add    $0x2b030608,%eax
    1559:	2e 05 07 06 3c 03    	cs add $0x33c0607,%eax
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    155f:	55                   	push   %rbp
    1560:	2e 05 0f 06 03 2e    	cs add $0x2e03060f,%eax
    1566:	74 05                	je     156d <balancer_ingress+0x156d>
    1568:	12 5c 05 29          	adc    0x29(%rbp,%rax,1),%bl
    156c:	06                   	(bad)
  new_eth->h_proto = BE_ETH_P_IP;
    156d:	4a 05 07 66 05 19    	rex.WX add $0x19056607,%rax
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1573:	06                   	(bad)
    1574:	30 75 06             	xor    %dh,0x6(%rbp)
    1577:	03 4b 66             	add    0x66(%rbx),%ecx
    157a:	06                   	(bad)
    157b:	03 37                	add    (%rdi),%esi
  iph->ihl = 5;
    157d:	58                   	pop    %rax
    157e:	05 1d 91 05 09       	add    $0x905911d,%eax
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1583:	06                   	(bad)
    1584:	66 03 48 2e          	add    0x2e(%rax),%cx
    1588:	05 19 06 03 88       	add    $0x88030619,%eax
    158d:	01 74 05 09          	add    %esi,0x9(%rbp,%rax,1)
    1591:	06                   	(bad)
  iph->id = 0;
    1592:	3c 05                	cmp    $0x5,%al
    1594:	24 06                	and    $0x6,%al
    1596:	03 9a 7f 2e 05 1e    	add    0x1e052e7f(%rdx),%ebx
  iph->saddr = saddr;
    159c:	03 ea                	add    %edx,%ebp
    159e:	00 66 05             	add    %ah,0x5(%rsi)
  iph->ttl = DEFAULT_TTL;
    15a1:	1c 06                	sbb    $0x6,%al
    15a3:	58                   	pop    %rax
    15a4:	05 07 06 59 05       	add    $0x5590607,%eax
    *csum += *next_iph_u16++;
    15a9:	34 03                	xor    $0x3,%al
    15ab:	95                   	xchg   %eax,%ebp
    15ac:	7f 08                	jg     15b6 <balancer_ingress+0x15b6>
    15ae:	3c 05                	cmp    $0x5,%al
    15b0:	0c 06                	or     $0x6,%al
    15b2:	4a 05 30 06 03 ed    	rex.WX add $0xffffffffed030630,%rax
    15b8:	00 ba 06 03 f1 7e    	add    %bh,0x7ef10306(%rdx)
    15be:	08 74 05 22          	or     %dh,0x22(%rbp,%rax,1)
    15c2:	06                   	(bad)
    15c3:	03 90 01 58 05 15    	add    0x15055801(%rax),%edx
      if (pckt.flow.proto == IPPROTO_TCP) {
    15c9:	06                   	(bad)
    15ca:	3c 05                	cmp    $0x5,%al
    15cc:	2b 58 05             	sub    0x5(%rax),%ebx
    15cf:	10 06                	adc    %al,(%rsi)
    15d1:	30 05 09 59 06 03    	xor    %al,0x3065909(%rip)        # 3066ee0 <_license+0x3064b4b>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    15d7:	ed                   	in     (%dx),%eax
    15d8:	7e 66                	jle    1640 <balancer_ingress+0x1640>
    15da:	03 93 01 d6 05 0b    	add    0xb05d601(%rbx),%edx
    15e0:	06                   	(bad)
    15e1:	93                   	xchg   %eax,%ebx
        if (!lru_stats) {
    15e2:	05 09 59 05 14       	add    $0x14055909,%eax
    15e7:	6d                   	insl   (%dx),%es:(%rdi)
    15e8:	05 0b 4b 05 07       	add    $0x7054b0b,%eax
        if (pckt.flags & F_SYN_SET) {
    15ed:	59                   	pop    %rcx
    15ee:	06                   	(bad)
    15ef:	03 e0                	add    %eax,%esp
    15f1:	7e 66                	jle    1659 <balancer_ingress+0x1659>
    15f3:	03 a0 01 08 20 03    	add    0x3200801(%rax),%esp
    15f9:	e0 7e                	loopne 1679 <balancer_ingress+0x1679>
    15fb:	90                   	nop
    15fc:	05 24 06 03 a6       	add    $0xa6030624,%eax
  struct real_pos_lru new_dst_lru = {};
    1601:	01 58 05             	add    %ebx,0x5(%rax)
    1604:	34 06                	xor    $0x6,%al
    1606:	82                   	(bad)
    1607:	05 1a 06 4b 05       	add    $0x54b061a,%eax
    160c:	09 06                	or     %eax,(%rsi)
    160e:	58                   	pop    %rax
    160f:	05 19 06 2f 05       	add    $0x52f0619,%eax
    1614:	15 5a 06 03 d6       	adc    $0xd603065a,%eax
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1619:	7e 3c                	jle    1657 <balancer_ingress+0x1657>
    161b:	04 06                	add    $0x6,%al
    161d:	05 01 06 03 9f       	add    $0x9f030601,%eax
    1622:	03 58 06             	add    0x6(%rax),%ebx
    1625:	03 e1                	add    %ecx,%esp
  if (!conn_rate_stats) {
    1627:	7c 3c                	jl     1665 <balancer_ingress+0x1665>
    1629:	03 9f 03 82 03 e1    	add    -0x1efc7dfd(%rdi),%ebx
    162f:	7c 58                	jl     1689 <balancer_ingress+0x1689>
    1631:	04 00                	add    $0x0,%al
    1633:	05 27 06 03 d4       	add    $0xd4030627,%eax
  *cur_time = bpf_ktime_get_ns();
    1638:	04 9e                	add    $0x9e,%al
    163a:	05 28 bb 05 36       	add    $0x3605bb28,%eax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    163f:	3d 05 2f 06 e4       	cmp    $0xe4062f05,%eax
    1644:	05 35 06 2d 05       	add    $0x52d0635,%eax
    conn_rate_stats->v1 = 1;
    1649:	2b 57 05             	sub    0x5(%rdi),%edx
    164c:	22 4d 05             	and    0x5(%rbp),%cl
    conn_rate_stats->v2 = *cur_time;
    164f:	21 ae 05 1c 9f 06    	and    %ebp,0x69f1c05(%rsi)
    1655:	03 a6 7b 2e 03 da    	add    -0x25fcd185(%rsi),%esp
    conn_rate_stats->v1 += 1;
    165b:	04 9e                	add    $0x9e,%al
    165d:	05 0a 06 c9 05       	add    $0x5c9060a,%eax
    1662:	09 06                	or     %eax,(%rsi)
    1664:	3c 05                	cmp    $0x5,%al
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1666:	14 06                	adc    $0x6,%al
    1668:	31 05 16 03 a7 03    	xor    %eax,0x3a70316(%rip)        # 3a71984 <_license+0x3a6f5ef>
    166e:	2e 06                	cs (bad)
    1670:	03 fb                	add    %ebx,%edi
    1672:	77 9e                	ja     1612 <balancer_ingress+0x1612>
    1674:	05 07 06 03 d0       	add    $0xd0030607,%eax
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1679:	00 9e 05 08 bb 05    	add    %bl,0x5bb0805(%rsi)
      pckt->flow.port16[0] = pckt->flow.port16[1];
    167f:	07                   	(bad)
    1680:	06                   	(bad)
    1681:	3c 05                	cmp    $0x5,%al
    1683:	12 06                	adc    (%rsi),%al
      memset(pckt->flow.srcv6, 0, 16);
    1685:	31 05 00 06 03 ac    	xor    %eax,-0x53fcfa00(%rip)        # ffffffffac031c8b <server_id_map+0x36ff93948c8b>
    168b:	7f 4a                	jg     16d7 <balancer_ingress+0x16d7>
    168d:	05 01 06 0b 03       	add    $0x30b0601,%eax
    1692:	c9                   	leave
    1693:	08 82 06 03 b7 77    	or     %al,0x77b70306(%rdx)
        jhash(pckt->flow.srcv6, 16, INIT_JHASH_SEED_V6),
    1699:	08 20                	or     %ah,(%rax)
    169b:	05 07 06 03 c5       	add    $0xc5030607,%eax
    16a0:	00 9e 05 08 bb 06    	add    %bl,0x6bb0805(%rsi)
    16a6:	03 ba 7f 74 04 11    	add    0x1104747f(%rdx),%edi
    return jhash_2words(
    16ac:	05 07 06 03 3a       	add    $0x3a030607,%eax
    16b1:	ba 06 90 03 46       	mov    $0x46039006,%edx
    16b6:	2e 05 1c 06 03 3d    	cs add $0x3d03061c,%eax
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    16bc:	58                   	pop    %rax
    16bd:	05 20 3d 05 0f       	add    $0xf053d20,%eax
    16c2:	4c 05 13 4c 05 1e    	rex.WR add $0x1e054c13,%rax
    16c8:	06                   	(bad)
    16c9:	3c 03                	cmp    $0x3,%al
    16cb:	be 7f 2e 03 c2       	mov    $0xc2032e7f,%esi
    16d0:	00 90 03 be 7f 58    	add    %dl,0x587fbe03(%rax)
    key = RING_SIZE * (vip_info->vip_num) + hash;
    16d6:	05 03 06 03 c5       	add    $0xc5030603,%eax
    16db:	00 9e 08 4b 05 14    	add    %bl,0x14054b08(%rsi)
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    16e1:	d7                   	xlat   %ds:(%rbx)
    16e2:	05 1b 6e 04 12       	add    $0x12046e1b,%eax
    if (!real_pos) {
    16e7:	05 12 03 56 58       	add    $0x58560312,%eax
    16ec:	04 11                	add    $0x11,%al
    16ee:	05 1d 03 2e 4a       	add    $0x4a2e031d,%eax
    16f3:	04 12                	add    $0x12,%al
    16f5:	05 03 59 05 12       	add    $0x12055903,%eax
    16fa:	bc 05 23 83 05       	mov    $0x5832305,%esp
    16ff:	15 06 3c 05 11       	adc    $0x11053c06,%eax
    key = *real_pos;
    1704:	06                   	(bad)
    1705:	40 05 15 67 05 03    	rex add $0x3056715,%eax
    if (key == 0) {
    170b:	4c 08 21             	rex.WR or %r12b,(%rcx)
  pckt->real_index = key;
    170e:	06                   	(bad)
    170f:	03 a1 7f 08 4a 04    	add    0x44a087f(%rcx),%esp
  if (!(*real)) {
    1715:	00 05 07 06 03 2a    	add    %al,0x2a030607(%rip)        # 2a031d22 <_license+0x2a02f98d>
    171b:	9e                   	sahf
    171c:	05 08 bb 05 07       	add    $0x705bb08,%eax
    1721:	06                   	(bad)
    1722:	3c 03                	cmp    $0x3,%al
    1724:	55                   	push   %rbp
    1725:	66 05 0f 06          	add    $0x60f,%ax
    1729:	03 2e                	add    (%rsi),%ebp
    172b:	74 05                	je     1732 <balancer_ingress+0x1732>
    172d:	12 32                	adc    (%rdx),%dh
    172f:	05 29 06 74 05       	add    $0x5740629,%eax
    1734:	07                   	(bad)
    1735:	74 05                	je     173c <balancer_ingress+0x173c>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1737:	19 06                	sbb    %eax,(%rsi)
    1739:	30 75 05             	xor    %dh,0x5(%rbp)
    173c:	14 03                	adc    $0x3,%al
    173e:	ba 04 66 05 37       	mov    $0x37056604,%edx
    if (pckt->flow.proto == IPPROTO_UDP) {
    1743:	03 9f 02 2e 05 07    	add    0x7052e02(%rdi),%ebx
    1749:	03 f2                	add    %edx,%esi
      new_dst_lru.atime = cur_time;
    174b:	7d 4a                	jge    1797 <balancer_ingress+0x1797>
    174d:	06                   	(bad)
    174e:	82                   	(bad)
    new_dst_lru.pos = key;
    174f:	03 80 7b 2e 03 80    	add    -0x7ffcd185(%rax),%eax
    1755:	05 e4 05 08 06       	add    $0x60805e4,%eax
    175a:	c9                   	leave
    175b:	05 07 06 3c 05       	add    $0x53c0607,%eax
    1760:	14 06                	adc    $0x6,%al
BPF_MAP_OPS_INLINE(map_update_elem,,
    1762:	35 06 03 f8 7a       	xor    $0x7af80306,%eax
    1767:	4a 05 19 06 03 37    	rex.WX add $0x37030619,%rax
    176d:	2e 05 1d 91 05 09    	cs add $0x905911d,%eax
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    1773:	06                   	(bad)
    1774:	66 05 17 06          	add    $0x617,%ax
    1778:	03 bf 04 2e 05 1b    	add    0x1b052e04(%rdi),%edi
    177e:	08 13                	or     %dl,(%rbx)
    1780:	05 13 06 4a 04       	add    $0x44a0613,%eax
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    1785:	06                   	(bad)
    1786:	05 01 06 03 a7       	add    $0xa7030601,%eax
    178b:	7e 3c                	jle    17c9 <balancer_ingress+0x17c9>
    178d:	04 00                	add    $0x0,%al
    178f:	05 23 03 f4 03       	add    $0x3f40323,%eax
    1794:	08 2e                	or     %ch,(%rsi)
    1796:	05 00 06 03 ed       	add    $0xed030600,%eax
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    179b:	78 74                	js     1811 <balancer_ingress+0x1811>
    179d:	05 2c 06 03 95       	add    $0x9503062c,%eax
    17a2:	07                   	(bad)
    17a3:	3c 05                	cmp    $0x5,%al
    17a5:	14 03                	adc    $0x3,%al
    17a7:	1b 4a 06             	sbb    0x6(%rdx),%ecx
                         lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
    17aa:	03 d0                	add    %eax,%edx
    17ac:	78 58                	js     1806 <balancer_ingress+0x1806>
    17ae:	05 10 06 03 8f       	add    $0x8f030610,%eax
    17b3:	08 90 06 66 03 f1    	or     %dl,-0xefc99fa(%rax)
    17b9:	77 ac                	ja     1767 <balancer_ingress+0x1767>
    17bb:	05 07 06 03 2a       	add    $0x2a030607,%eax
  bool port_match = lru_miss_stat_vip->port == vip->port;
    17c0:	9e                   	sahf
    17c1:	05 08 bb 05 07       	add    $0x705bb08,%eax
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    17c6:	06                   	(bad)
    17c7:	3c 03                	cmp    $0x3,%al
    17c9:	55                   	push   %rbp
    17ca:	66 05 0f 06          	add    $0x60f,%ax
    17ce:	03 2e                	add    (%rsi),%ebp
    17d0:	74 05                	je     17d7 <balancer_ingress+0x17d7>
    17d2:	12 32                	adc    (%rdx),%dh
    17d4:	05 29 06 74 05       	add    $0x5740629,%eax
  bool vip_match = address_match && port_match && proto_match;
    17d9:	07                   	(bad)
    17da:	74 05                	je     17e1 <balancer_ingress+0x17e1>
    17dc:	19 06                	sbb    %eax,(%rsi)
    17de:	30 75 05             	xor    %dh,0x5(%rbp)
    17e1:	14 03                	adc    $0x3,%al
    __u32 lru_stats_key = pckt->real_index;
    17e3:	ba 04 66 05 37       	mov    $0x37056604,%edx
    17e8:	03 9f 02 2e 05 07    	add    0x7052e02(%rdi),%ebx
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    17ee:	03 f2                	add    %edx,%esi
    17f0:	7d 4a                	jge    183c <balancer_ingress+0x183c>
    17f2:	06                   	(bad)
    17f3:	82                   	(bad)
    17f4:	03 80 7b 2e 03 80    	add    -0x7ffcd185(%rax),%eax
    17fa:	05 e4 05 08 06       	add    $0x60805e4,%eax
    17ff:	c9                   	leave
    1800:	05 07 06 3c 05       	add    $0x53c0607,%eax
    1805:	14 06                	adc    $0x6,%al
    1807:	35 06 03 f8 7a       	xor    $0x7af80306,%eax
    if (!lru_miss_stat) {
    180c:	4a 05 19 06 03 37    	rex.WX add $0x37030619,%rax
    *lru_miss_stat += 1;
    1812:	2e 05 1d 91 05 09    	cs add $0x905911d,%eax
      data_stats->v2 += 1;
    1818:	06                   	(bad)
    1819:	66 05 17 06          	add    $0x617,%ax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    181d:	03 bf 04 2e 05 1b    	add    0x1b052e04(%rdi),%edi
    1823:	08 13                	or     %dl,(%rbx)
    1825:	05 13 06 4a 03       	add    $0x34a0613,%eax
    182a:	88 7b 3c             	mov    %bh,0x3c(%rbx)
    182d:	04 06                	add    $0x6,%al
    182f:	05 01 06 03 9f       	add    $0x9f030601,%eax
    1834:	03 58 04             	add    0x4(%rax),%ebx
    1837:	00 05 23 03 f4 03    	add    %al,0x3f40323(%rip)        # 3f41b60 <_license+0x3f3f7cb>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    183d:	f2 05 00 06 03 ed    	repnz add $0xed030600,%eax
    1843:	78 74                	js     18b9 <balancer_ingress+0x18b9>
  if (!ch_drop_stats) {
    1845:	05 2c 06 03 95       	add    $0x9503062c,%eax
    184a:	07                   	(bad)
    184b:	3c 05                	cmp    $0x5,%al
    184d:	14 03                	adc    $0x3,%al
    184f:	1b 4a 06             	sbb    0x6(%rdx),%ecx
    1852:	03 d0                	add    %eax,%edx
    1854:	78 58                	js     18ae <balancer_ingress+0x18ae>
    1856:	02 0c 00             	add    (%rax,%rax,1),%cl
    1859:	01 01                	add    %eax,(%rcx)
    185b:	04 0d                	add    $0xd,%al
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    185d:	05 05 0a 00 09       	add    $0x9000a05,%eax
    1862:	02 60 22             	add    0x22(%rax),%ah
    1865:	00 00                	add    %al,(%rax)
    1867:	00 00                	add    %al,(%rax)
  if (!ch_drop_stats) {
    1869:	00 00                	add    %al,(%rax)
    186b:	03 e6                	add    %esi,%esp
    186d:	00 01                	add    %al,(%rcx)
    186f:	9f                   	lahf
    1870:	05 03 68 05 1a       	add    $0x1a056803,%eax
    1875:	03 9e 7f 74 05 03    	add    0x305747f(%rsi),%ebx
    187b:	03 e2                	add    %edx,%esp
    187d:	00 58 05             	add    %bl,0x5(%rax)
    1880:	1a 03                	sbb    (%rbx),%al
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1882:	9e                   	sahf
    1883:	7f 4a                	jg     18cf <balancer_ingress+0x18cf>
    1885:	05 03 03 e2 00       	add    $0xe20303,%eax
    188a:	58                   	pop    %rax
    188b:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    1890:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
  data = (void*)(long)xdp->data;
    1896:	58                   	pop    %rax
    1897:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
  data_end = (void*)(long)xdp->data_end;
    189c:	2e 05 03 03 e2 00    	cs add $0xe20303,%eax
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    18a2:	58                   	pop    %rax
    18a3:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    18a8:	66 05 03 03          	add    $0x303,%ax
    18ac:	e2 00                	loop   18ae <balancer_ingress+0x18ae>
    18ae:	58                   	pop    %rax
    18af:	05 1a 03 9e 7f       	add    $0x7f9e031a,%eax
    18b4:	4a 05 03 03 e2 00    	rex.WX add $0xe20303,%rax
    18ba:	3c 05                	cmp    $0x5,%al
    18bc:	1a 03                	sbb    (%rbx),%al
    18be:	9e                   	sahf
    18bf:	7f 4a                	jg     190b <balancer_ingress+0x190b>
    18c1:	05 03 03 e2 00       	add    $0xe20303,%eax
  memcpy(new_eth->h_dest, cval->mac, 6);
    18c6:	3c 33                	cmp    $0x33,%al
    18c8:	02 01                	add    (%rcx),%al
    18ca:	00 01                	add    %al,(%rcx)
    18cc:	01 04 0d 05 0a 0a 00 	add    %eax,0xa0a05(,%rcx,1)
    18d3:	09 02                	or     %eax,(%rdx)
    18d5:	c0 22 00             	shlb   $0x0,(%rdx)
    18d8:	00 00                	add    %al,(%rax)
    18da:	00 00                	add    %al,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    18dc:	00 03                	add    %al,(%rbx)
    18de:	3d 01 67 05 07       	cmp    $0x7056701,%eax
    18e3:	06                   	(bad)
    18e4:	3c 05                	cmp    $0x5,%al
    18e6:	0a 06                	or     (%rsi),%al
    18e8:	67 05 05 4b 05 07    	addr32 add $0x7054b05,%eax
  new_eth->h_proto = BE_ETH_P_IPV6;
    18ee:	3b 05 1a 03 48 74    	cmp    0x7448031a(%rip),%eax        # 74481c0e <_license+0x7447f879>
  saddr[3] = src ^ port;
    18f4:	05 05 03 39 4a       	add    $0x4a390305,%eax
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    18f9:	05 1a 03 47 66       	add    $0x6647031a,%eax
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    18fe:	05 05 03 39 66       	add    $0x66390305,%eax
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1903:	05 1a 03 47 08       	add    $0x847031a,%eax
    1908:	3c 05                	cmp    $0x5,%al
    190a:	05 03 39 3c 05       	add    $0x53c3903,%eax
  ip6h->priority = (tc & 0xF0) >> 4;
    190f:	1a 03                	sbb    (%rbx),%al
    1911:	47 58                	rex.RXB pop %r8
    1913:	05 05 03 39 58       	add    $0x58390305,%eax
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1918:	05 1a 03 47 74       	add    $0x7447031a,%eax
  ip6h->nexthdr = proto;
    191d:	05 05 03 39 74       	add    $0x74390305,%eax
  ip6h->payload_len = bpf_htons(payload_len);
    1922:	05 1a 03 47 ba       	add    $0xba47031a,%eax
    1927:	05 0c 03 cf 00       	add    $0xcf030c,%eax
    192c:	4a 05 16 06 4a 05    	rex.WX add $0x54a0616,%rax
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    1932:	11 06                	adc    %eax,(%rsi)
    1934:	3e 05 16 06 58 05    	ds add $0x5580616,%eax
    193a:	09 06                	or     %eax,(%rsi)
    193c:	48 05 11 40 05 16    	add    $0x16054011,%rax
  if (!connId) {
    1942:	06                   	(bad)
    1943:	58                   	pop    %rax
    1944:	05 09 06 48 05       	add    $0x5480609,%eax
    1949:	0c 40                	or     $0x40,%al
    194b:	05 09 48 3e 05       	add    $0x53e4809,%eax
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1950:	05 03 64 2e 05       	add    $0x52e6403,%eax
    1955:	07                   	(bad)
    1956:	03 1d 2e 05 1a 03    	add    0x31a052e(%rip),%ebx        # 31a1e8a <_license+0x319faf5>
    195c:	aa                   	stos   %al,%es:(%rdi)
    195d:	7f 3c                	jg     199b <balancer_ingress+0x199b>
    195f:	05 07 03 d6 00       	add    $0xd60307,%eax
    1964:	58                   	pop    %rax
    1965:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    196a:	2e 05 07 03 d6 00    	cs add $0xd60307,%eax
    1970:	58                   	pop    %rax
    1971:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    1976:	66 05 07 03          	add    $0x307,%ax
    197a:	d6                   	(bad)
    197b:	00 58 05             	add    %bl,0x5(%rax)
    197e:	1a 03                	sbb    (%rbx),%al
    1980:	aa                   	stos   %al,%es:(%rdi)
    1981:	7f 4a                	jg     19cd <balancer_ingress+0x19cd>
    1983:	05 07 03 d6 00       	add    $0xd60307,%eax
    1988:	58                   	pop    %rax
      if (qpr.server_id > 0) {
    1989:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    198e:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1994:	58                   	pop    %rax
    1995:	05 1a 03 aa 7f       	add    $0x7faa031a,%eax
    199a:	4a 05 07 03 d6 00    	rex.WX add $0xd60307,%rax
    19a0:	3c 05                	cmp    $0x5,%al
    quic_packets_stats->cid_v1 += 1;
    19a2:	1a 03                	sbb    (%rbx),%al
    19a4:	aa                   	stos   %al,%es:(%rdi)
    19a5:	7f 2e                	jg     19d5 <balancer_ingress+0x19d5>
    quic_packets_stats->cid_v2 += 1;
    19a7:	05 07 03 d6 00       	add    $0xd60307,%eax
    19ac:	58                   	pop    %rax
    quic_packets_stats->cid_v3 += 1;
    19ad:	05 03 4f 02 01       	add    $0x1024f03,%eax
    19b2:	00 01                	add    %al,(%rcx)
    quic_packets_stats->cid_v0 += 1;
    19b4:	01                   	.byte 0x1

Disassembly of section .debug_line_str:

0000000000000000 <.debug_line_str>:
  void* data = (void*)(long)ctx->data;
   0:	2f                   	(bad)
   1:	72 6f                	jb     72 <balancer_ingress+0x72>
   3:	6f                   	outsl  %ds:(%rsi),(%dx)
   4:	74 2f                	je     35 <balancer_ingress+0x35>
   6:	57                   	push   %rdi
   7:	6f                   	outsl  %ds:(%rsi),(%dx)
   8:	72 6b                	jb     75 <balancer_ingress+0x75>
   a:	73 70                	jae    7c <balancer_ingress+0x7c>
   c:	61                   	(bad)
   d:	63 65 2f             	movsxd 0x2f(%rbp),%esp
  10:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  14:	61                   	(bad)
  15:	6e                   	outsb  %ds:(%rsi),(%dx)
  16:	2f                   	(bad)
  17:	5f                   	pop    %rdi
  void* data_end = (void*)(long)ctx->data_end;
  18:	62 75                	(bad)
  1a:	69 6c 64 2f 64 65 70 	imul   $0x73706564,0x2f(%rsp,%riz,2),%ebp
  21:	73 
  if (data + nh_off > data_end) {
  22:	2f                   	(bad)
  23:	62                   	(bad)
  24:	70 66                	jo     8c <balancer_ingress+0x8c>
  26:	70 72                	jo     9a <balancer_ingress+0x9a>
  28:	6f                   	outsl  %ds:(%rsi),(%dx)
  29:	67 00 2e             	add    %ch,(%esi)
  2c:	2f                   	(bad)
  2d:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
  eth_proto = eth->h_proto; 
  31:	61                   	(bad)
  32:	6e                   	outsb  %ds:(%rsi),(%dx)
  33:	2f                   	(bad)
  34:	6c                   	insb   (%dx),%es:(%rdi)
  35:	69 62 2f 62 70 66 00 	imul   $0x667062,0x2f(%rdx),%esp
  if (eth_proto == BE_ETH_P_IP) {
  3c:	2f                   	(bad)
  3d:	75 73                	jne    b2 <balancer_ingress+0xb2>
  3f:	72 2f                	jb     70 <balancer_ingress+0x70>
  41:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  48:	2f                   	(bad)
  49:	61                   	(bad)
  4a:	73 6d                	jae    b9 <balancer_ingress+0xb9>
  4c:	2d 67 65 6e 65       	sub    $0x656e6567,%eax
  struct packet_description pckt = {};
  51:	72 69                	jb     bc <balancer_ingress+0xbc>
  53:	63 00                	movsxd (%rax),%eax
  55:	2f                   	(bad)
  56:	75 73                	jne    cb <balancer_ingress+0xcb>
  58:	72 2f                	jb     89 <balancer_ingress+0x89>
  5a:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  61:	2f                   	(bad)
  62:	6c                   	insb   (%dx),%es:(%rdi)
  63:	69 6e 75 78 00 2e 2f 	imul   $0x2f2e0078,0x75(%rsi),%ebp
  6a:	2e 68 65 61 64 65    	cs push $0x65646165
  70:	72 5f                	jb     d1 <balancer_ingress+0xd1>
  72:	6f                   	outsl  %ds:(%rsi),(%dx)
  73:	76 65                	jbe    da <balancer_ingress+0xda>
  75:	72 72                	jb     e9 <balancer_ingress+0xe9>
  77:	69 64 65 2f 36 2f 6b 	imul   $0x616b2f36,0x2f(%rbp,%riz,2),%esp
  7e:	61 
  7f:	74 72                	je     f3 <balancer_ingress+0xf3>
  81:	61                   	(bad)
  82:	6e                   	outsb  %ds:(%rsi),(%dx)
  struct vip_definition vip = {};
  83:	2f                   	(bad)
  84:	6c                   	insb   (%dx),%es:(%rdi)
  85:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
  8c:	78 5f                	js     ed <balancer_ingress+0xed>
  8e:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  95:	73 00                	jae    97 <balancer_ingress+0x97>
  97:	2e 2f                	cs (bad)
  99:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
    if (iph + 1 > data_end) {
  9d:	61                   	(bad)
  9e:	6e                   	outsb  %ds:(%rsi),(%dx)
  9f:	2f                   	(bad)
  a0:	6c                   	insb   (%dx),%es:(%rdi)
  a1:	69 62 2f 6c 69 6e 75 	imul   $0x756e696c,0x2f(%rdx),%esp
  a8:	78 5f                	js     109 <balancer_ingress+0x109>
    if (iph->ihl != 5) {
  aa:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%rsi),%ebp
  b1:	73 00                	jae    b3 <balancer_ingress+0xb3>
  b3:	6b 61 74 72          	imul   $0x72,0x74(%rcx),%esp
    pckt->tos = iph->tos;
  b7:	61                   	(bad)
  b8:	6e                   	outsb  %ds:(%rsi),(%dx)
  b9:	2f                   	(bad)
  ba:	6c                   	insb   (%dx),%es:(%rdi)
  bb:	69 62 2f 62 70 66 2f 	imul   $0x2f667062,0x2f(%rdx),%esp
    *protocol = iph->protocol;
  c2:	62 61 6c 61 6e       	(bad)
    pckt->flow.proto = *protocol;
  c7:	63 65 72             	movsxd 0x72(%rbp),%esp
    if (iph->frag_off & PCKT_FRAGMENTED) {
  ca:	2e 62                	cs (bad)
  cc:	70 66                	jo     134 <balancer_ingress+0x134>
  ce:	2e 63 00             	cs movsxd (%rax),%eax
  d1:	63 6f 6e             	movsxd 0x6e(%rdi),%ebp
  d4:	74 72                	je     148 <balancer_ingress+0x148>
  d6:	6f                   	outsl  %ds:(%rsi),(%dx)
  d7:	6c                   	insb   (%dx),%es:(%rdi)
  d8:	5f                   	pop    %rdi
  d9:	64 61                	fs (bad)
  db:	74 61                	je     13e <balancer_ingress+0x13e>
  dd:	5f                   	pop    %rdi
  de:	6d                   	insl   (%dx),%es:(%rdi)
    if (*protocol == IPPROTO_ICMP) {
  df:	61                   	(bad)
  e0:	70 73                	jo     155 <balancer_ingress+0x155>
  e2:	2e 68 00 69 6e 74    	cs push $0x746e6900
  if (icmp_hdr + 1 > data_end) {
  e8:	2d 6c 6c 36 34       	sub    $0x34366c6c,%eax
  ed:	2e 68 00 62 61 6c    	cs push $0x6c616200
  f3:	61                   	(bad)
  f4:	6e                   	outsb  %ds:(%rsi),(%dx)
  if (icmp_hdr->type == ICMP_ECHO) {
  f5:	63 65 72             	movsxd 0x72(%rbp),%esp
  f8:	5f                   	pop    %rdi
  f9:	73 74                	jae    16f <balancer_ingress+0x16f>
  fb:	72 75                	jb     172 <balancer_ingress+0x172>
  fd:	63 74 73 2e          	movsxd 0x2e(%rbx,%rsi,2),%esi
 101:	68 00 74 79 70       	push   $0x70797400
 106:	65 73 2e             	gs jae 137 <balancer_ingress+0x137>
 109:	68 00 62 61 6c       	push   $0x6c616200
 10e:	61                   	(bad)
  icmp_hdr->type = ICMP_ECHOREPLY;
 10f:	6e                   	outsb  %ds:(%rsi),(%dx)
 110:	63 65 72             	movsxd 0x72(%rbp),%esp
 113:	5f                   	pop    %rdi
  icmp_hdr->checksum += 0x0008;
 114:	6d                   	insl   (%dx),%es:(%rdi)
 115:	61                   	(bad)
 116:	70 73                	jo     18b <balancer_ingress+0x18b>
 118:	2e 68 00 62 70 66    	cs push $0x66706200
  iph->ttl = DEFAULT_TTL;
 11e:	5f                   	pop    %rdi
 11f:	68 65 6c 70 65       	push   $0x65706c65
 124:	72 73                	jb     199 <balancer_ingress+0x199>
 126:	2e 68 00 62 70 66    	cs push $0x66706200
  iph->daddr = iph->saddr;
 12c:	2e 68 00 69 6e 2e    	cs push $0x2e6e6900
 132:	68 00 69 70 76       	push   $0x76706900
 137:	36 2e 68 00 69 6e 36 	ss cs push $0x366e6900
 13e:	2e 68 00 69 70 2e    	cs push $0x2e706900
 144:	68 00 70 63 6b       	push   $0x6b637000
 149:	74 5f                	je     1aa <balancer_ingress+0x1aa>
 14b:	70 61                	jo     1ae <balancer_ingress+0x1ae>
 14d:	72 73                	jb     1c2 <balancer_ingress+0x1c2>
 14f:	69 6e 67 2e 68 00 6a 	imul   $0x6a00682e,0x67(%rsi),%ebp
 156:	68 61 73 68 2e       	push   $0x2e687361
  struct packet_description pckt = {};
 15b:	68 00 68 61 6e       	push   $0x6e616800
 160:	64 6c                	fs insb (%dx),%es:(%rdi)
 162:	65 5f                	gs pop %rdi
 164:	69 63 6d 70 2e 68 00 	imul   $0x682e70,0x6d(%rbx),%esp
 16b:	63 73 75             	movsxd 0x75(%rbx),%esi
 16e:	6d                   	insl   (%dx),%es:(%rdi)
 16f:	5f                   	pop    %rdi
 170:	68 65 6c 70 65       	push   $0x65706c65
 175:	72 73                	jb     1ea <balancer_ingress+0x1ea>
 177:	2e 68 00 62 61 6c    	cs push $0x6c616200
 17d:	61                   	(bad)
 17e:	6e                   	outsb  %ds:(%rsi),(%dx)
 17f:	63 65 72             	movsxd 0x72(%rbp),%esp
 182:	5f                   	pop    %rdi
 183:	68 65 6c 70 65       	push   $0x65706c65
 188:	72 73                	jb     1fd <balancer_ingress+0x1fd>
 18a:	2e 68 00 70 63 6b    	cs push $0x6b637000
  struct vip_definition vip = {};
 190:	74 5f                	je     1f1 <balancer_ingress+0x1f1>
 192:	65 6e                	outsb  %gs:(%rsi),(%dx)
 194:	63 61 70             	movsxd 0x70(%rcx),%esp
 197:	2e 68 00 65 6e 63    	cs push $0x636e6500
 19d:	61                   	(bad)
 19e:	70 5f                	jo     1ff <balancer_ingress+0x1ff>
 1a0:	68 65 6c 70 65       	push   $0x65706c65
 1a5:	72 73                	jb     21a <balancer_ingress+0x21a>
 1a7:	2e 68 00 69 63 6d    	cs push $0x6d636900
    if (ip6h + 1 > data_end) {
 1ad:	70 76                	jo     225 <balancer_ingress+0x225>
 1af:	36 2e 68 00 69 66 5f 	ss cs push $0x5f666900
    *protocol = ip6h->nexthdr;
 1b6:	65 74 68             	gs je  221 <balancer_ingress+0x221>
 1b9:	65 72 2e             	gs jb  1ea <balancer_ingress+0x1ea>
    pckt->flow.proto = *protocol;
 1bc:	68 00 74 63 70       	push   $0x70637400
    pckt->tos = (ip6h->priority << 4) & 0xF0;
 1c1:	2e 68 00 75 64 70    	cs push $0x70647500
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 1c7:	2e                   	cs
 1c8:	68                   	.byte 0x68
	...
