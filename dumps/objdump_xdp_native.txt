
bpf/native/balancer.bpf:     file format elf64-x86-64


Disassembly of section xdp:

0000000000000000 <balancer_ingress>:

  return XDP_TX;
}

SEC(PROG_SEC_NAME)
int balancer_ingress(struct xdp_md* ctx) {
       0:	f3 0f 1e fa          	endbr64
       4:	55                   	push   %rbp
       5:	48 89 e5             	mov    %rsp,%rbp
       8:	41 57                	push   %r15
       a:	41 56                	push   %r14
       c:	41 55                	push   %r13
       e:	41 54                	push   %r12
      10:	53                   	push   %rbx
      11:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  void* data = (void*)(long)ctx->data;
      18:	4c 8b 37             	mov    (%rdi),%r14
  void* data_end = (void*)(long)ctx->data_end;
      1b:	4c 8b 7f 08          	mov    0x8(%rdi),%r15
  struct ethhdr* eth = data;
  __u32 eth_proto;
  __u32 nh_off;
  nh_off = sizeof(struct ethhdr);

  if (data + nh_off > data_end) {
      1f:	49 8d 46 0e          	lea    0xe(%r14),%rax
      23:	bb 01 00 00 00       	mov    $0x1,%ebx
      28:	4c 39 f8             	cmp    %r15,%rax
      2b:	0f 87 ae 1a 00 00    	ja     1adf <balancer_ingress+0x1adf>
      31:	49 89 fc             	mov    %rdi,%r12
    // bogus packet, len less than minimum ethernet frame size
    return XDP_DROP;
  }

  eth_proto = eth->h_proto;
      34:	41 0f b7 4e 0c       	movzwl 0xc(%r14),%ecx

  if (eth_proto == BE_ETH_P_IP) {
      39:	81 f9 86 dd 00 00    	cmp    $0xdd86,%ecx
      3f:	0f 84 42 01 00 00    	je     187 <balancer_ingress+0x187>
      45:	bb 02 00 00 00       	mov    $0x2,%ebx
      4a:	66 83 f9 08          	cmp    $0x8,%cx
      4e:	0f 85 8b 1a 00 00    	jne    1adf <balancer_ingress+0x1adf>
  struct packet_description pckt = {};
      54:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
      5b:	00 
      5c:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
      63:	00 
      64:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
      6b:	00 
      6c:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
      73:	00 
      74:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
      7b:	00 
      7c:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
      83:	00 
  struct vip_definition vip = {};
      84:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%rbp)
      8b:	00 00 00 
      8e:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
      95:	00 00 00 00 
      99:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
      a0:	00 00 00 00 
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
    }
  } else {
    iph = data + nh_off;
    if (iph + 1 > data_end) {
      a4:	4d 8d 6e 22          	lea    0x22(%r14),%r13
      a8:	4d 39 fd             	cmp    %r15,%r13
      ab:	0f 87 29 1a 00 00    	ja     1ada <balancer_ingress+0x1ada>
      return XDP_DROP;
    }
    // ihl contains len of ipv4 header in 32bit words
    if (iph->ihl != 5) {
      b1:	8a 00                	mov    (%rax),%al
      b3:	24 0f                	and    $0xf,%al
      b5:	3c 05                	cmp    $0x5,%al
      b7:	0f 85 1d 1a 00 00    	jne    1ada <balancer_ingress+0x1ada>
      // if len of ipv4 hdr is not equal to 20bytes that means that header
      // contains ip options, and we dont support em
      return XDP_DROP;
    }
    pckt->tos = iph->tos;
      bd:	41 8a 46 0f          	mov    0xf(%r14),%al
      c1:	88 45 c5             	mov    %al,-0x3b(%rbp)
    *protocol = iph->protocol;
      c4:	41 8a 4e 17          	mov    0x17(%r14),%cl
    pckt->flow.proto = *protocol;
      c8:	88 4d bc             	mov    %cl,-0x44(%rbp)
    *pkt_bytes = bpf_ntohs(iph->tot_len);
    *th_off += nh_off + IPV4_HDR_LEN_NO_OPT;

    if (iph->frag_off & PCKT_FRAGMENTED) {
      cb:	41 0f b7 46 14       	movzwl 0x14(%r14),%eax
      d0:	a9 3f ff 00 00       	test   $0xff3f,%eax
      d5:	0f 85 ff 19 00 00    	jne    1ada <balancer_ingress+0x1ada>
      db:	41 0f b7 7e 10       	movzwl 0x10(%r14),%edi
      // we drop fragmented packets.
      return XDP_DROP;
    }
    if (*protocol == IPPROTO_ICMP) {
      e0:	80 f9 01             	cmp    $0x1,%cl
      e3:	0f 85 78 03 00 00    	jne    461 <balancer_ingress+0x461>
    __u64 off,
    struct packet_description* pckt) {
  struct icmphdr* icmp_hdr;
  struct iphdr* iph;
  icmp_hdr = data + off;
  if (icmp_hdr + 1 > data_end) {
      e9:	49 8d 4e 2a          	lea    0x2a(%r14),%rcx
      ed:	4c 39 f9             	cmp    %r15,%rcx
      f0:	0f 87 e4 19 00 00    	ja     1ada <balancer_ingress+0x1ada>
    return XDP_DROP;
  }
  if (icmp_hdr->type == ICMP_ECHO) {
      f6:	41 8a 55 00          	mov    0x0(%r13),%dl
      fa:	80 fa 03             	cmp    $0x3,%dl
      fd:	0f 84 65 06 00 00    	je     768 <balancer_ingress+0x768>
     103:	bb 02 00 00 00       	mov    $0x2,%ebx
     108:	80 fa 08             	cmp    $0x8,%dl
     10b:	0f 85 ce 19 00 00    	jne    1adf <balancer_ingress+0x1adf>
     111:	44 0f b7 c7          	movzwl %di,%r8d
  icmp_hdr->type = ICMP_ECHOREPLY;
     115:	41 c6 46 22 00       	movb   $0x0,0x22(%r14)
  icmp_hdr->checksum += 0x0008;
     11a:	66 41 83 46 24 08    	addw   $0x8,0x24(%r14)
  iph->ttl = DEFAULT_TTL;
     120:	41 c6 46 16 40       	movb   $0x40,0x16(%r14)
  iph->daddr = iph->saddr;
     125:	41 8b 4e 1a          	mov    0x1a(%r14),%ecx
  tmp_addr = iph->daddr;
     129:	41 8b 76 1e          	mov    0x1e(%r14),%esi
  iph->daddr = iph->saddr;
     12d:	41 89 4e 1e          	mov    %ecx,0x1e(%r14)
  iph->saddr = tmp_addr;
     131:	41 89 76 1a          	mov    %esi,0x1a(%r14)
    void* iph,
    __u64* csum) {
  __u16* next_iph_u16 = (__u16*)iph;
#pragma clang loop unroll(full)
  for (int i = 0; i < sizeof(struct iphdr) >> 1; i++) {
    *csum += *next_iph_u16++;
     135:	41 0f b7 7e 0e       	movzwl 0xe(%r14),%edi
     13a:	41 0f b7 5e 12       	movzwl 0x12(%r14),%ebx
     13f:	45 0f b7 4e 16       	movzwl 0x16(%r14),%r9d
     144:	0f b7 d6             	movzwl %si,%edx
     147:	48 c1 ee 10          	shr    $0x10,%rsi
     14b:	48 01 d6             	add    %rdx,%rsi
     14e:	0f b7 d1             	movzwl %cx,%edx
     151:	48 01 f2             	add    %rsi,%rdx
     154:	48 c1 e9 10          	shr    $0x10,%rcx
     158:	48 01 d1             	add    %rdx,%rcx
     15b:	48 01 f9             	add    %rdi,%rcx
     15e:	4c 01 c1             	add    %r8,%rcx
     161:	48 01 d9             	add    %rbx,%rcx
     164:	48 01 c1             	add    %rax,%rcx
     167:	4c 01 c9             	add    %r9,%rcx
    if (csum >> 16)
     16a:	48 89 c8             	mov    %rcx,%rax
     16d:	48 c1 e8 10          	shr    $0x10,%rax
     171:	0f b7 d1             	movzwl %cx,%edx
     174:	48 01 c2             	add    %rax,%rdx
     177:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
     17e:	48 0f 42 d1          	cmovb  %rcx,%rdx
     182:	e9 11 02 00 00       	jmp    398 <balancer_ingress+0x398>
  struct packet_description pckt = {};
     187:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
     18e:	00 
     18f:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
     196:	00 
     197:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
     19e:	00 
     19f:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
     1a6:	00 
     1a7:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
     1ae:	00 
     1af:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
     1b6:	00 
  struct vip_definition vip = {};
     1b7:	c7 85 70 ff ff ff 00 	movl   $0x0,-0x90(%rbp)
     1be:	00 00 00 
     1c1:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
     1c8:	00 00 00 00 
     1cc:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
     1d3:	00 00 00 00 
    if (ip6h + 1 > data_end) {
     1d7:	4d 8d 6e 36          	lea    0x36(%r14),%r13
     1db:	4d 39 fd             	cmp    %r15,%r13
     1de:	0f 87 f6 18 00 00    	ja     1ada <balancer_ingress+0x1ada>
    *protocol = ip6h->nexthdr;
     1e4:	41 8a 46 14          	mov    0x14(%r14),%al
    pckt->flow.proto = *protocol;
     1e8:	88 45 bc             	mov    %al,-0x44(%rbp)
    pckt->tos = (ip6h->priority << 4) & 0xF0;
     1eb:	41 8a 4e 0e          	mov    0xe(%r14),%cl
     1ef:	c0 e1 04             	shl    $0x4,%cl
     1f2:	88 4d c5             	mov    %cl,-0x3b(%rbp)
    pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
     1f5:	41 8a 56 0f          	mov    0xf(%r14),%dl
     1f9:	c0 ea 04             	shr    $0x4,%dl
     1fc:	08 ca                	or     %cl,%dl
     1fe:	88 55 c5             	mov    %dl,-0x3b(%rbp)
    if (*protocol == IPPROTO_FRAGMENT) {
     201:	3c 2c                	cmp    $0x2c,%al
     203:	0f 84 d1 18 00 00    	je     1ada <balancer_ingress+0x1ada>
     209:	41 0f b7 7e 12       	movzwl 0x12(%r14),%edi
     20e:	3c 3a                	cmp    $0x3a,%al
     210:	0f 85 aa 00 00 00    	jne    2c0 <balancer_ingress+0x2c0>
  if (icmp_hdr + 1 > data_end) {
     216:	49 8d 46 3e          	lea    0x3e(%r14),%rax
     21a:	4c 39 f8             	cmp    %r15,%rax
     21d:	0f 87 b7 18 00 00    	ja     1ada <balancer_ingress+0x1ada>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     223:	41 8a 45 00          	mov    0x0(%r13),%al
     227:	3c 02                	cmp    $0x2,%al
     229:	0f 84 d0 02 00 00    	je     4ff <balancer_ingress+0x4ff>
     22f:	3c 01                	cmp    $0x1,%al
     231:	0f 84 02 03 00 00    	je     539 <balancer_ingress+0x539>
     237:	bb 02 00 00 00       	mov    $0x2,%ebx
     23c:	3c 80                	cmp    $0x80,%al
     23e:	0f 85 9b 18 00 00    	jne    1adf <balancer_ingress+0x1adf>
     244:	41 c6 46 36 81       	movb   $0x81,0x36(%r14)
     249:	66 41 83 46 38 ff    	addw   $0xffff,0x38(%r14)
     24f:	41 c6 46 15 40       	movb   $0x40,0x15(%r14)
     254:	49 8b 46 16          	mov    0x16(%r14),%rax
     258:	49 8b 4e 1e          	mov    0x1e(%r14),%rcx
     25c:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
     260:	48 89 45 80          	mov    %rax,-0x80(%rbp)
     264:	49 8b 46 26          	mov    0x26(%r14),%rax
     268:	49 8b 4e 2e          	mov    0x2e(%r14),%rcx
     26c:	49 89 46 16          	mov    %rax,0x16(%r14)
     270:	49 89 4e 1e          	mov    %rcx,0x1e(%r14)
     274:	48 8b 45 80          	mov    -0x80(%rbp),%rax
     278:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
     27c:	49 89 46 26          	mov    %rax,0x26(%r14)
     280:	49 89 4e 2e          	mov    %rcx,0x2e(%r14)
     284:	41 0f b7 46 0a       	movzwl 0xa(%r14),%eax
     289:	66 89 85 54 ff ff ff 	mov    %ax,-0xac(%rbp)
     290:	41 8b 46 06          	mov    0x6(%r14),%eax
     294:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)
     29a:	41 8b 06             	mov    (%r14),%eax
     29d:	41 89 46 06          	mov    %eax,0x6(%r14)
     2a1:	41 0f b7 46 04       	movzwl 0x4(%r14),%eax
     2a6:	66 41 89 46 0a       	mov    %ax,0xa(%r14)
     2ab:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax
     2b1:	41 89 06             	mov    %eax,(%r14)
     2b4:	0f b7 85 54 ff ff ff 	movzwl -0xac(%rbp),%eax
     2bb:	e9 50 01 00 00       	jmp    410 <balancer_ingress+0x410>
      memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
     2c0:	49 8b 4e 16          	mov    0x16(%r14),%rcx
     2c4:	49 8b 56 1e          	mov    0x1e(%r14),%rdx
     2c8:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
     2cc:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
      memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
     2d0:	49 8b 4e 26          	mov    0x26(%r14),%rcx
     2d4:	49 8b 56 2e          	mov    0x2e(%r14),%rdx
     2d8:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
     2dc:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    void* data,
    void* data_end,
    __u64 off,
    struct packet_description* pckt,
    __u8 protocol) {
  if (protocol == IPPROTO_ICMPV6) {
     2e0:	3c 01                	cmp    $0x1,%al
     2e2:	0f 85 37 01 00 00    	jne    41f <balancer_ingress+0x41f>
  if (icmp_hdr + 1 > data_end) {
     2e8:	49 8d 46 3e          	lea    0x3e(%r14),%rax
     2ec:	4c 39 f8             	cmp    %r15,%rax
     2ef:	0f 87 e5 17 00 00    	ja     1ada <balancer_ingress+0x1ada>
  if (icmp_hdr->type == ICMP_ECHO) {
     2f5:	41 8a 4d 00          	mov    0x0(%r13),%cl
     2f9:	80 f9 03             	cmp    $0x3,%cl
     2fc:	0f 84 b2 03 00 00    	je     6b4 <balancer_ingress+0x6b4>
     302:	bb 02 00 00 00       	mov    $0x2,%ebx
     307:	80 f9 08             	cmp    $0x8,%cl
     30a:	0f 85 cf 17 00 00    	jne    1adf <balancer_ingress+0x1adf>
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     310:	49 8d 46 2a          	lea    0x2a(%r14),%rax
     314:	bb 01 00 00 00       	mov    $0x1,%ebx
       sizeof(struct icmphdr)) > data_end) {
     319:	4c 39 f8             	cmp    %r15,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
     31c:	0f 87 bd 17 00 00    	ja     1adf <balancer_ingress+0x1adf>
  icmp_hdr->type = ICMP_ECHOREPLY;
     322:	41 c6 46 22 00       	movb   $0x0,0x22(%r14)
  icmp_hdr->checksum += 0x0008;
     327:	66 41 83 46 24 08    	addw   $0x8,0x24(%r14)
  iph->ttl = DEFAULT_TTL;
     32d:	41 c6 46 16 40       	movb   $0x40,0x16(%r14)
  iph->daddr = iph->saddr;
     332:	41 8b 46 1a          	mov    0x1a(%r14),%eax
  tmp_addr = iph->daddr;
     336:	41 8b 4e 1e          	mov    0x1e(%r14),%ecx
  iph->daddr = iph->saddr;
     33a:	41 89 46 1e          	mov    %eax,0x1e(%r14)
  iph->saddr = tmp_addr;
     33e:	41 89 4e 1a          	mov    %ecx,0x1a(%r14)
    *csum += *next_iph_u16++;
     342:	45 0f b7 4e 0e       	movzwl 0xe(%r14),%r9d
     347:	41 0f b7 76 10       	movzwl 0x10(%r14),%esi
     34c:	41 0f b7 7e 12       	movzwl 0x12(%r14),%edi
     351:	41 0f b7 5e 14       	movzwl 0x14(%r14),%ebx
     356:	45 0f b7 46 16       	movzwl 0x16(%r14),%r8d
     35b:	0f b7 d1             	movzwl %cx,%edx
     35e:	48 c1 e9 10          	shr    $0x10,%rcx
     362:	48 01 d1             	add    %rdx,%rcx
     365:	0f b7 d0             	movzwl %ax,%edx
     368:	48 01 ca             	add    %rcx,%rdx
     36b:	48 c1 e8 10          	shr    $0x10,%rax
     36f:	48 01 d0             	add    %rdx,%rax
     372:	4c 01 c8             	add    %r9,%rax
     375:	48 01 f0             	add    %rsi,%rax
     378:	48 01 f8             	add    %rdi,%rax
     37b:	48 01 d8             	add    %rbx,%rax
     37e:	4c 01 c0             	add    %r8,%rax
    if (csum >> 16)
     381:	48 89 c1             	mov    %rax,%rcx
     384:	48 c1 e9 10          	shr    $0x10,%rcx
     388:	0f b7 d0             	movzwl %ax,%edx
     38b:	48 01 ca             	add    %rcx,%rdx
     38e:	48 3d 00 00 01 00    	cmp    $0x10000,%rax
     394:	48 0f 42 d0          	cmovb  %rax,%rdx
     398:	48 89 d0             	mov    %rdx,%rax
     39b:	48 c1 e8 10          	shr    $0x10,%rax
     39f:	0f b7 ca             	movzwl %dx,%ecx
     3a2:	48 01 c1             	add    %rax,%rcx
     3a5:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     3ac:	48 0f 42 ca          	cmovb  %rdx,%rcx
     3b0:	48 89 c8             	mov    %rcx,%rax
     3b3:	48 c1 e8 10          	shr    $0x10,%rax
     3b7:	0f b7 d1             	movzwl %cx,%edx
     3ba:	48 01 c2             	add    %rax,%rdx
     3bd:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
     3c4:	48 0f 42 d1          	cmovb  %rcx,%rdx
     3c8:	89 d0                	mov    %edx,%eax
     3ca:	c1 e8 10             	shr    $0x10,%eax
     3cd:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
     3d4:	b9 00 00 01 00       	mov    $0x10000,%ecx
     3d9:	0f 43 c8             	cmovae %eax,%ecx
     3dc:	01 d1                	add    %edx,%ecx
     3de:	f7 d1                	not    %ecx
     3e0:	66 41 89 4e 18       	mov    %cx,0x18(%r14)
     3e5:	41 0f b7 46 0a       	movzwl 0xa(%r14),%eax
     3ea:	66 89 45 84          	mov    %ax,-0x7c(%rbp)
     3ee:	41 8b 46 06          	mov    0x6(%r14),%eax
     3f2:	89 45 80             	mov    %eax,-0x80(%rbp)
     3f5:	41 8b 06             	mov    (%r14),%eax
     3f8:	41 89 46 06          	mov    %eax,0x6(%r14)
     3fc:	41 0f b7 46 04       	movzwl 0x4(%r14),%eax
     401:	66 41 89 46 0a       	mov    %ax,0xa(%r14)
     406:	8b 45 80             	mov    -0x80(%rbp),%eax
     409:	41 89 06             	mov    %eax,(%r14)
     40c:	0f b7 45 84          	movzwl -0x7c(%rbp),%eax
     410:	66 41 89 46 04       	mov    %ax,0x4(%r14)
     415:	bb 03 00 00 00       	mov    $0x3,%ebx
     41a:	e9 c0 16 00 00       	jmp    1adf <balancer_ingress+0x1adf>
     41f:	b2 02                	mov    $0x2,%dl
     421:	b1 01                	mov    $0x1,%cl
     423:	bb 02 00 00 00       	mov    $0x2,%ebx
  if (protocol == IPPROTO_TCP) {
     428:	3c 11                	cmp    $0x11,%al
     42a:	0f 84 52 01 00 00    	je     582 <balancer_ingress+0x582>
     430:	3c 06                	cmp    $0x6,%al
     432:	0f 85 a7 16 00 00    	jne    1adf <balancer_ingress+0x1adf>
  tcp = data + off;
     438:	49 8d 46 66          	lea    0x66(%r14),%rax
  if (is_ipv6) {
     43c:	84 c9                	test   %cl,%cl
  tcp = data + off;
     43e:	49 0f 45 c5          	cmovne %r13,%rax
  if (tcp + 1 > data_end) {
     442:	48 8d 70 14          	lea    0x14(%rax),%rsi
     446:	4c 39 fe             	cmp    %r15,%rsi
     449:	0f 87 8b 16 00 00    	ja     1ada <balancer_ingress+0x1ada>
  if (tcp->syn) {
     44f:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     453:	0f 84 40 01 00 00    	je     599 <balancer_ingress+0x599>
    pckt->flags |= F_SYN_SET;
     459:	88 55 c4             	mov    %dl,-0x3c(%rbp)
     45c:	e9 38 01 00 00       	jmp    599 <balancer_ingress+0x599>
      return FURTHER_PROCESSING;
    } else {
      pckt->flow.src = iph->saddr;
     461:	41 8b 46 1a          	mov    0x1a(%r14),%eax
     465:	89 45 98             	mov    %eax,-0x68(%rbp)
      pckt->flow.dst = iph->daddr;
     468:	41 8b 46 1e          	mov    0x1e(%r14),%eax
     46c:	89 45 a8             	mov    %eax,-0x58(%rbp)
  if (protocol == IPPROTO_ICMPV6) {
     46f:	80 f9 3a             	cmp    $0x3a,%cl
     472:	75 45                	jne    4b9 <balancer_ingress+0x4b9>
  if (icmp_hdr + 1 > data_end) {
     474:	49 8d 46 2a          	lea    0x2a(%r14),%rax
     478:	4c 39 f8             	cmp    %r15,%rax
     47b:	0f 87 59 16 00 00    	ja     1ada <balancer_ingress+0x1ada>
  if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
     481:	41 8a 45 00          	mov    0x0(%r13),%al
     485:	3c 02                	cmp    $0x2,%al
     487:	0f 84 f0 03 00 00    	je     87d <balancer_ingress+0x87d>
     48d:	3c 01                	cmp    $0x1,%al
     48f:	0f 84 22 04 00 00    	je     8b7 <balancer_ingress+0x8b7>
     495:	bb 02 00 00 00       	mov    $0x2,%ebx
     49a:	3c 80                	cmp    $0x80,%al
     49c:	0f 85 3d 16 00 00    	jne    1adf <balancer_ingress+0x1adf>
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4a2:	49 8d 46 3e          	lea    0x3e(%r14),%rax
     4a6:	bb 01 00 00 00       	mov    $0x1,%ebx
       sizeof(struct icmp6hdr)) > data_end) {
     4ab:	4c 39 f8             	cmp    %r15,%rax
  if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
     4ae:	0f 87 2b 16 00 00    	ja     1adf <balancer_ingress+0x1adf>
     4b4:	e9 8b fd ff ff       	jmp    244 <balancer_ingress+0x244>
     4b9:	40 b6 02             	mov    $0x2,%sil
     4bc:	b2 01                	mov    $0x1,%dl
     4be:	bb 02 00 00 00       	mov    $0x2,%ebx
     4c3:	80 f9 11             	cmp    $0x11,%cl
     4c6:	0f 84 39 04 00 00    	je     905 <balancer_ingress+0x905>
     4cc:	80 f9 06             	cmp    $0x6,%cl
     4cf:	0f 85 0a 16 00 00    	jne    1adf <balancer_ingress+0x1adf>
  tcp = data + off;
     4d5:	49 8d 46 3e          	lea    0x3e(%r14),%rax
  if (is_ipv6) {
     4d9:	84 d2                	test   %dl,%dl
  tcp = data + off;
     4db:	49 0f 45 c5          	cmovne %r13,%rax
  if (tcp + 1 > data_end) {
     4df:	48 8d 48 14          	lea    0x14(%rax),%rcx
     4e3:	4c 39 f9             	cmp    %r15,%rcx
     4e6:	0f 87 ee 15 00 00    	ja     1ada <balancer_ingress+0x1ada>
  if (tcp->syn) {
     4ec:	f6 40 0d 02          	testb  $0x2,0xd(%rax)
     4f0:	0f 84 26 04 00 00    	je     91c <balancer_ingress+0x91c>
    pckt->flags |= F_SYN_SET;
     4f6:	40 88 75 c4          	mov    %sil,-0x3c(%rbp)
     4fa:	e9 1d 04 00 00       	jmp    91c <balancer_ingress+0x91c>
     4ff:	48 b8 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rax
     506:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     509:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     510:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     517:	b9 bc 
    if (!icmp_ptb_v6_stats) {
     519:	48 85 c0             	test   %rax,%rax
     51c:	0f 84 b8 15 00 00    	je     1ada <balancer_ingress+0x1ada>
    icmp_ptb_v6_stats->v1 += 1;
     522:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     526:	41 8b 4e 3a          	mov    0x3a(%r14),%ecx
     52a:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     52c:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     532:	77 05                	ja     539 <balancer_ingress+0x539>
      icmp_ptb_v6_stats->v2 += 1;
     534:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     539:	49 8d 46 66          	lea    0x66(%r14),%rax
     53d:	4c 39 f8             	cmp    %r15,%rax
     540:	0f 87 94 15 00 00    	ja     1ada <balancer_ingress+0x1ada>
  pckt->flow.proto = ip6h->nexthdr;
     546:	41 8a 46 44          	mov    0x44(%r14),%al
     54a:	88 45 bc             	mov    %al,-0x44(%rbp)
  pckt->flags |= F_ICMP;
     54d:	c6 45 c4 01          	movb   $0x1,-0x3c(%rbp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     551:	49 8b 4e 56          	mov    0x56(%r14),%rcx
     555:	49 8b 56 5e          	mov    0x5e(%r14),%rdx
     559:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
     55d:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     561:	49 8b 4e 46          	mov    0x46(%r14),%rcx
     565:	49 8b 56 4e          	mov    0x4e(%r14),%rdx
     569:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
     56d:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
     571:	b2 03                	mov    $0x3,%dl
     573:	31 c9                	xor    %ecx,%ecx
     575:	bb 02 00 00 00       	mov    $0x2,%ebx
     57a:	3c 11                	cmp    $0x11,%al
     57c:	0f 85 ae fe ff ff    	jne    430 <balancer_ingress+0x430>
  udp = data + off;
     582:	49 8d 46 66          	lea    0x66(%r14),%rax
  if (is_ipv6) {
     586:	84 c9                	test   %cl,%cl
  udp = data + off;
     588:	49 0f 45 c5          	cmovne %r13,%rax
  if (udp + 1 > data_end) {
     58c:	48 8d 50 08          	lea    0x8(%rax),%rdx
     590:	4c 39 fa             	cmp    %r15,%rdx
     593:	0f 87 41 15 00 00    	ja     1ada <balancer_ingress+0x1ada>
     599:	84 c9                	test   %cl,%cl
     59b:	89 bd 78 ff ff ff    	mov    %edi,-0x88(%rbp)
     5a1:	74 11                	je     5b4 <balancer_ingress+0x5b4>
     5a3:	0f b7 10             	movzwl (%rax),%edx
     5a6:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
     5aa:	66 89 55 b8          	mov    %dx,-0x48(%rbp)
     5ae:	48 83 c0 02          	add    $0x2,%rax
     5b2:	eb 0c                	jmp    5c0 <balancer_ingress+0x5c0>
     5b4:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     5b8:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
     5bc:	66 89 55 b8          	mov    %dx,-0x48(%rbp)
     5c0:	0f b7 00             	movzwl (%rax),%eax
     5c3:	66 89 41 02          	mov    %ax,0x2(%rcx)
    memcpy(vip.vipv6, pckt.flow.dstv6, 16);
     5c7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
     5cb:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
     5cf:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
     5d6:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  vip.port = pckt.flow.port16[1];
     5dd:	0f b7 45 ba          	movzwl -0x46(%rbp),%eax
     5e1:	66 89 85 70 ff ff ff 	mov    %ax,-0x90(%rbp)
  vip.proto = pckt.flow.proto;
     5e8:	8a 45 bc             	mov    -0x44(%rbp),%al
     5eb:	88 85 72 ff ff ff    	mov    %al,-0x8e(%rbp)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     5f1:	48 bf 00 58 72 c4 81 	movabs $0xffff8881c4725800,%rdi
     5f8:	88 ff ff 
     5fb:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
     602:	48 c7 c0 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rax
     609:	ff d0                	call   *%rax
     60b:	48 89 c2             	mov    %rax,%rdx
  if (!vip_info) {
     60e:	48 85 c0             	test   %rax,%rax
     611:	0f 84 0e 01 00 00    	je     725 <balancer_ingress+0x725>
  if (data_end - data > MAX_PCKT_SIZE) {
     617:	4c 89 f8             	mov    %r15,%rax
     61a:	4c 29 f0             	sub    %r14,%rax
     61d:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     623:	0f 8f b1 14 00 00    	jg     1ada <balancer_ingress+0x1ada>
     629:	48 be 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rsi
     630:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     633:	48 8b 9e 00 11 00 00 	mov    0x1100(%rsi),%rbx
     63a:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffbcb95028,%rbx
     641:	b9 bc 
  if (!data_stats) {
     643:	48 85 db             	test   %rbx,%rbx
     646:	0f 84 8e 14 00 00    	je     1ada <balancer_ingress+0x1ada>
  data_stats->v1 += 1;
     64c:	48 83 03 01          	addq   $0x1,(%rbx)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     650:	f6 02 01             	testb  $0x1,(%rdx)
     653:	74 06                	je     65b <balancer_ingress+0x65b>
    pckt.flow.port16[0] = 0;
     655:	66 c7 45 b8 00 00    	movw   $0x0,-0x48(%rbp)
  vip_num = vip_info->vip_num;
     65b:	44 8b 52 04          	mov    0x4(%rdx),%r10d
     65f:	48 c7 c0 34 50 b9 bc 	mov    $0xffffffffbcb95034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     666:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     66d:	b9 bc 
     66f:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     672:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     677:	44 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%r8d
     67e:	0f 84 55 01 00 00    	je     7d9 <balancer_ingress+0x7d9>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     684:	48 8b 86 18 11 00 00 	mov    0x1118(%rsi),%rax
     68b:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     692:	b9 bc 
    if (!lru_stats) {
     694:	48 85 c0             	test   %rax,%rax
     697:	0f 84 3d 14 00 00    	je     1ada <balancer_ingress+0x1ada>
    lru_stats->v1 += 1;
     69d:	48 83 00 01          	addq   $0x1,(%rax)
     6a1:	48 b8 00 60 72 c4 81 	movabs $0xffff8881c4726000,%rax
     6a8:	88 ff ff 
     6ab:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     6af:	e9 46 01 00 00       	jmp    7fa <balancer_ingress+0x7fa>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     6b4:	41 80 7e 37 04       	cmpb   $0x4,0x37(%r14)
     6b9:	75 33                	jne    6ee <balancer_ingress+0x6ee>
     6bb:	48 b9 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rcx
     6c2:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     6c5:	48 8b 89 68 11 00 00 	mov    0x1168(%rcx),%rcx
     6cc:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffbcb95028,%rcx
     6d3:	b9 bc 
    if (!icmp_ptb_v4_stats) {
     6d5:	48 85 c9             	test   %rcx,%rcx
     6d8:	0f 84 fc 13 00 00    	je     1ada <balancer_ingress+0x1ada>
    icmp_ptb_v4_stats->v1 += 1;
     6de:	48 83 01 01          	addq   $0x1,(%rcx)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     6e2:	41 80 7e 3c 04       	cmpb   $0x4,0x3c(%r14)
     6e7:	77 05                	ja     6ee <balancer_ingress+0x6ee>
      icmp_ptb_v4_stats->v2 += 1;
     6e9:	48 83 41 08 01       	addq   $0x1,0x8(%rcx)
  if (iph + 1 > data_end) {
     6ee:	49 8d 4e 52          	lea    0x52(%r14),%rcx
     6f2:	4c 39 f9             	cmp    %r15,%rcx
     6f5:	0f 87 df 13 00 00    	ja     1ada <balancer_ingress+0x1ada>
  if (iph->ihl != 5) {
     6fb:	8a 00                	mov    (%rax),%al
     6fd:	24 0f                	and    $0xf,%al
     6ff:	3c 05                	cmp    $0x5,%al
     701:	0f 85 d3 13 00 00    	jne    1ada <balancer_ingress+0x1ada>
  pckt->flow.proto = iph->protocol;
     707:	41 8a 46 47          	mov    0x47(%r14),%al
     70b:	88 45 bc             	mov    %al,-0x44(%rbp)
  pckt->flags |= F_ICMP;
     70e:	c6 45 c4 01          	movb   $0x1,-0x3c(%rbp)
  pckt->flow.src = iph->daddr;
     712:	41 8b 4e 4e          	mov    0x4e(%r14),%ecx
     716:	89 4d 98             	mov    %ecx,-0x68(%rbp)
  pckt->flow.dst = iph->saddr;
     719:	41 8b 4e 4a          	mov    0x4a(%r14),%ecx
     71d:	89 4d a8             	mov    %ecx,-0x58(%rbp)
     720:	e9 4c fe ff ff       	jmp    571 <balancer_ingress+0x571>
    vip.port = 0;
     725:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%rbp)
     72c:	00 00 
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     72e:	48 bf 00 58 72 c4 81 	movabs $0xffff8881c4725800,%rdi
     735:	88 ff ff 
     738:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
     73f:	48 c7 c0 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rax
     746:	ff d0                	call   *%rax
    if (!vip_info) {
     748:	48 85 c0             	test   %rax,%rax
     74b:	0f 84 8e 13 00 00    	je     1adf <balancer_ingress+0x1adf>
     751:	48 89 c2             	mov    %rax,%rdx
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     754:	f6 00 88             	testb  $0x88,(%rax)
     757:	0f 85 ba fe ff ff    	jne    617 <balancer_ingress+0x617>
      pckt.flow.port16[1] = 0;
     75d:	66 c7 45 ba 00 00    	movw   $0x0,-0x46(%rbp)
     763:	e9 af fe ff ff       	jmp    617 <balancer_ingress+0x617>
  if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
     768:	41 80 7e 23 04       	cmpb   $0x4,0x23(%r14)
     76d:	75 33                	jne    7a2 <balancer_ingress+0x7a2>
     76f:	48 b8 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rax
     776:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     779:	48 8b 80 68 11 00 00 	mov    0x1168(%rax),%rax
     780:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     787:	b9 bc 
    if (!icmp_ptb_v4_stats) {
     789:	48 85 c0             	test   %rax,%rax
     78c:	0f 84 48 13 00 00    	je     1ada <balancer_ingress+0x1ada>
    icmp_ptb_v4_stats->v1 += 1;
     792:	48 83 00 01          	addq   $0x1,(%rax)
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     796:	41 80 7e 28 04       	cmpb   $0x4,0x28(%r14)
     79b:	77 05                	ja     7a2 <balancer_ingress+0x7a2>
      icmp_ptb_v4_stats->v2 += 1;
     79d:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (iph + 1 > data_end) {
     7a2:	49 8d 46 3e          	lea    0x3e(%r14),%rax
     7a6:	4c 39 f8             	cmp    %r15,%rax
     7a9:	0f 87 2b 13 00 00    	ja     1ada <balancer_ingress+0x1ada>
  if (iph->ihl != 5) {
     7af:	8a 01                	mov    (%rcx),%al
     7b1:	24 0f                	and    $0xf,%al
     7b3:	3c 05                	cmp    $0x5,%al
     7b5:	0f 85 1f 13 00 00    	jne    1ada <balancer_ingress+0x1ada>
  pckt->flow.proto = iph->protocol;
     7bb:	41 8a 4e 33          	mov    0x33(%r14),%cl
     7bf:	88 4d bc             	mov    %cl,-0x44(%rbp)
  pckt->flags |= F_ICMP;
     7c2:	c6 45 c4 01          	movb   $0x1,-0x3c(%rbp)
  pckt->flow.src = iph->daddr;
     7c6:	41 8b 46 3a          	mov    0x3a(%r14),%eax
     7ca:	89 45 98             	mov    %eax,-0x68(%rbp)
  pckt->flow.dst = iph->saddr;
     7cd:	41 8b 46 36          	mov    0x36(%r14),%eax
     7d1:	89 45 a8             	mov    %eax,-0x58(%rbp)
     7d4:	e9 19 01 00 00       	jmp    8f2 <balancer_ingress+0x8f2>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     7d9:	89 c0                	mov    %eax,%eax
     7db:	48 b9 00 60 2d 1f 81 	movabs $0xffff88811f2d6000,%rcx
     7e2:	88 ff ff 
     7e5:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     7ec:	00 
     7ed:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  if (!lru_map) {
     7f1:	48 85 c0             	test   %rax,%rax
     7f4:	0f 84 8a fe ff ff    	je     684 <balancer_ingress+0x684>
     7fa:	48 89 9d 48 ff ff ff 	mov    %rbx,-0xb8(%rbp)
  if ((vip_info->flags & F_QUIC_VIP)) {
     801:	f6 02 04             	testb  $0x4,(%rdx)
     804:	0f 84 a9 0c 00 00    	je     14b3 <balancer_ingress+0x14b3>
    bool is_icmp = (pckt.flags & F_ICMP);
     80a:	f6 45 c4 01          	testb  $0x1,-0x3c(%rbp)
    if (is_icmp) {
     80e:	0f 85 60 02 00 00    	jne    a74 <balancer_ingress+0xa74>
     814:	48 b8 00 7c 69 08 81 	movabs $0xffff888108697c00,%rax
     81b:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     81e:	48 8b 98 00 01 00 00 	mov    0x100(%rax),%rbx
     825:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffbcb95028,%rbx
     82c:	b9 bc 
      if (!quic_packets_stats) {
     82e:	48 85 db             	test   %rbx,%rbx
     831:	0f 84 a3 12 00 00    	je     1ada <balancer_ingress+0x1ada>
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     837:	49 83 c6 66          	add    $0x66,%r14
  bool is_icmp = (pckt->flags & F_ICMP);
     83b:	f6 45 c4 01          	testb  $0x1,-0x3c(%rbp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     83f:	4d 0f 44 f5          	cmove  %r13,%r14
     843:	49 8d 46 09          	lea    0x9(%r14),%rax
     847:	4c 39 f8             	cmp    %r15,%rax
     84a:	0f 87 5f 0c 00 00    	ja     14af <balancer_ingress+0x14af>
     850:	49 89 d1             	mov    %rdx,%r9
     853:	4c 89 55 c8          	mov    %r10,-0x38(%rbp)
     857:	45 89 c5             	mov    %r8d,%r13d
     85a:	49 83 c6 08          	add    $0x8,%r14
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     85e:	41 0f b6 0e          	movzbl (%r14),%ecx
     862:	f6 c1 80             	test   $0x80,%cl
     865:	0f 85 6c 03 00 00    	jne    bd7 <balancer_ingress+0xbd7>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     86b:	49 83 c6 09          	add    $0x9,%r14
     86f:	4d 39 fe             	cmp    %r15,%r14
     872:	0f 86 a1 04 00 00    	jbe    d19 <balancer_ingress+0xd19>
     878:	e9 1e 0c 00 00       	jmp    149b <balancer_ingress+0x149b>
     87d:	48 b8 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rax
     884:	88 ff ff 
        bpf_map_lookup_elem(&stats, &stats_key);
     887:	48 8b 80 60 11 00 00 	mov    0x1160(%rax),%rax
     88e:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     895:	b9 bc 
    if (!icmp_ptb_v6_stats) {
     897:	48 85 c0             	test   %rax,%rax
     89a:	0f 84 3a 12 00 00    	je     1ada <balancer_ingress+0x1ada>
    icmp_ptb_v6_stats->v1 += 1;
     8a0:	48 83 00 01          	addq   $0x1,(%rax)
    __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
     8a4:	41 8b 4e 26          	mov    0x26(%r14),%ecx
     8a8:	0f c9                	bswap  %ecx
    if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
     8aa:	81 f9 ff 04 00 00    	cmp    $0x4ff,%ecx
     8b0:	77 05                	ja     8b7 <balancer_ingress+0x8b7>
      icmp_ptb_v6_stats->v2 += 1;
     8b2:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
  if (ip6h + 1 > data_end) {
     8b7:	49 8d 46 52          	lea    0x52(%r14),%rax
     8bb:	4c 39 f8             	cmp    %r15,%rax
     8be:	0f 87 16 12 00 00    	ja     1ada <balancer_ingress+0x1ada>
     8c4:	48 8d 45 a8          	lea    -0x58(%rbp),%rax
  pckt->flow.proto = ip6h->nexthdr;
     8c8:	41 8a 4e 30          	mov    0x30(%r14),%cl
     8cc:	88 4d bc             	mov    %cl,-0x44(%rbp)
  pckt->flags |= F_ICMP;
     8cf:	c6 45 c4 01          	movb   $0x1,-0x3c(%rbp)
  memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
     8d3:	49 8b 56 42          	mov    0x42(%r14),%rdx
     8d7:	49 8b 76 4a          	mov    0x4a(%r14),%rsi
     8db:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
     8df:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
     8e3:	49 8b 56 32          	mov    0x32(%r14),%rdx
     8e7:	49 8b 76 3a          	mov    0x3a(%r14),%rsi
     8eb:	48 89 10             	mov    %rdx,(%rax)
     8ee:	48 89 70 08          	mov    %rsi,0x8(%rax)
     8f2:	40 b6 03             	mov    $0x3,%sil
     8f5:	31 d2                	xor    %edx,%edx
     8f7:	bb 02 00 00 00       	mov    $0x2,%ebx
  if (protocol == IPPROTO_TCP) {
     8fc:	80 f9 11             	cmp    $0x11,%cl
     8ff:	0f 85 c7 fb ff ff    	jne    4cc <balancer_ingress+0x4cc>
  udp = data + off;
     905:	49 8d 46 3e          	lea    0x3e(%r14),%rax
  if (is_ipv6) {
     909:	84 d2                	test   %dl,%dl
  udp = data + off;
     90b:	49 0f 45 c5          	cmovne %r13,%rax
  if (udp + 1 > data_end) {
     90f:	48 8d 48 08          	lea    0x8(%rax),%rcx
     913:	4c 39 f9             	cmp    %r15,%rcx
     916:	0f 87 be 11 00 00    	ja     1ada <balancer_ingress+0x1ada>
     91c:	84 d2                	test   %dl,%dl
     91e:	66 89 bd 78 ff ff ff 	mov    %di,-0x88(%rbp)
     925:	74 11                	je     938 <balancer_ingress+0x938>
     927:	0f b7 10             	movzwl (%rax),%edx
     92a:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
     92e:	66 89 55 b8          	mov    %dx,-0x48(%rbp)
     932:	48 83 c0 02          	add    $0x2,%rax
     936:	eb 0c                	jmp    944 <balancer_ingress+0x944>
     938:	0f b7 50 02          	movzwl 0x2(%rax),%edx
     93c:	48 8d 4d b8          	lea    -0x48(%rbp),%rcx
     940:	66 89 55 b8          	mov    %dx,-0x48(%rbp)
     944:	0f b7 00             	movzwl (%rax),%eax
     947:	66 89 41 02          	mov    %ax,0x2(%rcx)
    vip.vip = pckt.flow.dst;
     94b:	8b 45 a8             	mov    -0x58(%rbp),%eax
     94e:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
  vip.port = pckt.flow.port16[1];
     954:	0f b7 45 ba          	movzwl -0x46(%rbp),%eax
     958:	66 89 85 70 ff ff ff 	mov    %ax,-0x90(%rbp)
  vip.proto = pckt.flow.proto;
     95f:	8a 45 bc             	mov    -0x44(%rbp),%al
     962:	88 85 72 ff ff ff    	mov    %al,-0x8e(%rbp)
  vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     968:	48 bf 00 58 72 c4 81 	movabs $0xffff8881c4725800,%rdi
     96f:	88 ff ff 
     972:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
     979:	48 c7 c0 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rax
     980:	ff d0                	call   *%rax
     982:	48 89 c6             	mov    %rax,%rsi
  if (!vip_info) {
     985:	48 85 c0             	test   %rax,%rax
     988:	0f 84 a3 00 00 00    	je     a31 <balancer_ingress+0xa31>
  if (data_end - data > MAX_PCKT_SIZE) {
     98e:	4c 89 f8             	mov    %r15,%rax
     991:	4c 29 f0             	sub    %r14,%rax
     994:	48 3d ea 05 00 00    	cmp    $0x5ea,%rax
     99a:	0f 8f 3a 11 00 00    	jg     1ada <balancer_ingress+0x1ada>
     9a0:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
     9a7:	88 ff ff 
  data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     9aa:	48 8b 82 00 11 00 00 	mov    0x1100(%rdx),%rax
     9b1:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     9b8:	b9 bc 
  if (!data_stats) {
     9ba:	48 85 c0             	test   %rax,%rax
     9bd:	0f 84 17 11 00 00    	je     1ada <balancer_ingress+0x1ada>
     9c3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  data_stats->v1 += 1;
     9c7:	48 83 00 01          	addq   $0x1,(%rax)
  if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
     9cb:	f6 06 01             	testb  $0x1,(%rsi)
     9ce:	74 06                	je     9d6 <balancer_ingress+0x9d6>
    pckt.flow.port16[0] = 0;
     9d0:	66 c7 45 b8 00 00    	movw   $0x0,-0x48(%rbp)
  vip_num = vip_info->vip_num;
     9d6:	8b 46 04             	mov    0x4(%rsi),%eax
     9d9:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
     9e0:	48 c7 c0 34 50 b9 bc 	mov    $0xffffffffbcb95034,%rax
  __u32 cpu_num = bpf_get_smp_processor_id();
     9e7:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     9ee:	b9 bc 
     9f0:	48 8b 00             	mov    (%rax),%rax
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     9f3:	a9 80 ff ff ff       	test   $0xffffff80,%eax
     9f8:	0f 84 aa 00 00 00    	je     aa8 <balancer_ingress+0xaa8>
    struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
     9fe:	48 8b 82 18 11 00 00 	mov    0x1118(%rdx),%rax
     a05:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     a0c:	b9 bc 
    if (!lru_stats) {
     a0e:	48 85 c0             	test   %rax,%rax
     a11:	0f 84 c3 10 00 00    	je     1ada <balancer_ingress+0x1ada>
    lru_stats->v1 += 1;
     a17:	48 83 00 01          	addq   $0x1,(%rax)
     a1b:	48 b8 00 60 72 c4 81 	movabs $0xffff8881c4726000,%rax
     a22:	88 ff ff 
     a25:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
     a2c:	e9 9b 00 00 00       	jmp    acc <balancer_ingress+0xacc>
    vip.port = 0;
     a31:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%rbp)
     a38:	00 00 
    vip_info = bpf_map_lookup_elem(&vip_map, &vip);
     a3a:	48 bf 00 58 72 c4 81 	movabs $0xffff8881c4725800,%rdi
     a41:	88 ff ff 
     a44:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
     a4b:	48 c7 c0 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rax
     a52:	ff d0                	call   *%rax
    if (!vip_info) {
     a54:	48 85 c0             	test   %rax,%rax
     a57:	0f 84 82 10 00 00    	je     1adf <balancer_ingress+0x1adf>
     a5d:	48 89 c6             	mov    %rax,%rsi
    if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
     a60:	f6 00 88             	testb  $0x88,(%rax)
     a63:	0f 85 25 ff ff ff    	jne    98e <balancer_ingress+0x98e>
      pckt.flow.port16[1] = 0;
     a69:	66 c7 45 ba 00 00    	movw   $0x0,-0x46(%rbp)
     a6f:	e9 1a ff ff ff       	jmp    98e <balancer_ingress+0x98e>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     a74:	48 8b 9e 58 11 00 00 	mov    0x1158(%rsi),%rbx
     a7b:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffbcb95028,%rbx
     a82:	b9 bc 
      if (!data_stats) {
     a84:	48 85 db             	test   %rbx,%rbx
     a87:	0f 84 4d 10 00 00    	je     1ada <balancer_ingress+0x1ada>
      data_stats->v1 += 1;
     a8d:	48 83 03 01          	addq   $0x1,(%rbx)
        (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
     a91:	41 8a 46 37          	mov    0x37(%r14),%al
     a95:	04 fd                	add    $0xfd,%al
     a97:	3c 01                	cmp    $0x1,%al
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     a99:	0f 87 14 0a 00 00    	ja     14b3 <balancer_ingress+0x14b3>
        data_stats->v2 += 1;
     a9f:	48 83 c3 08          	add    $0x8,%rbx
     aa3:	e9 07 0a 00 00       	jmp    14af <balancer_ingress+0x14af>
  void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
     aa8:	89 c0                	mov    %eax,%eax
     aaa:	48 b9 00 60 2d 1f 81 	movabs $0xffff88811f2d6000,%rcx
     ab1:	88 ff ff 
     ab4:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
     abb:	00 
     abc:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  if (!lru_map) {
     ac3:	48 85 c0             	test   %rax,%rax
     ac6:	0f 84 32 ff ff ff    	je     9fe <balancer_ingress+0x9fe>
  if ((vip_info->flags & F_QUIC_VIP)) {
     acc:	f6 06 04             	testb  $0x4,(%rsi)
     acf:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
     ad3:	0f 84 95 00 00 00    	je     b6e <balancer_ingress+0xb6e>
    bool is_icmp = (pckt.flags & F_ICMP);
     ad9:	f6 45 c4 01          	testb  $0x1,-0x3c(%rbp)
    if (is_icmp) {
     add:	75 4f                	jne    b2e <balancer_ingress+0xb2e>
     adf:	48 b8 00 7c 69 08 81 	movabs $0xffff888108697c00,%rax
     ae6:	88 ff ff 
          bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
     ae9:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
     af0:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     af7:	b9 bc 
      if (!quic_packets_stats) {
     af9:	48 85 c0             	test   %rax,%rax
     afc:	0f 84 d8 0f 00 00    	je     1ada <balancer_ingress+0x1ada>
     b02:	48 89 c3             	mov    %rax,%rbx
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b05:	49 83 c6 3e          	add    $0x3e,%r14
  bool is_icmp = (pckt->flags & F_ICMP);
     b09:	f6 45 c4 01          	testb  $0x1,-0x3c(%rbp)
  if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
     b0d:	4d 0f 44 f5          	cmove  %r13,%r14
     b11:	49 8d 46 09          	lea    0x9(%r14),%rax
     b15:	4c 39 f8             	cmp    %r15,%rax
     b18:	0f 86 1e 01 00 00    	jbe    c3c <balancer_ingress+0xc3c>
     b1e:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
     b25:	88 ff ff 
     b28:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
     b2c:	eb 3c                	jmp    b6a <balancer_ingress+0xb6a>
      struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
     b2e:	48 8b 82 58 11 00 00 	mov    0x1158(%rdx),%rax
     b35:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     b3c:	b9 bc 
      if (!data_stats) {
     b3e:	48 85 c0             	test   %rax,%rax
     b41:	0f 84 93 0f 00 00    	je     1ada <balancer_ingress+0x1ada>
     b47:	48 89 c3             	mov    %rax,%rbx
      data_stats->v1 += 1;
     b4a:	48 83 00 01          	addq   $0x1,(%rax)
        (icmp_hdr->code == ICMP_PORT_UNREACH) ||
     b4e:	41 8a 46 23          	mov    0x23(%r14),%al
     b52:	24 fd                	and    $0xfd,%al
     b54:	3c 01                	cmp    $0x1,%al
     b56:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
     b5d:	88 ff ff 
     b60:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
      if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
     b64:	75 08                	jne    b6e <balancer_ingress+0xb6e>
        data_stats->v2 += 1;
     b66:	48 83 c3 08          	add    $0x8,%rbx
     b6a:	48 83 03 01          	addq   $0x1,(%rbx)
  original_sport = pckt.flow.port16[0];
     b6e:	44 0f b7 7d b8       	movzwl -0x48(%rbp),%r15d
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     b73:	f6 45 c4 02          	testb  $0x2,-0x3c(%rbp)
     b77:	75 56                	jne    bcf <balancer_ingress+0xbcf>
        !(vip_info->flags & F_LRU_BYPASS)) {
     b79:	f6 06 02             	testb  $0x2,(%rsi)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
     b7c:	75 49                	jne    bc7 <balancer_ingress+0xbc7>
     b7e:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
     b82:	48 c7 c0 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rax
     b89:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
     b90:	ff d0                	call   *%rax
  if (!dst_lru) {
     b92:	48 85 c0             	test   %rax,%rax
     b95:	74 30                	je     bc7 <balancer_ingress+0xbc7>
     b97:	49 89 c6             	mov    %rax,%r14
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
     b9a:	80 7d bc 11          	cmpb   $0x11,-0x44(%rbp)
     b9e:	0f 85 c1 01 00 00    	jne    d65 <balancer_ingress+0xd65>
     ba4:	48 c7 c0 30 d6 e9 b6 	mov    $0xffffffffb6e9d630,%rax
    cur_time = bpf_ktime_get_ns();
     bab:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
     bad:	48 89 c1             	mov    %rax,%rcx
     bb0:	49 2b 4e 08          	sub    0x8(%r14),%rcx
     bb4:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
     bbb:	00 00 00 
     bbe:	48 39 d1             	cmp    %rdx,%rcx
     bc1:	0f 86 9a 01 00 00    	jbe    d61 <balancer_ingress+0xd61>
     bc7:	45 31 f6             	xor    %r14d,%r14d
     bca:	e9 bf 01 00 00       	jmp    d8e <balancer_ingress+0xd8e>
     bcf:	45 31 f6             	xor    %r14d,%r14d
     bd2:	e9 c5 01 00 00       	jmp    d9c <balancer_ingress+0xd9c>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     bd7:	49 8d 46 0e          	lea    0xe(%r14),%rax
     bdb:	4c 39 f8             	cmp    %r15,%rax
     bde:	0f 87 b7 08 00 00    	ja     149b <balancer_ingress+0x149b>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     be4:	f6 c1 20             	test   $0x20,%cl
     be7:	0f 85 1a 01 00 00    	jne    d07 <balancer_ingress+0xd07>
        quic_packets_stats->cid_initial += 1;
     bed:	48 83 43 08 01       	addq   $0x1,0x8(%rbx)
     bf2:	4c 8b 55 c8          	mov    -0x38(%rbp),%r10
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     bf6:	41 81 fa ff 01 00 00 	cmp    $0x1ff,%r10d
     bfd:	45 89 e8             	mov    %r13d,%r8d
     c00:	48 be 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rsi
     c07:	88 ff ff 
     c0a:	4c 89 ca             	mov    %r9,%rdx
     c0d:	0f 87 a0 08 00 00    	ja     14b3 <balancer_ingress+0x14b3>
     c13:	48 b8 00 00 69 26 81 	movabs $0xffff888126690000,%rax
     c1a:	88 ff ff 
     c1d:	4a 8b 9c d0 00 01 00 	mov    0x100(%rax,%r10,8),%rbx
     c24:	00 
     c25:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffbcb95028,%rbx
     c2c:	b9 bc 
  if (!per_vip_stats) {
     c2e:	48 85 db             	test   %rbx,%rbx
     c31:	0f 85 78 08 00 00    	jne    14af <balancer_ingress+0x14af>
     c37:	e9 77 08 00 00       	jmp    14b3 <balancer_ingress+0x14b3>
     c3c:	49 83 c6 08          	add    $0x8,%r14
  if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
     c40:	41 0f b6 0e          	movzbl (%r14),%ecx
     c44:	f6 c1 80             	test   $0x80,%cl
     c47:	75 55                	jne    c9e <balancer_ingress+0xc9e>
    if (quic_data + sizeof(struct quic_short_header) > data_end) {
     c49:	49 83 c6 09          	add    $0x9,%r14
     c4d:	4d 39 fe             	cmp    %r15,%r14
     c50:	0f 87 c8 fe ff ff    	ja     b1e <balancer_ingress+0xb1e>
  if (!connId) {
     c56:	48 85 c0             	test   %rax,%rax
     c59:	0f 84 bf fe ff ff    	je     b1e <balancer_ingress+0xb1e>
  __u8 connIdVersion = (connId[0] >> 6);
     c5f:	0f b6 08             	movzbl (%rax),%ecx
     c62:	89 ca                	mov    %ecx,%edx
     c64:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     c67:	80 fa 03             	cmp    $0x3,%dl
     c6a:	0f 84 71 10 00 00    	je     1ce1 <balancer_ingress+0x1ce1>
     c70:	80 fa 02             	cmp    $0x2,%dl
     c73:	0f 84 8d 10 00 00    	je     1d06 <balancer_ingress+0x1d06>
     c79:	80 fa 01             	cmp    $0x1,%dl
     c7c:	0f 85 9c fe ff ff    	jne    b1e <balancer_ingress+0xb1e>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     c82:	83 e1 3f             	and    $0x3f,%ecx
     c85:	48 c1 e1 0a          	shl    $0xa,%rcx
     c89:	0f b6 50 01          	movzbl 0x1(%rax),%edx
     c8d:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
     c91:	8a 40 02             	mov    0x2(%rax),%al
     c94:	c0 e8 06             	shr    $0x6,%al
     c97:	b2 01                	mov    $0x1,%dl
     c99:	e9 80 10 00 00       	jmp    1d1e <balancer_ingress+0x1d1e>
    if (quic_data + sizeof(struct quic_long_header) > data_end) {
     c9e:	49 8d 46 0e          	lea    0xe(%r14),%rax
     ca2:	4c 39 f8             	cmp    %r15,%rax
     ca5:	0f 87 73 fe ff ff    	ja     b1e <balancer_ingress+0xb1e>
    if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
     cab:	f6 c1 20             	test   $0x20,%cl
     cae:	0f 85 25 07 00 00    	jne    13d9 <balancer_ingress+0x13d9>
        quic_packets_stats->cid_initial += 1;
     cb4:	48 83 43 08 01       	addq   $0x1,0x8(%rbx)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
     cb9:	81 bd 48 ff ff ff ff 	cmpl   $0x1ff,-0xb8(%rbp)
     cc0:	01 00 00 
     cc3:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
     cca:	88 ff ff 
     ccd:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
     cd1:	0f 87 97 fe ff ff    	ja     b6e <balancer_ingress+0xb6e>
     cd7:	48 b8 00 00 69 26 81 	movabs $0xffff888126690000,%rax
     cde:	88 ff ff 
     ce1:	48 8b 8d 48 ff ff ff 	mov    -0xb8(%rbp),%rcx
     ce8:	48 8b 9c c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rbx
     cef:	00 
     cf0:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffbcb95028,%rbx
     cf7:	b9 bc 
  if (!per_vip_stats) {
     cf9:	48 85 db             	test   %rbx,%rbx
     cfc:	0f 85 68 fe ff ff    	jne    b6a <balancer_ingress+0xb6a>
     d02:	e9 67 fe ff ff       	jmp    b6e <balancer_ingress+0xb6e>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
     d07:	41 80 7e 05 08       	cmpb   $0x8,0x5(%r14)
     d0c:	0f 82 89 07 00 00    	jb     149b <balancer_ingress+0x149b>
     d12:	49 83 c6 06          	add    $0x6,%r14
     d16:	4c 89 f0             	mov    %r14,%rax
  if (!connId) {
     d19:	48 85 c0             	test   %rax,%rax
     d1c:	0f 84 79 07 00 00    	je     149b <balancer_ingress+0x149b>
  __u8 connIdVersion = (connId[0] >> 6);
     d22:	0f b6 08             	movzbl (%rax),%ecx
     d25:	89 ca                	mov    %ecx,%edx
     d27:	c0 ea 06             	shr    $0x6,%dl
  if (connIdVersion == QUIC_CONNID_VERSION_V1) {
     d2a:	80 fa 03             	cmp    $0x3,%dl
     d2d:	0f 84 52 05 00 00    	je     1285 <balancer_ingress+0x1285>
     d33:	80 fa 02             	cmp    $0x2,%dl
     d36:	0f 84 6e 05 00 00    	je     12aa <balancer_ingress+0x12aa>
     d3c:	80 fa 01             	cmp    $0x1,%dl
     d3f:	0f 85 56 07 00 00    	jne    149b <balancer_ingress+0x149b>
        ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
     d45:	83 e1 3f             	and    $0x3f,%ecx
     d48:	48 c1 e1 0a          	shl    $0xa,%rcx
     d4c:	0f b6 50 01          	movzbl 0x1(%rax),%edx
     d50:	48 8d 0c 91          	lea    (%rcx,%rdx,4),%rcx
     d54:	8a 40 02             	mov    0x2(%rax),%al
     d57:	c0 e8 06             	shr    $0x6,%al
     d5a:	b2 01                	mov    $0x1,%dl
     d5c:	e9 61 05 00 00       	jmp    12c2 <balancer_ingress+0x12c2>
    dst_lru->atime = cur_time;
     d61:	49 89 46 08          	mov    %rax,0x8(%r14)
  key = dst_lru->pos;
     d65:	41 8b 06             	mov    (%r14),%eax
     d68:	45 31 f6             	xor    %r14d,%r14d
     d6b:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
     d71:	89 45 c0             	mov    %eax,-0x40(%rbp)
  *real = bpf_map_lookup_elem(&reals, &key);
     d74:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
     d78:	48 b9 00 c0 d4 08 00 	movabs $0xffffc90008d4c000,%rcx
     d7f:	c9 ff ff 
     d82:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
     d89:	00 
     d8a:	4c 0f 42 f0          	cmovb  %rax,%r14
     d8e:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
     d95:	88 ff ff 
     d98:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
     d9c:	80 7d bc 11          	cmpb   $0x11,-0x44(%rbp)
     da0:	0f 85 c8 00 00 00    	jne    e6e <balancer_ingress+0xe6e>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
     da6:	f6 46 01 02          	testb  $0x2,0x1(%rsi)
     daa:	0f 84 be 00 00 00    	je     e6e <balancer_ingress+0xe6e>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
     db0:	48 8b 9a 10 11 00 00 	mov    0x1110(%rdx),%rbx
     db7:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffbcb95028,%rbx
     dbe:	b9 bc 
  if (!conn_rate_stats) {
     dc0:	48 85 db             	test   %rbx,%rbx
     dc3:	0f 84 a5 00 00 00    	je     e6e <balancer_ingress+0xe6e>
     dc9:	48 c7 c0 30 d6 e9 b6 	mov    $0xffffffffb6e9d630,%rax
  *cur_time = bpf_ktime_get_ns();
     dd0:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
     dd2:	48 89 c1             	mov    %rax,%rcx
     dd5:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
     dd9:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
     de0:	72 0d                	jb     def <balancer_ingress+0xdef>
    conn_rate_stats->v1 = 1;
     de2:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
     de9:	48 89 43 08          	mov    %rax,0x8(%rbx)
     ded:	eb 1c                	jmp    e0b <balancer_ingress+0xe0b>
    conn_rate_stats->v1 += 1;
     def:	48 8b 03             	mov    (%rbx),%rax
     df2:	48 83 c0 01          	add    $0x1,%rax
     df6:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
     df9:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
     dff:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
     e06:	88 ff ff 
     e09:	77 63                	ja     e6e <balancer_ingress+0xe6e>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
     e0b:	48 bf 00 78 72 c4 81 	movabs $0xffff8881c4727800,%rdi
     e12:	88 ff ff 
     e15:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
     e1c:	48 c7 c3 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rbx
     e23:	ff d3                	call   *%rbx
     e25:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
     e2c:	88 ff ff 
    if (down_reals_map) {
     e2f:	48 85 c0             	test   %rax,%rax
     e32:	74 3a                	je     e6e <balancer_ingress+0xe6e>
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
     e34:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
     e38:	48 89 c7             	mov    %rax,%rdi
     e3b:	ff d3                	call   *%rbx
     e3d:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
     e44:	88 ff ff 
      if (down_real) {
     e47:	48 85 c0             	test   %rax,%rax
     e4a:	74 22                	je     e6e <balancer_ingress+0xe6e>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
     e4c:	48 8b 82 78 11 00 00 	mov    0x1178(%rdx),%rax
     e53:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
     e5a:	b9 bc 
        if (stats_data) {
     e5c:	48 85 c0             	test   %rax,%rax
     e5f:	0f 84 8f 01 00 00    	je     ff4 <balancer_ingress+0xff4>
          stats_data->v1 += 1;
     e65:	48 83 00 01          	addq   $0x1,(%rax)
     e69:	e9 86 01 00 00       	jmp    ff4 <balancer_ingress+0xff4>
    if (!dst) {
     e6e:	4d 85 f6             	test   %r14,%r14
     e71:	0f 84 7d 01 00 00    	je     ff4 <balancer_ingress+0xff4>
     e77:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
     e7e:	3d ff 03 00 00       	cmp    $0x3ff,%eax
     e83:	0f 87 51 0c 00 00    	ja     1ada <balancer_ingress+0x1ada>
     e89:	48 8b 8c c2 00 01 00 	mov    0x100(%rdx,%rax,8),%rcx
     e90:	00 
     e91:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffbcb95028,%rcx
     e98:	b9 bc 
  if (!data_stats) {
     e9a:	48 85 c9             	test   %rcx,%rcx
     e9d:	0f 84 37 0c 00 00    	je     1ada <balancer_ingress+0x1ada>
     ea3:	0f b7 85 78 ff ff ff 	movzwl -0x88(%rbp),%eax
     eaa:	41 89 c5             	mov    %eax,%r13d
     ead:	66 41 c1 c5 08       	rol    $0x8,%r13w
  data_stats->v1 += 1;
     eb2:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
     eb6:	41 0f b7 c5          	movzwl %r13w,%eax
     eba:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
     ebe:	8b 4d c0             	mov    -0x40(%rbp),%ecx
     ec1:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
     ec8:	0f 87 0c 0c 00 00    	ja     1ada <balancer_ingress+0x1ada>
     ece:	48 ba 00 b0 a2 08 00 	movabs $0xffffc90008a2b000,%rdx
     ed5:	c9 ff ff 
     ed8:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
     edf:	00 
     ee0:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffbcb95028,%rcx
     ee7:	b9 bc 
  if (!data_stats) {
     ee9:	48 85 c9             	test   %rcx,%rcx
     eec:	0f 84 e8 0b 00 00    	je     1ada <balancer_ingress+0x1ada>
  data_stats->v1 += 1;
     ef2:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
     ef6:	48 01 41 08          	add    %rax,0x8(%rcx)
  pckt.flow.port16[0] = original_sport;
     efa:	66 44 89 7d b8       	mov    %r15w,-0x48(%rbp)
  if (dst->flags & F_IPV6) {
     eff:	41 f6 46 10 01       	testb  $0x1,0x10(%r14)
     f04:	0f 85 d2 02 00 00    	jne    11dc <balancer_ingress+0x11dc>
  void* data;
  void* data_end;
  struct iphdr* iph;
  struct ethhdr* new_eth;
  struct ethhdr* old_eth;
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
     f0a:	0f b7 45 9a          	movzwl -0x66(%rbp),%eax
     f0e:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
     f15:	48 c7 c0 20 5c 03 b9 	mov    $0xffffffffb9035c20,%rax
  __u64 csum = 0;
  // ipip encap
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
     f1c:	4c 89 e7             	mov    %r12,%rdi
     f1f:	be ec ff ff ff       	mov    $0xffffffec,%esi
     f24:	ff d0                	call   *%rax
     f26:	85 c0                	test   %eax,%eax
     f28:	0f 85 ac 0b 00 00    	jne    1ada <balancer_ingress+0x1ada>
    return false;
  }
  data = (void*)(long)xdp->data;
     f2e:	49 8b 04 24          	mov    (%r12),%rax
  data_end = (void*)(long)xdp->data_end;
     f32:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
  new_eth = data;
  iph = data + sizeof(struct ethhdr);
     f37:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  old_eth = data + sizeof(struct iphdr);
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
     f3b:	48 39 ca             	cmp    %rcx,%rdx
     f3e:	0f 87 96 0b 00 00    	ja     1ada <balancer_ingress+0x1ada>
     f44:	48 8d 50 22          	lea    0x22(%rax),%rdx
     f48:	bb 01 00 00 00       	mov    $0x1,%ebx
     f4d:	48 39 ca             	cmp    %rcx,%rdx
     f50:	0f 87 89 0b 00 00    	ja     1adf <balancer_ingress+0x1adf>
     f56:	66 41 c1 c7 08       	rol    $0x8,%r15w
     f5b:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
     f62:	44 31 fa             	xor    %r15d,%edx
     f65:	c1 e2 10             	shl    $0x10,%edx
     f68:	8d ba ac 10 00 00    	lea    0x10ac(%rdx),%edi
     f6e:	48 b9 00 74 69 08 81 	movabs $0xffff888108697400,%rcx
     f75:	88 ff ff 
    return false;
  }
  memcpy(new_eth->h_dest, cval->mac, 6);
     f78:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
     f7f:	66 89 70 04          	mov    %si,0x4(%rax)
     f83:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
     f89:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
     f8b:	8b 48 14             	mov    0x14(%rax),%ecx
     f8e:	89 48 06             	mov    %ecx,0x6(%rax)
     f91:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
     f95:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
     f99:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)

  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
     f9f:	8a 5d c5             	mov    -0x3b(%rbp),%bl
     fa2:	41 8b 0e             	mov    (%r14),%ecx
    __u32 daddr,
    __u16 pkt_bytes,
    __u8 proto) {
  __u64 csum = 0;
  iph->version = 4;
  iph->ihl = 5;
     fa5:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->frag_off = 0;
  iph->protocol = proto;
  iph->check = 0;
#ifdef COPY_INNER_PACKET_TOS
  iph->tos = tos;
     fa9:	88 58 0f             	mov    %bl,0xf(%rax)
#else
  iph->tos = DEFAULT_TOS;
#endif
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
     fac:	41 83 c5 14          	add    $0x14,%r13d
     fb0:	66 41 c1 c5 08       	rol    $0x8,%r13w
     fb5:	66 44 89 68 10       	mov    %r13w,0x10(%rax)
  iph->id = 0;
     fba:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
     fc1:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
     fc4:	89 78 1a             	mov    %edi,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
     fc7:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    *csum += *next_iph_u16++;
     fcd:	0f b7 58 0e          	movzwl 0xe(%rax),%ebx
     fd1:	41 0f b7 f5          	movzwl %r13w,%esi
     fd5:	0f b7 78 16          	movzwl 0x16(%rax),%edi
     fd9:	c1 ea 10             	shr    $0x10,%edx
     fdc:	48 01 f2             	add    %rsi,%rdx
     fdf:	0f b7 f1             	movzwl %cx,%esi
     fe2:	48 01 d6             	add    %rdx,%rsi
     fe5:	48 c1 e9 10          	shr    $0x10,%rcx
     fe9:	48 01 f1             	add    %rsi,%rcx
     fec:	48 01 d9             	add    %rbx,%rcx
     fef:	e9 e0 07 00 00       	jmp    17d4 <balancer_ingress+0x17d4>
      if (pckt.flow.proto == IPPROTO_TCP) {
     ff4:	80 7d bc 06          	cmpb   $0x6,-0x44(%rbp)
     ff8:	75 33                	jne    102d <balancer_ingress+0x102d>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
     ffa:	48 8b 82 08 11 00 00 	mov    0x1108(%rdx),%rax
    1001:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    1008:	b9 bc 
        if (!lru_stats) {
    100a:	48 85 c0             	test   %rax,%rax
    100d:	0f 84 c7 0a 00 00    	je     1ada <balancer_ingress+0x1ada>
        if (pckt.flags & F_SYN_SET) {
    1013:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
    1016:	c1 e1 02             	shl    $0x2,%ecx
    1019:	f7 d1                	not    %ecx
    101b:	83 e1 08             	and    $0x8,%ecx
    101e:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
    1023:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
    102a:	88 ff ff 
  struct real_pos_lru new_dst_lru = {};
    102d:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    1034:	00 
    1035:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
    103c:	00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    103d:	48 8b 9a 10 11 00 00 	mov    0x1110(%rdx),%rbx
    1044:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffbcb95028,%rbx
    104b:	b9 bc 
    104d:	41 b6 01             	mov    $0x1,%r14b
  if (!conn_rate_stats) {
    1050:	48 85 db             	test   %rbx,%rbx
    1053:	74 26                	je     107b <balancer_ingress+0x107b>
    1055:	48 c7 c0 30 d6 e9 b6 	mov    $0xffffffffb6e9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    105c:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    105e:	48 89 c1             	mov    %rax,%rcx
    1061:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1065:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    106c:	72 11                	jb     107f <balancer_ingress+0x107f>
    conn_rate_stats->v1 = 1;
    106e:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    1075:	48 89 43 08          	mov    %rax,0x8(%rbx)
    1079:	eb 17                	jmp    1092 <balancer_ingress+0x1092>
    107b:	31 c0                	xor    %eax,%eax
    107d:	eb 16                	jmp    1095 <balancer_ingress+0x1095>
    conn_rate_stats->v1 += 1;
    107f:	48 8b 0b             	mov    (%rbx),%rcx
    1082:	48 83 c1 01          	add    $0x1,%rcx
    1086:	48 89 0b             	mov    %rcx,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1089:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    1090:	77 03                	ja     1095 <balancer_ingress+0x1095>
    1092:	45 31 f6             	xor    %r14d,%r14d
    1095:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    1099:	f6 01 08             	testb  $0x8,(%rcx)
    109c:	75 0a                	jne    10a8 <balancer_ingress+0x10a8>
    109e:	ba f7 c0 ad e0       	mov    $0xe0adc0f7,%edx
    10a3:	03 55 98             	add    -0x68(%rbp),%edx
    10a6:	eb 1d                	jmp    10c5 <balancer_ingress+0x10c5>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    10a8:	0f b7 4d ba          	movzwl -0x46(%rbp),%ecx
    10ac:	66 89 4d b8          	mov    %cx,-0x48(%rbp)
      memset(pckt->flow.srcv6, 0, 16);
    10b0:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
    10b7:	00 
    10b8:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
    10bf:	00 
    10c0:	ba f7 c0 ad e0       	mov    $0xe0adc0f7,%edx
    10c5:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  return c;
}

static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval) {
  a += initval;
  b += initval;
    10ca:	03 75 b8             	add    -0x48(%rbp),%esi
  c += initval;
  __jhash_final(a, b, c);
    10cd:	89 f1                	mov    %esi,%ecx
    10cf:	81 f1 f7 c0 ad e0    	xor    $0xe0adc0f7,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    10d5:	89 f7                	mov    %esi,%edi
    10d7:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    10da:	29 f9                	sub    %edi,%ecx
    10dc:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    10de:	89 cf                	mov    %ecx,%edi
    10e0:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    10e3:	29 fa                	sub    %edi,%edx
    10e5:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    10e7:	89 d7                	mov    %edx,%edi
    10e9:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    10ec:	29 fe                	sub    %edi,%esi
    10ee:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    10f0:	89 f7                	mov    %esi,%edi
    10f2:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    10f5:	29 f9                	sub    %edi,%ecx
    10f7:	31 ca                	xor    %ecx,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    10f9:	89 cf                	mov    %ecx,%edi
    10fb:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    10fe:	29 fa                	sub    %edi,%edx
    1100:	31 d6                	xor    %edx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1102:	c1 c2 0e             	rol    $0xe,%edx
  __jhash_final(a, b, c);
    1105:	29 d6                	sub    %edx,%esi
    1107:	31 f1                	xor    %esi,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1109:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    110c:	29 f1                	sub    %esi,%ecx
    110e:	ba 01 00 ff ff       	mov    $0xffff0001,%edx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1113:	48 0f af d1          	imul   %rcx,%rdx
    1117:	48 c1 ea 30          	shr    $0x30,%rdx
    111b:	89 d6                	mov    %edx,%esi
    111d:	c1 e6 10             	shl    $0x10,%esi
    1120:	09 d6                	or     %edx,%esi
    1122:	29 f1                	sub    %esi,%ecx
    1124:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1128:	8b 72 04             	mov    0x4(%rdx),%esi
    112b:	89 f2                	mov    %esi,%edx
    112d:	c1 e2 10             	shl    $0x10,%edx
    1130:	01 f2                	add    %esi,%edx
    1132:	01 ca                	add    %ecx,%edx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1134:	81 fa ff 01 00 02    	cmp    $0x20001ff,%edx
    if (!real_pos) {
    113a:	0f 87 9a 09 00 00    	ja     1ada <balancer_ingress+0x1ada>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1140:	89 d1                	mov    %edx,%ecx
    1142:	48 ba 00 90 9b 21 00 	movabs $0xffffc900219b9000,%rdx
    1149:	c9 ff ff 
    key = *real_pos;
    114c:	44 8b ac ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%r13d
    1153:	00 
    1154:	4d 85 ed             	test   %r13,%r13
    if (key == 0) {
    1157:	74 35                	je     118e <balancer_ingress+0x118e>
  pckt->real_index = key;
    1159:	44 89 6d c0          	mov    %r13d,-0x40(%rbp)
  *real = bpf_map_lookup_elem(&reals, &key);
    115d:	41 81 fd 00 10 00 00 	cmp    $0x1000,%r13d
  if (!(*real)) {
    1164:	72 50                	jb     11b6 <balancer_ingress+0x11b6>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1166:	48 b8 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rax
    116d:	88 ff ff 
    1170:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1177:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    117e:	b9 bc 
  if (!ch_drop_stats) {
    1180:	48 85 c0             	test   %rax,%rax
    1183:	0f 85 4d 09 00 00    	jne    1ad6 <balancer_ingress+0x1ad6>
    1189:	e9 4c 09 00 00       	jmp    1ada <balancer_ingress+0x1ada>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    118e:	48 b8 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rax
    1195:	88 ff ff 
    1198:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    119f:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    11a6:	b9 bc 
  if (!ch_drop_stats) {
    11a8:	48 85 c0             	test   %rax,%rax
    11ab:	0f 85 21 09 00 00    	jne    1ad2 <balancer_ingress+0x1ad2>
    11b1:	e9 24 09 00 00       	jmp    1ada <balancer_ingress+0x1ada>
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    11b6:	48 83 bd 58 ff ff ff 	cmpq   $0x0,-0xa8(%rbp)
    11bd:	00 
    11be:	74 14                	je     11d4 <balancer_ingress+0x11d4>
    11c0:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
    11c4:	8a 09                	mov    (%rcx),%cl
    11c6:	80 e1 02             	and    $0x2,%cl
    11c9:	d0 e9                	shr    %cl
    11cb:	41 08 ce             	or     %cl,%r14b
    11ce:	0f 84 21 01 00 00    	je     12f5 <balancer_ingress+0x12f5>
    11d4:	44 89 e8             	mov    %r13d,%eax
    11d7:	e9 44 01 00 00       	jmp    1320 <balancer_ingress+0x1320>
    11dc:	48 c7 c0 20 5c 03 b9 	mov    $0xffffffffb9035c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    11e3:	4c 89 e7             	mov    %r12,%rdi
    11e6:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    11eb:	ff d0                	call   *%rax
    11ed:	85 c0                	test   %eax,%eax
    11ef:	0f 85 e5 08 00 00    	jne    1ada <balancer_ingress+0x1ada>
  data = (void*)(long)xdp->data;
    11f5:	49 8b 04 24          	mov    (%r12),%rax
  data_end = (void*)(long)xdp->data_end;
    11f9:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
  ip6h = data + sizeof(struct ethhdr);
    11fe:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1202:	48 39 ca             	cmp    %rcx,%rdx
    1205:	0f 87 cf 08 00 00    	ja     1ada <balancer_ingress+0x1ada>
    120b:	48 8d 50 36          	lea    0x36(%rax),%rdx
    120f:	bb 01 00 00 00       	mov    $0x1,%ebx
    1214:	48 39 ca             	cmp    %rcx,%rdx
    1217:	0f b7 b5 78 ff ff ff 	movzwl -0x88(%rbp),%esi
    121e:	0f 87 bb 08 00 00    	ja     1adf <balancer_ingress+0x1adf>
    1224:	48 b9 00 74 69 08 81 	movabs $0xffff888108697400,%rcx
    122b:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    122e:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1235:	66 89 50 04          	mov    %dx,0x4(%rax)
    1239:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    123f:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1241:	8b 48 28             	mov    0x28(%rax),%ecx
    1244:	89 48 06             	mov    %ecx,0x6(%rax)
    1247:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    124b:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    124f:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    1255:	0f b7 4d b8          	movzwl -0x48(%rbp),%ecx
  saddr[3] = src ^ port;
    1259:	33 4d 98             	xor    -0x68(%rbp),%ecx
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    125c:	8a 5d c5             	mov    -0x3b(%rbp),%bl
    __u32* saddr,
    __u32* daddr,
    __u16 payload_len,
    __u8 proto) {
  ip6h->version = 6;
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    125f:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#ifdef COPY_INNER_PACKET_TOS
  ip6h->priority = (tc & 0xF0) >> 4;
    1265:	89 da                	mov    %ebx,%edx
    1267:	c0 ea 04             	shr    $0x4,%dl
    126a:	80 ca 60             	or     $0x60,%dl
    126d:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1270:	c0 e3 04             	shl    $0x4,%bl
    1273:	88 58 0f             	mov    %bl,0xf(%rax)
#else
  ip6h->priority = DEFAULT_TOS;
#endif
  ip6h->nexthdr = proto;
    1276:	66 c7 40 14 04 40    	movw   $0x4004,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    127c:	66 89 70 12          	mov    %si,0x12(%rax)
    1280:	e9 2c 09 00 00       	jmp    1bb1 <balancer_ingress+0x1bb1>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1285:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    1289:	48 c1 e1 18          	shl    $0x18,%rcx
    128d:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    1291:	48 c1 e2 10          	shl    $0x10,%rdx
    1295:	48 09 ca             	or     %rcx,%rdx
    1298:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    129c:	48 c1 e1 08          	shl    $0x8,%rcx
    12a0:	48 09 d1             	or     %rdx,%rcx
    12a3:	8a 40 04             	mov    0x4(%rax),%al
    12a6:	b2 03                	mov    $0x3,%dl
    12a8:	eb 18                	jmp    12c2 <balancer_ingress+0x12c2>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    12aa:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    12ae:	48 c1 e2 10          	shl    $0x10,%rdx
    12b2:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    12b6:	48 c1 e1 08          	shl    $0x8,%rcx
    12ba:	48 09 d1             	or     %rdx,%rcx
    12bd:	8a 40 03             	mov    0x3(%rax),%al
    12c0:	b2 02                	mov    $0x2,%dl
    12c2:	0f b6 c0             	movzbl %al,%eax
    12c5:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    12c8:	85 c0                	test   %eax,%eax
    12ca:	0f 8e cb 01 00 00    	jle    149b <balancer_ingress+0x149b>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    12d0:	80 fa 01             	cmp    $0x1,%dl
    12d3:	0f 84 20 01 00 00    	je     13f9 <balancer_ingress+0x13f9>
    12d9:	80 fa 03             	cmp    $0x3,%dl
    12dc:	0f 84 1e 01 00 00    	je     1400 <balancer_ingress+0x1400>
    12e2:	80 fa 02             	cmp    $0x2,%dl
    12e5:	0f 85 1c 01 00 00    	jne    1407 <balancer_ingress+0x1407>
    12eb:	b9 40 00 00 00       	mov    $0x40,%ecx
    12f0:	e9 17 01 00 00       	jmp    140c <balancer_ingress+0x140c>
    if (pckt->flow.proto == IPPROTO_UDP) {
    12f5:	80 7d bc 11          	cmpb   $0x11,-0x44(%rbp)
    12f9:	75 04                	jne    12ff <balancer_ingress+0x12ff>
      new_dst_lru.atime = cur_time;
    12fb:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    new_dst_lru.pos = key;
    12ff:	44 89 6d 80          	mov    %r13d,-0x80(%rbp)
    1303:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
    1307:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
    130b:	48 c7 c0 c0 c9 e9 b6 	mov    $0xffffffffb6e9c9c0,%rax
    1312:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1319:	31 c9                	xor    %ecx,%ecx
    131b:	ff d0                	call   *%rax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    131d:	8b 45 c0             	mov    -0x40(%rbp),%eax
    1320:	48 bf 00 78 69 08 81 	movabs $0xffff888108697800,%rdi
    1327:	88 ff ff 
    132a:	8b 9f 00 01 00 00    	mov    0x100(%rdi),%ebx
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1330:	0f b7 97 10 01 00 00 	movzwl 0x110(%rdi),%edx
    1337:	0f b7 b5 70 ff ff ff 	movzwl -0x90(%rbp),%esi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    133e:	8a 8d 72 ff ff ff    	mov    -0x8e(%rbp),%cl
    1344:	88 8f 12 01 00 00    	mov    %cl,0x112(%rdi)
    134a:	3b 9d 60 ff ff ff    	cmp    -0xa0(%rbp),%ebx
  bool vip_match = address_match && port_match && proto_match;
    1350:	75 3d                	jne    138f <balancer_ingress+0x138f>
    1352:	66 39 f2             	cmp    %si,%dx
    1355:	75 38                	jne    138f <balancer_ingress+0x138f>
    1357:	84 c9                	test   %cl,%cl
    1359:	74 34                	je     138f <balancer_ingress+0x138f>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    135b:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    1360:	0f 87 74 07 00 00    	ja     1ada <balancer_ingress+0x1ada>
    1366:	89 c0                	mov    %eax,%eax
    1368:	48 b9 00 60 d6 08 00 	movabs $0xffffc90008d66000,%rcx
    136f:	c9 ff ff 
    1372:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    1379:	00 
    137a:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    1381:	b9 bc 
    if (!lru_miss_stat) {
    1383:	48 85 c0             	test   %rax,%rax
    1386:	0f 84 4e 07 00 00    	je     1ada <balancer_ingress+0x1ada>
    *lru_miss_stat += 1;
    138c:	83 00 01             	addl   $0x1,(%rax)
    138f:	4a 8d 04 6d 00 00 00 	lea    0x0(,%r13,2),%rax
    1396:	00 
    1397:	4c 01 e8             	add    %r13,%rax
    139a:	48 b9 00 c0 d4 08 00 	movabs $0xffffc90008d4c000,%rcx
    13a1:	c9 ff ff 
    13a4:	4c 8d 34 c1          	lea    (%rcx,%rax,8),%r14
    13a8:	49 81 c6 00 01 00 00 	add    $0x100,%r14
    13af:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
      data_stats->v2 += 1;
    13b3:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    13b8:	48 ba 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rdx
    13bf:	88 ff ff 
    13c2:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    13c9:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    13ce:	0f 87 06 07 00 00    	ja     1ada <balancer_ingress+0x1ada>
    13d4:	e9 b0 fa ff ff       	jmp    e89 <balancer_ingress+0xe89>
    if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
    13d9:	41 80 7e 05 08       	cmpb   $0x8,0x5(%r14)
    13de:	0f 82 3a f7 ff ff    	jb     b1e <balancer_ingress+0xb1e>
    13e4:	49 83 c6 06          	add    $0x6,%r14
    13e8:	4c 89 f0             	mov    %r14,%rax
  if (!connId) {
    13eb:	48 85 c0             	test   %rax,%rax
    13ee:	0f 85 6b f8 ff ff    	jne    c5f <balancer_ingress+0xc5f>
    13f4:	e9 25 f7 ff ff       	jmp    b1e <balancer_ingress+0xb1e>
    13f9:	b9 38 00 00 00       	mov    $0x38,%ecx
    13fe:	eb 0c                	jmp    140c <balancer_ingress+0x140c>
    1400:	b9 48 00 00 00       	mov    $0x48,%ecx
    1405:	eb 05                	jmp    140c <balancer_ingress+0x140c>
    1407:	b9 30 00 00 00       	mov    $0x30,%ecx
    140c:	48 83 04 0b 01       	addq   $0x1,(%rbx,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1411:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    1416:	77 78                	ja     1490 <balancer_ingress+0x1490>
    1418:	48 b9 00 c0 9b 31 00 	movabs $0xffffc900319bc000,%rcx
    141f:	c9 ff ff 
          key = *real_pos;
    1422:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    1429:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    142c:	74 62                	je     1490 <balancer_ingress+0x1490>
            pckt.real_index = key;
    142e:	89 4d c0             	mov    %ecx,-0x40(%rbp)
    1431:	31 d2                	xor    %edx,%edx
            dst = bpf_map_lookup_elem(&reals, &key);
    1433:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    1439:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    143d:	48 b9 00 c0 d4 08 00 	movabs $0xffffc90008d4c000,%rcx
    1444:	c9 ff ff 
    1447:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    144e:	00 
    144f:	48 0f 42 d0          	cmovb  %rax,%rdx
            if (!dst) {
    1453:	48 85 d2             	test   %rdx,%rdx
    1456:	0f 84 da 09 00 00    	je     1e36 <balancer_ingress+0x1e36>
    145c:	49 89 d7             	mov    %rdx,%r15
    145f:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
    1463:	48 c7 c0 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rax
    146a:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    146e:	ff d0                	call   *%rax
  if (dst_lru) {
    1470:	48 85 c0             	test   %rax,%rax
    1473:	0f 84 c9 08 00 00    	je     1d42 <balancer_ingress+0x1d42>
    if (dst_lru->pos == pckt->real_index) {
    1479:	8b 4d c0             	mov    -0x40(%rbp),%ecx
    147c:	39 08                	cmp    %ecx,(%rax)
    147e:	0f 85 bc 09 00 00    	jne    1e40 <balancer_ingress+0x1e40>
              quic_packets_stats->dst_match_in_lru += 1;
    1484:	48 89 d8             	mov    %rbx,%rax
    1487:	48 83 c0 50          	add    $0x50,%rax
    148b:	e9 30 0a 00 00       	jmp    1ec0 <balancer_ingress+0x1ec0>
    1490:	48 83 43 10 01       	addq   $0x1,0x10(%rbx)
    1495:	48 98                	cltq
    1497:	48 89 43 18          	mov    %rax,0x18(%rbx)
    149b:	45 89 e8             	mov    %r13d,%r8d
    149e:	48 be 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rsi
    14a5:	88 ff ff 
    14a8:	4c 8b 55 c8          	mov    -0x38(%rbp),%r10
    14ac:	4c 89 ca             	mov    %r9,%rdx
    14af:	48 83 03 01          	addq   $0x1,(%rbx)
  original_sport = pckt.flow.port16[0];
    14b3:	0f b7 45 b8          	movzwl -0x48(%rbp),%eax
    14b7:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%rbp)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    14bd:	f6 45 c4 02          	testb  $0x2,-0x3c(%rbp)
    14c1:	75 54                	jne    1517 <balancer_ingress+0x1517>
        !(vip_info->flags & F_LRU_BYPASS)) {
    14c3:	f6 02 02             	testb  $0x2,(%rdx)
    if (!dst && !(pckt.flags & F_SYN_SET) &&
    14c6:	75 4f                	jne    1517 <balancer_ingress+0x1517>
    14c8:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    14cc:	4d 89 d7             	mov    %r10,%r15
    14cf:	49 89 f6             	mov    %rsi,%r14
    14d2:	45 89 c5             	mov    %r8d,%r13d
    14d5:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
    14d9:	48 c7 c0 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rax
    14e0:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    14e4:	ff d0                	call   *%rax
  if (!dst_lru) {
    14e6:	48 85 c0             	test   %rax,%rax
    14e9:	74 28                	je     1513 <balancer_ingress+0x1513>
    14eb:	48 89 c3             	mov    %rax,%rbx
  if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
    14ee:	80 7d bc 11          	cmpb   $0x11,-0x44(%rbp)
    14f2:	75 2b                	jne    151f <balancer_ingress+0x151f>
    14f4:	48 c7 c0 30 d6 e9 b6 	mov    $0xffffffffb6e9d630,%rax
    cur_time = bpf_ktime_get_ns();
    14fb:	ff d0                	call   *%rax
    if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
    14fd:	48 89 c1             	mov    %rax,%rcx
    1500:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    1504:	48 ba 00 ac 23 fc 06 	movabs $0x6fc23ac00,%rdx
    150b:	00 00 00 
    150e:	48 39 d1             	cmp    %rdx,%rcx
    1511:	76 08                	jbe    151b <balancer_ingress+0x151b>
    1513:	31 ff                	xor    %edi,%edi
    1515:	eb 2f                	jmp    1546 <balancer_ingress+0x1546>
    1517:	31 ff                	xor    %edi,%edi
    1519:	eb 38                	jmp    1553 <balancer_ingress+0x1553>
    dst_lru->atime = cur_time;
    151b:	48 89 43 08          	mov    %rax,0x8(%rbx)
  key = dst_lru->pos;
    151f:	8b 03                	mov    (%rbx),%eax
    1521:	31 ff                	xor    %edi,%edi
    1523:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  pckt->real_index = key;
    1529:	89 45 c0             	mov    %eax,-0x40(%rbp)
  *real = bpf_map_lookup_elem(&reals, &key);
    152c:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    1530:	48 b9 00 c0 d4 08 00 	movabs $0xffffc90008d4c000,%rcx
    1537:	c9 ff ff 
    153a:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    1541:	00 
    1542:	48 0f 42 f8          	cmovb  %rax,%rdi
    1546:	45 89 e8             	mov    %r13d,%r8d
    1549:	4c 89 f6             	mov    %r14,%rsi
    154c:	4d 89 fa             	mov    %r15,%r10
    154f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  if (dst && pckt->flow.proto == IPPROTO_UDP &&
    1553:	80 7d bc 11          	cmpb   $0x11,-0x44(%rbp)
    1557:	0f 85 fa 00 00 00    	jne    1657 <balancer_ingress+0x1657>
      vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
    155d:	f6 42 01 02          	testb  $0x2,0x1(%rdx)
    1561:	0f 84 f0 00 00 00    	je     1657 <balancer_ingress+0x1657>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1567:	48 8b 9e 10 11 00 00 	mov    0x1110(%rsi),%rbx
    156e:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffbcb95028,%rbx
    1575:	b9 bc 
  if (!conn_rate_stats) {
    1577:	48 85 db             	test   %rbx,%rbx
    157a:	0f 84 d7 00 00 00    	je     1657 <balancer_ingress+0x1657>
    1580:	48 89 bd 40 ff ff ff 	mov    %rdi,-0xc0(%rbp)
    1587:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    158b:	4d 89 d7             	mov    %r10,%r15
    158e:	49 89 f6             	mov    %rsi,%r14
    1591:	45 89 c5             	mov    %r8d,%r13d
    1594:	48 c7 c0 30 d6 e9 b6 	mov    $0xffffffffb6e9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    159b:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    159d:	48 89 c1             	mov    %rax,%rcx
    15a0:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    15a4:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    15ab:	72 0d                	jb     15ba <balancer_ingress+0x15ba>
    conn_rate_stats->v1 = 1;
    15ad:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    15b4:	48 89 43 08          	mov    %rax,0x8(%rbx)
    15b8:	eb 26                	jmp    15e0 <balancer_ingress+0x15e0>
    conn_rate_stats->v1 += 1;
    15ba:	48 8b 03             	mov    (%rbx),%rax
    15bd:	48 83 c0 01          	add    $0x1,%rax
    15c1:	48 89 03             	mov    %rax,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    15c4:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    15ca:	45 89 e8             	mov    %r13d,%r8d
    15cd:	4c 89 f6             	mov    %r14,%rsi
    15d0:	4d 89 fa             	mov    %r15,%r10
    15d3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    15d7:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
    15de:	77 77                	ja     1657 <balancer_ingress+0x1657>
    void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
    15e0:	48 bf 00 78 72 c4 81 	movabs $0xffff8881c4727800,%rdi
    15e7:	88 ff ff 
    15ea:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
    15f1:	48 c7 c3 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rbx
    15f8:	ff d3                	call   *%rbx
    15fa:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
    1601:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    1605:	4d 89 fa             	mov    %r15,%r10
    1608:	4c 89 f6             	mov    %r14,%rsi
    160b:	45 89 e8             	mov    %r13d,%r8d
    if (down_reals_map) {
    160e:	48 85 c0             	test   %rax,%rax
    1611:	74 44                	je     1657 <balancer_ingress+0x1657>
      void* down_real = real_bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
    1613:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    1617:	48 89 c7             	mov    %rax,%rdi
    161a:	ff d3                	call   *%rbx
    161c:	48 8b bd 40 ff ff ff 	mov    -0xc0(%rbp),%rdi
    1623:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    1627:	4d 89 fa             	mov    %r15,%r10
    162a:	4c 89 f6             	mov    %r14,%rsi
    162d:	45 89 e8             	mov    %r13d,%r8d
      if (down_real) {
    1630:	48 85 c0             	test   %rax,%rax
    1633:	74 22                	je     1657 <balancer_ingress+0x1657>
        struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
    1635:	48 8b 86 78 11 00 00 	mov    0x1178(%rsi),%rax
    163c:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    1643:	b9 bc 
        if (stats_data) {
    1645:	48 85 c0             	test   %rax,%rax
    1648:	0f 84 f9 01 00 00    	je     1847 <balancer_ingress+0x1847>
          stats_data->v1 += 1;
    164e:	48 83 00 01          	addq   $0x1,(%rax)
    1652:	e9 f0 01 00 00       	jmp    1847 <balancer_ingress+0x1847>
    if (!dst) {
    1657:	48 85 ff             	test   %rdi,%rdi
    165a:	0f 84 e7 01 00 00    	je     1847 <balancer_ingress+0x1847>
  data_stats = bpf_map_lookup_elem(&stats, &vip_num);
    1660:	41 81 fa ff 03 00 00 	cmp    $0x3ff,%r10d
    1667:	0f 87 6d 04 00 00    	ja     1ada <balancer_ingress+0x1ada>
    166d:	4a 8b 8c d6 00 01 00 	mov    0x100(%rsi,%r10,8),%rcx
    1674:	00 
    1675:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffbcb95028,%rcx
    167c:	b9 bc 
  if (!data_stats) {
    167e:	48 85 c9             	test   %rcx,%rcx
    1681:	0f 84 53 04 00 00    	je     1ada <balancer_ingress+0x1ada>
    1687:	66 41 c1 c0 08       	rol    $0x8,%r8w
  data_stats->v1 += 1;
    168c:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    1690:	41 0f b7 c0          	movzwl %r8w,%eax
    1694:	48 01 41 08          	add    %rax,0x8(%rcx)
  data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
    1698:	8b 4d c0             	mov    -0x40(%rbp),%ecx
    169b:	48 81 f9 ff 0f 00 00 	cmp    $0xfff,%rcx
    16a2:	0f 87 32 04 00 00    	ja     1ada <balancer_ingress+0x1ada>
    16a8:	44 89 85 78 ff ff ff 	mov    %r8d,-0x88(%rbp)
    16af:	48 ba 00 b0 a2 08 00 	movabs $0xffffc90008a2b000,%rdx
    16b6:	c9 ff ff 
    16b9:	48 8b 8c ca 00 01 00 	mov    0x100(%rdx,%rcx,8),%rcx
    16c0:	00 
    16c1:	65 48 03 0c 25 28 50 	add    %gs:0xffffffffbcb95028,%rcx
    16c8:	b9 bc 
  if (!data_stats) {
    16ca:	48 85 c9             	test   %rcx,%rcx
    16cd:	0f 84 07 04 00 00    	je     1ada <balancer_ingress+0x1ada>
  data_stats->v1 += 1;
    16d3:	48 83 01 01          	addq   $0x1,(%rcx)
  data_stats->v2 += pkt_bytes;
    16d7:	48 01 41 08          	add    %rax,0x8(%rcx)
    16db:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
  pckt.flow.port16[0] = original_sport;
    16e1:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
    16e5:	49 89 fe             	mov    %rdi,%r14
  if (dst->flags & F_IPV6) {
    16e8:	f6 47 10 01          	testb  $0x1,0x10(%rdi)
    16ec:	0f 85 21 04 00 00    	jne    1b13 <balancer_ingress+0x1b13>
  __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
    16f2:	44 0f b7 6d 9a       	movzwl -0x66(%rbp),%r13d
    16f7:	48 c7 c0 20 5c 03 b9 	mov    $0xffffffffb9035c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
    16fe:	4c 89 e7             	mov    %r12,%rdi
    1701:	be ec ff ff ff       	mov    $0xffffffec,%esi
    1706:	ff d0                	call   *%rax
    1708:	85 c0                	test   %eax,%eax
    170a:	0f 85 ca 03 00 00    	jne    1ada <balancer_ingress+0x1ada>
  data = (void*)(long)xdp->data;
    1710:	49 8b 04 24          	mov    (%r12),%rax
  data_end = (void*)(long)xdp->data_end;
    1714:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
  iph = data + sizeof(struct ethhdr);
    1719:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
    171d:	48 39 ca             	cmp    %rcx,%rdx
    1720:	0f 87 b4 03 00 00    	ja     1ada <balancer_ingress+0x1ada>
    1726:	48 8d 50 22          	lea    0x22(%rax),%rdx
    172a:	bb 01 00 00 00       	mov    $0x1,%ebx
    172f:	48 39 ca             	cmp    %rcx,%rdx
    1732:	0f 87 a7 03 00 00    	ja     1adf <balancer_ingress+0x1adf>
    1738:	8b 8d 58 ff ff ff    	mov    -0xa8(%rbp),%ecx
    173e:	66 c1 c1 08          	rol    $0x8,%cx
    1742:	41 31 cd             	xor    %ecx,%r13d
    1745:	41 c1 e5 10          	shl    $0x10,%r13d
    1749:	41 8d 95 ac 10 00 00 	lea    0x10ac(%r13),%edx
    1750:	48 b9 00 74 69 08 81 	movabs $0xffff888108697400,%rcx
    1757:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    175a:	0f b7 b1 04 01 00 00 	movzwl 0x104(%rcx),%esi
    1761:	66 89 70 04          	mov    %si,0x4(%rax)
    1765:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    176b:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    176d:	8b 48 14             	mov    0x14(%rax),%ecx
    1770:	89 48 06             	mov    %ecx,0x6(%rax)
    1773:	0f b7 48 18          	movzwl 0x18(%rax),%ecx
    1777:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IP;
    177b:	66 c7 40 0c 08 00    	movw   $0x8,0xc(%rax)
  create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
    1781:	8a 5d c5             	mov    -0x3b(%rbp),%bl
    1784:	41 8b 0e             	mov    (%r14),%ecx
  iph->ihl = 5;
    1787:	c6 40 0e 45          	movb   $0x45,0xe(%rax)
  iph->tos = tos;
    178b:	88 58 0f             	mov    %bl,0xf(%rax)
    178e:	8b b5 78 ff ff ff    	mov    -0x88(%rbp),%esi
  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
    1794:	83 c6 14             	add    $0x14,%esi
    1797:	66 c1 c6 08          	rol    $0x8,%si
    179b:	66 89 70 10          	mov    %si,0x10(%rax)
  iph->id = 0;
    179f:	c7 40 12 00 00 00 00 	movl   $0x0,0x12(%rax)
  iph->daddr = daddr;
    17a6:	89 48 1e             	mov    %ecx,0x1e(%rax)
  iph->saddr = saddr;
    17a9:	89 50 1a             	mov    %edx,0x1a(%rax)
  iph->ttl = DEFAULT_TTL;
    17ac:	66 c7 40 16 40 04    	movw   $0x440,0x16(%rax)
    17b2:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
    17b6:	0f b7 f6             	movzwl %si,%esi
    17b9:	0f b7 78 16          	movzwl 0x16(%rax),%edi
    17bd:	41 c1 ed 10          	shr    $0x10,%r13d
    17c1:	49 01 f5             	add    %rsi,%r13
    17c4:	0f b7 f1             	movzwl %cx,%esi
    17c7:	4c 01 ee             	add    %r13,%rsi
    17ca:	48 c1 e9 10          	shr    $0x10,%rcx
    17ce:	48 01 f1             	add    %rsi,%rcx
    17d1:	48 01 d1             	add    %rdx,%rcx
    17d4:	48 01 f9             	add    %rdi,%rcx
    17d7:	48 81 c1 ac 10 00 00 	add    $0x10ac,%rcx
    17de:	48 89 ca             	mov    %rcx,%rdx
    17e1:	48 c1 ea 10          	shr    $0x10,%rdx
    17e5:	0f b7 f1             	movzwl %cx,%esi
    17e8:	48 01 d6             	add    %rdx,%rsi
    17eb:	48 81 f9 00 00 01 00 	cmp    $0x10000,%rcx
    17f2:	48 0f 42 f1          	cmovb  %rcx,%rsi
    17f6:	48 89 f1             	mov    %rsi,%rcx
    17f9:	48 c1 e9 10          	shr    $0x10,%rcx
    17fd:	0f b7 d6             	movzwl %si,%edx
    1800:	48 01 ca             	add    %rcx,%rdx
    1803:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    180a:	48 0f 42 d6          	cmovb  %rsi,%rdx
    180e:	48 89 d1             	mov    %rdx,%rcx
    1811:	48 c1 e9 10          	shr    $0x10,%rcx
    1815:	0f b7 f2             	movzwl %dx,%esi
    1818:	48 01 ce             	add    %rcx,%rsi
    181b:	48 81 fa 00 00 01 00 	cmp    $0x10000,%rdx
    1822:	48 0f 42 f2          	cmovb  %rdx,%rsi
    1826:	89 f1                	mov    %esi,%ecx
    1828:	c1 e9 10             	shr    $0x10,%ecx
    182b:	48 81 fe 00 00 01 00 	cmp    $0x10000,%rsi
    1832:	ba 00 00 01 00       	mov    $0x10000,%edx
    1837:	0f 43 d1             	cmovae %ecx,%edx
    183a:	01 f2                	add    %esi,%edx
    183c:	f7 d2                	not    %edx
    183e:	66 89 50 18          	mov    %dx,0x18(%rax)
    1842:	e9 ce eb ff ff       	jmp    415 <balancer_ingress+0x415>
      if (pckt.flow.proto == IPPROTO_TCP) {
    1847:	80 7d bc 06          	cmpb   $0x6,-0x44(%rbp)
    184b:	75 29                	jne    1876 <balancer_ingress+0x1876>
            bpf_map_lookup_elem(&stats, &lru_stats_key);
    184d:	48 8b 86 08 11 00 00 	mov    0x1108(%rsi),%rax
    1854:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    185b:	b9 bc 
        if (!lru_stats) {
    185d:	48 85 c0             	test   %rax,%rax
    1860:	0f 84 74 02 00 00    	je     1ada <balancer_ingress+0x1ada>
        if (pckt.flags & F_SYN_SET) {
    1866:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
    1869:	c1 e1 02             	shl    $0x2,%ecx
    186c:	f7 d1                	not    %ecx
    186e:	83 e1 08             	and    $0x8,%ecx
    1871:	48 83 04 08 01       	addq   $0x1,(%rax,%rcx,1)
    1876:	4c 89 55 c8          	mov    %r10,-0x38(%rbp)
    187a:	44 89 85 78 ff ff ff 	mov    %r8d,-0x88(%rbp)
  struct real_pos_lru new_dst_lru = {};
    1881:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    1888:	00 
    1889:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
    1890:	00 
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1891:	48 8b 9e 10 11 00 00 	mov    0x1110(%rsi),%rbx
    1898:	65 48 03 1c 25 28 50 	add    %gs:0xffffffffbcb95028,%rbx
    189f:	b9 bc 
    18a1:	41 b7 01             	mov    $0x1,%r15b
  if (!conn_rate_stats) {
    18a4:	48 85 db             	test   %rbx,%rbx
    18a7:	74 2c                	je     18d5 <balancer_ingress+0x18d5>
    18a9:	49 89 d6             	mov    %rdx,%r14
    18ac:	48 c7 c0 30 d6 e9 b6 	mov    $0xffffffffb6e9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    18b3:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    18b5:	48 89 c1             	mov    %rax,%rcx
    18b8:	48 2b 4b 08          	sub    0x8(%rbx),%rcx
    18bc:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    18c3:	72 14                	jb     18d9 <balancer_ingress+0x18d9>
    conn_rate_stats->v1 = 1;
    18c5:	48 c7 03 01 00 00 00 	movq   $0x1,(%rbx)
    conn_rate_stats->v2 = *cur_time;
    18cc:	48 89 43 08          	mov    %rax,0x8(%rbx)
    18d0:	4c 89 f2             	mov    %r14,%rdx
    18d3:	eb 1a                	jmp    18ef <balancer_ingress+0x18ef>
    18d5:	31 c0                	xor    %eax,%eax
    18d7:	eb 19                	jmp    18f2 <balancer_ingress+0x18f2>
    conn_rate_stats->v1 += 1;
    18d9:	48 8b 0b             	mov    (%rbx),%rcx
    18dc:	48 83 c1 01          	add    $0x1,%rcx
    18e0:	48 89 0b             	mov    %rcx,(%rbx)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    18e3:	48 81 f9 48 e8 01 00 	cmp    $0x1e848,%rcx
    18ea:	4c 89 f2             	mov    %r14,%rdx
    18ed:	77 03                	ja     18f2 <balancer_ingress+0x18f2>
    18ef:	45 31 ff             	xor    %r15d,%r15d
    18f2:	49 89 d6             	mov    %rdx,%r14
    if (vip_info->flags & F_HASH_DPORT_ONLY) {
    18f5:	f6 02 08             	testb  $0x8,(%rdx)
    18f8:	75 1b                	jne    1915 <balancer_ingress+0x1915>
    18fa:	8b 7d 98             	mov    -0x68(%rbp),%edi
    b += *(u32*)(k + 4);
    18fd:	8b 4d 9c             	mov    -0x64(%rbp),%ecx
    c += *(u32*)(k + 8);
    1900:	8b 55 a0             	mov    -0x60(%rbp),%edx
      a += (u32)k[3] << 24;
    1903:	44 8a 5d a7          	mov    -0x59(%rbp),%r11b
      a += (u32)k[2] << 16;
    1907:	44 8a 55 a6          	mov    -0x5a(%rbp),%r10b
      a += (u32)k[1] << 8;
    190b:	44 8a 4d a5          	mov    -0x5b(%rbp),%r9b
      a += k[0];
    190f:	44 8a 45 a4          	mov    -0x5c(%rbp),%r8b
    1913:	eb 2a                	jmp    193f <balancer_ingress+0x193f>
      pckt->flow.port16[0] = pckt->flow.port16[1];
    1915:	0f b7 4d ba          	movzwl -0x46(%rbp),%ecx
    1919:	66 89 4d b8          	mov    %cx,-0x48(%rbp)
      memset(pckt->flow.srcv6, 0, 16);
    191d:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
    1924:	00 
    1925:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
    192c:	00 
    192d:	45 31 c0             	xor    %r8d,%r8d
    1930:	45 31 c9             	xor    %r9d,%r9d
    1933:	45 31 d2             	xor    %r10d,%r10d
    1936:	45 31 db             	xor    %r11d,%r11d
    1939:	31 d2                	xor    %edx,%edx
    193b:	31 c9                	xor    %ecx,%ecx
    193d:	31 ff                	xor    %edi,%edi
    c += *(u32*)(k + 8);
    193f:	8d 9a ff c0 ad de    	lea    -0x21523f01(%rdx),%ebx
    __jhash_mix(a, b, c);
    1945:	29 d7                	sub    %edx,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    1947:	c1 c3 04             	rol    $0x4,%ebx
    __jhash_mix(a, b, c);
    194a:	31 fb                	xor    %edi,%ebx
    b += *(u32*)(k + 4);
    194c:	89 cf                	mov    %ecx,%edi
    194e:	81 c7 ff c0 ad de    	add    $0xdeadc0ff,%edi
    __jhash_mix(a, b, c);
    1954:	01 ca                	add    %ecx,%edx
    1956:	81 c2 fe 81 5b bd    	add    $0xbd5b81fe,%edx
    195c:	29 df                	sub    %ebx,%edi
  return (word << shift) | (word >> ((-shift) & 31));
    195e:	89 de                	mov    %ebx,%esi
    1960:	c1 c6 06             	rol    $0x6,%esi
    __jhash_mix(a, b, c);
    1963:	31 fe                	xor    %edi,%esi
    1965:	01 d3                	add    %edx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1967:	89 f1                	mov    %esi,%ecx
    1969:	c1 c1 08             	rol    $0x8,%ecx
    __jhash_mix(a, b, c);
    196c:	29 f2                	sub    %esi,%edx
    196e:	31 d1                	xor    %edx,%ecx
    1970:	01 de                	add    %ebx,%esi
    1972:	29 cb                	sub    %ecx,%ebx
  return (word << shift) | (word >> ((-shift) & 31));
    1974:	89 cf                	mov    %ecx,%edi
    1976:	c1 c7 10             	rol    $0x10,%edi
    __jhash_mix(a, b, c);
    1979:	31 df                	xor    %ebx,%edi
    197b:	01 f1                	add    %esi,%ecx
    197d:	29 fe                	sub    %edi,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    197f:	89 fa                	mov    %edi,%edx
    1981:	c1 c2 13             	rol    $0x13,%edx
    __jhash_mix(a, b, c);
    1984:	31 f2                	xor    %esi,%edx
    1986:	01 cf                	add    %ecx,%edi
    1988:	29 d1                	sub    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    198a:	41 89 d5             	mov    %edx,%r13d
    198d:	41 c1 c5 04          	rol    $0x4,%r13d
    __jhash_mix(a, b, c);
    1991:	01 fa                	add    %edi,%edx
      a += (u32)k[3] << 24;
    1993:	41 0f b6 db          	movzbl %r11b,%ebx
    1997:	c1 e3 18             	shl    $0x18,%ebx
      a += (u32)k[2] << 16;
    199a:	41 0f b6 f2          	movzbl %r10b,%esi
    199e:	c1 e6 10             	shl    $0x10,%esi
      a += (u32)k[3] << 24;
    19a1:	09 de                	or     %ebx,%esi
      a += (u32)k[1] << 8;
    19a3:	41 0f b6 d9          	movzbl %r9b,%ebx
    19a7:	c1 e3 08             	shl    $0x8,%ebx
      a += (u32)k[2] << 16;
    19aa:	09 f3                	or     %esi,%ebx
      a += k[0];
    19ac:	41 0f b6 f0          	movzbl %r8b,%esi
      a += (u32)k[1] << 8;
    19b0:	09 de                	or     %ebx,%esi
      a += k[0];
    19b2:	01 fe                	add    %edi,%esi
    __jhash_mix(a, b, c);
    19b4:	31 d1                	xor    %edx,%ecx
      __jhash_final(a, b, c);
    19b6:	44 31 e9             	xor    %r13d,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    19b9:	89 d7                	mov    %edx,%edi
    19bb:	c1 c7 0e             	rol    $0xe,%edi
      __jhash_final(a, b, c);
    19be:	29 f9                	sub    %edi,%ecx
    19c0:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    19c2:	89 cf                	mov    %ecx,%edi
    19c4:	c1 c7 0b             	rol    $0xb,%edi
      __jhash_final(a, b, c);
    19c7:	29 fe                	sub    %edi,%esi
    19c9:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    19cb:	89 f7                	mov    %esi,%edi
    19cd:	c1 c7 19             	rol    $0x19,%edi
      __jhash_final(a, b, c);
    19d0:	29 fa                	sub    %edi,%edx
    19d2:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    19d4:	89 d7                	mov    %edx,%edi
    19d6:	c1 c7 10             	rol    $0x10,%edi
      __jhash_final(a, b, c);
    19d9:	29 f9                	sub    %edi,%ecx
    19db:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    19dd:	89 cf                	mov    %ecx,%edi
    19df:	c1 c7 04             	rol    $0x4,%edi
      __jhash_final(a, b, c);
    19e2:	29 fe                	sub    %edi,%esi
    19e4:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    19e6:	c1 c6 0e             	rol    $0xe,%esi
      __jhash_final(a, b, c);
    19e9:	29 f2                	sub    %esi,%edx
    19eb:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    19ed:	c1 c2 18             	rol    $0x18,%edx
  a += initval;
    19f0:	29 d1                	sub    %edx,%ecx
    19f2:	be f7 c0 ad e0       	mov    $0xe0adc0f7,%esi
  b += initval;
    19f7:	03 75 b8             	add    -0x48(%rbp),%esi
  a += initval;
    19fa:	81 c1 f7 c0 ad e0    	add    $0xe0adc0f7,%ecx
  __jhash_final(a, b, c);
    1a00:	89 f2                	mov    %esi,%edx
    1a02:	81 f2 f7 c0 ad e0    	xor    $0xe0adc0f7,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1a08:	89 f7                	mov    %esi,%edi
    1a0a:	c1 c7 0e             	rol    $0xe,%edi
  __jhash_final(a, b, c);
    1a0d:	29 fa                	sub    %edi,%edx
    1a0f:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1a11:	89 d7                	mov    %edx,%edi
    1a13:	c1 c7 0b             	rol    $0xb,%edi
  __jhash_final(a, b, c);
    1a16:	29 f9                	sub    %edi,%ecx
    1a18:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1a1a:	89 cf                	mov    %ecx,%edi
    1a1c:	c1 c7 19             	rol    $0x19,%edi
  __jhash_final(a, b, c);
    1a1f:	29 fe                	sub    %edi,%esi
    1a21:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1a23:	89 f7                	mov    %esi,%edi
    1a25:	c1 c7 10             	rol    $0x10,%edi
  __jhash_final(a, b, c);
    1a28:	29 fa                	sub    %edi,%edx
    1a2a:	31 d1                	xor    %edx,%ecx
  return (word << shift) | (word >> ((-shift) & 31));
    1a2c:	89 d7                	mov    %edx,%edi
    1a2e:	c1 c7 04             	rol    $0x4,%edi
  __jhash_final(a, b, c);
    1a31:	29 f9                	sub    %edi,%ecx
    1a33:	31 ce                	xor    %ecx,%esi
  return (word << shift) | (word >> ((-shift) & 31));
    1a35:	c1 c1 0e             	rol    $0xe,%ecx
  __jhash_final(a, b, c);
    1a38:	29 ce                	sub    %ecx,%esi
    1a3a:	31 f2                	xor    %esi,%edx
  return (word << shift) | (word >> ((-shift) & 31));
    1a3c:	c1 c6 18             	rol    $0x18,%esi
  __jhash_final(a, b, c);
    1a3f:	29 f2                	sub    %esi,%edx
    1a41:	b9 01 00 ff ff       	mov    $0xffff0001,%ecx
    hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
    1a46:	48 0f af ca          	imul   %rdx,%rcx
    1a4a:	48 c1 e9 30          	shr    $0x30,%rcx
    1a4e:	89 ce                	mov    %ecx,%esi
    1a50:	c1 e6 10             	shl    $0x10,%esi
    1a53:	09 ce                	or     %ecx,%esi
    1a55:	29 f2                	sub    %esi,%edx
    1a57:	4c 89 f1             	mov    %r14,%rcx
    key = RING_SIZE * (vip_info->vip_num) + hash;
    1a5a:	41 8b 76 04          	mov    0x4(%r14),%esi
    1a5e:	89 f1                	mov    %esi,%ecx
    1a60:	c1 e1 10             	shl    $0x10,%ecx
    1a63:	01 f1                	add    %esi,%ecx
    1a65:	01 d1                	add    %edx,%ecx
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1a67:	81 f9 ff 01 00 02    	cmp    $0x20001ff,%ecx
    if (!real_pos) {
    1a6d:	77 6b                	ja     1ada <balancer_ingress+0x1ada>
    real_pos = bpf_map_lookup_elem(&ch_rings, &key);
    1a6f:	89 c9                	mov    %ecx,%ecx
    1a71:	48 ba 00 90 9b 21 00 	movabs $0xffffc900219b9000,%rdx
    1a78:	c9 ff ff 
    key = *real_pos;
    1a7b:	8b 9c ca 00 01 00 00 	mov    0x100(%rdx,%rcx,8),%ebx
    1a82:	48 85 db             	test   %rbx,%rbx
    if (key == 0) {
    1a85:	74 2c                	je     1ab3 <balancer_ingress+0x1ab3>
  pckt->real_index = key;
    1a87:	89 5d c0             	mov    %ebx,-0x40(%rbp)
  *real = bpf_map_lookup_elem(&reals, &key);
    1a8a:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  if (!(*real)) {
    1a90:	72 61                	jb     1af3 <balancer_ingress+0x1af3>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1a92:	48 b8 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rax
    1a99:	88 ff ff 
    1a9c:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1aa3:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    1aaa:	b9 bc 
  if (!ch_drop_stats) {
    1aac:	48 85 c0             	test   %rax,%rax
    1aaf:	75 25                	jne    1ad6 <balancer_ingress+0x1ad6>
    1ab1:	eb 27                	jmp    1ada <balancer_ingress+0x1ada>
      bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
    1ab3:	48 b8 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rax
    1aba:	88 ff ff 
    1abd:	48 8b 80 48 11 00 00 	mov    0x1148(%rax),%rax
    1ac4:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    1acb:	b9 bc 
  if (!ch_drop_stats) {
    1acd:	48 85 c0             	test   %rax,%rax
    1ad0:	74 08                	je     1ada <balancer_ingress+0x1ada>
    1ad2:	48 83 c0 08          	add    $0x8,%rax
    1ad6:	48 83 00 01          	addq   $0x1,(%rax)
    1ada:	bb 01 00 00 00       	mov    $0x1,%ebx
    return process_packet(ctx, nh_off, true);
  } else {
    // pass to tcp/ip stack
    return XDP_PASS;
  }
}
    1adf:	89 d8                	mov    %ebx,%eax
    1ae1:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
    1ae8:	5b                   	pop    %rbx
    1ae9:	41 5c                	pop    %r12
    1aeb:	41 5d                	pop    %r13
    1aed:	41 5e                	pop    %r14
    1aef:	41 5f                	pop    %r15
    1af1:	5d                   	pop    %rbp
    1af2:	c3                   	ret
  if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
    1af3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
    1af8:	74 11                	je     1b0b <balancer_ingress+0x1b0b>
    1afa:	41 8a 0e             	mov    (%r14),%cl
    1afd:	80 e1 02             	and    $0x2,%cl
    1b00:	d0 e9                	shr    %cl
    1b02:	41 08 cf             	or     %cl,%r15b
    1b05:	0f 84 cc 00 00 00    	je     1bd7 <balancer_ingress+0x1bd7>
    1b0b:	41 89 d8             	mov    %ebx,%r8d
    1b0e:	e9 ec 00 00 00       	jmp    1bff <balancer_ingress+0x1bff>
    1b13:	48 c7 c0 20 5c 03 b9 	mov    $0xffffffffb9035c20,%rax
  if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
    1b1a:	4c 89 e7             	mov    %r12,%rdi
    1b1d:	be d8 ff ff ff       	mov    $0xffffffd8,%esi
    1b22:	ff d0                	call   *%rax
    1b24:	85 c0                	test   %eax,%eax
    1b26:	75 b2                	jne    1ada <balancer_ingress+0x1ada>
  data = (void*)(long)xdp->data;
    1b28:	49 8b 04 24          	mov    (%r12),%rax
  data_end = (void*)(long)xdp->data_end;
    1b2c:	49 8b 4c 24 08       	mov    0x8(%r12),%rcx
  ip6h = data + sizeof(struct ethhdr);
    1b31:	48 8d 50 0e          	lea    0xe(%rax),%rdx
  if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
    1b35:	48 39 ca             	cmp    %rcx,%rdx
    1b38:	77 a0                	ja     1ada <balancer_ingress+0x1ada>
    1b3a:	48 8d 50 36          	lea    0x36(%rax),%rdx
    1b3e:	bb 01 00 00 00       	mov    $0x1,%ebx
    1b43:	48 39 ca             	cmp    %rcx,%rdx
    1b46:	77 97                	ja     1adf <balancer_ingress+0x1adf>
    1b48:	48 b9 00 74 69 08 81 	movabs $0xffff888108697400,%rcx
    1b4f:	88 ff ff 
  memcpy(new_eth->h_dest, cval->mac, 6);
    1b52:	0f b7 91 04 01 00 00 	movzwl 0x104(%rcx),%edx
    1b59:	66 89 50 04          	mov    %dx,0x4(%rax)
    1b5d:	8b 89 00 01 00 00    	mov    0x100(%rcx),%ecx
    1b63:	89 08                	mov    %ecx,(%rax)
  memcpy(new_eth->h_source, old_eth->h_dest, 6);
    1b65:	8b 48 28             	mov    0x28(%rax),%ecx
    1b68:	89 48 06             	mov    %ecx,0x6(%rax)
    1b6b:	0f b7 48 2c          	movzwl 0x2c(%rax),%ecx
    1b6f:	66 89 48 0a          	mov    %cx,0xa(%rax)
  new_eth->h_proto = BE_ETH_P_IPV6;
    1b73:	66 c7 40 0c 86 dd    	movw   $0xdd86,0xc(%rax)
    1b79:	0f b7 4d b8          	movzwl -0x48(%rbp),%ecx
  saddr[3] = src ^ port;
    1b7d:	33 4d a4             	xor    -0x5c(%rbp),%ecx
    1b80:	8b b5 78 ff ff ff    	mov    -0x88(%rbp),%esi
    payload_len = pkt_bytes + sizeof(struct ipv6hdr);
    1b86:	83 c6 28             	add    $0x28,%esi
  create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
    1b89:	8a 5d c5             	mov    -0x3b(%rbp),%bl
  memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
    1b8c:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  ip6h->priority = (tc & 0xF0) >> 4;
    1b92:	89 da                	mov    %ebx,%edx
    1b94:	c0 ea 04             	shr    $0x4,%dl
    1b97:	80 ca 60             	or     $0x60,%dl
    1b9a:	88 50 0e             	mov    %dl,0xe(%rax)
  ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
    1b9d:	c0 e3 04             	shl    $0x4,%bl
    1ba0:	88 58 0f             	mov    %bl,0xf(%rax)
  ip6h->nexthdr = proto;
    1ba3:	66 c7 40 14 29 40    	movw   $0x4029,0x14(%rax)
  ip6h->payload_len = bpf_htons(payload_len);
    1ba9:	66 c1 c6 08          	rol    $0x8,%si
    1bad:	66 89 70 12          	mov    %si,0x12(%rax)
    1bb1:	48 c7 40 16 01 00 00 	movq   $0x1,0x16(%rax)
    1bb8:	00 
    1bb9:	c7 40 1e 00 00 00 00 	movl   $0x0,0x1e(%rax)
    1bc0:	89 48 22             	mov    %ecx,0x22(%rax)
    1bc3:	49 8b 0e             	mov    (%r14),%rcx
    1bc6:	49 8b 56 08          	mov    0x8(%r14),%rdx
    1bca:	48 89 48 26          	mov    %rcx,0x26(%rax)
    1bce:	48 89 50 2e          	mov    %rdx,0x2e(%rax)
    1bd2:	e9 3e e8 ff ff       	jmp    415 <balancer_ingress+0x415>
    if (pckt->flow.proto == IPPROTO_UDP) {
    1bd7:	80 7d bc 11          	cmpb   $0x11,-0x44(%rbp)
    1bdb:	75 04                	jne    1be1 <balancer_ingress+0x1be1>
      new_dst_lru.atime = cur_time;
    1bdd:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    new_dst_lru.pos = key;
    1be1:	89 5d 80             	mov    %ebx,-0x80(%rbp)
    1be4:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
    1be8:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
    1bec:	48 c7 c0 c0 c9 e9 b6 	mov    $0xffffffffb6e9c9c0,%rax
    1bf3:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
    bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1bf7:	31 c9                	xor    %ecx,%ecx
    1bf9:	ff d0                	call   *%rax
      if (update_vip_lru_miss_stats(&vip, &pckt, vip_info, is_ipv6) >= 0) {
    1bfb:	44 8b 45 c0          	mov    -0x40(%rbp),%r8d
    1bff:	48 b9 00 78 69 08 81 	movabs $0xffff888108697800,%rcx
    1c06:	88 ff ff 
                        (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
    1c09:	8b 81 00 01 00 00    	mov    0x100(%rcx),%eax
    1c0f:	b2 01                	mov    $0x1,%dl
    1c11:	3b 85 60 ff ff ff    	cmp    -0xa0(%rbp),%eax
    1c17:	75 2b                	jne    1c44 <balancer_ingress+0x1c44>
                         lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
    1c19:	8b 81 04 01 00 00    	mov    0x104(%rcx),%eax
    1c1f:	3b 85 64 ff ff ff    	cmp    -0x9c(%rbp),%eax
    1c25:	75 1d                	jne    1c44 <balancer_ingress+0x1c44>
                         lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
    1c27:	8b 81 08 01 00 00    	mov    0x108(%rcx),%eax
    1c2d:	3b 85 68 ff ff ff    	cmp    -0x98(%rbp),%eax
    1c33:	75 0f                	jne    1c44 <balancer_ingress+0x1c44>
    1c35:	8b 81 0c 01 00 00    	mov    0x10c(%rcx),%eax
    1c3b:	3b 85 6c ff ff ff    	cmp    -0x94(%rbp),%eax
    1c41:	0f 95 c2             	setne  %dl
  bool port_match = lru_miss_stat_vip->port == vip->port;
    1c44:	0f b7 b9 10 01 00 00 	movzwl 0x110(%rcx),%edi
    1c4b:	0f b7 b5 70 ff ff ff 	movzwl -0x90(%rbp),%esi
  bool proto_match = lru_miss_stat_vip->proto = vip->proto;
    1c52:	8a 85 72 ff ff ff    	mov    -0x8e(%rbp),%al
    1c58:	88 81 12 01 00 00    	mov    %al,0x112(%rcx)
  bool vip_match = address_match && port_match && proto_match;
    1c5e:	84 d2                	test   %dl,%dl
    1c60:	75 40                	jne    1ca2 <balancer_ingress+0x1ca2>
    1c62:	66 39 f7             	cmp    %si,%di
    1c65:	75 3b                	jne    1ca2 <balancer_ingress+0x1ca2>
    1c67:	84 c0                	test   %al,%al
    1c69:	74 37                	je     1ca2 <balancer_ingress+0x1ca2>
    __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
    1c6b:	41 81 f8 ff 0f 00 00 	cmp    $0xfff,%r8d
    1c72:	0f 87 62 fe ff ff    	ja     1ada <balancer_ingress+0x1ada>
    1c78:	44 89 c0             	mov    %r8d,%eax
    1c7b:	48 b9 00 60 d6 08 00 	movabs $0xffffc90008d66000,%rcx
    1c82:	c9 ff ff 
    1c85:	48 8b 84 c1 00 01 00 	mov    0x100(%rcx,%rax,8),%rax
    1c8c:	00 
    1c8d:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    1c94:	b9 bc 
    if (!lru_miss_stat) {
    1c96:	48 85 c0             	test   %rax,%rax
    1c99:	0f 84 3b fe ff ff    	je     1ada <balancer_ingress+0x1ada>
    *lru_miss_stat += 1;
    1c9f:	83 00 01             	addl   $0x1,(%rax)
    1ca2:	48 8d 04 5b          	lea    (%rbx,%rbx,2),%rax
    1ca6:	48 b9 00 c0 d4 08 00 	movabs $0xffffc90008d4c000,%rcx
    1cad:	c9 ff ff 
    1cb0:	48 8d 3c c1          	lea    (%rcx,%rax,8),%rdi
    1cb4:	48 81 c7 00 01 00 00 	add    $0x100,%rdi
    1cbb:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
      data_stats->v2 += 1;
    1cc2:	48 83 40 08 01       	addq   $0x1,0x8(%rax)
    1cc7:	44 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%r8d
    1cce:	48 be 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rsi
    1cd5:	88 ff ff 
    1cd8:	4c 8b 55 c8          	mov    -0x38(%rbp),%r10
    1cdc:	e9 7f f9 ff ff       	jmp    1660 <balancer_ingress+0x1660>
        (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
    1ce1:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
    1ce5:	48 c1 e1 18          	shl    $0x18,%rcx
    1ce9:	0f b6 50 02          	movzbl 0x2(%rax),%edx
    1ced:	48 c1 e2 10          	shl    $0x10,%rdx
    1cf1:	48 09 ca             	or     %rcx,%rdx
    1cf4:	0f b6 48 03          	movzbl 0x3(%rax),%ecx
    1cf8:	48 c1 e1 08          	shl    $0x8,%rcx
    1cfc:	48 09 d1             	or     %rdx,%rcx
    1cff:	8a 40 04             	mov    0x4(%rax),%al
    1d02:	b2 03                	mov    $0x3,%dl
    1d04:	eb 18                	jmp    1d1e <balancer_ingress+0x1d1e>
    result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
    1d06:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    1d0a:	48 c1 e2 10          	shl    $0x10,%rdx
    1d0e:	0f b6 48 02          	movzbl 0x2(%rax),%ecx
    1d12:	48 c1 e1 08          	shl    $0x8,%rcx
    1d16:	48 09 d1             	or     %rdx,%rcx
    1d19:	8a 40 03             	mov    0x3(%rax),%al
    1d1c:	b2 02                	mov    $0x2,%dl
    1d1e:	0f b6 c0             	movzbl %al,%eax
    1d21:	48 09 c8             	or     %rcx,%rax
      if (qpr.server_id > 0) {
    1d24:	85 c0                	test   %eax,%eax
    1d26:	0f 8e f2 ed ff ff    	jle    b1e <balancer_ingress+0xb1e>
  if (cid_version == QUIC_CONNID_VERSION_V1) {
    1d2c:	80 fa 01             	cmp    $0x1,%dl
    1d2f:	74 61                	je     1d92 <balancer_ingress+0x1d92>
    1d31:	80 fa 03             	cmp    $0x3,%dl
    1d34:	74 63                	je     1d99 <balancer_ingress+0x1d99>
    1d36:	80 fa 02             	cmp    $0x2,%dl
    1d39:	75 65                	jne    1da0 <balancer_ingress+0x1da0>
    1d3b:	b9 40 00 00 00       	mov    $0x40,%ecx
    1d40:	eb 63                	jmp    1da5 <balancer_ingress+0x1da5>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1d42:	48 b8 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rax
    1d49:	88 ff ff 
    1d4c:	4c 8b b0 10 11 00 00 	mov    0x1110(%rax),%r14
    1d53:	65 4c 03 34 25 28 50 	add    %gs:0xffffffffbcb95028,%r14
    1d5a:	b9 bc 
  if (!conn_rate_stats) {
    1d5c:	4d 85 f6             	test   %r14,%r14
    1d5f:	0f 84 54 01 00 00    	je     1eb9 <balancer_ingress+0x1eb9>
    1d65:	48 c7 c0 30 d6 e9 b6 	mov    $0xffffffffb6e9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1d6c:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1d6e:	48 89 c1             	mov    %rax,%rcx
    1d71:	49 2b 4e 08          	sub    0x8(%r14),%rcx
    1d75:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1d7c:	0f 82 f8 00 00 00    	jb     1e7a <balancer_ingress+0x1e7a>
    conn_rate_stats->v1 = 1;
    1d82:	49 c7 06 01 00 00 00 	movq   $0x1,(%r14)
    conn_rate_stats->v2 = *cur_time;
    1d89:	49 89 46 08          	mov    %rax,0x8(%r14)
    1d8d:	e9 fa 00 00 00       	jmp    1e8c <balancer_ingress+0x1e8c>
    1d92:	b9 38 00 00 00       	mov    $0x38,%ecx
    1d97:	eb 0c                	jmp    1da5 <balancer_ingress+0x1da5>
    1d99:	b9 48 00 00 00       	mov    $0x48,%ecx
    1d9e:	eb 05                	jmp    1da5 <balancer_ingress+0x1da5>
    1da0:	b9 30 00 00 00       	mov    $0x30,%ecx
    1da5:	48 83 04 0b 01       	addq   $0x1,(%rbx,%rcx,1)
        __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
    1daa:	3d fd ff ff 00       	cmp    $0xfffffd,%eax
        if (real_pos) {
    1daf:	77 75                	ja     1e26 <balancer_ingress+0x1e26>
    1db1:	48 b9 00 c0 9b 31 00 	movabs $0xffffc900319bc000,%rcx
    1db8:	c9 ff ff 
          key = *real_pos;
    1dbb:	8b 8c c1 00 01 00 00 	mov    0x100(%rcx,%rax,8),%ecx
    1dc2:	48 85 c9             	test   %rcx,%rcx
          if (key == 0) {
    1dc5:	74 5f                	je     1e26 <balancer_ingress+0x1e26>
            pckt.real_index = key;
    1dc7:	89 4d c0             	mov    %ecx,-0x40(%rbp)
    1dca:	45 31 f6             	xor    %r14d,%r14d
            dst = bpf_map_lookup_elem(&reals, &key);
    1dcd:	81 f9 00 10 00 00    	cmp    $0x1000,%ecx
    1dd3:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    1dd7:	48 b9 00 c0 d4 08 00 	movabs $0xffffc90008d4c000,%rcx
    1dde:	c9 ff ff 
    1de1:	48 8d 84 c1 00 01 00 	lea    0x100(%rcx,%rax,8),%rax
    1de8:	00 
    1de9:	4c 0f 42 f0          	cmovb  %rax,%r14
            if (!dst) {
    1ded:	4d 85 f6             	test   %r14,%r14
    1df0:	74 44                	je     1e36 <balancer_ingress+0x1e36>
    1df2:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
    1df6:	48 c7 c0 30 c9 e9 b6 	mov    $0xffffffffb6e9c930,%rax
    1dfd:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
  struct real_pos_lru* dst_lru = real_bpf_map_lookup_elem(lru_map, &pckt->flow);
    1e04:	ff d0                	call   *%rax
  if (dst_lru) {
    1e06:	48 85 c0             	test   %rax,%rax
    1e09:	0f 84 dd 00 00 00    	je     1eec <balancer_ingress+0x1eec>
    if (dst_lru->pos == pckt->real_index) {
    1e0f:	8b 4d c0             	mov    -0x40(%rbp),%ecx
    1e12:	39 08                	cmp    %ecx,(%rax)
    1e14:	0f 85 1b 01 00 00    	jne    1f35 <balancer_ingress+0x1f35>
              quic_packets_stats->dst_match_in_lru += 1;
    1e1a:	48 89 d8             	mov    %rbx,%rax
    1e1d:	48 83 c0 50          	add    $0x50,%rax
    1e21:	e9 98 01 00 00       	jmp    1fbe <balancer_ingress+0x1fbe>
    1e26:	48 83 43 10 01       	addq   $0x1,0x10(%rbx)
    1e2b:	48 98                	cltq
    1e2d:	48 89 43 18          	mov    %rax,0x18(%rbx)
    1e31:	e9 e8 ec ff ff       	jmp    b1e <balancer_ingress+0xb1e>
    1e36:	48 83 43 28 01       	addq   $0x1,0x28(%rbx)
    1e3b:	e9 9a fc ff ff       	jmp    1ada <balancer_ingress+0x1ada>
      dst_lru->pos = pckt->real_index;
    1e40:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1e42:	48 83 43 58 01       	addq   $0x1,0x58(%rbx)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1e47:	81 7d c8 ff 01 00 00 	cmpl   $0x1ff,-0x38(%rbp)
    1e4e:	77 74                	ja     1ec4 <balancer_ingress+0x1ec4>
    1e50:	48 b8 00 00 69 26 81 	movabs $0xffff888126690000,%rax
    1e57:	88 ff ff 
    1e5a:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    1e5e:	48 8b 84 c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rax
    1e65:	00 
    1e66:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    1e6d:	b9 bc 
  if (!per_vip_stats) {
    1e6f:	48 85 c0             	test   %rax,%rax
    1e72:	74 50                	je     1ec4 <balancer_ingress+0x1ec4>
    per_vip_stats->v2 += 1;
    1e74:	48 83 c0 08          	add    $0x8,%rax
    1e78:	eb 46                	jmp    1ec0 <balancer_ingress+0x1ec0>
    conn_rate_stats->v1 += 1;
    1e7a:	49 8b 06             	mov    (%r14),%rax
    1e7d:	48 83 c0 01          	add    $0x1,%rax
    1e81:	49 89 06             	mov    %rax,(%r14)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1e84:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    1e8a:	77 2d                	ja     1eb9 <balancer_ingress+0x1eb9>
  struct real_pos_lru new_dst_lru = {};
    1e8c:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
    1e93:	00 
    1e94:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    1e9b:	00 
  new_dst_lru.pos = pckt->real_index;
    1e9c:	8b 45 c0             	mov    -0x40(%rbp),%eax
    1e9f:	89 45 80             	mov    %eax,-0x80(%rbp)
    1ea2:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
    1ea6:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
    1eaa:	48 c7 c0 c0 c9 e9 b6 	mov    $0xffffffffb6e9c9c0,%rax
    1eb1:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1eb5:	31 c9                	xor    %ecx,%ecx
    1eb7:	ff d0                	call   *%rax
              quic_packets_stats->dst_not_found_in_lru += 1;
    1eb9:	48 89 d8             	mov    %rbx,%rax
    1ebc:	48 83 c0 60          	add    $0x60,%rax
    1ec0:	48 83 00 01          	addq   $0x1,(%rax)
            quic_packets_stats->cid_routed += 1;
    1ec4:	48 83 43 20 01       	addq   $0x1,0x20(%rbx)
  original_sport = pckt.flow.port16[0];
    1ec9:	0f b7 45 b8          	movzwl -0x48(%rbp),%eax
    1ecd:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%rbp)
    1ed3:	45 89 e8             	mov    %r13d,%r8d
    1ed6:	48 be 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rsi
    1edd:	88 ff ff 
    1ee0:	4c 8b 55 c8          	mov    -0x38(%rbp),%r10
    1ee4:	4c 89 ff             	mov    %r15,%rdi
    1ee7:	e9 74 f7 ff ff       	jmp    1660 <balancer_ingress+0x1660>
      bpf_map_lookup_elem(&stats, &conn_rate_key);
    1eec:	48 b8 00 00 98 b3 81 	movabs $0xffff8881b3980000,%rax
    1ef3:	88 ff ff 
    1ef6:	4c 8b b8 10 11 00 00 	mov    0x1110(%rax),%r15
    1efd:	65 4c 03 3c 25 28 50 	add    %gs:0xffffffffbcb95028,%r15
    1f04:	b9 bc 
  if (!conn_rate_stats) {
    1f06:	4d 85 ff             	test   %r15,%r15
    1f09:	0f 84 a8 00 00 00    	je     1fb7 <balancer_ingress+0x1fb7>
    1f0f:	48 c7 c0 30 d6 e9 b6 	mov    $0xffffffffb6e9d630,%rax
  *cur_time = bpf_ktime_get_ns();
    1f16:	ff d0                	call   *%rax
  if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
    1f18:	48 89 c1             	mov    %rax,%rcx
    1f1b:	49 2b 4f 08          	sub    0x8(%r15),%rcx
    1f1f:	48 81 f9 01 ca 9a 3b 	cmp    $0x3b9aca01,%rcx
    1f26:	72 4d                	jb     1f75 <balancer_ingress+0x1f75>
    conn_rate_stats->v1 = 1;
    1f28:	49 c7 07 01 00 00 00 	movq   $0x1,(%r15)
    conn_rate_stats->v2 = *cur_time;
    1f2f:	49 89 47 08          	mov    %rax,0x8(%r15)
    1f33:	eb 52                	jmp    1f87 <balancer_ingress+0x1f87>
      dst_lru->pos = pckt->real_index;
    1f35:	89 08                	mov    %ecx,(%rax)
              quic_packets_stats->dst_mismatch_in_lru += 1;
    1f37:	48 83 43 58 01       	addq   $0x1,0x58(%rbx)
      bpf_map_lookup_elem(&server_id_stats, &vip_num);
    1f3c:	81 bd 48 ff ff ff ff 	cmpl   $0x1ff,-0xb8(%rbp)
    1f43:	01 00 00 
    1f46:	77 7a                	ja     1fc2 <balancer_ingress+0x1fc2>
    1f48:	48 b8 00 00 69 26 81 	movabs $0xffff888126690000,%rax
    1f4f:	88 ff ff 
    1f52:	48 8b 8d 48 ff ff ff 	mov    -0xb8(%rbp),%rcx
    1f59:	48 8b 84 c8 00 01 00 	mov    0x100(%rax,%rcx,8),%rax
    1f60:	00 
    1f61:	65 48 03 04 25 28 50 	add    %gs:0xffffffffbcb95028,%rax
    1f68:	b9 bc 
  if (!per_vip_stats) {
    1f6a:	48 85 c0             	test   %rax,%rax
    1f6d:	74 53                	je     1fc2 <balancer_ingress+0x1fc2>
    per_vip_stats->v2 += 1;
    1f6f:	48 83 c0 08          	add    $0x8,%rax
    1f73:	eb 49                	jmp    1fbe <balancer_ingress+0x1fbe>
    conn_rate_stats->v1 += 1;
    1f75:	49 8b 07             	mov    (%r15),%rax
    1f78:	48 83 c0 01          	add    $0x1,%rax
    1f7c:	49 89 07             	mov    %rax,(%r15)
    if (conn_rate_stats->v1 > MAX_CONN_RATE) {
    1f7f:	48 3d 48 e8 01 00    	cmp    $0x1e848,%rax
    1f85:	77 30                	ja     1fb7 <balancer_ingress+0x1fb7>
  struct real_pos_lru new_dst_lru = {};
    1f87:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
    1f8e:	00 
    1f8f:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    1f96:	00 
  new_dst_lru.pos = pckt->real_index;
    1f97:	8b 45 c0             	mov    -0x40(%rbp),%eax
    1f9a:	89 45 80             	mov    %eax,-0x80(%rbp)
    1f9d:	48 8d 75 98          	lea    -0x68(%rbp),%rsi
    1fa1:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
    1fa5:	48 c7 c0 c0 c9 e9 b6 	mov    $0xffffffffb6e9c9c0,%rax
    1fac:	48 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%rdi
  bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
    1fb3:	31 c9                	xor    %ecx,%ecx
    1fb5:	ff d0                	call   *%rax
              quic_packets_stats->dst_not_found_in_lru += 1;
    1fb7:	48 89 d8             	mov    %rbx,%rax
    1fba:	48 83 c0 60          	add    $0x60,%rax
    1fbe:	48 83 00 01          	addq   $0x1,(%rax)
            quic_packets_stats->cid_routed += 1;
    1fc2:	48 83 43 20 01       	addq   $0x1,0x20(%rbx)
  original_sport = pckt.flow.port16[0];
    1fc7:	44 0f b7 7d b8       	movzwl -0x48(%rbp),%r15d
    1fcc:	e9 e7 f3 ff ff       	jmp    13b8 <balancer_ingress+0x13b8>
