int balancer_ingress(struct xdp_md * ctx):
bpf_prog_1be7137e798a4bcc_balancer_ingress:
; int balancer_ingress(struct xdp_md* ctx) {
   0:	endbr64
   4:	nopl   0x0(%rax,%rax,1)
   9:	xor    %rax,%rax
   c:	push   %rbp
   d:	mov    %rsp,%rbp
  10:	endbr64
  14:	sub    $0xd8,%rsp
  1b:	cmp    $0x21,%rax
  1f:	ja     0xffffffffc01d1fb3
  21:	push   %rax
  22:	mov    %rsp,%rax
  25:	jmp    0xffffffffc01d1fb4
  27:	push   %rax
  28:	push   %rax
  29:	push   %rbx
  2a:	push   %r13
  2c:	push   %r14
  2e:	push   %r15
  30:	mov    %rdi,%rbx
  33:	mov    $0x1,%r14d
; void* data_end = (void*)(long)ctx->data_end;
  39:	mov    0x8(%rbx),%r13
; void* data = (void*)(long)ctx->data;
  3d:	mov    0x0(%rbx),%r15
; if (data + nh_off > data_end) {
  41:	mov    %r15,%rdi
  44:	add    $0xe,%rdi
; if (data + nh_off > data_end) {
  48:	cmp    %r13,%rdi
  4b:	ja     0xffffffffc01d3469
; eth_proto = eth->h_proto;
  51:	movzbq 0xc(%r15),%rdx
  56:	movzbq 0xd(%r15),%rsi
  5b:	shl    $0x8,%rsi
  5f:	or     %rdx,%rsi
; if (eth_proto == BE_ETH_P_IP) {
  62:	cmp    $0xdd86,%rsi
  69:	je     0xffffffffc01d21a1
  6f:	mov    $0x2,%r14d
  75:	cmp    $0x8,%rsi
  79:	jne    0xffffffffc01d3469
  7f:	xor    %esi,%esi
; struct packet_description pckt = {};
  81:	mov    %rsi,-0x10(%rbp)
  85:	mov    %rsi,-0x18(%rbp)
  89:	mov    %rsi,-0x20(%rbp)
  8d:	mov    %rsi,-0x28(%rbp)
  91:	mov    %rsi,-0x30(%rbp)
  95:	mov    %rsi,-0x38(%rbp)
; struct vip_definition vip = {};
  99:	mov    %esi,-0x40(%rbp)
  9c:	mov    %rsi,-0x48(%rbp)
  a0:	mov    %rsi,-0x50(%rbp)
; __u32 mac_addr_pos = 0;
  a4:	mov    %esi,-0x58(%rbp)
; if (iph + 1 > data_end) {
  a7:	mov    %r15,%rdx
  aa:	add    $0x22,%rdx
; 
  ae:	mov    $0x1,%r14d
; if (iph + 1 > data_end) {
  b4:	cmp    %r13,%rdx
  b7:	ja     0xffffffffc01d3469
; if (iph->ihl != 5) {
  bd:	movzbq 0x0(%rdi),%rdi
  c2:	and    $0xf,%rdi
; 
  c6:	mov    $0x1,%r14d
; if (iph->ihl != 5) {
  cc:	cmp    $0x5,%rdi
  d0:	jne    0xffffffffc01d3469
; pckt->tos = iph->tos;
  d6:	movzbq 0xf(%r15),%rdi
; pckt->tos = iph->tos;
  db:	mov    %dil,-0xb(%rbp)
; *protocol = iph->protocol;
  df:	movzbq 0x17(%r15),%rdi
; pckt->flow.proto = *protocol;
  e4:	mov    %dil,-0x14(%rbp)
; if (iph->frag_off & PCKT_FRAGMENTED) {
  e8:	movzwq 0x14(%r15),%rcx
; if (iph->frag_off & PCKT_FRAGMENTED) {
  ed:	mov    %rcx,%rsi
  f0:	and    $0xff3f,%rsi
; 
  f7:	mov    $0x1,%r14d
; if (iph->frag_off & PCKT_FRAGMENTED) {
  fd:	test   %rsi,%rsi
 100:	jne    0xffffffffc01d3469
; 
 106:	movzwq 0x10(%r15),%rax
; if (*protocol == IPPROTO_ICMP) {
 10b:	mov    %rdi,%r8
; if (*protocol == IPPROTO_ICMP) {
 10e:	cmp    $0x1,%r8
 112:	je     0xffffffffc01d24a7
; pckt->flow.src = iph->saddr;
 118:	mov    0x1a(%r15),%esi
; pckt->flow.src = iph->saddr;
 11c:	mov    %esi,-0x38(%rbp)
; pckt->flow.dst = iph->daddr;
 11f:	mov    0x1e(%r15),%esi
; pckt->flow.dst = iph->daddr;
 123:	mov    %esi,-0x28(%rbp)
 126:	xor    %esi,%esi
; if (protocol == IPPROTO_ICMPV6) {
 128:	cmp    $0x3a,%r8
 12c:	jne    0xffffffffc01d3223
; if (icmp_hdr + 1 > data_end) {
 132:	mov    %r15,%rdi
 135:	add    $0x2a,%rdi
; 
 139:	mov    $0x1,%r14d
; if (icmp_hdr + 1 > data_end) {
 13f:	cmp    %r13,%rdi
 142:	ja     0xffffffffc01d3469
; if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 148:	movzbq 0x0(%rdx),%rdi
; if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 14d:	cmp    $0x1,%rdi
 151:	je     0xffffffffc01d31ae
 157:	cmp    $0x2,%rdi
 15b:	je     0xffffffffc01d3134
 161:	mov    $0x2,%r14d
 167:	cmp    $0x80,%rdi
 16e:	jne    0xffffffffc01d3469
 174:	mov    $0x1,%r14d
; if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 17a:	mov    %r15,%rdi
 17d:	add    $0x3e,%rdi
; if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 181:	cmp    %r13,%rdi
 184:	ja     0xffffffffc01d3469
 18a:	mov    $0x81,%edi
; 
 18f:	mov    %dil,0x36(%r15)
 193:	mov    $0x40,%edi
 198:	mov    %dil,0x15(%r15)
 19c:	movzwq 0x38(%r15),%rdi
 1a1:	add    $0xffffffffffffffff,%rdi
 1a5:	mov    %di,0x38(%r15)
 1aa:	mov    0x22(%r15),%edi
 1ae:	shl    $0x20,%rdi
 1b2:	mov    0x1e(%r15),%esi
 1b6:	or     %rsi,%rdi
 1b9:	mov    %rdi,-0x78(%rbp)
 1bd:	mov    0x1a(%r15),%edi
 1c1:	shl    $0x20,%rdi
 1c5:	mov    0x16(%r15),%esi
 1c9:	or     %rsi,%rdi
 1cc:	mov    %rdi,-0x80(%rbp)
 1d0:	mov    0x26(%r15),%edi
 1d4:	mov    %edi,0x16(%r15)
 1d8:	mov    0x2a(%r15),%edi
 1dc:	mov    %edi,0x1a(%r15)
 1e0:	mov    0x2e(%r15),%edi
 1e4:	mov    %edi,0x1e(%r15)
 1e8:	mov    0x32(%r15),%edi
 1ec:	mov    %edi,0x22(%r15)
 1f0:	mov    -0x80(%rbp),%rdi
 1f4:	mov    %edi,0x26(%r15)
 1f8:	shr    $0x20,%rdi
 1fc:	mov    %edi,0x2a(%r15)
 200:	mov    -0x78(%rbp),%rdi
 204:	mov    %edi,0x2e(%r15)
 208:	shr    $0x20,%rdi
 20c:	mov    %edi,0x32(%r15)
 210:	jmp    0xffffffffc01d239c
 215:	xor    %edi,%edi
; struct packet_description pckt = {};
 217:	mov    %rdi,-0x10(%rbp)
 21b:	mov    %rdi,-0x18(%rbp)
 21f:	mov    %rdi,-0x20(%rbp)
 223:	mov    %rdi,-0x28(%rbp)
 227:	mov    %rdi,-0x30(%rbp)
 22b:	mov    %rdi,-0x38(%rbp)
; struct vip_definition vip = {};
 22f:	mov    %edi,-0x40(%rbp)
 232:	mov    %rdi,-0x48(%rbp)
 236:	mov    %rdi,-0x50(%rbp)
; __u32 mac_addr_pos = 0;
 23a:	mov    %edi,-0x58(%rbp)
; if (ip6h + 1 > data_end) {
 23d:	mov    %r15,%rdx
 240:	add    $0x36,%rdx
; 
 244:	mov    $0x1,%r14d
; if (ip6h + 1 > data_end) {
 24a:	cmp    %r13,%rdx
 24d:	ja     0xffffffffc01d3469
; *protocol = ip6h->nexthdr;
 253:	movzbq 0x14(%r15),%rdi
; pckt->flow.proto = *protocol;
 258:	mov    %dil,-0x14(%rbp)
; pckt->tos = (ip6h->priority << 4) & 0xF0;
 25c:	movzbq 0xe(%r15),%rsi
; pckt->tos = (ip6h->priority << 4) & 0xF0;
 261:	shl    $0x4,%rsi
; pckt->tos = (ip6h->priority << 4) & 0xF0;
 265:	mov    %sil,-0xb(%rbp)
; pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 269:	movzbq 0xf(%r15),%rcx
; pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 26e:	shr    $0x4,%rcx
; pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 272:	or     %rsi,%rcx
; pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 275:	mov    %cl,-0xb(%rbp)
; 
 278:	mov    $0x1,%r14d
; if (*protocol == IPPROTO_FRAGMENT) {
 27e:	cmp    $0x2c,%rdi
 282:	je     0xffffffffc01d3469
; 
 288:	movzwq 0x12(%r15),%rax
; if (*protocol == IPPROTO_FRAGMENT) {
 28d:	cmp    $0x3a,%rdi
 291:	je     0xffffffffc01d2460
; memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 297:	mov    0x22(%r15),%esi
 29b:	shl    $0x20,%rsi
 29f:	mov    0x1e(%r15),%ecx
 2a3:	or     %rcx,%rsi
 2a6:	mov    %rsi,-0x30(%rbp)
 2aa:	mov    0x1a(%r15),%esi
 2ae:	shl    $0x20,%rsi
 2b2:	mov    0x16(%r15),%ecx
 2b6:	or     %rcx,%rsi
 2b9:	mov    %rsi,-0x38(%rbp)
; memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2bd:	mov    0x32(%r15),%esi
 2c1:	shl    $0x20,%rsi
 2c5:	mov    0x2e(%r15),%ecx
 2c9:	or     %rcx,%rsi
 2cc:	mov    %rsi,-0x20(%rbp)
 2d0:	mov    0x26(%r15),%esi
 2d4:	mov    0x2a(%r15),%ecx
 2d8:	shl    $0x20,%rcx
 2dc:	or     %rsi,%rcx
 2df:	mov    %rcx,-0x28(%rbp)
 2e3:	xor    %esi,%esi
; if (protocol == IPPROTO_ICMPV6) {
 2e5:	cmp    $0x1,%rdi
 2e9:	je     0xffffffffc01d227c
 2eb:	jmp    0xffffffffc01d266a
; if (icmp_hdr + 1 > data_end) {
 2f0:	mov    %r15,%rsi
 2f3:	add    $0x3e,%rsi
; 
 2f7:	mov    $0x1,%r14d
; if (icmp_hdr + 1 > data_end) {
 2fd:	cmp    %r13,%rsi
 300:	ja     0xffffffffc01d3469
; if (icmp_hdr->type == ICMP_ECHO) {
 306:	movzbq 0x0(%rdx),%rdi
; if (icmp_hdr->type == ICMP_ECHO) {
 30b:	cmp    $0x3,%rdi
 30f:	je     0xffffffffc01d27f5
 315:	mov    $0x2,%r14d
 31b:	cmp    $0x8,%rdi
 31f:	jne    0xffffffffc01d3469
; if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 325:	mov    %r15,%rdi
 328:	add    $0x2a,%rdi
; 
 32c:	mov    $0x1,%r14d
; if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 332:	cmp    %r13,%rdi
 335:	ja     0xffffffffc01d3469
; tmp_addr = iph->daddr;
 33b:	mov    0x1e(%r15),%esi
; *csum += *next_iph_u16++;
 33f:	mov    %rsi,%rdx
 342:	and    $0xffff,%rdx
 349:	mov    %rsi,%rdi
 34c:	shr    $0x10,%rdi
; *csum += *next_iph_u16++;
 350:	add    %rdx,%rdi
; iph->daddr = iph->saddr;
 353:	mov    0x1a(%r15),%edx
; *csum += *next_iph_u16++;
 357:	mov    %rdx,%rcx
 35a:	and    $0xffff,%rcx
; *csum += *next_iph_u16++;
 361:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 364:	mov    %rdx,%rcx
 367:	shr    $0x10,%rcx
; *csum += *next_iph_u16++;
 36b:	add    %rcx,%rdi
 36e:	mov    $0x40,%ecx
; iph->ttl = DEFAULT_TTL;
 373:	mov    %cl,0x16(%r15)
; *csum += *next_iph_u16++;
 377:	movzwq 0xe(%r15),%rcx
; *csum += *next_iph_u16++;
 37c:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 37f:	movzwq 0x10(%r15),%rcx
; *csum += *next_iph_u16++;
 384:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 387:	movzwq 0x12(%r15),%rcx
; *csum += *next_iph_u16++;
 38c:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 38f:	movzwq 0x14(%r15),%rcx
; *csum += *next_iph_u16++;
 394:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 397:	movzwq 0x16(%r15),%rcx
; *csum += *next_iph_u16++;
 39c:	add    %rcx,%rdi
; if (csum >> 16)
 39f:	mov    %rdi,%rcx
 3a2:	shr    $0x10,%rcx
; if (csum >> 16)
 3a6:	test   %rcx,%rcx
 3a9:	je     0xffffffffc01d2341
 3ab:	and    $0xffff,%rdi
 3b2:	add    %rcx,%rdi
; if (csum >> 16)
 3b5:	mov    %rdi,%rcx
 3b8:	shr    $0x10,%rcx
; if (csum >> 16)
 3bc:	test   %rcx,%rcx
 3bf:	je     0xffffffffc01d2357
 3c1:	and    $0xffff,%rdi
 3c8:	add    %rcx,%rdi
; if (csum >> 16)
 3cb:	mov    %rdi,%rcx
 3ce:	shr    $0x10,%rcx
; if (csum >> 16)
 3d2:	test   %rcx,%rcx
 3d5:	je     0xffffffffc01d236d
 3d7:	and    $0xffff,%rdi
 3de:	add    %rcx,%rdi
 3e1:	xor    %ecx,%ecx
; 
 3e3:	mov    %cl,0x22(%r15)
 3e7:	mov    %edx,0x1e(%r15)
 3eb:	mov    %esi,0x1a(%r15)
 3ef:	movzwq 0x24(%r15),%rsi
 3f4:	add    $0x8,%rsi
 3f8:	mov    %si,0x24(%r15)
 3fd:	mov    %rdi,%rsi
 400:	shr    $0x10,%rsi
 404:	add    %rdi,%rsi
 407:	xor    $0xffffffffffffffff,%rsi
 40b:	mov    %si,0x18(%r15)
 410:	movzbq 0xb(%r15),%rdi
 415:	shl    $0x8,%rdi
 419:	movzbq 0xa(%r15),%rsi
 41e:	or     %rsi,%rdi
 421:	mov    %di,-0x84(%rbp)
 428:	movzbq 0x7(%r15),%rdi
 42d:	shl    $0x8,%rdi
 431:	movzbq 0x6(%r15),%rsi
 436:	or     %rsi,%rdi
 439:	movzbq 0x9(%r15),%rsi
 43e:	shl    $0x8,%rsi
 442:	movzbq 0x8(%r15),%rdx
 447:	or     %rdx,%rsi
 44a:	shl    $0x10,%rsi
 44e:	or     %rdi,%rsi
 451:	mov    %esi,-0x88(%rbp)
 457:	movzbq 0x2(%r15),%rdi
 45c:	mov    %dil,0x8(%r15)
 460:	movzbq 0x3(%r15),%rdi
 465:	mov    %dil,0x9(%r15)
 469:	movzbq 0x0(%r15),%rdi
 46e:	mov    %dil,0x6(%r15)
 472:	movzbq 0x1(%r15),%rdi
 477:	mov    %dil,0x7(%r15)
 47b:	movzbq 0x4(%r15),%rdi
 480:	mov    %dil,0xa(%r15)
 484:	movzbq 0x5(%r15),%rdi
 489:	mov    %dil,0xb(%r15)
 48d:	mov    -0x88(%rbp),%edi
 493:	mov    %rdi,%rsi
 496:	shr    $0x10,%rsi
 49a:	mov    %sil,0x2(%r15)
 49e:	mov    %rdi,%rsi
 4a1:	shr    $0x18,%rsi
 4a5:	mov    %sil,0x3(%r15)
 4a9:	mov    %dil,0x0(%r15)
 4ad:	shr    $0x8,%rdi
 4b1:	mov    %dil,0x1(%r15)
 4b5:	movzwq -0x84(%rbp),%rdi
 4bd:	mov    %dil,0x4(%r15)
 4c1:	shr    $0x8,%rdi
 4c5:	mov    %dil,0x5(%r15)
 4c9:	mov    $0x3,%r14d
 4cf:	jmp    0xffffffffc01d3469
; if (icmp_hdr + 1 > data_end) {
 4d4:	mov    %r15,%rdi
 4d7:	add    $0x3e,%rdi
; 
 4db:	mov    $0x1,%r14d
; if (icmp_hdr + 1 > data_end) {
 4e1:	cmp    %r13,%rdi
 4e4:	ja     0xffffffffc01d3469
; if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 4ea:	movzbq 0x0(%rdx),%rdi
; if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 4ef:	cmp    $0x1,%rdi
 4f3:	je     0xffffffffc01d25f2
 4f9:	cmp    $0x2,%rdi
 4fd:	je     0xffffffffc01d2578
 503:	mov    $0x2,%r14d
 509:	cmp    $0x80,%rdi
 510:	jne    0xffffffffc01d3469
 516:	jmp    0xffffffffc01d2116
; if (icmp_hdr + 1 > data_end) {
 51b:	mov    %r15,%rsi
 51e:	add    $0x2a,%rsi
; 
 522:	mov    $0x1,%r14d
; if (icmp_hdr + 1 > data_end) {
 528:	cmp    %r13,%rsi
 52b:	ja     0xffffffffc01d3469
; if (icmp_hdr->type == ICMP_ECHO) {
 531:	movzbq 0x0(%rdx),%rdi
; if (icmp_hdr->type == ICMP_ECHO) {
 536:	cmp    $0x3,%rdi
 53a:	je     0xffffffffc01d3042
 540:	mov    $0x2,%r14d
 546:	cmp    $0x8,%rdi
 54a:	jne    0xffffffffc01d3469
; tmp_addr = iph->daddr;
 550:	mov    0x1e(%r15),%esi
; *csum += *next_iph_u16++;
 554:	mov    %rsi,%rdx
 557:	and    $0xffff,%rdx
 55e:	mov    %rsi,%rdi
 561:	shr    $0x10,%rdi
; *csum += *next_iph_u16++;
 565:	add    %rdx,%rdi
; iph->daddr = iph->saddr;
 568:	mov    0x1a(%r15),%edx
; *csum += *next_iph_u16++;
 56c:	mov    %rdx,%r8
 56f:	and    $0xffff,%r8
; *csum += *next_iph_u16++;
 576:	add    %r8,%rdi
; *csum += *next_iph_u16++;
 579:	mov    %rdx,%r8
 57c:	shr    $0x10,%r8
; *csum += *next_iph_u16++;
 580:	add    %r8,%rdi
 583:	mov    $0x40,%r8d
; iph->ttl = DEFAULT_TTL;
 589:	mov    %r8b,0x16(%r15)
; *csum += *next_iph_u16++;
 58d:	movzwq 0xe(%r15),%r8
; *csum += *next_iph_u16++;
 592:	add    %r8,%rdi
 595:	add    %rax,%rdi
; *csum += *next_iph_u16++;
 598:	movzwq 0x12(%r15),%r8
; *csum += *next_iph_u16++;
 59d:	add    %r8,%rdi
 5a0:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 5a3:	movzwq 0x16(%r15),%rcx
; *csum += *next_iph_u16++;
 5a8:	add    %rcx,%rdi
; if (csum >> 16)
 5ab:	mov    %rdi,%rcx
 5ae:	shr    $0x10,%rcx
; if (csum >> 16)
 5b2:	test   %rcx,%rcx
 5b5:	je     0xffffffffc01d254d
 5b7:	and    $0xffff,%rdi
 5be:	add    %rcx,%rdi
; if (csum >> 16)
 5c1:	mov    %rdi,%rcx
 5c4:	shr    $0x10,%rcx
; if (csum >> 16)
 5c8:	test   %rcx,%rcx
 5cb:	je     0xffffffffc01d2563
 5cd:	and    $0xffff,%rdi
 5d4:	add    %rcx,%rdi
; if (csum >> 16)
 5d7:	mov    %rdi,%rcx
 5da:	shr    $0x10,%rcx
; if (csum >> 16)
 5de:	test   %rcx,%rcx
 5e1:	je     0xffffffffc01d236d
 5e7:	jmp    0xffffffffc01d2363
 5ec:	mov    %rax,%r14
 5ef:	mov    $0x20c,%edi
; __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
 5f4:	mov    %edi,-0x80(%rbp)
 5f7:	mov    %rbp,%rsi
; 
 5fa:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &stats_key);
 5fe:	movabs $0xffff8881a98d8000,%rdi
 608:	add    $0x100,%rdi
 60f:	mov    0x0(%rsi),%eax
 612:	cmp    $0x400,%rax
 619:	jae    0xffffffffc01d25bd
 61b:	shl    $0x3,%rax
 61f:	add    %rdi,%rax
 622:	mov    0x0(%rax),%rax
 626:	add    %gs:0xffffffffaa995028,%rax
 62f:	jmp    0xffffffffc01d25bf
 631:	xor    %eax,%eax
; if (!icmp_ptb_v6_stats) {
 633:	test   %rax,%rax
 636:	je     0xffffffffc01d3463
; icmp_ptb_v6_stats->v1 += 1;
 63c:	mov    0x0(%rax),%rdi
 640:	add    $0x1,%rdi
 644:	mov    %rdi,0x0(%rax)
; __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 648:	mov    0x3a(%r15),%edi
 64c:	bswap  %edi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 64e:	cmp    $0x4ff,%rdi
 655:	ja     0xffffffffc01d25ef
; icmp_ptb_v6_stats->v2 += 1;
 657:	mov    0x8(%rax),%rdi
 65b:	add    $0x1,%rdi
 65f:	mov    %rdi,0x8(%rax)
 663:	mov    %r14,%rax
; if (ip6h + 1 > data_end) {
 666:	mov    %r15,%rdi
 669:	add    $0x66,%rdi
; 
 66d:	mov    $0x1,%r14d
; if (ip6h + 1 > data_end) {
 673:	cmp    %r13,%rdi
 676:	ja     0xffffffffc01d3469
; pckt->flow.proto = ip6h->nexthdr;
 67c:	movzbq 0x44(%r15),%rdi
; pckt->flow.proto = ip6h->nexthdr;
 681:	mov    %dil,-0x14(%rbp)
; pckt->flags |= F_ICMP;
 685:	movzbq -0xc(%rbp),%rsi
 68a:	or     $0x1,%rsi
 68e:	mov    %sil,-0xc(%rbp)
; memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 692:	mov    0x5a(%r15),%edx
 696:	shl    $0x20,%rdx
 69a:	mov    0x56(%r15),%ecx
 69e:	or     %rcx,%rdx
 6a1:	mov    %rdx,-0x38(%rbp)
 6a5:	mov    0x62(%r15),%edx
 6a9:	shl    $0x20,%rdx
 6ad:	mov    0x5e(%r15),%ecx
 6b1:	or     %rcx,%rdx
 6b4:	mov    %rdx,-0x30(%rbp)
; memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 6b8:	mov    0x4a(%r15),%edx
 6bc:	shl    $0x20,%rdx
 6c0:	mov    0x46(%r15),%ecx
 6c4:	or     %rcx,%rdx
 6c7:	mov    %rdx,-0x28(%rbp)
 6cb:	mov    0x4e(%r15),%edx
 6cf:	mov    0x52(%r15),%ecx
 6d3:	shl    $0x20,%rcx
 6d7:	or     %rdx,%rcx
 6da:	mov    %rcx,-0x20(%rbp)
; if (protocol == IPPROTO_IPIP) {
 6de:	mov    %rdi,%rdx
 6e1:	cmp    $0x10,%rdx
 6e5:	jg     0xffffffffc01d2708
 6eb:	cmp    $0x4,%rdx
 6ef:	je     0xffffffffc01d276a
; 
 6f5:	mov    $0x2,%r14d
; if (protocol == IPPROTO_IPIP) {
 6fb:	cmp    $0x6,%rdx
 6ff:	je     0xffffffffc01d2692
 701:	jmp    0xffffffffc01d3469
; bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 706:	mov    %rsi,%rcx
 709:	and    $0x1,%rcx
 70d:	mov    $0x36,%r8d
; if (is_ipv6) {
 713:	test   %rcx,%rcx
 716:	je     0xffffffffc01d26aa
 718:	mov    $0x66,%r8d
; tcp = data + off;
 71e:	mov    %r15,%rdx
 721:	add    %r8,%rdx
; if (tcp + 1 > data_end) {
 724:	mov    %rdx,%r8
 727:	add    $0x14,%r8
; 
 72b:	mov    $0x1,%r14d
; if (tcp + 1 > data_end) {
 731:	cmp    %r13,%r8
 734:	ja     0xffffffffc01d3469
; if (tcp->syn) {
 73a:	movzwq 0xc(%rdx),%r8
; if (tcp->syn) {
 73f:	and    $0x200,%r8
; if (tcp->syn) {
 746:	test   %r8,%r8
 749:	je     0xffffffffc01d26df
; pckt->flags |= F_SYN_SET;
 74b:	or     $0x2,%rsi
 74f:	mov    %sil,-0xc(%rbp)
 753:	mov    %rax,-0x90(%rbp)
; if (!is_icmp) {
 75a:	test   %rcx,%rcx
 75d:	jne    0xffffffffc01d2985
; 
 763:	movzwq 0x0(%rdx),%rsi
 768:	mov    %si,-0x18(%rbp)
 76c:	mov    %rbp,%rcx
 76f:	add    $0xffffffffffffffe8,%rcx
 773:	add    $0x2,%rdx
 777:	jmp    0xffffffffc01d2995
; if (protocol == IPPROTO_IPIP) {
 77c:	cmp    $0x11,%rdx
 780:	je     0xffffffffc01d27b1
; 
 786:	mov    $0x2,%r14d
; if (protocol == IPPROTO_IPIP) {
 78c:	cmp    $0x29,%rdx
 790:	je     0xffffffffc01d2723
 792:	jmp    0xffffffffc01d3469
; memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 797:	mov    -0x20(%rbp),%rdi
 79b:	mov    %rdi,-0x78(%rbp)
 79f:	mov    -0x28(%rbp),%rdi
 7a3:	mov    %rdi,-0x80(%rbp)
 7a7:	mov    %rbp,%rsi
; 
 7aa:	add    $0xffffffffffffff80,%rsi
; __u32* decap_dst_flags = bpf_map_lookup_elem(&decap_dst, &dst_addr);
 7ae:	movabs $0xffff8881a9939000,%rdi
 7b8:	call   0xffffffffa4cbb9b0
 7bd:	test   %rax,%rax
 7c0:	je     0xffffffffc01d2752
 7c2:	add    $0x40,%rax
 7c6:	mov    %rax,%r14
; if (decap_dst_flags) {
 7c9:	test   %r14,%r14
 7cc:	jne    0xffffffffc01d28e7
 7d2:	mov    %r14,-0x90(%rbp)
 7d9:	jmp    0xffffffffc01d2c7e
; memcpy(dst_addr.addrv6, pckt->flow.dstv6, 16);
 7de:	mov    -0x20(%rbp),%rdi
 7e2:	mov    %rdi,-0x78(%rbp)
 7e6:	mov    -0x28(%rbp),%rdi
 7ea:	mov    %rdi,-0x80(%rbp)
 7ee:	mov    %rbp,%rsi
; 
 7f1:	add    $0xffffffffffffff80,%rsi
; __u32* decap_dst_flags = bpf_map_lookup_elem(&decap_dst, &dst_addr);
 7f5:	movabs $0xffff8881a9939000,%rdi
 7ff:	call   0xffffffffa4cbb9b0
 804:	test   %rax,%rax
 807:	je     0xffffffffc01d2799
 809:	add    $0x40,%rax
 80d:	mov    %rax,%r14
; if (decap_dst_flags) {
 810:	test   %r14,%r14
 813:	jne    0xffffffffc01d2936
 819:	mov    %r14,-0x90(%rbp)
 820:	jmp    0xffffffffc01d2e5f
; bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 825:	and    $0x1,%rsi
 829:	mov    $0x36,%ecx
; if (is_ipv6) {
 82e:	test   %rsi,%rsi
 831:	je     0xffffffffc01d27c4
 833:	mov    $0x66,%ecx
; udp = data + off;
 838:	mov    %r15,%rdx
 83b:	add    %rcx,%rdx
; if (udp + 1 > data_end) {
 83e:	mov    %rdx,%rcx
 841:	add    $0x8,%rcx
; 
 845:	mov    $0x1,%r14d
; if (udp + 1 > data_end) {
 84b:	cmp    %r13,%rcx
 84e:	ja     0xffffffffc01d3469
 854:	mov    %rax,-0x90(%rbp)
; if (!is_icmp) {
 85b:	test   %rsi,%rsi
 85e:	jne    0xffffffffc01d2985
 864:	jmp    0xffffffffc01d26ef
; if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 869:	movzbq 0x37(%r15),%rdi
; if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 86e:	cmp    $0x4,%rdi
 872:	jne    0xffffffffc01d288f
 878:	mov    %rsi,-0x90(%rbp)
 87f:	mov    %rax,%r14
 882:	mov    $0x20d,%edi
; __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
 887:	mov    %edi,-0x80(%rbp)
 88a:	mov    %rbp,%rsi
; 
 88d:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &stats_key);
 891:	movabs $0xffff8881a98d8000,%rdi
 89b:	add    $0x100,%rdi
 8a2:	mov    0x0(%rsi),%eax
 8a5:	cmp    $0x400,%rax
 8ac:	jae    0xffffffffc01d2850
 8ae:	shl    $0x3,%rax
 8b2:	add    %rdi,%rax
 8b5:	mov    0x0(%rax),%rax
 8b9:	add    %gs:0xffffffffaa995028,%rax
 8c2:	jmp    0xffffffffc01d2852
 8c4:	xor    %eax,%eax
; if (!icmp_ptb_v4_stats) {
 8c6:	test   %rax,%rax
 8c9:	je     0xffffffffc01d3463
; icmp_ptb_v4_stats->v1 += 1;
 8cf:	mov    0x0(%rax),%rdi
 8d3:	add    $0x1,%rdi
 8d7:	mov    %rdi,0x0(%rax)
; __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);
 8db:	movzwq 0x3c(%r15),%rdi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 8e0:	and    $0xff,%rdi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 8e7:	cmp    $0x4,%rdi
 8eb:	ja     0xffffffffc01d2885
; icmp_ptb_v4_stats->v2 += 1;
 8ed:	mov    0x8(%rax),%rdi
 8f1:	add    $0x1,%rdi
 8f5:	mov    %rdi,0x8(%rax)
 8f9:	mov    %r14,%rax
 8fc:	mov    -0x90(%rbp),%rsi
; if (iph + 1 > data_end) {
 903:	mov    %r15,%rdi
 906:	add    $0x52,%rdi
; 
 90a:	mov    $0x1,%r14d
; if (iph + 1 > data_end) {
 910:	cmp    %r13,%rdi
 913:	ja     0xffffffffc01d3469
; if (iph->ihl != 5) {
 919:	movzbq 0x0(%rsi),%rdi
 91e:	and    $0xf,%rdi
; 
 922:	mov    $0x1,%r14d
; if (iph->ihl != 5) {
 928:	cmp    $0x5,%rdi
 92c:	jne    0xffffffffc01d3469
; pckt->flow.proto = iph->protocol;
 932:	movzbq 0x47(%r15),%rdi
; pckt->flow.proto = iph->protocol;
 937:	mov    %dil,-0x14(%rbp)
; pckt->flags |= F_ICMP;
 93b:	movzbq -0xc(%rbp),%rsi
 940:	or     $0x1,%rsi
 944:	mov    %sil,-0xc(%rbp)
; pckt->flow.src = iph->daddr;
 948:	mov    0x4e(%r15),%edx
; pckt->flow.src = iph->daddr;
 94c:	mov    %edx,-0x38(%rbp)
; pckt->flow.dst = iph->saddr;
 94f:	mov    0x4a(%r15),%edx
; pckt->flow.dst = iph->saddr;
 953:	mov    %edx,-0x28(%rbp)
 956:	jmp    0xffffffffc01d266a
 95b:	mov    $0x206,%edi
; __u32 stats_key = MAX_VIPS + REMOTE_ENCAP_CNTRS;
 960:	mov    %edi,-0x88(%rbp)
 966:	mov    %rbp,%rsi
; 
 969:	add    $0xffffffffffffff78,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 970:	movabs $0xffff8881a98d8000,%rdi
 97a:	add    $0x100,%rdi
 981:	mov    0x0(%rsi),%eax
 984:	cmp    $0x400,%rax
 98b:	jae    0xffffffffc01d292f
 98d:	shl    $0x3,%rax
 991:	add    %rdi,%rax
 994:	mov    0x0(%rax),%rax
 998:	add    %gs:0xffffffffaa995028,%rax
 9a1:	jmp    0xffffffffc01d2931
 9a3:	xor    %eax,%eax
; if (!data_stats) {
 9a5:	jmp    0xffffffffc01d2c6b
 9aa:	mov    $0x206,%edi
; __u32 stats_key = MAX_VIPS + REMOTE_ENCAP_CNTRS;
 9af:	mov    %edi,-0x88(%rbp)
 9b5:	mov    %rbp,%rsi
; 
 9b8:	add    $0xffffffffffffff78,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 9bf:	movabs $0xffff8881a98d8000,%rdi
 9c9:	add    $0x100,%rdi
 9d0:	mov    0x0(%rsi),%eax
 9d3:	cmp    $0x400,%rax
 9da:	jae    0xffffffffc01d297e
 9dc:	shl    $0x3,%rax
 9e0:	add    %rdi,%rax
 9e3:	mov    0x0(%rax),%rax
 9e7:	add    %gs:0xffffffffaa995028,%rax
 9f0:	jmp    0xffffffffc01d2980
 9f2:	xor    %eax,%eax
; if (!data_stats) {
 9f4:	jmp    0xffffffffc01d2e4c
; 
 9f9:	movzwq 0x2(%rdx),%rsi
 9fe:	mov    %si,-0x18(%rbp)
 a02:	mov    %rbp,%rcx
 a05:	add    $0xffffffffffffffe8,%rcx
 a09:	movzwq 0x0(%rdx),%rsi
 a0e:	mov    %rcx,-0x98(%rbp)
 a15:	mov    %si,0x2(%rcx)
; vip.proto = pckt.flow.proto;
 a19:	mov    %dil,-0x3e(%rbp)
; vip.port = pckt.flow.port16[1];
 a1d:	mov    %si,-0x40(%rbp)
; memcpy(vip.vipv6, pckt.flow.dstv6, 16);
 a21:	mov    -0x20(%rbp),%rdi
 a25:	mov    %rdi,-0x48(%rbp)
 a29:	mov    -0x28(%rbp),%rdi
 a2d:	mov    %rdi,-0x50(%rbp)
 a31:	mov    %rbp,%rsi
; 
 a34:	add    $0xffffffffffffffb0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 a38:	movabs $0xffff8881a9939800,%rdi
 a42:	call   0xffffffffa4cbb9b0
 a47:	test   %rax,%rax
 a4a:	je     0xffffffffc01d29dc
 a4c:	add    $0x48,%rax
; if (!vip_info) {
 a50:	test   %rax,%rax
 a53:	jne    0xffffffffc01d2a3f
 a55:	xor    %edi,%edi
; vip.port = 0;
 a57:	mov    %di,-0x40(%rbp)
 a5b:	mov    %rbp,%rsi
 a5e:	add    $0xffffffffffffffb0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 a62:	movabs $0xffff8881a9939800,%rdi
 a6c:	call   0xffffffffa4cbb9b0
 a71:	test   %rax,%rax
 a74:	je     0xffffffffc01d2a06
 a76:	add    $0x48,%rax
; 
 a7a:	mov    $0x2,%r14d
 a80:	mov    -0x90(%rbp),%rdi
; if (!vip_info) {
 a87:	test   %rax,%rax
 a8a:	je     0xffffffffc01d3469
 a90:	mov    %rdi,-0x90(%rbp)
; if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 a97:	mov    0x0(%rax),%edi
; if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 a9a:	and    $0x88,%rdi
 aa1:	test   %rdi,%rdi
 aa4:	jne    0xffffffffc01d2a3f
 aa6:	xor    %edi,%edi
; pckt.flow.port16[1] = 0;
 aa8:	mov    -0x98(%rbp),%rsi
 aaf:	mov    %di,0x2(%rsi)
; if (data_end - data > MAX_PCKT_SIZE) {
 ab3:	mov    %r13,%rdi
 ab6:	sub    %r15,%rdi
; 
 ab9:	mov    $0x1,%r14d
 abf:	mov    -0x90(%rbp),%rsi
; if (data_end - data > MAX_PCKT_SIZE) {
 ac6:	cmp    $0x5ea,%rdi
 acd:	jg     0xffffffffc01d3469
 ad3:	mov    %rax,-0xa0(%rbp)
 ada:	mov    %rsi,-0x90(%rbp)
 ae1:	mov    $0x200,%edi
; __u32 stats_key = MAX_VIPS + LRU_CNTRS;
 ae6:	mov    %edi,-0x5c(%rbp)
 ae9:	mov    %rbp,%rsi
; 
 aec:	add    $0xffffffffffffffa4,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 af0:	movabs $0xffff8881a98d8000,%rdi
 afa:	add    $0x100,%rdi
 b01:	mov    0x0(%rsi),%eax
 b04:	cmp    $0x400,%rax
 b0b:	jae    0xffffffffc01d2aaf
 b0d:	shl    $0x3,%rax
 b11:	add    %rdi,%rax
 b14:	mov    0x0(%rax),%rax
 b18:	add    %gs:0xffffffffaa995028,%rax
 b21:	jmp    0xffffffffc01d2ab1
 b23:	xor    %eax,%eax
 b25:	mov    $0x1,%r14d
; if (!data_stats) {
 b2b:	test   %rax,%rax
 b2e:	je     0xffffffffc01d3469
; data_stats->v1 += 1;
 b34:	mov    0x0(%rax),%rdi
 b38:	add    $0x1,%rdi
 b3c:	mov    %rax,-0xa8(%rbp)
 b43:	mov    %rdi,0x0(%rax)
 b47:	mov    -0xa0(%rbp),%r14
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 b4e:	mov    0x0(%r14),%edi
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 b52:	and    $0x1,%rdi
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 b56:	test   %rdi,%rdi
 b59:	je     0xffffffffc01d2aed
 b5b:	xor    %edi,%edi
; pckt.flow.port16[0] = 0;
 b5d:	mov    %di,-0x18(%rbp)
; vip_num = vip_info->vip_num;
 b61:	mov    0x4(%r14),%edi
; vip_num = vip_info->vip_num;
 b65:	mov    %edi,-0x54(%rbp)
; __u32 cpu_num = bpf_get_smp_processor_id();
 b68:	mov    $0xffffffffaa995034,%rax
 b6f:	add    %gs:0xffffffffaa995028,%rax
 b78:	mov    0x0(%rax),%eax
; __u32 cpu_num = bpf_get_smp_processor_id();
 b7b:	mov    %eax,-0x60(%rbp)
 b7e:	mov    %rbp,%rsi
; vip_num = vip_info->vip_num;
 b81:	add    $0xffffffffffffffa0,%rsi
; void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 b85:	movabs $0xffff888102de7000,%rdi
 b8f:	add    $0x100,%rdi
 b96:	mov    0x0(%rsi),%eax
 b99:	cmp    $0x80,%rax
 ba0:	jae    0xffffffffc01d2b40
 ba2:	shl    $0x3,%rax
 ba6:	add    %rdi,%rax
 ba9:	mov    0x0(%rax),%rax
 bad:	test   %rax,%rax
 bb0:	je     0xffffffffc01d2b40
 bb2:	jmp    0xffffffffc01d2b42
 bb4:	xor    %eax,%eax
 bb6:	mov    %rax,%rcx
; if (!lru_map) {
 bb9:	test   %rcx,%rcx
 bbc:	jne    0xffffffffc01d2bb4
 bbe:	mov    $0x203,%edi
; __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
 bc3:	mov    %edi,-0x80(%rbp)
 bc6:	mov    %rbp,%rsi
; 
 bc9:	add    $0xffffffffffffff80,%rsi
; struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
 bcd:	movabs $0xffff8881a98d8000,%rdi
 bd7:	add    $0x100,%rdi
 bde:	mov    0x0(%rsi),%eax
 be1:	cmp    $0x400,%rax
 be8:	jae    0xffffffffc01d2b8c
 bea:	shl    $0x3,%rax
 bee:	add    %rdi,%rax
 bf1:	mov    0x0(%rax),%rax
 bf5:	add    %gs:0xffffffffaa995028,%rax
 bfe:	jmp    0xffffffffc01d2b8e
 c00:	xor    %eax,%eax
; if (!lru_stats) {
 c02:	test   %rax,%rax
 c05:	je     0xffffffffc01d3463
; lru_stats->v1 += 1;
 c0b:	mov    0x0(%rax),%rdi
 c0f:	add    $0x1,%rdi
 c13:	mov    %rdi,0x0(%rax)
 c17:	movabs $0xffff8881a993a000,%rcx
 c21:	mov    -0xa0(%rbp),%r14
; if ((vip_info->flags & F_QUIC_VIP)) {
 c28:	mov    0x0(%r14),%edi
; if ((vip_info->flags & F_QUIC_VIP)) {
 c2c:	and    $0x4,%rdi
 c30:	mov    %r14,%rsi
; if ((vip_info->flags & F_QUIC_VIP)) {
 c33:	test   %rdi,%rdi
 c36:	je     0xffffffffc01d3cba
 c3c:	mov    %rcx,%r14
; bool is_icmp = (pckt.flags & F_ICMP);
 c3f:	movzbq -0xc(%rbp),%rdi
; bool is_icmp = (pckt.flags & F_ICMP);
 c44:	and    $0x1,%rdi
; if (is_icmp) {
 c48:	test   %rdi,%rdi
 c4b:	je     0xffffffffc01d3bde
 c51:	mov    $0x20b,%edi
; __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
 c56:	mov    %edi,-0x80(%rbp)
 c59:	mov    %rbp,%rsi
; 
 c5c:	add    $0xffffffffffffff80,%rsi
; struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 c60:	movabs $0xffff8881a98d8000,%rdi
 c6a:	add    $0x100,%rdi
 c71:	mov    0x0(%rsi),%eax
 c74:	cmp    $0x400,%rax
 c7b:	jae    0xffffffffc01d2c1f
 c7d:	shl    $0x3,%rax
 c81:	add    %rdi,%rax
 c84:	mov    0x0(%rax),%rax
 c88:	add    %gs:0xffffffffaa995028,%rax
 c91:	jmp    0xffffffffc01d2c21
 c93:	xor    %eax,%eax
; if (!data_stats) {
 c95:	test   %rax,%rax
 c98:	je     0xffffffffc01d3463
; data_stats->v1 += 1;
 c9e:	mov    0x0(%rax),%rdi
 ca2:	add    $0x1,%rdi
 ca6:	mov    %rdi,0x0(%rax)
; (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
 caa:	movzbq 0x37(%r15),%rdi
; (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
 caf:	add    $0xfffffffffffffffd,%rdi
 cb3:	and    $0xff,%rdi
 cba:	mov    -0xa0(%rbp),%rsi
 cc1:	mov    %r14,%rcx
; if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
 cc4:	cmp    $0x1,%rdi
 cc8:	ja     0xffffffffc01d3cba
; data_stats->v2 += 1;
 cce:	mov    0x8(%rax),%rdi
 cd2:	add    $0x1,%rdi
 cd6:	mov    %rdi,0x8(%rax)
 cda:	jmp    0xffffffffc01d3cba
 cdf:	mov    %r14,-0x90(%rbp)
; data_stats->v1 += 1;
 ce6:	mov    0x0(%rax),%rdi
 cea:	add    $0x1,%rdi
 cee:	mov    %rdi,0x0(%rax)
 cf2:	mov    $0x1,%r14d
; if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
 cf8:	mov    %r15,%rdi
 cfb:	add    $0x5e,%rdi
 cff:	mov    $0x1,%esi
; if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
 d04:	cmp    %r13,%rdi
 d07:	ja     0xffffffffc01d2cba
; if (!--ip6h->hop_limit) {
 d09:	movzbq 0x3d(%r15),%rdi
 d0e:	add    $0xffffffffffffffff,%rdi
 d12:	mov    %dil,0x3d(%r15)
 d16:	and    $0xff,%rdi
 d1d:	mov    $0x1,%esi
; if (!--ip6h->hop_limit) {
 d22:	test   %rdi,%rdi
 d25:	je     0xffffffffc01d2cba
 d27:	mov    $0xffffffffffffffff,%rsi
 d2e:	mov    %rsi,%r13
 d31:	mov    $0xdd,%edi
; new_eth->h_proto = BE_ETH_P_IPV6;
 d36:	mov    %dil,0x35(%r15)
 d3a:	mov    $0x86,%edi
 d3f:	mov    %dil,0x34(%r15)
; memcpy(new_eth->h_source, old_eth->h_source, 6);
 d43:	movzbq 0xb(%r15),%rdi
 d48:	mov    %dil,0x33(%r15)
 d4c:	movzbq 0xa(%r15),%rdi
 d51:	mov    %dil,0x32(%r15)
 d55:	movzbq 0x9(%r15),%rdi
 d5a:	mov    %dil,0x31(%r15)
 d5e:	movzbq 0x8(%r15),%rdi
 d63:	mov    %dil,0x30(%r15)
 d67:	movzbq 0x7(%r15),%rdi
 d6c:	mov    %dil,0x2f(%r15)
 d70:	movzbq 0x6(%r15),%rdi
 d75:	mov    %dil,0x2e(%r15)
; memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 d79:	movzbq 0x3(%r15),%rdi
 d7e:	mov    %dil,0x2b(%r15)
 d82:	movzbq 0x2(%r15),%rdi
 d87:	mov    %dil,0x2a(%r15)
 d8b:	movzbq 0x1(%r15),%rdi
 d90:	mov    %dil,0x29(%r15)
 d94:	movzbq 0x0(%r15),%rdi
 d99:	mov    %dil,0x28(%r15)
 d9d:	movzbq 0x5(%r15),%rdi
 da2:	mov    %dil,0x2d(%r15)
 da6:	movzbq 0x4(%r15),%rdi
 dab:	mov    %dil,0x2c(%r15)
; if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
 daf:	mov    %rbx,%rdi
 db2:	mov    $0x28,%esi
 db7:	call   0xffffffffa6e35c20
 dbc:	shl    $0x20,%rax
 dc0:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
 dc4:	test   %rax,%rax
 dc7:	jne    0xffffffffc01d3469
 dcd:	mov    $0x20a,%edi
; __u32 stats_key = MAX_VIPS + DECAP_CNTR;
 dd2:	mov    %edi,-0x88(%rbp)
 dd8:	mov    %rbp,%rsi
; 
 ddb:	add    $0xffffffffffffff78,%rsi
; struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 de2:	movabs $0xffff8881a98d8000,%rdi
 dec:	add    $0x100,%rdi
 df3:	mov    0x0(%rsi),%eax
 df6:	cmp    $0x400,%rax
 dfd:	jae    0xffffffffc01d2da1
 dff:	shl    $0x3,%rax
 e03:	add    %rdi,%rax
 e06:	mov    0x0(%rax),%rax
 e0a:	add    %gs:0xffffffffaa995028,%rax
 e13:	jmp    0xffffffffc01d2da3
 e15:	xor    %eax,%eax
 e17:	mov    $0x1,%r14d
; if (!data_stats) {
 e1d:	test   %rax,%rax
 e20:	je     0xffffffffc01d3469
; data_stats->v2 += 1;
 e26:	mov    0x8(%rax),%rdi
 e2a:	add    $0x1,%rdi
 e2e:	mov    %rdi,0x8(%rax)
; if (action >= 0) {
 e32:	mov    %r13,%rdi
 e35:	shl    $0x20,%rdi
 e39:	sar    $0x20,%rdi
; if (action >= 0) {
 e3d:	mov    %r13,%r14
 e40:	cmp    $0xffffffffffffffff,%rdi
 e44:	jg     0xffffffffc01d2dd8
 e46:	mov    $0x2,%r14d
 e4c:	mov    -0x90(%rbp),%rdi
 e53:	test   %rdi,%rdi
 e56:	je     0xffffffffc01d3469
 e5c:	shl    $0x20,%r13
 e60:	sar    $0x20,%r13
 e64:	cmp    $0xffffffffffffffff,%r13
 e68:	jg     0xffffffffc01d3469
 e6e:	mov    $0x20e,%edi
; __u32 xpop_stats_key = MAX_VIPS + XPOP_DECAP_SUCCESSFUL;
 e73:	mov    %edi,-0x80(%rbp)
 e76:	mov    %rbp,%rsi
; 
 e79:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &xpop_stats_key);
 e7d:	movabs $0xffff8881a98d8000,%rdi
 e87:	add    $0x100,%rdi
 e8e:	mov    0x0(%rsi),%eax
 e91:	cmp    $0x400,%rax
 e98:	jae    0xffffffffc01d2e3c
 e9a:	shl    $0x3,%rax
 e9e:	add    %rdi,%rax
 ea1:	mov    0x0(%rax),%rax
 ea5:	add    %gs:0xffffffffaa995028,%rax
 eae:	jmp    0xffffffffc01d2e3e
 eb0:	xor    %eax,%eax
; if (xpop_stats_data) {
 eb2:	test   %rax,%rax
 eb5:	je     0xffffffffc01d3874
 ebb:	jmp    0xffffffffc01d3663
 ec0:	mov    %r14,-0x90(%rbp)
; data_stats->v1 += 1;
 ec7:	mov    0x0(%rax),%rdi
 ecb:	add    $0x1,%rdi
 ecf:	mov    %rdi,0x0(%rax)
 ed3:	mov    $0x1,%r14d
; if ((data + offset + sizeof(struct iphdr)) > data_end) {
 ed9:	mov    %r15,%rdi
 edc:	add    $0x4a,%rdi
 ee0:	mov    $0x1,%esi
; if ((data + offset + sizeof(struct iphdr)) > data_end) {
 ee5:	cmp    %r13,%rdi
 ee8:	ja     0xffffffffc01d2eb3
; csum = iph->check + 0x0001;
 eea:	movzwq 0x40(%r15),%rdi
; csum = iph->check + 0x0001;
 eef:	add    $0x1,%rdi
; iph->check = (csum & 0xffff) + (csum >> 16);
 ef3:	mov    %rdi,%rsi
 ef6:	shr    $0x10,%rsi
; iph->check = (csum & 0xffff) + (csum >> 16);
 efa:	add    %rdi,%rsi
; iph->check = (csum & 0xffff) + (csum >> 16);
 efd:	mov    %si,0x40(%r15)
; if (!--iph->ttl) {
 f02:	movzbq 0x3e(%r15),%rdi
 f07:	add    $0xffffffffffffffff,%rdi
 f0b:	mov    %dil,0x3e(%r15)
 f0f:	and    $0xff,%rdi
 f16:	mov    $0x1,%esi
 f1b:	test   %rdi,%rdi
 f1e:	je     0xffffffffc01d2eb3
 f20:	mov    $0xffffffffffffffff,%rsi
 f27:	mov    %rsi,%r13
 f2a:	xor    %edi,%edi
; new_eth->h_proto = BE_ETH_P_IP;
 f2c:	mov    %dil,0x35(%r15)
 f30:	mov    $0x8,%edi
 f35:	mov    %dil,0x34(%r15)
; memcpy(new_eth->h_source, old_eth->h_source, 6);
 f39:	movzbq 0xb(%r15),%rdi
 f3e:	mov    %dil,0x33(%r15)
 f42:	movzbq 0xa(%r15),%rdi
 f47:	mov    %dil,0x32(%r15)
 f4b:	movzbq 0x9(%r15),%rdi
 f50:	mov    %dil,0x31(%r15)
 f54:	movzbq 0x8(%r15),%rdi
 f59:	mov    %dil,0x30(%r15)
 f5d:	movzbq 0x7(%r15),%rdi
 f62:	mov    %dil,0x2f(%r15)
 f66:	movzbq 0x6(%r15),%rdi
 f6b:	mov    %dil,0x2e(%r15)
; memcpy(new_eth->h_dest, old_eth->h_dest, 6);
 f6f:	movzbq 0x3(%r15),%rdi
 f74:	mov    %dil,0x2b(%r15)
 f78:	movzbq 0x2(%r15),%rdi
 f7d:	mov    %dil,0x2a(%r15)
 f81:	movzbq 0x1(%r15),%rdi
 f86:	mov    %dil,0x29(%r15)
 f8a:	movzbq 0x0(%r15),%rdi
 f8f:	mov    %dil,0x28(%r15)
 f93:	movzbq 0x5(%r15),%rdi
 f98:	mov    %dil,0x2d(%r15)
 f9c:	movzbq 0x4(%r15),%rdi
 fa1:	mov    %dil,0x2c(%r15)
; if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
 fa5:	mov    %rbx,%rdi
 fa8:	mov    $0x28,%esi
 fad:	call   0xffffffffa6e35c20
 fb2:	shl    $0x20,%rax
 fb6:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
 fba:	test   %rax,%rax
 fbd:	jne    0xffffffffc01d3469
 fc3:	mov    $0x20a,%edi
; __u32 stats_key = MAX_VIPS + DECAP_CNTR;
 fc8:	mov    %edi,-0x88(%rbp)
 fce:	mov    %rbp,%rsi
; 
 fd1:	add    $0xffffffffffffff78,%rsi
; struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 fd8:	movabs $0xffff8881a98d8000,%rdi
 fe2:	add    $0x100,%rdi
 fe9:	mov    0x0(%rsi),%eax
 fec:	cmp    $0x400,%rax
 ff3:	jae    0xffffffffc01d2f97
 ff5:	shl    $0x3,%rax
 ff9:	add    %rdi,%rax
 ffc:	mov    0x0(%rax),%rax
1000:	add    %gs:0xffffffffaa995028,%rax
1009:	jmp    0xffffffffc01d2f99
100b:	xor    %eax,%eax
100d:	mov    $0x1,%r14d
; if (!data_stats) {
1013:	test   %rax,%rax
1016:	je     0xffffffffc01d3469
; data_stats->v2 += 1;
101c:	mov    0x8(%rax),%rdi
1020:	add    $0x1,%rdi
1024:	mov    %rdi,0x8(%rax)
; if (action >= 0) {
1028:	mov    %r13,%rdi
102b:	shl    $0x20,%rdi
102f:	sar    $0x20,%rdi
; if (action >= 0) {
1033:	mov    %r13,%r14
1036:	cmp    $0xffffffffffffffff,%rdi
103a:	jg     0xffffffffc01d2fce
103c:	mov    $0x2,%r14d
1042:	mov    -0x90(%rbp),%rdi
1049:	test   %rdi,%rdi
104c:	je     0xffffffffc01d3469
1052:	shl    $0x20,%r13
1056:	sar    $0x20,%r13
105a:	cmp    $0xffffffffffffffff,%r13
105e:	jg     0xffffffffc01d3469
1064:	mov    $0x20e,%edi
; __u32 xpop_stats_key = MAX_VIPS + XPOP_DECAP_SUCCESSFUL;
1069:	mov    %edi,-0x80(%rbp)
106c:	mov    %rbp,%rsi
; 
106f:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &xpop_stats_key);
1073:	movabs $0xffff8881a98d8000,%rdi
107d:	add    $0x100,%rdi
1084:	mov    0x0(%rsi),%eax
1087:	cmp    $0x400,%rax
108e:	jae    0xffffffffc01d3032
1090:	shl    $0x3,%rax
1094:	add    %rdi,%rax
1097:	mov    0x0(%rax),%rax
109b:	add    %gs:0xffffffffaa995028,%rax
10a4:	jmp    0xffffffffc01d3034
10a6:	xor    %eax,%eax
; if (xpop_stats_data) {
10a8:	test   %rax,%rax
10ab:	je     0xffffffffc01d3874
10b1:	jmp    0xffffffffc01d3868
; if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
10b6:	movzbq 0x23(%r15),%rdi
; if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
10bb:	cmp    $0x4,%rdi
10bf:	jne    0xffffffffc01d30dc
10c5:	mov    %rsi,-0x90(%rbp)
10cc:	mov    %rax,%r14
10cf:	mov    $0x20d,%edi
; __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
10d4:	mov    %edi,-0x80(%rbp)
10d7:	mov    %rbp,%rsi
; 
10da:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &stats_key);
10de:	movabs $0xffff8881a98d8000,%rdi
10e8:	add    $0x100,%rdi
10ef:	mov    0x0(%rsi),%eax
10f2:	cmp    $0x400,%rax
10f9:	jae    0xffffffffc01d309d
10fb:	shl    $0x3,%rax
10ff:	add    %rdi,%rax
1102:	mov    0x0(%rax),%rax
1106:	add    %gs:0xffffffffaa995028,%rax
110f:	jmp    0xffffffffc01d309f
1111:	xor    %eax,%eax
; if (!icmp_ptb_v4_stats) {
1113:	test   %rax,%rax
1116:	je     0xffffffffc01d3463
; icmp_ptb_v4_stats->v1 += 1;
111c:	mov    0x0(%rax),%rdi
1120:	add    $0x1,%rdi
1124:	mov    %rdi,0x0(%rax)
; __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);
1128:	movzwq 0x28(%r15),%rdi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
112d:	and    $0xff,%rdi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
1134:	cmp    $0x4,%rdi
1138:	ja     0xffffffffc01d30d2
; icmp_ptb_v4_stats->v2 += 1;
113a:	mov    0x8(%rax),%rdi
113e:	add    $0x1,%rdi
1142:	mov    %rdi,0x8(%rax)
1146:	mov    %r14,%rax
1149:	mov    -0x90(%rbp),%rsi
; if (iph + 1 > data_end) {
1150:	mov    %r15,%rdi
1153:	add    $0x3e,%rdi
; 
1157:	mov    $0x1,%r14d
; if (iph + 1 > data_end) {
115d:	cmp    %r13,%rdi
1160:	ja     0xffffffffc01d3469
; if (iph->ihl != 5) {
1166:	movzbq 0x0(%rsi),%rdi
116b:	and    $0xf,%rdi
; 
116f:	mov    $0x1,%r14d
; if (iph->ihl != 5) {
1175:	cmp    $0x5,%rdi
1179:	jne    0xffffffffc01d3469
; pckt->flow.proto = iph->protocol;
117f:	movzbq 0x33(%r15),%rdi
; pckt->flow.proto = iph->protocol;
1184:	mov    %dil,-0x14(%rbp)
; pckt->flags |= F_ICMP;
1188:	movzbq -0xc(%rbp),%rsi
118d:	or     $0x1,%rsi
1191:	mov    %sil,-0xc(%rbp)
; pckt->flow.src = iph->daddr;
1195:	mov    0x3a(%r15),%edx
; pckt->flow.src = iph->daddr;
1199:	mov    %edx,-0x38(%rbp)
; pckt->flow.dst = iph->saddr;
119c:	mov    0x36(%r15),%edx
; pckt->flow.dst = iph->saddr;
11a0:	mov    %edx,-0x28(%rbp)
11a3:	jmp    0xffffffffc01d3223
11a8:	mov    %rax,%r14
11ab:	mov    $0x20c,%edi
; __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
11b0:	mov    %edi,-0x80(%rbp)
11b3:	mov    %rbp,%rsi
; 
11b6:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &stats_key);
11ba:	movabs $0xffff8881a98d8000,%rdi
11c4:	add    $0x100,%rdi
11cb:	mov    0x0(%rsi),%eax
11ce:	cmp    $0x400,%rax
11d5:	jae    0xffffffffc01d3179
11d7:	shl    $0x3,%rax
11db:	add    %rdi,%rax
11de:	mov    0x0(%rax),%rax
11e2:	add    %gs:0xffffffffaa995028,%rax
11eb:	jmp    0xffffffffc01d317b
11ed:	xor    %eax,%eax
; if (!icmp_ptb_v6_stats) {
11ef:	test   %rax,%rax
11f2:	je     0xffffffffc01d3463
; icmp_ptb_v6_stats->v1 += 1;
11f8:	mov    0x0(%rax),%rdi
11fc:	add    $0x1,%rdi
1200:	mov    %rdi,0x0(%rax)
; __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
1204:	mov    0x26(%r15),%edi
1208:	bswap  %edi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
120a:	cmp    $0x4ff,%rdi
1211:	ja     0xffffffffc01d31ab
; icmp_ptb_v6_stats->v2 += 1;
1213:	mov    0x8(%rax),%rdi
1217:	add    $0x1,%rdi
121b:	mov    %rdi,0x8(%rax)
121f:	mov    %r14,%rax
; if (ip6h + 1 > data_end) {
1222:	mov    %r15,%rdi
1225:	add    $0x52,%rdi
; 
1229:	mov    $0x1,%r14d
; if (ip6h + 1 > data_end) {
122f:	cmp    %r13,%rdi
1232:	ja     0xffffffffc01d3469
; 
1238:	mov    %rbp,%rdx
123b:	add    $0xffffffffffffffd8,%rdx
; pckt->flow.proto = ip6h->nexthdr;
123f:	movzbq 0x30(%r15),%rdi
; pckt->flow.proto = ip6h->nexthdr;
1244:	mov    %dil,-0x14(%rbp)
; pckt->flags |= F_ICMP;
1248:	movzbq -0xc(%rbp),%rsi
124d:	or     $0x1,%rsi
1251:	mov    %sil,-0xc(%rbp)
; memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
1255:	mov    0x4e(%r15),%ecx
1259:	shl    $0x20,%rcx
125d:	mov    0x4a(%r15),%r8d
1261:	or     %r8,%rcx
1264:	mov    %rcx,-0x30(%rbp)
1268:	mov    0x46(%r15),%ecx
126c:	shl    $0x20,%rcx
1270:	mov    0x42(%r15),%r8d
1274:	or     %r8,%rcx
1277:	mov    %rcx,-0x38(%rbp)
; memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
127b:	mov    0x3a(%r15),%ecx
127f:	mov    %ecx,0x8(%rdx)
1282:	mov    0x3e(%r15),%ecx
1286:	mov    %ecx,0xc(%rdx)
1289:	mov    0x32(%r15),%ecx
128d:	mov    %ecx,0x0(%rdx)
1290:	mov    0x36(%r15),%ecx
1294:	mov    %ecx,0x4(%rdx)
; if (protocol == IPPROTO_IPIP) {
1297:	mov    %rdi,%rdx
129a:	cmp    $0x10,%rdx
129e:	jg     0xffffffffc01d32c1
12a4:	cmp    $0x4,%rdx
12a8:	je     0xffffffffc01d3324
; 
12ae:	mov    $0x2,%r14d
; if (protocol == IPPROTO_IPIP) {
12b4:	cmp    $0x6,%rdx
12b8:	je     0xffffffffc01d324b
12ba:	jmp    0xffffffffc01d3469
; bool is_icmp = !((pckt->flags & F_ICMP) == 0);
12bf:	mov    %rsi,%rcx
12c2:	and    $0x1,%rcx
12c6:	mov    $0x22,%r8d
; if (is_ipv6) {
12cc:	test   %rcx,%rcx
12cf:	je     0xffffffffc01d3263
12d1:	mov    $0x3e,%r8d
; tcp = data + off;
12d7:	mov    %r15,%rdx
12da:	add    %r8,%rdx
; if (tcp + 1 > data_end) {
12dd:	mov    %rdx,%r8
12e0:	add    $0x14,%r8
; 
12e4:	mov    $0x1,%r14d
; if (tcp + 1 > data_end) {
12ea:	cmp    %r13,%r8
12ed:	ja     0xffffffffc01d3469
; if (tcp->syn) {
12f3:	movzwq 0xc(%rdx),%r8
; if (tcp->syn) {
12f8:	and    $0x200,%r8
; if (tcp->syn) {
12ff:	test   %r8,%r8
1302:	je     0xffffffffc01d3298
; pckt->flags |= F_SYN_SET;
1304:	or     $0x2,%rsi
1308:	mov    %sil,-0xc(%rbp)
130c:	mov    %rax,-0x90(%rbp)
; if (!is_icmp) {
1313:	test   %rcx,%rcx
1316:	jne    0xffffffffc01d38fd
; pckt->flow.port16[0] = tcp->source;
131c:	movzwq 0x0(%rdx),%rsi
; pckt->flow.port16[0] = tcp->source;
1321:	mov    %si,-0x18(%rbp)
; pckt->flow.port16[0] = tcp->source;
1325:	mov    %rbp,%rcx
1328:	add    $0xffffffffffffffe8,%rcx
; pckt->flow.port16[1] = tcp->dest;
132c:	add    $0x2,%rdx
1330:	jmp    0xffffffffc01d3918
; if (protocol == IPPROTO_IPIP) {
1335:	cmp    $0x11,%rdx
1339:	je     0xffffffffc01d336c
; 
133f:	mov    $0x2,%r14d
; if (protocol == IPPROTO_IPIP) {
1345:	cmp    $0x29,%rdx
1349:	je     0xffffffffc01d32dc
134b:	jmp    0xffffffffc01d3469
1350:	xor    %edi,%edi
; struct address dst_addr = {};
1352:	mov    %edi,-0x78(%rbp)
1355:	mov    %edi,-0x7c(%rbp)
1358:	mov    %edi,-0x74(%rbp)
; dst_addr.addr = pckt->flow.dst;
135b:	mov    -0x28(%rbp),%edi
; dst_addr.addr = pckt->flow.dst;
135e:	mov    %edi,-0x80(%rbp)
1361:	mov    %rbp,%rsi
; 
1364:	add    $0xffffffffffffff80,%rsi
; __u32* decap_dst_flags = bpf_map_lookup_elem(&decap_dst, &dst_addr);
1368:	movabs $0xffff8881a9939000,%rdi
1372:	call   0xffffffffa4cbb9b0
1377:	test   %rax,%rax
137a:	je     0xffffffffc01d330c
137c:	add    $0x40,%rax
1380:	mov    %rax,%r14
; if (decap_dst_flags) {
1383:	test   %r14,%r14
1386:	jne    0xffffffffc01d33c4
138c:	mov    %r14,-0x90(%rbp)
1393:	jmp    0xffffffffc01d3488
1398:	xor    %edi,%edi
; struct address dst_addr = {};
139a:	mov    %edi,-0x78(%rbp)
139d:	mov    %edi,-0x7c(%rbp)
13a0:	mov    %edi,-0x74(%rbp)
; dst_addr.addr = pckt->flow.dst;
13a3:	mov    -0x28(%rbp),%edi
; dst_addr.addr = pckt->flow.dst;
13a6:	mov    %edi,-0x80(%rbp)
13a9:	mov    %rbp,%rsi
; 
13ac:	add    $0xffffffffffffff80,%rsi
; __u32* decap_dst_flags = bpf_map_lookup_elem(&decap_dst, &dst_addr);
13b0:	movabs $0xffff8881a9939000,%rdi
13ba:	call   0xffffffffa4cbb9b0
13bf:	test   %rax,%rax
13c2:	je     0xffffffffc01d3354
13c4:	add    $0x40,%rax
13c8:	mov    %rax,%r14
; if (decap_dst_flags) {
13cb:	test   %r14,%r14
13ce:	jne    0xffffffffc01d3410
13d4:	mov    %r14,-0x90(%rbp)
13db:	jmp    0xffffffffc01d3687
; bool is_icmp = !((pckt->flags & F_ICMP) == 0);
13e0:	and    $0x1,%rsi
13e4:	mov    $0x22,%ecx
; if (is_ipv6) {
13e9:	test   %rsi,%rsi
13ec:	je     0xffffffffc01d337f
13ee:	mov    $0x3e,%ecx
; udp = data + off;
13f3:	mov    %r15,%rdx
13f6:	add    %rcx,%rdx
; if (udp + 1 > data_end) {
13f9:	mov    %rdx,%rcx
13fc:	add    $0x8,%rcx
; 
1400:	mov    $0x1,%r14d
; if (udp + 1 > data_end) {
1406:	cmp    %r13,%rcx
1409:	ja     0xffffffffc01d3469
140f:	mov    %rax,-0x90(%rbp)
; if (!is_icmp) {
1416:	mov    %rbp,%rcx
1419:	add    $0xffffffffffffffe8,%rcx
141d:	test   %rsi,%rsi
1420:	jne    0xffffffffc01d390f
; pckt->flow.port16[0] = udp->source;
1426:	movzwq 0x0(%rdx),%rsi
; pckt->flow.port16[0] = udp->source;
142b:	mov    %si,-0x18(%rbp)
; pckt->flow.port16[1] = udp->dest;
142f:	add    $0x2,%rdx
1433:	jmp    0xffffffffc01d3918
1438:	mov    $0x206,%edi
; __u32 stats_key = MAX_VIPS + REMOTE_ENCAP_CNTRS;
143d:	mov    %edi,-0x88(%rbp)
1443:	mov    %rbp,%rsi
; 
1446:	add    $0xffffffffffffff78,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &stats_key);
144d:	movabs $0xffff8881a98d8000,%rdi
1457:	add    $0x100,%rdi
145e:	mov    0x0(%rsi),%eax
1461:	cmp    $0x400,%rax
1468:	jae    0xffffffffc01d340c
146a:	shl    $0x3,%rax
146e:	add    %rdi,%rax
1471:	mov    0x0(%rax),%rax
1475:	add    %gs:0xffffffffaa995028,%rax
147e:	jmp    0xffffffffc01d340e
1480:	xor    %eax,%eax
; if (!data_stats) {
1482:	jmp    0xffffffffc01d3475
1484:	mov    $0x206,%edi
; __u32 stats_key = MAX_VIPS + REMOTE_ENCAP_CNTRS;
1489:	mov    %edi,-0x88(%rbp)
148f:	mov    %rbp,%rsi
; 
1492:	add    $0xffffffffffffff78,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &stats_key);
1499:	movabs $0xffff8881a98d8000,%rdi
14a3:	add    $0x100,%rdi
14aa:	mov    0x0(%rsi),%eax
14ad:	cmp    $0x400,%rax
14b4:	jae    0xffffffffc01d3458
14b6:	shl    $0x3,%rax
14ba:	add    %rdi,%rax
14bd:	mov    0x0(%rax),%rax
14c1:	add    %gs:0xffffffffaa995028,%rax
14ca:	jmp    0xffffffffc01d345a
14cc:	xor    %eax,%eax
; if (!data_stats) {
14ce:	test   %rax,%rax
14d1:	jne    0xffffffffc01d3674
14d7:	mov    $0x1,%r14d
; }
14dd:	mov    %r14,%rax
14e0:	pop    %r15
14e2:	pop    %r14
14e4:	pop    %r13
14e6:	pop    %rbx
14e7:	leave
14e8:	ret
14e9:	mov    %r14,-0x90(%rbp)
; data_stats->v1 += 1;
14f0:	mov    0x0(%rax),%rdi
14f4:	add    $0x1,%rdi
14f8:	mov    %rdi,0x0(%rax)
; if ((*data + offset) > *data_end) {
14fc:	mov    %r15,%rdi
14ff:	add    $0x36,%rdi
; 
1503:	mov    $0x1,%r14d
; if ((*data + offset) > *data_end) {
1509:	cmp    %r13,%rdi
150c:	ja     0xffffffffc01d3469
150e:	mov    $0x1,%r14d
; if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
1514:	mov    %r15,%rdi
1517:	add    $0x5e,%rdi
151b:	mov    $0x1,%esi
; if ((data + offset + sizeof(struct ipv6hdr)) > data_end) {
1520:	cmp    %r13,%rdi
1523:	ja     0xffffffffc01d34d6
; if (!--ip6h->hop_limit) {
1525:	movzbq 0x3d(%r15),%rdi
152a:	add    $0xffffffffffffffff,%rdi
152e:	mov    %dil,0x3d(%r15)
1532:	and    $0xff,%rdi
1539:	mov    $0x1,%esi
; if (!--ip6h->hop_limit) {
153e:	test   %rdi,%rdi
1541:	je     0xffffffffc01d34d6
1543:	mov    $0xffffffffffffffff,%rsi
154a:	mov    %rsi,%r13
154d:	mov    $0xdd,%edi
; new_eth->h_proto = BE_ETH_P_IPV6;
1552:	mov    %dil,0x35(%r15)
1556:	mov    $0x86,%edi
155b:	mov    %dil,0x34(%r15)
; memcpy(new_eth->h_source, old_eth->h_source, 6);
155f:	movzbq 0xb(%r15),%rdi
1564:	mov    %dil,0x33(%r15)
1568:	movzbq 0xa(%r15),%rdi
156d:	mov    %dil,0x32(%r15)
1571:	movzbq 0x9(%r15),%rdi
1576:	mov    %dil,0x31(%r15)
157a:	movzbq 0x8(%r15),%rdi
157f:	mov    %dil,0x30(%r15)
1583:	movzbq 0x7(%r15),%rdi
1588:	mov    %dil,0x2f(%r15)
158c:	movzbq 0x6(%r15),%rdi
1591:	mov    %dil,0x2e(%r15)
; memcpy(new_eth->h_dest, old_eth->h_dest, 6);
1595:	movzbq 0x3(%r15),%rdi
159a:	mov    %dil,0x2b(%r15)
159e:	movzbq 0x2(%r15),%rdi
15a3:	mov    %dil,0x2a(%r15)
15a7:	movzbq 0x1(%r15),%rdi
15ac:	mov    %dil,0x29(%r15)
15b0:	movzbq 0x0(%r15),%rdi
15b5:	mov    %dil,0x28(%r15)
15b9:	movzbq 0x5(%r15),%rdi
15be:	mov    %dil,0x2d(%r15)
15c2:	movzbq 0x4(%r15),%rdi
15c7:	mov    %dil,0x2c(%r15)
; if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
15cb:	mov    %rbx,%rdi
15ce:	mov    $0x28,%esi
15d3:	call   0xffffffffa6e35c20
15d8:	shl    $0x20,%rax
15dc:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct ipv6hdr))) {
15e0:	test   %rax,%rax
15e3:	jne    0xffffffffc01d3469
15e9:	mov    $0x20a,%edi
; __u32 stats_key = MAX_VIPS + DECAP_CNTR;
15ee:	mov    %edi,-0x88(%rbp)
15f4:	mov    %rbp,%rsi
; 
15f7:	add    $0xffffffffffffff78,%rsi
; struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
15fe:	movabs $0xffff8881a98d8000,%rdi
1608:	add    $0x100,%rdi
160f:	mov    0x0(%rsi),%eax
1612:	cmp    $0x400,%rax
1619:	jae    0xffffffffc01d35bd
161b:	shl    $0x3,%rax
161f:	add    %rdi,%rax
1622:	mov    0x0(%rax),%rax
1626:	add    %gs:0xffffffffaa995028,%rax
162f:	jmp    0xffffffffc01d35bf
1631:	xor    %eax,%eax
1633:	mov    $0x1,%r14d
; if (!data_stats) {
1639:	test   %rax,%rax
163c:	je     0xffffffffc01d3469
; data_stats->v2 += 1;
1642:	mov    0x8(%rax),%rdi
1646:	add    $0x1,%rdi
164a:	mov    %rdi,0x8(%rax)
164e:	mov    %r13,%r14
; if (action >= 0) {
1651:	mov    %r14,%rdi
1654:	shl    $0x20,%rdi
1658:	sar    $0x20,%rdi
; if (action >= 0) {
165c:	cmp    $0xffffffffffffffff,%rdi
1660:	jg     0xffffffffc01d35f4
1662:	mov    $0x2,%r14d
1668:	mov    -0x90(%rbp),%rdi
166f:	test   %rdi,%rdi
1672:	je     0xffffffffc01d3469
1678:	shl    $0x20,%r13
167c:	sar    $0x20,%r13
1680:	cmp    $0xffffffffffffffff,%r13
1684:	jg     0xffffffffc01d3469
168a:	mov    $0x20e,%edi
; __u32 xpop_stats_key = MAX_VIPS + XPOP_DECAP_SUCCESSFUL;
168f:	mov    %edi,-0x80(%rbp)
1692:	mov    %rbp,%rsi
; 
1695:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &xpop_stats_key);
1699:	movabs $0xffff8881a98d8000,%rdi
16a3:	add    $0x100,%rdi
16aa:	mov    0x0(%rsi),%eax
16ad:	cmp    $0x400,%rax
16b4:	jae    0xffffffffc01d3658
16b6:	shl    $0x3,%rax
16ba:	add    %rdi,%rax
16bd:	mov    0x0(%rax),%rax
16c1:	add    %gs:0xffffffffaa995028,%rax
16ca:	jmp    0xffffffffc01d365a
16cc:	xor    %eax,%eax
; if (xpop_stats_data) {
16ce:	test   %rax,%rax
16d1:	je     0xffffffffc01d3874
; 
16d7:	mov    0x8(%rax),%rdi
16db:	add    $0x1,%rdi
16df:	mov    %rdi,0x8(%rax)
16e3:	jmp    0xffffffffc01d3874
16e8:	mov    %r14,-0x90(%rbp)
; data_stats->v1 += 1;
16ef:	mov    0x0(%rax),%rdi
16f3:	add    $0x1,%rdi
16f7:	mov    %rdi,0x0(%rax)
; 
16fb:	mov    %r15,%rdi
16fe:	add    $0x14,%rdi
1702:	mov    $0x1,%r14d
; if ((data + offset + sizeof(struct iphdr)) > data_end) {
1708:	mov    %r15,%rsi
170b:	add    $0x36,%rsi
170f:	mov    $0x1,%edx
; if ((data + offset + sizeof(struct iphdr)) > data_end) {
1714:	cmp    %r13,%rsi
1717:	ja     0xffffffffc01d36e2
; csum = iph->check + 0x0001;
1719:	movzwq 0x2c(%r15),%rsi
; csum = iph->check + 0x0001;
171e:	add    $0x1,%rsi
; iph->check = (csum & 0xffff) + (csum >> 16);
1722:	mov    %rsi,%rdx
1725:	shr    $0x10,%rdx
; iph->check = (csum & 0xffff) + (csum >> 16);
1729:	add    %rsi,%rdx
; iph->check = (csum & 0xffff) + (csum >> 16);
172c:	mov    %dx,0x2c(%r15)
; if (!--iph->ttl) {
1731:	movzbq 0x2a(%r15),%rsi
1736:	add    $0xffffffffffffffff,%rsi
173a:	mov    %sil,0x2a(%r15)
173e:	and    $0xff,%rsi
1745:	mov    $0x1,%edx
174a:	test   %rsi,%rsi
174d:	je     0xffffffffc01d36e2
174f:	mov    $0xffffffffffffffff,%rdx
1756:	mov    %rdx,%r13
; memcpy(new_eth->h_source, old_eth->h_source, 6);
1759:	movzbq 0xb(%r15),%rsi
175e:	mov    %sil,0x1f(%r15)
1762:	movzbq 0xa(%r15),%rsi
1767:	mov    %sil,0x1e(%r15)
176b:	movzbq 0x9(%r15),%rsi
1770:	mov    %sil,0x1d(%r15)
1774:	movzbq 0x8(%r15),%rsi
1779:	mov    %sil,0x1c(%r15)
177d:	movzbq 0x7(%r15),%rsi
1782:	mov    %sil,0x1b(%r15)
1786:	movzbq 0x6(%r15),%rsi
178b:	mov    %sil,0x1a(%r15)
; memcpy(new_eth->h_dest, old_eth->h_dest, 6);
178f:	movzbq 0x4(%r15),%rsi
1794:	mov    %sil,0x4(%rdi)
1798:	movzbq 0x5(%r15),%rsi
179d:	mov    %sil,0x5(%rdi)
17a1:	movzbq 0x2(%r15),%rsi
17a6:	mov    %sil,0x2(%rdi)
17aa:	movzbq 0x3(%r15),%rsi
17af:	mov    %sil,0x3(%rdi)
17b3:	movzbq 0x0(%r15),%rsi
17b8:	mov    %sil,0x0(%rdi)
17bc:	movzbq 0x1(%r15),%rsi
17c1:	mov    %sil,0x1(%rdi)
17c5:	xor    %edi,%edi
; new_eth->h_proto = BE_ETH_P_IP;
17c7:	mov    %dil,0x21(%r15)
17cb:	mov    $0x8,%edi
17d0:	mov    %dil,0x20(%r15)
; if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
17d4:	mov    %rbx,%rdi
17d7:	mov    $0x14,%esi
17dc:	call   0xffffffffa6e35c20
17e1:	shl    $0x20,%rax
17e5:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, (int)sizeof(struct iphdr))) {
17e9:	test   %rax,%rax
17ec:	jne    0xffffffffc01d3469
17f2:	mov    $0x20a,%edi
; __u32 stats_key = MAX_VIPS + DECAP_CNTR;
17f7:	mov    %edi,-0x88(%rbp)
17fd:	mov    %rbp,%rsi
; 
1800:	add    $0xffffffffffffff78,%rsi
; struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
1807:	movabs $0xffff8881a98d8000,%rdi
1811:	add    $0x100,%rdi
1818:	mov    0x0(%rsi),%eax
181b:	cmp    $0x400,%rax
1822:	jae    0xffffffffc01d37c6
1824:	shl    $0x3,%rax
1828:	add    %rdi,%rax
182b:	mov    0x0(%rax),%rax
182f:	add    %gs:0xffffffffaa995028,%rax
1838:	jmp    0xffffffffc01d37c8
183a:	xor    %eax,%eax
183c:	mov    $0x1,%r14d
; if (!data_stats) {
1842:	test   %rax,%rax
1845:	je     0xffffffffc01d3469
; data_stats->v2 += 1;
184b:	mov    0x8(%rax),%rdi
184f:	add    $0x1,%rdi
1853:	mov    %rdi,0x8(%rax)
; if (action >= 0) {
1857:	mov    %r13,%rdi
185a:	shl    $0x20,%rdi
185e:	sar    $0x20,%rdi
; if (action >= 0) {
1862:	mov    %r13,%r14
1865:	cmp    $0xffffffffffffffff,%rdi
1869:	jg     0xffffffffc01d37fd
186b:	mov    $0x2,%r14d
1871:	mov    -0x90(%rbp),%rdi
1878:	test   %rdi,%rdi
187b:	je     0xffffffffc01d3469
1881:	shl    $0x20,%r13
1885:	sar    $0x20,%r13
1889:	cmp    $0xffffffffffffffff,%r13
188d:	jg     0xffffffffc01d3469
1893:	mov    $0x20e,%edi
; __u32 xpop_stats_key = MAX_VIPS + XPOP_DECAP_SUCCESSFUL;
1898:	mov    %edi,-0x80(%rbp)
189b:	mov    %rbp,%rsi
; 
189e:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &xpop_stats_key);
18a2:	movabs $0xffff8881a98d8000,%rdi
18ac:	add    $0x100,%rdi
18b3:	mov    0x0(%rsi),%eax
18b6:	cmp    $0x400,%rax
18bd:	jae    0xffffffffc01d3861
18bf:	shl    $0x3,%rax
18c3:	add    %rdi,%rax
18c6:	mov    0x0(%rax),%rax
18ca:	add    %gs:0xffffffffaa995028,%rax
18d3:	jmp    0xffffffffc01d3863
18d5:	xor    %eax,%eax
; if (xpop_stats_data) {
18d7:	test   %rax,%rax
18da:	je     0xffffffffc01d3874
; 
18dc:	mov    0x0(%rax),%rdi
18e0:	add    $0x1,%rdi
18e4:	mov    %rdi,0x0(%rax)
18e8:	mov    $0xa6c,%edi
18ed:	mov    %di,-0x6c(%rbp)
18f1:	mov    $0x6c616320,%edi
18f6:	mov    %edi,-0x70(%rbp)
18f9:	movabs $0x6c69617420657461,%rdi
1903:	mov    %rdi,-0x78(%rbp)
1907:	movabs $0x6c75637269636572,%rdi
1911:	mov    %rdi,-0x80(%rbp)
1915:	xor    %edi,%edi
1917:	mov    %dil,-0x6a(%rbp)
191b:	mov    %rbp,%rdi
191e:	add    $0xffffffffffffff80,%rdi
1922:	mov    $0x17,%esi
1927:	call   0xffffffffa4b909f0
192c:	mov    %rbx,%rdi
192f:	movabs $0xffff88819b01f400,%rsi
1939:	xor    %edx,%edx
193b:	mov    -0xe8(%rbp),%rax
1942:	cmpq   $0x21,(%rax)
1946:	jae    0xffffffffc01d38f2
1948:	nopl   0x0(%rax,%rax,1)
194d:	addq   $0x1,(%rax)
1951:	pop    %r15
1953:	pop    %r14
1955:	pop    %r13
1957:	pop    %rbx
1958:	pop    %rax
1959:	pop    %rax
195a:	add    $0xd8,%rsp
1961:	jmp    0xffffffffc01d1f9c
1966:	mov    $0x2,%r14d
196c:	jmp    0xffffffffc01d3469
; pckt->flow.port16[0] = tcp->dest;
1971:	movzwq 0x2(%rdx),%rsi
; pckt->flow.port16[0] = tcp->dest;
1976:	mov    %si,-0x18(%rbp)
; pckt->flow.port16[0] = tcp->dest;
197a:	mov    %rbp,%rcx
197d:	add    $0xffffffffffffffe8,%rcx
1981:	jmp    0xffffffffc01d3918
; pckt->flow.port16[0] = udp->dest;
1983:	movzwq 0x2(%rdx),%rsi
; pckt->flow.port16[0] = udp->dest;
1988:	mov    %si,-0x18(%rbp)
; 
198c:	movzwq 0x0(%rdx),%rsi
1991:	mov    %rcx,-0x98(%rbp)
1998:	mov    %si,0x2(%rcx)
; vip.proto = pckt.flow.proto;
199c:	mov    %dil,-0x3e(%rbp)
; vip.port = pckt.flow.port16[1];
19a0:	mov    %si,-0x40(%rbp)
; vip.vip = pckt.flow.dst;
19a4:	mov    -0x28(%rbp),%edi
; vip.vip = pckt.flow.dst;
19a7:	mov    %edi,-0x50(%rbp)
19aa:	mov    %rbp,%rsi
; 
19ad:	add    $0xffffffffffffffb0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip);
19b1:	movabs $0xffff8881a9939800,%rdi
19bb:	call   0xffffffffa4cbb9b0
19c0:	test   %rax,%rax
19c3:	je     0xffffffffc01d3955
19c5:	add    $0x48,%rax
; if (!vip_info) {
19c9:	test   %rax,%rax
19cc:	jne    0xffffffffc01d39b8
19ce:	xor    %edi,%edi
; vip.port = 0;
19d0:	mov    %di,-0x40(%rbp)
19d4:	mov    %rbp,%rsi
19d7:	add    $0xffffffffffffffb0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip);
19db:	movabs $0xffff8881a9939800,%rdi
19e5:	call   0xffffffffa4cbb9b0
19ea:	test   %rax,%rax
19ed:	je     0xffffffffc01d397f
19ef:	add    $0x48,%rax
; 
19f3:	mov    $0x2,%r14d
19f9:	mov    -0x90(%rbp),%rdi
; if (!vip_info) {
1a00:	test   %rax,%rax
1a03:	je     0xffffffffc01d3469
1a09:	mov    %rdi,-0x90(%rbp)
; if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
1a10:	mov    0x0(%rax),%edi
; if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
1a13:	and    $0x88,%rdi
1a1a:	test   %rdi,%rdi
1a1d:	jne    0xffffffffc01d39b8
1a1f:	xor    %edi,%edi
; pckt.flow.port16[1] = 0;
1a21:	mov    -0x98(%rbp),%rsi
1a28:	mov    %di,0x2(%rsi)
; if (data_end - data > MAX_PCKT_SIZE) {
1a2c:	mov    %r13,%rdi
1a2f:	sub    %r15,%rdi
; 
1a32:	mov    $0x1,%r14d
1a38:	mov    -0x90(%rbp),%rsi
; if (data_end - data > MAX_PCKT_SIZE) {
1a3f:	cmp    $0x5ea,%rdi
1a46:	jg     0xffffffffc01d3469
1a4c:	mov    %rax,-0xa0(%rbp)
1a53:	mov    %rsi,-0x90(%rbp)
1a5a:	mov    $0x200,%edi
; __u32 stats_key = MAX_VIPS + LRU_CNTRS;
1a5f:	mov    %edi,-0x5c(%rbp)
1a62:	mov    %rbp,%rsi
; 
1a65:	add    $0xffffffffffffffa4,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &stats_key);
1a69:	movabs $0xffff8881a98d8000,%rdi
1a73:	add    $0x100,%rdi
1a7a:	mov    0x0(%rsi),%eax
1a7d:	cmp    $0x400,%rax
1a84:	jae    0xffffffffc01d3a28
1a86:	shl    $0x3,%rax
1a8a:	add    %rdi,%rax
1a8d:	mov    0x0(%rax),%rax
1a91:	add    %gs:0xffffffffaa995028,%rax
1a9a:	jmp    0xffffffffc01d3a2a
1a9c:	xor    %eax,%eax
1a9e:	mov    $0x1,%r14d
; if (!data_stats) {
1aa4:	test   %rax,%rax
1aa7:	je     0xffffffffc01d3469
; data_stats->v1 += 1;
1aad:	mov    0x0(%rax),%rdi
1ab1:	add    $0x1,%rdi
1ab5:	mov    %rax,-0xb0(%rbp)
1abc:	mov    %rdi,0x0(%rax)
1ac0:	mov    -0xa0(%rbp),%r14
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
1ac7:	mov    0x0(%r14),%edi
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
1acb:	and    $0x1,%rdi
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
1acf:	test   %rdi,%rdi
1ad2:	je     0xffffffffc01d3a66
1ad4:	xor    %edi,%edi
; pckt.flow.port16[0] = 0;
1ad6:	mov    %di,-0x18(%rbp)
; vip_num = vip_info->vip_num;
1ada:	mov    0x4(%r14),%edi
; vip_num = vip_info->vip_num;
1ade:	mov    %edi,-0x54(%rbp)
; __u32 cpu_num = bpf_get_smp_processor_id();
1ae1:	mov    $0xffffffffaa995034,%rax
1ae8:	add    %gs:0xffffffffaa995028,%rax
1af1:	mov    0x0(%rax),%eax
; __u32 cpu_num = bpf_get_smp_processor_id();
1af4:	mov    %eax,-0x60(%rbp)
1af7:	mov    %rbp,%rsi
; vip_num = vip_info->vip_num;
1afa:	add    $0xffffffffffffffa0,%rsi
; void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
1afe:	movabs $0xffff888102de7000,%rdi
1b08:	add    $0x100,%rdi
1b0f:	mov    0x0(%rsi),%eax
1b12:	cmp    $0x80,%rax
1b19:	jae    0xffffffffc01d3ab9
1b1b:	shl    $0x3,%rax
1b1f:	add    %rdi,%rax
1b22:	mov    0x0(%rax),%rax
1b26:	test   %rax,%rax
1b29:	je     0xffffffffc01d3ab9
1b2b:	jmp    0xffffffffc01d3abb
1b2d:	xor    %eax,%eax
1b2f:	mov    %rax,-0xa8(%rbp)
; if (!lru_map) {
1b36:	test   %rax,%rax
1b39:	jne    0xffffffffc01d3b38
1b3b:	mov    $0x203,%edi
; __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
1b40:	mov    %edi,-0x80(%rbp)
1b43:	mov    %rbp,%rsi
; 
1b46:	add    $0xffffffffffffff80,%rsi
; struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
1b4a:	movabs $0xffff8881a98d8000,%rdi
1b54:	add    $0x100,%rdi
1b5b:	mov    0x0(%rsi),%eax
1b5e:	cmp    $0x400,%rax
1b65:	jae    0xffffffffc01d3b09
1b67:	shl    $0x3,%rax
1b6b:	add    %rdi,%rax
1b6e:	mov    0x0(%rax),%rax
1b72:	add    %gs:0xffffffffaa995028,%rax
1b7b:	jmp    0xffffffffc01d3b0b
1b7d:	xor    %eax,%eax
; if (!lru_stats) {
1b7f:	test   %rax,%rax
1b82:	je     0xffffffffc01d3463
; lru_stats->v1 += 1;
1b88:	mov    0x0(%rax),%rdi
1b8c:	add    $0x1,%rdi
1b90:	mov    %rdi,0x0(%rax)
1b94:	movabs $0xffff8881a993a000,%rdi
1b9e:	mov    %rdi,-0xa8(%rbp)
1ba5:	mov    -0xa0(%rbp),%r14
; if ((vip_info->flags & F_QUIC_VIP)) {
1bac:	mov    0x0(%r14),%edi
; if ((vip_info->flags & F_QUIC_VIP)) {
1bb0:	and    $0x4,%rdi
1bb4:	mov    %r14,%rsi
; if ((vip_info->flags & F_QUIC_VIP)) {
1bb7:	test   %rdi,%rdi
1bba:	je     0xffffffffc01d4fed
; bool is_icmp = (pckt.flags & F_ICMP);
1bc0:	movzbq -0xc(%rbp),%rdi
; bool is_icmp = (pckt.flags & F_ICMP);
1bc5:	and    $0x1,%rdi
; if (is_icmp) {
1bc9:	test   %rdi,%rdi
1bcc:	je     0xffffffffc01d3ecd
1bd2:	mov    $0x20b,%edi
; __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
1bd7:	mov    %edi,-0x80(%rbp)
1bda:	mov    %rbp,%rsi
; 
1bdd:	add    $0xffffffffffffff80,%rsi
; struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
1be1:	movabs $0xffff8881a98d8000,%rdi
1beb:	add    $0x100,%rdi
1bf2:	mov    0x0(%rsi),%eax
1bf5:	cmp    $0x400,%rax
1bfc:	jae    0xffffffffc01d3ba0
1bfe:	shl    $0x3,%rax
1c02:	add    %rdi,%rax
1c05:	mov    0x0(%rax),%rax
1c09:	add    %gs:0xffffffffaa995028,%rax
1c12:	jmp    0xffffffffc01d3ba2
1c14:	xor    %eax,%eax
; if (!data_stats) {
1c16:	test   %rax,%rax
1c19:	je     0xffffffffc01d3463
; data_stats->v1 += 1;
1c1f:	mov    0x0(%rax),%rdi
1c23:	add    $0x1,%rdi
1c27:	mov    %rdi,0x0(%rax)
; (icmp_hdr->code == ICMP_PORT_UNREACH) ||
1c2b:	movzbq 0x23(%r15),%rdi
; (icmp_hdr->code == ICMP_PORT_UNREACH) ||
1c30:	and    $0xfd,%rdi
; if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
1c37:	cmp    $0x1,%rdi
1c3b:	jne    0xffffffffc01d4fe6
; data_stats->v2 += 1;
1c41:	mov    0x8(%rax),%rdi
1c45:	add    $0x1,%rdi
1c49:	mov    %rdi,0x8(%rax)
1c4d:	jmp    0xffffffffc01d4fe6
1c52:	xor    %edi,%edi
; __u32 quic_packets_stats_key = 0;
1c54:	mov    %edi,-0x88(%rbp)
1c5a:	mov    %rbp,%rsi
; 
1c5d:	add    $0xffffffffffffff78,%rsi
; bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
1c64:	movabs $0xffff88819b01fc00,%rdi
1c6e:	add    $0x100,%rdi
1c75:	mov    0x0(%rsi),%eax
1c78:	cmp    $0x1,%rax
1c7c:	jae    0xffffffffc01d3c20
1c7e:	shl    $0x3,%rax
1c82:	add    %rdi,%rax
1c85:	mov    0x0(%rax),%rax
1c89:	add    %gs:0xffffffffaa995028,%rax
1c92:	jmp    0xffffffffc01d3c22
1c94:	xor    %eax,%eax
; if (!quic_packets_stats) {
1c96:	test   %rax,%rax
1c99:	je     0xffffffffc01d3463
; bool is_icmp = (pckt->flags & F_ICMP);
1c9f:	movzbq -0xc(%rbp),%rsi
; bool is_icmp = (pckt->flags & F_ICMP);
1ca4:	and    $0x1,%rsi
1ca8:	mov    $0x36,%edi
; if (is_ipv6) {
1cad:	test   %rsi,%rsi
1cb0:	je     0xffffffffc01d3c43
1cb2:	mov    $0x66,%edi
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
1cb7:	add    %rdi,%r15
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
1cba:	mov    %r15,%rdi
1cbd:	add    $0x9,%rdi
1cc1:	mov    %r14,%rcx
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
1cc4:	cmp    %r13,%rdi
1cc7:	ja     0xffffffffc01d3ca7
; 
1cc9:	add    $0x8,%r15
; if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
1ccd:	movzbq 0x0(%r15),%rsi
1cd2:	shl    $0x38,%rsi
1cd6:	sar    $0x38,%rsi
; if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
1cda:	cmp    $0xffffffffffffffff,%rsi
1cde:	jg     0xffffffffc01d4b83
; if (quic_data + sizeof(struct quic_long_header) > data_end) {
1ce4:	mov    %r15,%rdi
1ce7:	add    $0xe,%rdi
; if (quic_data + sizeof(struct quic_long_header) > data_end) {
1ceb:	cmp    %r13,%rdi
1cee:	ja     0xffffffffc01d3ca7
1cf0:	mov    %rcx,%r14
; if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
1cf3:	and    $0x20,%rsi
; if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
1cf7:	test   %rsi,%rsi
1cfa:	je     0xffffffffc01d4c5f
; if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
1d00:	movzbq 0x5(%r15),%rdi
; if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
1d05:	add    $0x6,%r15
1d09:	mov    $0x8,%esi
1d0e:	mov    %r14,%rcx
1d11:	cmp    %rdi,%rsi
1d14:	ja     0xffffffffc01d3ca7
1d16:	jmp    0xffffffffc01d4b96
; quic_packets_stats->ch_routed += 1;
1d1b:	mov    0x0(%rax),%rdi
1d1f:	add    $0x1,%rdi
1d23:	mov    %rdi,0x0(%rax)
1d27:	mov    -0xa0(%rbp),%rsi
1d2e:	xor    %r15d,%r15d
; original_sport = pckt.flow.port16[0];
1d31:	movzwq -0x18(%rbp),%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
1d36:	mov    %rdi,-0xb0(%rbp)
1d3d:	movzbq -0xc(%rbp),%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
1d42:	and    $0x2,%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
1d46:	test   %rdi,%rdi
1d49:	jne    0xffffffffc01d3d7b
; !(vip_info->flags & F_LRU_BYPASS)) {
1d4f:	mov    0x0(%rsi),%edi
; !(vip_info->flags & F_LRU_BYPASS)) {
1d52:	and    $0x2,%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
1d56:	test   %rdi,%rdi
1d59:	jne    0xffffffffc01d3d7b
1d5f:	mov    %rbp,%rsi
; 
1d62:	add    $0xffffffffffffffc8,%rsi
1d66:	mov    %rcx,%r13
; dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);
1d69:	mov    %rcx,%rdi
1d6c:	call   0xffffffffa4c9c930
1d71:	mov    %rax,%r14
1d74:	xor    %r15d,%r15d
; if (!dst_lru) {
1d77:	test   %r14,%r14
1d7a:	je     0xffffffffc01d3d71
; if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
1d7c:	movzbq -0x14(%rbp),%rdi
; if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
1d81:	cmp    $0x11,%rdi
1d85:	jne    0xffffffffc01d3d35
; cur_time = bpf_ktime_get_ns();
1d87:	call   0xffffffffa4c9d630
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
1d8c:	mov    0x8(%r14),%rdi
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
1d90:	mov    %rax,%rsi
1d93:	sub    %rdi,%rsi
1d96:	movabs $0x6fc23ac00,%rdi
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
1da0:	cmp    %rdi,%rsi
1da3:	ja     0xffffffffc01d3d71
; dst_lru->atime = cur_time;
1da5:	mov    %rax,0x8(%r14)
; key = dst_lru->pos;
1da9:	mov    0x0(%r14),%edi
; pckt->real_index = key;
1dad:	mov    %edi,-0x10(%rbp)
; key = dst_lru->pos;
1db0:	mov    %edi,-0x80(%rbp)
1db3:	mov    %rbp,%rsi
; key = dst_lru->pos;
1db6:	add    $0xffffffffffffff80,%rsi
; *real = bpf_map_lookup_elem(&reals, &key);
1dba:	movabs $0xffffc90008d64000,%rdi
1dc4:	add    $0x100,%rdi
1dcb:	mov    0x0(%rsi),%eax
1dce:	cmp    $0x1000,%rax
1dd5:	jae    0xffffffffc01d3d6c
1dd7:	imul   $0x18,%rax,%rax
1ddb:	add    %rdi,%rax
1dde:	jmp    0xffffffffc01d3d6e
1de0:	xor    %eax,%eax
1de2:	mov    %rax,%r15
1de5:	mov    %r13,%rcx
1de8:	mov    -0xa0(%rbp),%rsi
; if (dst && pckt->flow.proto == IPPROTO_UDP &&
1def:	movzbq -0x14(%rbp),%rdi
; if (dst && pckt->flow.proto == IPPROTO_UDP &&
1df4:	cmp    $0x11,%rdi
1df8:	jne    0xffffffffc01d3fb9
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
1dfe:	mov    0x0(%rsi),%edi
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
1e01:	and    $0x200,%rdi
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
1e08:	test   %rdi,%rdi
1e0b:	je     0xffffffffc01d3fb9
1e11:	mov    %rcx,%r13
1e14:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
1e19:	mov    %edi,-0x80(%rbp)
1e1c:	mov    %rbp,%rsi
; 
1e1f:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
1e23:	movabs $0xffff8881a98d8000,%rdi
1e2d:	add    $0x100,%rdi
1e34:	mov    0x0(%rsi),%eax
1e37:	cmp    $0x400,%rax
1e3e:	jae    0xffffffffc01d3de2
1e40:	shl    $0x3,%rax
1e44:	add    %rdi,%rax
1e47:	mov    0x0(%rax),%rax
1e4b:	add    %gs:0xffffffffaa995028,%rax
1e54:	jmp    0xffffffffc01d3de4
1e56:	xor    %eax,%eax
1e58:	mov    %rax,%r14
; if (!conn_rate_stats) {
1e5b:	test   %r14,%r14
1e5e:	je     0xffffffffc01d3fb6
; *cur_time = bpf_ktime_get_ns();
1e64:	call   0xffffffffa4c9d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
1e69:	mov    0x8(%r14),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
1e6d:	mov    %rax,%rsi
1e70:	sub    %rdi,%rsi
1e73:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
1e78:	cmp    %rsi,%rdi
1e7b:	ja     0xffffffffc01d3f9c
; conn_rate_stats->v2 = *cur_time;
1e81:	mov    %rax,0x8(%r14)
1e85:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
1e8a:	mov    %rdi,0x0(%r14)
1e8e:	mov    %rbp,%rsi
; void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
1e91:	add    $0xffffffffffffffb0,%rsi
1e95:	movabs $0xffff8881a993b800,%rdi
1e9f:	call   0xffffffffa4cbb9b0
1ea4:	test   %rax,%rax
1ea7:	je     0xffffffffc01d3e3d
1ea9:	add    $0x48,%rax
1ead:	mov    0x0(%rax),%rax
1eb1:	mov    %r13,%rcx
; if (down_reals_map) {
1eb4:	test   %rax,%rax
1eb7:	je     0xffffffffc01d3fb9
; void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
1ebd:	mov    %rbp,%rsi
1ec0:	add    $0xfffffffffffffff0,%rsi
; void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
1ec4:	mov    %rax,%rdi
1ec7:	mov    %rcx,%r14
1eca:	call   0xffffffffa4cbb9b0
1ecf:	test   %rax,%rax
1ed2:	je     0xffffffffc01d3e64
1ed4:	add    $0x38,%rax
1ed8:	mov    %r14,%rcx
; if (down_real) {
1edb:	test   %rax,%rax
1ede:	je     0xffffffffc01d3fb9
1ee4:	mov    $0x20f,%edi
; __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
1ee9:	mov    %edi,-0x80(%rbp)
1eec:	mov    %rbp,%rsi
; 
1eef:	add    $0xffffffffffffff80,%rsi
; struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
1ef3:	movabs $0xffff8881a98d8000,%rdi
1efd:	add    $0x100,%rdi
1f04:	mov    0x0(%rsi),%eax
1f07:	cmp    $0x400,%rax
1f0e:	jae    0xffffffffc01d3eb2
1f10:	shl    $0x3,%rax
1f14:	add    %rdi,%rax
1f17:	mov    0x0(%rax),%rax
1f1b:	add    %gs:0xffffffffaa995028,%rax
1f24:	jmp    0xffffffffc01d3eb4
1f26:	xor    %eax,%eax
; if (stats_data) {
1f28:	test   %rax,%rax
1f2b:	je     0xffffffffc01d3ec5
; stats_data->v1 += 1;
1f2d:	mov    0x0(%rax),%rdi
1f31:	add    $0x1,%rdi
1f35:	mov    %rdi,0x0(%rax)
1f39:	mov    %r13,%rcx
1f3c:	jmp    0xffffffffc01d4224
1f41:	xor    %edi,%edi
; __u32 quic_packets_stats_key = 0;
1f43:	mov    %edi,-0x88(%rbp)
1f49:	mov    %rbp,%rsi
; 
1f4c:	add    $0xffffffffffffff78,%rsi
; bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
1f53:	movabs $0xffff88819b01fc00,%rdi
1f5d:	add    $0x100,%rdi
1f64:	mov    0x0(%rsi),%eax
1f67:	cmp    $0x1,%rax
1f6b:	jae    0xffffffffc01d3f0f
1f6d:	shl    $0x3,%rax
1f71:	add    %rdi,%rax
1f74:	mov    0x0(%rax),%rax
1f78:	add    %gs:0xffffffffaa995028,%rax
1f81:	jmp    0xffffffffc01d3f11
1f83:	xor    %eax,%eax
1f85:	mov    %rax,%r14
; if (!quic_packets_stats) {
1f88:	test   %rax,%rax
1f8b:	je     0xffffffffc01d3463
; bool is_icmp = (pckt->flags & F_ICMP);
1f91:	movzbq -0xc(%rbp),%rsi
; bool is_icmp = (pckt->flags & F_ICMP);
1f96:	and    $0x1,%rsi
1f9a:	mov    $0x22,%edi
; if (is_ipv6) {
1f9f:	test   %rsi,%rsi
1fa2:	je     0xffffffffc01d3f35
1fa4:	mov    $0x3e,%edi
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
1fa9:	add    %rdi,%r15
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
1fac:	mov    %r15,%rdi
1faf:	add    $0x9,%rdi
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
1fb3:	cmp    %r13,%rdi
1fb6:	ja     0xffffffffc01d4fda
; 
1fbc:	add    $0x8,%r15
; if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
1fc0:	movzbq 0x0(%r15),%rsi
1fc5:	shl    $0x38,%rsi
1fc9:	sar    $0x38,%rsi
; if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
1fcd:	cmp    $0xffffffffffffffff,%rsi
1fd1:	jg     0xffffffffc01d4bfb
; if (quic_data + sizeof(struct quic_long_header) > data_end) {
1fd7:	mov    %r15,%rdi
1fda:	add    $0xe,%rdi
; if (quic_data + sizeof(struct quic_long_header) > data_end) {
1fde:	cmp    %r13,%rdi
1fe1:	ja     0xffffffffc01d4fda
; if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
1fe7:	and    $0x20,%rsi
; if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
1feb:	test   %rsi,%rsi
1fee:	je     0xffffffffc01d4e43
; if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
1ff4:	movzbq 0x5(%r15),%rdi
; if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
1ff9:	add    $0x6,%r15
1ffd:	mov    $0x8,%esi
2002:	cmp    %rdi,%rsi
2005:	ja     0xffffffffc01d4fda
200b:	jmp    0xffffffffc01d4c0e
; conn_rate_stats->v1 += 1;
2010:	mov    0x0(%r14),%rdi
2014:	add    $0x1,%rdi
2018:	mov    %rdi,0x0(%r14)
201c:	mov    $0x1e849,%esi
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
2021:	cmp    %rdi,%rsi
2024:	ja     0xffffffffc01d3e1a
202a:	mov    %r13,%rcx
; if (!dst) {
202d:	test   %r15,%r15
2030:	jne    0xffffffffc01d3fc3
2032:	jmp    0xffffffffc01d4224
2037:	mov    %r15,-0x98(%rbp)
203e:	mov    %rbp,%rsi
; 
2041:	add    $0xffffffffffffffa8,%rsi
; cval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos);
2045:	movabs $0xffff88819b01f000,%rdi
204f:	add    $0x100,%rdi
2056:	mov    0x0(%rsi),%eax
2059:	cmp    $0x10,%rax
205d:	jae    0xffffffffc01d3ff4
205f:	shl    $0x3,%rax
2063:	add    %rdi,%rax
2066:	jmp    0xffffffffc01d3ff6
2068:	xor    %eax,%eax
206a:	mov    %rax,%r15
206d:	mov    $0x1,%r14d
; if (!cval) {
2073:	test   %r15,%r15
2076:	je     0xffffffffc01d3469
207c:	mov    %rbp,%rsi
; 
207f:	add    $0xffffffffffffffac,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &vip_num);
2083:	movabs $0xffff8881a98d8000,%rdi
208d:	add    $0x100,%rdi
2094:	mov    0x0(%rsi),%eax
2097:	cmp    $0x400,%rax
209e:	jae    0xffffffffc01d4042
20a0:	shl    $0x3,%rax
20a4:	add    %rdi,%rax
20a7:	mov    0x0(%rax),%rax
20ab:	add    %gs:0xffffffffaa995028,%rax
20b4:	jmp    0xffffffffc01d4044
20b6:	xor    %eax,%eax
; if (!data_stats) {
20b8:	test   %rax,%rax
20bb:	je     0xffffffffc01d3469
20c1:	mov    -0x90(%rbp),%rsi
20c8:	ror    $0x8,%si
20cc:	movzwl %si,%esi
; data_stats->v1 += 1;
20cf:	mov    0x0(%rax),%rdi
20d3:	add    $0x1,%rdi
20d7:	mov    %rdi,0x0(%rax)
; data_stats->v2 += pkt_bytes;
20db:	mov    0x8(%rax),%rdi
20df:	mov    %rsi,%r13
20e2:	add    %rsi,%rdi
20e5:	mov    %rdi,0x8(%rax)
; data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
20e9:	mov    %rbp,%rsi
20ec:	add    $0xfffffffffffffff0,%rsi
; data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
20f0:	movabs $0xffffc90008d7e000,%rdi
20fa:	add    $0x100,%rdi
2101:	mov    0x0(%rsi),%eax
2104:	cmp    $0x1000,%rax
210b:	jae    0xffffffffc01d40af
210d:	shl    $0x3,%rax
2111:	add    %rdi,%rax
2114:	mov    0x0(%rax),%rax
2118:	add    %gs:0xffffffffaa995028,%rax
2121:	jmp    0xffffffffc01d40b1
2123:	xor    %eax,%eax
; if (!data_stats) {
2125:	test   %rax,%rax
2128:	je     0xffffffffc01d3469
; data_stats->v1 += 1;
212e:	mov    0x0(%rax),%rdi
2132:	add    $0x1,%rdi
2136:	mov    %rdi,0x0(%rax)
; data_stats->v2 += pkt_bytes;
213a:	mov    0x8(%rax),%rdi
213e:	add    %r13,%rdi
2141:	mov    %rdi,0x8(%rax)
; pckt.flow.port16[0] = original_sport;
2145:	mov    -0xb0(%rbp),%rdi
214c:	mov    %di,-0x18(%rbp)
; if (dst->flags & F_IPV6) {
2150:	mov    -0x98(%rbp),%rdi
2157:	movzbq 0x10(%rdi),%rdi
; if (dst->flags & F_IPV6) {
215c:	and    $0x1,%rdi
; if (dst->flags & F_IPV6) {
2160:	test   %rdi,%rdi
2163:	je     0xffffffffc01d49b5
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
2169:	mov    %rbx,%rdi
216c:	mov    $0xffffffd8,%esi
2171:	call   0xffffffffa6e35c20
2176:	shl    $0x20,%rax
217a:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
217e:	test   %rax,%rax
2181:	jne    0xffffffffc01d3469
; data = (void*)(long)xdp->data;
2187:	mov    0x0(%rbx),%rdi
; data_end = (void*)(long)xdp->data_end;
218b:	mov    0x8(%rbx),%rsi
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
218f:	mov    %rdi,%rdx
2192:	add    $0xe,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
2196:	cmp    %rsi,%rdx
2199:	ja     0xffffffffc01d3469
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
219f:	mov    %rdi,%rdx
21a2:	add    $0x36,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
21a6:	cmp    %rsi,%rdx
21a9:	ja     0xffffffffc01d3469
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
21af:	cmp    %rsi,%rdx
21b2:	ja     0xffffffffc01d3469
; 
21b8:	mov    %rdi,%rsi
21bb:	add    $0x28,%rsi
; memcpy(new_eth->h_dest, cval->mac, 6);
21bf:	movzbq 0x5(%r15),%rdx
21c4:	mov    %dl,0x5(%rdi)
21c7:	movzbq 0x4(%r15),%rdx
21cc:	mov    %dl,0x4(%rdi)
21cf:	movzbq 0x3(%r15),%rdx
21d4:	mov    %dl,0x3(%rdi)
21d7:	movzbq 0x2(%r15),%rdx
21dc:	mov    %dl,0x2(%rdi)
21df:	movzbq 0x1(%r15),%rdx
21e4:	mov    %dl,0x1(%rdi)
21e7:	movzbq 0x0(%r15),%rdx
21ec:	mov    %dl,0x0(%rdi)
; memcpy(new_eth->h_source, old_eth->h_dest, 6);
21ef:	movzbq 0x2(%rsi),%rdx
21f4:	mov    %dl,0x8(%rdi)
21f7:	movzbq 0x3(%rsi),%rdx
21fc:	mov    %dl,0x9(%rdi)
21ff:	movzbq 0x0(%rsi),%rdx
2204:	mov    %dl,0x6(%rdi)
2207:	movzbq 0x1(%rsi),%rdx
220c:	mov    %dl,0x7(%rdi)
220f:	movzbq 0x4(%rsi),%rdx
2214:	mov    %dl,0xa(%rdi)
2217:	movzbq 0x5(%rsi),%rsi
221c:	mov    %sil,0xb(%rdi)
2220:	mov    $0x86,%esi
; new_eth->h_proto = BE_ETH_P_IPV6;
2225:	mov    %sil,0xc(%rdi)
2229:	mov    $0xdd,%esi
222e:	mov    %sil,0xd(%rdi)
; create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
2232:	movzwq -0x18(%rbp),%rsi
; create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
2237:	mov    -0x2c(%rbp),%edx
; saddr[3] = src ^ port;
223a:	xor    %rsi,%rdx
; create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
223d:	movzbq -0xb(%rbp),%rsi
2242:	mov    $0x1,%ecx
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
2247:	mov    %ecx,0x16(%rdi)
; payload_len = pkt_bytes + sizeof(struct ipv6hdr);
224a:	add    $0x28,%r13
; ip6h->payload_len = bpf_htons(payload_len);
224e:	ror    $0x8,%r13w
2253:	movzwl %r13w,%r13d
; ip6h->payload_len = bpf_htons(payload_len);
2257:	mov    %r13w,0x12(%rdi)
225c:	xor    %ecx,%ecx
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
225e:	mov    %ecx,0x1a(%rdi)
2261:	mov    %ecx,0x1e(%rdi)
; memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
2264:	mov    %cl,0x10(%rdi)
2267:	mov    %cl,0x11(%rdi)
226a:	mov    $0x4029,%ecx
; ip6h->nexthdr = proto;
226f:	mov    %cx,0x14(%rdi)
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
2273:	mov    %edx,0x22(%rdi)
; ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
2276:	mov    %rsi,%rdx
2279:	shl    $0x4,%rdx
; ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
227d:	mov    %dl,0xf(%rdi)
; ip6h->priority = (tc & 0xF0) >> 4;
2280:	shr    $0x4,%rsi
; ip6h->priority = (tc & 0xF0) >> 4;
2284:	or     $0x60,%rsi
2288:	mov    %sil,0xe(%rdi)
228c:	mov    -0x98(%rbp),%rdx
2293:	jmp    0xffffffffc01d5467
; if (pckt.flow.proto == IPPROTO_TCP) {
2298:	movzbq -0x14(%rbp),%rdi
; if (pckt.flow.proto == IPPROTO_TCP) {
229d:	cmp    $0x6,%rdi
22a1:	jne    0xffffffffc01d42aa
22a3:	mov    %rcx,%r13
22a6:	mov    $0x201,%edi
; __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
22ab:	mov    %edi,-0x80(%rbp)
22ae:	mov    %rbp,%rsi
; 
22b1:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &lru_stats_key);
22b5:	movabs $0xffff8881a98d8000,%rdi
22bf:	add    $0x100,%rdi
22c6:	mov    0x0(%rsi),%eax
22c9:	cmp    $0x400,%rax
22d0:	jae    0xffffffffc01d4274
22d2:	shl    $0x3,%rax
22d6:	add    %rdi,%rax
22d9:	mov    0x0(%rax),%rax
22dd:	add    %gs:0xffffffffaa995028,%rax
22e6:	jmp    0xffffffffc01d4276
22e8:	xor    %eax,%eax
; if (!lru_stats) {
22ea:	test   %rax,%rax
22ed:	je     0xffffffffc01d3463
; if (pckt.flags & F_SYN_SET) {
22f3:	movzbq -0xc(%rbp),%rsi
; if (pckt.flags & F_SYN_SET) {
22f8:	and    $0x2,%rsi
22fc:	mov    $0x1,%edi
2301:	test   %rsi,%rsi
2304:	je     0xffffffffc01d4294
2306:	xor    %edi,%edi
; if (pckt.flags & F_SYN_SET) {
2308:	shl    $0x3,%rdi
; 
230c:	add    %rdi,%rax
230f:	mov    0x0(%rax),%rdi
2313:	add    $0x1,%rdi
2317:	mov    %rdi,0x0(%rax)
231b:	mov    %r13,%rcx
231e:	mov    %rcx,-0xc8(%rbp)
2325:	xor    %r13d,%r13d
; struct real_pos_lru new_dst_lru = {};
2328:	mov    %r13,-0x78(%rbp)
232c:	mov    %r13,-0x80(%rbp)
2330:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
2335:	mov    %edi,-0x88(%rbp)
233b:	mov    %rbp,%rsi
; 
233e:	add    $0xffffffffffffff78,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
2345:	movabs $0xffff8881a98d8000,%rdi
234f:	add    $0x100,%rdi
2356:	mov    0x0(%rsi),%eax
2359:	cmp    $0x400,%rax
2360:	jae    0xffffffffc01d4304
2362:	shl    $0x3,%rax
2366:	add    %rdi,%rax
2369:	mov    0x0(%rax),%rax
236d:	add    %gs:0xffffffffaa995028,%rax
2376:	jmp    0xffffffffc01d4306
2378:	xor    %eax,%eax
237a:	mov    %rax,%r14
237d:	mov    $0x1,%r15d
; if (!conn_rate_stats) {
2383:	test   %r14,%r14
2386:	je     0xffffffffc01d4357
; *cur_time = bpf_ktime_get_ns();
2388:	call   0xffffffffa4c9d630
238d:	mov    %rax,%r13
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
2390:	mov    0x8(%r14),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
2394:	mov    %r13,%rsi
2397:	sub    %rdi,%rsi
239a:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
239f:	cmp    %rsi,%rdi
23a2:	ja     0xffffffffc01d433f
; conn_rate_stats->v2 = *cur_time;
23a4:	mov    %r13,0x8(%r14)
23a8:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
23ad:	mov    %rdi,0x0(%r14)
23b1:	jmp    0xffffffffc01d4354
; conn_rate_stats->v1 += 1;
23b3:	mov    0x0(%r14),%rdi
23b7:	add    $0x1,%rdi
23bb:	mov    %rdi,0x0(%r14)
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
23bf:	cmp    $0x1e848,%rdi
23c6:	ja     0xffffffffc01d4357
23c8:	xor    %r15d,%r15d
23cb:	mov    %r15,-0xd0(%rbp)
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
23d2:	mov    -0xa0(%rbp),%rdi
23d9:	mov    0x0(%rdi),%edi
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
23dc:	and    $0x8,%rdi
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
23e0:	mov    %r13,-0xd8(%rbp)
23e7:	test   %rdi,%rdi
23ea:	jne    0xffffffffc01d439e
; a += k[0];
23ec:	movzbq -0x2c(%rbp),%rdi
; a += (u32)k[1] << 8;
23f1:	mov    %rdi,-0xc0(%rbp)
23f8:	movzbq -0x2b(%rbp),%r15
; a += (u32)k[2] << 16;
23fd:	movzbq -0x2a(%rbp),%rax
; a += (u32)k[3] << 24;
2402:	movzbq -0x29(%rbp),%r14
; c += *(u32*)(k + 8);
2407:	mov    -0x30(%rbp),%ecx
; b += *(u32*)(k + 4);
240a:	mov    -0x34(%rbp),%esi
; a += *(u32*)(k);
240d:	mov    -0x38(%rbp),%edi
2410:	jmp    0xffffffffc01d43cf
; pckt->flow.port16[0] = pckt->flow.port16[1];
2412:	mov    -0x98(%rbp),%rdi
2419:	movzwq 0x2(%rdi),%rdi
; pckt->flow.port16[0] = pckt->flow.port16[1];
241e:	mov    %di,-0x18(%rbp)
2422:	xor    %esi,%esi
; memset(pckt->flow.srcv6, 0, 16);
2424:	mov    %rsi,-0x38(%rbp)
2428:	xor    %edi,%edi
242a:	mov    %rdi,-0xc0(%rbp)
2431:	mov    %rsi,-0x30(%rbp)
; a += (u32)k[1] << 8;
2435:	xor    %r15d,%r15d
; a += (u32)k[2] << 16;
2438:	xor    %eax,%eax
; a += (u32)k[3] << 24;
243a:	xor    %r14d,%r14d
; c += *(u32*)(k + 8);
243d:	xor    %ecx,%ecx
; b += *(u32*)(k + 4);
243f:	xor    %esi,%esi
; a += *(u32*)(k);
2441:	xor    %edi,%edi
; __jhash_mix(a, b, c);
2443:	sub    %rcx,%rdi
; c += *(u32*)(k + 8);
2446:	add    $0xffffffffdeadc0ff,%rcx
244d:	mov    $0xf0000000,%edx
2452:	mov    %rcx,%r8
2455:	and    %rdx,%r8
; return (word << shift) | (word >> ((-shift) & 31));
2458:	shr    $0x1c,%r8
245c:	mov    %rcx,%r13
245f:	shl    $0x4,%r13
2463:	or     %r8,%r13
; __jhash_mix(a, b, c);
2466:	xor    %rdi,%r13
2469:	mov    $0xfc000000,%edi
246e:	mov    %r13,%r8
2471:	and    %rdi,%r8
; return (word << shift) | (word >> ((-shift) & 31));
2474:	shr    $0x1a,%r8
2478:	mov    %r13,%rdx
247b:	shl    $0x6,%rdx
247f:	or     %r8,%rdx
; b += *(u32*)(k + 4);
2482:	add    $0xffffffffdeadc0ff,%rsi
; __jhash_mix(a, b, c);
2489:	mov    %rsi,%rdi
248c:	sub    %r13,%rdi
248f:	xor    %rdx,%rdi
; a += (u32)k[3] << 24;
2492:	shl    $0x18,%r14
; a += (u32)k[2] << 16;
2496:	and    $0xff,%rax
; a += (u32)k[2] << 16;
249c:	shl    $0x10,%rax
; a += (u32)k[3] << 24;
24a0:	or     %r14,%rax
; pckt->flow.ports,
24a3:	mov    -0x18(%rbp),%r14d
; b += initval;
24a7:	add    $0xffffffffe0adc0f7,%r14
24ae:	mov    %r14,%rdx
24b1:	mov    %rsi,%r8
24b4:	mov    %r14,%rsi
24b7:	mov    %rsi,-0x98(%rbp)
24be:	mov    $0xfffc0000,%r14d
24c4:	and    %r14,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
24c7:	shr    $0x12,%rdx
24cb:	mov    %rsi,%r14
24ce:	shl    $0xe,%r14
24d2:	or     %rdx,%r14
; __jhash_final(a, b, c);
24d5:	xor    $0xffffffffe0adc0f7,%rsi
24dc:	sub    %r14,%rsi
24df:	mov    %rsi,%r14
; __jhash_mix(a, b, c);
24e2:	add    %r8,%rcx
; a += (u32)k[1] << 8;
24e5:	and    $0xff,%r15
; a += (u32)k[1] << 8;
24ec:	shl    $0x8,%r15
; a += (u32)k[2] << 16;
24f0:	or     %r15,%rax
24f3:	mov    -0xc0(%rbp),%rsi
; a += k[0];
24fa:	and    $0xff,%rsi
; a += (u32)k[1] << 8;
2501:	or     %rsi,%rax
2504:	mov    $0xff000000,%esi
; __jhash_mix(a, b, c);
2509:	mov    %rdi,%rdx
250c:	and    %rsi,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
250f:	shr    $0x18,%rdx
2513:	mov    %rdi,%rsi
2516:	shl    $0x8,%rsi
251a:	or     %rdx,%rsi
; __jhash_mix(a, b, c);
251d:	add    %rcx,%r13
2520:	sub    %rdi,%rcx
2523:	xor    %rsi,%rcx
2526:	mov    $0xffe00000,%edx
252b:	mov    %r14,%r15
; __jhash_final(a, b, c);
252e:	mov    %r15,-0xb8(%rbp)
2535:	mov    %r15,%rsi
2538:	and    %rdx,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
253b:	shr    $0x15,%rsi
253f:	shl    $0xb,%r15
2543:	or     %rsi,%r15
2546:	mov    $0xffff0000,%edx
; __jhash_mix(a, b, c);
254b:	mov    %rcx,%rsi
254e:	and    %rdx,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
2551:	shr    $0x10,%rsi
2555:	mov    %rcx,%rdx
2558:	shl    $0x10,%rdx
255c:	or     %rsi,%rdx
; __jhash_mix(a, b, c);
255f:	add    %r13,%rdi
2562:	sub    %rcx,%r13
2565:	xor    %rdx,%r13
2568:	mov    $0xffffe000,%esi
256d:	mov    %r13,%rdx
2570:	and    %rsi,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
2573:	shr    $0xd,%rdx
2577:	mov    %r13,%rsi
257a:	shl    $0x13,%rsi
257e:	or     %rdx,%rsi
; __jhash_mix(a, b, c);
2581:	add    %rdi,%rcx
2584:	sub    %r13,%rdi
2587:	xor    %rsi,%rdi
258a:	add    %rcx,%r13
258d:	mov    %rdi,%r8
2590:	add    %r13,%r8
2593:	mov    %r8,%rdx
2596:	mov    $0xfffc0000,%esi
259b:	and    %rsi,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
259e:	shr    $0x12,%rdx
25a2:	mov    %r8,%rsi
25a5:	shl    $0xe,%rsi
25a9:	or     %rdx,%rsi
; __jhash_mix(a, b, c);
25ac:	mov    %rdi,%rdx
25af:	mov    $0xf0000000,%r14d
25b5:	and    %r14,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
25b8:	shr    $0x1c,%rdx
; __jhash_mix(a, b, c);
25bc:	sub    %rdi,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
25bf:	shl    $0x4,%rdi
25c3:	or     %rdx,%rdi
; __jhash_mix(a, b, c);
25c6:	xor    %rdi,%rcx
; a += k[0];
25c9:	add    %rax,%r13
; __jhash_final(a, b, c);
25cc:	xor    %r8,%rcx
25cf:	sub    %rsi,%rcx
25d2:	mov    %rcx,%rdi
25d5:	mov    $0xffe00000,%esi
25da:	and    %rsi,%rdi
; return (word << shift) | (word >> ((-shift) & 31));
25dd:	shr    $0x15,%rdi
25e1:	mov    %rcx,%rsi
25e4:	shl    $0xb,%rsi
25e8:	or     %rdi,%rsi
; __jhash_final(a, b, c);
25eb:	mov    %rcx,%rax
25ee:	xor    %r13,%rax
25f1:	sub    %rsi,%rax
25f4:	mov    $0xffffff80,%edi
25f9:	mov    %rax,%rsi
25fc:	and    %rdi,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
25ff:	shr    $0x7,%rsi
2603:	mov    %rax,%r13
2606:	shl    $0x19,%r13
260a:	or     %rsi,%r13
; __jhash_final(a, b, c);
260d:	mov    %rax,%rdx
2610:	xor    %r8,%rdx
2613:	sub    %r13,%rdx
2616:	mov    %rdx,%rsi
2619:	mov    $0xffff0000,%r8d
261f:	and    %r8,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
2622:	shr    $0x10,%rsi
2626:	mov    %rdx,%r8
2629:	shl    $0x10,%r8
262d:	or     %rsi,%r8
; __jhash_final(a, b, c);
2630:	mov    %rdx,%r14
2633:	xor    %rcx,%r14
2636:	sub    %r8,%r14
2639:	mov    %r14,%rsi
263c:	mov    $0xf0000000,%r13d
2642:	and    %r13,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
2645:	shr    $0x1c,%rsi
2649:	mov    %r14,%rcx
264c:	shl    $0x4,%rcx
2650:	or     %rsi,%rcx
; __jhash_final(a, b, c);
2653:	mov    %r14,%rsi
2656:	xor    %rax,%rsi
2659:	sub    %rcx,%rsi
265c:	mov    %rsi,%rcx
265f:	mov    $0xfffc0000,%r8d
2665:	and    %r8,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
2668:	shr    $0x12,%rcx
266c:	mov    %rsi,%r8
266f:	shl    $0xe,%r8
2673:	or     %rcx,%r8
; __jhash_final(a, b, c);
2676:	xor    %rdx,%rsi
2679:	sub    %r8,%rsi
267c:	mov    $0xffffff00,%edx
2681:	mov    %rsi,%rcx
2684:	and    %rdx,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
2687:	shr    $0x8,%rcx
268b:	mov    %rsi,%r8
268e:	shl    $0x18,%r8
2692:	or     %rcx,%r8
; __jhash_final(a, b, c);
2695:	xor    %r14,%rsi
; a += initval;
2698:	sub    %r8,%rsi
269b:	add    $0xffffffffe0adc0f7,%rsi
26a2:	mov    -0xb8(%rbp),%r14
; __jhash_final(a, b, c);
26a9:	xor    %r14,%rsi
26ac:	sub    %r15,%rsi
26af:	mov    %rsi,%rcx
26b2:	and    %rdi,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
26b5:	shr    $0x7,%rcx
26b9:	mov    %rsi,%rdi
26bc:	shl    $0x19,%rdi
26c0:	or     %rcx,%rdi
; __jhash_final(a, b, c);
26c3:	mov    %rsi,%rax
26c6:	mov    -0x98(%rbp),%rcx
26cd:	xor    %rcx,%rax
26d0:	sub    %rdi,%rax
26d3:	mov    %rax,%rdi
26d6:	mov    $0xffff0000,%ecx
26db:	and    %rcx,%rdi
; return (word << shift) | (word >> ((-shift) & 31));
26de:	shr    $0x10,%rdi
26e2:	mov    %rax,%r8
26e5:	shl    $0x10,%r8
26e9:	or     %rdi,%r8
; __jhash_final(a, b, c);
26ec:	mov    %rax,%rcx
26ef:	xor    %r14,%rcx
26f2:	sub    %r8,%rcx
26f5:	mov    %rcx,%rdi
26f8:	and    %r13,%rdi
; return (word << shift) | (word >> ((-shift) & 31));
26fb:	shr    $0x1c,%rdi
26ff:	mov    %rcx,%r8
2702:	shl    $0x4,%r8
2706:	or     %rdi,%r8
; __jhash_final(a, b, c);
2709:	mov    %rcx,%rdi
270c:	xor    %rsi,%rdi
270f:	sub    %r8,%rdi
2712:	mov    %rdi,%rsi
2715:	mov    $0xfffc0000,%r8d
271b:	and    %r8,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
271e:	shr    $0x12,%rsi
2722:	mov    %rdi,%r8
2725:	shl    $0xe,%r8
2729:	or     %rsi,%r8
; __jhash_final(a, b, c);
272c:	xor    %rax,%rdi
272f:	sub    %r8,%rdi
2732:	mov    %rdi,%rsi
2735:	and    %rdx,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
2738:	shr    $0x8,%rsi
273c:	mov    %rdi,%rdx
273f:	shl    $0x18,%rdx
2743:	or     %rsi,%rdx
; __jhash_final(a, b, c);
2746:	xor    %rcx,%rdi
2749:	sub    %rdx,%rdi
274c:	mov    %rdi,%rsi
274f:	shl    $0x20,%rsi
2753:	shr    $0x20,%rsi
; hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
2757:	push   %rax
2758:	push   %rdx
2759:	mov    $0x10001,%r11
2760:	mov    %rsi,%rax
2763:	xor    %edx,%edx
2765:	div    %r11
2768:	mov    %rax,%rsi
276b:	pop    %rdx
276c:	pop    %rax
276d:	imul   $0x10001,%rsi,%rsi
2774:	sub    %rsi,%rdi
; key = RING_SIZE * (vip_info->vip_num) + hash;
2777:	mov    -0xa0(%rbp),%rsi
277e:	mov    0x4(%rsi),%esi
; key = RING_SIZE * (vip_info->vip_num) + hash;
2781:	imul   $0x10001,%rsi,%rsi
; key = RING_SIZE * (vip_info->vip_num) + hash;
2788:	add    %rsi,%rdi
; key = RING_SIZE * (vip_info->vip_num) + hash;
278b:	mov    %edi,-0x4(%rbp)
278e:	mov    %rbp,%rsi
; 
2791:	add    $0xfffffffffffffffc,%rsi
; real_pos = bpf_map_lookup_elem(&ch_rings, &key);
2795:	movabs $0xffffc900221cc000,%rdi
279f:	add    $0x100,%rdi
27a6:	mov    0x0(%rsi),%eax
27a9:	cmp    $0x2000200,%rax
27b0:	jae    0xffffffffc01d4747
27b2:	shl    $0x3,%rax
27b6:	add    %rdi,%rax
27b9:	jmp    0xffffffffc01d4749
27bb:	xor    %eax,%eax
; if (!real_pos) {
27bd:	test   %rax,%rax
27c0:	je     0xffffffffc01d3463
; key = *real_pos;
27c6:	mov    0x0(%rax),%edi
; key = *real_pos;
27c9:	mov    %edi,-0x4(%rbp)
; if (key == 0) {
27cc:	test   %rdi,%rdi
27cf:	jne    0xffffffffc01d47b5
27d1:	mov    $0x209,%edi
; __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
27d6:	mov    %edi,-0x88(%rbp)
27dc:	mov    %rbp,%rsi
; 
27df:	add    $0xffffffffffffff78,%rsi
; bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
27e6:	movabs $0xffff8881a98d8000,%rdi
27f0:	add    $0x100,%rdi
27f7:	mov    0x0(%rsi),%eax
27fa:	cmp    $0x400,%rax
2801:	jae    0xffffffffc01d47a5
2803:	shl    $0x3,%rax
2807:	add    %rdi,%rax
280a:	mov    0x0(%rax),%rax
280e:	add    %gs:0xffffffffaa995028,%rax
2817:	jmp    0xffffffffc01d47a7
2819:	xor    %eax,%eax
; if (!ch_drop_stats) {
281b:	test   %rax,%rax
281e:	je     0xffffffffc01d3463
2824:	jmp    0xffffffffc01d57c2
; pckt->real_index = key;
2829:	mov    %edi,-0x10(%rbp)
282c:	mov    %rbp,%rsi
; 
282f:	add    $0xfffffffffffffffc,%rsi
; *real = bpf_map_lookup_elem(&reals, &key);
2833:	movabs $0xffffc90008d64000,%rdi
283d:	add    $0x100,%rdi
2844:	mov    0x0(%rsi),%eax
2847:	cmp    $0x1000,%rax
284e:	jae    0xffffffffc01d47e5
2850:	imul   $0x18,%rax,%rax
2854:	add    %rdi,%rax
2857:	jmp    0xffffffffc01d47e7
2859:	xor    %eax,%eax
285b:	mov    %rax,%r15
; if (!(*real)) {
285e:	test   %rax,%rax
2861:	jne    0xffffffffc01d4847
2863:	mov    $0x209,%edi
; __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
2868:	mov    %edi,-0x88(%rbp)
286e:	mov    %rbp,%rsi
; 
2871:	add    $0xffffffffffffff78,%rsi
; bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
2878:	movabs $0xffff8881a98d8000,%rdi
2882:	add    $0x100,%rdi
2889:	mov    0x0(%rsi),%eax
288c:	cmp    $0x400,%rax
2893:	jae    0xffffffffc01d4837
2895:	shl    $0x3,%rax
2899:	add    %rdi,%rax
289c:	mov    0x0(%rax),%rax
28a0:	add    %gs:0xffffffffaa995028,%rax
28a9:	jmp    0xffffffffc01d4839
28ab:	xor    %eax,%eax
; if (!ch_drop_stats) {
28ad:	test   %rax,%rax
28b0:	je     0xffffffffc01d3463
28b6:	jmp    0xffffffffc01d5864
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
28bb:	mov    -0xc8(%rbp),%rdi
28c2:	test   %rdi,%rdi
28c5:	je     0xffffffffc01d48ab
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
28c7:	mov    -0xa0(%rbp),%rdi
28ce:	mov    0x0(%rdi),%edi
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
28d1:	and    $0x2,%rdi
28d5:	shr    %rdi
28d8:	mov    -0xd0(%rbp),%rsi
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
28df:	or     %rdi,%rsi
28e2:	test   %rsi,%rsi
28e5:	jne    0xffffffffc01d48ab
; if (pckt->flow.proto == IPPROTO_UDP) {
28e7:	movzbq -0x14(%rbp),%rdi
; if (pckt->flow.proto == IPPROTO_UDP) {
28ec:	cmp    $0x11,%rdi
28f0:	jne    0xffffffffc01d4889
; new_dst_lru.atime = cur_time;
28f2:	mov    -0xd8(%rbp),%rdi
28f9:	mov    %rdi,-0x78(%rbp)
; new_dst_lru.pos = key;
28fd:	mov    -0x4(%rbp),%edi
; new_dst_lru.pos = key;
2900:	mov    %edi,-0x80(%rbp)
2903:	mov    %rbp,%rsi
; new_dst_lru.pos = key;
2906:	add    $0xffffffffffffffc8,%rsi
290a:	mov    %rbp,%rdx
290d:	add    $0xffffffffffffff80,%rdx
; bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
2911:	mov    -0xc8(%rbp),%rdi
2918:	xor    %ecx,%ecx
291a:	call   0xffffffffa4c9c9c0
291f:	xor    %r13d,%r13d
; __u32 vip_miss_stats_key = 0;
2922:	mov    %r13d,-0x80(%rbp)
2926:	mov    %rbp,%rsi
; 
2929:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&vip_miss_stats, &vip_miss_stats_key);
292d:	movabs $0xffff88819b01f800,%rdi
2937:	add    $0x100,%rdi
293e:	mov    0x0(%rsi),%eax
2941:	cmp    $0x1,%rax
2945:	jae    0xffffffffc01d48dc
2947:	imul   $0x18,%rax,%rax
294b:	add    %rdi,%rax
294e:	jmp    0xffffffffc01d48de
2950:	xor    %eax,%eax
; if (!lru_miss_stat_vip) {
2952:	test   %rax,%rax
2955:	je     0xffffffffc01d3463
; (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
295b:	mov    0x0(%rax),%edi
; (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
295e:	mov    -0x50(%rbp),%esi
; (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
2961:	cmp    %rsi,%rdi
2964:	jne    0xffffffffc01d491c
; lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
2966:	mov    0x4(%rax),%edi
; lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
2969:	mov    -0x4c(%rbp),%esi
; lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
296c:	cmp    %rsi,%rdi
296f:	jne    0xffffffffc01d491c
; lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
2971:	mov    0x8(%rax),%edi
; lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
2974:	mov    -0x48(%rbp),%esi
; lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
2977:	cmp    %rsi,%rdi
297a:	jne    0xffffffffc01d491c
; lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
297c:	mov    0xc(%rax),%edi
297f:	mov    $0x1,%r13d
; lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
2985:	mov    -0x44(%rbp),%esi
; lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
2988:	cmp    %rsi,%rdi
298b:	je     0xffffffffc01d491c
298d:	xor    %r13d,%r13d
; bool vip_match = address_match && port_match && proto_match;
2990:	movzwq -0x40(%rbp),%rsi
2995:	movzbq -0x3e(%rbp),%rdi
; bool proto_match = lru_miss_stat_vip->proto = vip->proto;
299a:	mov    %dil,0x12(%rax)
; bool vip_match = address_match && port_match && proto_match;
299e:	and    $0x1,%r13
29a2:	test   %r13,%r13
29a5:	je     0xffffffffc01d499d
29a7:	movzwq 0x10(%rax),%rdx
29ac:	cmp    %rsi,%rdx
29af:	jne    0xffffffffc01d499d
29b1:	test   %rdi,%rdi
29b4:	je     0xffffffffc01d499d
; __u32 lru_stats_key = pckt->real_index;
29b6:	mov    -0x10(%rbp),%edi
; __u32 lru_stats_key = pckt->real_index;
29b9:	mov    %edi,-0x88(%rbp)
29bf:	mov    %rbp,%rsi
; __u32 lru_stats_key = pckt->real_index;
29c2:	add    $0xffffffffffffff78,%rsi
; __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
29c9:	movabs $0xffffc90008d88000,%rdi
29d3:	add    $0x100,%rdi
29da:	mov    0x0(%rsi),%eax
29dd:	cmp    $0x1000,%rax
29e4:	jae    0xffffffffc01d4988
29e6:	shl    $0x3,%rax
29ea:	add    %rdi,%rax
29ed:	mov    0x0(%rax),%rax
29f1:	add    %gs:0xffffffffaa995028,%rax
29fa:	jmp    0xffffffffc01d498a
29fc:	xor    %eax,%eax
; if (!lru_miss_stat) {
29fe:	test   %rax,%rax
2a01:	je     0xffffffffc01d3463
; *lru_miss_stat += 1;
2a07:	mov    0x0(%rax),%edi
2a0a:	add    $0x1,%rdi
2a0e:	mov    %edi,0x0(%rax)
2a11:	mov    -0xa8(%rbp),%rsi
; data_stats->v2 += 1;
2a18:	mov    0x8(%rsi),%rdi
2a1c:	add    $0x1,%rdi
2a20:	mov    %rdi,0x8(%rsi)
2a24:	jmp    0xffffffffc01d3fc3
; __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
2a29:	mov    -0x38(%rbp),%edi
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
2a2c:	mov    %rdi,-0x90(%rbp)
2a33:	mov    %rbx,%rdi
2a36:	mov    $0xffffffec,%esi
2a3b:	call   0xffffffffa6e35c20
2a40:	shl    $0x20,%rax
2a44:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
2a48:	test   %rax,%rax
2a4b:	jne    0xffffffffc01d3469
; data = (void*)(long)xdp->data;
2a51:	mov    0x0(%rbx),%rdi
; data_end = (void*)(long)xdp->data_end;
2a55:	mov    0x8(%rbx),%rsi
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2a59:	mov    %rdi,%rdx
2a5c:	add    $0xe,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2a60:	cmp    %rsi,%rdx
2a63:	ja     0xffffffffc01d3469
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2a69:	mov    %rdi,%rdx
2a6c:	add    $0x22,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2a70:	cmp    %rsi,%rdx
2a73:	ja     0xffffffffc01d3469
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2a79:	cmp    %rsi,%rdx
2a7c:	ja     0xffffffffc01d3469
2a82:	mov    -0xb0(%rbp),%rbx
2a89:	bswap  %ebx
2a8b:	mov    $0xffff0000,%esi
; 
2a90:	and    %rsi,%rbx
2a93:	mov    -0x90(%rbp),%rsi
2a9a:	and    $0xffffffffffff0000,%rsi
2aa1:	xor    %rsi,%rbx
2aa4:	mov    %rbx,%rsi
2aa7:	or     $0x10ac,%rsi
2aae:	mov    %rdi,%rdx
2ab1:	add    $0x14,%rdx
; memcpy(new_eth->h_dest, cval->mac, 6);
2ab5:	movzbq 0x5(%r15),%rcx
2aba:	mov    %cl,0x5(%rdi)
2abd:	movzbq 0x4(%r15),%rcx
2ac2:	mov    %cl,0x4(%rdi)
2ac5:	movzbq 0x3(%r15),%rcx
2aca:	mov    %cl,0x3(%rdi)
2acd:	movzbq 0x2(%r15),%rcx
2ad2:	mov    %cl,0x2(%rdi)
2ad5:	movzbq 0x1(%r15),%rcx
2ada:	mov    %cl,0x1(%rdi)
2add:	movzbq 0x0(%r15),%rcx
2ae2:	mov    %cl,0x0(%rdi)
; memcpy(new_eth->h_source, old_eth->h_dest, 6);
2ae5:	movzbq 0x2(%rdx),%rcx
2aea:	mov    %cl,0x8(%rdi)
2aed:	movzbq 0x3(%rdx),%rcx
2af2:	mov    %cl,0x9(%rdi)
2af5:	movzbq 0x0(%rdx),%rcx
2afa:	mov    %cl,0x6(%rdi)
2afd:	movzbq 0x1(%rdx),%rcx
2b02:	mov    %cl,0x7(%rdi)
2b05:	movzbq 0x4(%rdx),%rcx
2b0a:	mov    %cl,0xa(%rdi)
2b0d:	movzbq 0x5(%rdx),%rdx
2b12:	mov    %dl,0xb(%rdi)
2b15:	mov    $0x8,%edx
; new_eth->h_proto = BE_ETH_P_IP;
2b1a:	mov    %dl,0xc(%rdi)
2b1d:	xor    %edx,%edx
2b1f:	mov    %dl,0xd(%rdi)
; create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
2b22:	mov    -0x98(%rbp),%rcx
2b29:	mov    0x0(%rcx),%ecx
; create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
2b2c:	movzbq -0xb(%rbp),%r8
2b31:	mov    $0x45,%eax
; iph->ihl = 5;
2b36:	mov    %al,0xe(%rdi)
; iph->tos = tos;
2b39:	mov    %r8b,0xf(%rdi)
; *csum += *next_iph_u16++;
2b3d:	shl    $0x20,%rbx
2b41:	shr    $0x20,%rbx
2b45:	shr    $0x10,%rbx
2b49:	mov    %rcx,%r8
2b4c:	and    $0xffff,%r8
; *csum += *next_iph_u16++;
2b53:	add    %r8,%rbx
; iph->id = 0;
2b56:	mov    %edx,0x12(%rdi)
2b59:	mov    $0x440,%edx
; iph->ttl = DEFAULT_TTL;
2b5e:	mov    %dx,0x16(%rdi)
; iph->saddr = saddr;
2b62:	mov    %esi,0x1a(%rdi)
; iph->daddr = daddr;
2b65:	mov    %ecx,0x1e(%rdi)
; *csum += *next_iph_u16++;
2b68:	shr    $0x10,%rcx
; *csum += *next_iph_u16++;
2b6c:	add    %rcx,%rbx
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
2b6f:	add    $0x14,%r13
2b73:	ror    $0x8,%r13w
2b78:	movzwl %r13w,%r13d
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
2b7c:	mov    %r13w,0x10(%rdi)
; *csum += *next_iph_u16++;
2b81:	add    %r13,%rbx
; *csum += *next_iph_u16++;
2b84:	movzwq 0xe(%rdi),%rsi
; *csum += *next_iph_u16++;
2b89:	add    %rsi,%rbx
; *csum += *next_iph_u16++;
2b8c:	movzwq 0x16(%rdi),%rsi
; *csum += *next_iph_u16++;
2b91:	add    %rsi,%rbx
2b94:	add    $0x10ac,%rbx
2b9b:	mov    %rbx,%rdx
; if (csum >> 16)
2b9e:	mov    %rbx,%rsi
2ba1:	shr    $0x10,%rsi
; if (csum >> 16)
2ba5:	test   %rsi,%rsi
2ba8:	je     0xffffffffc01d4b40
2baa:	and    $0xffff,%rdx
2bb1:	add    %rsi,%rdx
; if (csum >> 16)
2bb4:	mov    %rdx,%rsi
2bb7:	shr    $0x10,%rsi
; if (csum >> 16)
2bbb:	test   %rsi,%rsi
2bbe:	je     0xffffffffc01d4b56
2bc0:	and    $0xffff,%rdx
2bc7:	add    %rsi,%rdx
; if (csum >> 16)
2bca:	mov    %rdx,%rsi
2bcd:	shr    $0x10,%rsi
; if (csum >> 16)
2bd1:	test   %rsi,%rsi
2bd4:	je     0xffffffffc01d4b6c
2bd6:	and    $0xffff,%rdx
2bdd:	add    %rsi,%rdx
; 
2be0:	mov    %rdx,%rsi
2be3:	shr    $0x10,%rsi
2be7:	add    %rdx,%rsi
2bea:	xor    $0xffffffffffffffff,%rsi
2bee:	mov    %si,0x18(%rdi)
2bf2:	jmp    0xffffffffc01d2455
; if (quic_data + sizeof(struct quic_short_header) > data_end) {
2bf7:	mov    %r15,%rsi
2bfa:	add    $0x9,%rsi
2bfe:	mov    %rdi,%r15
; if (quic_data + sizeof(struct quic_short_header) > data_end) {
2c01:	cmp    %r13,%rsi
2c04:	ja     0xffffffffc01d3ca7
2c0a:	mov    %rax,%r14
2c0d:	mov    %rcx,-0xc8(%rbp)
; __u8 connIdVersion = (connId[0] >> 6);
2c14:	movzbq 0x0(%r15),%rdi
; __u8 connIdVersion = (connId[0] >> 6);
2c19:	mov    %rdi,%rsi
2c1c:	shr    $0x6,%rsi
; if (connIdVersion == QUIC_CONNID_VERSION_V1) {
2c20:	cmp    $0x3,%rsi
2c24:	je     0xffffffffc01d4cc6
2c2a:	cmp    $0x2,%rsi
2c2e:	je     0xffffffffc01d4cf3
2c34:	mov    -0xc8(%rbp),%rcx
2c3b:	mov    %r14,%rax
2c3e:	cmp    $0x1,%rsi
2c42:	jne    0xffffffffc01d3ca7
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2c48:	and    $0x3f,%rdi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2c4c:	shl    $0xa,%rdi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2c50:	movzbq 0x1(%r15),%r13
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2c55:	shl    $0x2,%r13
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2c59:	or     %rdi,%r13
2c5c:	mov    $0x38,%edi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2c61:	movzbq 0x2(%r15),%rsi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2c66:	shr    $0x6,%rsi
2c6a:	jmp    0xffffffffc01d4d12
; if (quic_data + sizeof(struct quic_short_header) > data_end) {
2c6f:	mov    %r15,%rsi
2c72:	add    $0x9,%rsi
2c76:	mov    %rdi,%r15
; if (quic_data + sizeof(struct quic_short_header) > data_end) {
2c79:	cmp    %r13,%rsi
2c7c:	ja     0xffffffffc01d4fda
; __u8 connIdVersion = (connId[0] >> 6);
2c82:	movzbq 0x0(%r15),%rdi
; __u8 connIdVersion = (connId[0] >> 6);
2c87:	mov    %rdi,%rsi
2c8a:	shr    $0x6,%rsi
; if (connIdVersion == QUIC_CONNID_VERSION_V1) {
2c8e:	cmp    $0x3,%rsi
2c92:	je     0xffffffffc01d4eab
2c98:	cmp    $0x2,%rsi
2c9c:	je     0xffffffffc01d4ed8
2ca2:	cmp    $0x1,%rsi
2ca6:	jne    0xffffffffc01d4fda
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2cac:	and    $0x3f,%rdi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2cb0:	shl    $0xa,%rdi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2cb4:	movzbq 0x1(%r15),%r13
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2cb9:	shl    $0x2,%r13
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2cbd:	or     %rdi,%r13
2cc0:	mov    $0x38,%edi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2cc5:	movzbq 0x2(%r15),%rsi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
2cca:	shr    $0x6,%rsi
2cce:	jmp    0xffffffffc01d4ef7
; quic_packets_stats->cid_initial += 1;
2cd3:	mov    0x8(%rax),%rdi
2cd7:	add    $0x1,%rdi
2cdb:	mov    %rdi,0x8(%rax)
; vip_num, /* new conn */ true, /* mismatch in lru */ false);
2cdf:	mov    -0x54(%rbp),%edi
2ce2:	mov    %edi,-0x80(%rbp)
2ce5:	mov    %rbp,%rsi
; 
2ce8:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&server_id_stats, &vip_num);
2cec:	movabs $0xffff8881aa428000,%rdi
2cf6:	add    $0x100,%rdi
2cfd:	mov    0x0(%rsi),%eax
2d00:	cmp    $0x200,%rax
2d07:	jae    0xffffffffc01d4cab
2d09:	shl    $0x3,%rax
2d0d:	add    %rdi,%rax
2d10:	mov    0x0(%rax),%rax
2d14:	add    %gs:0xffffffffaa995028,%rax
2d1d:	jmp    0xffffffffc01d4cad
2d1f:	xor    %eax,%eax
; if (!per_vip_stats) {
2d21:	test   %rax,%rax
2d24:	je     0xffffffffc01d4cbe
; per_vip_stats->v1 += 1;
2d26:	mov    0x0(%rax),%rdi
2d2a:	add    $0x1,%rdi
2d2e:	mov    %rdi,0x0(%rax)
2d32:	mov    %r14,%rcx
2d35:	jmp    0xffffffffc01d3cb3
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2d3a:	movzbq 0x1(%r15),%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2d3f:	shl    $0x18,%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2d43:	movzbq 0x2(%r15),%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2d48:	shl    $0x10,%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2d4c:	or     %rdi,%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2d4f:	movzbq 0x3(%r15),%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2d54:	shl    $0x8,%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2d58:	or     %rdi,%r13
2d5b:	mov    $0x48,%edi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2d60:	movzbq 0x4(%r15),%rsi
2d65:	jmp    0xffffffffc01d4d12
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2d67:	movzbq 0x1(%r15),%rdi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2d6c:	shl    $0x10,%rdi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2d70:	movzbq 0x2(%r15),%r13
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2d75:	shl    $0x8,%r13
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2d79:	or     %rdi,%r13
2d7c:	mov    $0x40,%edi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2d81:	movzbq 0x3(%r15),%rsi
; 
2d86:	and    $0xff,%rsi
2d8d:	or     %rsi,%r13
; struct quic_parse_result qpr = parse_quic(data, data_end, is_ipv6, &pckt);
2d90:	mov    %r13,%rsi
2d93:	shl    $0x20,%rsi
2d97:	sar    $0x20,%rsi
2d9b:	mov    $0x1,%edx
2da0:	mov    -0xc8(%rbp),%rcx
2da7:	mov    %r14,%rax
; if (qpr.server_id > 0) {
2daa:	cmp    %rsi,%rdx
2dad:	jg     0xffffffffc01d3ca7
; 
2db3:	mov    %rax,%rsi
2db6:	add    %rdi,%rsi
2db9:	mov    0x0(%rsi),%rdi
2dbd:	add    $0x1,%rdi
2dc1:	mov    %rdi,0x0(%rsi)
; __u32 key = qpr.server_id;
2dc5:	mov    %r13d,-0x4(%rbp)
2dc9:	mov    %rbp,%rsi
; 
2dcc:	add    $0xfffffffffffffffc,%rsi
; __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
2dd0:	movabs $0xffffc90008d92000,%rdi
2dda:	add    $0x100,%rdi
2de1:	mov    0x0(%rsi),%eax
2de4:	cmp    $0xfffffe,%rax
2deb:	jae    0xffffffffc01d4d82
2ded:	shl    $0x3,%rax
2df1:	add    %rdi,%rax
2df4:	jmp    0xffffffffc01d4d84
2df6:	xor    %eax,%eax
; if (real_pos) {
2df8:	test   %rax,%rax
2dfb:	je     0xffffffffc01d4dd3
; key = *real_pos;
2dfd:	mov    0x0(%rax),%edi
; key = *real_pos;
2e00:	mov    %edi,-0x4(%rbp)
; if (key == 0) {
2e03:	test   %rdi,%rdi
2e06:	je     0xffffffffc01d4dd3
; pckt.real_index = key;
2e08:	mov    %edi,-0x10(%rbp)
2e0b:	mov    %rbp,%rsi
2e0e:	add    $0xfffffffffffffffc,%rsi
; dst = bpf_map_lookup_elem(&reals, &key);
2e12:	movabs $0xffffc90008d64000,%rdi
2e1c:	add    $0x100,%rdi
2e23:	mov    0x0(%rsi),%eax
2e26:	cmp    $0x1000,%rax
2e2d:	jae    0xffffffffc01d4dc4
2e2f:	imul   $0x18,%rax,%rax
2e33:	add    %rdi,%rax
2e36:	jmp    0xffffffffc01d4dc6
2e38:	xor    %eax,%eax
2e3a:	mov    %rax,%r15
; if (!dst) {
2e3d:	test   %rax,%rax
2e40:	jne    0xffffffffc01d4e03
2e42:	jmp    0xffffffffc01d4fb1
; 
2e47:	shl    $0x20,%r13
2e4b:	sar    $0x20,%r13
2e4f:	mov    %r13,0x18(%r14)
2e53:	mov    0x10(%r14),%rdi
2e57:	add    $0x1,%rdi
2e5b:	mov    %rdi,0x10(%r14)
2e5f:	mov    0x0(%r14),%rdi
2e63:	add    $0x1,%rdi
2e67:	mov    %rdi,0x0(%r14)
2e6b:	mov    -0xc8(%rbp),%rcx
2e72:	jmp    0xffffffffc01d3cb3
2e77:	mov    %rbp,%rsi
; 
2e7a:	add    $0xffffffffffffffc8,%rsi
; struct real_pos_lru* dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);
2e7e:	mov    -0xc8(%rbp),%rdi
2e85:	call   0xffffffffa4c9c930
; if (dst_lru) {
2e8a:	test   %rax,%rax
2e8d:	je     0xffffffffc01d5b5d
; if (dst_lru->pos == pckt->real_index) {
2e93:	mov    0x0(%rax),%esi
; if (dst_lru->pos == pckt->real_index) {
2e96:	mov    -0x10(%rbp),%edi
; if (dst_lru->pos == pckt->real_index) {
2e99:	cmp    %rdi,%rsi
2e9c:	je     0xffffffffc01d4e2f
2e9e:	jmp    0xffffffffc01d5c08
2ea3:	mov    %r14,%rsi
; quic_packets_stats->dst_match_in_lru += 1;
2ea6:	mov    0x50(%rsi),%rdi
2eaa:	add    $0x1,%rdi
2eae:	mov    %rdi,0x50(%rsi)
2eb2:	jmp    0xffffffffc01d5cd4
; quic_packets_stats->cid_initial += 1;
2eb7:	mov    0x8(%r14),%rdi
2ebb:	add    $0x1,%rdi
2ebf:	mov    %rdi,0x8(%r14)
; vip_num, /* new conn */ true, /* mismatch in lru */ false);
2ec3:	mov    -0x54(%rbp),%edi
2ec6:	mov    %edi,-0x80(%rbp)
2ec9:	mov    %rbp,%rsi
; 
2ecc:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&server_id_stats, &vip_num);
2ed0:	movabs $0xffff8881aa428000,%rdi
2eda:	add    $0x100,%rdi
2ee1:	mov    0x0(%rsi),%eax
2ee4:	cmp    $0x200,%rax
2eeb:	jae    0xffffffffc01d4e8f
2eed:	shl    $0x3,%rax
2ef1:	add    %rdi,%rax
2ef4:	mov    0x0(%rax),%rax
2ef8:	add    %gs:0xffffffffaa995028,%rax
2f01:	jmp    0xffffffffc01d4e91
2f03:	xor    %eax,%eax
; if (!per_vip_stats) {
2f05:	test   %rax,%rax
2f08:	je     0xffffffffc01d4fe6
; per_vip_stats->v1 += 1;
2f0e:	mov    0x0(%rax),%rdi
2f12:	add    $0x1,%rdi
2f16:	mov    %rdi,0x0(%rax)
2f1a:	jmp    0xffffffffc01d4fe6
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2f1f:	movzbq 0x1(%r15),%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2f24:	shl    $0x18,%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2f28:	movzbq 0x2(%r15),%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2f2d:	shl    $0x10,%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2f31:	or     %rdi,%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2f34:	movzbq 0x3(%r15),%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2f39:	shl    $0x8,%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2f3d:	or     %rdi,%r13
2f40:	mov    $0x48,%edi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2f45:	movzbq 0x4(%r15),%rsi
2f4a:	jmp    0xffffffffc01d4ef7
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2f4c:	movzbq 0x1(%r15),%rdi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2f51:	shl    $0x10,%rdi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2f55:	movzbq 0x2(%r15),%r13
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2f5a:	shl    $0x8,%r13
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2f5e:	or     %rdi,%r13
2f61:	mov    $0x40,%edi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2f66:	movzbq 0x3(%r15),%rsi
; 
2f6b:	and    $0xff,%rsi
2f72:	or     %rsi,%r13
; struct quic_parse_result qpr = parse_quic(data, data_end, is_ipv6, &pckt);
2f75:	mov    %r13,%rsi
2f78:	shl    $0x20,%rsi
2f7c:	sar    $0x20,%rsi
2f80:	mov    $0x1,%edx
; if (qpr.server_id > 0) {
2f85:	cmp    %rsi,%rdx
2f88:	jg     0xffffffffc01d4fda
; 
2f8e:	mov    %r14,%rsi
2f91:	add    %rdi,%rsi
2f94:	mov    0x0(%rsi),%rdi
2f98:	add    $0x1,%rdi
2f9c:	mov    %rdi,0x0(%rsi)
; __u32 key = qpr.server_id;
2fa0:	mov    %r13d,-0x4(%rbp)
2fa4:	mov    %rbp,%rsi
; 
2fa7:	add    $0xfffffffffffffffc,%rsi
; __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
2fab:	movabs $0xffffc90008d92000,%rdi
2fb5:	add    $0x100,%rdi
2fbc:	mov    0x0(%rsi),%eax
2fbf:	cmp    $0xfffffe,%rax
2fc6:	jae    0xffffffffc01d4f5d
2fc8:	shl    $0x3,%rax
2fcc:	add    %rdi,%rax
2fcf:	jmp    0xffffffffc01d4f5f
2fd1:	xor    %eax,%eax
; if (real_pos) {
2fd3:	test   %rax,%rax
2fd6:	je     0xffffffffc01d4fc2
; key = *real_pos;
2fd8:	mov    0x0(%rax),%edi
; key = *real_pos;
2fdb:	mov    %edi,-0x4(%rbp)
; if (key == 0) {
2fde:	test   %rdi,%rdi
2fe1:	je     0xffffffffc01d4fc2
; pckt.real_index = key;
2fe3:	mov    %edi,-0x10(%rbp)
2fe6:	mov    %rbp,%rsi
2fe9:	add    $0xfffffffffffffffc,%rsi
; dst = bpf_map_lookup_elem(&reals, &key);
2fed:	movabs $0xffffc90008d64000,%rdi
2ff7:	add    $0x100,%rdi
2ffe:	mov    0x0(%rsi),%eax
3001:	cmp    $0x1000,%rax
3008:	jae    0xffffffffc01d4f9f
300a:	imul   $0x18,%rax,%rax
300e:	add    %rdi,%rax
3011:	jmp    0xffffffffc01d4fa1
3013:	xor    %eax,%eax
3015:	mov    %rax,-0xb8(%rbp)
; if (!dst) {
301c:	test   %rax,%rax
301f:	jne    0xffffffffc01d5c6f
; 
3025:	mov    0x28(%r14),%rdi
3029:	add    $0x1,%rdi
302d:	mov    %rdi,0x28(%r14)
3031:	jmp    0xffffffffc01d3463
; 
3036:	shl    $0x20,%r13
303a:	sar    $0x20,%r13
303e:	mov    %r13,0x18(%r14)
3042:	mov    0x10(%r14),%rdi
3046:	add    $0x1,%rdi
304a:	mov    %rdi,0x10(%r14)
; 
304e:	mov    0x0(%r14),%rdi
3052:	add    $0x1,%rdi
3056:	mov    %rdi,0x0(%r14)
305a:	mov    -0xa0(%rbp),%rsi
3061:	xor    %r13d,%r13d
; original_sport = pckt.flow.port16[0];
3064:	movzwq -0x18(%rbp),%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
3069:	mov    %rdi,-0xc0(%rbp)
3070:	movzbq -0xc(%rbp),%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
3075:	and    $0x2,%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
3079:	test   %rdi,%rdi
307c:	jne    0xffffffffc01d50ac
; !(vip_info->flags & F_LRU_BYPASS)) {
3082:	mov    0x0(%rsi),%edi
; !(vip_info->flags & F_LRU_BYPASS)) {
3085:	and    $0x2,%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
3089:	test   %rdi,%rdi
308c:	jne    0xffffffffc01d50ac
3092:	mov    %rbp,%rsi
; 
3095:	add    $0xffffffffffffffc8,%rsi
; dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);
3099:	mov    -0xa8(%rbp),%rdi
30a0:	call   0xffffffffa4c9c930
30a5:	mov    %rax,%r14
30a8:	xor    %r13d,%r13d
; if (!dst_lru) {
30ab:	test   %r14,%r14
30ae:	je     0xffffffffc01d50a5
; if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
30b0:	movzbq -0x14(%rbp),%rdi
; if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
30b5:	cmp    $0x11,%rdi
30b9:	jne    0xffffffffc01d5069
; cur_time = bpf_ktime_get_ns();
30bb:	call   0xffffffffa4c9d630
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
30c0:	mov    0x8(%r14),%rdi
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
30c4:	mov    %rax,%rsi
30c7:	sub    %rdi,%rsi
30ca:	movabs $0x6fc23ac00,%rdi
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
30d4:	cmp    %rdi,%rsi
30d7:	ja     0xffffffffc01d50a5
; dst_lru->atime = cur_time;
30d9:	mov    %rax,0x8(%r14)
; key = dst_lru->pos;
30dd:	mov    0x0(%r14),%edi
; pckt->real_index = key;
30e1:	mov    %edi,-0x10(%rbp)
; key = dst_lru->pos;
30e4:	mov    %edi,-0x80(%rbp)
30e7:	mov    %rbp,%rsi
; key = dst_lru->pos;
30ea:	add    $0xffffffffffffff80,%rsi
; *real = bpf_map_lookup_elem(&reals, &key);
30ee:	movabs $0xffffc90008d64000,%rdi
30f8:	add    $0x100,%rdi
30ff:	mov    0x0(%rsi),%eax
3102:	cmp    $0x1000,%rax
3109:	jae    0xffffffffc01d50a0
310b:	imul   $0x18,%rax,%rax
310f:	add    %rdi,%rax
3112:	jmp    0xffffffffc01d50a2
3114:	xor    %eax,%eax
3116:	mov    %rax,%r13
3119:	mov    -0xa0(%rbp),%rsi
; if (dst && pckt->flow.proto == IPPROTO_UDP &&
3120:	movzbq -0x14(%rbp),%rdi
; if (dst && pckt->flow.proto == IPPROTO_UDP &&
3125:	cmp    $0x11,%rdi
3129:	jne    0xffffffffc01d5209
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
312f:	mov    0x0(%rsi),%edi
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
3132:	and    $0x200,%rdi
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
3139:	test   %rdi,%rdi
313c:	je     0xffffffffc01d5209
3142:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
3147:	mov    %edi,-0x80(%rbp)
314a:	mov    %rbp,%rsi
; 
314d:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
3151:	movabs $0xffff8881a98d8000,%rdi
315b:	add    $0x100,%rdi
3162:	mov    0x0(%rsi),%eax
3165:	cmp    $0x400,%rax
316c:	jae    0xffffffffc01d5110
316e:	shl    $0x3,%rax
3172:	add    %rdi,%rax
3175:	mov    0x0(%rax),%rax
3179:	add    %gs:0xffffffffaa995028,%rax
3182:	jmp    0xffffffffc01d5112
3184:	xor    %eax,%eax
3186:	mov    %rax,%r14
; if (!conn_rate_stats) {
3189:	test   %r14,%r14
318c:	je     0xffffffffc01d5209
; *cur_time = bpf_ktime_get_ns();
3192:	call   0xffffffffa4c9d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
3197:	mov    0x8(%r14),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
319b:	mov    %rax,%rsi
319e:	sub    %rdi,%rsi
31a1:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
31a6:	cmp    %rsi,%rdi
31a9:	ja     0xffffffffc01d51ef
; conn_rate_stats->v2 = *cur_time;
31af:	mov    %rax,0x8(%r14)
31b3:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
31b8:	mov    %rdi,0x0(%r14)
31bc:	mov    %rbp,%rsi
; void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
31bf:	add    $0xffffffffffffffb0,%rsi
31c3:	movabs $0xffff8881a993b800,%rdi
31cd:	call   0xffffffffa4cbb9b0
31d2:	test   %rax,%rax
31d5:	je     0xffffffffc01d516b
31d7:	add    $0x48,%rax
31db:	mov    0x0(%rax),%rax
; if (down_reals_map) {
31df:	test   %rax,%rax
31e2:	je     0xffffffffc01d5209
; void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
31e8:	mov    %rbp,%rsi
31eb:	add    $0xfffffffffffffff0,%rsi
; void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
31ef:	mov    %rax,%rdi
31f2:	call   0xffffffffa4cbb9b0
31f7:	test   %rax,%rax
31fa:	je     0xffffffffc01d518c
31fc:	add    $0x38,%rax
; if (down_real) {
3200:	test   %rax,%rax
3203:	je     0xffffffffc01d5209
3205:	mov    $0x20f,%edi
; __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
320a:	mov    %edi,-0x80(%rbp)
320d:	mov    %rbp,%rsi
; 
3210:	add    $0xffffffffffffff80,%rsi
; struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
3214:	movabs $0xffff8881a98d8000,%rdi
321e:	add    $0x100,%rdi
3225:	mov    0x0(%rsi),%eax
3228:	cmp    $0x400,%rax
322f:	jae    0xffffffffc01d51d3
3231:	shl    $0x3,%rax
3235:	add    %rdi,%rax
3238:	mov    0x0(%rax),%rax
323c:	add    %gs:0xffffffffaa995028,%rax
3245:	jmp    0xffffffffc01d51d5
3247:	xor    %eax,%eax
; if (stats_data) {
3249:	test   %rax,%rax
324c:	je     0xffffffffc01d5484
; stats_data->v1 += 1;
3252:	mov    0x0(%rax),%rdi
3256:	add    $0x1,%rdi
325a:	mov    %rdi,0x0(%rax)
325e:	jmp    0xffffffffc01d5484
; conn_rate_stats->v1 += 1;
3263:	mov    0x0(%r14),%rdi
3267:	add    $0x1,%rdi
326b:	mov    %rdi,0x0(%r14)
326f:	mov    $0x1e849,%esi
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
3274:	cmp    %rdi,%rsi
3277:	ja     0xffffffffc01d5148
327d:	mov    %r13,-0xb8(%rbp)
; if (!dst) {
3284:	test   %r13,%r13
3287:	jne    0xffffffffc01d521a
3289:	jmp    0xffffffffc01d5484
328e:	mov    %rbp,%rsi
; 
3291:	add    $0xffffffffffffffa8,%rsi
; cval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos);
3295:	movabs $0xffff88819b01f000,%rdi
329f:	add    $0x100,%rdi
32a6:	mov    0x0(%rsi),%eax
32a9:	cmp    $0x10,%rax
32ad:	jae    0xffffffffc01d5244
32af:	shl    $0x3,%rax
32b3:	add    %rdi,%rax
32b6:	jmp    0xffffffffc01d5246
32b8:	xor    %eax,%eax
32ba:	mov    %rax,%r15
32bd:	mov    $0x1,%r14d
; if (!cval) {
32c3:	test   %r15,%r15
32c6:	je     0xffffffffc01d3469
32cc:	mov    %rbp,%rsi
; 
32cf:	add    $0xffffffffffffffac,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &vip_num);
32d3:	movabs $0xffff8881a98d8000,%rdi
32dd:	add    $0x100,%rdi
32e4:	mov    0x0(%rsi),%eax
32e7:	cmp    $0x400,%rax
32ee:	jae    0xffffffffc01d5292
32f0:	shl    $0x3,%rax
32f4:	add    %rdi,%rax
32f7:	mov    0x0(%rax),%rax
32fb:	add    %gs:0xffffffffaa995028,%rax
3304:	jmp    0xffffffffc01d5294
3306:	xor    %eax,%eax
; if (!data_stats) {
3308:	test   %rax,%rax
330b:	je     0xffffffffc01d3469
3311:	mov    -0x90(%rbp),%r13
3318:	ror    $0x8,%r13w
331d:	movzwl %r13w,%r13d
; data_stats->v1 += 1;
3321:	mov    0x0(%rax),%rdi
3325:	add    $0x1,%rdi
3329:	mov    %rdi,0x0(%rax)
; data_stats->v2 += pkt_bytes;
332d:	mov    0x8(%rax),%rdi
3331:	add    %r13,%rdi
3334:	mov    %rdi,0x8(%rax)
; data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
3338:	mov    %rbp,%rsi
333b:	add    $0xfffffffffffffff0,%rsi
; data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
333f:	movabs $0xffffc90008d7e000,%rdi
3349:	add    $0x100,%rdi
3350:	mov    0x0(%rsi),%eax
3353:	cmp    $0x1000,%rax
335a:	jae    0xffffffffc01d52fe
335c:	shl    $0x3,%rax
3360:	add    %rdi,%rax
3363:	mov    0x0(%rax),%rax
3367:	add    %gs:0xffffffffaa995028,%rax
3370:	jmp    0xffffffffc01d5300
3372:	xor    %eax,%eax
; if (!data_stats) {
3374:	test   %rax,%rax
3377:	je     0xffffffffc01d3469
; data_stats->v1 += 1;
337d:	mov    0x0(%rax),%rdi
3381:	add    $0x1,%rdi
3385:	mov    %rdi,0x0(%rax)
; data_stats->v2 += pkt_bytes;
3389:	mov    0x8(%rax),%rdi
338d:	add    %r13,%rdi
3390:	mov    %rdi,0x8(%rax)
; pckt.flow.port16[0] = original_sport;
3394:	mov    -0xc0(%rbp),%rdi
339b:	mov    %di,-0x18(%rbp)
; if (dst->flags & F_IPV6) {
339f:	mov    -0xb8(%rbp),%rdi
33a6:	movzbq 0x10(%rdi),%rdi
; if (dst->flags & F_IPV6) {
33ab:	and    $0x1,%rdi
; if (dst->flags & F_IPV6) {
33af:	test   %rdi,%rdi
33b2:	je     0xffffffffc01d59a7
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
33b8:	mov    %rbx,%rdi
33bb:	mov    $0xffffffd8,%esi
33c0:	call   0xffffffffa6e35c20
33c5:	shl    $0x20,%rax
33c9:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
33cd:	test   %rax,%rax
33d0:	jne    0xffffffffc01d3469
; data = (void*)(long)xdp->data;
33d6:	mov    0x0(%rbx),%rdi
; data_end = (void*)(long)xdp->data_end;
33da:	mov    0x8(%rbx),%rsi
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
33de:	mov    %rdi,%rdx
33e1:	add    $0xe,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
33e5:	cmp    %rsi,%rdx
33e8:	ja     0xffffffffc01d3469
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
33ee:	mov    %rdi,%rdx
33f1:	add    $0x36,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
33f5:	cmp    %rsi,%rdx
33f8:	ja     0xffffffffc01d3469
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
33fe:	cmp    %rsi,%rdx
3401:	ja     0xffffffffc01d3469
; 
3407:	mov    %rdi,%rsi
340a:	add    $0x28,%rsi
; memcpy(new_eth->h_dest, cval->mac, 6);
340e:	movzbq 0x5(%r15),%rdx
3413:	mov    %dl,0x5(%rdi)
3416:	movzbq 0x4(%r15),%rdx
341b:	mov    %dl,0x4(%rdi)
341e:	movzbq 0x3(%r15),%rdx
3423:	mov    %dl,0x3(%rdi)
3426:	movzbq 0x2(%r15),%rdx
342b:	mov    %dl,0x2(%rdi)
342e:	movzbq 0x1(%r15),%rdx
3433:	mov    %dl,0x1(%rdi)
3436:	movzbq 0x0(%r15),%rdx
343b:	mov    %dl,0x0(%rdi)
; memcpy(new_eth->h_source, old_eth->h_dest, 6);
343e:	movzbq 0x2(%rsi),%rdx
3443:	mov    %dl,0x8(%rdi)
3446:	movzbq 0x3(%rsi),%rdx
344b:	mov    %dl,0x9(%rdi)
344e:	movzbq 0x0(%rsi),%rdx
3453:	mov    %dl,0x6(%rdi)
3456:	movzbq 0x1(%rsi),%rdx
345b:	mov    %dl,0x7(%rdi)
345e:	movzbq 0x4(%rsi),%rdx
3463:	mov    %dl,0xa(%rdi)
3466:	movzbq 0x5(%rsi),%rsi
346b:	mov    %sil,0xb(%rdi)
346f:	mov    $0x86,%esi
; new_eth->h_proto = BE_ETH_P_IPV6;
3474:	mov    %sil,0xc(%rdi)
3478:	mov    $0xdd,%esi
347d:	mov    %sil,0xd(%rdi)
; create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
3481:	movzwq -0x18(%rbp),%rsi
; create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
3486:	mov    -0x38(%rbp),%edx
; saddr[3] = src ^ port;
3489:	xor    %rsi,%rdx
; create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
348c:	movzbq -0xb(%rbp),%rsi
3491:	mov    $0x4004,%ecx
; ip6h->nexthdr = proto;
3496:	mov    %cx,0x14(%rdi)
349a:	mov    $0x1,%ecx
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
349f:	mov    %ecx,0x16(%rdi)
34a2:	xor    %ecx,%ecx
34a4:	mov    %ecx,0x1a(%rdi)
34a7:	mov    %ecx,0x1e(%rdi)
; memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
34aa:	mov    %cl,0x10(%rdi)
34ad:	mov    %cl,0x11(%rdi)
; ip6h->payload_len = bpf_htons(payload_len);
34b0:	mov    -0x90(%rbp),%rcx
34b7:	mov    %cx,0x12(%rdi)
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
34bb:	mov    %edx,0x22(%rdi)
; ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
34be:	mov    %rsi,%rdx
34c1:	shl    $0x4,%rdx
; ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
34c5:	mov    %dl,0xf(%rdi)
; ip6h->priority = (tc & 0xF0) >> 4;
34c8:	shr    $0x4,%rsi
; ip6h->priority = (tc & 0xF0) >> 4;
34cc:	or     $0x60,%rsi
34d0:	mov    %sil,0xe(%rdi)
34d4:	mov    -0xb8(%rbp),%rdx
; 
34db:	mov    0xc(%rdx),%esi
34de:	mov    %esi,0x32(%rdi)
34e1:	mov    0x8(%rdx),%esi
34e4:	mov    %esi,0x2e(%rdi)
34e7:	mov    0x4(%rdx),%esi
34ea:	mov    %esi,0x2a(%rdi)
34ed:	mov    0x0(%rdx),%esi
34f0:	mov    %esi,0x26(%rdi)
34f3:	jmp    0xffffffffc01d2455
; if (pckt.flow.proto == IPPROTO_TCP) {
34f8:	movzbq -0x14(%rbp),%rdi
; if (pckt.flow.proto == IPPROTO_TCP) {
34fd:	cmp    $0x6,%rdi
3501:	jne    0xffffffffc01d5504
3503:	mov    $0x201,%edi
; __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
3508:	mov    %edi,-0x80(%rbp)
350b:	mov    %rbp,%rsi
; 
350e:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &lru_stats_key);
3512:	movabs $0xffff8881a98d8000,%rdi
351c:	add    $0x100,%rdi
3523:	mov    0x0(%rsi),%eax
3526:	cmp    $0x400,%rax
352d:	jae    0xffffffffc01d54d1
352f:	shl    $0x3,%rax
3533:	add    %rdi,%rax
3536:	mov    0x0(%rax),%rax
353a:	add    %gs:0xffffffffaa995028,%rax
3543:	jmp    0xffffffffc01d54d3
3545:	xor    %eax,%eax
; if (!lru_stats) {
3547:	test   %rax,%rax
354a:	je     0xffffffffc01d3463
; if (pckt.flags & F_SYN_SET) {
3550:	movzbq -0xc(%rbp),%rsi
; if (pckt.flags & F_SYN_SET) {
3555:	and    $0x2,%rsi
3559:	mov    $0x1,%edi
355e:	test   %rsi,%rsi
3561:	je     0xffffffffc01d54f1
3563:	xor    %edi,%edi
; if (pckt.flags & F_SYN_SET) {
3565:	shl    $0x3,%rdi
; 
3569:	add    %rdi,%rax
356c:	mov    0x0(%rax),%rdi
3570:	add    $0x1,%rdi
3574:	mov    %rdi,0x0(%rax)
3578:	xor    %esi,%esi
; struct real_pos_lru new_dst_lru = {};
357a:	mov    %rsi,-0x78(%rbp)
357e:	xor    %edi,%edi
3580:	mov    %rdi,-0xc8(%rbp)
3587:	mov    %rsi,-0x80(%rbp)
358b:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
3590:	mov    %edi,-0x88(%rbp)
3596:	mov    %rbp,%rsi
; 
3599:	add    $0xffffffffffffff78,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
35a0:	movabs $0xffff8881a98d8000,%rdi
35aa:	add    $0x100,%rdi
35b1:	mov    0x0(%rsi),%eax
35b4:	cmp    $0x400,%rax
35bb:	jae    0xffffffffc01d555f
35bd:	shl    $0x3,%rax
35c1:	add    %rdi,%rax
35c4:	mov    0x0(%rax),%rax
35c8:	add    %gs:0xffffffffaa995028,%rax
35d1:	jmp    0xffffffffc01d5561
35d3:	xor    %eax,%eax
35d5:	mov    %rax,%r14
35d8:	mov    $0x1,%r15d
; if (!conn_rate_stats) {
35de:	test   %r14,%r14
35e1:	je     0xffffffffc01d55bd
; *cur_time = bpf_ktime_get_ns();
35e3:	call   0xffffffffa4c9d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
35e8:	mov    0x8(%r14),%rdi
35ec:	mov    %rax,-0xc8(%rbp)
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
35f3:	mov    %rax,%rsi
35f6:	sub    %rdi,%rsi
35f9:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
35fe:	cmp    %rsi,%rdi
3601:	ja     0xffffffffc01d55a5
; conn_rate_stats->v2 = *cur_time;
3603:	mov    -0xc8(%rbp),%rdi
360a:	mov    %rdi,0x8(%r14)
360e:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
3613:	mov    %rdi,0x0(%r14)
3617:	jmp    0xffffffffc01d55ba
; conn_rate_stats->v1 += 1;
3619:	mov    0x0(%r14),%rdi
361d:	add    $0x1,%rdi
3621:	mov    %rdi,0x0(%r14)
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
3625:	cmp    $0x1e848,%rdi
362c:	ja     0xffffffffc01d55bd
362e:	xor    %r15d,%r15d
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
3631:	mov    -0xa0(%rbp),%rdi
3638:	mov    0x0(%rdi),%edi
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
363b:	and    $0x8,%rdi
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
363f:	test   %rdi,%rdi
3642:	jne    0xffffffffc01d55d6
; return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
3644:	mov    -0x38(%rbp),%r8d
3648:	jmp    0xffffffffc01d55f1
; pckt->flow.port16[0] = pckt->flow.port16[1];
364a:	mov    -0x98(%rbp),%rdi
3651:	movzwq 0x2(%rdi),%rdi
; pckt->flow.port16[0] = pckt->flow.port16[1];
3656:	mov    %di,-0x18(%rbp)
365a:	xor    %r8d,%r8d
; memset(pckt->flow.srcv6, 0, 16);
365d:	mov    %r8,-0x38(%rbp)
3661:	mov    %r8,-0x30(%rbp)
; return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
3665:	mov    -0x18(%rbp),%edx
; b += initval;
3668:	add    $0xffffffffe0adc0f7,%rdx
366f:	mov    $0xfffc0000,%edi
3674:	mov    %rdx,%rsi
3677:	and    %rdi,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
367a:	shr    $0x12,%rsi
367e:	mov    %rdx,%rcx
3681:	shl    $0xe,%rcx
3685:	or     %rsi,%rcx
; __jhash_final(a, b, c);
3688:	mov    %rdx,%rsi
368b:	xor    $0xffffffffe0adc0f7,%rsi
3692:	sub    %rcx,%rsi
3695:	mov    $0xffe00000,%ecx
369a:	mov    %rsi,%rax
369d:	and    %rcx,%rax
; return (word << shift) | (word >> ((-shift) & 31));
36a0:	shr    $0x15,%rax
36a4:	mov    %rsi,%r13
36a7:	shl    $0xb,%r13
36ab:	or     %rax,%r13
; a += initval;
36ae:	add    $0xffffffffe0adc0f7,%r8
; __jhash_final(a, b, c);
36b5:	mov    %rsi,%rcx
36b8:	xor    %r8,%rcx
36bb:	sub    %r13,%rcx
36be:	mov    $0xffffff80,%r8d
36c4:	mov    %rcx,%rax
36c7:	and    %r8,%rax
; return (word << shift) | (word >> ((-shift) & 31));
36ca:	shr    $0x7,%rax
36ce:	mov    %rcx,%r13
36d1:	shl    $0x19,%r13
36d5:	or     %rax,%r13
; __jhash_final(a, b, c);
36d8:	mov    %rcx,%r8
36db:	xor    %rdx,%r8
36de:	sub    %r13,%r8
36e1:	mov    $0xffff0000,%edx
36e6:	mov    %r8,%rax
36e9:	and    %rdx,%rax
; return (word << shift) | (word >> ((-shift) & 31));
36ec:	shr    $0x10,%rax
36f0:	mov    %r8,%r13
36f3:	shl    $0x10,%r13
36f7:	or     %rax,%r13
; __jhash_final(a, b, c);
36fa:	mov    %r8,%rdx
36fd:	xor    %rsi,%rdx
3700:	sub    %r13,%rdx
3703:	mov    $0xf0000000,%esi
3708:	mov    %rdx,%rax
370b:	and    %rsi,%rax
; return (word << shift) | (word >> ((-shift) & 31));
370e:	shr    $0x1c,%rax
3712:	mov    %rdx,%r13
3715:	shl    $0x4,%r13
3719:	or     %rax,%r13
; __jhash_final(a, b, c);
371c:	mov    %rdx,%rsi
371f:	xor    %rcx,%rsi
3722:	sub    %r13,%rsi
3725:	mov    %rsi,%rcx
3728:	and    %rdi,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
372b:	shr    $0x12,%rcx
372f:	mov    %rsi,%rdi
3732:	shl    $0xe,%rdi
3736:	or     %rcx,%rdi
; __jhash_final(a, b, c);
3739:	xor    %r8,%rsi
373c:	sub    %rdi,%rsi
373f:	mov    $0xffffff00,%edi
3744:	mov    %rsi,%rcx
3747:	and    %rdi,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
374a:	shr    $0x8,%rcx
374e:	mov    %rsi,%rdi
3751:	shl    $0x18,%rdi
3755:	or     %rcx,%rdi
; __jhash_final(a, b, c);
3758:	xor    %rdx,%rsi
375b:	sub    %rdi,%rsi
375e:	mov    %rsi,%rdi
3761:	shl    $0x20,%rdi
3765:	shr    $0x20,%rdi
; hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
3769:	push   %rax
376a:	push   %rdx
376b:	mov    $0x10001,%r11
3772:	mov    %rdi,%rax
3775:	xor    %edx,%edx
3777:	div    %r11
377a:	mov    %rax,%rdi
377d:	pop    %rdx
377e:	pop    %rax
377f:	imul   $0x10001,%rdi,%rdi
3786:	sub    %rdi,%rsi
; key = RING_SIZE * (vip_info->vip_num) + hash;
3789:	mov    -0xa0(%rbp),%rdi
3790:	mov    0x4(%rdi),%edi
; key = RING_SIZE * (vip_info->vip_num) + hash;
3793:	imul   $0x10001,%rdi,%rdi
; key = RING_SIZE * (vip_info->vip_num) + hash;
379a:	add    %rdi,%rsi
; key = RING_SIZE * (vip_info->vip_num) + hash;
379d:	mov    %esi,-0x4(%rbp)
37a0:	mov    %rbp,%rsi
; 
37a3:	add    $0xfffffffffffffffc,%rsi
; real_pos = bpf_map_lookup_elem(&ch_rings, &key);
37a7:	movabs $0xffffc900221cc000,%rdi
37b1:	add    $0x100,%rdi
37b8:	mov    0x0(%rsi),%eax
37bb:	cmp    $0x2000200,%rax
37c2:	jae    0xffffffffc01d5759
37c4:	shl    $0x3,%rax
37c8:	add    %rdi,%rax
37cb:	jmp    0xffffffffc01d575b
37cd:	xor    %eax,%eax
; if (!real_pos) {
37cf:	test   %rax,%rax
37d2:	je     0xffffffffc01d3463
; key = *real_pos;
37d8:	mov    0x0(%rax),%edi
; key = *real_pos;
37db:	mov    %edi,-0x4(%rbp)
; if (key == 0) {
37de:	test   %rdi,%rdi
37e1:	jne    0xffffffffc01d57d3
37e3:	mov    $0x209,%edi
; __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
37e8:	mov    %edi,-0x88(%rbp)
37ee:	mov    %rbp,%rsi
; 
37f1:	add    $0xffffffffffffff78,%rsi
; bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
37f8:	movabs $0xffff8881a98d8000,%rdi
3802:	add    $0x100,%rdi
3809:	mov    0x0(%rsi),%eax
380c:	cmp    $0x400,%rax
3813:	jae    0xffffffffc01d57b7
3815:	shl    $0x3,%rax
3819:	add    %rdi,%rax
381c:	mov    0x0(%rax),%rax
3820:	add    %gs:0xffffffffaa995028,%rax
3829:	jmp    0xffffffffc01d57b9
382b:	xor    %eax,%eax
; if (!ch_drop_stats) {
382d:	test   %rax,%rax
3830:	je     0xffffffffc01d3463
; 
3836:	mov    0x8(%rax),%rdi
383a:	add    $0x1,%rdi
383e:	mov    %rdi,0x8(%rax)
3842:	jmp    0xffffffffc01d3463
; pckt->real_index = key;
3847:	mov    %edi,-0x10(%rbp)
384a:	mov    %rbp,%rsi
; 
384d:	add    $0xfffffffffffffffc,%rsi
; *real = bpf_map_lookup_elem(&reals, &key);
3851:	movabs $0xffffc90008d64000,%rdi
385b:	add    $0x100,%rdi
3862:	mov    0x0(%rsi),%eax
3865:	cmp    $0x1000,%rax
386c:	jae    0xffffffffc01d5803
386e:	imul   $0x18,%rax,%rax
3872:	add    %rdi,%rax
3875:	jmp    0xffffffffc01d5805
3877:	xor    %eax,%eax
3879:	mov    %rax,-0xb8(%rbp)
; if (!(*real)) {
3880:	test   %rax,%rax
3883:	jne    0xffffffffc01d5875
3885:	mov    $0x209,%edi
; __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
388a:	mov    %edi,-0x88(%rbp)
3890:	mov    %rbp,%rsi
; 
3893:	add    $0xffffffffffffff78,%rsi
; bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
389a:	movabs $0xffff8881a98d8000,%rdi
38a4:	add    $0x100,%rdi
38ab:	mov    0x0(%rsi),%eax
38ae:	cmp    $0x400,%rax
38b5:	jae    0xffffffffc01d5859
38b7:	shl    $0x3,%rax
38bb:	add    %rdi,%rax
38be:	mov    0x0(%rax),%rax
38c2:	add    %gs:0xffffffffaa995028,%rax
38cb:	jmp    0xffffffffc01d585b
38cd:	xor    %eax,%eax
; if (!ch_drop_stats) {
38cf:	test   %rax,%rax
38d2:	je     0xffffffffc01d3463
; 
38d8:	mov    0x0(%rax),%rdi
38dc:	add    $0x1,%rdi
38e0:	mov    %rdi,0x0(%rax)
38e4:	jmp    0xffffffffc01d3463
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
38e9:	mov    -0xa8(%rbp),%rdi
38f0:	test   %rdi,%rdi
38f3:	je     0xffffffffc01d58d2
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
38f5:	mov    -0xa0(%rbp),%rdi
38fc:	mov    0x0(%rdi),%edi
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
38ff:	and    $0x2,%rdi
3903:	shr    %rdi
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
3906:	or     %rdi,%r15
3909:	test   %r15,%r15
390c:	jne    0xffffffffc01d58d2
; if (pckt->flow.proto == IPPROTO_UDP) {
390e:	movzbq -0x14(%rbp),%rdi
; if (pckt->flow.proto == IPPROTO_UDP) {
3913:	cmp    $0x11,%rdi
3917:	jne    0xffffffffc01d58b0
; new_dst_lru.atime = cur_time;
3919:	mov    -0xc8(%rbp),%rdi
3920:	mov    %rdi,-0x78(%rbp)
; new_dst_lru.pos = key;
3924:	mov    -0x4(%rbp),%edi
; new_dst_lru.pos = key;
3927:	mov    %edi,-0x80(%rbp)
392a:	mov    %rbp,%rsi
; new_dst_lru.pos = key;
392d:	add    $0xffffffffffffffc8,%rsi
3931:	mov    %rbp,%rdx
3934:	add    $0xffffffffffffff80,%rdx
; bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
3938:	mov    -0xa8(%rbp),%rdi
393f:	xor    %ecx,%ecx
3941:	call   0xffffffffa4c9c9c0
3946:	xor    %edi,%edi
; __u32 vip_miss_stats_key = 0;
3948:	mov    %edi,-0x80(%rbp)
394b:	mov    %rbp,%rsi
; 
394e:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&vip_miss_stats, &vip_miss_stats_key);
3952:	movabs $0xffff88819b01f800,%rdi
395c:	add    $0x100,%rdi
3963:	mov    0x0(%rsi),%eax
3966:	cmp    $0x1,%rax
396a:	jae    0xffffffffc01d5901
396c:	imul   $0x18,%rax,%rax
3970:	add    %rdi,%rax
3973:	jmp    0xffffffffc01d5903
3975:	xor    %eax,%eax
; if (!lru_miss_stat_vip) {
3977:	test   %rax,%rax
397a:	je     0xffffffffc01d3463
; bool vip_match = address_match && port_match && proto_match;
3980:	movzwq -0x40(%rbp),%rsi
; (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
3985:	mov    -0x50(%rbp),%edx
; bool vip_match = address_match && port_match && proto_match;
3988:	movzbq -0x3e(%rbp),%rdi
; bool proto_match = lru_miss_stat_vip->proto = vip->proto;
398d:	mov    %dil,0x12(%rax)
; (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
3991:	mov    0x0(%rax),%ecx
; bool vip_match = address_match && port_match && proto_match;
3994:	cmp    %rdx,%rcx
3997:	jne    0xffffffffc01d598f
3999:	movzwq 0x10(%rax),%rdx
399e:	cmp    %rsi,%rdx
39a1:	jne    0xffffffffc01d598f
39a3:	test   %rdi,%rdi
39a6:	je     0xffffffffc01d598f
; __u32 lru_stats_key = pckt->real_index;
39a8:	mov    -0x10(%rbp),%edi
; __u32 lru_stats_key = pckt->real_index;
39ab:	mov    %edi,-0x88(%rbp)
39b1:	mov    %rbp,%rsi
; __u32 lru_stats_key = pckt->real_index;
39b4:	add    $0xffffffffffffff78,%rsi
; __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
39bb:	movabs $0xffffc90008d88000,%rdi
39c5:	add    $0x100,%rdi
39cc:	mov    0x0(%rsi),%eax
39cf:	cmp    $0x1000,%rax
39d6:	jae    0xffffffffc01d597a
39d8:	shl    $0x3,%rax
39dc:	add    %rdi,%rax
39df:	mov    0x0(%rax),%rax
39e3:	add    %gs:0xffffffffaa995028,%rax
39ec:	jmp    0xffffffffc01d597c
39ee:	xor    %eax,%eax
; if (!lru_miss_stat) {
39f0:	test   %rax,%rax
39f3:	je     0xffffffffc01d3463
; *lru_miss_stat += 1;
39f9:	mov    0x0(%rax),%edi
39fc:	add    $0x1,%rdi
3a00:	mov    %edi,0x0(%rax)
3a03:	mov    -0xb0(%rbp),%rsi
; data_stats->v2 += 1;
3a0a:	mov    0x8(%rsi),%rdi
3a0e:	add    $0x1,%rdi
3a12:	mov    %rdi,0x8(%rsi)
3a16:	jmp    0xffffffffc01d521a
; __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
3a1b:	mov    -0x38(%rbp),%edi
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
3a1e:	mov    %rdi,-0x90(%rbp)
3a25:	mov    %rbx,%rdi
3a28:	mov    $0xffffffec,%esi
3a2d:	call   0xffffffffa6e35c20
3a32:	shl    $0x20,%rax
3a36:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
3a3a:	test   %rax,%rax
3a3d:	jne    0xffffffffc01d3469
; data = (void*)(long)xdp->data;
3a43:	mov    0x0(%rbx),%rdi
; data_end = (void*)(long)xdp->data_end;
3a47:	mov    0x8(%rbx),%rsi
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
3a4b:	mov    %rdi,%rdx
3a4e:	add    $0xe,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
3a52:	cmp    %rsi,%rdx
3a55:	ja     0xffffffffc01d3469
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
3a5b:	mov    %rdi,%rdx
3a5e:	add    $0x22,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
3a62:	cmp    %rsi,%rdx
3a65:	ja     0xffffffffc01d3469
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
3a6b:	cmp    %rsi,%rdx
3a6e:	ja     0xffffffffc01d3469
3a74:	mov    -0xc0(%rbp),%rbx
3a7b:	bswap  %ebx
3a7d:	mov    $0xffff0000,%esi
; 
3a82:	and    %rsi,%rbx
3a85:	mov    -0x90(%rbp),%rsi
3a8c:	and    $0xffffffffffff0000,%rsi
3a93:	xor    %rsi,%rbx
3a96:	mov    %rbx,%rsi
3a99:	or     $0x10ac,%rsi
3aa0:	mov    %rdi,%rdx
3aa3:	add    $0x14,%rdx
; memcpy(new_eth->h_dest, cval->mac, 6);
3aa7:	movzbq 0x5(%r15),%rcx
3aac:	mov    %cl,0x5(%rdi)
3aaf:	movzbq 0x4(%r15),%rcx
3ab4:	mov    %cl,0x4(%rdi)
3ab7:	movzbq 0x3(%r15),%rcx
3abc:	mov    %cl,0x3(%rdi)
3abf:	movzbq 0x2(%r15),%rcx
3ac4:	mov    %cl,0x2(%rdi)
3ac7:	movzbq 0x1(%r15),%rcx
3acc:	mov    %cl,0x1(%rdi)
3acf:	movzbq 0x0(%r15),%rcx
3ad4:	mov    %cl,0x0(%rdi)
; memcpy(new_eth->h_source, old_eth->h_dest, 6);
3ad7:	movzbq 0x2(%rdx),%rcx
3adc:	mov    %cl,0x8(%rdi)
3adf:	movzbq 0x3(%rdx),%rcx
3ae4:	mov    %cl,0x9(%rdi)
3ae7:	movzbq 0x0(%rdx),%rcx
3aec:	mov    %cl,0x6(%rdi)
3aef:	movzbq 0x1(%rdx),%rcx
3af4:	mov    %cl,0x7(%rdi)
3af7:	movzbq 0x4(%rdx),%rcx
3afc:	mov    %cl,0xa(%rdi)
3aff:	movzbq 0x5(%rdx),%rdx
3b04:	mov    %dl,0xb(%rdi)
3b07:	mov    $0x8,%edx
; new_eth->h_proto = BE_ETH_P_IP;
3b0c:	mov    %dl,0xc(%rdi)
3b0f:	xor    %edx,%edx
3b11:	mov    %dl,0xd(%rdi)
; create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
3b14:	mov    -0xb8(%rbp),%rcx
3b1b:	mov    0x0(%rcx),%ecx
; create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
3b1e:	movzbq -0xb(%rbp),%r8
3b23:	mov    $0x45,%eax
; iph->ihl = 5;
3b28:	mov    %al,0xe(%rdi)
; iph->tos = tos;
3b2b:	mov    %r8b,0xf(%rdi)
; *csum += *next_iph_u16++;
3b2f:	shl    $0x20,%rbx
3b33:	shr    $0x20,%rbx
3b37:	shr    $0x10,%rbx
3b3b:	mov    %rcx,%r8
3b3e:	and    $0xffff,%r8
; *csum += *next_iph_u16++;
3b45:	add    %r8,%rbx
; iph->id = 0;
3b48:	mov    %edx,0x12(%rdi)
3b4b:	mov    $0x440,%edx
; iph->ttl = DEFAULT_TTL;
3b50:	mov    %dx,0x16(%rdi)
; iph->saddr = saddr;
3b54:	mov    %esi,0x1a(%rdi)
; iph->daddr = daddr;
3b57:	mov    %ecx,0x1e(%rdi)
; *csum += *next_iph_u16++;
3b5a:	shr    $0x10,%rcx
; *csum += *next_iph_u16++;
3b5e:	add    %rcx,%rbx
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
3b61:	add    $0x14,%r13
3b65:	ror    $0x8,%r13w
3b6a:	movzwl %r13w,%r13d
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
3b6e:	mov    %r13w,0x10(%rdi)
; *csum += *next_iph_u16++;
3b73:	add    %r13,%rbx
; *csum += *next_iph_u16++;
3b76:	movzwq 0xe(%rdi),%rsi
; *csum += *next_iph_u16++;
3b7b:	add    %rsi,%rbx
; *csum += *next_iph_u16++;
3b7e:	movzwq 0x16(%rdi),%rsi
; *csum += *next_iph_u16++;
3b83:	add    %rsi,%rbx
3b86:	add    $0x10ac,%rbx
3b8d:	mov    %rbx,%rdx
; if (csum >> 16)
3b90:	mov    %rbx,%rsi
3b93:	shr    $0x10,%rsi
; if (csum >> 16)
3b97:	test   %rsi,%rsi
3b9a:	je     0xffffffffc01d5b32
3b9c:	and    $0xffff,%rdx
3ba3:	add    %rsi,%rdx
; if (csum >> 16)
3ba6:	mov    %rdx,%rsi
3ba9:	shr    $0x10,%rsi
; if (csum >> 16)
3bad:	test   %rsi,%rsi
3bb0:	je     0xffffffffc01d5b48
3bb2:	and    $0xffff,%rdx
3bb9:	add    %rsi,%rdx
; if (csum >> 16)
3bbc:	mov    %rdx,%rsi
3bbf:	shr    $0x10,%rsi
; if (csum >> 16)
3bc3:	test   %rsi,%rsi
3bc6:	je     0xffffffffc01d4b6c
3bcc:	jmp    0xffffffffc01d4b62
3bd1:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
3bd6:	mov    %edi,-0x80(%rbp)
3bd9:	mov    %rbp,%rsi
; 
3bdc:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
3be0:	movabs $0xffff8881a98d8000,%rdi
3bea:	add    $0x100,%rdi
3bf1:	mov    0x0(%rsi),%eax
3bf4:	cmp    $0x400,%rax
3bfb:	jae    0xffffffffc01d5b9f
3bfd:	shl    $0x3,%rax
3c01:	add    %rdi,%rax
3c04:	mov    0x0(%rax),%rax
3c08:	add    %gs:0xffffffffaa995028,%rax
3c11:	jmp    0xffffffffc01d5ba1
3c13:	xor    %eax,%eax
3c15:	mov    %rax,%r13
; if (!conn_rate_stats) {
3c18:	test   %r13,%r13
3c1b:	je     0xffffffffc01d5cc5
; *cur_time = bpf_ktime_get_ns();
3c21:	call   0xffffffffa4c9d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
3c26:	mov    0x8(%r13),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
3c2a:	mov    %rax,%rsi
3c2d:	sub    %rdi,%rsi
3c30:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
3c35:	cmp    %rsi,%rdi
3c38:	ja     0xffffffffc01d5cab
; conn_rate_stats->v2 = *cur_time;
3c3e:	mov    %rax,0x8(%r13)
3c42:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
3c47:	mov    %rdi,0x0(%r13)
3c4b:	xor    %edi,%edi
; struct real_pos_lru new_dst_lru = {};
3c4d:	mov    %rdi,-0x80(%rbp)
; new_dst_lru.pos = pckt->real_index;
3c51:	mov    -0x10(%rbp),%esi
; new_dst_lru.pos = pckt->real_index;
3c54:	mov    %esi,-0x80(%rbp)
; struct real_pos_lru new_dst_lru = {};
3c57:	mov    %rdi,-0x78(%rbp)
3c5b:	mov    %rbp,%rsi
3c5e:	add    $0xffffffffffffffc8,%rsi
3c62:	mov    %rbp,%rdx
3c65:	add    $0xffffffffffffff80,%rdx
; bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
3c69:	mov    -0xc8(%rbp),%rdi
3c70:	xor    %ecx,%ecx
3c72:	call   0xffffffffa4c9c9c0
3c77:	jmp    0xffffffffc01d5cc5
; dst_lru->pos = pckt->real_index;
3c7c:	mov    %edi,0x0(%rax)
3c7f:	mov    %r14,%rsi
; quic_packets_stats->dst_mismatch_in_lru += 1;
3c82:	mov    0x58(%rsi),%rdi
3c86:	add    $0x1,%rdi
3c8a:	mov    %rdi,0x58(%rsi)
; vip_num, /* new conn */ false, /* mismatch in lru */ true);
3c8e:	mov    -0x54(%rbp),%edi
3c91:	mov    %edi,-0x80(%rbp)
3c94:	mov    %rbp,%rsi
; dst_lru->pos = pckt->real_index;
3c97:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&server_id_stats, &vip_num);
3c9b:	movabs $0xffff8881aa428000,%rdi
3ca5:	add    $0x100,%rdi
3cac:	mov    0x0(%rsi),%eax
3caf:	cmp    $0x200,%rax
3cb6:	jae    0xffffffffc01d5c5a
3cb8:	shl    $0x3,%rax
3cbc:	add    %rdi,%rax
3cbf:	mov    0x0(%rax),%rax
3cc3:	add    %gs:0xffffffffaa995028,%rax
3ccc:	jmp    0xffffffffc01d5c5c
3cce:	xor    %eax,%eax
; if (!per_vip_stats) {
3cd0:	test   %rax,%rax
3cd3:	je     0xffffffffc01d5cd4
; per_vip_stats->v2 += 1;
3cd5:	mov    0x8(%rax),%rdi
3cd9:	add    $0x1,%rdi
3cdd:	mov    %rdi,0x8(%rax)
3ce1:	jmp    0xffffffffc01d5cd4
3ce3:	mov    %rbp,%rsi
; 
3ce6:	add    $0xffffffffffffffc8,%rsi
; struct real_pos_lru* dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);
3cea:	mov    -0xa8(%rbp),%rdi
3cf1:	call   0xffffffffa4c9c930
; if (dst_lru) {
3cf6:	test   %rax,%rax
3cf9:	je     0xffffffffc01d5cf1
; if (dst_lru->pos == pckt->real_index) {
3cfb:	mov    0x0(%rax),%esi
; if (dst_lru->pos == pckt->real_index) {
3cfe:	mov    -0x10(%rbp),%edi
; if (dst_lru->pos == pckt->real_index) {
3d01:	cmp    %rdi,%rsi
3d04:	je     0xffffffffc01d5c97
3d06:	jmp    0xffffffffc01d5d9c
3d0b:	mov    %r14,%rsi
; quic_packets_stats->dst_match_in_lru += 1;
3d0e:	mov    0x50(%rsi),%rdi
3d12:	add    $0x1,%rdi
3d16:	mov    %rdi,0x50(%rsi)
3d1a:	jmp    0xffffffffc01d5e2c
; conn_rate_stats->v1 += 1;
3d1f:	mov    0x0(%r13),%rdi
3d23:	add    $0x1,%rdi
3d27:	mov    %rdi,0x0(%r13)
3d2b:	mov    $0x1e849,%esi
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
3d30:	cmp    %rdi,%rsi
3d33:	ja     0xffffffffc01d5bd7
3d39:	mov    %r14,%rsi
; quic_packets_stats->dst_not_found_in_lru += 1;
3d3c:	mov    0x60(%rsi),%rdi
3d40:	add    $0x1,%rdi
3d44:	mov    %rdi,0x60(%rsi)
; quic_packets_stats->cid_routed += 1;
3d48:	mov    0x20(%r14),%rdi
3d4c:	add    $0x1,%rdi
3d50:	mov    %rdi,0x20(%r14)
; original_sport = pckt.flow.port16[0];
3d54:	movzwq -0x18(%rbp),%rdi
; if (!dst) {
3d59:	mov    %rdi,-0xb0(%rbp)
3d60:	jmp    0xffffffffc01d3fc3
3d65:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
3d6a:	mov    %edi,-0x80(%rbp)
3d6d:	mov    %rbp,%rsi
; 
3d70:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
3d74:	movabs $0xffff8881a98d8000,%rdi
3d7e:	add    $0x100,%rdi
3d85:	mov    0x0(%rsi),%eax
3d88:	cmp    $0x400,%rax
3d8f:	jae    0xffffffffc01d5d33
3d91:	shl    $0x3,%rax
3d95:	add    %rdi,%rax
3d98:	mov    0x0(%rax),%rax
3d9c:	add    %gs:0xffffffffaa995028,%rax
3da5:	jmp    0xffffffffc01d5d35
3da7:	xor    %eax,%eax
3da9:	mov    %rax,%r13
; if (!conn_rate_stats) {
3dac:	test   %r13,%r13
3daf:	je     0xffffffffc01d5e1d
; *cur_time = bpf_ktime_get_ns();
3db5:	call   0xffffffffa4c9d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
3dba:	mov    0x8(%r13),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
3dbe:	mov    %rax,%rsi
3dc1:	sub    %rdi,%rsi
3dc4:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
3dc9:	cmp    %rsi,%rdi
3dcc:	ja     0xffffffffc01d5e03
; conn_rate_stats->v2 = *cur_time;
3dd2:	mov    %rax,0x8(%r13)
3dd6:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
3ddb:	mov    %rdi,0x0(%r13)
3ddf:	xor    %edi,%edi
; struct real_pos_lru new_dst_lru = {};
3de1:	mov    %rdi,-0x80(%rbp)
; new_dst_lru.pos = pckt->real_index;
3de5:	mov    -0x10(%rbp),%esi
; new_dst_lru.pos = pckt->real_index;
3de8:	mov    %esi,-0x80(%rbp)
; struct real_pos_lru new_dst_lru = {};
3deb:	mov    %rdi,-0x78(%rbp)
3def:	mov    %rbp,%rsi
3df2:	add    $0xffffffffffffffc8,%rsi
3df6:	mov    %rbp,%rdx
3df9:	add    $0xffffffffffffff80,%rdx
; bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
3dfd:	mov    -0xa8(%rbp),%rdi
3e04:	xor    %ecx,%ecx
3e06:	call   0xffffffffa4c9c9c0
3e0b:	jmp    0xffffffffc01d5e1d
; dst_lru->pos = pckt->real_index;
3e10:	mov    %edi,0x0(%rax)
3e13:	mov    %r14,%rsi
; quic_packets_stats->dst_mismatch_in_lru += 1;
3e16:	mov    0x58(%rsi),%rdi
3e1a:	add    $0x1,%rdi
3e1e:	mov    %rdi,0x58(%rsi)
; vip_num, /* new conn */ false, /* mismatch in lru */ true);
3e22:	mov    -0x54(%rbp),%edi
3e25:	mov    %edi,-0x80(%rbp)
3e28:	mov    %rbp,%rsi
; dst_lru->pos = pckt->real_index;
3e2b:	add    $0xffffffffffffff80,%rsi
; bpf_map_lookup_elem(&server_id_stats, &vip_num);
3e2f:	movabs $0xffff8881aa428000,%rdi
3e39:	add    $0x100,%rdi
3e40:	mov    0x0(%rsi),%eax
3e43:	cmp    $0x200,%rax
3e4a:	jae    0xffffffffc01d5dee
3e4c:	shl    $0x3,%rax
3e50:	add    %rdi,%rax
3e53:	mov    0x0(%rax),%rax
3e57:	add    %gs:0xffffffffaa995028,%rax
3e60:	jmp    0xffffffffc01d5df0
3e62:	xor    %eax,%eax
; if (!per_vip_stats) {
3e64:	test   %rax,%rax
3e67:	je     0xffffffffc01d5e2c
; per_vip_stats->v2 += 1;
3e69:	mov    0x8(%rax),%rdi
3e6d:	add    $0x1,%rdi
3e71:	mov    %rdi,0x8(%rax)
3e75:	jmp    0xffffffffc01d5e2c
; conn_rate_stats->v1 += 1;
3e77:	mov    0x0(%r13),%rdi
3e7b:	add    $0x1,%rdi
3e7f:	mov    %rdi,0x0(%r13)
3e83:	mov    $0x1e849,%esi
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
3e88:	cmp    %rdi,%rsi
3e8b:	ja     0xffffffffc01d5d6b
3e91:	mov    %r14,%rsi
; quic_packets_stats->dst_not_found_in_lru += 1;
3e94:	mov    0x60(%rsi),%rdi
3e98:	add    $0x1,%rdi
3e9c:	mov    %rdi,0x60(%rsi)
; quic_packets_stats->cid_routed += 1;
3ea0:	mov    0x20(%r14),%rdi
3ea4:	add    $0x1,%rdi
3ea8:	mov    %rdi,0x20(%r14)
; original_sport = pckt.flow.port16[0];
3eac:	movzwq -0x18(%rbp),%rdi
; if (!dst) {
3eb1:	mov    %rdi,-0xc0(%rbp)
3eb8:	jmp    0xffffffffc01d521a

