int balancer_ingress(struct xdp_md * ctx):
bpf_prog_54714ac0ee8fee63_balancer_ingress:
; int balancer_ingress(struct xdp_md* ctx) {
   0:	endbr64
   4:	nopl   0x0(%rax,%rax,1)
   9:	nopl   (%rax)
   c:	push   %rbp
   d:	mov    %rsp,%rbp
  10:	endbr64
  14:	sub    $0xc8,%rsp
  1b:	push   %rbx
  1c:	push   %r13
  1e:	push   %r14
  20:	push   %r15
  22:	mov    %rdi,%rbx
  25:	mov    $0x1,%r14d
; void* data_end = (void*)(long)ctx->data_end;
  2b:	mov    0x8(%rbx),%r13
; void* data = (void*)(long)ctx->data;
  2f:	mov    0x0(%rbx),%r15
; if (data + nh_off > data_end) {
  33:	mov    %r15,%rdi
  36:	add    $0xe,%rdi
; if (data + nh_off > data_end) {
  3a:	cmp    %r13,%rdi
  3d:	ja     0xffffffffc00d3477
; eth_proto = eth->h_proto;
  43:	movzbq 0xc(%r15),%rdx
  48:	movzbq 0xd(%r15),%rsi
  4d:	shl    $0x8,%rsi
  51:	or     %rdx,%rsi
; if (eth_proto == BE_ETH_P_IP) {
  54:	cmp    $0xdd86,%rsi
  5b:	je     0xffffffffc00d21df
  61:	mov    $0x2,%r14d
  67:	cmp    $0x8,%rsi
  6b:	jne    0xffffffffc00d3477
  71:	xor    %esi,%esi
; struct packet_description pckt = {};
  73:	mov    %rsi,-0x20(%rbp)
  77:	mov    %rsi,-0x28(%rbp)
  7b:	mov    %rsi,-0x30(%rbp)
  7f:	mov    %rsi,-0x38(%rbp)
  83:	mov    %rsi,-0x40(%rbp)
  87:	mov    %rsi,-0x48(%rbp)
; struct vip_definition vip = {};
  8b:	mov    %esi,-0x50(%rbp)
  8e:	mov    %rsi,-0x58(%rbp)
  92:	mov    %rsi,-0x60(%rbp)
; __u32 mac_addr_pos = 0;
  96:	mov    %esi,-0x68(%rbp)
; if (iph + 1 > data_end) {
  99:	mov    %r15,%rdx
  9c:	add    $0x22,%rdx
; 
  a0:	mov    $0x1,%r14d
; if (iph + 1 > data_end) {
  a6:	cmp    %r13,%rdx
  a9:	ja     0xffffffffc00d3477
; if (iph->ihl != 5) {
  af:	movzbq 0x0(%rdi),%rdi
  b4:	and    $0xf,%rdi
; 
  b8:	mov    $0x1,%r14d
; if (iph->ihl != 5) {
  be:	cmp    $0x5,%rdi
  c2:	jne    0xffffffffc00d3477
; pckt->tos = iph->tos;
  c8:	movzbq 0xf(%r15),%rdi
; pckt->tos = iph->tos;
  cd:	mov    %dil,-0x1b(%rbp)
; *protocol = iph->protocol;
  d1:	movzbq 0x17(%r15),%rdi
; pckt->flow.proto = *protocol;
  d6:	mov    %dil,-0x24(%rbp)
; if (iph->frag_off & PCKT_FRAGMENTED) {
  da:	movzwq 0x14(%r15),%rcx
; if (iph->frag_off & PCKT_FRAGMENTED) {
  df:	mov    %rcx,%rsi
  e2:	and    $0xff3f,%rsi
; 
  e9:	mov    $0x1,%r14d
; if (iph->frag_off & PCKT_FRAGMENTED) {
  ef:	test   %rsi,%rsi
  f2:	jne    0xffffffffc00d3477
; 
  f8:	movzwq 0x10(%r15),%rax
; if (*protocol == IPPROTO_ICMP) {
  fd:	mov    %rdi,%r8
; if (*protocol == IPPROTO_ICMP) {
 100:	cmp    $0x1,%r8
 104:	je     0xffffffffc00d24d9
; pckt->flow.src = iph->saddr;
 10a:	mov    0x1a(%r15),%esi
; pckt->flow.src = iph->saddr;
 10e:	mov    %esi,-0x48(%rbp)
; pckt->flow.dst = iph->daddr;
 111:	mov    0x1e(%r15),%esi
; pckt->flow.dst = iph->daddr;
 115:	mov    %esi,-0x38(%rbp)
 118:	xor    %esi,%esi
; if (protocol == IPPROTO_ICMPV6) {
 11a:	cmp    $0x3a,%r8
 11e:	jne    0xffffffffc00d2cfe
; if (icmp_hdr + 1 > data_end) {
 124:	mov    %r15,%rdi
 127:	add    $0x2a,%rdi
; 
 12b:	mov    $0x1,%r14d
; if (icmp_hdr + 1 > data_end) {
 131:	cmp    %r13,%rdi
 134:	ja     0xffffffffc00d3477
; if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 13a:	movzbq 0x0(%rdx),%rdi
; if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 13f:	cmp    $0x1,%rdi
 143:	je     0xffffffffc00d2c89
 149:	cmp    $0x2,%rdi
 14d:	je     0xffffffffc00d2c0f
 153:	mov    $0x2,%r14d
 159:	cmp    $0x80,%rdi
 160:	jne    0xffffffffc00d3477
 166:	mov    $0x1,%r14d
; if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 16c:	mov    %r15,%rdi
 16f:	add    $0x3e,%rdi
; if ((data + sizeof(struct ethhdr) + sizeof(struct ipv6hdr) +
 173:	cmp    %r13,%rdi
 176:	ja     0xffffffffc00d3477
 17c:	mov    $0x81,%edi
; 
 181:	mov    %dil,0x36(%r15)
 185:	mov    $0x40,%edi
 18a:	mov    %dil,0x15(%r15)
 18e:	movzwq 0x38(%r15),%rdi
 193:	add    $0xffffffffffffffff,%rdi
 197:	mov    %di,0x38(%r15)
 19c:	mov    0x22(%r15),%edi
 1a0:	shl    $0x20,%rdi
 1a4:	mov    0x1e(%r15),%esi
 1a8:	or     %rsi,%rdi
 1ab:	mov    %rdi,-0x8(%rbp)
 1af:	mov    0x1a(%r15),%edi
 1b3:	shl    $0x20,%rdi
 1b7:	mov    0x16(%r15),%esi
 1bb:	or     %rsi,%rdi
 1be:	mov    %rdi,-0x10(%rbp)
 1c2:	mov    0x26(%r15),%edi
 1c6:	mov    %edi,0x16(%r15)
 1ca:	mov    0x2a(%r15),%edi
 1ce:	mov    %edi,0x1a(%r15)
 1d2:	mov    0x2e(%r15),%edi
 1d6:	mov    %edi,0x1e(%r15)
 1da:	mov    0x32(%r15),%edi
 1de:	mov    %edi,0x22(%r15)
 1e2:	mov    -0x10(%rbp),%rdi
 1e6:	mov    %edi,0x26(%r15)
 1ea:	shr    $0x20,%rdi
 1ee:	mov    %edi,0x2a(%r15)
 1f2:	mov    -0x8(%rbp),%rdi
 1f6:	mov    %edi,0x2e(%r15)
 1fa:	shr    $0x20,%rdi
 1fe:	mov    %edi,0x32(%r15)
 202:	jmp    0xffffffffc00d23da
 207:	xor    %edi,%edi
; struct packet_description pckt = {};
 209:	mov    %rdi,-0x20(%rbp)
 20d:	mov    %rdi,-0x28(%rbp)
 211:	mov    %rdi,-0x30(%rbp)
 215:	mov    %rdi,-0x38(%rbp)
 219:	mov    %rdi,-0x40(%rbp)
 21d:	mov    %rdi,-0x48(%rbp)
; struct vip_definition vip = {};
 221:	mov    %edi,-0x50(%rbp)
 224:	mov    %rdi,-0x58(%rbp)
 228:	mov    %rdi,-0x60(%rbp)
; __u32 mac_addr_pos = 0;
 22c:	mov    %edi,-0x68(%rbp)
; if (ip6h + 1 > data_end) {
 22f:	mov    %r15,%rdx
 232:	add    $0x36,%rdx
; 
 236:	mov    $0x1,%r14d
; if (ip6h + 1 > data_end) {
 23c:	cmp    %r13,%rdx
 23f:	ja     0xffffffffc00d3477
; *protocol = ip6h->nexthdr;
 245:	movzbq 0x14(%r15),%rdi
; pckt->flow.proto = *protocol;
 24a:	mov    %dil,-0x24(%rbp)
; pckt->tos = (ip6h->priority << 4) & 0xF0;
 24e:	movzbq 0xe(%r15),%rsi
; pckt->tos = (ip6h->priority << 4) & 0xF0;
 253:	shl    $0x4,%rsi
; pckt->tos = (ip6h->priority << 4) & 0xF0;
 257:	mov    %sil,-0x1b(%rbp)
; pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 25b:	movzbq 0xf(%r15),%rcx
; pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 260:	shr    $0x4,%rcx
; pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 264:	or     %rsi,%rcx
; pckt->tos = pckt->tos | ((ip6h->flow_lbl[0] >> 4) & 0x0F);
 267:	mov    %cl,-0x1b(%rbp)
; 
 26a:	mov    $0x1,%r14d
; if (*protocol == IPPROTO_FRAGMENT) {
 270:	cmp    $0x2c,%rdi
 274:	je     0xffffffffc00d3477
; 
 27a:	movzwq 0x12(%r15),%rax
; if (*protocol == IPPROTO_FRAGMENT) {
 27f:	cmp    $0x3a,%rdi
 283:	je     0xffffffffc00d2492
; memcpy(pckt->flow.srcv6, ip6h->saddr.s6_addr32, 16);
 289:	mov    0x22(%r15),%esi
 28d:	shl    $0x20,%rsi
 291:	mov    0x1e(%r15),%ecx
 295:	or     %rcx,%rsi
 298:	mov    %rsi,-0x40(%rbp)
 29c:	mov    0x1a(%r15),%esi
 2a0:	shl    $0x20,%rsi
 2a4:	mov    0x16(%r15),%ecx
 2a8:	or     %rcx,%rsi
 2ab:	mov    %rsi,-0x48(%rbp)
; memcpy(pckt->flow.dstv6, ip6h->daddr.s6_addr32, 16);
 2af:	mov    0x32(%r15),%esi
 2b3:	shl    $0x20,%rsi
 2b7:	mov    0x2e(%r15),%ecx
 2bb:	or     %rcx,%rsi
 2be:	mov    %rsi,-0x30(%rbp)
 2c2:	mov    0x26(%r15),%esi
 2c6:	mov    0x2a(%r15),%ecx
 2ca:	shl    $0x20,%rcx
 2ce:	or     %rsi,%rcx
 2d1:	mov    %rcx,-0x38(%rbp)
 2d5:	xor    %esi,%esi
; if (protocol == IPPROTO_ICMPV6) {
 2d7:	cmp    $0x1,%rdi
 2db:	je     0xffffffffc00d22ba
 2dd:	jmp    0xffffffffc00d269c
; if (icmp_hdr + 1 > data_end) {
 2e2:	mov    %r15,%rsi
 2e5:	add    $0x3e,%rsi
; 
 2e9:	mov    $0x1,%r14d
; if (icmp_hdr + 1 > data_end) {
 2ef:	cmp    %r13,%rsi
 2f2:	ja     0xffffffffc00d3477
; if (icmp_hdr->type == ICMP_ECHO) {
 2f8:	movzbq 0x0(%rdx),%rdi
; if (icmp_hdr->type == ICMP_ECHO) {
 2fd:	cmp    $0x3,%rdi
 301:	je     0xffffffffc00d2a37
 307:	mov    $0x2,%r14d
 30d:	cmp    $0x8,%rdi
 311:	jne    0xffffffffc00d3477
; if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 317:	mov    %r15,%rdi
 31a:	add    $0x2a,%rdi
; 
 31e:	mov    $0x1,%r14d
; if ((data + sizeof(struct ethhdr) + sizeof(struct iphdr) +
 324:	cmp    %r13,%rdi
 327:	ja     0xffffffffc00d3477
; tmp_addr = iph->daddr;
 32d:	mov    0x1e(%r15),%esi
; *csum += *next_iph_u16++;
 331:	mov    %rsi,%rdx
 334:	and    $0xffff,%rdx
 33b:	mov    %rsi,%rdi
 33e:	shr    $0x10,%rdi
; *csum += *next_iph_u16++;
 342:	add    %rdx,%rdi
; iph->daddr = iph->saddr;
 345:	mov    0x1a(%r15),%edx
; *csum += *next_iph_u16++;
 349:	mov    %rdx,%rcx
 34c:	and    $0xffff,%rcx
; *csum += *next_iph_u16++;
 353:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 356:	mov    %rdx,%rcx
 359:	shr    $0x10,%rcx
; *csum += *next_iph_u16++;
 35d:	add    %rcx,%rdi
 360:	mov    $0x40,%ecx
; iph->ttl = DEFAULT_TTL;
 365:	mov    %cl,0x16(%r15)
; *csum += *next_iph_u16++;
 369:	movzwq 0xe(%r15),%rcx
; *csum += *next_iph_u16++;
 36e:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 371:	movzwq 0x10(%r15),%rcx
; *csum += *next_iph_u16++;
 376:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 379:	movzwq 0x12(%r15),%rcx
; *csum += *next_iph_u16++;
 37e:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 381:	movzwq 0x14(%r15),%rcx
; *csum += *next_iph_u16++;
 386:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 389:	movzwq 0x16(%r15),%rcx
; *csum += *next_iph_u16++;
 38e:	add    %rcx,%rdi
; if (csum >> 16)
 391:	mov    %rdi,%rcx
 394:	shr    $0x10,%rcx
; if (csum >> 16)
 398:	test   %rcx,%rcx
 39b:	je     0xffffffffc00d237f
 39d:	and    $0xffff,%rdi
 3a4:	add    %rcx,%rdi
; if (csum >> 16)
 3a7:	mov    %rdi,%rcx
 3aa:	shr    $0x10,%rcx
; if (csum >> 16)
 3ae:	test   %rcx,%rcx
 3b1:	je     0xffffffffc00d2395
 3b3:	and    $0xffff,%rdi
 3ba:	add    %rcx,%rdi
; if (csum >> 16)
 3bd:	mov    %rdi,%rcx
 3c0:	shr    $0x10,%rcx
; if (csum >> 16)
 3c4:	test   %rcx,%rcx
 3c7:	je     0xffffffffc00d23ab
 3c9:	and    $0xffff,%rdi
 3d0:	add    %rcx,%rdi
 3d3:	xor    %ecx,%ecx
; 
 3d5:	mov    %cl,0x22(%r15)
 3d9:	mov    %edx,0x1e(%r15)
 3dd:	mov    %esi,0x1a(%r15)
 3e1:	movzwq 0x24(%r15),%rsi
 3e6:	add    $0x8,%rsi
 3ea:	mov    %si,0x24(%r15)
 3ef:	mov    %rdi,%rsi
 3f2:	shr    $0x10,%rsi
 3f6:	add    %rdi,%rsi
 3f9:	xor    $0xffffffffffffffff,%rsi
 3fd:	mov    %si,0x18(%r15)
 402:	movzbq 0xb(%r15),%rdi
 407:	shl    $0x8,%rdi
 40b:	movzbq 0xa(%r15),%rsi
 410:	or     %rsi,%rdi
 413:	mov    %di,-0x74(%rbp)
 417:	movzbq 0x7(%r15),%rdi
 41c:	shl    $0x8,%rdi
 420:	movzbq 0x6(%r15),%rsi
 425:	or     %rsi,%rdi
 428:	movzbq 0x9(%r15),%rsi
 42d:	shl    $0x8,%rsi
 431:	movzbq 0x8(%r15),%rdx
 436:	or     %rdx,%rsi
 439:	shl    $0x10,%rsi
 43d:	or     %rdi,%rsi
 440:	mov    %esi,-0x78(%rbp)
 443:	movzbq 0x2(%r15),%rdi
 448:	mov    %dil,0x8(%r15)
 44c:	movzbq 0x3(%r15),%rdi
 451:	mov    %dil,0x9(%r15)
 455:	movzbq 0x0(%r15),%rdi
 45a:	mov    %dil,0x6(%r15)
 45e:	movzbq 0x1(%r15),%rdi
 463:	mov    %dil,0x7(%r15)
 467:	movzbq 0x4(%r15),%rdi
 46c:	mov    %dil,0xa(%r15)
 470:	movzbq 0x5(%r15),%rdi
 475:	mov    %dil,0xb(%r15)
 479:	mov    -0x78(%rbp),%edi
 47c:	mov    %rdi,%rsi
 47f:	shr    $0x10,%rsi
 483:	mov    %sil,0x2(%r15)
 487:	mov    %rdi,%rsi
 48a:	shr    $0x18,%rsi
 48e:	mov    %sil,0x3(%r15)
 492:	mov    %dil,0x0(%r15)
 496:	shr    $0x8,%rdi
 49a:	mov    %dil,0x1(%r15)
 49e:	movzwq -0x74(%rbp),%rdi
 4a3:	mov    %dil,0x4(%r15)
 4a7:	shr    $0x8,%rdi
 4ab:	mov    %dil,0x5(%r15)
 4af:	mov    $0x3,%r14d
 4b5:	jmp    0xffffffffc00d3477
; if (icmp_hdr + 1 > data_end) {
 4ba:	mov    %r15,%rdi
 4bd:	add    $0x3e,%rdi
; 
 4c1:	mov    $0x1,%r14d
; if (icmp_hdr + 1 > data_end) {
 4c7:	cmp    %r13,%rdi
 4ca:	ja     0xffffffffc00d3477
; if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 4d0:	movzbq 0x0(%rdx),%rdi
; if (icmp_hdr->icmp6_type == ICMPV6_ECHO_REQUEST) {
 4d5:	cmp    $0x1,%rdi
 4d9:	je     0xffffffffc00d2624
 4df:	cmp    $0x2,%rdi
 4e3:	je     0xffffffffc00d25aa
 4e9:	mov    $0x2,%r14d
 4ef:	cmp    $0x80,%rdi
 4f6:	jne    0xffffffffc00d3477
 4fc:	jmp    0xffffffffc00d2154
; if (icmp_hdr + 1 > data_end) {
 501:	mov    %r15,%rsi
 504:	add    $0x2a,%rsi
; 
 508:	mov    $0x1,%r14d
; if (icmp_hdr + 1 > data_end) {
 50e:	cmp    %r13,%rsi
 511:	ja     0xffffffffc00d3477
; if (icmp_hdr->type == ICMP_ECHO) {
 517:	movzbq 0x0(%rdx),%rdi
; if (icmp_hdr->type == ICMP_ECHO) {
 51c:	cmp    $0x3,%rdi
 520:	je     0xffffffffc00d2b23
 526:	mov    $0x2,%r14d
 52c:	cmp    $0x8,%rdi
 530:	jne    0xffffffffc00d3477
; tmp_addr = iph->daddr;
 536:	mov    0x1e(%r15),%esi
; *csum += *next_iph_u16++;
 53a:	mov    %rsi,%rdx
 53d:	and    $0xffff,%rdx
 544:	mov    %rsi,%rdi
 547:	shr    $0x10,%rdi
; *csum += *next_iph_u16++;
 54b:	add    %rdx,%rdi
; iph->daddr = iph->saddr;
 54e:	mov    0x1a(%r15),%edx
; *csum += *next_iph_u16++;
 552:	mov    %rdx,%r8
 555:	and    $0xffff,%r8
; *csum += *next_iph_u16++;
 55c:	add    %r8,%rdi
; *csum += *next_iph_u16++;
 55f:	mov    %rdx,%r8
 562:	shr    $0x10,%r8
; *csum += *next_iph_u16++;
 566:	add    %r8,%rdi
 569:	mov    $0x40,%r8d
; iph->ttl = DEFAULT_TTL;
 56f:	mov    %r8b,0x16(%r15)
; *csum += *next_iph_u16++;
 573:	movzwq 0xe(%r15),%r8
; *csum += *next_iph_u16++;
 578:	add    %r8,%rdi
 57b:	add    %rax,%rdi
; *csum += *next_iph_u16++;
 57e:	movzwq 0x12(%r15),%r8
; *csum += *next_iph_u16++;
 583:	add    %r8,%rdi
 586:	add    %rcx,%rdi
; *csum += *next_iph_u16++;
 589:	movzwq 0x16(%r15),%rcx
; *csum += *next_iph_u16++;
 58e:	add    %rcx,%rdi
; if (csum >> 16)
 591:	mov    %rdi,%rcx
 594:	shr    $0x10,%rcx
; if (csum >> 16)
 598:	test   %rcx,%rcx
 59b:	je     0xffffffffc00d257f
 59d:	and    $0xffff,%rdi
 5a4:	add    %rcx,%rdi
; if (csum >> 16)
 5a7:	mov    %rdi,%rcx
 5aa:	shr    $0x10,%rcx
; if (csum >> 16)
 5ae:	test   %rcx,%rcx
 5b1:	je     0xffffffffc00d2595
 5b3:	and    $0xffff,%rdi
 5ba:	add    %rcx,%rdi
; if (csum >> 16)
 5bd:	mov    %rdi,%rcx
 5c0:	shr    $0x10,%rcx
; if (csum >> 16)
 5c4:	test   %rcx,%rcx
 5c7:	je     0xffffffffc00d23ab
 5cd:	jmp    0xffffffffc00d23a1
 5d2:	mov    %rax,%r14
 5d5:	mov    $0x20c,%edi
; __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
 5da:	mov    %edi,-0x10(%rbp)
 5dd:	mov    %rbp,%rsi
; 
 5e0:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &stats_key);
 5e4:	movabs $0xffff888138844000,%rdi
 5ee:	add    $0x100,%rdi
 5f5:	mov    0x0(%rsi),%eax
 5f8:	cmp    $0x400,%rax
 5ff:	jae    0xffffffffc00d25ef
 601:	shl    $0x3,%rax
 605:	add    %rdi,%rax
 608:	mov    0x0(%rax),%rax
 60c:	add    %gs:0xffffffffbe595028,%rax
 615:	jmp    0xffffffffc00d25f1
 617:	xor    %eax,%eax
; if (!icmp_ptb_v6_stats) {
 619:	test   %rax,%rax
 61c:	je     0xffffffffc00d3471
; icmp_ptb_v6_stats->v1 += 1;
 622:	mov    0x0(%rax),%rdi
 626:	add    $0x1,%rdi
 62a:	mov    %rdi,0x0(%rax)
; __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 62e:	mov    0x3a(%r15),%edi
 632:	bswap  %edi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 634:	cmp    $0x4ff,%rdi
 63b:	ja     0xffffffffc00d2621
; icmp_ptb_v6_stats->v2 += 1;
 63d:	mov    0x8(%rax),%rdi
 641:	add    $0x1,%rdi
 645:	mov    %rdi,0x8(%rax)
 649:	mov    %r14,%rax
; if (ip6h + 1 > data_end) {
 64c:	mov    %r15,%rdi
 64f:	add    $0x66,%rdi
; 
 653:	mov    $0x1,%r14d
; if (ip6h + 1 > data_end) {
 659:	cmp    %r13,%rdi
 65c:	ja     0xffffffffc00d3477
; pckt->flow.proto = ip6h->nexthdr;
 662:	movzbq 0x44(%r15),%rdi
; pckt->flow.proto = ip6h->nexthdr;
 667:	mov    %dil,-0x24(%rbp)
; pckt->flags |= F_ICMP;
 66b:	movzbq -0x1c(%rbp),%rsi
 670:	or     $0x1,%rsi
 674:	mov    %sil,-0x1c(%rbp)
; memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 678:	mov    0x5a(%r15),%edx
 67c:	shl    $0x20,%rdx
 680:	mov    0x56(%r15),%ecx
 684:	or     %rcx,%rdx
 687:	mov    %rdx,-0x48(%rbp)
 68b:	mov    0x62(%r15),%edx
 68f:	shl    $0x20,%rdx
 693:	mov    0x5e(%r15),%ecx
 697:	or     %rcx,%rdx
 69a:	mov    %rdx,-0x40(%rbp)
; memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 69e:	mov    0x4a(%r15),%edx
 6a2:	shl    $0x20,%rdx
 6a6:	mov    0x46(%r15),%ecx
 6aa:	or     %rcx,%rdx
 6ad:	mov    %rdx,-0x38(%rbp)
 6b1:	mov    0x4e(%r15),%edx
 6b5:	mov    0x52(%r15),%ecx
 6b9:	shl    $0x20,%rcx
 6bd:	or     %rdx,%rcx
 6c0:	mov    %rcx,-0x30(%rbp)
; if (protocol == IPPROTO_TCP) {
 6c4:	mov    %rdi,%rdx
 6c7:	cmp    $0x11,%rdx
 6cb:	je     0xffffffffc00d2725
; 
 6d1:	mov    $0x2,%r14d
; if (protocol == IPPROTO_TCP) {
 6d7:	cmp    $0x6,%rdx
 6db:	jne    0xffffffffc00d3477
; bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 6e1:	mov    %rsi,%rcx
 6e4:	and    $0x1,%rcx
 6e8:	mov    $0x36,%r8d
; if (is_ipv6) {
 6ee:	test   %rcx,%rcx
 6f1:	je     0xffffffffc00d26d1
 6f3:	mov    $0x66,%r8d
; tcp = data + off;
 6f9:	mov    %r15,%rdx
 6fc:	add    %r8,%rdx
; if (tcp + 1 > data_end) {
 6ff:	mov    %rdx,%r8
 702:	add    $0x14,%r8
; 
 706:	mov    $0x1,%r14d
; if (tcp + 1 > data_end) {
 70c:	cmp    %r13,%r8
 70f:	ja     0xffffffffc00d3477
; if (tcp->syn) {
 715:	movzwq 0xc(%rdx),%r8
; if (tcp->syn) {
 71a:	and    $0x200,%r8
; if (tcp->syn) {
 721:	test   %r8,%r8
 724:	je     0xffffffffc00d2706
; pckt->flags |= F_SYN_SET;
 726:	or     $0x2,%rsi
 72a:	mov    %sil,-0x1c(%rbp)
 72e:	mov    %rax,-0x80(%rbp)
; if (!is_icmp) {
 732:	test   %rcx,%rcx
 735:	jne    0xffffffffc00d275f
; 
 737:	movzwq 0x0(%rdx),%rsi
 73c:	mov    %si,-0x28(%rbp)
 740:	mov    %rbp,%rcx
 743:	add    $0xffffffffffffffd8,%rcx
 747:	add    $0x2,%rdx
 74b:	jmp    0xffffffffc00d276f
; bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 74d:	and    $0x1,%rsi
 751:	mov    $0x36,%ecx
; if (is_ipv6) {
 756:	test   %rsi,%rsi
 759:	je     0xffffffffc00d2738
 75b:	mov    $0x66,%ecx
; udp = data + off;
 760:	mov    %r15,%rdx
 763:	add    %rcx,%rdx
; if (udp + 1 > data_end) {
 766:	mov    %rdx,%rcx
 769:	add    $0x8,%rcx
; 
 76d:	mov    $0x1,%r14d
; if (udp + 1 > data_end) {
 773:	cmp    %r13,%rcx
 776:	ja     0xffffffffc00d3477
 77c:	mov    %rax,-0x80(%rbp)
; if (!is_icmp) {
 780:	test   %rsi,%rsi
 783:	jne    0xffffffffc00d275f
 785:	jmp    0xffffffffc00d270f
; 
 787:	movzwq 0x2(%rdx),%rsi
 78c:	mov    %si,-0x28(%rbp)
 790:	mov    %rbp,%rcx
 793:	add    $0xffffffffffffffd8,%rcx
 797:	movzwq 0x0(%rdx),%rsi
 79c:	mov    %rcx,-0x88(%rbp)
 7a3:	mov    %si,0x2(%rcx)
; vip.proto = pckt.flow.proto;
 7a7:	mov    %dil,-0x4e(%rbp)
; vip.port = pckt.flow.port16[1];
 7ab:	mov    %si,-0x50(%rbp)
; memcpy(vip.vipv6, pckt.flow.dstv6, 16);
 7af:	mov    -0x30(%rbp),%rdi
 7b3:	mov    %rdi,-0x58(%rbp)
 7b7:	mov    -0x38(%rbp),%rdi
 7bb:	mov    %rdi,-0x60(%rbp)
 7bf:	mov    %rbp,%rsi
; 
 7c2:	add    $0xffffffffffffffa0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 7c6:	movabs $0xffff8881583c1000,%rdi
 7d0:	call   0xffffffffb88bb9b0
 7d5:	test   %rax,%rax
 7d8:	je     0xffffffffc00d27b6
 7da:	add    $0x48,%rax
; if (!vip_info) {
 7de:	test   %rax,%rax
 7e1:	jne    0xffffffffc00d2813
 7e3:	xor    %edi,%edi
; vip.port = 0;
 7e5:	mov    %di,-0x50(%rbp)
 7e9:	mov    %rbp,%rsi
 7ec:	add    $0xffffffffffffffa0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 7f0:	movabs $0xffff8881583c1000,%rdi
 7fa:	call   0xffffffffb88bb9b0
 7ff:	test   %rax,%rax
 802:	je     0xffffffffc00d27e0
 804:	add    $0x48,%rax
; 
 808:	mov    $0x2,%r14d
 80e:	mov    -0x80(%rbp),%rdi
; if (!vip_info) {
 812:	test   %rax,%rax
 815:	je     0xffffffffc00d3477
 81b:	mov    %rdi,-0x80(%rbp)
; if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 81f:	mov    0x0(%rax),%edi
; if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 822:	and    $0x88,%rdi
 829:	test   %rdi,%rdi
 82c:	jne    0xffffffffc00d2813
 82e:	xor    %edi,%edi
; pckt.flow.port16[1] = 0;
 830:	mov    -0x88(%rbp),%rsi
 837:	mov    %di,0x2(%rsi)
; if (data_end - data > MAX_PCKT_SIZE) {
 83b:	mov    %r13,%rdi
 83e:	sub    %r15,%rdi
; 
 841:	mov    $0x1,%r14d
 847:	mov    -0x80(%rbp),%rsi
; if (data_end - data > MAX_PCKT_SIZE) {
 84b:	cmp    $0x5ea,%rdi
 852:	jg     0xffffffffc00d3477
 858:	mov    %rax,-0x90(%rbp)
 85f:	mov    %rsi,-0x80(%rbp)
 863:	mov    $0x200,%edi
; __u32 stats_key = MAX_VIPS + LRU_CNTRS;
 868:	mov    %edi,-0x6c(%rbp)
 86b:	mov    %rbp,%rsi
; 
 86e:	add    $0xffffffffffffff94,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 872:	movabs $0xffff888138844000,%rdi
 87c:	add    $0x100,%rdi
 883:	mov    0x0(%rsi),%eax
 886:	cmp    $0x400,%rax
 88d:	jae    0xffffffffc00d287d
 88f:	shl    $0x3,%rax
 893:	add    %rdi,%rax
 896:	mov    0x0(%rax),%rax
 89a:	add    %gs:0xffffffffbe595028,%rax
 8a3:	jmp    0xffffffffc00d287f
 8a5:	xor    %eax,%eax
 8a7:	mov    $0x1,%r14d
; if (!data_stats) {
 8ad:	test   %rax,%rax
 8b0:	je     0xffffffffc00d3477
; data_stats->v1 += 1;
 8b6:	mov    0x0(%rax),%rdi
 8ba:	add    $0x1,%rdi
 8be:	mov    %rax,-0xa0(%rbp)
 8c5:	mov    %rdi,0x0(%rax)
 8c9:	mov    -0x90(%rbp),%r14
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 8d0:	mov    0x0(%r14),%edi
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 8d4:	and    $0x1,%rdi
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 8d8:	test   %rdi,%rdi
 8db:	je     0xffffffffc00d28bb
 8dd:	xor    %edi,%edi
; pckt.flow.port16[0] = 0;
 8df:	mov    %di,-0x28(%rbp)
; vip_num = vip_info->vip_num;
 8e3:	mov    0x4(%r14),%edi
; vip_num = vip_info->vip_num;
 8e7:	mov    %edi,-0x64(%rbp)
; __u32 cpu_num = bpf_get_smp_processor_id();
 8ea:	mov    $0xffffffffbe595034,%rax
 8f1:	add    %gs:0xffffffffbe595028,%rax
 8fa:	mov    0x0(%rax),%eax
; __u32 cpu_num = bpf_get_smp_processor_id();
 8fd:	mov    %eax,-0x70(%rbp)
 900:	mov    %rbp,%rsi
; vip_num = vip_info->vip_num;
 903:	add    $0xffffffffffffff90,%rsi
; void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 907:	movabs $0xffff8881583d0000,%rdi
 911:	add    $0x100,%rdi
 918:	mov    0x0(%rsi),%eax
 91b:	cmp    $0x80,%rax
 922:	jae    0xffffffffc00d290e
 924:	shl    $0x3,%rax
 928:	add    %rdi,%rax
 92b:	mov    0x0(%rax),%rax
 92f:	test   %rax,%rax
 932:	je     0xffffffffc00d290e
 934:	jmp    0xffffffffc00d2910
 936:	xor    %eax,%eax
; if (!lru_map) {
 938:	test   %rax,%rax
 93b:	jne    0xffffffffc00d297f
 93d:	mov    $0x203,%edi
; __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
 942:	mov    %edi,-0x10(%rbp)
 945:	mov    %rbp,%rsi
; 
 948:	add    $0xfffffffffffffff0,%rsi
; struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
 94c:	movabs $0xffff888138844000,%rdi
 956:	add    $0x100,%rdi
 95d:	mov    0x0(%rsi),%eax
 960:	cmp    $0x400,%rax
 967:	jae    0xffffffffc00d2957
 969:	shl    $0x3,%rax
 96d:	add    %rdi,%rax
 970:	mov    0x0(%rax),%rax
 974:	add    %gs:0xffffffffbe595028,%rax
 97d:	jmp    0xffffffffc00d2959
 97f:	xor    %eax,%eax
; if (!lru_stats) {
 981:	test   %rax,%rax
 984:	je     0xffffffffc00d3471
; lru_stats->v1 += 1;
 98a:	mov    0x0(%rax),%rdi
 98e:	add    $0x1,%rdi
 992:	mov    %rdi,0x0(%rax)
 996:	movabs $0xffff8881583c1800,%rax
 9a0:	mov    -0x90(%rbp),%r14
 9a7:	mov    %rax,-0x98(%rbp)
; if ((vip_info->flags & F_QUIC_VIP)) {
 9ae:	mov    0x0(%r14),%edi
; if ((vip_info->flags & F_QUIC_VIP)) {
 9b2:	and    $0x4,%rdi
 9b6:	mov    %r14,%rsi
; if ((vip_info->flags & F_QUIC_VIP)) {
 9b9:	test   %rdi,%rdi
 9bc:	je     0xffffffffc00d34ae
; bool is_icmp = (pckt.flags & F_ICMP);
 9c2:	movzbq -0x1c(%rbp),%rdi
; bool is_icmp = (pckt.flags & F_ICMP);
 9c7:	and    $0x1,%rdi
; if (is_icmp) {
 9cb:	test   %rdi,%rdi
 9ce:	je     0xffffffffc00d30a4
 9d4:	mov    $0x20b,%edi
; __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
 9d9:	mov    %edi,-0x10(%rbp)
 9dc:	mov    %rbp,%rsi
; 
 9df:	add    $0xfffffffffffffff0,%rsi
; struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 9e3:	movabs $0xffff888138844000,%rdi
 9ed:	add    $0x100,%rdi
 9f4:	mov    0x0(%rsi),%eax
 9f7:	cmp    $0x400,%rax
 9fe:	jae    0xffffffffc00d29ee
 a00:	shl    $0x3,%rax
 a04:	add    %rdi,%rax
 a07:	mov    0x0(%rax),%rax
 a0b:	add    %gs:0xffffffffbe595028,%rax
 a14:	jmp    0xffffffffc00d29f0
 a16:	xor    %eax,%eax
; if (!data_stats) {
 a18:	test   %rax,%rax
 a1b:	je     0xffffffffc00d3471
; data_stats->v1 += 1;
 a21:	mov    0x0(%rax),%rdi
 a25:	add    $0x1,%rdi
 a29:	mov    %rdi,0x0(%rax)
; (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
 a2d:	movzbq 0x37(%r15),%rdi
; (icmp_hdr->icmp6_code == ICMPV6_ADDR_UNREACH) ||
 a32:	add    $0xfffffffffffffffd,%rdi
 a36:	and    $0xff,%rdi
 a3d:	mov    -0x90(%rbp),%rsi
; if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
 a44:	cmp    $0x1,%rdi
 a48:	ja     0xffffffffc00d34ae
; data_stats->v2 += 1;
 a4e:	mov    0x8(%rax),%rdi
 a52:	add    $0x1,%rdi
 a56:	mov    %rdi,0x8(%rax)
 a5a:	jmp    0xffffffffc00d34ae
; if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 a5f:	movzbq 0x37(%r15),%rdi
; if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 a64:	cmp    $0x4,%rdi
 a68:	jne    0xffffffffc00d2acb
 a6e:	mov    %rsi,-0x80(%rbp)
 a72:	mov    %rax,%r14
 a75:	mov    $0x20d,%edi
; __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
 a7a:	mov    %edi,-0x10(%rbp)
 a7d:	mov    %rbp,%rsi
; 
 a80:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &stats_key);
 a84:	movabs $0xffff888138844000,%rdi
 a8e:	add    $0x100,%rdi
 a95:	mov    0x0(%rsi),%eax
 a98:	cmp    $0x400,%rax
 a9f:	jae    0xffffffffc00d2a8f
 aa1:	shl    $0x3,%rax
 aa5:	add    %rdi,%rax
 aa8:	mov    0x0(%rax),%rax
 aac:	add    %gs:0xffffffffbe595028,%rax
 ab5:	jmp    0xffffffffc00d2a91
 ab7:	xor    %eax,%eax
; if (!icmp_ptb_v4_stats) {
 ab9:	test   %rax,%rax
 abc:	je     0xffffffffc00d3471
; icmp_ptb_v4_stats->v1 += 1;
 ac2:	mov    0x0(%rax),%rdi
 ac6:	add    $0x1,%rdi
 aca:	mov    %rdi,0x0(%rax)
; __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);
 ace:	movzwq 0x3c(%r15),%rdi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 ad3:	and    $0xff,%rdi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 ada:	cmp    $0x4,%rdi
 ade:	ja     0xffffffffc00d2ac4
; icmp_ptb_v4_stats->v2 += 1;
 ae0:	mov    0x8(%rax),%rdi
 ae4:	add    $0x1,%rdi
 ae8:	mov    %rdi,0x8(%rax)
 aec:	mov    %r14,%rax
 aef:	mov    -0x80(%rbp),%rsi
; if (iph + 1 > data_end) {
 af3:	mov    %r15,%rdi
 af6:	add    $0x52,%rdi
; 
 afa:	mov    $0x1,%r14d
; if (iph + 1 > data_end) {
 b00:	cmp    %r13,%rdi
 b03:	ja     0xffffffffc00d3477
; if (iph->ihl != 5) {
 b09:	movzbq 0x0(%rsi),%rdi
 b0e:	and    $0xf,%rdi
; 
 b12:	mov    $0x1,%r14d
; if (iph->ihl != 5) {
 b18:	cmp    $0x5,%rdi
 b1c:	jne    0xffffffffc00d3477
; pckt->flow.proto = iph->protocol;
 b22:	movzbq 0x47(%r15),%rdi
; pckt->flow.proto = iph->protocol;
 b27:	mov    %dil,-0x24(%rbp)
; pckt->flags |= F_ICMP;
 b2b:	movzbq -0x1c(%rbp),%rsi
 b30:	or     $0x1,%rsi
 b34:	mov    %sil,-0x1c(%rbp)
; pckt->flow.src = iph->daddr;
 b38:	mov    0x4e(%r15),%edx
; pckt->flow.src = iph->daddr;
 b3c:	mov    %edx,-0x48(%rbp)
; pckt->flow.dst = iph->saddr;
 b3f:	mov    0x4a(%r15),%edx
; pckt->flow.dst = iph->saddr;
 b43:	mov    %edx,-0x38(%rbp)
 b46:	jmp    0xffffffffc00d269c
; if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 b4b:	movzbq 0x23(%r15),%rdi
; if (icmp_hdr->code == ICMP_FRAG_NEEDED) {
 b50:	cmp    $0x4,%rdi
 b54:	jne    0xffffffffc00d2bb7
 b5a:	mov    %rsi,-0x80(%rbp)
 b5e:	mov    %rax,%r14
 b61:	mov    $0x20d,%edi
; __u32 stats_key = MAX_VIPS + ICMP_PTB_V4_STATS;
 b66:	mov    %edi,-0x10(%rbp)
 b69:	mov    %rbp,%rsi
; 
 b6c:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &stats_key);
 b70:	movabs $0xffff888138844000,%rdi
 b7a:	add    $0x100,%rdi
 b81:	mov    0x0(%rsi),%eax
 b84:	cmp    $0x400,%rax
 b8b:	jae    0xffffffffc00d2b7b
 b8d:	shl    $0x3,%rax
 b91:	add    %rdi,%rax
 b94:	mov    0x0(%rax),%rax
 b98:	add    %gs:0xffffffffbe595028,%rax
 ba1:	jmp    0xffffffffc00d2b7d
 ba3:	xor    %eax,%eax
; if (!icmp_ptb_v4_stats) {
 ba5:	test   %rax,%rax
 ba8:	je     0xffffffffc00d3471
; icmp_ptb_v4_stats->v1 += 1;
 bae:	mov    0x0(%rax),%rdi
 bb2:	add    $0x1,%rdi
 bb6:	mov    %rdi,0x0(%rax)
; __u16 mtu = bpf_ntohs(icmp_hdr->un.frag.mtu);
 bba:	movzwq 0x28(%r15),%rdi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 bbf:	and    $0xff,%rdi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 bc6:	cmp    $0x4,%rdi
 bca:	ja     0xffffffffc00d2bb0
; icmp_ptb_v4_stats->v2 += 1;
 bcc:	mov    0x8(%rax),%rdi
 bd0:	add    $0x1,%rdi
 bd4:	mov    %rdi,0x8(%rax)
 bd8:	mov    %r14,%rax
 bdb:	mov    -0x80(%rbp),%rsi
; if (iph + 1 > data_end) {
 bdf:	mov    %r15,%rdi
 be2:	add    $0x3e,%rdi
; 
 be6:	mov    $0x1,%r14d
; if (iph + 1 > data_end) {
 bec:	cmp    %r13,%rdi
 bef:	ja     0xffffffffc00d3477
; if (iph->ihl != 5) {
 bf5:	movzbq 0x0(%rsi),%rdi
 bfa:	and    $0xf,%rdi
; 
 bfe:	mov    $0x1,%r14d
; if (iph->ihl != 5) {
 c04:	cmp    $0x5,%rdi
 c08:	jne    0xffffffffc00d3477
; pckt->flow.proto = iph->protocol;
 c0e:	movzbq 0x33(%r15),%rdi
; pckt->flow.proto = iph->protocol;
 c13:	mov    %dil,-0x24(%rbp)
; pckt->flags |= F_ICMP;
 c17:	movzbq -0x1c(%rbp),%rsi
 c1c:	or     $0x1,%rsi
 c20:	mov    %sil,-0x1c(%rbp)
; pckt->flow.src = iph->daddr;
 c24:	mov    0x3a(%r15),%edx
; pckt->flow.src = iph->daddr;
 c28:	mov    %edx,-0x48(%rbp)
; pckt->flow.dst = iph->saddr;
 c2b:	mov    0x36(%r15),%edx
; pckt->flow.dst = iph->saddr;
 c2f:	mov    %edx,-0x38(%rbp)
 c32:	jmp    0xffffffffc00d2cfe
 c37:	mov    %rax,%r14
 c3a:	mov    $0x20c,%edi
; __u32 stats_key = MAX_VIPS + ICMP_PTB_V6_STATS;
 c3f:	mov    %edi,-0x10(%rbp)
 c42:	mov    %rbp,%rsi
; 
 c45:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &stats_key);
 c49:	movabs $0xffff888138844000,%rdi
 c53:	add    $0x100,%rdi
 c5a:	mov    0x0(%rsi),%eax
 c5d:	cmp    $0x400,%rax
 c64:	jae    0xffffffffc00d2c54
 c66:	shl    $0x3,%rax
 c6a:	add    %rdi,%rax
 c6d:	mov    0x0(%rax),%rax
 c71:	add    %gs:0xffffffffbe595028,%rax
 c7a:	jmp    0xffffffffc00d2c56
 c7c:	xor    %eax,%eax
; if (!icmp_ptb_v6_stats) {
 c7e:	test   %rax,%rax
 c81:	je     0xffffffffc00d3471
; icmp_ptb_v6_stats->v1 += 1;
 c87:	mov    0x0(%rax),%rdi
 c8b:	add    $0x1,%rdi
 c8f:	mov    %rdi,0x0(%rax)
; __u32 mtu = bpf_ntohl(icmp_hdr->icmp6_mtu);
 c93:	mov    0x26(%r15),%edi
 c97:	bswap  %edi
; if (mtu < MAX_MTU_IN_PTB_TO_DROP) {
 c99:	cmp    $0x4ff,%rdi
 ca0:	ja     0xffffffffc00d2c86
; icmp_ptb_v6_stats->v2 += 1;
 ca2:	mov    0x8(%rax),%rdi
 ca6:	add    $0x1,%rdi
 caa:	mov    %rdi,0x8(%rax)
 cae:	mov    %r14,%rax
; if (ip6h + 1 > data_end) {
 cb1:	mov    %r15,%rdi
 cb4:	add    $0x52,%rdi
; 
 cb8:	mov    $0x1,%r14d
; if (ip6h + 1 > data_end) {
 cbe:	cmp    %r13,%rdi
 cc1:	ja     0xffffffffc00d3477
; 
 cc7:	mov    %rbp,%rdx
 cca:	add    $0xffffffffffffffc8,%rdx
; pckt->flow.proto = ip6h->nexthdr;
 cce:	movzbq 0x30(%r15),%rdi
; pckt->flow.proto = ip6h->nexthdr;
 cd3:	mov    %dil,-0x24(%rbp)
; pckt->flags |= F_ICMP;
 cd7:	movzbq -0x1c(%rbp),%rsi
 cdc:	or     $0x1,%rsi
 ce0:	mov    %sil,-0x1c(%rbp)
; memcpy(pckt->flow.srcv6, ip6h->daddr.s6_addr32, 16);
 ce4:	mov    0x4e(%r15),%ecx
 ce8:	shl    $0x20,%rcx
 cec:	mov    0x4a(%r15),%r8d
 cf0:	or     %r8,%rcx
 cf3:	mov    %rcx,-0x40(%rbp)
 cf7:	mov    0x46(%r15),%ecx
 cfb:	shl    $0x20,%rcx
 cff:	mov    0x42(%r15),%r8d
 d03:	or     %r8,%rcx
 d06:	mov    %rcx,-0x48(%rbp)
; memcpy(pckt->flow.dstv6, ip6h->saddr.s6_addr32, 16);
 d0a:	mov    0x3a(%r15),%ecx
 d0e:	mov    %ecx,0x8(%rdx)
 d11:	mov    0x3e(%r15),%ecx
 d15:	mov    %ecx,0xc(%rdx)
 d18:	mov    0x32(%r15),%ecx
 d1c:	mov    %ecx,0x0(%rdx)
 d1f:	mov    0x36(%r15),%ecx
 d23:	mov    %ecx,0x4(%rdx)
; if (protocol == IPPROTO_TCP) {
 d26:	mov    %rdi,%rdx
 d29:	cmp    $0x11,%rdx
 d2d:	je     0xffffffffc00d2d87
; 
 d33:	mov    $0x2,%r14d
; if (protocol == IPPROTO_TCP) {
 d39:	cmp    $0x6,%rdx
 d3d:	jne    0xffffffffc00d3477
; bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 d43:	mov    %rsi,%rcx
 d46:	and    $0x1,%rcx
 d4a:	mov    $0x22,%r8d
; if (is_ipv6) {
 d50:	test   %rcx,%rcx
 d53:	je     0xffffffffc00d2d33
 d55:	mov    $0x3e,%r8d
; tcp = data + off;
 d5b:	mov    %r15,%rdx
 d5e:	add    %r8,%rdx
; if (tcp + 1 > data_end) {
 d61:	mov    %rdx,%r8
 d64:	add    $0x14,%r8
; 
 d68:	mov    $0x1,%r14d
; if (tcp + 1 > data_end) {
 d6e:	cmp    %r13,%r8
 d71:	ja     0xffffffffc00d3477
; if (tcp->syn) {
 d77:	movzwq 0xc(%rdx),%r8
; if (tcp->syn) {
 d7c:	and    $0x200,%r8
; if (tcp->syn) {
 d83:	test   %r8,%r8
 d86:	je     0xffffffffc00d2d68
; pckt->flags |= F_SYN_SET;
 d88:	or     $0x2,%rsi
 d8c:	mov    %sil,-0x1c(%rbp)
 d90:	mov    %rax,-0x80(%rbp)
; if (!is_icmp) {
 d94:	mov    %rbp,%r8
 d97:	add    $0xffffffffffffffd8,%r8
 d9b:	test   %rcx,%rcx
 d9e:	jne    0xffffffffc00d2dd5
; pckt->flow.port16[0] = tcp->source;
 da0:	movzwq 0x0(%rdx),%rsi
; pckt->flow.port16[0] = tcp->source;
 da5:	mov    %si,-0x28(%rbp)
; pckt->flow.port16[1] = tcp->dest;
 da9:	add    $0x2,%rdx
 dad:	jmp    0xffffffffc00d2df0
; bool is_icmp = !((pckt->flags & F_ICMP) == 0);
 daf:	and    $0x1,%rsi
 db3:	mov    $0x22,%ecx
; if (is_ipv6) {
 db8:	test   %rsi,%rsi
 dbb:	je     0xffffffffc00d2d9a
 dbd:	mov    $0x3e,%ecx
; udp = data + off;
 dc2:	mov    %r15,%rdx
 dc5:	add    %rcx,%rdx
; if (udp + 1 > data_end) {
 dc8:	mov    %rdx,%rcx
 dcb:	add    $0x8,%rcx
; 
 dcf:	mov    $0x1,%r14d
; if (udp + 1 > data_end) {
 dd5:	cmp    %r13,%rcx
 dd8:	ja     0xffffffffc00d3477
 dde:	mov    %rax,-0x80(%rbp)
; if (!is_icmp) {
 de2:	test   %rsi,%rsi
 de5:	jne    0xffffffffc00d2de0
; pckt->flow.port16[0] = udp->source;
 de7:	movzwq 0x0(%rdx),%rsi
; pckt->flow.port16[0] = udp->source;
 dec:	mov    %si,-0x28(%rbp)
; pckt->flow.port16[0] = udp->source;
 df0:	mov    %rbp,%r8
 df3:	add    $0xffffffffffffffd8,%r8
; pckt->flow.port16[1] = udp->dest;
 df7:	add    $0x2,%rdx
 dfb:	jmp    0xffffffffc00d2df0
; pckt->flow.port16[0] = tcp->dest;
 dfd:	movzwq 0x2(%rdx),%rsi
; pckt->flow.port16[0] = tcp->dest;
 e02:	mov    %si,-0x28(%rbp)
 e06:	jmp    0xffffffffc00d2df0
; pckt->flow.port16[0] = udp->dest;
 e08:	movzwq 0x2(%rdx),%rsi
; pckt->flow.port16[0] = udp->dest;
 e0d:	mov    %si,-0x28(%rbp)
; pckt->flow.port16[0] = udp->dest;
 e11:	mov    %rbp,%r8
 e14:	add    $0xffffffffffffffd8,%r8
; 
 e18:	movzwq 0x0(%rdx),%rsi
 e1d:	mov    %r8,-0x88(%rbp)
 e24:	mov    %si,0x2(%r8)
; vip.proto = pckt.flow.proto;
 e29:	mov    %dil,-0x4e(%rbp)
; vip.port = pckt.flow.port16[1];
 e2d:	mov    %si,-0x50(%rbp)
; vip.vip = pckt.flow.dst;
 e31:	mov    -0x38(%rbp),%edi
; vip.vip = pckt.flow.dst;
 e34:	mov    %edi,-0x60(%rbp)
 e37:	mov    %rbp,%rsi
; 
 e3a:	add    $0xffffffffffffffa0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 e3e:	movabs $0xffff8881583c1000,%rdi
 e48:	call   0xffffffffb88bb9b0
 e4d:	test   %rax,%rax
 e50:	je     0xffffffffc00d2e2e
 e52:	add    $0x48,%rax
; if (!vip_info) {
 e56:	test   %rax,%rax
 e59:	jne    0xffffffffc00d2e8b
 e5b:	xor    %edi,%edi
; vip.port = 0;
 e5d:	mov    %di,-0x50(%rbp)
 e61:	mov    %rbp,%rsi
 e64:	add    $0xffffffffffffffa0,%rsi
; vip_info = bpf_map_lookup_elem(&vip_map, &vip);
 e68:	movabs $0xffff8881583c1000,%rdi
 e72:	call   0xffffffffb88bb9b0
 e77:	test   %rax,%rax
 e7a:	je     0xffffffffc00d2e58
 e7c:	add    $0x48,%rax
; 
 e80:	mov    $0x2,%r14d
 e86:	mov    -0x80(%rbp),%rdi
; if (!vip_info) {
 e8a:	test   %rax,%rax
 e8d:	je     0xffffffffc00d3477
 e93:	mov    %rdi,-0x80(%rbp)
; if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 e97:	mov    0x0(%rax),%edi
; if (!(vip_info->flags & F_HASH_DPORT_ONLY) &&
 e9a:	and    $0x88,%rdi
 ea1:	test   %rdi,%rdi
 ea4:	jne    0xffffffffc00d2e8b
 ea6:	xor    %edi,%edi
; pckt.flow.port16[1] = 0;
 ea8:	mov    -0x88(%rbp),%rsi
 eaf:	mov    %di,0x2(%rsi)
; if (data_end - data > MAX_PCKT_SIZE) {
 eb3:	mov    %r13,%rdi
 eb6:	sub    %r15,%rdi
; 
 eb9:	mov    $0x1,%r14d
 ebf:	mov    -0x80(%rbp),%rsi
; if (data_end - data > MAX_PCKT_SIZE) {
 ec3:	cmp    $0x5ea,%rdi
 eca:	jg     0xffffffffc00d3477
 ed0:	mov    %rax,-0x90(%rbp)
 ed7:	mov    %rsi,-0x80(%rbp)
 edb:	mov    $0x200,%edi
; __u32 stats_key = MAX_VIPS + LRU_CNTRS;
 ee0:	mov    %edi,-0x6c(%rbp)
 ee3:	mov    %rbp,%rsi
; 
 ee6:	add    $0xffffffffffffff94,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &stats_key);
 eea:	movabs $0xffff888138844000,%rdi
 ef4:	add    $0x100,%rdi
 efb:	mov    0x0(%rsi),%eax
 efe:	cmp    $0x400,%rax
 f05:	jae    0xffffffffc00d2ef5
 f07:	shl    $0x3,%rax
 f0b:	add    %rdi,%rax
 f0e:	mov    0x0(%rax),%rax
 f12:	add    %gs:0xffffffffbe595028,%rax
 f1b:	jmp    0xffffffffc00d2ef7
 f1d:	xor    %eax,%eax
 f1f:	mov    $0x1,%r14d
; if (!data_stats) {
 f25:	test   %rax,%rax
 f28:	je     0xffffffffc00d3477
; data_stats->v1 += 1;
 f2e:	mov    0x0(%rax),%rdi
 f32:	add    $0x1,%rdi
 f36:	mov    %rax,-0xa0(%rbp)
 f3d:	mov    %rdi,0x0(%rax)
 f41:	mov    -0x90(%rbp),%r14
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 f48:	mov    0x0(%r14),%edi
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 f4c:	and    $0x1,%rdi
; if ((vip_info->flags & F_HASH_NO_SRC_PORT)) {
 f50:	test   %rdi,%rdi
 f53:	je     0xffffffffc00d2f33
 f55:	xor    %edi,%edi
; pckt.flow.port16[0] = 0;
 f57:	mov    %di,-0x28(%rbp)
; vip_num = vip_info->vip_num;
 f5b:	mov    0x4(%r14),%edi
; vip_num = vip_info->vip_num;
 f5f:	mov    %edi,-0x64(%rbp)
; __u32 cpu_num = bpf_get_smp_processor_id();
 f62:	mov    $0xffffffffbe595034,%rax
 f69:	add    %gs:0xffffffffbe595028,%rax
 f72:	mov    0x0(%rax),%eax
; __u32 cpu_num = bpf_get_smp_processor_id();
 f75:	mov    %eax,-0x70(%rbp)
 f78:	mov    %rbp,%rsi
; vip_num = vip_info->vip_num;
 f7b:	add    $0xffffffffffffff90,%rsi
; void* lru_map = bpf_map_lookup_elem(&lru_mapping, &cpu_num);
 f7f:	movabs $0xffff8881583d0000,%rdi
 f89:	add    $0x100,%rdi
 f90:	mov    0x0(%rsi),%eax
 f93:	cmp    $0x80,%rax
 f9a:	jae    0xffffffffc00d2f86
 f9c:	shl    $0x3,%rax
 fa0:	add    %rdi,%rax
 fa3:	mov    0x0(%rax),%rax
 fa7:	test   %rax,%rax
 faa:	je     0xffffffffc00d2f86
 fac:	jmp    0xffffffffc00d2f88
 fae:	xor    %eax,%eax
; if (!lru_map) {
 fb0:	test   %rax,%rax
 fb3:	jne    0xffffffffc00d2ff7
 fb5:	mov    $0x203,%edi
; __u32 lru_stats_key = MAX_VIPS + FALLBACK_LRU_CNTR;
 fba:	mov    %edi,-0x10(%rbp)
 fbd:	mov    %rbp,%rsi
; 
 fc0:	add    $0xfffffffffffffff0,%rsi
; struct lb_stats* lru_stats = bpf_map_lookup_elem(&stats, &lru_stats_key);
 fc4:	movabs $0xffff888138844000,%rdi
 fce:	add    $0x100,%rdi
 fd5:	mov    0x0(%rsi),%eax
 fd8:	cmp    $0x400,%rax
 fdf:	jae    0xffffffffc00d2fcf
 fe1:	shl    $0x3,%rax
 fe5:	add    %rdi,%rax
 fe8:	mov    0x0(%rax),%rax
 fec:	add    %gs:0xffffffffbe595028,%rax
 ff5:	jmp    0xffffffffc00d2fd1
 ff7:	xor    %eax,%eax
; if (!lru_stats) {
 ff9:	test   %rax,%rax
 ffc:	je     0xffffffffc00d3471
; lru_stats->v1 += 1;
1002:	mov    0x0(%rax),%rdi
1006:	add    $0x1,%rdi
100a:	mov    %rdi,0x0(%rax)
100e:	movabs $0xffff8881583c1800,%rax
1018:	mov    -0x90(%rbp),%r14
101f:	mov    %rax,-0x98(%rbp)
; if ((vip_info->flags & F_QUIC_VIP)) {
1026:	mov    0x0(%r14),%edi
; if ((vip_info->flags & F_QUIC_VIP)) {
102a:	and    $0x4,%rdi
102e:	mov    %r14,%rsi
; if ((vip_info->flags & F_QUIC_VIP)) {
1031:	test   %rdi,%rdi
1034:	je     0xffffffffc00d4444
; bool is_icmp = (pckt.flags & F_ICMP);
103a:	movzbq -0x1c(%rbp),%rdi
; bool is_icmp = (pckt.flags & F_ICMP);
103f:	and    $0x1,%rdi
; if (is_icmp) {
1043:	test   %rdi,%rdi
1046:	je     0xffffffffc00d316d
104c:	mov    $0x20b,%edi
; __u32 stats_key = MAX_VIPS + QUIC_ICMP_STATS;
1051:	mov    %edi,-0x10(%rbp)
1054:	mov    %rbp,%rsi
; 
1057:	add    $0xfffffffffffffff0,%rsi
; struct lb_stats* data_stats = bpf_map_lookup_elem(&stats, &stats_key);
105b:	movabs $0xffff888138844000,%rdi
1065:	add    $0x100,%rdi
106c:	mov    0x0(%rsi),%eax
106f:	cmp    $0x400,%rax
1076:	jae    0xffffffffc00d3066
1078:	shl    $0x3,%rax
107c:	add    %rdi,%rax
107f:	mov    0x0(%rax),%rax
1083:	add    %gs:0xffffffffbe595028,%rax
108c:	jmp    0xffffffffc00d3068
108e:	xor    %eax,%eax
; if (!data_stats) {
1090:	test   %rax,%rax
1093:	je     0xffffffffc00d3471
; data_stats->v1 += 1;
1099:	mov    0x0(%rax),%rdi
109d:	add    $0x1,%rdi
10a1:	mov    %rdi,0x0(%rax)
; (icmp_hdr->code == ICMP_PORT_UNREACH) ||
10a5:	movzbq 0x23(%r15),%rdi
; (icmp_hdr->code == ICMP_PORT_UNREACH) ||
10aa:	and    $0xfd,%rdi
; if (ignorable_quic_icmp_code(data, data_end, is_ipv6)) {
10b1:	cmp    $0x1,%rdi
10b5:	jne    0xffffffffc00d443d
; data_stats->v2 += 1;
10bb:	mov    0x8(%rax),%rdi
10bf:	add    $0x1,%rdi
10c3:	mov    %rdi,0x8(%rax)
10c7:	jmp    0xffffffffc00d443d
10cc:	xor    %edi,%edi
; __u32 quic_packets_stats_key = 0;
10ce:	mov    %edi,-0x78(%rbp)
10d1:	mov    %rbp,%rsi
; 
10d4:	add    $0xffffffffffffff88,%rsi
; bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
10d8:	movabs $0xffff8881064d4400,%rdi
10e2:	add    $0x100,%rdi
10e9:	mov    0x0(%rsi),%eax
10ec:	cmp    $0x1,%rax
10f0:	jae    0xffffffffc00d30e0
10f2:	shl    $0x3,%rax
10f6:	add    %rdi,%rax
10f9:	mov    0x0(%rax),%rax
10fd:	add    %gs:0xffffffffbe595028,%rax
1106:	jmp    0xffffffffc00d30e2
1108:	xor    %eax,%eax
110a:	mov    %rax,%r14
; if (!quic_packets_stats) {
110d:	test   %r14,%r14
1110:	je     0xffffffffc00d3471
; bool is_icmp = (pckt->flags & F_ICMP);
1116:	movzbq -0x1c(%rbp),%rsi
; bool is_icmp = (pckt->flags & F_ICMP);
111b:	and    $0x1,%rsi
111f:	mov    $0x36,%edi
; if (is_ipv6) {
1124:	test   %rsi,%rsi
1127:	je     0xffffffffc00d3106
1129:	mov    $0x66,%edi
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
112e:	add    %rdi,%r15
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
1131:	mov    %r15,%rdi
1134:	add    $0x9,%rdi
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
1138:	cmp    %r13,%rdi
113b:	ja     0xffffffffc00d349b
; 
1141:	add    $0x8,%r15
; if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
1145:	movzbq 0x0(%r15),%rsi
114a:	shl    $0x38,%rsi
114e:	sar    $0x38,%rsi
; if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
1152:	cmp    $0xffffffffffffffff,%rsi
1156:	jg     0xffffffffc00d3233
; if (quic_data + sizeof(struct quic_long_header) > data_end) {
115c:	mov    %r15,%rdi
115f:	add    $0xe,%rdi
; if (quic_data + sizeof(struct quic_long_header) > data_end) {
1163:	cmp    %r13,%rdi
1166:	ja     0xffffffffc00d349b
; if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
116c:	and    $0x20,%rsi
; if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
1170:	test   %rsi,%rsi
1173:	je     0xffffffffc00d32fb
; if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
1179:	movzbq 0x5(%r15),%rdi
; if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
117e:	add    $0x6,%r15
1182:	mov    $0x8,%esi
1187:	cmp    %rdi,%rsi
118a:	ja     0xffffffffc00d349b
1190:	jmp    0xffffffffc00d3246
1195:	xor    %edi,%edi
; __u32 quic_packets_stats_key = 0;
1197:	mov    %edi,-0x78(%rbp)
119a:	mov    %rbp,%rsi
; 
119d:	add    $0xffffffffffffff88,%rsi
; bpf_map_lookup_elem(&quic_stats_map, &quic_packets_stats_key);
11a1:	movabs $0xffff8881064d4400,%rdi
11ab:	add    $0x100,%rdi
11b2:	mov    0x0(%rsi),%eax
11b5:	cmp    $0x1,%rax
11b9:	jae    0xffffffffc00d31a9
11bb:	shl    $0x3,%rax
11bf:	add    %rdi,%rax
11c2:	mov    0x0(%rax),%rax
11c6:	add    %gs:0xffffffffbe595028,%rax
11cf:	jmp    0xffffffffc00d31ab
11d1:	xor    %eax,%eax
11d3:	mov    %rax,%r14
; if (!quic_packets_stats) {
11d6:	test   %r14,%r14
11d9:	je     0xffffffffc00d3471
; bool is_icmp = (pckt->flags & F_ICMP);
11df:	movzbq -0x1c(%rbp),%rsi
; bool is_icmp = (pckt->flags & F_ICMP);
11e4:	and    $0x1,%rsi
11e8:	mov    $0x22,%edi
; if (is_ipv6) {
11ed:	test   %rsi,%rsi
11f0:	je     0xffffffffc00d31cf
11f2:	mov    $0x3e,%edi
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
11f7:	add    %rdi,%r15
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
11fa:	mov    %r15,%rdi
11fd:	add    $0x9,%rdi
; if ((data + off + sizeof(struct udphdr) + sizeof(__u8)) > data_end) {
1201:	cmp    %r13,%rdi
1204:	ja     0xffffffffc00d4431
; 
120a:	add    $0x8,%r15
; if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
120e:	movzbq 0x0(%r15),%rsi
1213:	shl    $0x38,%rsi
1217:	sar    $0x38,%rsi
; if ((*pkt_type & QUIC_LONG_HEADER) == QUIC_LONG_HEADER) {
121b:	cmp    $0xffffffffffffffff,%rsi
121f:	jg     0xffffffffc00d3297
; if (quic_data + sizeof(struct quic_long_header) > data_end) {
1225:	mov    %r15,%rdi
1228:	add    $0xe,%rdi
; if (quic_data + sizeof(struct quic_long_header) > data_end) {
122c:	cmp    %r13,%rdi
122f:	ja     0xffffffffc00d4431
; if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
1235:	and    $0x20,%rsi
; if ((*pkt_type & QUIC_PACKET_TYPE_MASK) < QUIC_HANDSHAKE) {
1239:	test   %rsi,%rsi
123c:	je     0xffffffffc00d42a6
; if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
1242:	movzbq 0x5(%r15),%rdi
; if (long_header->conn_id_lens < QUIC_MIN_CONNID_LEN) {
1247:	add    $0x6,%r15
124b:	mov    $0x8,%esi
1250:	cmp    %rdi,%rsi
1253:	ja     0xffffffffc00d4431
1259:	jmp    0xffffffffc00d32aa
; if (quic_data + sizeof(struct quic_short_header) > data_end) {
125b:	mov    %r15,%rsi
125e:	add    $0x9,%rsi
1262:	mov    %rdi,%r15
; if (quic_data + sizeof(struct quic_short_header) > data_end) {
1265:	cmp    %r13,%rsi
1268:	ja     0xffffffffc00d349b
; __u8 connIdVersion = (connId[0] >> 6);
126e:	movzbq 0x0(%r15),%rdi
; __u8 connIdVersion = (connId[0] >> 6);
1273:	mov    %rdi,%rsi
1276:	shr    $0x6,%rsi
; if (connIdVersion == QUIC_CONNID_VERSION_V1) {
127a:	cmp    $0x3,%rsi
127e:	je     0xffffffffc00d3363
1284:	cmp    $0x2,%rsi
1288:	je     0xffffffffc00d3390
128e:	cmp    $0x1,%rsi
1292:	jne    0xffffffffc00d349b
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
1298:	and    $0x3f,%rdi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
129c:	shl    $0xa,%rdi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
12a0:	movzbq 0x1(%r15),%r13
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
12a5:	shl    $0x2,%r13
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
12a9:	or     %rdi,%r13
12ac:	mov    $0x38,%edi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
12b1:	movzbq 0x2(%r15),%rsi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
12b6:	shr    $0x6,%rsi
12ba:	jmp    0xffffffffc00d33af
; if (quic_data + sizeof(struct quic_short_header) > data_end) {
12bf:	mov    %r15,%rsi
12c2:	add    $0x9,%rsi
12c6:	mov    %rdi,%r15
; if (quic_data + sizeof(struct quic_short_header) > data_end) {
12c9:	cmp    %r13,%rsi
12cc:	ja     0xffffffffc00d4431
; __u8 connIdVersion = (connId[0] >> 6);
12d2:	movzbq 0x0(%r15),%rdi
; __u8 connIdVersion = (connId[0] >> 6);
12d7:	mov    %rdi,%rsi
12da:	shr    $0x6,%rsi
; if (connIdVersion == QUIC_CONNID_VERSION_V1) {
12de:	cmp    $0x3,%rsi
12e2:	je     0xffffffffc00d430e
12e8:	cmp    $0x2,%rsi
12ec:	je     0xffffffffc00d433b
12f2:	cmp    $0x1,%rsi
12f6:	jne    0xffffffffc00d4431
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
12fc:	and    $0x3f,%rdi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
1300:	shl    $0xa,%rdi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
1304:	movzbq 0x1(%r15),%r13
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
1309:	shl    $0x2,%r13
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
130d:	or     %rdi,%r13
1310:	mov    $0x38,%edi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
1315:	movzbq 0x2(%r15),%rsi
; ((connId[0] & 0x3F) << 10) | (connId[1] << 2) | (connId[2] >> 6);
131a:	shr    $0x6,%rsi
131e:	jmp    0xffffffffc00d435a
; quic_packets_stats->cid_initial += 1;
1323:	mov    0x8(%r14),%rdi
1327:	add    $0x1,%rdi
132b:	mov    %rdi,0x8(%r14)
; vip_num, /* new conn */ true, /* mismatch in lru */ false);
132f:	mov    -0x64(%rbp),%edi
1332:	mov    %edi,-0x10(%rbp)
1335:	mov    %rbp,%rsi
; 
1338:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&server_id_stats, &vip_num);
133c:	movabs $0xffff8881583d8000,%rdi
1346:	add    $0x100,%rdi
134d:	mov    0x0(%rsi),%eax
1350:	cmp    $0x200,%rax
1357:	jae    0xffffffffc00d3347
1359:	shl    $0x3,%rax
135d:	add    %rdi,%rax
1360:	mov    0x0(%rax),%rax
1364:	add    %gs:0xffffffffbe595028,%rax
136d:	jmp    0xffffffffc00d3349
136f:	xor    %eax,%eax
; if (!per_vip_stats) {
1371:	test   %rax,%rax
1374:	je     0xffffffffc00d34a7
; per_vip_stats->v1 += 1;
137a:	mov    0x0(%rax),%rdi
137e:	add    $0x1,%rdi
1382:	mov    %rdi,0x0(%rax)
1386:	jmp    0xffffffffc00d34a7
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
138b:	movzbq 0x1(%r15),%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
1390:	shl    $0x18,%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
1394:	movzbq 0x2(%r15),%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
1399:	shl    $0x10,%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
139d:	or     %rdi,%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
13a0:	movzbq 0x3(%r15),%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
13a5:	shl    $0x8,%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
13a9:	or     %rdi,%r13
13ac:	mov    $0x48,%edi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
13b1:	movzbq 0x4(%r15),%rsi
13b6:	jmp    0xffffffffc00d33af
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
13b8:	movzbq 0x1(%r15),%rdi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
13bd:	shl    $0x10,%rdi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
13c1:	movzbq 0x2(%r15),%r13
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
13c6:	shl    $0x8,%r13
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
13ca:	or     %rdi,%r13
13cd:	mov    $0x40,%edi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
13d2:	movzbq 0x3(%r15),%rsi
; 
13d7:	and    $0xff,%rsi
13de:	or     %rsi,%r13
; struct quic_parse_result qpr = parse_quic(data, data_end, is_ipv6, &pckt);
13e1:	mov    %r13,%rsi
13e4:	shl    $0x20,%rsi
13e8:	sar    $0x20,%rsi
13ec:	mov    $0x1,%edx
; if (qpr.server_id > 0) {
13f1:	cmp    %rsi,%rdx
13f4:	jg     0xffffffffc00d349b
; 
13fa:	mov    %r14,%rsi
13fd:	add    %rdi,%rsi
1400:	mov    0x0(%rsi),%rdi
1404:	add    $0x1,%rdi
1408:	mov    %rdi,0x0(%rsi)
; __u32 key = qpr.server_id;
140c:	mov    %r13d,-0x14(%rbp)
1410:	mov    %rbp,%rsi
; 
1413:	add    $0xffffffffffffffec,%rsi
; __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
1417:	movabs $0xffffc9001872e000,%rdi
1421:	add    $0x100,%rdi
1428:	mov    0x0(%rsi),%eax
142b:	cmp    $0xfffffe,%rax
1432:	jae    0xffffffffc00d3415
1434:	shl    $0x3,%rax
1438:	add    %rdi,%rax
143b:	jmp    0xffffffffc00d3417
143d:	xor    %eax,%eax
; if (real_pos) {
143f:	test   %rax,%rax
1442:	je     0xffffffffc00d3483
; key = *real_pos;
1444:	mov    0x0(%rax),%edi
; key = *real_pos;
1447:	mov    %edi,-0x14(%rbp)
; if (key == 0) {
144a:	test   %rdi,%rdi
144d:	je     0xffffffffc00d3483
; pckt.real_index = key;
144f:	mov    %edi,-0x20(%rbp)
1452:	mov    %rbp,%rsi
1455:	add    $0xffffffffffffffec,%rsi
; dst = bpf_map_lookup_elem(&reals, &key);
1459:	movabs $0xffffc90018700000,%rdi
1463:	add    $0x100,%rdi
146a:	mov    0x0(%rsi),%eax
146d:	cmp    $0x1000,%rax
1474:	jae    0xffffffffc00d3457
1476:	imul   $0x18,%rax,%rax
147a:	add    %rdi,%rax
147d:	jmp    0xffffffffc00d3459
147f:	xor    %eax,%eax
1481:	mov    %rax,%r13
; if (!dst) {
1484:	test   %rax,%rax
1487:	jne    0xffffffffc00d4269
; 
148d:	mov    0x28(%r14),%rdi
1491:	add    $0x1,%rdi
1495:	mov    %rdi,0x28(%r14)
1499:	mov    $0x1,%r14d
; }
149f:	mov    %r14,%rax
14a2:	pop    %r15
14a4:	pop    %r14
14a6:	pop    %r13
14a8:	pop    %rbx
14a9:	leave
14aa:	ret
; 
14ab:	shl    $0x20,%r13
14af:	sar    $0x20,%r13
14b3:	mov    %r13,0x18(%r14)
14b7:	mov    0x10(%r14),%rdi
14bb:	add    $0x1,%rdi
14bf:	mov    %rdi,0x10(%r14)
; 
14c3:	mov    0x0(%r14),%rdi
14c7:	add    $0x1,%rdi
14cb:	mov    %rdi,0x0(%r14)
14cf:	mov    -0x90(%rbp),%rsi
14d6:	xor    %r13d,%r13d
; original_sport = pckt.flow.port16[0];
14d9:	movzwq -0x28(%rbp),%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
14de:	mov    %rdi,-0xa8(%rbp)
14e5:	movzbq -0x1c(%rbp),%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
14ea:	and    $0x2,%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
14ee:	test   %rdi,%rdi
14f1:	jne    0xffffffffc00d356d
; !(vip_info->flags & F_LRU_BYPASS)) {
14f7:	mov    0x0(%rsi),%edi
; !(vip_info->flags & F_LRU_BYPASS)) {
14fa:	and    $0x2,%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
14fe:	test   %rdi,%rdi
1501:	jne    0xffffffffc00d356d
1507:	mov    %rbp,%rsi
; 
150a:	add    $0xffffffffffffffb8,%rsi
; dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);
150e:	mov    -0x98(%rbp),%rdi
1515:	call   0xffffffffb889c930
151a:	mov    %rax,%r14
151d:	xor    %r13d,%r13d
; if (!dst_lru) {
1520:	test   %r14,%r14
1523:	je     0xffffffffc00d3566
; if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
1525:	movzbq -0x24(%rbp),%rdi
; if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
152a:	cmp    $0x11,%rdi
152e:	jne    0xffffffffc00d352a
; cur_time = bpf_ktime_get_ns();
1530:	call   0xffffffffb889d630
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
1535:	mov    0x8(%r14),%rdi
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
1539:	mov    %rax,%rsi
153c:	sub    %rdi,%rsi
153f:	movabs $0x6fc23ac00,%rdi
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
1549:	cmp    %rdi,%rsi
154c:	ja     0xffffffffc00d3566
; dst_lru->atime = cur_time;
154e:	mov    %rax,0x8(%r14)
; key = dst_lru->pos;
1552:	mov    0x0(%r14),%edi
; pckt->real_index = key;
1556:	mov    %edi,-0x20(%rbp)
; key = dst_lru->pos;
1559:	mov    %edi,-0x10(%rbp)
155c:	mov    %rbp,%rsi
; key = dst_lru->pos;
155f:	add    $0xfffffffffffffff0,%rsi
; *real = bpf_map_lookup_elem(&reals, &key);
1563:	movabs $0xffffc90018700000,%rdi
156d:	add    $0x100,%rdi
1574:	mov    0x0(%rsi),%eax
1577:	cmp    $0x1000,%rax
157e:	jae    0xffffffffc00d3561
1580:	imul   $0x18,%rax,%rax
1584:	add    %rdi,%rax
1587:	jmp    0xffffffffc00d3563
1589:	xor    %eax,%eax
158b:	mov    %rax,%r13
158e:	mov    -0x90(%rbp),%rsi
; if (dst && pckt->flow.proto == IPPROTO_UDP &&
1595:	movzbq -0x24(%rbp),%rdi
; if (dst && pckt->flow.proto == IPPROTO_UDP &&
159a:	cmp    $0x11,%rdi
159e:	jne    0xffffffffc00d36ca
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
15a4:	mov    0x0(%rsi),%edi
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
15a7:	and    $0x200,%rdi
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
15ae:	test   %rdi,%rdi
15b1:	je     0xffffffffc00d36ca
15b7:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
15bc:	mov    %edi,-0x10(%rbp)
15bf:	mov    %rbp,%rsi
; 
15c2:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
15c6:	movabs $0xffff888138844000,%rdi
15d0:	add    $0x100,%rdi
15d7:	mov    0x0(%rsi),%eax
15da:	cmp    $0x400,%rax
15e1:	jae    0xffffffffc00d35d1
15e3:	shl    $0x3,%rax
15e7:	add    %rdi,%rax
15ea:	mov    0x0(%rax),%rax
15ee:	add    %gs:0xffffffffbe595028,%rax
15f7:	jmp    0xffffffffc00d35d3
15f9:	xor    %eax,%eax
15fb:	mov    %rax,%r14
; if (!conn_rate_stats) {
15fe:	test   %r14,%r14
1601:	je     0xffffffffc00d36ca
; *cur_time = bpf_ktime_get_ns();
1607:	call   0xffffffffb889d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
160c:	mov    0x8(%r14),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
1610:	mov    %rax,%rsi
1613:	sub    %rdi,%rsi
1616:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
161b:	cmp    %rsi,%rdi
161e:	ja     0xffffffffc00d36b0
; conn_rate_stats->v2 = *cur_time;
1624:	mov    %rax,0x8(%r14)
1628:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
162d:	mov    %rdi,0x0(%r14)
1631:	mov    %rbp,%rsi
; void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
1634:	add    $0xffffffffffffffa0,%rsi
1638:	movabs $0xffff8881583c3000,%rdi
1642:	call   0xffffffffb88bb9b0
1647:	test   %rax,%rax
164a:	je     0xffffffffc00d362c
164c:	add    $0x48,%rax
1650:	mov    0x0(%rax),%rax
; if (down_reals_map) {
1654:	test   %rax,%rax
1657:	je     0xffffffffc00d36ca
; void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
165d:	mov    %rbp,%rsi
1660:	add    $0xffffffffffffffe0,%rsi
; void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
1664:	mov    %rax,%rdi
1667:	call   0xffffffffb88bb9b0
166c:	test   %rax,%rax
166f:	je     0xffffffffc00d364d
1671:	add    $0x38,%rax
; if (down_real) {
1675:	test   %rax,%rax
1678:	je     0xffffffffc00d36ca
167a:	mov    $0x20f,%edi
; __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
167f:	mov    %edi,-0x10(%rbp)
1682:	mov    %rbp,%rsi
; 
1685:	add    $0xfffffffffffffff0,%rsi
; struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
1689:	movabs $0xffff888138844000,%rdi
1693:	add    $0x100,%rdi
169a:	mov    0x0(%rsi),%eax
169d:	cmp    $0x400,%rax
16a4:	jae    0xffffffffc00d3694
16a6:	shl    $0x3,%rax
16aa:	add    %rdi,%rax
16ad:	mov    0x0(%rax),%rax
16b1:	add    %gs:0xffffffffbe595028,%rax
16ba:	jmp    0xffffffffc00d3696
16bc:	xor    %eax,%eax
; if (stats_data) {
16be:	test   %rax,%rax
16c1:	je     0xffffffffc00d3932
; stats_data->v1 += 1;
16c7:	mov    0x0(%rax),%rdi
16cb:	add    $0x1,%rdi
16cf:	mov    %rdi,0x0(%rax)
16d3:	jmp    0xffffffffc00d3932
; conn_rate_stats->v1 += 1;
16d8:	mov    0x0(%r14),%rdi
16dc:	add    $0x1,%rdi
16e0:	mov    %rdi,0x0(%r14)
16e4:	mov    $0x1e849,%esi
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
16e9:	cmp    %rdi,%rsi
16ec:	ja     0xffffffffc00d3609
; if (!dst) {
16f2:	test   %r13,%r13
16f5:	jne    0xffffffffc00d36d4
16f7:	jmp    0xffffffffc00d3932
16fc:	mov    %r13,-0x88(%rbp)
1703:	mov    %rbp,%rsi
; 
1706:	add    $0xffffffffffffff98,%rsi
; cval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos);
170a:	movabs $0xffff8881064d3c00,%rdi
1714:	add    $0x100,%rdi
171b:	mov    0x0(%rsi),%eax
171e:	cmp    $0x10,%rax
1722:	jae    0xffffffffc00d3705
1724:	shl    $0x3,%rax
1728:	add    %rdi,%rax
172b:	jmp    0xffffffffc00d3707
172d:	xor    %eax,%eax
172f:	mov    %rax,%r15
1732:	mov    $0x1,%r14d
; if (!cval) {
1738:	test   %r15,%r15
173b:	je     0xffffffffc00d3477
1741:	mov    %rbp,%rsi
; 
1744:	add    $0xffffffffffffff9c,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &vip_num);
1748:	movabs $0xffff888138844000,%rdi
1752:	add    $0x100,%rdi
1759:	mov    0x0(%rsi),%eax
175c:	cmp    $0x400,%rax
1763:	jae    0xffffffffc00d3753
1765:	shl    $0x3,%rax
1769:	add    %rdi,%rax
176c:	mov    0x0(%rax),%rax
1770:	add    %gs:0xffffffffbe595028,%rax
1779:	jmp    0xffffffffc00d3755
177b:	xor    %eax,%eax
; if (!data_stats) {
177d:	test   %rax,%rax
1780:	je     0xffffffffc00d3477
1786:	mov    -0x80(%rbp),%rsi
178a:	ror    $0x8,%si
178e:	movzwl %si,%esi
; data_stats->v1 += 1;
1791:	mov    0x0(%rax),%rdi
1795:	add    $0x1,%rdi
1799:	mov    %rdi,0x0(%rax)
; data_stats->v2 += pkt_bytes;
179d:	mov    0x8(%rax),%rdi
17a1:	mov    %rsi,%r13
17a4:	add    %rsi,%rdi
17a7:	mov    %rdi,0x8(%rax)
; data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
17ab:	mov    %rbp,%rsi
17ae:	add    $0xffffffffffffffe0,%rsi
; data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
17b2:	movabs $0xffffc9001871a000,%rdi
17bc:	add    $0x100,%rdi
17c3:	mov    0x0(%rsi),%eax
17c6:	cmp    $0x1000,%rax
17cd:	jae    0xffffffffc00d37bd
17cf:	shl    $0x3,%rax
17d3:	add    %rdi,%rax
17d6:	mov    0x0(%rax),%rax
17da:	add    %gs:0xffffffffbe595028,%rax
17e3:	jmp    0xffffffffc00d37bf
17e5:	xor    %eax,%eax
; if (!data_stats) {
17e7:	test   %rax,%rax
17ea:	je     0xffffffffc00d3477
; data_stats->v1 += 1;
17f0:	mov    0x0(%rax),%rdi
17f4:	add    $0x1,%rdi
17f8:	mov    %rdi,0x0(%rax)
; data_stats->v2 += pkt_bytes;
17fc:	mov    0x8(%rax),%rdi
1800:	add    %r13,%rdi
1803:	mov    %rdi,0x8(%rax)
; pckt.flow.port16[0] = original_sport;
1807:	mov    -0xa8(%rbp),%rdi
180e:	mov    %di,-0x28(%rbp)
; if (dst->flags & F_IPV6) {
1812:	mov    -0x88(%rbp),%rdi
1819:	movzbq 0x10(%rdi),%rdi
; if (dst->flags & F_IPV6) {
181e:	and    $0x1,%rdi
; if (dst->flags & F_IPV6) {
1822:	test   %rdi,%rdi
1825:	je     0xffffffffc00d40a1
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
182b:	mov    %rbx,%rdi
182e:	mov    $0xffffffd8,%esi
1833:	call   0xffffffffbaa35c20
1838:	shl    $0x20,%rax
183c:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
1840:	test   %rax,%rax
1843:	jne    0xffffffffc00d3477
; data = (void*)(long)xdp->data;
1849:	mov    0x0(%rbx),%rdi
; data_end = (void*)(long)xdp->data_end;
184d:	mov    0x8(%rbx),%rsi
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
1851:	mov    %rdi,%rdx
1854:	add    $0xe,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
1858:	cmp    %rsi,%rdx
185b:	ja     0xffffffffc00d3477
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
1861:	mov    %rdi,%rdx
1864:	add    $0x36,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
1868:	cmp    %rsi,%rdx
186b:	ja     0xffffffffc00d3477
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
1871:	cmp    %rsi,%rdx
1874:	ja     0xffffffffc00d3477
; 
187a:	mov    %rdi,%rsi
187d:	add    $0x28,%rsi
; memcpy(new_eth->h_dest, cval->mac, 6);
1881:	movzbq 0x5(%r15),%rdx
1886:	mov    %dl,0x5(%rdi)
1889:	movzbq 0x4(%r15),%rdx
188e:	mov    %dl,0x4(%rdi)
1891:	movzbq 0x3(%r15),%rdx
1896:	mov    %dl,0x3(%rdi)
1899:	movzbq 0x2(%r15),%rdx
189e:	mov    %dl,0x2(%rdi)
18a1:	movzbq 0x1(%r15),%rdx
18a6:	mov    %dl,0x1(%rdi)
18a9:	movzbq 0x0(%r15),%rdx
18ae:	mov    %dl,0x0(%rdi)
; memcpy(new_eth->h_source, old_eth->h_dest, 6);
18b1:	movzbq 0x2(%rsi),%rdx
18b6:	mov    %dl,0x8(%rdi)
18b9:	movzbq 0x3(%rsi),%rdx
18be:	mov    %dl,0x9(%rdi)
18c1:	movzbq 0x0(%rsi),%rdx
18c6:	mov    %dl,0x6(%rdi)
18c9:	movzbq 0x1(%rsi),%rdx
18ce:	mov    %dl,0x7(%rdi)
18d1:	movzbq 0x4(%rsi),%rdx
18d6:	mov    %dl,0xa(%rdi)
18d9:	movzbq 0x5(%rsi),%rsi
18de:	mov    %sil,0xb(%rdi)
18e2:	mov    $0x86,%esi
; new_eth->h_proto = BE_ETH_P_IPV6;
18e7:	mov    %sil,0xc(%rdi)
18eb:	mov    $0xdd,%esi
18f0:	mov    %sil,0xd(%rdi)
; create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
18f4:	movzwq -0x28(%rbp),%rsi
; create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.srcv6[3], saddr);
18f9:	mov    -0x3c(%rbp),%edx
; saddr[3] = src ^ port;
18fc:	xor    %rsi,%rdx
; create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
18ff:	movzbq -0x1b(%rbp),%rsi
1904:	mov    $0x1,%ecx
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
1909:	mov    %ecx,0x16(%rdi)
; payload_len = pkt_bytes + sizeof(struct ipv6hdr);
190c:	add    $0x28,%r13
; ip6h->payload_len = bpf_htons(payload_len);
1910:	ror    $0x8,%r13w
1915:	movzwl %r13w,%r13d
; ip6h->payload_len = bpf_htons(payload_len);
1919:	mov    %r13w,0x12(%rdi)
191e:	xor    %ecx,%ecx
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
1920:	mov    %ecx,0x1a(%rdi)
1923:	mov    %ecx,0x1e(%rdi)
; memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
1926:	mov    %cl,0x10(%rdi)
1929:	mov    %cl,0x11(%rdi)
192c:	mov    $0x4029,%ecx
; ip6h->nexthdr = proto;
1931:	mov    %cx,0x14(%rdi)
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
1935:	mov    %edx,0x22(%rdi)
; ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
1938:	mov    %rsi,%rdx
193b:	shl    $0x4,%rdx
; ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
193f:	mov    %dl,0xf(%rdi)
; ip6h->priority = (tc & 0xF0) >> 4;
1942:	shr    $0x4,%rsi
; ip6h->priority = (tc & 0xF0) >> 4;
1946:	or     $0x60,%rsi
194a:	mov    %sil,0xe(%rdi)
194e:	mov    -0x88(%rbp),%rdx
1955:	jmp    0xffffffffc00d48bb
; if (pckt.flow.proto == IPPROTO_TCP) {
195a:	movzbq -0x24(%rbp),%rdi
; if (pckt.flow.proto == IPPROTO_TCP) {
195f:	cmp    $0x6,%rdi
1963:	jne    0xffffffffc00d39b2
1965:	mov    $0x201,%edi
; __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
196a:	mov    %edi,-0x10(%rbp)
196d:	mov    %rbp,%rsi
; 
1970:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &lru_stats_key);
1974:	movabs $0xffff888138844000,%rdi
197e:	add    $0x100,%rdi
1985:	mov    0x0(%rsi),%eax
1988:	cmp    $0x400,%rax
198f:	jae    0xffffffffc00d397f
1991:	shl    $0x3,%rax
1995:	add    %rdi,%rax
1998:	mov    0x0(%rax),%rax
199c:	add    %gs:0xffffffffbe595028,%rax
19a5:	jmp    0xffffffffc00d3981
19a7:	xor    %eax,%eax
; if (!lru_stats) {
19a9:	test   %rax,%rax
19ac:	je     0xffffffffc00d3471
; if (pckt.flags & F_SYN_SET) {
19b2:	movzbq -0x1c(%rbp),%rsi
; if (pckt.flags & F_SYN_SET) {
19b7:	and    $0x2,%rsi
19bb:	mov    $0x1,%edi
19c0:	test   %rsi,%rsi
19c3:	je     0xffffffffc00d399f
19c5:	xor    %edi,%edi
; if (pckt.flags & F_SYN_SET) {
19c7:	shl    $0x3,%rdi
; 
19cb:	add    %rdi,%rax
19ce:	mov    0x0(%rax),%rdi
19d2:	add    $0x1,%rdi
19d6:	mov    %rdi,0x0(%rax)
19da:	xor    %r13d,%r13d
; struct real_pos_lru new_dst_lru = {};
19dd:	mov    %r13,-0x8(%rbp)
19e1:	mov    %r13,-0x10(%rbp)
19e5:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
19ea:	mov    %edi,-0x78(%rbp)
19ed:	mov    %rbp,%rsi
; 
19f0:	add    $0xffffffffffffff88,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
19f4:	movabs $0xffff888138844000,%rdi
19fe:	add    $0x100,%rdi
1a05:	mov    0x0(%rsi),%eax
1a08:	cmp    $0x400,%rax
1a0f:	jae    0xffffffffc00d39ff
1a11:	shl    $0x3,%rax
1a15:	add    %rdi,%rax
1a18:	mov    0x0(%rax),%rax
1a1c:	add    %gs:0xffffffffbe595028,%rax
1a25:	jmp    0xffffffffc00d3a01
1a27:	xor    %eax,%eax
1a29:	mov    %rax,%r14
1a2c:	mov    $0x1,%r15d
; if (!conn_rate_stats) {
1a32:	test   %r14,%r14
1a35:	je     0xffffffffc00d3a52
; *cur_time = bpf_ktime_get_ns();
1a37:	call   0xffffffffb889d630
1a3c:	mov    %rax,%r13
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
1a3f:	mov    0x8(%r14),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
1a43:	mov    %r13,%rsi
1a46:	sub    %rdi,%rsi
1a49:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
1a4e:	cmp    %rsi,%rdi
1a51:	ja     0xffffffffc00d3a3a
; conn_rate_stats->v2 = *cur_time;
1a53:	mov    %r13,0x8(%r14)
1a57:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
1a5c:	mov    %rdi,0x0(%r14)
1a60:	jmp    0xffffffffc00d3a4f
; conn_rate_stats->v1 += 1;
1a62:	mov    0x0(%r14),%rdi
1a66:	add    $0x1,%rdi
1a6a:	mov    %rdi,0x0(%r14)
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
1a6e:	cmp    $0x1e848,%rdi
1a75:	ja     0xffffffffc00d3a52
1a77:	xor    %r15d,%r15d
1a7a:	mov    %r15,-0xc0(%rbp)
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
1a81:	mov    -0x90(%rbp),%rdi
1a88:	mov    0x0(%rdi),%edi
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
1a8b:	and    $0x8,%rdi
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
1a8f:	mov    %r13,-0xc8(%rbp)
1a96:	test   %rdi,%rdi
1a99:	jne    0xffffffffc00d3a99
; a += k[0];
1a9b:	movzbq -0x3c(%rbp),%rdi
; a += (u32)k[1] << 8;
1aa0:	mov    %rdi,-0xb8(%rbp)
1aa7:	movzbq -0x3b(%rbp),%r15
; a += (u32)k[2] << 16;
1aac:	movzbq -0x3a(%rbp),%rax
; a += (u32)k[3] << 24;
1ab1:	movzbq -0x39(%rbp),%r14
; c += *(u32*)(k + 8);
1ab6:	mov    -0x40(%rbp),%ecx
; b += *(u32*)(k + 4);
1ab9:	mov    -0x44(%rbp),%esi
; a += *(u32*)(k);
1abc:	mov    -0x48(%rbp),%edi
1abf:	jmp    0xffffffffc00d3aca
; pckt->flow.port16[0] = pckt->flow.port16[1];
1ac1:	mov    -0x88(%rbp),%rdi
1ac8:	movzwq 0x2(%rdi),%rdi
; pckt->flow.port16[0] = pckt->flow.port16[1];
1acd:	mov    %di,-0x28(%rbp)
1ad1:	xor    %esi,%esi
; memset(pckt->flow.srcv6, 0, 16);
1ad3:	mov    %rsi,-0x48(%rbp)
1ad7:	xor    %edi,%edi
1ad9:	mov    %rdi,-0xb8(%rbp)
1ae0:	mov    %rsi,-0x40(%rbp)
; a += (u32)k[1] << 8;
1ae4:	xor    %r15d,%r15d
; a += (u32)k[2] << 16;
1ae7:	xor    %eax,%eax
; a += (u32)k[3] << 24;
1ae9:	xor    %r14d,%r14d
; c += *(u32*)(k + 8);
1aec:	xor    %ecx,%ecx
; b += *(u32*)(k + 4);
1aee:	xor    %esi,%esi
; a += *(u32*)(k);
1af0:	xor    %edi,%edi
; __jhash_mix(a, b, c);
1af2:	sub    %rcx,%rdi
; c += *(u32*)(k + 8);
1af5:	add    $0xffffffffdeadc0ff,%rcx
1afc:	mov    $0xf0000000,%edx
1b01:	mov    %rcx,%r8
1b04:	and    %rdx,%r8
; return (word << shift) | (word >> ((-shift) & 31));
1b07:	shr    $0x1c,%r8
1b0b:	mov    %rcx,%r13
1b0e:	shl    $0x4,%r13
1b12:	or     %r8,%r13
; __jhash_mix(a, b, c);
1b15:	xor    %rdi,%r13
1b18:	mov    $0xfc000000,%edi
1b1d:	mov    %r13,%r8
1b20:	and    %rdi,%r8
; return (word << shift) | (word >> ((-shift) & 31));
1b23:	shr    $0x1a,%r8
1b27:	mov    %r13,%rdx
1b2a:	shl    $0x6,%rdx
1b2e:	or     %r8,%rdx
; b += *(u32*)(k + 4);
1b31:	add    $0xffffffffdeadc0ff,%rsi
; __jhash_mix(a, b, c);
1b38:	mov    %rsi,%rdi
1b3b:	sub    %r13,%rdi
1b3e:	xor    %rdx,%rdi
; a += (u32)k[3] << 24;
1b41:	shl    $0x18,%r14
; a += (u32)k[2] << 16;
1b45:	and    $0xff,%rax
; a += (u32)k[2] << 16;
1b4b:	shl    $0x10,%rax
; a += (u32)k[3] << 24;
1b4f:	or     %r14,%rax
; pckt->flow.ports,
1b52:	mov    -0x28(%rbp),%r14d
; b += initval;
1b56:	add    $0xffffffffe0adc0f7,%r14
1b5d:	mov    %r14,%rdx
1b60:	mov    %rsi,%r8
1b63:	mov    %r14,%rsi
1b66:	mov    %rsi,-0x88(%rbp)
1b6d:	mov    $0xfffc0000,%r14d
1b73:	and    %r14,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
1b76:	shr    $0x12,%rdx
1b7a:	mov    %rsi,%r14
1b7d:	shl    $0xe,%r14
1b81:	or     %rdx,%r14
; __jhash_final(a, b, c);
1b84:	xor    $0xffffffffe0adc0f7,%rsi
1b8b:	sub    %r14,%rsi
1b8e:	mov    %rsi,%r14
; __jhash_mix(a, b, c);
1b91:	add    %r8,%rcx
; a += (u32)k[1] << 8;
1b94:	and    $0xff,%r15
; a += (u32)k[1] << 8;
1b9b:	shl    $0x8,%r15
; a += (u32)k[2] << 16;
1b9f:	or     %r15,%rax
1ba2:	mov    -0xb8(%rbp),%rsi
; a += k[0];
1ba9:	and    $0xff,%rsi
; a += (u32)k[1] << 8;
1bb0:	or     %rsi,%rax
1bb3:	mov    $0xff000000,%esi
; __jhash_mix(a, b, c);
1bb8:	mov    %rdi,%rdx
1bbb:	and    %rsi,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
1bbe:	shr    $0x18,%rdx
1bc2:	mov    %rdi,%rsi
1bc5:	shl    $0x8,%rsi
1bc9:	or     %rdx,%rsi
; __jhash_mix(a, b, c);
1bcc:	add    %rcx,%r13
1bcf:	sub    %rdi,%rcx
1bd2:	xor    %rsi,%rcx
1bd5:	mov    $0xffe00000,%edx
1bda:	mov    %r14,%r15
; __jhash_final(a, b, c);
1bdd:	mov    %r15,-0xb0(%rbp)
1be4:	mov    %r15,%rsi
1be7:	and    %rdx,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
1bea:	shr    $0x15,%rsi
1bee:	shl    $0xb,%r15
1bf2:	or     %rsi,%r15
1bf5:	mov    $0xffff0000,%edx
; __jhash_mix(a, b, c);
1bfa:	mov    %rcx,%rsi
1bfd:	and    %rdx,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
1c00:	shr    $0x10,%rsi
1c04:	mov    %rcx,%rdx
1c07:	shl    $0x10,%rdx
1c0b:	or     %rsi,%rdx
; __jhash_mix(a, b, c);
1c0e:	add    %r13,%rdi
1c11:	sub    %rcx,%r13
1c14:	xor    %rdx,%r13
1c17:	mov    $0xffffe000,%esi
1c1c:	mov    %r13,%rdx
1c1f:	and    %rsi,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
1c22:	shr    $0xd,%rdx
1c26:	mov    %r13,%rsi
1c29:	shl    $0x13,%rsi
1c2d:	or     %rdx,%rsi
; __jhash_mix(a, b, c);
1c30:	add    %rdi,%rcx
1c33:	sub    %r13,%rdi
1c36:	xor    %rsi,%rdi
1c39:	add    %rcx,%r13
1c3c:	mov    %rdi,%r8
1c3f:	add    %r13,%r8
1c42:	mov    %r8,%rdx
1c45:	mov    $0xfffc0000,%esi
1c4a:	and    %rsi,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
1c4d:	shr    $0x12,%rdx
1c51:	mov    %r8,%rsi
1c54:	shl    $0xe,%rsi
1c58:	or     %rdx,%rsi
; __jhash_mix(a, b, c);
1c5b:	mov    %rdi,%rdx
1c5e:	mov    $0xf0000000,%r14d
1c64:	and    %r14,%rdx
; return (word << shift) | (word >> ((-shift) & 31));
1c67:	shr    $0x1c,%rdx
; __jhash_mix(a, b, c);
1c6b:	sub    %rdi,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
1c6e:	shl    $0x4,%rdi
1c72:	or     %rdx,%rdi
; __jhash_mix(a, b, c);
1c75:	xor    %rdi,%rcx
; a += k[0];
1c78:	add    %rax,%r13
; __jhash_final(a, b, c);
1c7b:	xor    %r8,%rcx
1c7e:	sub    %rsi,%rcx
1c81:	mov    %rcx,%rdi
1c84:	mov    $0xffe00000,%esi
1c89:	and    %rsi,%rdi
; return (word << shift) | (word >> ((-shift) & 31));
1c8c:	shr    $0x15,%rdi
1c90:	mov    %rcx,%rsi
1c93:	shl    $0xb,%rsi
1c97:	or     %rdi,%rsi
; __jhash_final(a, b, c);
1c9a:	mov    %rcx,%rax
1c9d:	xor    %r13,%rax
1ca0:	sub    %rsi,%rax
1ca3:	mov    $0xffffff80,%edi
1ca8:	mov    %rax,%rsi
1cab:	and    %rdi,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
1cae:	shr    $0x7,%rsi
1cb2:	mov    %rax,%r13
1cb5:	shl    $0x19,%r13
1cb9:	or     %rsi,%r13
; __jhash_final(a, b, c);
1cbc:	mov    %rax,%rdx
1cbf:	xor    %r8,%rdx
1cc2:	sub    %r13,%rdx
1cc5:	mov    %rdx,%rsi
1cc8:	mov    $0xffff0000,%r8d
1cce:	and    %r8,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
1cd1:	shr    $0x10,%rsi
1cd5:	mov    %rdx,%r8
1cd8:	shl    $0x10,%r8
1cdc:	or     %rsi,%r8
; __jhash_final(a, b, c);
1cdf:	mov    %rdx,%r14
1ce2:	xor    %rcx,%r14
1ce5:	sub    %r8,%r14
1ce8:	mov    %r14,%rsi
1ceb:	mov    $0xf0000000,%r13d
1cf1:	and    %r13,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
1cf4:	shr    $0x1c,%rsi
1cf8:	mov    %r14,%rcx
1cfb:	shl    $0x4,%rcx
1cff:	or     %rsi,%rcx
; __jhash_final(a, b, c);
1d02:	mov    %r14,%rsi
1d05:	xor    %rax,%rsi
1d08:	sub    %rcx,%rsi
1d0b:	mov    %rsi,%rcx
1d0e:	mov    $0xfffc0000,%r8d
1d14:	and    %r8,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
1d17:	shr    $0x12,%rcx
1d1b:	mov    %rsi,%r8
1d1e:	shl    $0xe,%r8
1d22:	or     %rcx,%r8
; __jhash_final(a, b, c);
1d25:	xor    %rdx,%rsi
1d28:	sub    %r8,%rsi
1d2b:	mov    $0xffffff00,%edx
1d30:	mov    %rsi,%rcx
1d33:	and    %rdx,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
1d36:	shr    $0x8,%rcx
1d3a:	mov    %rsi,%r8
1d3d:	shl    $0x18,%r8
1d41:	or     %rcx,%r8
; __jhash_final(a, b, c);
1d44:	xor    %r14,%rsi
; a += initval;
1d47:	sub    %r8,%rsi
1d4a:	add    $0xffffffffe0adc0f7,%rsi
1d51:	mov    -0xb0(%rbp),%r14
; __jhash_final(a, b, c);
1d58:	xor    %r14,%rsi
1d5b:	sub    %r15,%rsi
1d5e:	mov    %rsi,%rcx
1d61:	and    %rdi,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
1d64:	shr    $0x7,%rcx
1d68:	mov    %rsi,%rdi
1d6b:	shl    $0x19,%rdi
1d6f:	or     %rcx,%rdi
; __jhash_final(a, b, c);
1d72:	mov    %rsi,%rax
1d75:	mov    -0x88(%rbp),%rcx
1d7c:	xor    %rcx,%rax
1d7f:	sub    %rdi,%rax
1d82:	mov    %rax,%rdi
1d85:	mov    $0xffff0000,%ecx
1d8a:	and    %rcx,%rdi
; return (word << shift) | (word >> ((-shift) & 31));
1d8d:	shr    $0x10,%rdi
1d91:	mov    %rax,%r8
1d94:	shl    $0x10,%r8
1d98:	or     %rdi,%r8
; __jhash_final(a, b, c);
1d9b:	mov    %rax,%rcx
1d9e:	xor    %r14,%rcx
1da1:	sub    %r8,%rcx
1da4:	mov    %rcx,%rdi
1da7:	and    %r13,%rdi
; return (word << shift) | (word >> ((-shift) & 31));
1daa:	shr    $0x1c,%rdi
1dae:	mov    %rcx,%r8
1db1:	shl    $0x4,%r8
1db5:	or     %rdi,%r8
; __jhash_final(a, b, c);
1db8:	mov    %rcx,%rdi
1dbb:	xor    %rsi,%rdi
1dbe:	sub    %r8,%rdi
1dc1:	mov    %rdi,%rsi
1dc4:	mov    $0xfffc0000,%r8d
1dca:	and    %r8,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
1dcd:	shr    $0x12,%rsi
1dd1:	mov    %rdi,%r8
1dd4:	shl    $0xe,%r8
1dd8:	or     %rsi,%r8
; __jhash_final(a, b, c);
1ddb:	xor    %rax,%rdi
1dde:	sub    %r8,%rdi
1de1:	mov    %rdi,%rsi
1de4:	and    %rdx,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
1de7:	shr    $0x8,%rsi
1deb:	mov    %rdi,%rdx
1dee:	shl    $0x18,%rdx
1df2:	or     %rsi,%rdx
; __jhash_final(a, b, c);
1df5:	xor    %rcx,%rdi
1df8:	sub    %rdx,%rdi
1dfb:	mov    %rdi,%rsi
1dfe:	shl    $0x20,%rsi
1e02:	shr    $0x20,%rsi
; hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
1e06:	push   %rax
1e07:	push   %rdx
1e08:	mov    $0x10001,%r11
1e0f:	mov    %rsi,%rax
1e12:	xor    %edx,%edx
1e14:	div    %r11
1e17:	mov    %rax,%rsi
1e1a:	pop    %rdx
1e1b:	pop    %rax
1e1c:	imul   $0x10001,%rsi,%rsi
1e23:	sub    %rsi,%rdi
; key = RING_SIZE * (vip_info->vip_num) + hash;
1e26:	mov    -0x90(%rbp),%rsi
1e2d:	mov    0x4(%rsi),%esi
; key = RING_SIZE * (vip_info->vip_num) + hash;
1e30:	imul   $0x10001,%rsi,%rsi
; key = RING_SIZE * (vip_info->vip_num) + hash;
1e37:	add    %rsi,%rdi
; key = RING_SIZE * (vip_info->vip_num) + hash;
1e3a:	mov    %edi,-0x14(%rbp)
1e3d:	mov    %rbp,%rsi
; 
1e40:	add    $0xffffffffffffffec,%rsi
; real_pos = bpf_map_lookup_elem(&ch_rings, &key);
1e44:	movabs $0xffffc9000867b000,%rdi
1e4e:	add    $0x100,%rdi
1e55:	mov    0x0(%rsi),%eax
1e58:	cmp    $0x2000200,%rax
1e5f:	jae    0xffffffffc00d3e42
1e61:	shl    $0x3,%rax
1e65:	add    %rdi,%rax
1e68:	jmp    0xffffffffc00d3e44
1e6a:	xor    %eax,%eax
; if (!real_pos) {
1e6c:	test   %rax,%rax
1e6f:	je     0xffffffffc00d3471
; key = *real_pos;
1e75:	mov    0x0(%rax),%edi
; key = *real_pos;
1e78:	mov    %edi,-0x14(%rbp)
; if (key == 0) {
1e7b:	test   %rdi,%rdi
1e7e:	jne    0xffffffffc00d3eaa
1e80:	mov    $0x209,%edi
; __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
1e85:	mov    %edi,-0x78(%rbp)
1e88:	mov    %rbp,%rsi
; 
1e8b:	add    $0xffffffffffffff88,%rsi
; bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
1e8f:	movabs $0xffff888138844000,%rdi
1e99:	add    $0x100,%rdi
1ea0:	mov    0x0(%rsi),%eax
1ea3:	cmp    $0x400,%rax
1eaa:	jae    0xffffffffc00d3e9a
1eac:	shl    $0x3,%rax
1eb0:	add    %rdi,%rax
1eb3:	mov    0x0(%rax),%rax
1eb7:	add    %gs:0xffffffffbe595028,%rax
1ec0:	jmp    0xffffffffc00d3e9c
1ec2:	xor    %eax,%eax
; if (!ch_drop_stats) {
1ec4:	test   %rax,%rax
1ec7:	je     0xffffffffc00d3471
1ecd:	jmp    0xffffffffc00d4c0a
; pckt->real_index = key;
1ed2:	mov    %edi,-0x20(%rbp)
1ed5:	mov    %rbp,%rsi
; 
1ed8:	add    $0xffffffffffffffec,%rsi
; *real = bpf_map_lookup_elem(&reals, &key);
1edc:	movabs $0xffffc90018700000,%rdi
1ee6:	add    $0x100,%rdi
1eed:	mov    0x0(%rsi),%eax
1ef0:	cmp    $0x1000,%rax
1ef7:	jae    0xffffffffc00d3eda
1ef9:	imul   $0x18,%rax,%rax
1efd:	add    %rdi,%rax
1f00:	jmp    0xffffffffc00d3edc
1f02:	xor    %eax,%eax
; if (!(*real)) {
1f04:	test   %rax,%rax
1f07:	jne    0xffffffffc00d3f33
1f09:	mov    $0x209,%edi
; __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
1f0e:	mov    %edi,-0x78(%rbp)
1f11:	mov    %rbp,%rsi
; 
1f14:	add    $0xffffffffffffff88,%rsi
; bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
1f18:	movabs $0xffff888138844000,%rdi
1f22:	add    $0x100,%rdi
1f29:	mov    0x0(%rsi),%eax
1f2c:	cmp    $0x400,%rax
1f33:	jae    0xffffffffc00d3f23
1f35:	shl    $0x3,%rax
1f39:	add    %rdi,%rax
1f3c:	mov    0x0(%rax),%rax
1f40:	add    %gs:0xffffffffbe595028,%rax
1f49:	jmp    0xffffffffc00d3f25
1f4b:	xor    %eax,%eax
; if (!ch_drop_stats) {
1f4d:	test   %rax,%rax
1f50:	je     0xffffffffc00d3471
1f56:	jmp    0xffffffffc00d4cac
1f5b:	mov    %rax,%r14
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
1f5e:	mov    -0x98(%rbp),%rdi
1f65:	test   %rdi,%rdi
1f68:	je     0xffffffffc00d3f9a
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
1f6a:	mov    -0x90(%rbp),%rdi
1f71:	mov    0x0(%rdi),%edi
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
1f74:	and    $0x2,%rdi
1f78:	shr    %rdi
1f7b:	mov    -0xc0(%rbp),%rsi
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
1f82:	or     %rdi,%rsi
1f85:	test   %rsi,%rsi
1f88:	jne    0xffffffffc00d3f9a
; if (pckt->flow.proto == IPPROTO_UDP) {
1f8a:	movzbq -0x24(%rbp),%rdi
; if (pckt->flow.proto == IPPROTO_UDP) {
1f8f:	cmp    $0x11,%rdi
1f93:	jne    0xffffffffc00d3f78
; new_dst_lru.atime = cur_time;
1f95:	mov    -0xc8(%rbp),%rdi
1f9c:	mov    %rdi,-0x8(%rbp)
; new_dst_lru.pos = key;
1fa0:	mov    -0x14(%rbp),%edi
; new_dst_lru.pos = key;
1fa3:	mov    %edi,-0x10(%rbp)
1fa6:	mov    %rbp,%rsi
; new_dst_lru.pos = key;
1fa9:	add    $0xffffffffffffffb8,%rsi
1fad:	mov    %rbp,%rdx
1fb0:	add    $0xfffffffffffffff0,%rdx
; bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
1fb4:	mov    -0x98(%rbp),%rdi
1fbb:	xor    %ecx,%ecx
1fbd:	call   0xffffffffb889c9c0
1fc2:	xor    %r13d,%r13d
; __u32 vip_miss_stats_key = 0;
1fc5:	mov    %r13d,-0x10(%rbp)
1fc9:	mov    %rbp,%rsi
; 
1fcc:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&vip_miss_stats, &vip_miss_stats_key);
1fd0:	movabs $0xffff8881064d4000,%rdi
1fda:	add    $0x100,%rdi
1fe1:	mov    0x0(%rsi),%eax
1fe4:	cmp    $0x1,%rax
1fe8:	jae    0xffffffffc00d3fcb
1fea:	imul   $0x18,%rax,%rax
1fee:	add    %rdi,%rax
1ff1:	jmp    0xffffffffc00d3fcd
1ff3:	xor    %eax,%eax
; if (!lru_miss_stat_vip) {
1ff5:	test   %rax,%rax
1ff8:	je     0xffffffffc00d3471
; (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
1ffe:	mov    0x0(%rax),%edi
; (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
2001:	mov    -0x60(%rbp),%esi
; (lru_miss_stat_vip->vipv6[0] == vip->vipv6[0] &&
2004:	cmp    %rsi,%rdi
2007:	jne    0xffffffffc00d400b
; lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
2009:	mov    0x4(%rax),%edi
; lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
200c:	mov    -0x5c(%rbp),%esi
; lru_miss_stat_vip->vipv6[1] == vip->vipv6[1] &&
200f:	cmp    %rsi,%rdi
2012:	jne    0xffffffffc00d400b
; lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
2014:	mov    0x8(%rax),%edi
; lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
2017:	mov    -0x58(%rbp),%esi
; lru_miss_stat_vip->vipv6[2] == vip->vipv6[2] &&
201a:	cmp    %rsi,%rdi
201d:	jne    0xffffffffc00d400b
; lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
201f:	mov    0xc(%rax),%edi
2022:	mov    $0x1,%r13d
; lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
2028:	mov    -0x54(%rbp),%esi
; lru_miss_stat_vip->vipv6[3] == vip->vipv6[3])) ||
202b:	cmp    %rsi,%rdi
202e:	je     0xffffffffc00d400b
2030:	xor    %r13d,%r13d
; bool vip_match = address_match && port_match && proto_match;
2033:	movzwq -0x50(%rbp),%rsi
2038:	movzbq -0x4e(%rbp),%rdi
; bool proto_match = lru_miss_stat_vip->proto = vip->proto;
203d:	mov    %dil,0x12(%rax)
; bool vip_match = address_match && port_match && proto_match;
2041:	and    $0x1,%r13
2045:	test   %r13,%r13
2048:	je     0xffffffffc00d4086
204a:	movzwq 0x10(%rax),%rdx
204f:	cmp    %rsi,%rdx
2052:	jne    0xffffffffc00d4086
2054:	test   %rdi,%rdi
2057:	je     0xffffffffc00d4086
; __u32 lru_stats_key = pckt->real_index;
2059:	mov    -0x20(%rbp),%edi
; __u32 lru_stats_key = pckt->real_index;
205c:	mov    %edi,-0x78(%rbp)
205f:	mov    %rbp,%rsi
; __u32 lru_stats_key = pckt->real_index;
2062:	add    $0xffffffffffffff88,%rsi
; __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
2066:	movabs $0xffffc90018724000,%rdi
2070:	add    $0x100,%rdi
2077:	mov    0x0(%rsi),%eax
207a:	cmp    $0x1000,%rax
2081:	jae    0xffffffffc00d4071
2083:	shl    $0x3,%rax
2087:	add    %rdi,%rax
208a:	mov    0x0(%rax),%rax
208e:	add    %gs:0xffffffffbe595028,%rax
2097:	jmp    0xffffffffc00d4073
2099:	xor    %eax,%eax
; if (!lru_miss_stat) {
209b:	test   %rax,%rax
209e:	je     0xffffffffc00d3471
; *lru_miss_stat += 1;
20a4:	mov    0x0(%rax),%edi
20a7:	add    $0x1,%rdi
20ab:	mov    %edi,0x0(%rax)
20ae:	mov    -0xa0(%rbp),%rsi
; data_stats->v2 += 1;
20b5:	mov    0x8(%rsi),%rdi
20b9:	add    $0x1,%rdi
20bd:	mov    %rdi,0x8(%rsi)
20c1:	mov    %r14,%r13
20c4:	jmp    0xffffffffc00d36d4
; __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
20c9:	mov    -0x48(%rbp),%edi
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
20cc:	mov    %rdi,-0x80(%rbp)
20d0:	mov    %rbx,%rdi
20d3:	mov    $0xffffffec,%esi
20d8:	call   0xffffffffbaa35c20
20dd:	shl    $0x20,%rax
20e1:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
20e5:	test   %rax,%rax
20e8:	jne    0xffffffffc00d3477
; data = (void*)(long)xdp->data;
20ee:	mov    0x0(%rbx),%rdi
; data_end = (void*)(long)xdp->data_end;
20f2:	mov    0x8(%rbx),%rsi
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
20f6:	mov    %rdi,%rdx
20f9:	add    $0xe,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
20fd:	cmp    %rsi,%rdx
2100:	ja     0xffffffffc00d3477
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2106:	mov    %rdi,%rdx
2109:	add    $0x22,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
210d:	cmp    %rsi,%rdx
2110:	ja     0xffffffffc00d3477
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2116:	cmp    %rsi,%rdx
2119:	ja     0xffffffffc00d3477
211f:	mov    -0xa8(%rbp),%rbx
2126:	bswap  %ebx
2128:	mov    $0xffff0000,%esi
; 
212d:	and    %rsi,%rbx
2130:	mov    -0x80(%rbp),%rsi
2134:	and    $0xffffffffffff0000,%rsi
213b:	xor    %rsi,%rbx
213e:	mov    %rbx,%rsi
2141:	or     $0x10ac,%rsi
2148:	mov    %rdi,%rdx
214b:	add    $0x14,%rdx
; memcpy(new_eth->h_dest, cval->mac, 6);
214f:	movzbq 0x5(%r15),%rcx
2154:	mov    %cl,0x5(%rdi)
2157:	movzbq 0x4(%r15),%rcx
215c:	mov    %cl,0x4(%rdi)
215f:	movzbq 0x3(%r15),%rcx
2164:	mov    %cl,0x3(%rdi)
2167:	movzbq 0x2(%r15),%rcx
216c:	mov    %cl,0x2(%rdi)
216f:	movzbq 0x1(%r15),%rcx
2174:	mov    %cl,0x1(%rdi)
2177:	movzbq 0x0(%r15),%rcx
217c:	mov    %cl,0x0(%rdi)
; memcpy(new_eth->h_source, old_eth->h_dest, 6);
217f:	movzbq 0x2(%rdx),%rcx
2184:	mov    %cl,0x8(%rdi)
2187:	movzbq 0x3(%rdx),%rcx
218c:	mov    %cl,0x9(%rdi)
218f:	movzbq 0x0(%rdx),%rcx
2194:	mov    %cl,0x6(%rdi)
2197:	movzbq 0x1(%rdx),%rcx
219c:	mov    %cl,0x7(%rdi)
219f:	movzbq 0x4(%rdx),%rcx
21a4:	mov    %cl,0xa(%rdi)
21a7:	movzbq 0x5(%rdx),%rdx
21ac:	mov    %dl,0xb(%rdi)
21af:	mov    $0x8,%edx
; new_eth->h_proto = BE_ETH_P_IP;
21b4:	mov    %dl,0xc(%rdi)
21b7:	xor    %edx,%edx
21b9:	mov    %dl,0xd(%rdi)
; create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
21bc:	mov    -0x88(%rbp),%rcx
21c3:	mov    0x0(%rcx),%ecx
; create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
21c6:	movzbq -0x1b(%rbp),%r8
21cb:	mov    $0x45,%eax
; iph->ihl = 5;
21d0:	mov    %al,0xe(%rdi)
; iph->tos = tos;
21d3:	mov    %r8b,0xf(%rdi)
; *csum += *next_iph_u16++;
21d7:	shl    $0x20,%rbx
21db:	shr    $0x20,%rbx
21df:	shr    $0x10,%rbx
21e3:	mov    %rcx,%r8
21e6:	and    $0xffff,%r8
; *csum += *next_iph_u16++;
21ed:	add    %r8,%rbx
; iph->id = 0;
21f0:	mov    %edx,0x12(%rdi)
21f3:	mov    $0x440,%edx
; iph->ttl = DEFAULT_TTL;
21f8:	mov    %dx,0x16(%rdi)
; iph->saddr = saddr;
21fc:	mov    %esi,0x1a(%rdi)
; iph->daddr = daddr;
21ff:	mov    %ecx,0x1e(%rdi)
; *csum += *next_iph_u16++;
2202:	shr    $0x10,%rcx
; *csum += *next_iph_u16++;
2206:	add    %rcx,%rbx
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
2209:	add    $0x14,%r13
220d:	ror    $0x8,%r13w
2212:	movzwl %r13w,%r13d
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
2216:	mov    %r13w,0x10(%rdi)
; *csum += *next_iph_u16++;
221b:	add    %r13,%rbx
; *csum += *next_iph_u16++;
221e:	movzwq 0xe(%rdi),%rsi
; *csum += *next_iph_u16++;
2223:	add    %rsi,%rbx
; *csum += *next_iph_u16++;
2226:	movzwq 0x16(%rdi),%rsi
; *csum += *next_iph_u16++;
222b:	add    %rsi,%rbx
222e:	add    $0x10ac,%rbx
2235:	mov    %rbx,%rdx
; if (csum >> 16)
2238:	mov    %rbx,%rsi
223b:	shr    $0x10,%rsi
; if (csum >> 16)
223f:	test   %rsi,%rsi
2242:	je     0xffffffffc00d4226
2244:	and    $0xffff,%rdx
224b:	add    %rsi,%rdx
; if (csum >> 16)
224e:	mov    %rdx,%rsi
2251:	shr    $0x10,%rsi
; if (csum >> 16)
2255:	test   %rsi,%rsi
2258:	je     0xffffffffc00d423c
225a:	and    $0xffff,%rdx
2261:	add    %rsi,%rdx
; if (csum >> 16)
2264:	mov    %rdx,%rsi
2267:	shr    $0x10,%rsi
; if (csum >> 16)
226b:	test   %rsi,%rsi
226e:	je     0xffffffffc00d4252
2270:	and    $0xffff,%rdx
2277:	add    %rsi,%rdx
; 
227a:	mov    %rdx,%rsi
227d:	shr    $0x10,%rsi
2281:	add    %rdx,%rsi
2284:	xor    $0xffffffffffffffff,%rsi
2288:	mov    %si,0x18(%rdi)
228c:	jmp    0xffffffffc00d2487
2291:	mov    %rbp,%rsi
; 
2294:	add    $0xffffffffffffffb8,%rsi
; struct real_pos_lru* dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);
2298:	mov    -0x98(%rbp),%rdi
229f:	call   0xffffffffb889c930
; if (dst_lru) {
22a4:	test   %rax,%rax
22a7:	je     0xffffffffc00d4f9f
; if (dst_lru->pos == pckt->real_index) {
22ad:	mov    0x0(%rax),%esi
; if (dst_lru->pos == pckt->real_index) {
22b0:	mov    -0x20(%rbp),%edi
; if (dst_lru->pos == pckt->real_index) {
22b3:	cmp    %rdi,%rsi
22b6:	je     0xffffffffc00d4295
22b8:	jmp    0xffffffffc00d504a
; quic_packets_stats->dst_match_in_lru += 1;
22bd:	mov    0x50(%r14),%rdi
22c1:	add    $0x1,%rdi
22c5:	mov    %rdi,0x50(%r14)
22c9:	jmp    0xffffffffc00d510d
; quic_packets_stats->cid_initial += 1;
22ce:	mov    0x8(%r14),%rdi
22d2:	add    $0x1,%rdi
22d6:	mov    %rdi,0x8(%r14)
; vip_num, /* new conn */ true, /* mismatch in lru */ false);
22da:	mov    -0x64(%rbp),%edi
22dd:	mov    %edi,-0x10(%rbp)
22e0:	mov    %rbp,%rsi
; 
22e3:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&server_id_stats, &vip_num);
22e7:	movabs $0xffff8881583d8000,%rdi
22f1:	add    $0x100,%rdi
22f8:	mov    0x0(%rsi),%eax
22fb:	cmp    $0x200,%rax
2302:	jae    0xffffffffc00d42f2
2304:	shl    $0x3,%rax
2308:	add    %rdi,%rax
230b:	mov    0x0(%rax),%rax
230f:	add    %gs:0xffffffffbe595028,%rax
2318:	jmp    0xffffffffc00d42f4
231a:	xor    %eax,%eax
; if (!per_vip_stats) {
231c:	test   %rax,%rax
231f:	je     0xffffffffc00d443d
; per_vip_stats->v1 += 1;
2325:	mov    0x0(%rax),%rdi
2329:	add    $0x1,%rdi
232d:	mov    %rdi,0x0(%rax)
2331:	jmp    0xffffffffc00d443d
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2336:	movzbq 0x1(%r15),%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
233b:	shl    $0x18,%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
233f:	movzbq 0x2(%r15),%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2344:	shl    $0x10,%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2348:	or     %rdi,%r13
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
234b:	movzbq 0x3(%r15),%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2350:	shl    $0x8,%rdi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
2354:	or     %rdi,%r13
2357:	mov    $0x48,%edi
; (connId[1] << 24) | (connId[2] << 16) | (connId[3] << 8) | (connId[4]);
235c:	movzbq 0x4(%r15),%rsi
2361:	jmp    0xffffffffc00d435a
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2363:	movzbq 0x1(%r15),%rdi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2368:	shl    $0x10,%rdi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
236c:	movzbq 0x2(%r15),%r13
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2371:	shl    $0x8,%r13
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
2375:	or     %rdi,%r13
2378:	mov    $0x40,%edi
; result.server_id = (connId[1] << 16) | (connId[2] << 8) | (connId[3]);
237d:	movzbq 0x3(%r15),%rsi
; 
2382:	and    $0xff,%rsi
2389:	or     %rsi,%r13
; struct quic_parse_result qpr = parse_quic(data, data_end, is_ipv6, &pckt);
238c:	mov    %r13,%rsi
238f:	shl    $0x20,%rsi
2393:	sar    $0x20,%rsi
2397:	mov    $0x1,%edx
; if (qpr.server_id > 0) {
239c:	cmp    %rsi,%rdx
239f:	jg     0xffffffffc00d4431
; 
23a5:	mov    %r14,%rsi
23a8:	add    %rdi,%rsi
23ab:	mov    0x0(%rsi),%rdi
23af:	add    $0x1,%rdi
23b3:	mov    %rdi,0x0(%rsi)
; __u32 key = qpr.server_id;
23b7:	mov    %r13d,-0x14(%rbp)
23bb:	mov    %rbp,%rsi
; 
23be:	add    $0xffffffffffffffec,%rsi
; __u32* real_pos = bpf_map_lookup_elem(&server_id_map, &key);
23c2:	movabs $0xffffc9001872e000,%rdi
23cc:	add    $0x100,%rdi
23d3:	mov    0x0(%rsi),%eax
23d6:	cmp    $0xfffffe,%rax
23dd:	jae    0xffffffffc00d43c0
23df:	shl    $0x3,%rax
23e3:	add    %rdi,%rax
23e6:	jmp    0xffffffffc00d43c2
23e8:	xor    %eax,%eax
; if (real_pos) {
23ea:	test   %rax,%rax
23ed:	je     0xffffffffc00d4419
; key = *real_pos;
23ef:	mov    0x0(%rax),%edi
; key = *real_pos;
23f2:	mov    %edi,-0x14(%rbp)
; if (key == 0) {
23f5:	test   %rdi,%rdi
23f8:	je     0xffffffffc00d4419
; pckt.real_index = key;
23fa:	mov    %edi,-0x20(%rbp)
23fd:	mov    %rbp,%rsi
2400:	add    $0xffffffffffffffec,%rsi
; dst = bpf_map_lookup_elem(&reals, &key);
2404:	movabs $0xffffc90018700000,%rdi
240e:	add    $0x100,%rdi
2415:	mov    0x0(%rsi),%eax
2418:	cmp    $0x1000,%rax
241f:	jae    0xffffffffc00d4402
2421:	imul   $0x18,%rax,%rax
2425:	add    %rdi,%rax
2428:	jmp    0xffffffffc00d4404
242a:	xor    %eax,%eax
242c:	mov    %rax,-0xa8(%rbp)
; if (!dst) {
2433:	test   %rax,%rax
2436:	jne    0xffffffffc00d50ae
243c:	jmp    0xffffffffc00d3465
; 
2441:	shl    $0x20,%r13
2445:	sar    $0x20,%r13
2449:	mov    %r13,0x18(%r14)
244d:	mov    0x10(%r14),%rdi
2451:	add    $0x1,%rdi
2455:	mov    %rdi,0x10(%r14)
; 
2459:	mov    0x0(%r14),%rdi
245d:	add    $0x1,%rdi
2461:	mov    %rdi,0x0(%r14)
2465:	mov    -0x90(%rbp),%rsi
246c:	xor    %r13d,%r13d
; original_sport = pckt.flow.port16[0];
246f:	movzwq -0x28(%rbp),%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
2474:	mov    %rdi,-0xb0(%rbp)
247b:	movzbq -0x1c(%rbp),%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
2480:	and    $0x2,%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
2484:	test   %rdi,%rdi
2487:	jne    0xffffffffc00d4506
; !(vip_info->flags & F_LRU_BYPASS)) {
248d:	mov    0x0(%rsi),%edi
; !(vip_info->flags & F_LRU_BYPASS)) {
2490:	and    $0x2,%rdi
; if (!dst && !(pckt.flags & F_SYN_SET) &&
2494:	test   %rdi,%rdi
2497:	jne    0xffffffffc00d4506
249d:	mov    %rbp,%rsi
; 
24a0:	add    $0xffffffffffffffb8,%rsi
; dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);
24a4:	mov    -0x98(%rbp),%rdi
24ab:	call   0xffffffffb889c930
24b0:	mov    %rax,%r14
24b3:	xor    %r13d,%r13d
; if (!dst_lru) {
24b6:	test   %r14,%r14
24b9:	je     0xffffffffc00d44ff
; if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
24bb:	movzbq -0x24(%rbp),%rdi
; if (!isGlobalLru && pckt->flow.proto == IPPROTO_UDP) {
24c0:	cmp    $0x11,%rdi
24c4:	jne    0xffffffffc00d44c3
; cur_time = bpf_ktime_get_ns();
24c6:	call   0xffffffffb889d630
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
24cb:	mov    0x8(%r14),%rdi
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
24cf:	mov    %rax,%rsi
24d2:	sub    %rdi,%rsi
24d5:	movabs $0x6fc23ac00,%rdi
24df:	xor    %r13d,%r13d
; if (cur_time - dst_lru->atime > LRU_UDP_TIMEOUT) {
24e2:	cmp    %rdi,%rsi
24e5:	ja     0xffffffffc00d44ff
; dst_lru->atime = cur_time;
24e7:	mov    %rax,0x8(%r14)
; key = dst_lru->pos;
24eb:	mov    0x0(%r14),%edi
; pckt->real_index = key;
24ef:	mov    %edi,-0x20(%rbp)
; key = dst_lru->pos;
24f2:	mov    %edi,-0x10(%rbp)
24f5:	mov    %rbp,%rsi
; key = dst_lru->pos;
24f8:	add    $0xfffffffffffffff0,%rsi
; *real = bpf_map_lookup_elem(&reals, &key);
24fc:	movabs $0xffffc90018700000,%rdi
2506:	add    $0x100,%rdi
250d:	mov    0x0(%rsi),%eax
2510:	cmp    $0x1000,%rax
2517:	jae    0xffffffffc00d44fa
2519:	imul   $0x18,%rax,%rax
251d:	add    %rdi,%rax
2520:	jmp    0xffffffffc00d44fc
2522:	xor    %eax,%eax
2524:	mov    %rax,%r13
2527:	mov    -0x90(%rbp),%rsi
; if (dst && pckt->flow.proto == IPPROTO_UDP &&
252e:	movzbq -0x24(%rbp),%rdi
; if (dst && pckt->flow.proto == IPPROTO_UDP &&
2533:	cmp    $0x11,%rdi
2537:	jne    0xffffffffc00d4663
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
253d:	mov    0x0(%rsi),%edi
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
2540:	and    $0x200,%rdi
; vip_info->flags & F_UDP_FLOW_MIGRATION && !is_under_flood(&cur_time)) {
2547:	test   %rdi,%rdi
254a:	je     0xffffffffc00d4663
2550:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
2555:	mov    %edi,-0x10(%rbp)
2558:	mov    %rbp,%rsi
; 
255b:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
255f:	movabs $0xffff888138844000,%rdi
2569:	add    $0x100,%rdi
2570:	mov    0x0(%rsi),%eax
2573:	cmp    $0x400,%rax
257a:	jae    0xffffffffc00d456a
257c:	shl    $0x3,%rax
2580:	add    %rdi,%rax
2583:	mov    0x0(%rax),%rax
2587:	add    %gs:0xffffffffbe595028,%rax
2590:	jmp    0xffffffffc00d456c
2592:	xor    %eax,%eax
2594:	mov    %rax,%r14
; if (!conn_rate_stats) {
2597:	test   %r14,%r14
259a:	je     0xffffffffc00d4663
; *cur_time = bpf_ktime_get_ns();
25a0:	call   0xffffffffb889d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
25a5:	mov    0x8(%r14),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
25a9:	mov    %rax,%rsi
25ac:	sub    %rdi,%rsi
25af:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
25b4:	cmp    %rsi,%rdi
25b7:	ja     0xffffffffc00d4649
; conn_rate_stats->v2 = *cur_time;
25bd:	mov    %rax,0x8(%r14)
25c1:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
25c6:	mov    %rdi,0x0(%r14)
25ca:	mov    %rbp,%rsi
; void* down_reals_map = bpf_map_lookup_elem(&vip_to_down_reals_map, vip);
25cd:	add    $0xffffffffffffffa0,%rsi
25d1:	movabs $0xffff8881583c3000,%rdi
25db:	call   0xffffffffb88bb9b0
25e0:	test   %rax,%rax
25e3:	je     0xffffffffc00d45c5
25e5:	add    $0x48,%rax
25e9:	mov    0x0(%rax),%rax
; if (down_reals_map) {
25ed:	test   %rax,%rax
25f0:	je     0xffffffffc00d4663
; void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
25f6:	mov    %rbp,%rsi
25f9:	add    $0xffffffffffffffe0,%rsi
; void* down_real = bpf_map_lookup_elem(down_reals_map, &pckt->real_index);
25fd:	mov    %rax,%rdi
2600:	call   0xffffffffb88bb9b0
2605:	test   %rax,%rax
2608:	je     0xffffffffc00d45e6
260a:	add    $0x38,%rax
; if (down_real) {
260e:	test   %rax,%rax
2611:	je     0xffffffffc00d4663
2613:	mov    $0x20f,%edi
; __u32 stats_key = MAX_VIPS + UDP_FLOW_MIGRATION_STATS;
2618:	mov    %edi,-0x10(%rbp)
261b:	mov    %rbp,%rsi
; 
261e:	add    $0xfffffffffffffff0,%rsi
; struct lb_stats* stats_data = bpf_map_lookup_elem(&stats, &stats_key);
2622:	movabs $0xffff888138844000,%rdi
262c:	add    $0x100,%rdi
2633:	mov    0x0(%rsi),%eax
2636:	cmp    $0x400,%rax
263d:	jae    0xffffffffc00d462d
263f:	shl    $0x3,%rax
2643:	add    %rdi,%rax
2646:	mov    0x0(%rax),%rax
264a:	add    %gs:0xffffffffbe595028,%rax
2653:	jmp    0xffffffffc00d462f
2655:	xor    %eax,%eax
; if (stats_data) {
2657:	test   %rax,%rax
265a:	je     0xffffffffc00d48d8
; stats_data->v1 += 1;
2660:	mov    0x0(%rax),%rdi
2664:	add    $0x1,%rdi
2668:	mov    %rdi,0x0(%rax)
266c:	jmp    0xffffffffc00d48d8
; conn_rate_stats->v1 += 1;
2671:	mov    0x0(%r14),%rdi
2675:	add    $0x1,%rdi
2679:	mov    %rdi,0x0(%r14)
267d:	mov    $0x1e849,%esi
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
2682:	cmp    %rdi,%rsi
2685:	ja     0xffffffffc00d45a2
268b:	mov    %r13,-0xa8(%rbp)
; if (!dst) {
2692:	test   %r13,%r13
2695:	jne    0xffffffffc00d4674
2697:	jmp    0xffffffffc00d48d8
269c:	mov    %rbp,%rsi
; 
269f:	add    $0xffffffffffffff98,%rsi
; cval = bpf_map_lookup_elem(&ctl_array, &mac_addr_pos);
26a3:	movabs $0xffff8881064d3c00,%rdi
26ad:	add    $0x100,%rdi
26b4:	mov    0x0(%rsi),%eax
26b7:	cmp    $0x10,%rax
26bb:	jae    0xffffffffc00d469e
26bd:	shl    $0x3,%rax
26c1:	add    %rdi,%rax
26c4:	jmp    0xffffffffc00d46a0
26c6:	xor    %eax,%eax
26c8:	mov    %rax,%r15
26cb:	mov    $0x1,%r14d
; if (!cval) {
26d1:	test   %r15,%r15
26d4:	je     0xffffffffc00d3477
26da:	mov    %rbp,%rsi
; 
26dd:	add    $0xffffffffffffff9c,%rsi
; data_stats = bpf_map_lookup_elem(&stats, &vip_num);
26e1:	movabs $0xffff888138844000,%rdi
26eb:	add    $0x100,%rdi
26f2:	mov    0x0(%rsi),%eax
26f5:	cmp    $0x400,%rax
26fc:	jae    0xffffffffc00d46ec
26fe:	shl    $0x3,%rax
2702:	add    %rdi,%rax
2705:	mov    0x0(%rax),%rax
2709:	add    %gs:0xffffffffbe595028,%rax
2712:	jmp    0xffffffffc00d46ee
2714:	xor    %eax,%eax
; if (!data_stats) {
2716:	test   %rax,%rax
2719:	je     0xffffffffc00d3477
271f:	mov    -0x80(%rbp),%r13
2723:	ror    $0x8,%r13w
2728:	movzwl %r13w,%r13d
; data_stats->v1 += 1;
272c:	mov    0x0(%rax),%rdi
2730:	add    $0x1,%rdi
2734:	mov    %rdi,0x0(%rax)
; data_stats->v2 += pkt_bytes;
2738:	mov    0x8(%rax),%rdi
273c:	add    %r13,%rdi
273f:	mov    %rdi,0x8(%rax)
; data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
2743:	mov    %rbp,%rsi
2746:	add    $0xffffffffffffffe0,%rsi
; data_stats = bpf_map_lookup_elem(&reals_stats, &pckt.real_index);
274a:	movabs $0xffffc9001871a000,%rdi
2754:	add    $0x100,%rdi
275b:	mov    0x0(%rsi),%eax
275e:	cmp    $0x1000,%rax
2765:	jae    0xffffffffc00d4755
2767:	shl    $0x3,%rax
276b:	add    %rdi,%rax
276e:	mov    0x0(%rax),%rax
2772:	add    %gs:0xffffffffbe595028,%rax
277b:	jmp    0xffffffffc00d4757
277d:	xor    %eax,%eax
; if (!data_stats) {
277f:	test   %rax,%rax
2782:	je     0xffffffffc00d3477
; data_stats->v1 += 1;
2788:	mov    0x0(%rax),%rdi
278c:	add    $0x1,%rdi
2790:	mov    %rdi,0x0(%rax)
; data_stats->v2 += pkt_bytes;
2794:	mov    0x8(%rax),%rdi
2798:	add    %r13,%rdi
279b:	mov    %rdi,0x8(%rax)
; pckt.flow.port16[0] = original_sport;
279f:	mov    -0xb0(%rbp),%rdi
27a6:	mov    %di,-0x28(%rbp)
; if (dst->flags & F_IPV6) {
27aa:	mov    -0xa8(%rbp),%rdi
27b1:	movzbq 0x10(%rdi),%rdi
; if (dst->flags & F_IPV6) {
27b6:	and    $0x1,%rdi
; if (dst->flags & F_IPV6) {
27ba:	test   %rdi,%rdi
27bd:	je     0xffffffffc00d4def
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
27c3:	mov    %rbx,%rdi
27c6:	mov    $0xffffffd8,%esi
27cb:	call   0xffffffffbaa35c20
27d0:	shl    $0x20,%rax
27d4:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct ipv6hdr))) {
27d8:	test   %rax,%rax
27db:	jne    0xffffffffc00d3477
; data = (void*)(long)xdp->data;
27e1:	mov    0x0(%rbx),%rdi
; data_end = (void*)(long)xdp->data_end;
27e5:	mov    0x8(%rbx),%rsi
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
27e9:	mov    %rdi,%rdx
27ec:	add    $0xe,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
27f0:	cmp    %rsi,%rdx
27f3:	ja     0xffffffffc00d3477
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
27f9:	mov    %rdi,%rdx
27fc:	add    $0x36,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
2800:	cmp    %rsi,%rdx
2803:	ja     0xffffffffc00d3477
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || ip6h + 1 > data_end) {
2809:	cmp    %rsi,%rdx
280c:	ja     0xffffffffc00d3477
; 
2812:	mov    %rdi,%rsi
2815:	add    $0x28,%rsi
; memcpy(new_eth->h_dest, cval->mac, 6);
2819:	movzbq 0x5(%r15),%rdx
281e:	mov    %dl,0x5(%rdi)
2821:	movzbq 0x4(%r15),%rdx
2826:	mov    %dl,0x4(%rdi)
2829:	movzbq 0x3(%r15),%rdx
282e:	mov    %dl,0x3(%rdi)
2831:	movzbq 0x2(%r15),%rdx
2836:	mov    %dl,0x2(%rdi)
2839:	movzbq 0x1(%r15),%rdx
283e:	mov    %dl,0x1(%rdi)
2841:	movzbq 0x0(%r15),%rdx
2846:	mov    %dl,0x0(%rdi)
; memcpy(new_eth->h_source, old_eth->h_dest, 6);
2849:	movzbq 0x2(%rsi),%rdx
284e:	mov    %dl,0x8(%rdi)
2851:	movzbq 0x3(%rsi),%rdx
2856:	mov    %dl,0x9(%rdi)
2859:	movzbq 0x0(%rsi),%rdx
285e:	mov    %dl,0x6(%rdi)
2861:	movzbq 0x1(%rsi),%rdx
2866:	mov    %dl,0x7(%rdi)
2869:	movzbq 0x4(%rsi),%rdx
286e:	mov    %dl,0xa(%rdi)
2871:	movzbq 0x5(%rsi),%rsi
2876:	mov    %sil,0xb(%rdi)
287a:	mov    $0x86,%esi
; new_eth->h_proto = BE_ETH_P_IPV6;
287f:	mov    %sil,0xc(%rdi)
2883:	mov    $0xdd,%esi
2888:	mov    %sil,0xd(%rdi)
; create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
288c:	movzwq -0x28(%rbp),%rsi
; create_encap_ipv6_src(pckt->flow.port16[0], pckt->flow.src, saddr);
2891:	mov    -0x48(%rbp),%edx
; saddr[3] = src ^ port;
2894:	xor    %rsi,%rdx
; create_v6_hdr(ip6h, pckt->tos, saddr, dst->dstv6, payload_len, proto);
2897:	movzbq -0x1b(%rbp),%rsi
289c:	mov    $0x4004,%ecx
; ip6h->nexthdr = proto;
28a1:	mov    %cx,0x14(%rdi)
28a5:	mov    $0x1,%ecx
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
28aa:	mov    %ecx,0x16(%rdi)
28ad:	xor    %ecx,%ecx
28af:	mov    %ecx,0x1a(%rdi)
28b2:	mov    %ecx,0x1e(%rdi)
; memset(ip6h->flow_lbl, 0, sizeof(ip6h->flow_lbl));
28b5:	mov    %cl,0x10(%rdi)
28b8:	mov    %cl,0x11(%rdi)
; ip6h->payload_len = bpf_htons(payload_len);
28bb:	mov    -0x80(%rbp),%rcx
28bf:	mov    %cx,0x12(%rdi)
; memcpy(ip6h->saddr.s6_addr32, saddr, 16);
28c3:	mov    %edx,0x22(%rdi)
; ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
28c6:	mov    %rsi,%rdx
28c9:	shl    $0x4,%rdx
; ip6h->flow_lbl[0] = (tc & 0x0F) << 4;
28cd:	mov    %dl,0xf(%rdi)
; ip6h->priority = (tc & 0xF0) >> 4;
28d0:	shr    $0x4,%rsi
; ip6h->priority = (tc & 0xF0) >> 4;
28d4:	or     $0x60,%rsi
28d8:	mov    %sil,0xe(%rdi)
28dc:	mov    -0xa8(%rbp),%rdx
; 
28e3:	mov    0xc(%rdx),%esi
28e6:	mov    %esi,0x32(%rdi)
28e9:	mov    0x8(%rdx),%esi
28ec:	mov    %esi,0x2e(%rdi)
28ef:	mov    0x4(%rdx),%esi
28f2:	mov    %esi,0x2a(%rdi)
28f5:	mov    0x0(%rdx),%esi
28f8:	mov    %esi,0x26(%rdi)
28fb:	jmp    0xffffffffc00d2487
; if (pckt.flow.proto == IPPROTO_TCP) {
2900:	movzbq -0x24(%rbp),%rdi
; if (pckt.flow.proto == IPPROTO_TCP) {
2905:	cmp    $0x6,%rdi
2909:	jne    0xffffffffc00d4958
290b:	mov    $0x201,%edi
; __u32 lru_stats_key = MAX_VIPS + LRU_MISS_CNTR;
2910:	mov    %edi,-0x10(%rbp)
2913:	mov    %rbp,%rsi
; 
2916:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &lru_stats_key);
291a:	movabs $0xffff888138844000,%rdi
2924:	add    $0x100,%rdi
292b:	mov    0x0(%rsi),%eax
292e:	cmp    $0x400,%rax
2935:	jae    0xffffffffc00d4925
2937:	shl    $0x3,%rax
293b:	add    %rdi,%rax
293e:	mov    0x0(%rax),%rax
2942:	add    %gs:0xffffffffbe595028,%rax
294b:	jmp    0xffffffffc00d4927
294d:	xor    %eax,%eax
; if (!lru_stats) {
294f:	test   %rax,%rax
2952:	je     0xffffffffc00d3471
; if (pckt.flags & F_SYN_SET) {
2958:	movzbq -0x1c(%rbp),%rsi
; if (pckt.flags & F_SYN_SET) {
295d:	and    $0x2,%rsi
2961:	mov    $0x1,%edi
2966:	test   %rsi,%rsi
2969:	je     0xffffffffc00d4945
296b:	xor    %edi,%edi
; if (pckt.flags & F_SYN_SET) {
296d:	shl    $0x3,%rdi
; 
2971:	add    %rdi,%rax
2974:	mov    0x0(%rax),%rdi
2978:	add    $0x1,%rdi
297c:	mov    %rdi,0x0(%rax)
2980:	xor    %esi,%esi
; struct real_pos_lru new_dst_lru = {};
2982:	mov    %rsi,-0x8(%rbp)
2986:	xor    %edi,%edi
2988:	mov    %rdi,-0xb8(%rbp)
298f:	mov    %rsi,-0x10(%rbp)
2993:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
2998:	mov    %edi,-0x78(%rbp)
299b:	mov    %rbp,%rsi
; 
299e:	add    $0xffffffffffffff88,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
29a2:	movabs $0xffff888138844000,%rdi
29ac:	add    $0x100,%rdi
29b3:	mov    0x0(%rsi),%eax
29b6:	cmp    $0x400,%rax
29bd:	jae    0xffffffffc00d49ad
29bf:	shl    $0x3,%rax
29c3:	add    %rdi,%rax
29c6:	mov    0x0(%rax),%rax
29ca:	add    %gs:0xffffffffbe595028,%rax
29d3:	jmp    0xffffffffc00d49af
29d5:	xor    %eax,%eax
29d7:	mov    %rax,%r14
29da:	mov    $0x1,%r15d
; if (!conn_rate_stats) {
29e0:	test   %r14,%r14
29e3:	je     0xffffffffc00d4a0b
; *cur_time = bpf_ktime_get_ns();
29e5:	call   0xffffffffb889d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
29ea:	mov    0x8(%r14),%rdi
29ee:	mov    %rax,-0xb8(%rbp)
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
29f5:	mov    %rax,%rsi
29f8:	sub    %rdi,%rsi
29fb:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
2a00:	cmp    %rsi,%rdi
2a03:	ja     0xffffffffc00d49f3
; conn_rate_stats->v2 = *cur_time;
2a05:	mov    -0xb8(%rbp),%rdi
2a0c:	mov    %rdi,0x8(%r14)
2a10:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
2a15:	mov    %rdi,0x0(%r14)
2a19:	jmp    0xffffffffc00d4a08
; conn_rate_stats->v1 += 1;
2a1b:	mov    0x0(%r14),%rdi
2a1f:	add    $0x1,%rdi
2a23:	mov    %rdi,0x0(%r14)
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
2a27:	cmp    $0x1e848,%rdi
2a2e:	ja     0xffffffffc00d4a0b
2a30:	xor    %r15d,%r15d
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
2a33:	mov    -0x90(%rbp),%rdi
2a3a:	mov    0x0(%rdi),%edi
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
2a3d:	and    $0x8,%rdi
; if (vip_info->flags & F_HASH_DPORT_ONLY) {
2a41:	test   %rdi,%rdi
2a44:	jne    0xffffffffc00d4a24
; return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
2a46:	mov    -0x48(%rbp),%r8d
2a4a:	jmp    0xffffffffc00d4a3f
; pckt->flow.port16[0] = pckt->flow.port16[1];
2a4c:	mov    -0x88(%rbp),%rdi
2a53:	movzwq 0x2(%rdi),%rdi
; pckt->flow.port16[0] = pckt->flow.port16[1];
2a58:	mov    %di,-0x28(%rbp)
2a5c:	xor    %r8d,%r8d
; memset(pckt->flow.srcv6, 0, 16);
2a5f:	mov    %r8,-0x48(%rbp)
2a63:	mov    %r8,-0x40(%rbp)
; return jhash_2words(pckt->flow.src, pckt->flow.ports, INIT_JHASH_SEED);
2a67:	mov    -0x28(%rbp),%edx
; b += initval;
2a6a:	add    $0xffffffffe0adc0f7,%rdx
2a71:	mov    $0xfffc0000,%edi
2a76:	mov    %rdx,%rsi
2a79:	and    %rdi,%rsi
; return (word << shift) | (word >> ((-shift) & 31));
2a7c:	shr    $0x12,%rsi
2a80:	mov    %rdx,%rcx
2a83:	shl    $0xe,%rcx
2a87:	or     %rsi,%rcx
; __jhash_final(a, b, c);
2a8a:	mov    %rdx,%rsi
2a8d:	xor    $0xffffffffe0adc0f7,%rsi
2a94:	sub    %rcx,%rsi
2a97:	mov    $0xffe00000,%ecx
2a9c:	mov    %rsi,%rax
2a9f:	and    %rcx,%rax
; return (word << shift) | (word >> ((-shift) & 31));
2aa2:	shr    $0x15,%rax
2aa6:	mov    %rsi,%r13
2aa9:	shl    $0xb,%r13
2aad:	or     %rax,%r13
; a += initval;
2ab0:	add    $0xffffffffe0adc0f7,%r8
; __jhash_final(a, b, c);
2ab7:	mov    %rsi,%rcx
2aba:	xor    %r8,%rcx
2abd:	sub    %r13,%rcx
2ac0:	mov    $0xffffff80,%r8d
2ac6:	mov    %rcx,%rax
2ac9:	and    %r8,%rax
; return (word << shift) | (word >> ((-shift) & 31));
2acc:	shr    $0x7,%rax
2ad0:	mov    %rcx,%r13
2ad3:	shl    $0x19,%r13
2ad7:	or     %rax,%r13
; __jhash_final(a, b, c);
2ada:	mov    %rcx,%r8
2add:	xor    %rdx,%r8
2ae0:	sub    %r13,%r8
2ae3:	mov    $0xffff0000,%edx
2ae8:	mov    %r8,%rax
2aeb:	and    %rdx,%rax
; return (word << shift) | (word >> ((-shift) & 31));
2aee:	shr    $0x10,%rax
2af2:	mov    %r8,%r13
2af5:	shl    $0x10,%r13
2af9:	or     %rax,%r13
; __jhash_final(a, b, c);
2afc:	mov    %r8,%rdx
2aff:	xor    %rsi,%rdx
2b02:	sub    %r13,%rdx
2b05:	mov    $0xf0000000,%esi
2b0a:	mov    %rdx,%rax
2b0d:	and    %rsi,%rax
; return (word << shift) | (word >> ((-shift) & 31));
2b10:	shr    $0x1c,%rax
2b14:	mov    %rdx,%r13
2b17:	shl    $0x4,%r13
2b1b:	or     %rax,%r13
; __jhash_final(a, b, c);
2b1e:	mov    %rdx,%rsi
2b21:	xor    %rcx,%rsi
2b24:	sub    %r13,%rsi
2b27:	mov    %rsi,%rcx
2b2a:	and    %rdi,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
2b2d:	shr    $0x12,%rcx
2b31:	mov    %rsi,%rdi
2b34:	shl    $0xe,%rdi
2b38:	or     %rcx,%rdi
; __jhash_final(a, b, c);
2b3b:	xor    %r8,%rsi
2b3e:	sub    %rdi,%rsi
2b41:	mov    $0xffffff00,%edi
2b46:	mov    %rsi,%rcx
2b49:	and    %rdi,%rcx
; return (word << shift) | (word >> ((-shift) & 31));
2b4c:	shr    $0x8,%rcx
2b50:	mov    %rsi,%rdi
2b53:	shl    $0x18,%rdi
2b57:	or     %rcx,%rdi
; __jhash_final(a, b, c);
2b5a:	xor    %rdx,%rsi
2b5d:	sub    %rdi,%rsi
2b60:	mov    %rsi,%rdi
2b63:	shl    $0x20,%rdi
2b67:	shr    $0x20,%rdi
; hash = get_packet_hash(pckt, hash_16bytes) % RING_SIZE;
2b6b:	push   %rax
2b6c:	push   %rdx
2b6d:	mov    $0x10001,%r11
2b74:	mov    %rdi,%rax
2b77:	xor    %edx,%edx
2b79:	div    %r11
2b7c:	mov    %rax,%rdi
2b7f:	pop    %rdx
2b80:	pop    %rax
2b81:	imul   $0x10001,%rdi,%rdi
2b88:	sub    %rdi,%rsi
; key = RING_SIZE * (vip_info->vip_num) + hash;
2b8b:	mov    -0x90(%rbp),%rdi
2b92:	mov    0x4(%rdi),%edi
; key = RING_SIZE * (vip_info->vip_num) + hash;
2b95:	imul   $0x10001,%rdi,%rdi
; key = RING_SIZE * (vip_info->vip_num) + hash;
2b9c:	add    %rdi,%rsi
; key = RING_SIZE * (vip_info->vip_num) + hash;
2b9f:	mov    %esi,-0x14(%rbp)
2ba2:	mov    %rbp,%rsi
; 
2ba5:	add    $0xffffffffffffffec,%rsi
; real_pos = bpf_map_lookup_elem(&ch_rings, &key);
2ba9:	movabs $0xffffc9000867b000,%rdi
2bb3:	add    $0x100,%rdi
2bba:	mov    0x0(%rsi),%eax
2bbd:	cmp    $0x2000200,%rax
2bc4:	jae    0xffffffffc00d4ba7
2bc6:	shl    $0x3,%rax
2bca:	add    %rdi,%rax
2bcd:	jmp    0xffffffffc00d4ba9
2bcf:	xor    %eax,%eax
; if (!real_pos) {
2bd1:	test   %rax,%rax
2bd4:	je     0xffffffffc00d3471
; key = *real_pos;
2bda:	mov    0x0(%rax),%edi
; key = *real_pos;
2bdd:	mov    %edi,-0x14(%rbp)
; if (key == 0) {
2be0:	test   %rdi,%rdi
2be3:	jne    0xffffffffc00d4c21
2be5:	mov    $0x209,%edi
; __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
2bea:	mov    %edi,-0x78(%rbp)
2bed:	mov    %rbp,%rsi
; 
2bf0:	add    $0xffffffffffffff88,%rsi
; bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
2bf4:	movabs $0xffff888138844000,%rdi
2bfe:	add    $0x100,%rdi
2c05:	mov    0x0(%rsi),%eax
2c08:	cmp    $0x400,%rax
2c0f:	jae    0xffffffffc00d4bff
2c11:	shl    $0x3,%rax
2c15:	add    %rdi,%rax
2c18:	mov    0x0(%rax),%rax
2c1c:	add    %gs:0xffffffffbe595028,%rax
2c25:	jmp    0xffffffffc00d4c01
2c27:	xor    %eax,%eax
; if (!ch_drop_stats) {
2c29:	test   %rax,%rax
2c2c:	je     0xffffffffc00d3471
; 
2c32:	mov    0x8(%rax),%rdi
2c36:	add    $0x1,%rdi
2c3a:	mov    %rdi,0x8(%rax)
2c3e:	mov    $0x1,%r14d
2c44:	jmp    0xffffffffc00d3477
; pckt->real_index = key;
2c49:	mov    %edi,-0x20(%rbp)
2c4c:	mov    %rbp,%rsi
; 
2c4f:	add    $0xffffffffffffffec,%rsi
; *real = bpf_map_lookup_elem(&reals, &key);
2c53:	movabs $0xffffc90018700000,%rdi
2c5d:	add    $0x100,%rdi
2c64:	mov    0x0(%rsi),%eax
2c67:	cmp    $0x1000,%rax
2c6e:	jae    0xffffffffc00d4c51
2c70:	imul   $0x18,%rax,%rax
2c74:	add    %rdi,%rax
2c77:	jmp    0xffffffffc00d4c53
2c79:	xor    %eax,%eax
2c7b:	mov    %rax,-0xa8(%rbp)
; if (!(*real)) {
2c82:	test   %rax,%rax
2c85:	jne    0xffffffffc00d4cc3
2c87:	mov    $0x209,%edi
; __u32 ch_drop_stats_key = MAX_VIPS + CH_DROP_STATS;
2c8c:	mov    %edi,-0x78(%rbp)
2c8f:	mov    %rbp,%rsi
; 
2c92:	add    $0xffffffffffffff88,%rsi
; bpf_map_lookup_elem(&stats, &ch_drop_stats_key);
2c96:	movabs $0xffff888138844000,%rdi
2ca0:	add    $0x100,%rdi
2ca7:	mov    0x0(%rsi),%eax
2caa:	cmp    $0x400,%rax
2cb1:	jae    0xffffffffc00d4ca1
2cb3:	shl    $0x3,%rax
2cb7:	add    %rdi,%rax
2cba:	mov    0x0(%rax),%rax
2cbe:	add    %gs:0xffffffffbe595028,%rax
2cc7:	jmp    0xffffffffc00d4ca3
2cc9:	xor    %eax,%eax
; if (!ch_drop_stats) {
2ccb:	test   %rax,%rax
2cce:	je     0xffffffffc00d3471
; 
2cd4:	mov    0x0(%rax),%rdi
2cd8:	add    $0x1,%rdi
2cdc:	mov    %rdi,0x0(%rax)
2ce0:	mov    $0x1,%r14d
2ce6:	jmp    0xffffffffc00d3477
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
2ceb:	mov    -0x98(%rbp),%rdi
2cf2:	test   %rdi,%rdi
2cf5:	je     0xffffffffc00d4d20
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
2cf7:	mov    -0x90(%rbp),%rdi
2cfe:	mov    0x0(%rdi),%edi
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
2d01:	and    $0x2,%rdi
2d05:	shr    %rdi
; if (lru_map && !(vip_info->flags & F_LRU_BYPASS) && !under_flood) {
2d08:	or     %rdi,%r15
2d0b:	test   %r15,%r15
2d0e:	jne    0xffffffffc00d4d20
; if (pckt->flow.proto == IPPROTO_UDP) {
2d10:	movzbq -0x24(%rbp),%rdi
; if (pckt->flow.proto == IPPROTO_UDP) {
2d15:	cmp    $0x11,%rdi
2d19:	jne    0xffffffffc00d4cfe
; new_dst_lru.atime = cur_time;
2d1b:	mov    -0xb8(%rbp),%rdi
2d22:	mov    %rdi,-0x8(%rbp)
; new_dst_lru.pos = key;
2d26:	mov    -0x14(%rbp),%edi
; new_dst_lru.pos = key;
2d29:	mov    %edi,-0x10(%rbp)
2d2c:	mov    %rbp,%rsi
; new_dst_lru.pos = key;
2d2f:	add    $0xffffffffffffffb8,%rsi
2d33:	mov    %rbp,%rdx
2d36:	add    $0xfffffffffffffff0,%rdx
; bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
2d3a:	mov    -0x98(%rbp),%rdi
2d41:	xor    %ecx,%ecx
2d43:	call   0xffffffffb889c9c0
2d48:	xor    %edi,%edi
; __u32 vip_miss_stats_key = 0;
2d4a:	mov    %edi,-0x10(%rbp)
2d4d:	mov    %rbp,%rsi
; 
2d50:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&vip_miss_stats, &vip_miss_stats_key);
2d54:	movabs $0xffff8881064d4000,%rdi
2d5e:	add    $0x100,%rdi
2d65:	mov    0x0(%rsi),%eax
2d68:	cmp    $0x1,%rax
2d6c:	jae    0xffffffffc00d4d4f
2d6e:	imul   $0x18,%rax,%rax
2d72:	add    %rdi,%rax
2d75:	jmp    0xffffffffc00d4d51
2d77:	xor    %eax,%eax
; if (!lru_miss_stat_vip) {
2d79:	test   %rax,%rax
2d7c:	je     0xffffffffc00d3471
; bool vip_match = address_match && port_match && proto_match;
2d82:	movzwq -0x50(%rbp),%rsi
; (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
2d87:	mov    -0x60(%rbp),%edx
; bool vip_match = address_match && port_match && proto_match;
2d8a:	movzbq -0x4e(%rbp),%rdi
; bool proto_match = lru_miss_stat_vip->proto = vip->proto;
2d8f:	mov    %dil,0x12(%rax)
; (!is_ipv6 && lru_miss_stat_vip->vip == vip->vip);
2d93:	mov    0x0(%rax),%ecx
; bool vip_match = address_match && port_match && proto_match;
2d96:	cmp    %rdx,%rcx
2d99:	jne    0xffffffffc00d4dd7
2d9b:	movzwq 0x10(%rax),%rdx
2da0:	cmp    %rsi,%rdx
2da3:	jne    0xffffffffc00d4dd7
2da5:	test   %rdi,%rdi
2da8:	je     0xffffffffc00d4dd7
; __u32 lru_stats_key = pckt->real_index;
2daa:	mov    -0x20(%rbp),%edi
; __u32 lru_stats_key = pckt->real_index;
2dad:	mov    %edi,-0x78(%rbp)
2db0:	mov    %rbp,%rsi
; __u32 lru_stats_key = pckt->real_index;
2db3:	add    $0xffffffffffffff88,%rsi
; __u32* lru_miss_stat = bpf_map_lookup_elem(&lru_miss_stats, &lru_stats_key);
2db7:	movabs $0xffffc90018724000,%rdi
2dc1:	add    $0x100,%rdi
2dc8:	mov    0x0(%rsi),%eax
2dcb:	cmp    $0x1000,%rax
2dd2:	jae    0xffffffffc00d4dc2
2dd4:	shl    $0x3,%rax
2dd8:	add    %rdi,%rax
2ddb:	mov    0x0(%rax),%rax
2ddf:	add    %gs:0xffffffffbe595028,%rax
2de8:	jmp    0xffffffffc00d4dc4
2dea:	xor    %eax,%eax
; if (!lru_miss_stat) {
2dec:	test   %rax,%rax
2def:	je     0xffffffffc00d3471
; *lru_miss_stat += 1;
2df5:	mov    0x0(%rax),%edi
2df8:	add    $0x1,%rdi
2dfc:	mov    %edi,0x0(%rax)
2dff:	mov    -0xa0(%rbp),%rsi
; data_stats->v2 += 1;
2e06:	mov    0x8(%rsi),%rdi
2e0a:	add    $0x1,%rdi
2e0e:	mov    %rdi,0x8(%rsi)
2e12:	jmp    0xffffffffc00d4674
; __u32 ip_src = create_encap_ipv4_src(pckt->flow.port16[0], pckt->flow.src);
2e17:	mov    -0x48(%rbp),%edi
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
2e1a:	mov    %rdi,-0x80(%rbp)
2e1e:	mov    %rbx,%rdi
2e21:	mov    $0xffffffec,%esi
2e26:	call   0xffffffffbaa35c20
2e2b:	shl    $0x20,%rax
2e2f:	shr    $0x20,%rax
; if (XDP_ADJUST_HEAD_FUNC(xdp, 0 - (int)sizeof(struct iphdr))) {
2e33:	test   %rax,%rax
2e36:	jne    0xffffffffc00d3477
; data = (void*)(long)xdp->data;
2e3c:	mov    0x0(%rbx),%rdi
; data_end = (void*)(long)xdp->data_end;
2e40:	mov    0x8(%rbx),%rsi
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2e44:	mov    %rdi,%rdx
2e47:	add    $0xe,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2e4b:	cmp    %rsi,%rdx
2e4e:	ja     0xffffffffc00d3477
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2e54:	mov    %rdi,%rdx
2e57:	add    $0x22,%rdx
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2e5b:	cmp    %rsi,%rdx
2e5e:	ja     0xffffffffc00d3477
; if (new_eth + 1 > data_end || old_eth + 1 > data_end || iph + 1 > data_end) {
2e64:	cmp    %rsi,%rdx
2e67:	ja     0xffffffffc00d3477
2e6d:	mov    -0xb0(%rbp),%rbx
2e74:	bswap  %ebx
2e76:	mov    $0xffff0000,%esi
; 
2e7b:	and    %rsi,%rbx
2e7e:	mov    -0x80(%rbp),%rsi
2e82:	and    $0xffffffffffff0000,%rsi
2e89:	xor    %rsi,%rbx
2e8c:	mov    %rbx,%rsi
2e8f:	or     $0x10ac,%rsi
2e96:	mov    %rdi,%rdx
2e99:	add    $0x14,%rdx
; memcpy(new_eth->h_dest, cval->mac, 6);
2e9d:	movzbq 0x5(%r15),%rcx
2ea2:	mov    %cl,0x5(%rdi)
2ea5:	movzbq 0x4(%r15),%rcx
2eaa:	mov    %cl,0x4(%rdi)
2ead:	movzbq 0x3(%r15),%rcx
2eb2:	mov    %cl,0x3(%rdi)
2eb5:	movzbq 0x2(%r15),%rcx
2eba:	mov    %cl,0x2(%rdi)
2ebd:	movzbq 0x1(%r15),%rcx
2ec2:	mov    %cl,0x1(%rdi)
2ec5:	movzbq 0x0(%r15),%rcx
2eca:	mov    %cl,0x0(%rdi)
; memcpy(new_eth->h_source, old_eth->h_dest, 6);
2ecd:	movzbq 0x2(%rdx),%rcx
2ed2:	mov    %cl,0x8(%rdi)
2ed5:	movzbq 0x3(%rdx),%rcx
2eda:	mov    %cl,0x9(%rdi)
2edd:	movzbq 0x0(%rdx),%rcx
2ee2:	mov    %cl,0x6(%rdi)
2ee5:	movzbq 0x1(%rdx),%rcx
2eea:	mov    %cl,0x7(%rdi)
2eed:	movzbq 0x4(%rdx),%rcx
2ef2:	mov    %cl,0xa(%rdi)
2ef5:	movzbq 0x5(%rdx),%rdx
2efa:	mov    %dl,0xb(%rdi)
2efd:	mov    $0x8,%edx
; new_eth->h_proto = BE_ETH_P_IP;
2f02:	mov    %dl,0xc(%rdi)
2f05:	xor    %edx,%edx
2f07:	mov    %dl,0xd(%rdi)
; create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
2f0a:	mov    -0xa8(%rbp),%rcx
2f11:	mov    0x0(%rcx),%ecx
; create_v4_hdr(iph, pckt->tos, ip_src, dst->dst, pkt_bytes, IPPROTO_IPIP);
2f14:	movzbq -0x1b(%rbp),%r8
2f19:	mov    $0x45,%eax
; iph->ihl = 5;
2f1e:	mov    %al,0xe(%rdi)
; iph->tos = tos;
2f21:	mov    %r8b,0xf(%rdi)
; *csum += *next_iph_u16++;
2f25:	shl    $0x20,%rbx
2f29:	shr    $0x20,%rbx
2f2d:	shr    $0x10,%rbx
2f31:	mov    %rcx,%r8
2f34:	and    $0xffff,%r8
; *csum += *next_iph_u16++;
2f3b:	add    %r8,%rbx
; iph->id = 0;
2f3e:	mov    %edx,0x12(%rdi)
2f41:	mov    $0x440,%edx
; iph->ttl = DEFAULT_TTL;
2f46:	mov    %dx,0x16(%rdi)
; iph->saddr = saddr;
2f4a:	mov    %esi,0x1a(%rdi)
; iph->daddr = daddr;
2f4d:	mov    %ecx,0x1e(%rdi)
; *csum += *next_iph_u16++;
2f50:	shr    $0x10,%rcx
; *csum += *next_iph_u16++;
2f54:	add    %rcx,%rbx
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
2f57:	add    $0x14,%r13
2f5b:	ror    $0x8,%r13w
2f60:	movzwl %r13w,%r13d
; iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));
2f64:	mov    %r13w,0x10(%rdi)
; *csum += *next_iph_u16++;
2f69:	add    %r13,%rbx
; *csum += *next_iph_u16++;
2f6c:	movzwq 0xe(%rdi),%rsi
; *csum += *next_iph_u16++;
2f71:	add    %rsi,%rbx
; *csum += *next_iph_u16++;
2f74:	movzwq 0x16(%rdi),%rsi
; *csum += *next_iph_u16++;
2f79:	add    %rsi,%rbx
2f7c:	add    $0x10ac,%rbx
2f83:	mov    %rbx,%rdx
; if (csum >> 16)
2f86:	mov    %rbx,%rsi
2f89:	shr    $0x10,%rsi
; if (csum >> 16)
2f8d:	test   %rsi,%rsi
2f90:	je     0xffffffffc00d4f74
2f92:	and    $0xffff,%rdx
2f99:	add    %rsi,%rdx
; if (csum >> 16)
2f9c:	mov    %rdx,%rsi
2f9f:	shr    $0x10,%rsi
; if (csum >> 16)
2fa3:	test   %rsi,%rsi
2fa6:	je     0xffffffffc00d4f8a
2fa8:	and    $0xffff,%rdx
2faf:	add    %rsi,%rdx
; if (csum >> 16)
2fb2:	mov    %rdx,%rsi
2fb5:	shr    $0x10,%rsi
; if (csum >> 16)
2fb9:	test   %rsi,%rsi
2fbc:	je     0xffffffffc00d4252
2fc2:	jmp    0xffffffffc00d4248
2fc7:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
2fcc:	mov    %edi,-0x10(%rbp)
2fcf:	mov    %rbp,%rsi
; 
2fd2:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
2fd6:	movabs $0xffff888138844000,%rdi
2fe0:	add    $0x100,%rdi
2fe7:	mov    0x0(%rsi),%eax
2fea:	cmp    $0x400,%rax
2ff1:	jae    0xffffffffc00d4fe1
2ff3:	shl    $0x3,%rax
2ff7:	add    %rdi,%rax
2ffa:	mov    0x0(%rax),%rax
2ffe:	add    %gs:0xffffffffbe595028,%rax
3007:	jmp    0xffffffffc00d4fe3
3009:	xor    %eax,%eax
300b:	mov    %rax,%r15
; if (!conn_rate_stats) {
300e:	test   %r15,%r15
3011:	je     0xffffffffc00d5101
; *cur_time = bpf_ktime_get_ns();
3017:	call   0xffffffffb889d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
301c:	mov    0x8(%r15),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
3020:	mov    %rax,%rsi
3023:	sub    %rdi,%rsi
3026:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
302b:	cmp    %rsi,%rdi
302e:	ja     0xffffffffc00d50e7
; conn_rate_stats->v2 = *cur_time;
3034:	mov    %rax,0x8(%r15)
3038:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
303d:	mov    %rdi,0x0(%r15)
3041:	xor    %edi,%edi
; struct real_pos_lru new_dst_lru = {};
3043:	mov    %rdi,-0x10(%rbp)
; new_dst_lru.pos = pckt->real_index;
3047:	mov    -0x20(%rbp),%esi
; new_dst_lru.pos = pckt->real_index;
304a:	mov    %esi,-0x10(%rbp)
; struct real_pos_lru new_dst_lru = {};
304d:	mov    %rdi,-0x8(%rbp)
3051:	mov    %rbp,%rsi
3054:	add    $0xffffffffffffffb8,%rsi
3058:	mov    %rbp,%rdx
305b:	add    $0xfffffffffffffff0,%rdx
; bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
305f:	mov    -0x98(%rbp),%rdi
3066:	xor    %ecx,%ecx
3068:	call   0xffffffffb889c9c0
306d:	jmp    0xffffffffc00d5101
; dst_lru->pos = pckt->real_index;
3072:	mov    %edi,0x0(%rax)
; quic_packets_stats->dst_mismatch_in_lru += 1;
3075:	mov    0x58(%r14),%rdi
3079:	add    $0x1,%rdi
307d:	mov    %rdi,0x58(%r14)
; vip_num, /* new conn */ false, /* mismatch in lru */ true);
3081:	mov    -0x64(%rbp),%edi
3084:	mov    %edi,-0x10(%rbp)
3087:	mov    %rbp,%rsi
; dst_lru->pos = pckt->real_index;
308a:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&server_id_stats, &vip_num);
308e:	movabs $0xffff8881583d8000,%rdi
3098:	add    $0x100,%rdi
309f:	mov    0x0(%rsi),%eax
30a2:	cmp    $0x200,%rax
30a9:	jae    0xffffffffc00d5099
30ab:	shl    $0x3,%rax
30af:	add    %rdi,%rax
30b2:	mov    0x0(%rax),%rax
30b6:	add    %gs:0xffffffffbe595028,%rax
30bf:	jmp    0xffffffffc00d509b
30c1:	xor    %eax,%eax
; if (!per_vip_stats) {
30c3:	test   %rax,%rax
30c6:	je     0xffffffffc00d510d
; per_vip_stats->v2 += 1;
30c8:	mov    0x8(%rax),%rdi
30cc:	add    $0x1,%rdi
30d0:	mov    %rdi,0x8(%rax)
30d4:	jmp    0xffffffffc00d510d
30d6:	mov    %rbp,%rsi
; 
30d9:	add    $0xffffffffffffffb8,%rsi
; struct real_pos_lru* dst_lru = bpf_map_lookup_elem(lru_map, &pckt->flow);
30dd:	mov    -0x98(%rbp),%rdi
30e4:	call   0xffffffffb889c930
; if (dst_lru) {
30e9:	test   %rax,%rax
30ec:	je     0xffffffffc00d512a
; if (dst_lru->pos == pckt->real_index) {
30ee:	mov    0x0(%rax),%esi
; if (dst_lru->pos == pckt->real_index) {
30f1:	mov    -0x20(%rbp),%edi
; if (dst_lru->pos == pckt->real_index) {
30f4:	cmp    %rdi,%rsi
30f7:	je     0xffffffffc00d50d6
30f9:	jmp    0xffffffffc00d51d5
; quic_packets_stats->dst_match_in_lru += 1;
30fe:	mov    0x50(%r14),%rdi
3102:	add    $0x1,%rdi
3106:	mov    %rdi,0x50(%r14)
310a:	jmp    0xffffffffc00d525f
; conn_rate_stats->v1 += 1;
310f:	mov    0x0(%r15),%rdi
3113:	add    $0x1,%rdi
3117:	mov    %rdi,0x0(%r15)
311b:	mov    $0x1e849,%esi
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
3120:	cmp    %rdi,%rsi
3123:	ja     0xffffffffc00d5019
; quic_packets_stats->dst_not_found_in_lru += 1;
3129:	mov    0x60(%r14),%rdi
312d:	add    $0x1,%rdi
3131:	mov    %rdi,0x60(%r14)
; quic_packets_stats->cid_routed += 1;
3135:	mov    0x20(%r14),%rdi
3139:	add    $0x1,%rdi
313d:	mov    %rdi,0x20(%r14)
; original_sport = pckt.flow.port16[0];
3141:	movzwq -0x28(%rbp),%rdi
; if (!dst) {
3146:	mov    %rdi,-0xa8(%rbp)
314d:	jmp    0xffffffffc00d36d4
3152:	mov    $0x202,%edi
; __u32 conn_rate_key = MAX_VIPS + NEW_CONN_RATE_CNTR;
3157:	mov    %edi,-0x10(%rbp)
315a:	mov    %rbp,%rsi
; 
315d:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&stats, &conn_rate_key);
3161:	movabs $0xffff888138844000,%rdi
316b:	add    $0x100,%rdi
3172:	mov    0x0(%rsi),%eax
3175:	cmp    $0x400,%rax
317c:	jae    0xffffffffc00d516c
317e:	shl    $0x3,%rax
3182:	add    %rdi,%rax
3185:	mov    0x0(%rax),%rax
3189:	add    %gs:0xffffffffbe595028,%rax
3192:	jmp    0xffffffffc00d516e
3194:	xor    %eax,%eax
3196:	mov    %rax,%r15
; if (!conn_rate_stats) {
3199:	test   %r15,%r15
319c:	je     0xffffffffc00d5253
; *cur_time = bpf_ktime_get_ns();
31a2:	call   0xffffffffb889d630
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
31a7:	mov    0x8(%r15),%rdi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
31ab:	mov    %rax,%rsi
31ae:	sub    %rdi,%rsi
31b1:	mov    $0x3b9aca01,%edi
; if ((*cur_time - conn_rate_stats->v2) > ONE_SEC) {
31b6:	cmp    %rsi,%rdi
31b9:	ja     0xffffffffc00d5239
; conn_rate_stats->v2 = *cur_time;
31bf:	mov    %rax,0x8(%r15)
31c3:	mov    $0x1,%edi
; conn_rate_stats->v1 = 1;
31c8:	mov    %rdi,0x0(%r15)
31cc:	xor    %edi,%edi
; struct real_pos_lru new_dst_lru = {};
31ce:	mov    %rdi,-0x10(%rbp)
; new_dst_lru.pos = pckt->real_index;
31d2:	mov    -0x20(%rbp),%esi
; new_dst_lru.pos = pckt->real_index;
31d5:	mov    %esi,-0x10(%rbp)
; struct real_pos_lru new_dst_lru = {};
31d8:	mov    %rdi,-0x8(%rbp)
31dc:	mov    %rbp,%rsi
31df:	add    $0xffffffffffffffb8,%rsi
31e3:	mov    %rbp,%rdx
31e6:	add    $0xfffffffffffffff0,%rdx
; bpf_map_update_elem(lru_map, &pckt->flow, &new_dst_lru, BPF_ANY);
31ea:	mov    -0x98(%rbp),%rdi
31f1:	xor    %ecx,%ecx
31f3:	call   0xffffffffb889c9c0
31f8:	jmp    0xffffffffc00d5253
; dst_lru->pos = pckt->real_index;
31fd:	mov    %edi,0x0(%rax)
; quic_packets_stats->dst_mismatch_in_lru += 1;
3200:	mov    0x58(%r14),%rdi
3204:	add    $0x1,%rdi
3208:	mov    %rdi,0x58(%r14)
; vip_num, /* new conn */ false, /* mismatch in lru */ true);
320c:	mov    -0x64(%rbp),%edi
320f:	mov    %edi,-0x10(%rbp)
3212:	mov    %rbp,%rsi
; dst_lru->pos = pckt->real_index;
3215:	add    $0xfffffffffffffff0,%rsi
; bpf_map_lookup_elem(&server_id_stats, &vip_num);
3219:	movabs $0xffff8881583d8000,%rdi
3223:	add    $0x100,%rdi
322a:	mov    0x0(%rsi),%eax
322d:	cmp    $0x200,%rax
3234:	jae    0xffffffffc00d5224
3236:	shl    $0x3,%rax
323a:	add    %rdi,%rax
323d:	mov    0x0(%rax),%rax
3241:	add    %gs:0xffffffffbe595028,%rax
324a:	jmp    0xffffffffc00d5226
324c:	xor    %eax,%eax
; if (!per_vip_stats) {
324e:	test   %rax,%rax
3251:	je     0xffffffffc00d525f
; per_vip_stats->v2 += 1;
3253:	mov    0x8(%rax),%rdi
3257:	add    $0x1,%rdi
325b:	mov    %rdi,0x8(%rax)
325f:	jmp    0xffffffffc00d525f
; conn_rate_stats->v1 += 1;
3261:	mov    0x0(%r15),%rdi
3265:	add    $0x1,%rdi
3269:	mov    %rdi,0x0(%r15)
326d:	mov    $0x1e849,%esi
; if (conn_rate_stats->v1 > MAX_CONN_RATE) {
3272:	cmp    %rdi,%rsi
3275:	ja     0xffffffffc00d51a4
; quic_packets_stats->dst_not_found_in_lru += 1;
327b:	mov    0x60(%r14),%rdi
327f:	add    $0x1,%rdi
3283:	mov    %rdi,0x60(%r14)
; quic_packets_stats->cid_routed += 1;
3287:	mov    0x20(%r14),%rdi
328b:	add    $0x1,%rdi
328f:	mov    %rdi,0x20(%r14)
; original_sport = pckt.flow.port16[0];
3293:	movzwq -0x28(%rbp),%rdi
; if (!dst) {
3298:	mov    %rdi,-0xb0(%rbp)
329f:	jmp    0xffffffffc00d4674

